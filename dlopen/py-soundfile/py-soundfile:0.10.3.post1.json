{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-py-soundfile-0.10.3.post1-2vredvl2lxfwe72pnscuzav3y5hjpyqz/spack-src/soundfile.py": "\"\"\"SoundFile is an audio library based on libsndfile, CFFI and NumPy.\n\nSound files can be read or written directly using the functions\n:func:`read` and :func:`write`.\nTo read a sound file in a block-wise fashion, use :func:`blocks`.\nAlternatively, sound files can be opened as :class:`SoundFile` objects.\n\nFor further information, see http://pysoundfile.readthedocs.org/.\n\n\"\"\"\n__version__ = \"0.10.3\"\n\nimport os as _os\nimport sys as _sys\nfrom os import SEEK_SET, SEEK_CUR, SEEK_END\nfrom ctypes.util import find_library as _find_library\nfrom _soundfile import ffi as _ffi\n\ntry:\n    _unicode = unicode  # doesn't exist in Python 3.x\nexcept NameError:\n    _unicode = str\n\n\n_str_types = {\n    'title':       0x01,\n    'copyright':   0x02,\n    'software':    0x03,\n    'artist':      0x04,\n    'comment':     0x05,\n    'date':        0x06,\n    'album':       0x07,\n    'license':     0x08,\n    'tracknumber': 0x09,\n    'genre':       0x10,\n}\n\n_formats = {\n    'WAV':   0x010000,  # Microsoft WAV format (little endian default).\n    'AIFF':  0x020000,  # Apple/SGI AIFF format (big endian).\n    'AU':    0x030000,  # Sun/NeXT AU format (big endian).\n    'RAW':   0x040000,  # RAW PCM data.\n    'PAF':   0x050000,  # Ensoniq PARIS file format.\n    'SVX':   0x060000,  # Amiga IFF / SVX8 / SV16 format.\n    'NIST':  0x070000,  # Sphere NIST format.\n    'VOC':   0x080000,  # VOC files.\n    'IRCAM': 0x0A0000,  # Berkeley/IRCAM/CARL\n    'W64':   0x0B0000,  # Sonic Foundry's 64 bit RIFF/WAV\n    'MAT4':  0x0C0000,  # Matlab (tm) V4.2 / GNU Octave 2.0\n    'MAT5':  0x0D0000,  # Matlab (tm) V5.0 / GNU Octave 2.1\n    'PVF':   0x0E0000,  # Portable Voice Format\n    'XI':    0x0F0000,  # Fasttracker 2 Extended Instrument\n    'HTK':   0x100000,  # HMM Tool Kit format\n    'SDS':   0x110000,  # Midi Sample Dump Standard\n    'AVR':   0x120000,  # Audio Visual Research\n    'WAVEX': 0x130000,  # MS WAVE with WAVEFORMATEX\n    'SD2':   0x160000,  # Sound Designer 2\n    'FLAC':  0x170000,  # FLAC lossless file format\n    'CAF':   0x180000,  # Core Audio File format\n    'WVE':   0x190000,  # Psion WVE format\n    'OGG':   0x200000,  # Xiph OGG container\n    'MPC2K': 0x210000,  # Akai MPC 2000 sampler\n    'RF64':  0x220000,  # RF64 WAV file\n}\n\n_subtypes = {\n    'PCM_S8':    0x0001,  # Signed 8 bit data\n    'PCM_16':    0x0002,  # Signed 16 bit data\n    'PCM_24':    0x0003,  # Signed 24 bit data\n    'PCM_32':    0x0004,  # Signed 32 bit data\n    'PCM_U8':    0x0005,  # Unsigned 8 bit data (WAV and RAW only)\n    'FLOAT':     0x0006,  # 32 bit float data\n    'DOUBLE':    0x0007,  # 64 bit float data\n    'ULAW':      0x0010,  # U-Law encoded.\n    'ALAW':      0x0011,  # A-Law encoded.\n    'IMA_ADPCM': 0x0012,  # IMA ADPCM.\n    'MS_ADPCM':  0x0013,  # Microsoft ADPCM.\n    'GSM610':    0x0020,  # GSM 6.10 encoding.\n    'VOX_ADPCM': 0x0021,  # OKI / Dialogix ADPCM\n    'G721_32':   0x0030,  # 32kbs G721 ADPCM encoding.\n    'G723_24':   0x0031,  # 24kbs G723 ADPCM encoding.\n    'G723_40':   0x0032,  # 40kbs G723 ADPCM encoding.\n    'DWVW_12':   0x0040,  # 12 bit Delta Width Variable Word encoding.\n    'DWVW_16':   0x0041,  # 16 bit Delta Width Variable Word encoding.\n    'DWVW_24':   0x0042,  # 24 bit Delta Width Variable Word encoding.\n    'DWVW_N':    0x0043,  # N bit Delta Width Variable Word encoding.\n    'DPCM_8':    0x0050,  # 8 bit differential PCM (XI only)\n    'DPCM_16':   0x0051,  # 16 bit differential PCM (XI only)\n    'VORBIS':    0x0060,  # Xiph Vorbis encoding.\n    'ALAC_16':   0x0070,  # Apple Lossless Audio Codec (16 bit).\n    'ALAC_20':   0x0071,  # Apple Lossless Audio Codec (20 bit).\n    'ALAC_24':   0x0072,  # Apple Lossless Audio Codec (24 bit).\n    'ALAC_32':   0x0073,  # Apple Lossless Audio Codec (32 bit).\n}\n\n_endians = {\n    'FILE':   0x00000000,  # Default file endian-ness.\n    'LITTLE': 0x10000000,  # Force little endian-ness.\n    'BIG':    0x20000000,  # Force big endian-ness.\n    'CPU':    0x30000000,  # Force CPU endian-ness.\n}\n\n# libsndfile doesn't specify default subtypes, these are somehow arbitrary:\n_default_subtypes = {\n    'WAV':   'PCM_16',\n    'AIFF':  'PCM_16',\n    'AU':    'PCM_16',\n    # 'RAW':  # subtype must be explicit!\n    'PAF':   'PCM_16',\n    'SVX':   'PCM_16',\n    'NIST':  'PCM_16',\n    'VOC':   'PCM_16',\n    'IRCAM': 'PCM_16',\n    'W64':   'PCM_16',\n    'MAT4':  'DOUBLE',\n    'MAT5':  'DOUBLE',\n    'PVF':   'PCM_16',\n    'XI':    'DPCM_16',\n    'HTK':   'PCM_16',\n    'SDS':   'PCM_16',\n    'AVR':   'PCM_16',\n    'WAVEX': 'PCM_16',\n    'SD2':   'PCM_16',\n    'FLAC':  'PCM_16',\n    'CAF':   'PCM_16',\n    'WVE':   'ALAW',\n    'OGG':   'VORBIS',\n    'MPC2K': 'PCM_16',\n    'RF64':  'PCM_16',\n}\n\n_ffi_types = {\n    'float64': 'double',\n    'float32': 'float',\n    'int32': 'int',\n    'int16': 'short'\n}\n\ntry:\n    _libname = _find_library('sndfile')\n    if _libname is None:\n        raise OSError('sndfile library not found')\n    _snd = _ffi.dlopen(_libname)\nexcept OSError:\n    if _sys.platform == 'darwin':\n        _libname = 'libsndfile.dylib'\n    elif _sys.platform == 'win32':\n        from platform import architecture as _architecture\n        _libname = 'libsndfile' + _architecture()[0] + '.dll'\n    else:\n        raise\n\n    # hack for packaging tools like cx_Freeze, which\n    # compress all scripts into a zip file\n    # which causes __file__ to be inside this zip file\n\n    _path = _os.path.dirname(_os.path.abspath(__file__))\n\n    while not _os.path.isdir(_path):\n        _path = _os.path.abspath(_os.path.join(_path, '..'))\n\n    _snd = _ffi.dlopen(_os.path.join(\n        _path, '_soundfile_data', _libname))\n\n__libsndfile_version__ = _ffi.string(_snd.sf_version_string()).decode('utf-8', 'replace')\nif __libsndfile_version__.startswith('libsndfile-'):\n    __libsndfile_version__ = __libsndfile_version__[len('libsndfile-'):]\n\n\ndef read(file, frames=-1, start=0, stop=None, dtype='float64', always_2d=False,\n         fill_value=None, out=None, samplerate=None, channels=None,\n         format=None, subtype=None, endian=None, closefd=True):\n    \"\"\"Provide audio data from a sound file as NumPy array.\n\n    By default, the whole file is read from the beginning, but the\n    position to start reading can be specified with `start` and the\n    number of frames to read can be specified with `frames`.\n    Alternatively, a range can be specified with `start` and `stop`.\n\n    If there is less data left in the file than requested, the rest of\n    the frames are filled with `fill_value`.\n    If no `fill_value` is specified, a smaller array is returned.\n\n    Parameters\n    ----------\n    file : str or int or file-like object\n        The file to read from.  See :class:`SoundFile` for details.\n    frames : int, optional\n        The number of frames to read. If `frames` is negative, the whole\n        rest of the file is read.  Not allowed if `stop` is given.\n    start : int, optional\n        Where to start reading.  A negative value counts from the end.\n    stop : int, optional\n        The index after the last frame to be read.  A negative value\n        counts from the end.  Not allowed if `frames` is given.\n    dtype : {'float64', 'float32', 'int32', 'int16'}, optional\n        Data type of the returned array, by default ``'float64'``.\n        Floating point audio data is typically in the range from\n        ``-1.0`` to ``1.0``.  Integer data is in the range from\n        ``-2**15`` to ``2**15-1`` for ``'int16'`` and from ``-2**31`` to\n        ``2**31-1`` for ``'int32'``.\n\n        .. note:: Reading int values from a float file will *not*\n            scale the data to [-1.0, 1.0). If the file contains\n            ``np.array([42.6], dtype='float32')``, you will read\n            ``np.array([43], dtype='int32')`` for ``dtype='int32'``.\n\n    Returns\n    -------\n    audiodata : numpy.ndarray or type(out)\n        A two-dimensional (frames x channels) NumPy array is returned.\n        If the sound file has only one channel, a one-dimensional array\n        is returned.  Use ``always_2d=True`` to return a two-dimensional\n        array anyway.\n\n        If `out` was specified, it is returned.  If `out` has more\n        frames than available in the file (or if `frames` is smaller\n        than the length of `out`) and no `fill_value` is given, then\n        only a part of `out` is overwritten and a view containing all\n        valid frames is returned.\n    samplerate : int\n        The sample rate of the audio file.\n\n    Other Parameters\n    ----------------\n    always_2d : bool, optional\n        By default, reading a mono sound file will return a\n        one-dimensional array.  With ``always_2d=True``, audio data is\n        always returned as a two-dimensional array, even if the audio\n        file has only one channel.\n    fill_value : float, optional\n        If more frames are requested than available in the file, the\n        rest of the output is be filled with `fill_value`.  If\n        `fill_value` is not specified, a smaller array is returned.\n    out : numpy.ndarray or subclass, optional\n        If `out` is specified, the data is written into the given array\n        instead of creating a new array.  In this case, the arguments\n        `dtype` and `always_2d` are silently ignored!  If `frames` is\n        not given, it is obtained from the length of `out`.\n    samplerate, channels, format, subtype, endian, closefd\n        See :class:`SoundFile`.\n\n    Examples\n    --------\n    >>> import soundfile as sf\n    >>> data, samplerate = sf.read('stereo_file.wav')\n    >>> data\n    array([[ 0.71329652,  0.06294799],\n           [-0.26450912, -0.38874483],\n           ...\n           [ 0.67398441, -0.11516333]])\n    >>> samplerate\n    44100\n\n    \"\"\"\n    with SoundFile(file, 'r', samplerate, channels,\n                   subtype, endian, format, closefd) as f:\n        frames = f._prepare_read(start, stop, frames)\n        data = f.read(frames, dtype, always_2d, fill_value, out)\n    return data, f.samplerate\n\n\ndef write(file, data, samplerate, subtype=None, endian=None, format=None,\n          closefd=True):\n    \"\"\"Write data to a sound file.\n\n    .. note:: If `file` exists, it will be truncated and overwritten!\n\n    Parameters\n    ----------\n    file : str or int or file-like object\n        The file to write to.  See :class:`SoundFile` for details.\n    data : array_like\n        The data to write.  Usually two-dimensional (frames x channels),\n        but one-dimensional `data` can be used for mono files.\n        Only the data types ``'float64'``, ``'float32'``, ``'int32'``\n        and ``'int16'`` are supported.\n\n        .. note:: The data type of `data` does **not** select the data\n                  type of the written file. Audio data will be\n                  converted to the given `subtype`. Writing int values\n                  to a float file will *not* scale the values to\n                  [-1.0, 1.0). If you write the value ``np.array([42],\n                  dtype='int32')``, to a ``subtype='FLOAT'`` file, the\n                  file will then contain ``np.array([42.],\n                  dtype='float32')``.\n\n    samplerate : int\n        The sample rate of the audio data.\n    subtype : str, optional\n        See :func:`default_subtype` for the default value and\n        :func:`available_subtypes` for all possible values.\n\n    Other Parameters\n    ----------------\n    format, endian, closefd\n        See :class:`SoundFile`.\n\n    Examples\n    --------\n    Write 10 frames of random data to a new file:\n\n    >>> import numpy as np\n    >>> import soundfile as sf\n    >>> sf.write('stereo_file.wav', np.random.randn(10, 2), 44100, 'PCM_24')\n\n    \"\"\"\n    import numpy as np\n    data = np.asarray(data)\n    if data.ndim == 1:\n        channels = 1\n    else:\n        channels = data.shape[1]\n    with SoundFile(file, 'w', samplerate, channels,\n                   subtype, endian, format, closefd) as f:\n        f.write(data)\n\n\ndef blocks(file, blocksize=None, overlap=0, frames=-1, start=0, stop=None,\n           dtype='float64', always_2d=False, fill_value=None, out=None,\n           samplerate=None, channels=None,\n           format=None, subtype=None, endian=None, closefd=True):\n    \"\"\"Return a generator for block-wise reading.\n\n    By default, iteration starts at the beginning and stops at the end\n    of the file.  Use `start` to start at a later position and `frames`\n    or `stop` to stop earlier.\n\n    If you stop iterating over the generator before it's exhausted,\n    the sound file is not closed. This is normally not a problem\n    because the file is opened in read-only mode. To close the file\n    properly, the generator's ``close()`` method can be called.\n\n    Parameters\n    ----------\n    file : str or int or file-like object\n        The file to read from.  See :class:`SoundFile` for details.\n    blocksize : int\n        The number of frames to read per block.\n        Either this or `out` must be given.\n    overlap : int, optional\n        The number of frames to rewind between each block.\n\n    Yields\n    ------\n    numpy.ndarray or type(out)\n        Blocks of audio data.\n        If `out` was given, and the requested frames are not an integer\n        multiple of the length of `out`, and no `fill_value` was given,\n        the last block will be a smaller view into `out`.\n\n    Other Parameters\n    ----------------\n    frames, start, stop\n        See :func:`read`.\n    dtype : {'float64', 'float32', 'int32', 'int16'}, optional\n        See :func:`read`.\n    always_2d, fill_value, out\n        See :func:`read`.\n    samplerate, channels, format, subtype, endian, closefd\n        See :class:`SoundFile`.\n\n    Examples\n    --------\n    >>> import soundfile as sf\n    >>> for block in sf.blocks('stereo_file.wav', blocksize=1024):\n    >>>     pass  # do something with 'block'\n\n    \"\"\"\n    with SoundFile(file, 'r', samplerate, channels,\n                   subtype, endian, format, closefd) as f:\n        frames = f._prepare_read(start, stop, frames)\n        for block in f.blocks(blocksize, overlap, frames,\n                              dtype, always_2d, fill_value, out):\n            yield block\n\n\nclass _SoundFileInfo(object):\n    \"\"\"Information about a SoundFile\"\"\"\n\n    def __init__(self, file, verbose):\n        self.verbose = verbose\n        with SoundFile(file) as f:\n            self.name = f.name\n            self.samplerate = f.samplerate\n            self.channels = f.channels\n            self.frames = f.frames\n            self.duration = float(self.frames)/f.samplerate\n            self.format = f.format\n            self.subtype = f.subtype\n            self.endian = f.endian\n            self.format_info = f.format_info\n            self.subtype_info = f.subtype_info\n            self.sections = f.sections\n            self.extra_info = f.extra_info\n\n    @property\n    def _duration_str(self):\n        hours, rest = divmod(self.duration, 3600)\n        minutes, seconds = divmod(rest, 60)\n        if hours >= 1:\n            duration = \"{0:.0g}:{1:02.0g}:{2:05.3f} h\".format(hours, minutes, seconds)\n        elif minutes >= 1:\n            duration = \"{0:02.0g}:{1:05.3f} min\".format(minutes, seconds)\n        elif seconds <= 1:\n            duration = \"{0:d} samples\".format(self.frames)\n        else:\n            duration = \"{0:.3f} s\".format(seconds)\n        return duration\n\n    def __repr__(self):\n        info = \"\\n\".join(\n            [\"{0.name}\",\n             \"samplerate: {0.samplerate} Hz\",\n             \"channels: {0.channels}\",\n             \"duration: {0._duration_str}\",\n             \"format: {0.format_info} [{0.format}]\",\n             \"subtype: {0.subtype_info} [{0.subtype}]\"])\n        if self.verbose:\n            info += \"\\n\".join(\n                [\"\\nendian: {0.endian}\",\n                 \"sections: {0.sections}\",\n                 \"frames: {0.frames}\",\n                 'extra_info: \"\"\"',\n                 '    {1}\"\"\"'])\n        indented_extra_info = (\"\\n\"+\" \"*4).join(self.extra_info.split(\"\\n\"))\n        return info.format(self, indented_extra_info)\n\n\ndef info(file, verbose=False):\n    \"\"\"Returns an object with information about a SoundFile.\n\n    Parameters\n    ----------\n    verbose : bool\n        Whether to print additional information.\n    \"\"\"\n    return _SoundFileInfo(file, verbose)\n\n\ndef available_formats():\n    \"\"\"Return a dictionary of available major formats.\n\n    Examples\n    --------\n    >>> import soundfile as sf\n    >>> sf.available_formats()\n    {'FLAC': 'FLAC (FLAC Lossless Audio Codec)',\n     'OGG': 'OGG (OGG Container format)',\n     'WAV': 'WAV (Microsoft)',\n     'AIFF': 'AIFF (Apple/SGI)',\n     ...\n     'WAVEX': 'WAVEX (Microsoft)',\n     'RAW': 'RAW (header-less)',\n     'MAT5': 'MAT5 (GNU Octave 2.1 / Matlab 5.0)'}\n\n    \"\"\"\n    return dict(_available_formats_helper(_snd.SFC_GET_FORMAT_MAJOR_COUNT,\n                                          _snd.SFC_GET_FORMAT_MAJOR))\n\n\ndef available_subtypes(format=None):\n    \"\"\"Return a dictionary of available subtypes.\n\n    Parameters\n    ----------\n    format : str\n        If given, only compatible subtypes are returned.\n\n    Examples\n    --------\n    >>> import soundfile as sf\n    >>> sf.available_subtypes('FLAC')\n    {'PCM_24': 'Signed 24 bit PCM',\n     'PCM_16': 'Signed 16 bit PCM',\n     'PCM_S8': 'Signed 8 bit PCM'}\n\n    \"\"\"\n    subtypes = _available_formats_helper(_snd.SFC_GET_FORMAT_SUBTYPE_COUNT,\n                                         _snd.SFC_GET_FORMAT_SUBTYPE)\n    return dict((subtype, name) for subtype, name in subtypes\n                if format is None or check_format(format, subtype))\n\n\ndef check_format(format, subtype=None, endian=None):\n    \"\"\"Check if the combination of format/subtype/endian is valid.\n\n    Examples\n    --------\n    >>> import soundfile as sf\n    >>> sf.check_format('WAV', 'PCM_24')\n    True\n    >>> sf.check_format('FLAC', 'VORBIS')\n    False\n\n    \"\"\"\n    try:\n        return bool(_format_int(format, subtype, endian))\n    except (ValueError, TypeError):\n        return False\n\n\ndef default_subtype(format):\n    \"\"\"Return the default subtype for a given format.\n\n    Examples\n    --------\n    >>> import soundfile as sf\n    >>> sf.default_subtype('WAV')\n    'PCM_16'\n    >>> sf.default_subtype('MAT5')\n    'DOUBLE'\n\n    \"\"\"\n    _check_format(format)\n    return _default_subtypes.get(format.upper())\n\n\nclass SoundFile(object):\n    \"\"\"A sound file.\n\n    For more documentation see the __init__() docstring (which is also\n    used for the online documentation (http://pysoundfile.readthedocs.org/).\n\n    \"\"\"\n\n    def __init__(self, file, mode='r', samplerate=None, channels=None,\n                 subtype=None, endian=None, format=None, closefd=True):\n        \"\"\"Open a sound file.\n\n        If a file is opened with `mode` ``'r'`` (the default) or\n        ``'r+'``, no sample rate, channels or file format need to be\n        given because the information is obtained from the file. An\n        exception is the ``'RAW'`` data format, which always requires\n        these data points.\n\n        File formats consist of three case-insensitive strings:\n\n        * a *major format* which is by default obtained from the\n          extension of the file name (if known) and which can be\n          forced with the format argument (e.g. ``format='WAVEX'``).\n        * a *subtype*, e.g. ``'PCM_24'``. Most major formats have a\n          default subtype which is used if no subtype is specified.\n        * an *endian-ness*, which doesn't have to be specified at all in\n          most cases.\n\n        A :class:`SoundFile` object is a *context manager*, which means\n        if used in a \"with\" statement, :meth:`.close` is automatically\n        called when reaching the end of the code block inside the \"with\"\n        statement.\n\n        Parameters\n        ----------\n        file : str or int or file-like object\n            The file to open.  This can be a file name, a file\n            descriptor or a Python file object (or a similar object with\n            the methods ``read()``/``readinto()``, ``write()``,\n            ``seek()`` and ``tell()``).\n        mode : {'r', 'r+', 'w', 'w+', 'x', 'x+'}, optional\n            Open mode.  Has to begin with one of these three characters:\n            ``'r'`` for reading, ``'w'`` for writing (truncates `file`)\n            or ``'x'`` for writing (raises an error if `file` already\n            exists).  Additionally, it may contain ``'+'`` to open\n            `file` for both reading and writing.\n            The character ``'b'`` for *binary mode* is implied because\n            all sound files have to be opened in this mode.\n            If `file` is a file descriptor or a file-like object,\n            ``'w'`` doesn't truncate and ``'x'`` doesn't raise an error.\n        samplerate : int\n            The sample rate of the file.  If `mode` contains ``'r'``,\n            this is obtained from the file (except for ``'RAW'`` files).\n        channels : int\n            The number of channels of the file.\n            If `mode` contains ``'r'``, this is obtained from the file\n            (except for ``'RAW'`` files).\n        subtype : str, sometimes optional\n            The subtype of the sound file.  If `mode` contains ``'r'``,\n            this is obtained from the file (except for ``'RAW'``\n            files), if not, the default value depends on the selected\n            `format` (see :func:`default_subtype`).\n            See :func:`available_subtypes` for all possible subtypes for\n            a given `format`.\n        endian : {'FILE', 'LITTLE', 'BIG', 'CPU'}, sometimes optional\n            The endian-ness of the sound file.  If `mode` contains\n            ``'r'``, this is obtained from the file (except for\n            ``'RAW'`` files), if not, the default value is ``'FILE'``,\n            which is correct in most cases.\n        format : str, sometimes optional\n            The major format of the sound file.  If `mode` contains\n            ``'r'``, this is obtained from the file (except for\n            ``'RAW'`` files), if not, the default value is determined\n            from the file extension.  See :func:`available_formats` for\n            all possible values.\n        closefd : bool, optional\n            Whether to close the file descriptor on :meth:`.close`. Only\n            applicable if the `file` argument is a file descriptor.\n\n        Examples\n        --------\n        >>> from soundfile import SoundFile\n\n        Open an existing file for reading:\n\n        >>> myfile = SoundFile('existing_file.wav')\n        >>> # do something with myfile\n        >>> myfile.close()\n\n        Create a new sound file for reading and writing using a with\n        statement:\n\n        >>> with SoundFile('new_file.wav', 'x+', 44100, 2) as myfile:\n        >>>     # do something with myfile\n        >>>     # ...\n        >>>     assert not myfile.closed\n        >>>     # myfile.close() is called automatically at the end\n        >>> assert myfile.closed\n\n        \"\"\"\n        # resolve PathLike objects (see PEP519 for details):\n        # can be replaced with _os.fspath(file) for Python >= 3.6\n        file = file.__fspath__() if hasattr(file, '__fspath__') else file\n        self._name = file\n        if mode is None:\n            mode = getattr(file, 'mode', None)\n        mode_int = _check_mode(mode)\n        self._mode = mode\n        self._info = _create_info_struct(file, mode, samplerate, channels,\n                                         format, subtype, endian)\n        self._file = self._open(file, mode_int, closefd)\n        if set(mode).issuperset('r+') and self.seekable():\n            # Move write position to 0 (like in Python file objects)\n            self.seek(0)\n        _snd.sf_command(self._file, _snd.SFC_SET_CLIPPING, _ffi.NULL,\n                        _snd.SF_TRUE)\n\n    name = property(lambda self: self._name)\n    \"\"\"The file name of the sound file.\"\"\"\n    mode = property(lambda self: self._mode)\n    \"\"\"The open mode the sound file was opened with.\"\"\"\n    samplerate = property(lambda self: self._info.samplerate)\n    \"\"\"The sample rate of the sound file.\"\"\"\n    frames = property(lambda self: self._info.frames)\n    \"\"\"The number of frames in the sound file.\"\"\"\n    channels = property(lambda self: self._info.channels)\n    \"\"\"The number of channels in the sound file.\"\"\"\n    format = property(\n        lambda self: _format_str(self._info.format & _snd.SF_FORMAT_TYPEMASK))\n    \"\"\"The major format of the sound file.\"\"\"\n    subtype = property(\n        lambda self: _format_str(self._info.format & _snd.SF_FORMAT_SUBMASK))\n    \"\"\"The subtype of data in the the sound file.\"\"\"\n    endian = property(\n        lambda self: _format_str(self._info.format & _snd.SF_FORMAT_ENDMASK))\n    \"\"\"The endian-ness of the data in the sound file.\"\"\"\n    format_info = property(\n        lambda self: _format_info(self._info.format &\n                                  _snd.SF_FORMAT_TYPEMASK)[1])\n    \"\"\"A description of the major format of the sound file.\"\"\"\n    subtype_info = property(\n        lambda self: _format_info(self._info.format &\n                                  _snd.SF_FORMAT_SUBMASK)[1])\n    \"\"\"A description of the subtype of the sound file.\"\"\"\n    sections = property(lambda self: self._info.sections)\n    \"\"\"The number of sections of the sound file.\"\"\"\n    closed = property(lambda self: self._file is None)\n    \"\"\"Whether the sound file is closed or not.\"\"\"\n    _errorcode = property(lambda self: _snd.sf_error(self._file))\n    \"\"\"A pending sndfile error code.\"\"\"\n\n    @property\n    def extra_info(self):\n        \"\"\"Retrieve the log string generated when opening the file.\"\"\"\n        info = _ffi.new(\"char[]\", 2**14)\n        _snd.sf_command(self._file, _snd.SFC_GET_LOG_INFO,\n                        info, _ffi.sizeof(info))\n        return _ffi.string(info).decode('utf-8', 'replace')\n\n    # avoid confusion if something goes wrong before assigning self._file:\n    _file = None\n\n    def __repr__(self):\n        return (\"SoundFile({0.name!r}, mode={0.mode!r}, \"\n                \"samplerate={0.samplerate}, channels={0.channels}, \"\n                \"format={0.format!r}, subtype={0.subtype!r}, \"\n                \"endian={0.endian!r})\".format(self))\n\n    def __del__(self):\n        self.close()\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, *args):\n        self.close()\n\n    def __setattr__(self, name, value):\n        \"\"\"Write text meta-data in the sound file through properties.\"\"\"\n        if name in _str_types:\n            self._check_if_closed()\n            err = _snd.sf_set_string(self._file, _str_types[name],\n                                     value.encode())\n            _error_check(err)\n        else:\n            object.__setattr__(self, name, value)\n\n    def __getattr__(self, name):\n        \"\"\"Read text meta-data in the sound file through properties.\"\"\"\n        if name in _str_types:\n            self._check_if_closed()\n            data = _snd.sf_get_string(self._file, _str_types[name])\n            return _ffi.string(data).decode('utf-8', 'replace') if data else \"\"\n        else:\n            raise AttributeError(\n                \"'SoundFile' object has no attribute {0!r}\".format(name))\n\n    def __len__(self):\n        # Note: This is deprecated and will be removed at some point,\n        # see https://github.com/bastibe/SoundFile/issues/199\n        return self._info.frames\n\n    def __bool__(self):\n        # Note: This is temporary until __len__ is removed, afterwards it\n        # can (and should) be removed without change of behavior\n        return True\n\n    def __nonzero__(self):\n        # Note: This is only for compatibility with Python 2 and it shall be\n        # removed at the same time as __bool__().\n        return self.__bool__()\n\n    def seekable(self):\n        \"\"\"Return True if the file supports seeking.\"\"\"\n        return self._info.seekable == _snd.SF_TRUE\n\n    def seek(self, frames, whence=SEEK_SET):\n        \"\"\"Set the read/write position.\n\n        Parameters\n        ----------\n        frames : int\n            The frame index or offset to seek.\n        whence : {SEEK_SET, SEEK_CUR, SEEK_END}, optional\n            By default (``whence=SEEK_SET``), `frames` are counted from\n            the beginning of the file.\n            ``whence=SEEK_CUR`` seeks from the current position\n            (positive and negative values are allowed for `frames`).\n            ``whence=SEEK_END`` seeks from the end (use negative value\n            for `frames`).\n\n        Returns\n        -------\n        int\n            The new absolute read/write position in frames.\n\n        Examples\n        --------\n        >>> from soundfile import SoundFile, SEEK_END\n        >>> myfile = SoundFile('stereo_file.wav')\n\n        Seek to the beginning of the file:\n\n        >>> myfile.seek(0)\n        0\n\n        Seek to the end of the file:\n\n        >>> myfile.seek(0, SEEK_END)\n        44100  # this is the file length\n\n        \"\"\"\n        self._check_if_closed()\n        position = _snd.sf_seek(self._file, frames, whence)\n        _error_check(self._errorcode)\n        return position\n\n    def tell(self):\n        \"\"\"Return the current read/write position.\"\"\"\n        return self.seek(0, SEEK_CUR)\n\n    def read(self, frames=-1, dtype='float64', always_2d=False,\n             fill_value=None, out=None):\n        \"\"\"Read from the file and return data as NumPy array.\n\n        Reads the given number of frames in the given data format\n        starting at the current read/write position.  This advances the\n        read/write position by the same number of frames.\n        By default, all frames from the current read/write position to\n        the end of the file are returned.\n        Use :meth:`.seek` to move the current read/write position.\n\n        Parameters\n        ----------\n        frames : int, optional\n            The number of frames to read. If ``frames < 0``, the whole\n            rest of the file is read.\n        dtype : {'float64', 'float32', 'int32', 'int16'}, optional\n            Data type of the returned array, by default ``'float64'``.\n            Floating point audio data is typically in the range from\n            ``-1.0`` to ``1.0``. Integer data is in the range from\n            ``-2**15`` to ``2**15-1`` for ``'int16'`` and from\n            ``-2**31`` to ``2**31-1`` for ``'int32'``.\n\n            .. note:: Reading int values from a float file will *not*\n                scale the data to [-1.0, 1.0). If the file contains\n                ``np.array([42.6], dtype='float32')``, you will read\n                ``np.array([43], dtype='int32')`` for\n                ``dtype='int32'``.\n\n        Returns\n        -------\n        audiodata : numpy.ndarray or type(out)\n            A two-dimensional NumPy (frames x channels) array is\n            returned. If the sound file has only one channel, a\n            one-dimensional array is returned. Use ``always_2d=True``\n            to return a two-dimensional array anyway.\n\n            If `out` was specified, it is returned. If `out` has more\n            frames than available in the file (or if `frames` is\n            smaller than the length of `out`) and no `fill_value` is\n            given, then only a part of `out` is overwritten and a view\n            containing all valid frames is returned. numpy.ndarray or\n            type(out)\n\n        Other Parameters\n        ----------------\n        always_2d : bool, optional\n            By default, reading a mono sound file will return a\n            one-dimensional array. With ``always_2d=True``, audio data\n            is always returned as a two-dimensional array, even if the\n            audio file has only one channel.\n        fill_value : float, optional\n            If more frames are requested than available in the file,\n            the rest of the output is be filled with `fill_value`. If\n            `fill_value` is not specified, a smaller array is\n            returned.\n        out : numpy.ndarray or subclass, optional\n            If `out` is specified, the data is written into the given\n            array instead of creating a new array. In this case, the\n            arguments `dtype` and `always_2d` are silently ignored! If\n            `frames` is not given, it is obtained from the length of\n            `out`.\n\n        Examples\n        --------\n        >>> from soundfile import SoundFile\n        >>> myfile = SoundFile('stereo_file.wav')\n\n        Reading 3 frames from a stereo file:\n\n        >>> myfile.read(3)\n        array([[ 0.71329652,  0.06294799],\n               [-0.26450912, -0.38874483],\n               [ 0.67398441, -0.11516333]])\n        >>> myfile.close()\n\n        See Also\n        --------\n        buffer_read, .write\n\n        \"\"\"\n        if out is None:\n            frames = self._check_frames(frames, fill_value)\n            out = self._create_empty_array(frames, always_2d, dtype)\n        else:\n            if frames < 0 or frames > len(out):\n                frames = len(out)\n        frames = self._array_io('read', out, frames)\n        if len(out) > frames:\n            if fill_value is None:\n                out = out[:frames]\n            else:\n                out[frames:] = fill_value\n        return out\n\n    def buffer_read(self, frames=-1, dtype=None):\n        \"\"\"Read from the file and return data as buffer object.\n\n        Reads the given number of `frames` in the given data format\n        starting at the current read/write position.  This advances the\n        read/write position by the same number of frames.\n        By default, all frames from the current read/write position to\n        the end of the file are returned.\n        Use :meth:`.seek` to move the current read/write position.\n\n        Parameters\n        ----------\n        frames : int, optional\n            The number of frames to read. If `frames < 0`, the whole\n            rest of the file is read.\n        dtype : {'float64', 'float32', 'int32', 'int16'}\n            Audio data will be converted to the given data type.\n\n        Returns\n        -------\n        buffer\n            A buffer containing the read data.\n\n        See Also\n        --------\n        buffer_read_into, .read, buffer_write\n\n        \"\"\"\n        frames = self._check_frames(frames, fill_value=None)\n        ctype = self._check_dtype(dtype)\n        cdata = _ffi.new(ctype + '[]', frames * self.channels)\n        read_frames = self._cdata_io('read', cdata, ctype, frames)\n        assert read_frames == frames\n        return _ffi.buffer(cdata)\n\n    def buffer_read_into(self, buffer, dtype):\n        \"\"\"Read from the file into a given buffer object.\n\n        Fills the given `buffer` with frames in the given data format\n        starting at the current read/write position (which can be\n        changed with :meth:`.seek`) until the buffer is full or the end\n        of the file is reached.  This advances the read/write position\n        by the number of frames that were read.\n\n        Parameters\n        ----------\n        buffer : writable buffer\n            Audio frames from the file are written to this buffer.\n        dtype : {'float64', 'float32', 'int32', 'int16'}\n            The data type of `buffer`.\n\n        Returns\n        -------\n        int\n            The number of frames that were read from the file.\n            This can be less than the size of `buffer`.\n            The rest of the buffer is not filled with meaningful data.\n\n        See Also\n        --------\n        buffer_read, .read\n\n        \"\"\"\n        ctype = self._check_dtype(dtype)\n        cdata, frames = self._check_buffer(buffer, ctype)\n        frames = self._cdata_io('read', cdata, ctype, frames)\n        return frames\n\n    def write(self, data):\n        \"\"\"Write audio data from a NumPy array to the file.\n\n        Writes a number of frames at the read/write position to the\n        file. This also advances the read/write position by the same\n        number of frames and enlarges the file if necessary.\n\n        Note that writing int values to a float file will *not* scale\n        the values to [-1.0, 1.0). If you write the value\n        ``np.array([42], dtype='int32')``, to a ``subtype='FLOAT'``\n        file, the file will then contain ``np.array([42.],\n        dtype='float32')``.\n\n        Parameters\n        ----------\n        data : array_like\n            The data to write. Usually two-dimensional (frames x\n            channels), but one-dimensional `data` can be used for mono\n            files. Only the data types ``'float64'``, ``'float32'``,\n            ``'int32'`` and ``'int16'`` are supported.\n\n            .. note:: The data type of `data` does **not** select the\n                  data type of the written file. Audio data will be\n                  converted to the given `subtype`. Writing int values\n                  to a float file will *not* scale the values to\n                  [-1.0, 1.0). If you write the value ``np.array([42],\n                  dtype='int32')``, to a ``subtype='FLOAT'`` file, the\n                  file will then contain ``np.array([42.],\n                  dtype='float32')``.\n\n        Examples\n        --------\n        >>> import numpy as np\n        >>> from soundfile import SoundFile\n        >>> myfile = SoundFile('stereo_file.wav')\n\n        Write 10 frames of random data to a new file:\n\n        >>> with SoundFile('stereo_file.wav', 'w', 44100, 2, 'PCM_24') as f:\n        >>>     f.write(np.random.randn(10, 2))\n\n        See Also\n        --------\n        buffer_write, .read\n\n        \"\"\"\n        import numpy as np\n        # no copy is made if data has already the correct memory layout:\n        data = np.ascontiguousarray(data)\n        written = self._array_io('write', data, len(data))\n        assert written == len(data)\n        self._update_frames(written)\n\n    def buffer_write(self, data, dtype):\n        \"\"\"Write audio data from a buffer/bytes object to the file.\n\n        Writes the contents of `data` to the file at the current\n        read/write position.\n        This also advances the read/write position by the number of\n        frames that were written and enlarges the file if necessary.\n\n        Parameters\n        ----------\n        data : buffer or bytes\n            A buffer or bytes object containing the audio data to be\n            written.\n        dtype : {'float64', 'float32', 'int32', 'int16'}\n            The data type of the audio data stored in `data`.\n\n        See Also\n        --------\n        .write, buffer_read\n\n        \"\"\"\n        ctype = self._check_dtype(dtype)\n        cdata, frames = self._check_buffer(data, ctype)\n        written = self._cdata_io('write', cdata, ctype, frames)\n        assert written == frames\n        self._update_frames(written)\n\n    def blocks(self, blocksize=None, overlap=0, frames=-1, dtype='float64',\n               always_2d=False, fill_value=None, out=None):\n        \"\"\"Return a generator for block-wise reading.\n\n        By default, the generator yields blocks of the given\n        `blocksize` (using a given `overlap`) until the end of the file\n        is reached; `frames` can be used to stop earlier.\n\n        Parameters\n        ----------\n        blocksize : int\n            The number of frames to read per block. Either this or `out`\n            must be given.\n        overlap : int, optional\n            The number of frames to rewind between each block.\n        frames : int, optional\n            The number of frames to read.\n            If ``frames < 0``, the file is read until the end.\n        dtype : {'float64', 'float32', 'int32', 'int16'}, optional\n            See :meth:`.read`.\n\n        Yields\n        ------\n        numpy.ndarray or type(out)\n            Blocks of audio data.\n            If `out` was given, and the requested frames are not an\n            integer multiple of the length of `out`, and no\n            `fill_value` was given, the last block will be a smaller\n            view into `out`.\n\n\n        Other Parameters\n        ----------------\n        always_2d, fill_value, out\n            See :meth:`.read`.\n        fill_value : float, optional\n            See :meth:`.read`.\n        out : numpy.ndarray or subclass, optional\n            If `out` is specified, the data is written into the given\n            array instead of creating a new array. In this case, the\n            arguments `dtype` and `always_2d` are silently ignored!\n\n        Examples\n        --------\n        >>> from soundfile import SoundFile\n        >>> with SoundFile('stereo_file.wav') as f:\n        >>>     for block in f.blocks(blocksize=1024):\n        >>>         pass  # do something with 'block'\n\n        \"\"\"\n        import numpy as np\n\n        if 'r' not in self.mode and '+' not in self.mode:\n            raise RuntimeError(\"blocks() is not allowed in write-only mode\")\n\n        if out is None:\n            if blocksize is None:\n                raise TypeError(\"One of {blocksize, out} must be specified\")\n            out = self._create_empty_array(blocksize, always_2d, dtype)\n            copy_out = True\n        else:\n            if blocksize is not None:\n                raise TypeError(\n                    \"Only one of {blocksize, out} may be specified\")\n            blocksize = len(out)\n            copy_out = False\n\n        overlap_memory = None\n        frames = self._check_frames(frames, fill_value)\n        while frames > 0:\n            if overlap_memory is None:\n                output_offset = 0\n            else:\n                output_offset = len(overlap_memory)\n                out[:output_offset] = overlap_memory\n\n            toread = min(blocksize - output_offset, frames)\n            self.read(toread, dtype, always_2d, fill_value, out[output_offset:])\n\n            if overlap:\n                if overlap_memory is None:\n                    overlap_memory = np.copy(out[-overlap:])\n                else:\n                    overlap_memory[:] = out[-overlap:]\n\n            if blocksize > frames + overlap and fill_value is None:\n                block = out[:frames + overlap]\n            else:\n                block = out\n            yield np.copy(block) if copy_out else block\n            frames -= toread\n\n    def truncate(self, frames=None):\n        \"\"\"Truncate the file to a given number of frames.\n\n        After this command, the read/write position will be at the new\n        end of the file.\n\n        Parameters\n        ----------\n        frames : int, optional\n            Only the data before `frames` is kept, the rest is deleted.\n            If not specified, the current read/write position is used.\n\n        \"\"\"\n        if frames is None:\n            frames = self.tell()\n        err = _snd.sf_command(self._file, _snd.SFC_FILE_TRUNCATE,\n                              _ffi.new(\"sf_count_t*\", frames),\n                              _ffi.sizeof(\"sf_count_t\"))\n        if err:\n            raise RuntimeError(\"Error truncating the file\")\n        self._info.frames = frames\n\n    def flush(self):\n        \"\"\"Write unwritten data to the file system.\n\n        Data written with :meth:`.write` is not immediately written to\n        the file system but buffered in memory to be written at a later\n        time.  Calling :meth:`.flush` makes sure that all changes are\n        actually written to the file system.\n\n        This has no effect on files opened in read-only mode.\n\n        \"\"\"\n        self._check_if_closed()\n        _snd.sf_write_sync(self._file)\n\n    def close(self):\n        \"\"\"Close the file.  Can be called multiple times.\"\"\"\n        if not self.closed:\n            # be sure to flush data to disk before closing the file\n            self.flush()\n            err = _snd.sf_close(self._file)\n            self._file = None\n            _error_check(err)\n\n    def _open(self, file, mode_int, closefd):\n        \"\"\"Call the appropriate sf_open*() function from libsndfile.\"\"\"\n        if isinstance(file, (_unicode, bytes)):\n            if _os.path.isfile(file):\n                if 'x' in self.mode:\n                    raise OSError(\"File exists: {0!r}\".format(self.name))\n                elif set(self.mode).issuperset('w+'):\n                    # truncate the file, because SFM_RDWR doesn't:\n                    _os.close(_os.open(file, _os.O_WRONLY | _os.O_TRUNC))\n            openfunction = _snd.sf_open\n            if isinstance(file, _unicode):\n                if _sys.platform == 'win32':\n                    openfunction = _snd.sf_wchar_open\n                else:\n                    file = file.encode(_sys.getfilesystemencoding())\n            file_ptr = openfunction(file, mode_int, self._info)\n        elif isinstance(file, int):\n            file_ptr = _snd.sf_open_fd(file, mode_int, self._info, closefd)\n        elif _has_virtual_io_attrs(file, mode_int):\n            file_ptr = _snd.sf_open_virtual(self._init_virtual_io(file),\n                                            mode_int, self._info, _ffi.NULL)\n        else:\n            raise TypeError(\"Invalid file: {0!r}\".format(self.name))\n        _error_check(_snd.sf_error(file_ptr),\n                     \"Error opening {0!r}: \".format(self.name))\n        if mode_int == _snd.SFM_WRITE:\n            # Due to a bug in libsndfile version <= 1.0.25, frames != 0\n            # when opening a named pipe in SFM_WRITE mode.\n            # See http://github.com/erikd/libsndfile/issues/77.\n            self._info.frames = 0\n            # This is not necessary for \"normal\" files (because\n            # frames == 0 in this case), but it doesn't hurt, either.\n        return file_ptr\n\n    def _init_virtual_io(self, file):\n        \"\"\"Initialize callback functions for sf_open_virtual().\"\"\"\n        @_ffi.callback(\"sf_vio_get_filelen\")\n        def vio_get_filelen(user_data):\n            curr = file.tell()\n            file.seek(0, SEEK_END)\n            size = file.tell()\n            file.seek(curr, SEEK_SET)\n            return size\n\n        @_ffi.callback(\"sf_vio_seek\")\n        def vio_seek(offset, whence, user_data):\n            file.seek(offset, whence)\n            return file.tell()\n\n        @_ffi.callback(\"sf_vio_read\")\n        def vio_read(ptr, count, user_data):\n            # first try readinto(), if not available fall back to read()\n            try:\n                buf = _ffi.buffer(ptr, count)\n                data_read = file.readinto(buf)\n            except AttributeError:\n                data = file.read(count)\n                data_read = len(data)\n                buf = _ffi.buffer(ptr, data_read)\n                buf[0:data_read] = data\n            return data_read\n\n        @_ffi.callback(\"sf_vio_write\")\n        def vio_write(ptr, count, user_data):\n            buf = _ffi.buffer(ptr, count)\n            data = buf[:]\n            written = file.write(data)\n            # write() returns None for file objects in Python <= 2.7:\n            if written is None:\n                written = count\n            return written\n\n        @_ffi.callback(\"sf_vio_tell\")\n        def vio_tell(user_data):\n            return file.tell()\n\n        # Note: the callback functions must be kept alive!\n        self._virtual_io = {'get_filelen': vio_get_filelen,\n                            'seek': vio_seek,\n                            'read': vio_read,\n                            'write': vio_write,\n                            'tell': vio_tell}\n\n        return _ffi.new(\"SF_VIRTUAL_IO*\", self._virtual_io)\n\n    def _getAttributeNames(self):\n        \"\"\"Return all attributes used in __setattr__ and __getattr__.\n\n        This is useful for auto-completion (e.g. IPython).\n\n        \"\"\"\n        return _str_types\n\n    def _check_if_closed(self):\n        \"\"\"Check if the file is closed and raise an error if it is.\n\n        This should be used in every method that uses self._file.\n\n        \"\"\"\n        if self.closed:\n            raise RuntimeError(\"I/O operation on closed file\")\n\n    def _check_frames(self, frames, fill_value):\n        \"\"\"Reduce frames to no more than are available in the file.\"\"\"\n        if self.seekable():\n            remaining_frames = self.frames - self.tell()\n            if frames < 0 or (frames > remaining_frames and\n                              fill_value is None):\n                frames = remaining_frames\n        elif frames < 0:\n            raise ValueError(\"frames must be specified for non-seekable files\")\n        return frames\n\n    def _check_buffer(self, data, ctype):\n        \"\"\"Convert buffer to cdata and check for valid size.\"\"\"\n        assert ctype in _ffi_types.values()\n        if not isinstance(data, bytes):\n            data = _ffi.from_buffer(data)\n        frames, remainder = divmod(len(data),\n                                   self.channels * _ffi.sizeof(ctype))\n        if remainder:\n            raise ValueError(\"Data size must be a multiple of frame size\")\n        return data, frames\n\n    def _create_empty_array(self, frames, always_2d, dtype):\n        \"\"\"Create an empty array with appropriate shape.\"\"\"\n        import numpy as np\n        if always_2d or self.channels > 1:\n            shape = frames, self.channels\n        else:\n            shape = frames,\n        return np.empty(shape, dtype, order='C')\n\n    def _check_dtype(self, dtype):\n        \"\"\"Check if dtype string is valid and return ctype string.\"\"\"\n        try:\n            return _ffi_types[dtype]\n        except KeyError:\n            raise ValueError(\"dtype must be one of {0!r} and not {1!r}\".format(\n                sorted(_ffi_types.keys()), dtype))\n\n    def _array_io(self, action, array, frames):\n        \"\"\"Check array and call low-level IO function.\"\"\"\n        if (array.ndim not in (1, 2) or\n                array.ndim == 1 and self.channels != 1 or\n                array.ndim == 2 and array.shape[1] != self.channels):\n            raise ValueError(\"Invalid shape: {0!r}\".format(array.shape))\n        if not array.flags.c_contiguous:\n            raise ValueError(\"Data must be C-contiguous\")\n        ctype = self._check_dtype(array.dtype.name)\n        assert array.dtype.itemsize == _ffi.sizeof(ctype)\n        cdata = _ffi.cast(ctype + '*', array.__array_interface__['data'][0])\n        return self._cdata_io(action, cdata, ctype, frames)\n\n    def _cdata_io(self, action, data, ctype, frames):\n        \"\"\"Call one of libsndfile's read/write functions.\"\"\"\n        assert ctype in _ffi_types.values()\n        self._check_if_closed()\n        if self.seekable():\n            curr = self.tell()\n        func = getattr(_snd, 'sf_' + action + 'f_' + ctype)\n        frames = func(self._file, data, frames)\n        _error_check(self._errorcode)\n        if self.seekable():\n            self.seek(curr + frames, SEEK_SET)  # Update read & write position\n        return frames\n\n    def _update_frames(self, written):\n        \"\"\"Update self.frames after writing.\"\"\"\n        if self.seekable():\n            curr = self.tell()\n            self._info.frames = self.seek(0, SEEK_END)\n            self.seek(curr, SEEK_SET)\n        else:\n            self._info.frames += written\n\n    def _prepare_read(self, start, stop, frames):\n        \"\"\"Seek to start frame and calculate length.\"\"\"\n        if start != 0 and not self.seekable():\n            raise ValueError(\"start is only allowed for seekable files\")\n        if frames >= 0 and stop is not None:\n            raise TypeError(\"Only one of {frames, stop} may be used\")\n\n        start, stop, _ = slice(start, stop).indices(self.frames)\n        if stop < start:\n            stop = start\n        if frames < 0:\n            frames = stop - start\n        if self.seekable():\n            self.seek(start, SEEK_SET)\n        return frames\n\n\ndef _error_check(err, prefix=\"\"):\n    \"\"\"Pretty-print a numerical error code if there is an error.\"\"\"\n    if err != 0:\n        err_str = _snd.sf_error_number(err)\n        raise RuntimeError(prefix + _ffi.string(err_str).decode('utf-8', 'replace'))\n\n\ndef _format_int(format, subtype, endian):\n    \"\"\"Return numeric ID for given format|subtype|endian combo.\"\"\"\n    result = _check_format(format)\n    if subtype is None:\n        subtype = default_subtype(format)\n        if subtype is None:\n            raise TypeError(\n                \"No default subtype for major format {0!r}\".format(format))\n    elif not isinstance(subtype, (_unicode, str)):\n        raise TypeError(\"Invalid subtype: {0!r}\".format(subtype))\n    try:\n        result |= _subtypes[subtype.upper()]\n    except KeyError:\n        raise ValueError(\"Unknown subtype: {0!r}\".format(subtype))\n    if endian is None:\n        endian = 'FILE'\n    elif not isinstance(endian, (_unicode, str)):\n        raise TypeError(\"Invalid endian-ness: {0!r}\".format(endian))\n    try:\n        result |= _endians[endian.upper()]\n    except KeyError:\n        raise ValueError(\"Unknown endian-ness: {0!r}\".format(endian))\n\n    info = _ffi.new(\"SF_INFO*\")\n    info.format = result\n    info.channels = 1\n    if _snd.sf_format_check(info) == _snd.SF_FALSE:\n        raise ValueError(\n            \"Invalid combination of format, subtype and endian\")\n    return result\n\n\ndef _check_mode(mode):\n    \"\"\"Check if mode is valid and return its integer representation.\"\"\"\n    if not isinstance(mode, (_unicode, str)):\n        raise TypeError(\"Invalid mode: {0!r}\".format(mode))\n    mode_set = set(mode)\n    if mode_set.difference('xrwb+') or len(mode) > len(mode_set):\n        raise ValueError(\"Invalid mode: {0!r}\".format(mode))\n    if len(mode_set.intersection('xrw')) != 1:\n        raise ValueError(\"mode must contain exactly one of 'xrw'\")\n\n    if '+' in mode_set:\n        mode_int = _snd.SFM_RDWR\n    elif 'r' in mode_set:\n        mode_int = _snd.SFM_READ\n    else:\n        mode_int = _snd.SFM_WRITE\n    return mode_int\n\n\ndef _create_info_struct(file, mode, samplerate, channels,\n                        format, subtype, endian):\n    \"\"\"Check arguments and create SF_INFO struct.\"\"\"\n    original_format = format\n    if format is None:\n        format = _get_format_from_filename(file, mode)\n        assert isinstance(format, (_unicode, str))\n    else:\n        _check_format(format)\n\n    info = _ffi.new(\"SF_INFO*\")\n    if 'r' not in mode or format.upper() == 'RAW':\n        if samplerate is None:\n            raise TypeError(\"samplerate must be specified\")\n        info.samplerate = samplerate\n        if channels is None:\n            raise TypeError(\"channels must be specified\")\n        info.channels = channels\n        info.format = _format_int(format, subtype, endian)\n    else:\n        if any(arg is not None for arg in (\n                samplerate, channels, original_format, subtype, endian)):\n            raise TypeError(\"Not allowed for existing files (except 'RAW'): \"\n                            \"samplerate, channels, format, subtype, endian\")\n    return info\n\n\ndef _get_format_from_filename(file, mode):\n    \"\"\"Return a format string obtained from file (or file.name).\n\n    If file already exists (= read mode), an empty string is returned on\n    error.  If not, an exception is raised.\n    The return type will always be str or unicode (even if\n    file/file.name is a bytes object).\n\n    \"\"\"\n    format = ''\n    file = getattr(file, 'name', file)\n    try:\n        # This raises an exception if file is not a (Unicode/byte) string:\n        format = _os.path.splitext(file)[-1][1:]\n        # Convert bytes to unicode (raises AttributeError on Python 3 str):\n        format = format.decode('utf-8', 'replace')\n    except Exception:\n        pass\n    if format.upper() not in _formats and 'r' not in mode:\n        raise TypeError(\"No format specified and unable to get format from \"\n                        \"file extension: {0!r}\".format(file))\n    return format\n\n\ndef _format_str(format_int):\n    \"\"\"Return the string representation of a given numeric format.\"\"\"\n    for dictionary in _formats, _subtypes, _endians:\n        for k, v in dictionary.items():\n            if v == format_int:\n                return k\n    else:\n        return 'n/a'\n\n\ndef _format_info(format_int, format_flag=_snd.SFC_GET_FORMAT_INFO):\n    \"\"\"Return the ID and short description of a given format.\"\"\"\n    format_info = _ffi.new(\"SF_FORMAT_INFO*\")\n    format_info.format = format_int\n    _snd.sf_command(_ffi.NULL, format_flag, format_info,\n                    _ffi.sizeof(\"SF_FORMAT_INFO\"))\n    name = format_info.name\n    return (_format_str(format_info.format),\n            _ffi.string(name).decode('utf-8', 'replace') if name else \"\")\n\n\ndef _available_formats_helper(count_flag, format_flag):\n    \"\"\"Helper for available_formats() and available_subtypes().\"\"\"\n    count = _ffi.new(\"int*\")\n    _snd.sf_command(_ffi.NULL, count_flag, count, _ffi.sizeof(\"int\"))\n    for format_int in range(count[0]):\n        yield _format_info(format_int, format_flag)\n\n\ndef _check_format(format_str):\n    \"\"\"Check if `format_str` is valid and return format ID.\"\"\"\n    if not isinstance(format_str, (_unicode, str)):\n        raise TypeError(\"Invalid format: {0!r}\".format(format_str))\n    try:\n        format_int = _formats[format_str.upper()]\n    except KeyError:\n        raise ValueError(\"Unknown format: {0!r}\".format(format_str))\n    return format_int\n\n\ndef _has_virtual_io_attrs(file, mode_int):\n    \"\"\"Check if file has all the necessary attributes for virtual IO.\"\"\"\n    readonly = mode_int == _snd.SFM_READ\n    writeonly = mode_int == _snd.SFM_WRITE\n    return all([\n        hasattr(file, 'seek'),\n        hasattr(file, 'tell'),\n        hasattr(file, 'write') or readonly,\n        hasattr(file, 'read') or hasattr(file, 'readinto') or writeonly,\n    ])\n",
        "/tmp/vanessa/spack-stage/spack-stage-py-soundfile-0.10.3.post1-2vredvl2lxfwe72pnscuzav3y5hjpyqz/spack-src/doc/fake__soundfile.py": "\"\"\"Mock module for Sphinx autodoc.\"\"\"\n\nimport ctypes\n\n# Monkey-patch ctypes to disable searching for libsndfile\nctypes.util.find_library = lambda _: NotImplemented\n\n\nclass ffi(object):\n\n    def dlopen(self, _):\n        return self\n\n    def string(self, _):\n        return b'not implemented'\n\n    def sf_version_string(self):\n        return NotImplemented\n\n    SFC_GET_FORMAT_INFO = NotImplemented\n\n\nffi = ffi()\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-py-soundfile-0.10.3.post1-2vredvl2lxfwe72pnscuzav3y5hjpyqz/spack-src/tests/mono.raw",
        "/tmp/vanessa/spack-stage/spack-stage-py-soundfile-0.10.3.post1-2vredvl2lxfwe72pnscuzav3y5hjpyqz/spack-src/tests/mono.wav",
        "/tmp/vanessa/spack-stage/spack-stage-py-soundfile-0.10.3.post1-2vredvl2lxfwe72pnscuzav3y5hjpyqz/spack-src/tests/stereo.wav"
    ],
    "total_files": 22
}