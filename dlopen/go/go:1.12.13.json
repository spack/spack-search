{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/plugin/plugin_dlopen.go": "// Copyright 2016 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// +build linux,cgo darwin,cgo\n\npackage plugin\n\n/*\n#cgo linux LDFLAGS: -ldl\n#include <dlfcn.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <stdint.h>\n\n#include <stdio.h>\n\nstatic uintptr_t pluginOpen(const char* path, char** err) {\n\tvoid* h = dlopen(path, RTLD_NOW|RTLD_GLOBAL);\n\tif (h == NULL) {\n\t\t*err = (char*)dlerror();\n\t}\n\treturn (uintptr_t)h;\n}\n\nstatic void* pluginLookup(uintptr_t h, const char* name, char** err) {\n\tvoid* r = dlsym((void*)h, name);\n\tif (r == NULL) {\n\t\t*err = (char*)dlerror();\n\t}\n\treturn r;\n}\n*/\nimport \"C\"\n\nimport (\n\t\"errors\"\n\t\"sync\"\n\t\"unsafe\"\n)\n\nfunc open(name string) (*Plugin, error) {\n\tcPath := make([]byte, C.PATH_MAX+1)\n\tcRelName := make([]byte, len(name)+1)\n\tcopy(cRelName, name)\n\tif C.realpath(\n\t\t(*C.char)(unsafe.Pointer(&cRelName[0])),\n\t\t(*C.char)(unsafe.Pointer(&cPath[0]))) == nil {\n\t\treturn nil, errors.New(`plugin.Open(\"` + name + `\"): realpath failed`)\n\t}\n\n\tfilepath := C.GoString((*C.char)(unsafe.Pointer(&cPath[0])))\n\n\tpluginsMu.Lock()\n\tif p := plugins[filepath]; p != nil {\n\t\tpluginsMu.Unlock()\n\t\tif p.err != \"\" {\n\t\t\treturn nil, errors.New(`plugin.Open(\"` + name + `\"): ` + p.err + ` (previous failure)`)\n\t\t}\n\t\t<-p.loaded\n\t\treturn p, nil\n\t}\n\tvar cErr *C.char\n\th := C.pluginOpen((*C.char)(unsafe.Pointer(&cPath[0])), &cErr)\n\tif h == 0 {\n\t\tpluginsMu.Unlock()\n\t\treturn nil, errors.New(`plugin.Open(\"` + name + `\"): ` + C.GoString(cErr))\n\t}\n\t// TODO(crawshaw): look for plugin note, confirm it is a Go plugin\n\t// and it was built with the correct toolchain.\n\tif len(name) > 3 && name[len(name)-3:] == \".so\" {\n\t\tname = name[:len(name)-3]\n\t}\n\tif plugins == nil {\n\t\tplugins = make(map[string]*Plugin)\n\t}\n\tpluginpath, syms, errstr := lastmoduleinit()\n\tif errstr != \"\" {\n\t\tplugins[filepath] = &Plugin{\n\t\t\tpluginpath: pluginpath,\n\t\t\terr:        errstr,\n\t\t}\n\t\tpluginsMu.Unlock()\n\t\treturn nil, errors.New(`plugin.Open(\"` + name + `\"): ` + errstr)\n\t}\n\t// This function can be called from the init function of a plugin.\n\t// Drop a placeholder in the map so subsequent opens can wait on it.\n\tp := &Plugin{\n\t\tpluginpath: pluginpath,\n\t\tloaded:     make(chan struct{}),\n\t}\n\tplugins[filepath] = p\n\tpluginsMu.Unlock()\n\n\tinitStr := make([]byte, len(pluginpath)+6)\n\tcopy(initStr, pluginpath)\n\tcopy(initStr[len(pluginpath):], \".init\")\n\n\tinitFuncPC := C.pluginLookup(h, (*C.char)(unsafe.Pointer(&initStr[0])), &cErr)\n\tif initFuncPC != nil {\n\t\tinitFuncP := &initFuncPC\n\t\tinitFunc := *(*func())(unsafe.Pointer(&initFuncP))\n\t\tinitFunc()\n\t}\n\n\t// Fill out the value of each plugin symbol.\n\tupdatedSyms := map[string]interface{}{}\n\tfor symName, sym := range syms {\n\t\tisFunc := symName[0] == '.'\n\t\tif isFunc {\n\t\t\tdelete(syms, symName)\n\t\t\tsymName = symName[1:]\n\t\t}\n\n\t\tfullName := pluginpath + \".\" + symName\n\t\tcname := make([]byte, len(fullName)+1)\n\t\tcopy(cname, fullName)\n\n\t\tp := C.pluginLookup(h, (*C.char)(unsafe.Pointer(&cname[0])), &cErr)\n\t\tif p == nil {\n\t\t\treturn nil, errors.New(`plugin.Open(\"` + name + `\"): could not find symbol ` + symName + `: ` + C.GoString(cErr))\n\t\t}\n\t\tvalp := (*[2]unsafe.Pointer)(unsafe.Pointer(&sym))\n\t\tif isFunc {\n\t\t\t(*valp)[1] = unsafe.Pointer(&p)\n\t\t} else {\n\t\t\t(*valp)[1] = p\n\t\t}\n\t\t// we can't add to syms during iteration as we'll end up processing\n\t\t// some symbols twice with the inability to tell if the symbol is a function\n\t\tupdatedSyms[symName] = sym\n\t}\n\tp.syms = updatedSyms\n\n\tclose(p.loaded)\n\treturn p, nil\n}\n\nfunc lookup(p *Plugin, symName string) (Symbol, error) {\n\tif s := p.syms[symName]; s != nil {\n\t\treturn s, nil\n\t}\n\treturn nil, errors.New(\"plugin: symbol \" + symName + \" not found in plugin \" + p.pluginpath)\n}\n\nvar (\n\tpluginsMu sync.Mutex\n\tplugins   map[string]*Plugin\n)\n\n// lastmoduleinit is defined in package runtime\nfunc lastmoduleinit() (pluginpath string, syms map[string]interface{}, errstr string)\n",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/runtime/asm_arm.s": "// Copyright 2009 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n#include \"go_asm.h\"\n#include \"go_tls.h\"\n#include \"funcdata.h\"\n#include \"textflag.h\"\n\n// _rt0_arm is common startup code for most ARM systems when using\n// internal linking. This is the entry point for the program from the\n// kernel for an ordinary -buildmode=exe program. The stack holds the\n// number of arguments and the C-style argv.\nTEXT _rt0_arm(SB),NOSPLIT|NOFRAME,$0\n\tMOVW\t(R13), R0\t// argc\n\tMOVW\t$4(R13), R1\t\t// argv\n\tB\truntime\u00b7rt0_go(SB)\n\n// main is common startup code for most ARM systems when using\n// external linking. The C startup code will call the symbol \"main\"\n// passing argc and argv in the usual C ABI registers R0 and R1.\nTEXT main(SB),NOSPLIT|NOFRAME,$0\n\tB\truntime\u00b7rt0_go(SB)\n\n// _rt0_arm_lib is common startup code for most ARM systems when\n// using -buildmode=c-archive or -buildmode=c-shared. The linker will\n// arrange to invoke this function as a global constructor (for\n// c-archive) or when the shared library is loaded (for c-shared).\n// We expect argc and argv to be passed in the usual C ABI registers\n// R0 and R1.\nTEXT _rt0_arm_lib(SB),NOSPLIT,$104\n\t// Preserve callee-save registers. Raspberry Pi's dlopen(), for example,\n\t// actually cares that R11 is preserved.\n\tMOVW\tR4, 12(R13)\n\tMOVW\tR5, 16(R13)\n\tMOVW\tR6, 20(R13)\n\tMOVW\tR7, 24(R13)\n\tMOVW\tR8, 28(R13)\n\tMOVW\tg, 32(R13)\n\tMOVW\tR11, 36(R13)\n\n\t// Skip floating point registers on GOARM < 6.\n\tMOVB    runtime\u00b7goarm(SB), R11\n\tCMP\t$6, R11\n\tBLT\tskipfpsave\n\tMOVD\tF8, (40+8*0)(R13)\n\tMOVD\tF9, (40+8*1)(R13)\n\tMOVD\tF10, (40+8*2)(R13)\n\tMOVD\tF11, (40+8*3)(R13)\n\tMOVD\tF12, (40+8*4)(R13)\n\tMOVD\tF13, (40+8*5)(R13)\n\tMOVD\tF14, (40+8*6)(R13)\n\tMOVD\tF15, (40+8*7)(R13)\nskipfpsave:\n\t// Save argc/argv.\n\tMOVW\tR0, _rt0_arm_lib_argc<>(SB)\n\tMOVW\tR1, _rt0_arm_lib_argv<>(SB)\n\n\tMOVW\t$0, g // Initialize g.\n\n\t// Synchronous initialization.\n\tCALL\truntime\u00b7libpreinit(SB)\n\n\t// Create a new thread to do the runtime initialization.\n\tMOVW\t_cgo_sys_thread_create(SB), R2\n\tCMP\t$0, R2\n\tBEQ\tnocgo\n\tMOVW\t$_rt0_arm_lib_go<>(SB), R0\n\tMOVW\t$0, R1\n\tBL\t(R2)\n\tB\trr\nnocgo:\n\tMOVW\t$0x800000, R0                     // stacksize = 8192KB\n\tMOVW\t$_rt0_arm_lib_go<>(SB), R1  // fn\n\tMOVW\tR0, 4(R13)\n\tMOVW\tR1, 8(R13)\n\tBL\truntime\u00b7newosproc0(SB)\nrr:\n\t// Restore callee-save registers and return.\n\tMOVB    runtime\u00b7goarm(SB), R11\n\tCMP\t$6, R11\n\tBLT\tskipfprest\n\tMOVD\t(40+8*0)(R13), F8\n\tMOVD\t(40+8*1)(R13), F9\n\tMOVD\t(40+8*2)(R13), F10\n\tMOVD\t(40+8*3)(R13), F11\n\tMOVD\t(40+8*4)(R13), F12\n\tMOVD\t(40+8*5)(R13), F13\n\tMOVD\t(40+8*6)(R13), F14\n\tMOVD\t(40+8*7)(R13), F15\nskipfprest:\n\tMOVW\t12(R13), R4\n\tMOVW\t16(R13), R5\n\tMOVW\t20(R13), R6\n\tMOVW\t24(R13), R7\n\tMOVW\t28(R13), R8\n\tMOVW\t32(R13), g\n\tMOVW\t36(R13), R11\n\tRET\n\n// _rt0_arm_lib_go initializes the Go runtime.\n// This is started in a separate thread by _rt0_arm_lib.\nTEXT _rt0_arm_lib_go<>(SB),NOSPLIT,$8\n\tMOVW\t_rt0_arm_lib_argc<>(SB), R0\n\tMOVW\t_rt0_arm_lib_argv<>(SB), R1\n\tB\truntime\u00b7rt0_go(SB)\n\nDATA _rt0_arm_lib_argc<>(SB)/4,$0\nGLOBL _rt0_arm_lib_argc<>(SB),NOPTR,$4\nDATA _rt0_arm_lib_argv<>(SB)/4,$0\nGLOBL _rt0_arm_lib_argv<>(SB),NOPTR,$4\n\n// using NOFRAME means do not save LR on stack.\n// argc is in R0, argv is in R1.\nTEXT runtime\u00b7rt0_go(SB),NOSPLIT|NOFRAME,$0\n\tMOVW\t$0xcafebabe, R12\n\n\t// copy arguments forward on an even stack\n\t// use R13 instead of SP to avoid linker rewriting the offsets\n\tSUB\t$64, R13\t\t// plenty of scratch\n\tAND\t$~7, R13\n\tMOVW\tR0, 60(R13)\t\t// save argc, argv away\n\tMOVW\tR1, 64(R13)\n\n\t// set up g register\n\t// g is R10\n\tMOVW\t$runtime\u00b7g0(SB), g\n\tMOVW\t$runtime\u00b7m0(SB), R8\n\n\t// save m->g0 = g0\n\tMOVW\tg, m_g0(R8)\n\t// save g->m = m0\n\tMOVW\tR8, g_m(g)\n\n\t// create istack out of the OS stack\n\t// (1MB of system stack is available on iOS and Android)\n\tMOVW\t$(-64*1024+104)(R13), R0\n\tMOVW\tR0, g_stackguard0(g)\n\tMOVW\tR0, g_stackguard1(g)\n\tMOVW\tR0, (g_stack+stack_lo)(g)\n\tMOVW\tR13, (g_stack+stack_hi)(g)\n\n\tBL\truntime\u00b7emptyfunc(SB)\t// fault if stack check is wrong\n\n\tBL\truntime\u00b7_initcgo(SB)\t// will clobber R0-R3\n\n\t// update stackguard after _cgo_init\n\tMOVW\t(g_stack+stack_lo)(g), R0\n\tADD\t$const__StackGuard, R0\n\tMOVW\tR0, g_stackguard0(g)\n\tMOVW\tR0, g_stackguard1(g)\n\n\tBL\truntime\u00b7check(SB)\n\n\t// saved argc, argv\n\tMOVW\t60(R13), R0\n\tMOVW\tR0, 4(R13)\n\tMOVW\t64(R13), R1\n\tMOVW\tR1, 8(R13)\n\tBL\truntime\u00b7args(SB)\n\tBL\truntime\u00b7checkgoarm(SB)\n\tBL\truntime\u00b7osinit(SB)\n\tBL\truntime\u00b7schedinit(SB)\n\n\t// create a new goroutine to start program\n\tMOVW\t$runtime\u00b7mainPC(SB), R0\n\tMOVW.W\tR0, -4(R13)\n\tMOVW\t$8, R0\n\tMOVW.W\tR0, -4(R13)\n\tMOVW\t$0, R0\n\tMOVW.W\tR0, -4(R13)\t// push $0 as guard\n\tBL\truntime\u00b7newproc(SB)\n\tMOVW\t$12(R13), R13\t// pop args and LR\n\n\t// start this M\n\tBL\truntime\u00b7mstart(SB)\n\n\tMOVW\t$1234, R0\n\tMOVW\t$1000, R1\n\tMOVW\tR0, (R1)\t// fail hard\n\nDATA\truntime\u00b7mainPC+0(SB)/4,$runtime\u00b7main(SB)\nGLOBL\truntime\u00b7mainPC(SB),RODATA,$4\n\nTEXT runtime\u00b7breakpoint(SB),NOSPLIT,$0-0\n\t// gdb won't skip this breakpoint instruction automatically,\n\t// so you must manually \"set $pc+=4\" to skip it and continue.\n#ifdef GOOS_nacl\n\tWORD\t$0xe125be7f\t// BKPT 0x5bef, NACL_INSTR_ARM_BREAKPOINT\n#else\n#ifdef GOOS_plan9\n\tWORD\t$0xD1200070\t// undefined instruction used as armv5 breakpoint in Plan 9\n#else\n\tWORD\t$0xe7f001f0\t// undefined instruction that gdb understands is a software breakpoint\n#endif\n#endif\n\tRET\n\nTEXT runtime\u00b7asminit(SB),NOSPLIT,$0-0\n\t// disable runfast (flush-to-zero) mode of vfp if runtime.goarm > 5\n\tMOVB\truntime\u00b7goarm(SB), R11\n\tCMP\t$5, R11\n\tBLE\t4(PC)\n\tWORD\t$0xeef1ba10\t// vmrs r11, fpscr\n\tBIC\t$(1<<24), R11\n\tWORD\t$0xeee1ba10\t// vmsr fpscr, r11\n\tRET\n\n/*\n *  go-routine\n */\n\n// void gosave(Gobuf*)\n// save state in Gobuf; setjmp\nTEXT runtime\u00b7gosave(SB),NOSPLIT|NOFRAME,$0-4\n\tMOVW\tbuf+0(FP), R0\n\tMOVW\tR13, gobuf_sp(R0)\n\tMOVW\tLR, gobuf_pc(R0)\n\tMOVW\tg, gobuf_g(R0)\n\tMOVW\t$0, R11\n\tMOVW\tR11, gobuf_lr(R0)\n\tMOVW\tR11, gobuf_ret(R0)\n\t// Assert ctxt is zero. See func save.\n\tMOVW\tgobuf_ctxt(R0), R0\n\tCMP\tR0, R11\n\tB.EQ\t2(PC)\n\tCALL\truntime\u00b7badctxt(SB)\n\tRET\n\n// void gogo(Gobuf*)\n// restore state from Gobuf; longjmp\nTEXT runtime\u00b7gogo(SB),NOSPLIT,$8-4\n\tMOVW\tbuf+0(FP), R1\n\tMOVW\tgobuf_g(R1), R0\n\tBL\tsetg<>(SB)\n\n\t// NOTE: We updated g above, and we are about to update SP.\n\t// Until LR and PC are also updated, the g/SP/LR/PC quadruple\n\t// are out of sync and must not be used as the basis of a traceback.\n\t// Sigprof skips the traceback when SP is not within g's bounds,\n\t// and when the PC is inside this function, runtime.gogo.\n\t// Since we are about to update SP, until we complete runtime.gogo\n\t// we must not leave this function. In particular, no calls\n\t// after this point: it must be straight-line code until the\n\t// final B instruction.\n\t// See large comment in sigprof for more details.\n\tMOVW\tgobuf_sp(R1), R13\t// restore SP==R13\n\tMOVW\tgobuf_lr(R1), LR\n\tMOVW\tgobuf_ret(R1), R0\n\tMOVW\tgobuf_ctxt(R1), R7\n\tMOVW\t$0, R11\n\tMOVW\tR11, gobuf_sp(R1)\t// clear to help garbage collector\n\tMOVW\tR11, gobuf_ret(R1)\n\tMOVW\tR11, gobuf_lr(R1)\n\tMOVW\tR11, gobuf_ctxt(R1)\n\tMOVW\tgobuf_pc(R1), R11\n\tCMP\tR11, R11 // set condition codes for == test, needed by stack split\n\tB\t(R11)\n\n// func mcall(fn func(*g))\n// Switch to m->g0's stack, call fn(g).\n// Fn must never return. It should gogo(&g->sched)\n// to keep running g.\nTEXT runtime\u00b7mcall(SB),NOSPLIT|NOFRAME,$0-4\n\t// Save caller state in g->sched.\n\tMOVW\tR13, (g_sched+gobuf_sp)(g)\n\tMOVW\tLR, (g_sched+gobuf_pc)(g)\n\tMOVW\t$0, R11\n\tMOVW\tR11, (g_sched+gobuf_lr)(g)\n\tMOVW\tg, (g_sched+gobuf_g)(g)\n\n\t// Switch to m->g0 & its stack, call fn.\n\tMOVW\tg, R1\n\tMOVW\tg_m(g), R8\n\tMOVW\tm_g0(R8), R0\n\tBL\tsetg<>(SB)\n\tCMP\tg, R1\n\tB.NE\t2(PC)\n\tB\truntime\u00b7badmcall(SB)\n\tMOVB\truntime\u00b7iscgo(SB), R11\n\tCMP\t$0, R11\n\tBL.NE\truntime\u00b7save_g(SB)\n\tMOVW\tfn+0(FP), R0\n\tMOVW\t(g_sched+gobuf_sp)(g), R13\n\tSUB\t$8, R13\n\tMOVW\tR1, 4(R13)\n\tMOVW\tR0, R7\n\tMOVW\t0(R0), R0\n\tBL\t(R0)\n\tB\truntime\u00b7badmcall2(SB)\n\tRET\n\n// systemstack_switch is a dummy routine that systemstack leaves at the bottom\n// of the G stack. We need to distinguish the routine that\n// lives at the bottom of the G stack from the one that lives\n// at the top of the system stack because the one at the top of\n// the system stack terminates the stack walk (see topofstack()).\nTEXT runtime\u00b7systemstack_switch(SB),NOSPLIT,$0-0\n\tMOVW\t$0, R0\n\tBL\t(R0) // clobber lr to ensure push {lr} is kept\n\tRET\n\n// func systemstack(fn func())\nTEXT runtime\u00b7systemstack(SB),NOSPLIT,$0-4\n\tMOVW\tfn+0(FP), R0\t// R0 = fn\n\tMOVW\tg_m(g), R1\t// R1 = m\n\n\tMOVW\tm_gsignal(R1), R2\t// R2 = gsignal\n\tCMP\tg, R2\n\tB.EQ\tnoswitch\n\n\tMOVW\tm_g0(R1), R2\t// R2 = g0\n\tCMP\tg, R2\n\tB.EQ\tnoswitch\n\n\tMOVW\tm_curg(R1), R3\n\tCMP\tg, R3\n\tB.EQ\tswitch\n\n\t// Bad: g is not gsignal, not g0, not curg. What is it?\n\t// Hide call from linker nosplit analysis.\n\tMOVW\t$runtime\u00b7badsystemstack(SB), R0\n\tBL\t(R0)\n\tB\truntime\u00b7abort(SB)\n\nswitch:\n\t// save our state in g->sched. Pretend to\n\t// be systemstack_switch if the G stack is scanned.\n\tMOVW\t$runtime\u00b7systemstack_switch(SB), R3\n#ifdef GOOS_nacl\n\tADD\t$4, R3, R3 // get past nacl-insert bic instruction\n#endif\n\tADD\t$4, R3, R3 // get past push {lr}\n\tMOVW\tR3, (g_sched+gobuf_pc)(g)\n\tMOVW\tR13, (g_sched+gobuf_sp)(g)\n\tMOVW\tLR, (g_sched+gobuf_lr)(g)\n\tMOVW\tg, (g_sched+gobuf_g)(g)\n\n\t// switch to g0\n\tMOVW\tR0, R5\n\tMOVW\tR2, R0\n\tBL\tsetg<>(SB)\n\tMOVW\tR5, R0\n\tMOVW\t(g_sched+gobuf_sp)(R2), R3\n\t// make it look like mstart called systemstack on g0, to stop traceback\n\tSUB\t$4, R3, R3\n\tMOVW\t$runtime\u00b7mstart(SB), R4\n\tMOVW\tR4, 0(R3)\n\tMOVW\tR3, R13\n\n\t// call target function\n\tMOVW\tR0, R7\n\tMOVW\t0(R0), R0\n\tBL\t(R0)\n\n\t// switch back to g\n\tMOVW\tg_m(g), R1\n\tMOVW\tm_curg(R1), R0\n\tBL\tsetg<>(SB)\n\tMOVW\t(g_sched+gobuf_sp)(g), R13\n\tMOVW\t$0, R3\n\tMOVW\tR3, (g_sched+gobuf_sp)(g)\n\tRET\n\nnoswitch:\n\t// Using a tail call here cleans up tracebacks since we won't stop\n\t// at an intermediate systemstack.\n\tMOVW\tR0, R7\n\tMOVW\t0(R0), R0\n\tMOVW.P\t4(R13), R14\t// restore LR\n\tB\t(R0)\n\n/*\n * support for morestack\n */\n\n// Called during function prolog when more stack is needed.\n// R3 prolog's LR\n// using NOFRAME means do not save LR on stack.\n//\n// The traceback routines see morestack on a g0 as being\n// the top of a stack (for example, morestack calling newstack\n// calling the scheduler calling newm calling gc), so we must\n// record an argument size. For that purpose, it has no arguments.\nTEXT runtime\u00b7morestack(SB),NOSPLIT|NOFRAME,$0-0\n\t// Cannot grow scheduler stack (m->g0).\n\tMOVW\tg_m(g), R8\n\tMOVW\tm_g0(R8), R4\n\tCMP\tg, R4\n\tBNE\t3(PC)\n\tBL\truntime\u00b7badmorestackg0(SB)\n\tB\truntime\u00b7abort(SB)\n\n\t// Cannot grow signal stack (m->gsignal).\n\tMOVW\tm_gsignal(R8), R4\n\tCMP\tg, R4\n\tBNE\t3(PC)\n\tBL\truntime\u00b7badmorestackgsignal(SB)\n\tB\truntime\u00b7abort(SB)\n\n\t// Called from f.\n\t// Set g->sched to context in f.\n\tMOVW\tR13, (g_sched+gobuf_sp)(g)\n\tMOVW\tLR, (g_sched+gobuf_pc)(g)\n\tMOVW\tR3, (g_sched+gobuf_lr)(g)\n\tMOVW\tR7, (g_sched+gobuf_ctxt)(g)\n\n\t// Called from f.\n\t// Set m->morebuf to f's caller.\n\tMOVW\tR3, (m_morebuf+gobuf_pc)(R8)\t// f's caller's PC\n\tMOVW\tR13, (m_morebuf+gobuf_sp)(R8)\t// f's caller's SP\n\tMOVW\tg, (m_morebuf+gobuf_g)(R8)\n\n\t// Call newstack on m->g0's stack.\n\tMOVW\tm_g0(R8), R0\n\tBL\tsetg<>(SB)\n\tMOVW\t(g_sched+gobuf_sp)(g), R13\n\tMOVW\t$0, R0\n\tMOVW.W  R0, -4(R13)\t// create a call frame on g0 (saved LR)\n\tBL\truntime\u00b7newstack(SB)\n\n\t// Not reached, but make sure the return PC from the call to newstack\n\t// is still in this function, and not the beginning of the next.\n\tRET\n\nTEXT runtime\u00b7morestack_noctxt(SB),NOSPLIT|NOFRAME,$0-0\n\tMOVW\t$0, R7\n\tB runtime\u00b7morestack(SB)\n\n// reflectcall: call a function with the given argument list\n// func call(argtype *_type, f *FuncVal, arg *byte, argsize, retoffset uint32).\n// we don't have variable-sized frames, so we use a small number\n// of constant-sized-frame functions to encode a few bits of size in the pc.\n// Caution: ugly multiline assembly macros in your future!\n\n#define DISPATCH(NAME,MAXSIZE)\t\t\\\n\tCMP\t$MAXSIZE, R0;\t\t\\\n\tB.HI\t3(PC);\t\t\t\\\n\tMOVW\t$NAME(SB), R1;\t\t\\\n\tB\t(R1)\n\nTEXT \u00b7reflectcall(SB),NOSPLIT|NOFRAME,$0-20\n\tMOVW\targsize+12(FP), R0\n\tDISPATCH(runtime\u00b7call16, 16)\n\tDISPATCH(runtime\u00b7call32, 32)\n\tDISPATCH(runtime\u00b7call64, 64)\n\tDISPATCH(runtime\u00b7call128, 128)\n\tDISPATCH(runtime\u00b7call256, 256)\n\tDISPATCH(runtime\u00b7call512, 512)\n\tDISPATCH(runtime\u00b7call1024, 1024)\n\tDISPATCH(runtime\u00b7call2048, 2048)\n\tDISPATCH(runtime\u00b7call4096, 4096)\n\tDISPATCH(runtime\u00b7call8192, 8192)\n\tDISPATCH(runtime\u00b7call16384, 16384)\n\tDISPATCH(runtime\u00b7call32768, 32768)\n\tDISPATCH(runtime\u00b7call65536, 65536)\n\tDISPATCH(runtime\u00b7call131072, 131072)\n\tDISPATCH(runtime\u00b7call262144, 262144)\n\tDISPATCH(runtime\u00b7call524288, 524288)\n\tDISPATCH(runtime\u00b7call1048576, 1048576)\n\tDISPATCH(runtime\u00b7call2097152, 2097152)\n\tDISPATCH(runtime\u00b7call4194304, 4194304)\n\tDISPATCH(runtime\u00b7call8388608, 8388608)\n\tDISPATCH(runtime\u00b7call16777216, 16777216)\n\tDISPATCH(runtime\u00b7call33554432, 33554432)\n\tDISPATCH(runtime\u00b7call67108864, 67108864)\n\tDISPATCH(runtime\u00b7call134217728, 134217728)\n\tDISPATCH(runtime\u00b7call268435456, 268435456)\n\tDISPATCH(runtime\u00b7call536870912, 536870912)\n\tDISPATCH(runtime\u00b7call1073741824, 1073741824)\n\tMOVW\t$runtime\u00b7badreflectcall(SB), R1\n\tB\t(R1)\n\n#define CALLFN(NAME,MAXSIZE)\t\t\t\\\nTEXT NAME(SB), WRAPPER, $MAXSIZE-20;\t\t\\\n\tNO_LOCAL_POINTERS;\t\t\t\\\n\t/* copy arguments to stack */\t\t\\\n\tMOVW\targptr+8(FP), R0;\t\t\\\n\tMOVW\targsize+12(FP), R2;\t\t\\\n\tADD\t$4, R13, R1;\t\t\t\\\n\tCMP\t$0, R2;\t\t\t\t\\\n\tB.EQ\t5(PC);\t\t\t\t\\\n\tMOVBU.P\t1(R0), R5;\t\t\t\\\n\tMOVBU.P R5, 1(R1);\t\t\t\\\n\tSUB\t$1, R2, R2;\t\t\t\\\n\tB\t-5(PC);\t\t\t\t\\\n\t/* call function */\t\t\t\\\n\tMOVW\tf+4(FP), R7;\t\t\t\\\n\tMOVW\t(R7), R0;\t\t\t\\\n\tPCDATA  $PCDATA_StackMapIndex, $0;\t\\\n\tBL\t(R0);\t\t\t\t\\\n\t/* copy return values back */\t\t\\\n\tMOVW\targtype+0(FP), R4;\t\t\\\n\tMOVW\targptr+8(FP), R0;\t\t\\\n\tMOVW\targsize+12(FP), R2;\t\t\\\n\tMOVW\tretoffset+16(FP), R3;\t\t\\\n\tADD\t$4, R13, R1;\t\t\t\\\n\tADD\tR3, R1;\t\t\t\t\\\n\tADD\tR3, R0;\t\t\t\t\\\n\tSUB\tR3, R2;\t\t\t\t\\\n\tBL\tcallRet<>(SB);\t\t\t\\\n\tRET\n\n// callRet copies return values back at the end of call*. This is a\n// separate function so it can allocate stack space for the arguments\n// to reflectcallmove. It does not follow the Go ABI; it expects its\n// arguments in registers.\nTEXT callRet<>(SB), NOSPLIT, $16-0\n\tMOVW\tR4, 4(R13)\n\tMOVW\tR0, 8(R13)\n\tMOVW\tR1, 12(R13)\n\tMOVW\tR2, 16(R13)\n\tBL\truntime\u00b7reflectcallmove(SB)\n\tRET\n\nCALLFN(\u00b7call16, 16)\nCALLFN(\u00b7call32, 32)\nCALLFN(\u00b7call64, 64)\nCALLFN(\u00b7call128, 128)\nCALLFN(\u00b7call256, 256)\nCALLFN(\u00b7call512, 512)\nCALLFN(\u00b7call1024, 1024)\nCALLFN(\u00b7call2048, 2048)\nCALLFN(\u00b7call4096, 4096)\nCALLFN(\u00b7call8192, 8192)\nCALLFN(\u00b7call16384, 16384)\nCALLFN(\u00b7call32768, 32768)\nCALLFN(\u00b7call65536, 65536)\nCALLFN(\u00b7call131072, 131072)\nCALLFN(\u00b7call262144, 262144)\nCALLFN(\u00b7call524288, 524288)\nCALLFN(\u00b7call1048576, 1048576)\nCALLFN(\u00b7call2097152, 2097152)\nCALLFN(\u00b7call4194304, 4194304)\nCALLFN(\u00b7call8388608, 8388608)\nCALLFN(\u00b7call16777216, 16777216)\nCALLFN(\u00b7call33554432, 33554432)\nCALLFN(\u00b7call67108864, 67108864)\nCALLFN(\u00b7call134217728, 134217728)\nCALLFN(\u00b7call268435456, 268435456)\nCALLFN(\u00b7call536870912, 536870912)\nCALLFN(\u00b7call1073741824, 1073741824)\n\n// void jmpdefer(fn, sp);\n// called from deferreturn.\n// 1. grab stored LR for caller\n// 2. sub 4 bytes to get back to BL deferreturn\n// 3. B to fn\n// TODO(rsc): Push things on stack and then use pop\n// to load all registers simultaneously, so that a profiling\n// interrupt can never see mismatched SP/LR/PC.\n// (And double-check that pop is atomic in that way.)\nTEXT runtime\u00b7jmpdefer(SB),NOSPLIT,$0-8\n\tMOVW\t0(R13), LR\n\tMOVW\t$-4(LR), LR\t// BL deferreturn\n\tMOVW\tfv+0(FP), R7\n\tMOVW\targp+4(FP), R13\n\tMOVW\t$-4(R13), R13\t// SP is 4 below argp, due to saved LR\n\tMOVW\t0(R7), R1\n\tB\t(R1)\n\n// Save state of caller into g->sched. Smashes R11.\nTEXT gosave<>(SB),NOSPLIT|NOFRAME,$0\n\tMOVW\tLR, (g_sched+gobuf_pc)(g)\n\tMOVW\tR13, (g_sched+gobuf_sp)(g)\n\tMOVW\t$0, R11\n\tMOVW\tR11, (g_sched+gobuf_lr)(g)\n\tMOVW\tR11, (g_sched+gobuf_ret)(g)\n\tMOVW\tR11, (g_sched+gobuf_ctxt)(g)\n\t// Assert ctxt is zero. See func save.\n\tMOVW\t(g_sched+gobuf_ctxt)(g), R11\n\tCMP\t$0, R11\n\tB.EQ\t2(PC)\n\tCALL\truntime\u00b7badctxt(SB)\n\tRET\n\n// func asmcgocall(fn, arg unsafe.Pointer) int32\n// Call fn(arg) on the scheduler stack,\n// aligned appropriately for the gcc ABI.\n// See cgocall.go for more details.\nTEXT \u00b7asmcgocall(SB),NOSPLIT,$0-12\n\tMOVW\tfn+0(FP), R1\n\tMOVW\targ+4(FP), R0\n\n\tMOVW\tR13, R2\n\tCMP\t$0, g\n\tBEQ nosave\n\tMOVW\tg, R4\n\n\t// Figure out if we need to switch to m->g0 stack.\n\t// We get called to create new OS threads too, and those\n\t// come in on the m->g0 stack already.\n\tMOVW\tg_m(g), R8\n\tMOVW\tm_gsignal(R8), R3\n\tCMP\tR3, g\n\tBEQ\tnosave\n\tMOVW\tm_g0(R8), R3\n\tCMP\tR3, g\n\tBEQ\tnosave\n\tBL\tgosave<>(SB)\n\tMOVW\tR0, R5\n\tMOVW\tR3, R0\n\tBL\tsetg<>(SB)\n\tMOVW\tR5, R0\n\tMOVW\t(g_sched+gobuf_sp)(g), R13\n\n\t// Now on a scheduling stack (a pthread-created stack).\n\tSUB\t$24, R13\n\tBIC\t$0x7, R13\t// alignment for gcc ABI\n\tMOVW\tR4, 20(R13) // save old g\n\tMOVW\t(g_stack+stack_hi)(R4), R4\n\tSUB\tR2, R4\n\tMOVW\tR4, 16(R13)\t// save depth in stack (can't just save SP, as stack might be copied during a callback)\n\tBL\t(R1)\n\n\t// Restore registers, g, stack pointer.\n\tMOVW\tR0, R5\n\tMOVW\t20(R13), R0\n\tBL\tsetg<>(SB)\n\tMOVW\t(g_stack+stack_hi)(g), R1\n\tMOVW\t16(R13), R2\n\tSUB\tR2, R1\n\tMOVW\tR5, R0\n\tMOVW\tR1, R13\n\n\tMOVW\tR0, ret+8(FP)\n\tRET\n\nnosave:\n\t// Running on a system stack, perhaps even without a g.\n\t// Having no g can happen during thread creation or thread teardown\n\t// (see needm/dropm on Solaris, for example).\n\t// This code is like the above sequence but without saving/restoring g\n\t// and without worrying about the stack moving out from under us\n\t// (because we're on a system stack, not a goroutine stack).\n\t// The above code could be used directly if already on a system stack,\n\t// but then the only path through this code would be a rare case on Solaris.\n\t// Using this code for all \"already on system stack\" calls exercises it more,\n\t// which should help keep it correct.\n\tSUB\t$24, R13\n\tBIC\t$0x7, R13\t// alignment for gcc ABI\n\t// save null g in case someone looks during debugging.\n\tMOVW\t$0, R4\n\tMOVW\tR4, 20(R13)\n\tMOVW\tR2, 16(R13)\t// Save old stack pointer.\n\tBL\t(R1)\n\t// Restore stack pointer.\n\tMOVW\t16(R13), R2\n\tMOVW\tR2, R13\n\tMOVW\tR0, ret+8(FP)\n\tRET\n\n// cgocallback(void (*fn)(void*), void *frame, uintptr framesize, uintptr ctxt)\n// Turn the fn into a Go func (by taking its address) and call\n// cgocallback_gofunc.\nTEXT runtime\u00b7cgocallback(SB),NOSPLIT,$16-16\n\tMOVW\t$fn+0(FP), R0\n\tMOVW\tR0, 4(R13)\n\tMOVW\tframe+4(FP), R0\n\tMOVW\tR0, 8(R13)\n\tMOVW\tframesize+8(FP), R0\n\tMOVW\tR0, 12(R13)\n\tMOVW\tctxt+12(FP), R0\n\tMOVW\tR0, 16(R13)\n\tMOVW\t$runtime\u00b7cgocallback_gofunc(SB), R0\n\tBL\t(R0)\n\tRET\n\n// cgocallback_gofunc(void (*fn)(void*), void *frame, uintptr framesize, uintptr ctxt)\n// See cgocall.go for more details.\nTEXT\t\u00b7cgocallback_gofunc(SB),NOSPLIT,$8-16\n\tNO_LOCAL_POINTERS\n\n\t// Load m and g from thread-local storage.\n\tMOVB\truntime\u00b7iscgo(SB), R0\n\tCMP\t$0, R0\n\tBL.NE\truntime\u00b7load_g(SB)\n\n\t// If g is nil, Go did not create the current thread.\n\t// Call needm to obtain one for temporary use.\n\t// In this case, we're running on the thread stack, so there's\n\t// lots of space, but the linker doesn't know. Hide the call from\n\t// the linker analysis by using an indirect call.\n\tCMP\t$0, g\n\tB.EQ\tneedm\n\n\tMOVW\tg_m(g), R8\n\tMOVW\tR8, savedm-4(SP)\n\tB\thavem\n\nneedm:\n\tMOVW\tg, savedm-4(SP) // g is zero, so is m.\n\tMOVW\t$runtime\u00b7needm(SB), R0\n\tBL\t(R0)\n\n\t// Set m->sched.sp = SP, so that if a panic happens\n\t// during the function we are about to execute, it will\n\t// have a valid SP to run on the g0 stack.\n\t// The next few lines (after the havem label)\n\t// will save this SP onto the stack and then write\n\t// the same SP back to m->sched.sp. That seems redundant,\n\t// but if an unrecovered panic happens, unwindm will\n\t// restore the g->sched.sp from the stack location\n\t// and then systemstack will try to use it. If we don't set it here,\n\t// that restored SP will be uninitialized (typically 0) and\n\t// will not be usable.\n\tMOVW\tg_m(g), R8\n\tMOVW\tm_g0(R8), R3\n\tMOVW\tR13, (g_sched+gobuf_sp)(R3)\n\nhavem:\n\t// Now there's a valid m, and we're running on its m->g0.\n\t// Save current m->g0->sched.sp on stack and then set it to SP.\n\t// Save current sp in m->g0->sched.sp in preparation for\n\t// switch back to m->curg stack.\n\t// NOTE: unwindm knows that the saved g->sched.sp is at 4(R13) aka savedsp-8(SP).\n\tMOVW\tm_g0(R8), R3\n\tMOVW\t(g_sched+gobuf_sp)(R3), R4\n\tMOVW\tR4, savedsp-8(SP)\n\tMOVW\tR13, (g_sched+gobuf_sp)(R3)\n\n\t// Switch to m->curg stack and call runtime.cgocallbackg.\n\t// Because we are taking over the execution of m->curg\n\t// but *not* resuming what had been running, we need to\n\t// save that information (m->curg->sched) so we can restore it.\n\t// We can restore m->curg->sched.sp easily, because calling\n\t// runtime.cgocallbackg leaves SP unchanged upon return.\n\t// To save m->curg->sched.pc, we push it onto the stack.\n\t// This has the added benefit that it looks to the traceback\n\t// routine like cgocallbackg is going to return to that\n\t// PC (because the frame we allocate below has the same\n\t// size as cgocallback_gofunc's frame declared above)\n\t// so that the traceback will seamlessly trace back into\n\t// the earlier calls.\n\t//\n\t// In the new goroutine, -4(SP) is unused (where SP refers to\n\t// m->curg's SP while we're setting it up, before we've adjusted it).\n\tMOVW\tm_curg(R8), R0\n\tBL\tsetg<>(SB)\n\tMOVW\t(g_sched+gobuf_sp)(g), R4 // prepare stack as R4\n\tMOVW\t(g_sched+gobuf_pc)(g), R5\n\tMOVW\tR5, -12(R4)\n\tMOVW\tctxt+12(FP), R0\n\tMOVW\tR0, -8(R4)\n\tMOVW\t$-12(R4), R13\n\tBL\truntime\u00b7cgocallbackg(SB)\n\n\t// Restore g->sched (== m->curg->sched) from saved values.\n\tMOVW\t0(R13), R5\n\tMOVW\tR5, (g_sched+gobuf_pc)(g)\n\tMOVW\t$12(R13), R4\n\tMOVW\tR4, (g_sched+gobuf_sp)(g)\n\n\t// Switch back to m->g0's stack and restore m->g0->sched.sp.\n\t// (Unlike m->curg, the g0 goroutine never uses sched.pc,\n\t// so we do not have to restore it.)\n\tMOVW\tg_m(g), R8\n\tMOVW\tm_g0(R8), R0\n\tBL\tsetg<>(SB)\n\tMOVW\t(g_sched+gobuf_sp)(g), R13\n\tMOVW\tsavedsp-8(SP), R4\n\tMOVW\tR4, (g_sched+gobuf_sp)(g)\n\n\t// If the m on entry was nil, we called needm above to borrow an m\n\t// for the duration of the call. Since the call is over, return it with dropm.\n\tMOVW\tsavedm-4(SP), R6\n\tCMP\t$0, R6\n\tB.NE\t3(PC)\n\tMOVW\t$runtime\u00b7dropm(SB), R0\n\tBL\t(R0)\n\n\t// Done!\n\tRET\n\n// void setg(G*); set g. for use by needm.\nTEXT runtime\u00b7setg(SB),NOSPLIT|NOFRAME,$0-4\n\tMOVW\tgg+0(FP), R0\n\tB\tsetg<>(SB)\n\nTEXT setg<>(SB),NOSPLIT|NOFRAME,$0-0\n\tMOVW\tR0, g\n\n\t// Save g to thread-local storage.\n#ifdef GOOS_windows\n\tB\truntime\u00b7save_g(SB)\n#else\n\tMOVB\truntime\u00b7iscgo(SB), R0\n\tCMP\t$0, R0\n\tB.EQ\t2(PC)\n\tB\truntime\u00b7save_g(SB)\n\n\tMOVW\tg, R0\n\tRET\n#endif\n\nTEXT runtime\u00b7emptyfunc(SB),0,$0-0\n\tRET\n\nTEXT runtime\u00b7abort(SB),NOSPLIT|NOFRAME,$0-0\n\tMOVW\t$0, R0\n\tMOVW\t(R0), R1\n\n// armPublicationBarrier is a native store/store barrier for ARMv7+.\n// On earlier ARM revisions, armPublicationBarrier is a no-op.\n// This will not work on SMP ARMv6 machines, if any are in use.\n// To implement publicationBarrier in sys_$GOOS_arm.s using the native\n// instructions, use:\n//\n//\tTEXT \u00b7publicationBarrier(SB),NOSPLIT|NOFRAME,$0-0\n//\t\tB\truntime\u00b7armPublicationBarrier(SB)\n//\nTEXT runtime\u00b7armPublicationBarrier(SB),NOSPLIT|NOFRAME,$0-0\n\tMOVB\truntime\u00b7goarm(SB), R11\n\tCMP\t$7, R11\n\tBLT\t2(PC)\n\tDMB\tMB_ST\n\tRET\n\n// AES hashing not implemented for ARM\nTEXT runtime\u00b7aeshash(SB),NOSPLIT|NOFRAME,$0-0\n\tMOVW\t$0, R0\n\tMOVW\t(R0), R1\nTEXT runtime\u00b7aeshash32(SB),NOSPLIT|NOFRAME,$0-0\n\tMOVW\t$0, R0\n\tMOVW\t(R0), R1\nTEXT runtime\u00b7aeshash64(SB),NOSPLIT|NOFRAME,$0-0\n\tMOVW\t$0, R0\n\tMOVW\t(R0), R1\nTEXT runtime\u00b7aeshashstr(SB),NOSPLIT|NOFRAME,$0-0\n\tMOVW\t$0, R0\n\tMOVW\t(R0), R1\n\nTEXT runtime\u00b7return0(SB),NOSPLIT,$0\n\tMOVW\t$0, R0\n\tRET\n\nTEXT runtime\u00b7procyield(SB),NOSPLIT|NOFRAME,$0\n\tMOVW\tcycles+0(FP), R1\n\tMOVW\t$0, R0\nyieldloop:\n\tWORD\t$0xe320f001\t// YIELD (NOP pre-ARMv6K)\n\tCMP\tR0, R1\n\tB.NE\t2(PC)\n\tRET\n\tSUB\t$1, R1\n\tB yieldloop\n\n// Called from cgo wrappers, this function returns g->m->curg.stack.hi.\n// Must obey the gcc calling convention.\nTEXT _cgo_topofstack(SB),NOSPLIT,$8\n\t// R11 and g register are clobbered by load_g. They are\n\t// callee-save in the gcc calling convention, so save them here.\n\tMOVW\tR11, saveR11-4(SP)\n\tMOVW\tg, saveG-8(SP)\n\n\tBL\truntime\u00b7load_g(SB)\n\tMOVW\tg_m(g), R0\n\tMOVW\tm_curg(R0), R0\n\tMOVW\t(g_stack+stack_hi)(R0), R0\n\n\tMOVW\tsaveG-8(SP), g\n\tMOVW\tsaveR11-4(SP), R11\n\tRET\n\n// The top-most function running on a goroutine\n// returns to goexit+PCQuantum.\nTEXT runtime\u00b7goexit(SB),NOSPLIT|NOFRAME,$0-0\n\tMOVW\tR0, R0\t// NOP\n\tBL\truntime\u00b7goexit1(SB)\t// does not return\n\t// traceback from goexit1 must hit code range of goexit\n\tMOVW\tR0, R0\t// NOP\n\n// x -> x/1000000, x%1000000, called from Go with args, results on stack.\nTEXT runtime\u00b7usplit(SB),NOSPLIT,$0-12\n\tMOVW\tx+0(FP), R0\n\tCALL\truntime\u00b7usplitR0(SB)\n\tMOVW\tR0, q+4(FP)\n\tMOVW\tR1, r+8(FP)\n\tRET\n\n// R0, R1 = R0/1000000, R0%1000000\nTEXT runtime\u00b7usplitR0(SB),NOSPLIT,$0\n\t// magic multiply to avoid software divide without available m.\n\t// see output of go tool compile -S for x/1000000.\n\tMOVW\tR0, R3\n\tMOVW\t$1125899907, R1\n\tMULLU\tR1, R0, (R0, R1)\n\tMOVW\tR0>>18, R0\n\tMOVW\t$1000000, R1\n\tMULU\tR0, R1\n\tSUB\tR1, R3, R1\n\tRET\n\nTEXT runtime\u00b7sigreturn(SB),NOSPLIT,$0-0\n\tRET\n\n#ifndef GOOS_nacl\n// This is called from .init_array and follows the platform, not Go, ABI.\nTEXT runtime\u00b7addmoduledata(SB),NOSPLIT,$0-8\n\tMOVW\tR9, saver9-4(SP) // The access to global variables below implicitly uses R9, which is callee-save\n\tMOVW\tR11, saver11-8(SP) // Likewise, R11 is the temp register, but callee-save in C ABI\n\tMOVW\truntime\u00b7lastmoduledatap(SB), R1\n\tMOVW\tR0, moduledata_next(R1)\n\tMOVW\tR0, runtime\u00b7lastmoduledatap(SB)\n\tMOVW\tsaver11-8(SP), R11\n\tMOVW\tsaver9-4(SP), R9\n\tRET\n#endif\n\nTEXT \u00b7checkASM(SB),NOSPLIT,$0-1\n\tMOVW\t$1, R3\n\tMOVB\tR3, ret+0(FP)\n\tRET\n\n// gcWriteBarrier performs a heap pointer write and informs the GC.\n//\n// gcWriteBarrier does NOT follow the Go ABI. It takes two arguments:\n// - R2 is the destination of the write\n// - R3 is the value being written at R2\n// It clobbers condition codes.\n// It does not clobber any other general-purpose registers,\n// but may clobber others (e.g., floating point registers).\n// The act of CALLing gcWriteBarrier will clobber R14 (LR).\nTEXT runtime\u00b7gcWriteBarrier(SB),NOSPLIT|NOFRAME,$0\n\t// Save the registers clobbered by the fast path.\n\tMOVM.DB.W\t[R0,R1], (R13)\n\tMOVW\tg_m(g), R0\n\tMOVW\tm_p(R0), R0\n\tMOVW\t(p_wbBuf+wbBuf_next)(R0), R1\n\t// Increment wbBuf.next position.\n\tADD\t$8, R1\n\tMOVW\tR1, (p_wbBuf+wbBuf_next)(R0)\n\tMOVW\t(p_wbBuf+wbBuf_end)(R0), R0\n\tCMP\tR1, R0\n\t// Record the write.\n\tMOVW\tR3, -8(R1)\t// Record value\n\tMOVW\t(R2), R0\t// TODO: This turns bad writes into bad reads.\n\tMOVW\tR0, -4(R1)\t// Record *slot\n\t// Is the buffer full? (flags set in CMP above)\n\tB.EQ\tflush\nret:\n\tMOVM.IA.W\t(R13), [R0,R1]\n\t// Do the write.\n\tMOVW\tR3, (R2)\n\t// Normally RET on nacl clobbers R12, but because this\n\t// function has no frame it doesn't have to usual epilogue.\n\tRET\n\nflush:\n\t// Save all general purpose registers since these could be\n\t// clobbered by wbBufFlush and were not saved by the caller.\n\t//\n\t// R0 and R1 were saved at entry.\n\t// R10 is g, so preserved.\n\t// R11 is linker temp, so no need to save.\n\t// R13 is stack pointer.\n\t// R15 is PC.\n\t//\n\t// This also sets up R2 and R3 as the arguments to wbBufFlush.\n\tMOVM.DB.W\t[R2-R9,R12], (R13)\n\t// Save R14 (LR) because the fast path above doesn't save it,\n\t// but needs it to RET. This is after the MOVM so it appears below\n\t// the arguments in the stack frame.\n\tMOVM.DB.W\t[R14], (R13)\n\n\t// This takes arguments R2 and R3.\n\tCALL\truntime\u00b7wbBufFlush(SB)\n\n\tMOVM.IA.W\t(R13), [R14]\n\tMOVM.IA.W\t(R13), [R2-R9,R12]\n\tJMP\tret\n",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/cmd/link/internal/ld/lib.go": "// Inferno utils/8l/asm.c\n// https://bitbucket.org/inferno-os/inferno-os/src/default/utils/8l/asm.c\n//\n//\tCopyright \u00a9 1994-1999 Lucent Technologies Inc.  All rights reserved.\n//\tPortions Copyright \u00a9 1995-1997 C H Forsyth (forsyth@terzarima.net)\n//\tPortions Copyright \u00a9 1997-1999 Vita Nuova Limited\n//\tPortions Copyright \u00a9 2000-2007 Vita Nuova Holdings Limited (www.vitanuova.com)\n//\tPortions Copyright \u00a9 2004,2006 Bruce Ellis\n//\tPortions Copyright \u00a9 2005-2007 C H Forsyth (forsyth@terzarima.net)\n//\tRevisions Copyright \u00a9 2000-2007 Lucent Technologies Inc. and others\n//\tPortions Copyright \u00a9 2009 The Go Authors. All rights reserved.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage ld\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"cmd/internal/bio\"\n\t\"cmd/internal/objabi\"\n\t\"cmd/internal/sys\"\n\t\"cmd/link/internal/loadelf\"\n\t\"cmd/link/internal/loadmacho\"\n\t\"cmd/link/internal/loadpe\"\n\t\"cmd/link/internal/loadxcoff\"\n\t\"cmd/link/internal/objfile\"\n\t\"cmd/link/internal/sym\"\n\t\"crypto/sha1\"\n\t\"debug/elf\"\n\t\"encoding/base64\"\n\t\"encoding/binary\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strings\"\n\t\"sync\"\n)\n\n// Data layout and relocation.\n\n// Derived from Inferno utils/6l/l.h\n// https://bitbucket.org/inferno-os/inferno-os/src/default/utils/6l/l.h\n//\n//\tCopyright \u00a9 1994-1999 Lucent Technologies Inc.  All rights reserved.\n//\tPortions Copyright \u00a9 1995-1997 C H Forsyth (forsyth@terzarima.net)\n//\tPortions Copyright \u00a9 1997-1999 Vita Nuova Limited\n//\tPortions Copyright \u00a9 2000-2007 Vita Nuova Holdings Limited (www.vitanuova.com)\n//\tPortions Copyright \u00a9 2004,2006 Bruce Ellis\n//\tPortions Copyright \u00a9 2005-2007 C H Forsyth (forsyth@terzarima.net)\n//\tRevisions Copyright \u00a9 2000-2007 Lucent Technologies Inc. and others\n//\tPortions Copyright \u00a9 2009 The Go Authors. All rights reserved.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\ntype Arch struct {\n\tFuncalign      int\n\tMaxalign       int\n\tMinalign       int\n\tDwarfregsp     int\n\tDwarfreglr     int\n\tLinuxdynld     string\n\tFreebsddynld   string\n\tNetbsddynld    string\n\tOpenbsddynld   string\n\tDragonflydynld string\n\tSolarisdynld   string\n\tAdddynrel      func(*Link, *sym.Symbol, *sym.Reloc) bool\n\tArchinit       func(*Link)\n\t// Archreloc is an arch-specific hook that assists in\n\t// relocation processing (invoked by 'relocsym'); it handles\n\t// target-specific relocation tasks. Here \"rel\" is the current\n\t// relocation being examined, \"sym\" is the symbol containing the\n\t// chunk of data to which the relocation applies, and \"off\" is the\n\t// contents of the to-be-relocated data item (from sym.P). Return\n\t// value is the appropriately relocated value (to be written back\n\t// to the same spot in sym.P) and a boolean indicating\n\t// success/failure (a failing value indicates a fatal error).\n\tArchreloc func(link *Link, rel *sym.Reloc, sym *sym.Symbol,\n\t\toffset int64) (relocatedOffset int64, success bool)\n\t// Archrelocvariant is a second arch-specific hook used for\n\t// relocation processing; it handles relocations where r.Type is\n\t// insufficient to describe the relocation (r.Variant !=\n\t// sym.RV_NONE). Here \"rel\" is the relocation being applied, \"sym\"\n\t// is the symbol containing the chunk of data to which the\n\t// relocation applies, and \"off\" is the contents of the\n\t// to-be-relocated data item (from sym.P). Return is an updated\n\t// offset value.\n\tArchrelocvariant func(link *Link, rel *sym.Reloc, sym *sym.Symbol,\n\t\toffset int64) (relocatedOffset int64)\n\tTrampoline  func(*Link, *sym.Reloc, *sym.Symbol)\n\tAsmb        func(*Link)\n\tElfreloc1   func(*Link, *sym.Reloc, int64) bool\n\tElfsetupplt func(*Link)\n\tGentext     func(*Link)\n\tMachoreloc1 func(*sys.Arch, *OutBuf, *sym.Symbol, *sym.Reloc, int64) bool\n\tPEreloc1    func(*sys.Arch, *OutBuf, *sym.Symbol, *sym.Reloc, int64) bool\n\n\t// TLSIEtoLE converts a TLS Initial Executable relocation to\n\t// a TLS Local Executable relocation.\n\t//\n\t// This is possible when a TLS IE relocation refers to a local\n\t// symbol in an executable, which is typical when internally\n\t// linking PIE binaries.\n\tTLSIEtoLE func(s *sym.Symbol, off, size int)\n\n\t// optional override for assignAddress\n\tAssignAddress func(ctxt *Link, sect *sym.Section, n int, s *sym.Symbol, va uint64, isTramp bool) (*sym.Section, int, uint64)\n}\n\nvar (\n\tthearch Arch\n\tLcsize  int32\n\trpath   Rpath\n\tSpsize  int32\n\tSymsize int32\n)\n\nconst (\n\tMINFUNC = 16 // minimum size for a function\n)\n\n// DynlinkingGo reports whether we are producing Go code that can live\n// in separate shared libraries linked together at runtime.\nfunc (ctxt *Link) DynlinkingGo() bool {\n\tif !ctxt.Loaded {\n\t\tpanic(\"DynlinkingGo called before all symbols loaded\")\n\t}\n\treturn ctxt.BuildMode == BuildModeShared || ctxt.linkShared || ctxt.BuildMode == BuildModePlugin || ctxt.CanUsePlugins()\n}\n\n// CanUsePlugins reports whether a plugins can be used\nfunc (ctxt *Link) CanUsePlugins() bool {\n\treturn ctxt.Syms.ROLookup(\"plugin.Open\", sym.SymVerABIInternal) != nil\n}\n\n// UseRelro reports whether to make use of \"read only relocations\" aka\n// relro.\nfunc (ctxt *Link) UseRelro() bool {\n\tswitch ctxt.BuildMode {\n\tcase BuildModeCArchive, BuildModeCShared, BuildModeShared, BuildModePIE, BuildModePlugin:\n\t\treturn ctxt.IsELF\n\tdefault:\n\t\treturn ctxt.linkShared\n\t}\n}\n\nvar (\n\tdynexp          []*sym.Symbol\n\tdynlib          []string\n\tldflag          []string\n\thavedynamic     int\n\tFuncalign       int\n\tiscgo           bool\n\telfglobalsymndx int\n\tinterpreter     string\n\n\tdebug_s bool // backup old value of debug['s']\n\tHEADR   int32\n\n\tnerrors  int\n\tliveness int64\n)\n\nvar (\n\tSegtext      sym.Segment\n\tSegrodata    sym.Segment\n\tSegrelrodata sym.Segment\n\tSegdata      sym.Segment\n\tSegdwarf     sym.Segment\n)\n\nconst pkgdef = \"__.PKGDEF\"\n\nvar (\n\t// Set if we see an object compiled by the host compiler that is not\n\t// from a package that is known to support internal linking mode.\n\texternalobj = false\n\ttheline     string\n)\n\nfunc Lflag(ctxt *Link, arg string) {\n\tctxt.Libdir = append(ctxt.Libdir, arg)\n}\n\n/*\n * Unix doesn't like it when we write to a running (or, sometimes,\n * recently run) binary, so remove the output file before writing it.\n * On Windows 7, remove() can force a subsequent create() to fail.\n * S_ISREG() does not exist on Plan 9.\n */\nfunc mayberemoveoutfile() {\n\tif fi, err := os.Lstat(*flagOutfile); err == nil && !fi.Mode().IsRegular() {\n\t\treturn\n\t}\n\tos.Remove(*flagOutfile)\n}\n\nfunc libinit(ctxt *Link) {\n\tFuncalign = thearch.Funcalign\n\n\t// add goroot to the end of the libdir list.\n\tsuffix := \"\"\n\n\tsuffixsep := \"\"\n\tif *flagInstallSuffix != \"\" {\n\t\tsuffixsep = \"_\"\n\t\tsuffix = *flagInstallSuffix\n\t} else if *flagRace {\n\t\tsuffixsep = \"_\"\n\t\tsuffix = \"race\"\n\t} else if *flagMsan {\n\t\tsuffixsep = \"_\"\n\t\tsuffix = \"msan\"\n\t}\n\n\tLflag(ctxt, filepath.Join(objabi.GOROOT, \"pkg\", fmt.Sprintf(\"%s_%s%s%s\", objabi.GOOS, objabi.GOARCH, suffixsep, suffix)))\n\n\tmayberemoveoutfile()\n\tf, err := os.OpenFile(*flagOutfile, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0775)\n\tif err != nil {\n\t\tExitf(\"cannot create %s: %v\", *flagOutfile, err)\n\t}\n\n\tctxt.Out.w = bufio.NewWriter(f)\n\tctxt.Out.f = f\n\n\tif *flagEntrySymbol == \"\" {\n\t\tswitch ctxt.BuildMode {\n\t\tcase BuildModeCShared, BuildModeCArchive:\n\t\t\t*flagEntrySymbol = fmt.Sprintf(\"_rt0_%s_%s_lib\", objabi.GOARCH, objabi.GOOS)\n\t\tcase BuildModeExe, BuildModePIE:\n\t\t\t*flagEntrySymbol = fmt.Sprintf(\"_rt0_%s_%s\", objabi.GOARCH, objabi.GOOS)\n\t\tcase BuildModeShared, BuildModePlugin:\n\t\t\t// No *flagEntrySymbol for -buildmode=shared and plugin\n\t\tdefault:\n\t\t\tErrorf(nil, \"unknown *flagEntrySymbol for buildmode %v\", ctxt.BuildMode)\n\t\t}\n\t}\n}\n\nfunc errorexit() {\n\tif nerrors != 0 {\n\t\tExit(2)\n\t}\n\tExit(0)\n}\n\nfunc loadinternal(ctxt *Link, name string) *sym.Library {\n\tif ctxt.linkShared && ctxt.PackageShlib != nil {\n\t\tif shlib := ctxt.PackageShlib[name]; shlib != \"\" {\n\t\t\treturn addlibpath(ctxt, \"internal\", \"internal\", \"\", name, shlib)\n\t\t}\n\t}\n\tif ctxt.PackageFile != nil {\n\t\tif pname := ctxt.PackageFile[name]; pname != \"\" {\n\t\t\treturn addlibpath(ctxt, \"internal\", \"internal\", pname, name, \"\")\n\t\t}\n\t\tctxt.Logf(\"loadinternal: cannot find %s\\n\", name)\n\t\treturn nil\n\t}\n\n\tfor _, libdir := range ctxt.Libdir {\n\t\tif ctxt.linkShared {\n\t\t\tshlibname := filepath.Join(libdir, name+\".shlibname\")\n\t\t\tif ctxt.Debugvlog != 0 {\n\t\t\t\tctxt.Logf(\"searching for %s.a in %s\\n\", name, shlibname)\n\t\t\t}\n\t\t\tif _, err := os.Stat(shlibname); err == nil {\n\t\t\t\treturn addlibpath(ctxt, \"internal\", \"internal\", \"\", name, shlibname)\n\t\t\t}\n\t\t}\n\t\tpname := filepath.Join(libdir, name+\".a\")\n\t\tif ctxt.Debugvlog != 0 {\n\t\t\tctxt.Logf(\"searching for %s.a in %s\\n\", name, pname)\n\t\t}\n\t\tif _, err := os.Stat(pname); err == nil {\n\t\t\treturn addlibpath(ctxt, \"internal\", \"internal\", pname, name, \"\")\n\t\t}\n\t}\n\n\tctxt.Logf(\"warning: unable to find %s.a\\n\", name)\n\treturn nil\n}\n\n// findLibPathCmd uses cmd command to find gcc library libname.\n// It returns library full path if found, or \"none\" if not found.\nfunc (ctxt *Link) findLibPathCmd(cmd, libname string) string {\n\tif *flagExtld == \"\" {\n\t\t*flagExtld = \"gcc\"\n\t}\n\targs := hostlinkArchArgs(ctxt.Arch)\n\targs = append(args, cmd)\n\tif ctxt.Debugvlog != 0 {\n\t\tctxt.Logf(\"%s %v\\n\", *flagExtld, args)\n\t}\n\tout, err := exec.Command(*flagExtld, args...).Output()\n\tif err != nil {\n\t\tif ctxt.Debugvlog != 0 {\n\t\t\tctxt.Logf(\"not using a %s file because compiler failed\\n%v\\n%s\\n\", libname, err, out)\n\t\t}\n\t\treturn \"none\"\n\t}\n\treturn strings.TrimSpace(string(out))\n}\n\n// findLibPath searches for library libname.\n// It returns library full path if found, or \"none\" if not found.\nfunc (ctxt *Link) findLibPath(libname string) string {\n\treturn ctxt.findLibPathCmd(\"--print-file-name=\"+libname, libname)\n}\n\nfunc (ctxt *Link) loadlib() {\n\tswitch ctxt.BuildMode {\n\tcase BuildModeCShared, BuildModePlugin:\n\t\ts := ctxt.Syms.Lookup(\"runtime.islibrary\", 0)\n\t\ts.Attr |= sym.AttrDuplicateOK\n\t\ts.AddUint8(1)\n\tcase BuildModeCArchive:\n\t\ts := ctxt.Syms.Lookup(\"runtime.isarchive\", 0)\n\t\ts.Attr |= sym.AttrDuplicateOK\n\t\ts.AddUint8(1)\n\t}\n\n\tloadinternal(ctxt, \"runtime\")\n\tif ctxt.Arch.Family == sys.ARM {\n\t\tloadinternal(ctxt, \"math\")\n\t}\n\tif *flagRace {\n\t\tloadinternal(ctxt, \"runtime/race\")\n\t}\n\tif *flagMsan {\n\t\tloadinternal(ctxt, \"runtime/msan\")\n\t}\n\n\t// ctxt.Library grows during the loop, so not a range loop.\n\tfor i := 0; i < len(ctxt.Library); i++ {\n\t\tlib := ctxt.Library[i]\n\t\tif lib.Shlib == \"\" {\n\t\t\tif ctxt.Debugvlog > 1 {\n\t\t\t\tctxt.Logf(\"%5.2f autolib: %s (from %s)\\n\", Cputime(), lib.File, lib.Objref)\n\t\t\t}\n\t\t\tloadobjfile(ctxt, lib)\n\t\t}\n\t}\n\n\tfor _, lib := range ctxt.Library {\n\t\tif lib.Shlib != \"\" {\n\t\t\tif ctxt.Debugvlog > 1 {\n\t\t\t\tctxt.Logf(\"%5.2f autolib: %s (from %s)\\n\", Cputime(), lib.Shlib, lib.Objref)\n\t\t\t}\n\t\t\tldshlibsyms(ctxt, lib.Shlib)\n\t\t}\n\t}\n\n\tiscgo = ctxt.Syms.ROLookup(\"x_cgo_init\", 0) != nil\n\n\t// We now have enough information to determine the link mode.\n\tdetermineLinkMode(ctxt)\n\n\t// Recalculate pe parameters now that we have ctxt.LinkMode set.\n\tif ctxt.HeadType == objabi.Hwindows {\n\t\tPeinit(ctxt)\n\t}\n\n\tif ctxt.HeadType == objabi.Hdarwin && ctxt.LinkMode == LinkExternal {\n\t\t*FlagTextAddr = 0\n\t}\n\n\tif ctxt.LinkMode == LinkExternal && ctxt.Arch.Family == sys.PPC64 {\n\t\ttoc := ctxt.Syms.Lookup(\".TOC.\", 0)\n\t\ttoc.Type = sym.SDYNIMPORT\n\t}\n\n\tif ctxt.LinkMode == LinkExternal && !iscgo && ctxt.LibraryByPkg[\"runtime/cgo\"] == nil && !(objabi.GOOS == \"darwin\" && (ctxt.Arch.Family == sys.AMD64 || ctxt.Arch.Family == sys.I386)) {\n\t\t// This indicates a user requested -linkmode=external.\n\t\t// The startup code uses an import of runtime/cgo to decide\n\t\t// whether to initialize the TLS.  So give it one. This could\n\t\t// be handled differently but it's an unusual case.\n\t\tif lib := loadinternal(ctxt, \"runtime/cgo\"); lib != nil {\n\t\t\tif lib.Shlib != \"\" {\n\t\t\t\tldshlibsyms(ctxt, lib.Shlib)\n\t\t\t} else {\n\t\t\t\tif ctxt.BuildMode == BuildModeShared || ctxt.linkShared {\n\t\t\t\t\tExitf(\"cannot implicitly include runtime/cgo in a shared library\")\n\t\t\t\t}\n\t\t\t\tloadobjfile(ctxt, lib)\n\t\t\t}\n\t\t}\n\t}\n\n\tif ctxt.LinkMode == LinkInternal {\n\t\t// Drop all the cgo_import_static declarations.\n\t\t// Turns out we won't be needing them.\n\t\tfor _, s := range ctxt.Syms.Allsym {\n\t\t\tif s.Type == sym.SHOSTOBJ {\n\t\t\t\t// If a symbol was marked both\n\t\t\t\t// cgo_import_static and cgo_import_dynamic,\n\t\t\t\t// then we want to make it cgo_import_dynamic\n\t\t\t\t// now.\n\t\t\t\tif s.Extname() != \"\" && s.Dynimplib() != \"\" && !s.Attr.CgoExport() {\n\t\t\t\t\ts.Type = sym.SDYNIMPORT\n\t\t\t\t} else {\n\t\t\t\t\ts.Type = 0\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\ttlsg := ctxt.Syms.Lookup(\"runtime.tlsg\", 0)\n\n\t// runtime.tlsg is used for external linking on platforms that do not define\n\t// a variable to hold g in assembly (currently only intel).\n\tif tlsg.Type == 0 {\n\t\ttlsg.Type = sym.STLSBSS\n\t\ttlsg.Size = int64(ctxt.Arch.PtrSize)\n\t} else if tlsg.Type != sym.SDYNIMPORT {\n\t\tErrorf(nil, \"runtime declared tlsg variable %v\", tlsg.Type)\n\t}\n\ttlsg.Attr |= sym.AttrReachable\n\tctxt.Tlsg = tlsg\n\n\tvar moduledata *sym.Symbol\n\tif ctxt.BuildMode == BuildModePlugin {\n\t\tmoduledata = ctxt.Syms.Lookup(\"local.pluginmoduledata\", 0)\n\t\tmoduledata.Attr |= sym.AttrLocal\n\t} else {\n\t\tmoduledata = ctxt.Syms.Lookup(\"runtime.firstmoduledata\", 0)\n\t}\n\tif moduledata.Type != 0 && moduledata.Type != sym.SDYNIMPORT {\n\t\t// If the module (toolchain-speak for \"executable or shared\n\t\t// library\") we are linking contains the runtime package, it\n\t\t// will define the runtime.firstmoduledata symbol and we\n\t\t// truncate it back to 0 bytes so we can define its entire\n\t\t// contents in symtab.go:symtab().\n\t\tmoduledata.Size = 0\n\n\t\t// In addition, on ARM, the runtime depends on the linker\n\t\t// recording the value of GOARM.\n\t\tif ctxt.Arch.Family == sys.ARM {\n\t\t\ts := ctxt.Syms.Lookup(\"runtime.goarm\", 0)\n\t\t\ts.Type = sym.SDATA\n\t\t\ts.Size = 0\n\t\t\ts.AddUint8(uint8(objabi.GOARM))\n\t\t}\n\n\t\tif objabi.Framepointer_enabled(objabi.GOOS, objabi.GOARCH) {\n\t\t\ts := ctxt.Syms.Lookup(\"runtime.framepointer_enabled\", 0)\n\t\t\ts.Type = sym.SDATA\n\t\t\ts.Size = 0\n\t\t\ts.AddUint8(1)\n\t\t}\n\t} else {\n\t\t// If OTOH the module does not contain the runtime package,\n\t\t// create a local symbol for the moduledata.\n\t\tmoduledata = ctxt.Syms.Lookup(\"local.moduledata\", 0)\n\t\tmoduledata.Attr |= sym.AttrLocal\n\t}\n\t// In all cases way we mark the moduledata as noptrdata to hide it from\n\t// the GC.\n\tmoduledata.Type = sym.SNOPTRDATA\n\tmoduledata.Attr |= sym.AttrReachable\n\tctxt.Moduledata = moduledata\n\n\t// Now that we know the link mode, trim the dynexp list.\n\tx := sym.AttrCgoExportDynamic\n\n\tif ctxt.LinkMode == LinkExternal {\n\t\tx = sym.AttrCgoExportStatic\n\t}\n\tw := 0\n\tfor i := range dynexp {\n\t\tif dynexp[i].Attr&x != 0 {\n\t\t\tdynexp[w] = dynexp[i]\n\t\t\tw++\n\t\t}\n\t}\n\tdynexp = dynexp[:w]\n\n\t// In internal link mode, read the host object files.\n\tif ctxt.LinkMode == LinkInternal {\n\t\thostobjs(ctxt)\n\n\t\t// If we have any undefined symbols in external\n\t\t// objects, try to read them from the libgcc file.\n\t\tany := false\n\t\tfor _, s := range ctxt.Syms.Allsym {\n\t\t\tfor i := range s.R {\n\t\t\t\tr := &s.R[i] // Copying sym.Reloc has measurable impact on performance\n\t\t\t\tif r.Sym != nil && r.Sym.Type == sym.SXREF && r.Sym.Name != \".got\" {\n\t\t\t\t\tany = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif any {\n\t\t\tif *flagLibGCC == \"\" {\n\t\t\t\t*flagLibGCC = ctxt.findLibPathCmd(\"--print-libgcc-file-name\", \"libgcc\")\n\t\t\t}\n\t\t\tif runtime.GOOS == \"openbsd\" && *flagLibGCC == \"libgcc.a\" {\n\t\t\t\t// On OpenBSD `clang --print-libgcc-file-name` returns \"libgcc.a\".\n\t\t\t\t// In this case we fail to load libgcc.a and can encounter link\n\t\t\t\t// errors - see if we can find libcompiler_rt.a instead.\n\t\t\t\t*flagLibGCC = ctxt.findLibPathCmd(\"--print-file-name=libcompiler_rt.a\", \"libcompiler_rt\")\n\t\t\t}\n\t\t\tif *flagLibGCC != \"none\" {\n\t\t\t\thostArchive(ctxt, *flagLibGCC)\n\t\t\t}\n\t\t\tif ctxt.HeadType == objabi.Hwindows {\n\t\t\t\tif p := ctxt.findLibPath(\"libmingwex.a\"); p != \"none\" {\n\t\t\t\t\thostArchive(ctxt, p)\n\t\t\t\t}\n\t\t\t\tif p := ctxt.findLibPath(\"libmingw32.a\"); p != \"none\" {\n\t\t\t\t\thostArchive(ctxt, p)\n\t\t\t\t}\n\t\t\t\t// TODO: maybe do something similar to peimporteddlls to collect all lib names\n\t\t\t\t// and try link them all to final exe just like libmingwex.a and libmingw32.a:\n\t\t\t\t/*\n\t\t\t\t\tfor:\n\t\t\t\t\t#cgo windows LDFLAGS: -lmsvcrt -lm\n\t\t\t\t\timport:\n\t\t\t\t\tlibmsvcrt.a libm.a\n\t\t\t\t*/\n\t\t\t}\n\t\t}\n\t} else {\n\t\thostlinksetup(ctxt)\n\t}\n\n\t// We've loaded all the code now.\n\tctxt.Loaded = true\n\n\t// If there are no dynamic libraries needed, gcc disables dynamic linking.\n\t// Because of this, glibc's dynamic ELF loader occasionally (like in version 2.13)\n\t// assumes that a dynamic binary always refers to at least one dynamic library.\n\t// Rather than be a source of test cases for glibc, disable dynamic linking\n\t// the same way that gcc would.\n\t//\n\t// Exception: on OS X, programs such as Shark only work with dynamic\n\t// binaries, so leave it enabled on OS X (Mach-O) binaries.\n\t// Also leave it enabled on Solaris which doesn't support\n\t// statically linked binaries.\n\tif ctxt.BuildMode == BuildModeExe {\n\t\tif havedynamic == 0 && ctxt.HeadType != objabi.Hdarwin && ctxt.HeadType != objabi.Hsolaris {\n\t\t\t*FlagD = true\n\t\t}\n\t}\n\n\t// If package versioning is required, generate a hash of the\n\t// packages used in the link.\n\tif ctxt.BuildMode == BuildModeShared || ctxt.BuildMode == BuildModePlugin || ctxt.CanUsePlugins() {\n\t\tfor _, lib := range ctxt.Library {\n\t\t\tif lib.Shlib == \"\" {\n\t\t\t\tgenhash(ctxt, lib)\n\t\t\t}\n\t\t}\n\t}\n\n\tif ctxt.Arch == sys.Arch386 && ctxt.HeadType != objabi.Hwindows {\n\t\tif (ctxt.BuildMode == BuildModeCArchive && ctxt.IsELF) || ctxt.BuildMode == BuildModeCShared || ctxt.BuildMode == BuildModePIE || ctxt.DynlinkingGo() {\n\t\t\tgot := ctxt.Syms.Lookup(\"_GLOBAL_OFFSET_TABLE_\", 0)\n\t\t\tgot.Type = sym.SDYNIMPORT\n\t\t\tgot.Attr |= sym.AttrReachable\n\t\t}\n\t}\n\n\timportcycles()\n\n\t// put symbols into Textp\n\t// do it in postorder so that packages are laid down in dependency order\n\t// internal first, then everything else\n\tctxt.Library = postorder(ctxt.Library)\n\tfor _, doInternal := range [2]bool{true, false} {\n\t\tfor _, lib := range ctxt.Library {\n\t\t\tif isRuntimeDepPkg(lib.Pkg) != doInternal {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tctxt.Textp = append(ctxt.Textp, lib.Textp...)\n\t\t\tfor _, s := range lib.DupTextSyms {\n\t\t\t\tif !s.Attr.OnList() {\n\t\t\t\t\tctxt.Textp = append(ctxt.Textp, s)\n\t\t\t\t\ts.Attr |= sym.AttrOnList\n\t\t\t\t\t// dupok symbols may be defined in multiple packages. its\n\t\t\t\t\t// associated package is chosen sort of arbitrarily (the\n\t\t\t\t\t// first containing package that the linker loads). canonicalize\n\t\t\t\t\t// it here to the package with which it will be laid down\n\t\t\t\t\t// in text.\n\t\t\t\t\ts.File = objabi.PathToPrefix(lib.Pkg)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif len(ctxt.Shlibs) > 0 {\n\t\t// We might have overwritten some functions above (this tends to happen for the\n\t\t// autogenerated type equality/hashing functions) and we don't want to generated\n\t\t// pcln table entries for these any more so remove them from Textp.\n\t\ttextp := make([]*sym.Symbol, 0, len(ctxt.Textp))\n\t\tfor _, s := range ctxt.Textp {\n\t\t\tif s.Type != sym.SDYNIMPORT {\n\t\t\t\ttextp = append(textp, s)\n\t\t\t}\n\t\t}\n\t\tctxt.Textp = textp\n\t}\n\n\t// Resolve ABI aliases in the list of cgo-exported functions.\n\t// This is necessary because we load the ABI0 symbol for all\n\t// cgo exports.\n\tfor i, s := range dynexp {\n\t\tif s.Type != sym.SABIALIAS {\n\t\t\tcontinue\n\t\t}\n\t\tt := resolveABIAlias(s)\n\t\tt.Attr |= s.Attr\n\t\tt.SetExtname(s.Extname())\n\t\tdynexp[i] = t\n\t}\n}\n\n// mangleTypeSym shortens the names of symbols that represent Go types\n// if they are visible in the symbol table.\n//\n// As the names of these symbols are derived from the string of\n// the type, they can run to many kilobytes long. So we shorten\n// them using a SHA-1 when the name appears in the final binary.\n// This also removes characters that upset external linkers.\n//\n// These are the symbols that begin with the prefix 'type.' and\n// contain run-time type information used by the runtime and reflect\n// packages. All Go binaries contain these symbols, but only\n// those programs loaded dynamically in multiple parts need these\n// symbols to have entries in the symbol table.\nfunc (ctxt *Link) mangleTypeSym() {\n\tif ctxt.BuildMode != BuildModeShared && !ctxt.linkShared && ctxt.BuildMode != BuildModePlugin && !ctxt.CanUsePlugins() {\n\t\treturn\n\t}\n\n\tfor _, s := range ctxt.Syms.Allsym {\n\t\tnewName := typeSymbolMangle(s.Name)\n\t\tif newName != s.Name {\n\t\t\tctxt.Syms.Rename(s.Name, newName, int(s.Version), ctxt.Reachparent)\n\t\t}\n\t}\n}\n\n// typeSymbolMangle mangles the given symbol name into something shorter.\n//\n// Keep the type.. prefix, which parts of the linker (like the\n// DWARF generator) know means the symbol is not decodable.\n// Leave type.runtime. symbols alone, because other parts of\n// the linker manipulates them.\nfunc typeSymbolMangle(name string) string {\n\tif !strings.HasPrefix(name, \"type.\") {\n\t\treturn name\n\t}\n\tif strings.HasPrefix(name, \"type.runtime.\") {\n\t\treturn name\n\t}\n\tif len(name) <= 14 && !strings.Contains(name, \"@\") { // Issue 19529\n\t\treturn name\n\t}\n\thash := sha1.Sum([]byte(name))\n\tprefix := \"type.\"\n\tif name[5] == '.' {\n\t\tprefix = \"type..\"\n\t}\n\treturn prefix + base64.StdEncoding.EncodeToString(hash[:6])\n}\n\n/*\n * look for the next file in an archive.\n * adapted from libmach.\n */\nfunc nextar(bp *bio.Reader, off int64, a *ArHdr) int64 {\n\tif off&1 != 0 {\n\t\toff++\n\t}\n\tbp.Seek(off, 0)\n\tvar buf [SAR_HDR]byte\n\tif n, err := io.ReadFull(bp, buf[:]); err != nil {\n\t\tif n == 0 && err != io.EOF {\n\t\t\treturn -1\n\t\t}\n\t\treturn 0\n\t}\n\n\ta.name = artrim(buf[0:16])\n\ta.date = artrim(buf[16:28])\n\ta.uid = artrim(buf[28:34])\n\ta.gid = artrim(buf[34:40])\n\ta.mode = artrim(buf[40:48])\n\ta.size = artrim(buf[48:58])\n\ta.fmag = artrim(buf[58:60])\n\n\tarsize := atolwhex(a.size)\n\tif arsize&1 != 0 {\n\t\tarsize++\n\t}\n\treturn arsize + SAR_HDR\n}\n\nfunc genhash(ctxt *Link, lib *sym.Library) {\n\tf, err := bio.Open(lib.File)\n\tif err != nil {\n\t\tErrorf(nil, \"cannot open file %s for hash generation: %v\", lib.File, err)\n\t\treturn\n\t}\n\tdefer f.Close()\n\n\tvar magbuf [len(ARMAG)]byte\n\tif _, err := io.ReadFull(f, magbuf[:]); err != nil {\n\t\tExitf(\"file %s too short\", lib.File)\n\t}\n\n\tif string(magbuf[:]) != ARMAG {\n\t\tExitf(\"%s is not an archive file\", lib.File)\n\t}\n\n\tvar arhdr ArHdr\n\tl := nextar(f, f.Offset(), &arhdr)\n\tif l <= 0 {\n\t\tErrorf(nil, \"%s: short read on archive file symbol header\", lib.File)\n\t\treturn\n\t}\n\tif arhdr.name != pkgdef {\n\t\tErrorf(nil, \"%s: missing package data entry\", lib.File)\n\t\treturn\n\t}\n\n\th := sha1.New()\n\n\t// To compute the hash of a package, we hash the first line of\n\t// __.PKGDEF (which contains the toolchain version and any\n\t// GOEXPERIMENT flags) and the export data (which is between\n\t// the first two occurrences of \"\\n$$\").\n\n\tpkgDefBytes := make([]byte, atolwhex(arhdr.size))\n\t_, err = io.ReadFull(f, pkgDefBytes)\n\tif err != nil {\n\t\tErrorf(nil, \"%s: error reading package data: %v\", lib.File, err)\n\t\treturn\n\t}\n\tfirstEOL := bytes.IndexByte(pkgDefBytes, '\\n')\n\tif firstEOL < 0 {\n\t\tErrorf(nil, \"cannot parse package data of %s for hash generation, no newline found\", lib.File)\n\t\treturn\n\t}\n\tfirstDoubleDollar := bytes.Index(pkgDefBytes, []byte(\"\\n$$\"))\n\tif firstDoubleDollar < 0 {\n\t\tErrorf(nil, \"cannot parse package data of %s for hash generation, no \\\\n$$ found\", lib.File)\n\t\treturn\n\t}\n\tsecondDoubleDollar := bytes.Index(pkgDefBytes[firstDoubleDollar+1:], []byte(\"\\n$$\"))\n\tif secondDoubleDollar < 0 {\n\t\tErrorf(nil, \"cannot parse package data of %s for hash generation, only one \\\\n$$ found\", lib.File)\n\t\treturn\n\t}\n\th.Write(pkgDefBytes[0:firstEOL])\n\th.Write(pkgDefBytes[firstDoubleDollar : firstDoubleDollar+secondDoubleDollar])\n\tlib.Hash = hex.EncodeToString(h.Sum(nil))\n}\n\nfunc loadobjfile(ctxt *Link, lib *sym.Library) {\n\tpkg := objabi.PathToPrefix(lib.Pkg)\n\n\tif ctxt.Debugvlog > 1 {\n\t\tctxt.Logf(\"%5.2f ldobj: %s (%s)\\n\", Cputime(), lib.File, pkg)\n\t}\n\tf, err := bio.Open(lib.File)\n\tif err != nil {\n\t\tExitf(\"cannot open file %s: %v\", lib.File, err)\n\t}\n\tdefer f.Close()\n\tdefer func() {\n\t\tif pkg == \"main\" && !lib.Main {\n\t\t\tExitf(\"%s: not package main\", lib.File)\n\t\t}\n\n\t\t// Ideally, we'd check that *all* object files within\n\t\t// the archive were marked safe, but here we settle\n\t\t// for *any*.\n\t\t//\n\t\t// Historically, cmd/link only checked the __.PKGDEF\n\t\t// file, which in turn came from the first object\n\t\t// file, typically produced by cmd/compile. The\n\t\t// remaining object files are normally produced by\n\t\t// cmd/asm, which doesn't support marking files as\n\t\t// safe anyway. So at least in practice, this matches\n\t\t// how safe mode has always worked.\n\t\tif *flagU && !lib.Safe {\n\t\t\tExitf(\"%s: load of unsafe package %s\", lib.File, pkg)\n\t\t}\n\t}()\n\n\tfor i := 0; i < len(ARMAG); i++ {\n\t\tif c, err := f.ReadByte(); err == nil && c == ARMAG[i] {\n\t\t\tcontinue\n\t\t}\n\n\t\t/* load it as a regular file */\n\t\tl := f.Seek(0, 2)\n\t\tf.Seek(0, 0)\n\t\tldobj(ctxt, f, lib, l, lib.File, lib.File)\n\t\treturn\n\t}\n\n\t/*\n\t * load all the object files from the archive now.\n\t * this gives us sequential file access and keeps us\n\t * from needing to come back later to pick up more\n\t * objects.  it breaks the usual C archive model, but\n\t * this is Go, not C.  the common case in Go is that\n\t * we need to load all the objects, and then we throw away\n\t * the individual symbols that are unused.\n\t *\n\t * loading every object will also make it possible to\n\t * load foreign objects not referenced by __.PKGDEF.\n\t */\n\tvar arhdr ArHdr\n\toff := f.Offset()\n\tfor {\n\t\tl := nextar(f, off, &arhdr)\n\t\tif l == 0 {\n\t\t\tbreak\n\t\t}\n\t\tif l < 0 {\n\t\t\tExitf(\"%s: malformed archive\", lib.File)\n\t\t}\n\t\toff += l\n\n\t\t// __.PKGDEF isn't a real Go object file, and it's\n\t\t// absent in -linkobj builds anyway. Skipping it\n\t\t// ensures consistency between -linkobj and normal\n\t\t// build modes.\n\t\tif arhdr.name == pkgdef {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Skip other special (non-object-file) sections that\n\t\t// build tools may have added. Such sections must have\n\t\t// short names so that the suffix is not truncated.\n\t\tif len(arhdr.name) < 16 {\n\t\t\tif ext := filepath.Ext(arhdr.name); ext != \".o\" && ext != \".syso\" {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\tpname := fmt.Sprintf(\"%s(%s)\", lib.File, arhdr.name)\n\t\tl = atolwhex(arhdr.size)\n\t\tldobj(ctxt, f, lib, l, pname, lib.File)\n\t}\n}\n\ntype Hostobj struct {\n\tld     func(*Link, *bio.Reader, string, int64, string)\n\tpkg    string\n\tpn     string\n\tfile   string\n\toff    int64\n\tlength int64\n}\n\nvar hostobj []Hostobj\n\n// These packages can use internal linking mode.\n// Others trigger external mode.\nvar internalpkg = []string{\n\t\"crypto/x509\",\n\t\"net\",\n\t\"os/user\",\n\t\"runtime/cgo\",\n\t\"runtime/race\",\n\t\"runtime/msan\",\n}\n\nfunc ldhostobj(ld func(*Link, *bio.Reader, string, int64, string), headType objabi.HeadType, f *bio.Reader, pkg string, length int64, pn string, file string) *Hostobj {\n\tisinternal := false\n\tfor _, intpkg := range internalpkg {\n\t\tif pkg == intpkg {\n\t\t\tisinternal = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// DragonFly declares errno with __thread, which results in a symbol\n\t// type of R_386_TLS_GD or R_X86_64_TLSGD. The Go linker does not\n\t// currently know how to handle TLS relocations, hence we have to\n\t// force external linking for any libraries that link in code that\n\t// uses errno. This can be removed if the Go linker ever supports\n\t// these relocation types.\n\tif headType == objabi.Hdragonfly {\n\t\tif pkg == \"net\" || pkg == \"os/user\" {\n\t\t\tisinternal = false\n\t\t}\n\t}\n\n\tif !isinternal {\n\t\texternalobj = true\n\t}\n\n\thostobj = append(hostobj, Hostobj{})\n\th := &hostobj[len(hostobj)-1]\n\th.ld = ld\n\th.pkg = pkg\n\th.pn = pn\n\th.file = file\n\th.off = f.Offset()\n\th.length = length\n\treturn h\n}\n\nfunc hostobjs(ctxt *Link) {\n\tvar h *Hostobj\n\n\tfor i := 0; i < len(hostobj); i++ {\n\t\th = &hostobj[i]\n\t\tf, err := bio.Open(h.file)\n\t\tif err != nil {\n\t\t\tExitf(\"cannot reopen %s: %v\", h.pn, err)\n\t\t}\n\n\t\tf.Seek(h.off, 0)\n\t\th.ld(ctxt, f, h.pkg, h.length, h.pn)\n\t\tf.Close()\n\t}\n}\n\nfunc hostlinksetup(ctxt *Link) {\n\tif ctxt.LinkMode != LinkExternal {\n\t\treturn\n\t}\n\n\t// For external link, record that we need to tell the external linker -s,\n\t// and turn off -s internally: the external linker needs the symbol\n\t// information for its final link.\n\tdebug_s = *FlagS\n\t*FlagS = false\n\n\t// create temporary directory and arrange cleanup\n\tif *flagTmpdir == \"\" {\n\t\tdir, err := ioutil.TempDir(\"\", \"go-link-\")\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\t*flagTmpdir = dir\n\t\tAtExit(func() {\n\t\t\tctxt.Out.f.Close()\n\t\t\tos.RemoveAll(*flagTmpdir)\n\t\t})\n\t}\n\n\t// change our output to temporary object file\n\tctxt.Out.f.Close()\n\tmayberemoveoutfile()\n\n\tp := filepath.Join(*flagTmpdir, \"go.o\")\n\tvar err error\n\tf, err := os.OpenFile(p, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0775)\n\tif err != nil {\n\t\tExitf(\"cannot create %s: %v\", p, err)\n\t}\n\n\tctxt.Out.w = bufio.NewWriter(f)\n\tctxt.Out.f = f\n\tctxt.Out.off = 0\n}\n\n// hostobjCopy creates a copy of the object files in hostobj in a\n// temporary directory.\nfunc hostobjCopy() (paths []string) {\n\tvar wg sync.WaitGroup\n\tsema := make(chan struct{}, runtime.NumCPU()) // limit open file descriptors\n\tfor i, h := range hostobj {\n\t\th := h\n\t\tdst := filepath.Join(*flagTmpdir, fmt.Sprintf(\"%06d.o\", i))\n\t\tpaths = append(paths, dst)\n\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tsema <- struct{}{}\n\t\t\tdefer func() {\n\t\t\t\t<-sema\n\t\t\t\twg.Done()\n\t\t\t}()\n\t\t\tf, err := os.Open(h.file)\n\t\t\tif err != nil {\n\t\t\t\tExitf(\"cannot reopen %s: %v\", h.pn, err)\n\t\t\t}\n\t\t\tdefer f.Close()\n\t\t\tif _, err := f.Seek(h.off, 0); err != nil {\n\t\t\t\tExitf(\"cannot seek %s: %v\", h.pn, err)\n\t\t\t}\n\n\t\t\tw, err := os.Create(dst)\n\t\t\tif err != nil {\n\t\t\t\tExitf(\"cannot create %s: %v\", dst, err)\n\t\t\t}\n\t\t\tif _, err := io.CopyN(w, f, h.length); err != nil {\n\t\t\t\tExitf(\"cannot write %s: %v\", dst, err)\n\t\t\t}\n\t\t\tif err := w.Close(); err != nil {\n\t\t\t\tExitf(\"cannot close %s: %v\", dst, err)\n\t\t\t}\n\t\t}()\n\t}\n\twg.Wait()\n\treturn paths\n}\n\n// writeGDBLinkerScript creates gcc linker script file in temp\n// directory. writeGDBLinkerScript returns created file path.\n// The script is used to work around gcc bug\n// (see https://golang.org/issue/20183 for details).\nfunc writeGDBLinkerScript() string {\n\tname := \"fix_debug_gdb_scripts.ld\"\n\tpath := filepath.Join(*flagTmpdir, name)\n\tsrc := `SECTIONS\n{\n  .debug_gdb_scripts BLOCK(__section_alignment__) (NOLOAD) :\n  {\n    *(.debug_gdb_scripts)\n  }\n}\nINSERT AFTER .debug_types;\n`\n\terr := ioutil.WriteFile(path, []byte(src), 0666)\n\tif err != nil {\n\t\tErrorf(nil, \"WriteFile %s failed: %v\", name, err)\n\t}\n\treturn path\n}\n\n// archive builds a .a archive from the hostobj object files.\nfunc (ctxt *Link) archive() {\n\tif ctxt.BuildMode != BuildModeCArchive {\n\t\treturn\n\t}\n\n\tif *flagExtar == \"\" {\n\t\t*flagExtar = \"ar\"\n\t}\n\n\tmayberemoveoutfile()\n\n\t// Force the buffer to flush here so that external\n\t// tools will see a complete file.\n\tctxt.Out.Flush()\n\tif err := ctxt.Out.f.Close(); err != nil {\n\t\tExitf(\"close: %v\", err)\n\t}\n\tctxt.Out.f = nil\n\n\targv := []string{*flagExtar, \"-q\", \"-c\", \"-s\", *flagOutfile}\n\targv = append(argv, filepath.Join(*flagTmpdir, \"go.o\"))\n\targv = append(argv, hostobjCopy()...)\n\n\tif ctxt.Debugvlog != 0 {\n\t\tctxt.Logf(\"archive: %s\\n\", strings.Join(argv, \" \"))\n\t}\n\n\tif out, err := exec.Command(argv[0], argv[1:]...).CombinedOutput(); err != nil {\n\t\tExitf(\"running %s failed: %v\\n%s\", argv[0], err, out)\n\t}\n}\n\nfunc (ctxt *Link) hostlink() {\n\tif ctxt.LinkMode != LinkExternal || nerrors > 0 {\n\t\treturn\n\t}\n\tif ctxt.BuildMode == BuildModeCArchive {\n\t\treturn\n\t}\n\n\tif *flagExtld == \"\" {\n\t\t*flagExtld = \"gcc\"\n\t}\n\n\tvar argv []string\n\targv = append(argv, *flagExtld)\n\targv = append(argv, hostlinkArchArgs(ctxt.Arch)...)\n\n\tif *FlagS || debug_s {\n\t\tif ctxt.HeadType == objabi.Hdarwin {\n\t\t\t// Recent versions of macOS print\n\t\t\t//\tld: warning: option -s is obsolete and being ignored\n\t\t\t// so do not pass any arguments.\n\t\t} else {\n\t\t\targv = append(argv, \"-s\")\n\t\t}\n\t}\n\n\tswitch ctxt.HeadType {\n\tcase objabi.Hdarwin:\n\t\targv = append(argv, \"-Wl,-headerpad,1144\")\n\t\tif ctxt.DynlinkingGo() && !ctxt.Arch.InFamily(sys.ARM, sys.ARM64) {\n\t\t\targv = append(argv, \"-Wl,-flat_namespace\")\n\t\t}\n\t\tif ctxt.BuildMode == BuildModeExe && !ctxt.Arch.InFamily(sys.ARM64) {\n\t\t\targv = append(argv, \"-Wl,-no_pie\")\n\t\t}\n\tcase objabi.Hopenbsd:\n\t\targv = append(argv, \"-Wl,-nopie\")\n\tcase objabi.Hwindows:\n\t\tif windowsgui {\n\t\t\targv = append(argv, \"-mwindows\")\n\t\t} else {\n\t\t\targv = append(argv, \"-mconsole\")\n\t\t}\n\t}\n\n\tswitch ctxt.BuildMode {\n\tcase BuildModeExe:\n\t\tif ctxt.HeadType == objabi.Hdarwin {\n\t\t\tif ctxt.Arch.Family == sys.ARM64 {\n\t\t\t\t// __PAGEZERO segment size determined empirically.\n\t\t\t\t// XCode 9.0.1 successfully uploads an iOS app with this value.\n\t\t\t\targv = append(argv, \"-Wl,-pagezero_size,100000000\")\n\t\t\t} else {\n\t\t\t\targv = append(argv, \"-Wl,-pagezero_size,4000000\")\n\t\t\t}\n\t\t}\n\tcase BuildModePIE:\n\t\t// ELF.\n\t\tif ctxt.HeadType != objabi.Hdarwin {\n\t\t\tif ctxt.UseRelro() {\n\t\t\t\targv = append(argv, \"-Wl,-z,relro\")\n\t\t\t}\n\t\t\targv = append(argv, \"-pie\")\n\t\t}\n\tcase BuildModeCShared:\n\t\tif ctxt.HeadType == objabi.Hdarwin {\n\t\t\targv = append(argv, \"-dynamiclib\")\n\t\t\tif ctxt.Arch.Family != sys.AMD64 {\n\t\t\t\targv = append(argv, \"-Wl,-read_only_relocs,suppress\")\n\t\t\t}\n\t\t} else {\n\t\t\t// ELF.\n\t\t\targv = append(argv, \"-Wl,-Bsymbolic\")\n\t\t\tif ctxt.UseRelro() {\n\t\t\t\targv = append(argv, \"-Wl,-z,relro\")\n\t\t\t}\n\t\t\targv = append(argv, \"-shared\")\n\t\t\tif ctxt.HeadType != objabi.Hwindows {\n\t\t\t\t// Pass -z nodelete to mark the shared library as\n\t\t\t\t// non-closeable: a dlclose will do nothing.\n\t\t\t\targv = append(argv, \"-Wl,-z,nodelete\")\n\t\t\t}\n\t\t}\n\tcase BuildModeShared:\n\t\tif ctxt.UseRelro() {\n\t\t\targv = append(argv, \"-Wl,-z,relro\")\n\t\t}\n\t\targv = append(argv, \"-shared\")\n\tcase BuildModePlugin:\n\t\tif ctxt.HeadType == objabi.Hdarwin {\n\t\t\targv = append(argv, \"-dynamiclib\")\n\t\t} else {\n\t\t\tif ctxt.UseRelro() {\n\t\t\t\targv = append(argv, \"-Wl,-z,relro\")\n\t\t\t}\n\t\t\targv = append(argv, \"-shared\")\n\t\t}\n\t}\n\n\tif ctxt.IsELF && ctxt.DynlinkingGo() {\n\t\t// We force all symbol resolution to be done at program startup\n\t\t// because lazy PLT resolution can use large amounts of stack at\n\t\t// times we cannot allow it to do so.\n\t\targv = append(argv, \"-Wl,-znow\")\n\n\t\t// Do not let the host linker generate COPY relocations. These\n\t\t// can move symbols out of sections that rely on stable offsets\n\t\t// from the beginning of the section (like sym.STYPE).\n\t\targv = append(argv, \"-Wl,-znocopyreloc\")\n\n\t\tif ctxt.Arch.InFamily(sys.ARM, sys.ARM64) {\n\t\t\t// On ARM, the GNU linker will generate COPY relocations\n\t\t\t// even with -znocopyreloc set.\n\t\t\t// https://sourceware.org/bugzilla/show_bug.cgi?id=19962\n\t\t\t//\n\t\t\t// On ARM64, the GNU linker will fail instead of\n\t\t\t// generating COPY relocations.\n\t\t\t//\n\t\t\t// In both cases, switch to gold.\n\t\t\targv = append(argv, \"-fuse-ld=gold\")\n\n\t\t\t// If gold is not installed, gcc will silently switch\n\t\t\t// back to ld.bfd. So we parse the version information\n\t\t\t// and provide a useful error if gold is missing.\n\t\t\tcmd := exec.Command(*flagExtld, \"-fuse-ld=gold\", \"-Wl,--version\")\n\t\t\tif out, err := cmd.CombinedOutput(); err == nil {\n\t\t\t\tif !bytes.Contains(out, []byte(\"GNU gold\")) {\n\t\t\t\t\tlog.Fatalf(\"ARM external linker must be gold (issue #15696), but is not: %s\", out)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif ctxt.IsELF && len(buildinfo) > 0 {\n\t\targv = append(argv, fmt.Sprintf(\"-Wl,--build-id=0x%x\", buildinfo))\n\t}\n\n\t// On Windows, given -o foo, GCC will append \".exe\" to produce\n\t// \"foo.exe\".  We have decided that we want to honor the -o\n\t// option. To make this work, we append a '.' so that GCC\n\t// will decide that the file already has an extension. We\n\t// only want to do this when producing a Windows output file\n\t// on a Windows host.\n\toutopt := *flagOutfile\n\tif objabi.GOOS == \"windows\" && runtime.GOOS == \"windows\" && filepath.Ext(outopt) == \"\" {\n\t\toutopt += \".\"\n\t}\n\targv = append(argv, \"-o\")\n\targv = append(argv, outopt)\n\n\tif rpath.val != \"\" {\n\t\targv = append(argv, fmt.Sprintf(\"-Wl,-rpath,%s\", rpath.val))\n\t}\n\n\t// Force global symbols to be exported for dlopen, etc.\n\tif ctxt.IsELF {\n\t\targv = append(argv, \"-rdynamic\")\n\t}\n\n\tif strings.Contains(argv[0], \"clang\") {\n\t\targv = append(argv, \"-Qunused-arguments\")\n\t}\n\n\tconst compressDWARF = \"-Wl,--compress-debug-sections=zlib-gnu\"\n\tif ctxt.compressDWARF && linkerFlagSupported(argv[0], compressDWARF) {\n\t\targv = append(argv, compressDWARF)\n\t}\n\n\targv = append(argv, filepath.Join(*flagTmpdir, \"go.o\"))\n\targv = append(argv, hostobjCopy()...)\n\n\tif ctxt.linkShared {\n\t\tseenDirs := make(map[string]bool)\n\t\tseenLibs := make(map[string]bool)\n\t\taddshlib := func(path string) {\n\t\t\tdir, base := filepath.Split(path)\n\t\t\tif !seenDirs[dir] {\n\t\t\t\targv = append(argv, \"-L\"+dir)\n\t\t\t\tif !rpath.set {\n\t\t\t\t\targv = append(argv, \"-Wl,-rpath=\"+dir)\n\t\t\t\t}\n\t\t\t\tseenDirs[dir] = true\n\t\t\t}\n\t\t\tbase = strings.TrimSuffix(base, \".so\")\n\t\t\tbase = strings.TrimPrefix(base, \"lib\")\n\t\t\tif !seenLibs[base] {\n\t\t\t\targv = append(argv, \"-l\"+base)\n\t\t\t\tseenLibs[base] = true\n\t\t\t}\n\t\t}\n\t\tfor _, shlib := range ctxt.Shlibs {\n\t\t\taddshlib(shlib.Path)\n\t\t\tfor _, dep := range shlib.Deps {\n\t\t\t\tif dep == \"\" {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tlibpath := findshlib(ctxt, dep)\n\t\t\t\tif libpath != \"\" {\n\t\t\t\t\taddshlib(libpath)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// clang, unlike GCC, passes -rdynamic to the linker\n\t// even when linking with -static, causing a linker\n\t// error when using GNU ld. So take out -rdynamic if\n\t// we added it. We do it in this order, rather than\n\t// only adding -rdynamic later, so that -*extldflags\n\t// can override -rdynamic without using -static.\n\tcheckStatic := func(arg string) {\n\t\tif ctxt.IsELF && arg == \"-static\" {\n\t\t\tfor i := range argv {\n\t\t\t\tif argv[i] == \"-rdynamic\" {\n\t\t\t\t\targv[i] = \"-static\"\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor _, p := range ldflag {\n\t\targv = append(argv, p)\n\t\tcheckStatic(p)\n\t}\n\n\t// When building a program with the default -buildmode=exe the\n\t// gc compiler generates code requires DT_TEXTREL in a\n\t// position independent executable (PIE). On systems where the\n\t// toolchain creates PIEs by default, and where DT_TEXTREL\n\t// does not work, the resulting programs will not run. See\n\t// issue #17847. To avoid this problem pass -no-pie to the\n\t// toolchain if it is supported.\n\tif ctxt.BuildMode == BuildModeExe && !ctxt.linkShared {\n\t\t// GCC uses -no-pie, clang uses -nopie.\n\t\tfor _, nopie := range []string{\"-no-pie\", \"-nopie\"} {\n\t\t\tif linkerFlagSupported(argv[0], nopie) {\n\t\t\t\targv = append(argv, nopie)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\tfor _, p := range strings.Fields(*flagExtldflags) {\n\t\targv = append(argv, p)\n\t\tcheckStatic(p)\n\t}\n\tif ctxt.HeadType == objabi.Hwindows {\n\t\t// use gcc linker script to work around gcc bug\n\t\t// (see https://golang.org/issue/20183 for details).\n\t\tp := writeGDBLinkerScript()\n\t\targv = append(argv, \"-Wl,-T,\"+p)\n\t\t// libmingw32 and libmingwex have some inter-dependencies,\n\t\t// so must use linker groups.\n\t\targv = append(argv, \"-Wl,--start-group\", \"-lmingwex\", \"-lmingw32\", \"-Wl,--end-group\")\n\t\targv = append(argv, peimporteddlls()...)\n\t}\n\n\tif ctxt.Debugvlog != 0 {\n\t\tctxt.Logf(\"%5.2f host link:\", Cputime())\n\t\tfor _, v := range argv {\n\t\t\tctxt.Logf(\" %q\", v)\n\t\t}\n\t\tctxt.Logf(\"\\n\")\n\t}\n\n\tout, err := exec.Command(argv[0], argv[1:]...).CombinedOutput()\n\tif err != nil {\n\t\tExitf(\"running %s failed: %v\\n%s\", argv[0], err, out)\n\t}\n\n\t// Filter out useless linker warnings caused by bugs outside Go.\n\t// See also cmd/go/internal/work/exec.go's gccld method.\n\tvar save [][]byte\n\tfor _, line := range bytes.SplitAfter(out, []byte(\"\\n\")) {\n\t\t// golang.org/issue/26073 - Apple Xcode bug\n\t\tif bytes.Contains(line, []byte(\"ld: warning: text-based stub file\")) {\n\t\t\tcontinue\n\t\t}\n\t\tsave = append(save, line)\n\t}\n\tout = bytes.Join(save, nil)\n\n\tif len(out) > 0 {\n\t\t// always print external output even if the command is successful, so that we don't\n\t\t// swallow linker warnings (see https://golang.org/issue/17935).\n\t\tctxt.Logf(\"%s\", out)\n\t}\n\n\tif !*FlagS && !*FlagW && !debug_s && ctxt.HeadType == objabi.Hdarwin {\n\t\tdsym := filepath.Join(*flagTmpdir, \"go.dwarf\")\n\t\tif out, err := exec.Command(\"dsymutil\", \"-f\", *flagOutfile, \"-o\", dsym).CombinedOutput(); err != nil {\n\t\t\tExitf(\"%s: running dsymutil failed: %v\\n%s\", os.Args[0], err, out)\n\t\t}\n\t\t// Skip combining if `dsymutil` didn't generate a file. See #11994.\n\t\tif _, err := os.Stat(dsym); os.IsNotExist(err) {\n\t\t\treturn\n\t\t}\n\t\t// For os.Rename to work reliably, must be in same directory as outfile.\n\t\tcombinedOutput := *flagOutfile + \"~\"\n\t\tisIOS, err := machoCombineDwarf(ctxt, *flagOutfile, dsym, combinedOutput)\n\t\tif err != nil {\n\t\t\tExitf(\"%s: combining dwarf failed: %v\", os.Args[0], err)\n\t\t}\n\t\tif !isIOS {\n\t\t\tos.Remove(*flagOutfile)\n\t\t\tif err := os.Rename(combinedOutput, *flagOutfile); err != nil {\n\t\t\t\tExitf(\"%s: %v\", os.Args[0], err)\n\t\t\t}\n\t\t}\n\t}\n}\n\nvar createTrivialCOnce sync.Once\n\nfunc linkerFlagSupported(linker, flag string) bool {\n\tcreateTrivialCOnce.Do(func() {\n\t\tsrc := filepath.Join(*flagTmpdir, \"trivial.c\")\n\t\tif err := ioutil.WriteFile(src, []byte(\"int main() { return 0; }\"), 0666); err != nil {\n\t\t\tErrorf(nil, \"WriteFile trivial.c failed: %v\", err)\n\t\t}\n\t})\n\n\tflagsWithNextArgSkip := []string{\n\t\t\"-F\",\n\t\t\"-l\",\n\t\t\"-L\",\n\t\t\"-framework\",\n\t\t\"-Wl,-framework\",\n\t\t\"-Wl,-rpath\",\n\t\t\"-Wl,-undefined\",\n\t}\n\tflagsWithNextArgKeep := []string{\n\t\t\"-arch\",\n\t\t\"-isysroot\",\n\t\t\"--sysroot\",\n\t\t\"-target\",\n\t}\n\tprefixesToKeep := []string{\n\t\t\"-f\",\n\t\t\"-m\",\n\t\t\"-p\",\n\t\t\"-Wl,\",\n\t\t\"-arch\",\n\t\t\"-isysroot\",\n\t\t\"--sysroot\",\n\t\t\"-target\",\n\t}\n\n\tvar flags []string\n\tkeep := false\n\tskip := false\n\textldflags := strings.Fields(*flagExtldflags)\n\tfor _, f := range append(extldflags, ldflag...) {\n\t\tif keep {\n\t\t\tflags = append(flags, f)\n\t\t\tkeep = false\n\t\t} else if skip {\n\t\t\tskip = false\n\t\t} else if f == \"\" || f[0] != '-' {\n\t\t} else if contains(flagsWithNextArgSkip, f) {\n\t\t\tskip = true\n\t\t} else if contains(flagsWithNextArgKeep, f) {\n\t\t\tflags = append(flags, f)\n\t\t\tkeep = true\n\t\t} else {\n\t\t\tfor _, p := range prefixesToKeep {\n\t\t\t\tif strings.HasPrefix(f, p) {\n\t\t\t\t\tflags = append(flags, f)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tflags = append(flags, flag, \"trivial.c\")\n\n\tcmd := exec.Command(linker, flags...)\n\tcmd.Dir = *flagTmpdir\n\tcmd.Env = append([]string{\"LC_ALL=C\"}, os.Environ()...)\n\tout, err := cmd.CombinedOutput()\n\t// GCC says \"unrecognized command line option \u2018-no-pie\u2019\"\n\t// clang says \"unknown argument: '-no-pie'\"\n\treturn err == nil && !bytes.Contains(out, []byte(\"unrecognized\")) && !bytes.Contains(out, []byte(\"unknown\"))\n}\n\n// hostlinkArchArgs returns arguments to pass to the external linker\n// based on the architecture.\nfunc hostlinkArchArgs(arch *sys.Arch) []string {\n\tswitch arch.Family {\n\tcase sys.I386:\n\t\treturn []string{\"-m32\"}\n\tcase sys.AMD64, sys.PPC64, sys.S390X:\n\t\treturn []string{\"-m64\"}\n\tcase sys.ARM:\n\t\treturn []string{\"-marm\"}\n\tcase sys.ARM64:\n\t\t// nothing needed\n\tcase sys.MIPS64:\n\t\treturn []string{\"-mabi=64\"}\n\tcase sys.MIPS:\n\t\treturn []string{\"-mabi=32\"}\n\t}\n\treturn nil\n}\n\n// ldobj loads an input object. If it is a host object (an object\n// compiled by a non-Go compiler) it returns the Hostobj pointer. If\n// it is a Go object, it returns nil.\nfunc ldobj(ctxt *Link, f *bio.Reader, lib *sym.Library, length int64, pn string, file string) *Hostobj {\n\tpkg := objabi.PathToPrefix(lib.Pkg)\n\n\teof := f.Offset() + length\n\tstart := f.Offset()\n\tc1 := bgetc(f)\n\tc2 := bgetc(f)\n\tc3 := bgetc(f)\n\tc4 := bgetc(f)\n\tf.Seek(start, 0)\n\n\tmagic := uint32(c1)<<24 | uint32(c2)<<16 | uint32(c3)<<8 | uint32(c4)\n\tif magic == 0x7f454c46 { // \\x7F E L F\n\t\tldelf := func(ctxt *Link, f *bio.Reader, pkg string, length int64, pn string) {\n\t\t\ttextp, flags, err := loadelf.Load(ctxt.Arch, ctxt.Syms, f, pkg, length, pn, ehdr.flags)\n\t\t\tif err != nil {\n\t\t\t\tErrorf(nil, \"%v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tehdr.flags = flags\n\t\t\tctxt.Textp = append(ctxt.Textp, textp...)\n\t\t}\n\t\treturn ldhostobj(ldelf, ctxt.HeadType, f, pkg, length, pn, file)\n\t}\n\n\tif magic&^1 == 0xfeedface || magic&^0x01000000 == 0xcefaedfe {\n\t\tldmacho := func(ctxt *Link, f *bio.Reader, pkg string, length int64, pn string) {\n\t\t\ttextp, err := loadmacho.Load(ctxt.Arch, ctxt.Syms, f, pkg, length, pn)\n\t\t\tif err != nil {\n\t\t\t\tErrorf(nil, \"%v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tctxt.Textp = append(ctxt.Textp, textp...)\n\t\t}\n\t\treturn ldhostobj(ldmacho, ctxt.HeadType, f, pkg, length, pn, file)\n\t}\n\n\tif c1 == 0x4c && c2 == 0x01 || c1 == 0x64 && c2 == 0x86 {\n\t\tldpe := func(ctxt *Link, f *bio.Reader, pkg string, length int64, pn string) {\n\t\t\ttextp, rsrc, err := loadpe.Load(ctxt.Arch, ctxt.Syms, f, pkg, length, pn)\n\t\t\tif err != nil {\n\t\t\t\tErrorf(nil, \"%v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif rsrc != nil {\n\t\t\t\tsetpersrc(ctxt, rsrc)\n\t\t\t}\n\t\t\tctxt.Textp = append(ctxt.Textp, textp...)\n\t\t}\n\t\treturn ldhostobj(ldpe, ctxt.HeadType, f, pkg, length, pn, file)\n\t}\n\n\tif c1 == 0x01 && (c2 == 0xD7 || c2 == 0xF7) {\n\t\tldxcoff := func(ctxt *Link, f *bio.Reader, pkg string, length int64, pn string) {\n\t\t\ttextp, err := loadxcoff.Load(ctxt.Arch, ctxt.Syms, f, pkg, length, pn)\n\t\t\tif err != nil {\n\t\t\t\tErrorf(nil, \"%v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tctxt.Textp = append(ctxt.Textp, textp...)\n\t\t}\n\t\treturn ldhostobj(ldxcoff, ctxt.HeadType, f, pkg, length, pn, file)\n\t}\n\n\t/* check the header */\n\tline, err := f.ReadString('\\n')\n\tif err != nil {\n\t\tErrorf(nil, \"truncated object file: %s: %v\", pn, err)\n\t\treturn nil\n\t}\n\n\tif !strings.HasPrefix(line, \"go object \") {\n\t\tif strings.HasSuffix(pn, \".go\") {\n\t\t\tExitf(\"%s: uncompiled .go source file\", pn)\n\t\t\treturn nil\n\t\t}\n\n\t\tif line == ctxt.Arch.Name {\n\t\t\t// old header format: just $GOOS\n\t\t\tErrorf(nil, \"%s: stale object file\", pn)\n\t\t\treturn nil\n\t\t}\n\n\t\tErrorf(nil, \"%s: not an object file\", pn)\n\t\treturn nil\n\t}\n\n\t// First, check that the basic GOOS, GOARCH, and Version match.\n\tt := fmt.Sprintf(\"%s %s %s \", objabi.GOOS, objabi.GOARCH, objabi.Version)\n\n\tline = strings.TrimRight(line, \"\\n\")\n\tif !strings.HasPrefix(line[10:]+\" \", t) && !*flagF {\n\t\tErrorf(nil, \"%s: object is [%s] expected [%s]\", pn, line[10:], t)\n\t\treturn nil\n\t}\n\n\t// Second, check that longer lines match each other exactly,\n\t// so that the Go compiler and write additional information\n\t// that must be the same from run to run.\n\tif len(line) >= len(t)+10 {\n\t\tif theline == \"\" {\n\t\t\ttheline = line[10:]\n\t\t} else if theline != line[10:] {\n\t\t\tErrorf(nil, \"%s: object is [%s] expected [%s]\", pn, line[10:], theline)\n\t\t\treturn nil\n\t\t}\n\t}\n\n\t// Skip over exports and other info -- ends with \\n!\\n.\n\t//\n\t// Note: It's possible for \"\\n!\\n\" to appear within the binary\n\t// package export data format. To avoid truncating the package\n\t// definition prematurely (issue 21703), we keep track of\n\t// how many \"$$\" delimiters we've seen.\n\n\timport0 := f.Offset()\n\n\tc1 = '\\n' // the last line ended in \\n\n\tc2 = bgetc(f)\n\tc3 = bgetc(f)\n\tmarkers := 0\n\tfor {\n\t\tif c1 == '\\n' {\n\t\t\tif markers%2 == 0 && c2 == '!' && c3 == '\\n' {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif c2 == '$' && c3 == '$' {\n\t\t\t\tmarkers++\n\t\t\t}\n\t\t}\n\n\t\tc1 = c2\n\t\tc2 = c3\n\t\tc3 = bgetc(f)\n\t\tif c3 == -1 {\n\t\t\tErrorf(nil, \"truncated object file: %s\", pn)\n\t\t\treturn nil\n\t\t}\n\t}\n\n\timport1 := f.Offset()\n\n\tf.Seek(import0, 0)\n\tldpkg(ctxt, f, lib, import1-import0-2, pn) // -2 for !\\n\n\tf.Seek(import1, 0)\n\n\tobjfile.Load(ctxt.Arch, ctxt.Syms, f, lib, eof-f.Offset(), pn)\n\taddImports(ctxt, lib, pn)\n\treturn nil\n}\n\nfunc readelfsymboldata(ctxt *Link, f *elf.File, sym *elf.Symbol) []byte {\n\tdata := make([]byte, sym.Size)\n\tsect := f.Sections[sym.Section]\n\tif sect.Type != elf.SHT_PROGBITS && sect.Type != elf.SHT_NOTE {\n\t\tErrorf(nil, \"reading %s from non-data section\", sym.Name)\n\t}\n\tn, err := sect.ReadAt(data, int64(sym.Value-sect.Addr))\n\tif uint64(n) != sym.Size {\n\t\tErrorf(nil, \"reading contents of %s: %v\", sym.Name, err)\n\t}\n\treturn data\n}\n\nfunc readwithpad(r io.Reader, sz int32) ([]byte, error) {\n\tdata := make([]byte, Rnd(int64(sz), 4))\n\t_, err := io.ReadFull(r, data)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdata = data[:sz]\n\treturn data, nil\n}\n\nfunc readnote(f *elf.File, name []byte, typ int32) ([]byte, error) {\n\tfor _, sect := range f.Sections {\n\t\tif sect.Type != elf.SHT_NOTE {\n\t\t\tcontinue\n\t\t}\n\t\tr := sect.Open()\n\t\tfor {\n\t\t\tvar namesize, descsize, noteType int32\n\t\t\terr := binary.Read(r, f.ByteOrder, &namesize)\n\t\t\tif err != nil {\n\t\t\t\tif err == io.EOF {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\treturn nil, fmt.Errorf(\"read namesize failed: %v\", err)\n\t\t\t}\n\t\t\terr = binary.Read(r, f.ByteOrder, &descsize)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"read descsize failed: %v\", err)\n\t\t\t}\n\t\t\terr = binary.Read(r, f.ByteOrder, &noteType)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"read type failed: %v\", err)\n\t\t\t}\n\t\t\tnoteName, err := readwithpad(r, namesize)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"read name failed: %v\", err)\n\t\t\t}\n\t\t\tdesc, err := readwithpad(r, descsize)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"read desc failed: %v\", err)\n\t\t\t}\n\t\t\tif string(name) == string(noteName) && typ == noteType {\n\t\t\t\treturn desc, nil\n\t\t\t}\n\t\t}\n\t}\n\treturn nil, nil\n}\n\nfunc findshlib(ctxt *Link, shlib string) string {\n\tif filepath.IsAbs(shlib) {\n\t\treturn shlib\n\t}\n\tfor _, libdir := range ctxt.Libdir {\n\t\tlibpath := filepath.Join(libdir, shlib)\n\t\tif _, err := os.Stat(libpath); err == nil {\n\t\t\treturn libpath\n\t\t}\n\t}\n\tErrorf(nil, \"cannot find shared library: %s\", shlib)\n\treturn \"\"\n}\n\nfunc ldshlibsyms(ctxt *Link, shlib string) {\n\tvar libpath string\n\tif filepath.IsAbs(shlib) {\n\t\tlibpath = shlib\n\t\tshlib = filepath.Base(shlib)\n\t} else {\n\t\tlibpath = findshlib(ctxt, shlib)\n\t\tif libpath == \"\" {\n\t\t\treturn\n\t\t}\n\t}\n\tfor _, processedlib := range ctxt.Shlibs {\n\t\tif processedlib.Path == libpath {\n\t\t\treturn\n\t\t}\n\t}\n\tif ctxt.Debugvlog > 1 {\n\t\tctxt.Logf(\"%5.2f ldshlibsyms: found library with name %s at %s\\n\", Cputime(), shlib, libpath)\n\t}\n\n\tf, err := elf.Open(libpath)\n\tif err != nil {\n\t\tErrorf(nil, \"cannot open shared library: %s\", libpath)\n\t\treturn\n\t}\n\tdefer f.Close()\n\n\thash, err := readnote(f, ELF_NOTE_GO_NAME, ELF_NOTE_GOABIHASH_TAG)\n\tif err != nil {\n\t\tErrorf(nil, \"cannot read ABI hash from shared library %s: %v\", libpath, err)\n\t\treturn\n\t}\n\n\tdepsbytes, err := readnote(f, ELF_NOTE_GO_NAME, ELF_NOTE_GODEPS_TAG)\n\tif err != nil {\n\t\tErrorf(nil, \"cannot read dep list from shared library %s: %v\", libpath, err)\n\t\treturn\n\t}\n\tvar deps []string\n\tfor _, dep := range strings.Split(string(depsbytes), \"\\n\") {\n\t\tif dep == \"\" {\n\t\t\tcontinue\n\t\t}\n\t\tif !filepath.IsAbs(dep) {\n\t\t\t// If the dep can be interpreted as a path relative to the shlib\n\t\t\t// in which it was found, do that. Otherwise, we will leave it\n\t\t\t// to be resolved by libdir lookup.\n\t\t\tabs := filepath.Join(filepath.Dir(libpath), dep)\n\t\t\tif _, err := os.Stat(abs); err == nil {\n\t\t\t\tdep = abs\n\t\t\t}\n\t\t}\n\t\tdeps = append(deps, dep)\n\t}\n\n\tsyms, err := f.DynamicSymbols()\n\tif err != nil {\n\t\tErrorf(nil, \"cannot read symbols from shared library: %s\", libpath)\n\t\treturn\n\t}\n\tgcdataLocations := make(map[uint64]*sym.Symbol)\n\tfor _, elfsym := range syms {\n\t\tif elf.ST_TYPE(elfsym.Info) == elf.STT_NOTYPE || elf.ST_TYPE(elfsym.Info) == elf.STT_SECTION {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Symbols whose names start with \"type.\" are compiler\n\t\t// generated, so make functions with that prefix internal.\n\t\tver := 0\n\t\tif elf.ST_TYPE(elfsym.Info) == elf.STT_FUNC && strings.HasPrefix(elfsym.Name, \"type.\") {\n\t\t\tver = sym.SymVerABIInternal\n\t\t}\n\n\t\tlsym := ctxt.Syms.Lookup(elfsym.Name, ver)\n\t\t// Because loadlib above loads all .a files before loading any shared\n\t\t// libraries, any non-dynimport symbols we find that duplicate symbols\n\t\t// already loaded should be ignored (the symbols from the .a files\n\t\t// \"win\").\n\t\tif lsym.Type != 0 && lsym.Type != sym.SDYNIMPORT {\n\t\t\tcontinue\n\t\t}\n\t\tlsym.Type = sym.SDYNIMPORT\n\t\tlsym.SetElfType(elf.ST_TYPE(elfsym.Info))\n\t\tlsym.Size = int64(elfsym.Size)\n\t\tif elfsym.Section != elf.SHN_UNDEF {\n\t\t\t// Set .File for the library that actually defines the symbol.\n\t\t\tlsym.File = libpath\n\t\t\t// The decodetype_* functions in decodetype.go need access to\n\t\t\t// the type data.\n\t\t\tif strings.HasPrefix(lsym.Name, \"type.\") && !strings.HasPrefix(lsym.Name, \"type..\") {\n\t\t\t\tlsym.P = readelfsymboldata(ctxt, f, &elfsym)\n\t\t\t\tgcdataLocations[elfsym.Value+2*uint64(ctxt.Arch.PtrSize)+8+1*uint64(ctxt.Arch.PtrSize)] = lsym\n\t\t\t}\n\t\t}\n\t\t// For function symbols, we don't know what ABI is\n\t\t// available, so alias it under both ABIs.\n\t\t//\n\t\t// TODO(austin): This is almost certainly wrong once\n\t\t// the ABIs are actually different. We might have to\n\t\t// mangle Go function names in the .so to include the\n\t\t// ABI.\n\t\tif elf.ST_TYPE(elfsym.Info) == elf.STT_FUNC && ver == 0 {\n\t\t\talias := ctxt.Syms.Lookup(elfsym.Name, sym.SymVerABIInternal)\n\t\t\tif alias.Type != 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\talias.Type = sym.SABIALIAS\n\t\t\talias.R = []sym.Reloc{{Sym: lsym}}\n\t\t}\n\t}\n\tgcdataAddresses := make(map[*sym.Symbol]uint64)\n\tif ctxt.Arch.Family == sys.ARM64 {\n\t\tfor _, sect := range f.Sections {\n\t\t\tif sect.Type == elf.SHT_RELA {\n\t\t\t\tvar rela elf.Rela64\n\t\t\t\trdr := sect.Open()\n\t\t\t\tfor {\n\t\t\t\t\terr := binary.Read(rdr, f.ByteOrder, &rela)\n\t\t\t\t\tif err == io.EOF {\n\t\t\t\t\t\tbreak\n\t\t\t\t\t} else if err != nil {\n\t\t\t\t\t\tErrorf(nil, \"reading relocation failed %v\", err)\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tt := elf.R_AARCH64(rela.Info & 0xffff)\n\t\t\t\t\tif t != elf.R_AARCH64_RELATIVE {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tif lsym, ok := gcdataLocations[rela.Off]; ok {\n\t\t\t\t\t\tgcdataAddresses[lsym] = uint64(rela.Addend)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tctxt.Shlibs = append(ctxt.Shlibs, Shlib{Path: libpath, Hash: hash, Deps: deps, File: f, gcdataAddresses: gcdataAddresses})\n}\n\nfunc addsection(arch *sys.Arch, seg *sym.Segment, name string, rwx int) *sym.Section {\n\tsect := new(sym.Section)\n\tsect.Rwx = uint8(rwx)\n\tsect.Name = name\n\tsect.Seg = seg\n\tsect.Align = int32(arch.PtrSize) // everything is at least pointer-aligned\n\tseg.Sections = append(seg.Sections, sect)\n\treturn sect\n}\n\ntype chain struct {\n\tsym   *sym.Symbol\n\tup    *chain\n\tlimit int // limit on entry to sym\n}\n\nvar morestack *sym.Symbol\n\n// TODO: Record enough information in new object files to\n// allow stack checks here.\n\nfunc haslinkregister(ctxt *Link) bool {\n\treturn ctxt.FixedFrameSize() != 0\n}\n\nfunc callsize(ctxt *Link) int {\n\tif haslinkregister(ctxt) {\n\t\treturn 0\n\t}\n\treturn ctxt.Arch.RegSize\n}\n\nfunc (ctxt *Link) dostkcheck() {\n\tvar ch chain\n\n\tmorestack = ctxt.Syms.Lookup(\"runtime.morestack\", 0)\n\n\t// Every splitting function ensures that there are at least StackLimit\n\t// bytes available below SP when the splitting prologue finishes.\n\t// If the splitting function calls F, then F begins execution with\n\t// at least StackLimit - callsize() bytes available.\n\t// Check that every function behaves correctly with this amount\n\t// of stack, following direct calls in order to piece together chains\n\t// of non-splitting functions.\n\tch.up = nil\n\n\tch.limit = objabi.StackLimit - callsize(ctxt)\n\tif objabi.GOARCH == \"arm64\" {\n\t\t// need extra 8 bytes below SP to save FP\n\t\tch.limit -= 8\n\t}\n\n\t// Check every function, but do the nosplit functions in a first pass,\n\t// to make the printed failure chains as short as possible.\n\tfor _, s := range ctxt.Textp {\n\t\t// runtime.racesymbolizethunk is called from gcc-compiled C\n\t\t// code running on the operating system thread stack.\n\t\t// It uses more than the usual amount of stack but that's okay.\n\t\tif s.Name == \"runtime.racesymbolizethunk\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tif s.Attr.NoSplit() {\n\t\t\tch.sym = s\n\t\t\tstkcheck(ctxt, &ch, 0)\n\t\t}\n\t}\n\n\tfor _, s := range ctxt.Textp {\n\t\tif !s.Attr.NoSplit() {\n\t\t\tch.sym = s\n\t\t\tstkcheck(ctxt, &ch, 0)\n\t\t}\n\t}\n}\n\nfunc stkcheck(ctxt *Link, up *chain, depth int) int {\n\tlimit := up.limit\n\ts := up.sym\n\n\t// Don't duplicate work: only need to consider each\n\t// function at top of safe zone once.\n\ttop := limit == objabi.StackLimit-callsize(ctxt)\n\tif top {\n\t\tif s.Attr.StackCheck() {\n\t\t\treturn 0\n\t\t}\n\t\ts.Attr |= sym.AttrStackCheck\n\t}\n\n\tif depth > 500 {\n\t\tErrorf(s, \"nosplit stack check too deep\")\n\t\tstkbroke(ctxt, up, 0)\n\t\treturn -1\n\t}\n\n\tif s.Attr.External() || s.FuncInfo == nil {\n\t\t// external function.\n\t\t// should never be called directly.\n\t\t// onlyctxt.Diagnose the direct caller.\n\t\t// TODO(mwhudson): actually think about this.\n\t\t// TODO(khr): disabled for now. Calls to external functions can only happen on the g0 stack.\n\t\t// See the trampolines in src/runtime/sys_darwin_$ARCH.go.\n\t\tif depth == 1 && s.Type != sym.SXREF && !ctxt.DynlinkingGo() &&\n\t\t\tctxt.BuildMode != BuildModeCArchive && ctxt.BuildMode != BuildModePIE && ctxt.BuildMode != BuildModeCShared && ctxt.BuildMode != BuildModePlugin {\n\t\t\t//Errorf(s, \"call to external function\")\n\t\t}\n\t\treturn -1\n\t}\n\n\tif limit < 0 {\n\t\tstkbroke(ctxt, up, limit)\n\t\treturn -1\n\t}\n\n\t// morestack looks like it calls functions,\n\t// but it switches the stack pointer first.\n\tif s == morestack {\n\t\treturn 0\n\t}\n\n\tvar ch chain\n\tch.up = up\n\n\tif !s.Attr.NoSplit() {\n\t\t// Ensure we have enough stack to call morestack.\n\t\tch.limit = limit - callsize(ctxt)\n\t\tch.sym = morestack\n\t\tif stkcheck(ctxt, &ch, depth+1) < 0 {\n\t\t\treturn -1\n\t\t}\n\t\tif !top {\n\t\t\treturn 0\n\t\t}\n\t\t// Raise limit to allow frame.\n\t\tlocals := int32(0)\n\t\tif s.FuncInfo != nil {\n\t\t\tlocals = s.FuncInfo.Locals\n\t\t}\n\t\tlimit = objabi.StackLimit + int(locals) + int(ctxt.FixedFrameSize())\n\t}\n\n\t// Walk through sp adjustments in function, consuming relocs.\n\tri := 0\n\n\tendr := len(s.R)\n\tvar ch1 chain\n\tvar pcsp Pciter\n\tvar r *sym.Reloc\n\tfor pciterinit(ctxt, &pcsp, &s.FuncInfo.Pcsp); pcsp.done == 0; pciternext(&pcsp) {\n\t\t// pcsp.value is in effect for [pcsp.pc, pcsp.nextpc).\n\n\t\t// Check stack size in effect for this span.\n\t\tif int32(limit)-pcsp.value < 0 {\n\t\t\tstkbroke(ctxt, up, int(int32(limit)-pcsp.value))\n\t\t\treturn -1\n\t\t}\n\n\t\t// Process calls in this span.\n\t\tfor ; ri < endr && uint32(s.R[ri].Off) < pcsp.nextpc; ri++ {\n\t\t\tr = &s.R[ri]\n\t\t\tswitch r.Type {\n\t\t\t// Direct call.\n\t\t\tcase objabi.R_CALL, objabi.R_CALLARM, objabi.R_CALLARM64, objabi.R_CALLPOWER, objabi.R_CALLMIPS:\n\t\t\t\tch.limit = int(int32(limit) - pcsp.value - int32(callsize(ctxt)))\n\t\t\t\tch.sym = r.Sym\n\t\t\t\tif stkcheck(ctxt, &ch, depth+1) < 0 {\n\t\t\t\t\treturn -1\n\t\t\t\t}\n\n\t\t\t// Indirect call. Assume it is a call to a splitting function,\n\t\t\t// so we have to make sure it can call morestack.\n\t\t\t// Arrange the data structures to report both calls, so that\n\t\t\t// if there is an error, stkprint shows all the steps involved.\n\t\t\tcase objabi.R_CALLIND:\n\t\t\t\tch.limit = int(int32(limit) - pcsp.value - int32(callsize(ctxt)))\n\n\t\t\t\tch.sym = nil\n\t\t\t\tch1.limit = ch.limit - callsize(ctxt) // for morestack in called prologue\n\t\t\t\tch1.up = &ch\n\t\t\t\tch1.sym = morestack\n\t\t\t\tif stkcheck(ctxt, &ch1, depth+2) < 0 {\n\t\t\t\t\treturn -1\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0\n}\n\nfunc stkbroke(ctxt *Link, ch *chain, limit int) {\n\tErrorf(ch.sym, \"nosplit stack overflow\")\n\tstkprint(ctxt, ch, limit)\n}\n\nfunc stkprint(ctxt *Link, ch *chain, limit int) {\n\tvar name string\n\n\tif ch.sym != nil {\n\t\tname = ch.sym.Name\n\t\tif ch.sym.Attr.NoSplit() {\n\t\t\tname += \" (nosplit)\"\n\t\t}\n\t} else {\n\t\tname = \"function pointer\"\n\t}\n\n\tif ch.up == nil {\n\t\t// top of chain.  ch->sym != nil.\n\t\tif ch.sym.Attr.NoSplit() {\n\t\t\tfmt.Printf(\"\\t%d\\tassumed on entry to %s\\n\", ch.limit, name)\n\t\t} else {\n\t\t\tfmt.Printf(\"\\t%d\\tguaranteed after split check in %s\\n\", ch.limit, name)\n\t\t}\n\t} else {\n\t\tstkprint(ctxt, ch.up, ch.limit+callsize(ctxt))\n\t\tif !haslinkregister(ctxt) {\n\t\t\tfmt.Printf(\"\\t%d\\ton entry to %s\\n\", ch.limit, name)\n\t\t}\n\t}\n\n\tif ch.limit != limit {\n\t\tfmt.Printf(\"\\t%d\\tafter %s uses %d\\n\", limit, name, ch.limit-limit)\n\t}\n}\n\nfunc usage() {\n\tfmt.Fprintf(os.Stderr, \"usage: link [options] main.o\\n\")\n\tobjabi.Flagprint(os.Stderr)\n\tExit(2)\n}\n\ntype SymbolType int8\n\nconst (\n\t// see also https://9p.io/magic/man2html/1/nm\n\tTextSym      SymbolType = 'T'\n\tDataSym      SymbolType = 'D'\n\tBSSSym       SymbolType = 'B'\n\tUndefinedSym SymbolType = 'U'\n\tTLSSym       SymbolType = 't'\n\tFrameSym     SymbolType = 'm'\n\tParamSym     SymbolType = 'p'\n\tAutoSym      SymbolType = 'a'\n\n\t// Deleted auto (not a real sym, just placeholder for type)\n\tDeletedAutoSym = 'x'\n)\n\nfunc genasmsym(ctxt *Link, put func(*Link, *sym.Symbol, string, SymbolType, int64, *sym.Symbol)) {\n\t// These symbols won't show up in the first loop below because we\n\t// skip sym.STEXT symbols. Normal sym.STEXT symbols are emitted by walking textp.\n\ts := ctxt.Syms.Lookup(\"runtime.text\", 0)\n\tif s.Type == sym.STEXT {\n\t\t// We've already included this symbol in ctxt.Textp\n\t\t// if ctxt.DynlinkingGo() && ctxt.HeadType == objabi.Hdarwin.\n\t\t// See data.go:/textaddress\n\t\tif !(ctxt.DynlinkingGo() && ctxt.HeadType == objabi.Hdarwin) {\n\t\t\tput(ctxt, s, s.Name, TextSym, s.Value, nil)\n\t\t}\n\t}\n\n\tn := 0\n\n\t// Generate base addresses for all text sections if there are multiple\n\tfor _, sect := range Segtext.Sections {\n\t\tif n == 0 {\n\t\t\tn++\n\t\t\tcontinue\n\t\t}\n\t\tif sect.Name != \".text\" {\n\t\t\tbreak\n\t\t}\n\t\ts = ctxt.Syms.ROLookup(fmt.Sprintf(\"runtime.text.%d\", n), 0)\n\t\tif s == nil {\n\t\t\tbreak\n\t\t}\n\t\tif s.Type == sym.STEXT {\n\t\t\tput(ctxt, s, s.Name, TextSym, s.Value, nil)\n\t\t}\n\t\tn++\n\t}\n\n\ts = ctxt.Syms.Lookup(\"runtime.etext\", 0)\n\tif s.Type == sym.STEXT {\n\t\t// We've already included this symbol in ctxt.Textp\n\t\t// if ctxt.DynlinkingGo() && ctxt.HeadType == objabi.Hdarwin.\n\t\t// See data.go:/textaddress\n\t\tif !(ctxt.DynlinkingGo() && ctxt.HeadType == objabi.Hdarwin) {\n\t\t\tput(ctxt, s, s.Name, TextSym, s.Value, nil)\n\t\t}\n\t}\n\n\tfor _, s := range ctxt.Syms.Allsym {\n\t\tif s.Attr.NotInSymbolTable() {\n\t\t\tcontinue\n\t\t}\n\t\tif (s.Name == \"\" || s.Name[0] == '.') && !s.IsFileLocal() && s.Name != \".rathole\" && s.Name != \".TOC.\" {\n\t\t\tcontinue\n\t\t}\n\t\tswitch s.Type {\n\t\tcase sym.SCONST,\n\t\t\tsym.SRODATA,\n\t\t\tsym.SSYMTAB,\n\t\t\tsym.SPCLNTAB,\n\t\t\tsym.SINITARR,\n\t\t\tsym.SDATA,\n\t\t\tsym.SNOPTRDATA,\n\t\t\tsym.SELFROSECT,\n\t\t\tsym.SMACHOGOT,\n\t\t\tsym.STYPE,\n\t\t\tsym.SSTRING,\n\t\t\tsym.SGOSTRING,\n\t\t\tsym.SGOFUNC,\n\t\t\tsym.SGCBITS,\n\t\t\tsym.STYPERELRO,\n\t\t\tsym.SSTRINGRELRO,\n\t\t\tsym.SGOSTRINGRELRO,\n\t\t\tsym.SGOFUNCRELRO,\n\t\t\tsym.SGCBITSRELRO,\n\t\t\tsym.SRODATARELRO,\n\t\t\tsym.STYPELINK,\n\t\t\tsym.SITABLINK,\n\t\t\tsym.SWINDOWS:\n\t\t\tif !s.Attr.Reachable() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tput(ctxt, s, s.Name, DataSym, Symaddr(s), s.Gotype)\n\n\t\tcase sym.SBSS, sym.SNOPTRBSS:\n\t\t\tif !s.Attr.Reachable() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif len(s.P) > 0 {\n\t\t\t\tErrorf(s, \"should not be bss (size=%d type=%v special=%v)\", len(s.P), s.Type, s.Attr.Special())\n\t\t\t}\n\t\t\tput(ctxt, s, s.Name, BSSSym, Symaddr(s), s.Gotype)\n\n\t\tcase sym.SHOSTOBJ:\n\t\t\tif ctxt.HeadType == objabi.Hwindows || ctxt.IsELF {\n\t\t\t\tput(ctxt, s, s.Name, UndefinedSym, s.Value, nil)\n\t\t\t}\n\n\t\tcase sym.SDYNIMPORT:\n\t\t\tif !s.Attr.Reachable() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tput(ctxt, s, s.Extname(), UndefinedSym, 0, nil)\n\n\t\tcase sym.STLSBSS:\n\t\t\tif ctxt.LinkMode == LinkExternal {\n\t\t\t\tput(ctxt, s, s.Name, TLSSym, Symaddr(s), s.Gotype)\n\t\t\t}\n\t\t}\n\t}\n\n\tvar off int32\n\tfor _, s := range ctxt.Textp {\n\t\tput(ctxt, s, s.Name, TextSym, s.Value, s.Gotype)\n\n\t\tlocals := int32(0)\n\t\tif s.FuncInfo != nil {\n\t\t\tlocals = s.FuncInfo.Locals\n\t\t}\n\t\t// NOTE(ality): acid can't produce a stack trace without .frame symbols\n\t\tput(ctxt, nil, \".frame\", FrameSym, int64(locals)+int64(ctxt.Arch.PtrSize), nil)\n\n\t\tif s.FuncInfo == nil {\n\t\t\tcontinue\n\t\t}\n\t\tfor _, a := range s.FuncInfo.Autom {\n\t\t\tif a.Name == objabi.A_DELETED_AUTO {\n\t\t\t\tput(ctxt, nil, \"\", DeletedAutoSym, 0, a.Gotype)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// Emit a or p according to actual offset, even if label is wrong.\n\t\t\t// This avoids negative offsets, which cannot be encoded.\n\t\t\tif a.Name != objabi.A_AUTO && a.Name != objabi.A_PARAM {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// compute offset relative to FP\n\t\t\tif a.Name == objabi.A_PARAM {\n\t\t\t\toff = a.Aoffset\n\t\t\t} else {\n\t\t\t\toff = a.Aoffset - int32(ctxt.Arch.PtrSize)\n\t\t\t}\n\n\t\t\t// FP\n\t\t\tif off >= 0 {\n\t\t\t\tput(ctxt, nil, a.Asym.Name, ParamSym, int64(off), a.Gotype)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// SP\n\t\t\tif off <= int32(-ctxt.Arch.PtrSize) {\n\t\t\t\tput(ctxt, nil, a.Asym.Name, AutoSym, -(int64(off) + int64(ctxt.Arch.PtrSize)), a.Gotype)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// Otherwise, off is addressing the saved program counter.\n\t\t\t// Something underhanded is going on. Say nothing.\n\t\t}\n\t}\n\n\tif ctxt.Debugvlog != 0 || *flagN {\n\t\tctxt.Logf(\"%5.2f symsize = %d\\n\", Cputime(), uint32(Symsize))\n\t}\n}\n\nfunc Symaddr(s *sym.Symbol) int64 {\n\tif !s.Attr.Reachable() {\n\t\tErrorf(s, \"unreachable symbol in symaddr\")\n\t}\n\treturn s.Value\n}\n\nfunc (ctxt *Link) xdefine(p string, t sym.SymKind, v int64) {\n\ts := ctxt.Syms.Lookup(p, 0)\n\ts.Type = t\n\ts.Value = v\n\ts.Attr |= sym.AttrReachable\n\ts.Attr |= sym.AttrSpecial\n\ts.Attr |= sym.AttrLocal\n}\n\nfunc datoff(s *sym.Symbol, addr int64) int64 {\n\tif uint64(addr) >= Segdata.Vaddr {\n\t\treturn int64(uint64(addr) - Segdata.Vaddr + Segdata.Fileoff)\n\t}\n\tif uint64(addr) >= Segtext.Vaddr {\n\t\treturn int64(uint64(addr) - Segtext.Vaddr + Segtext.Fileoff)\n\t}\n\tErrorf(s, \"invalid datoff %#x\", addr)\n\treturn 0\n}\n\nfunc Entryvalue(ctxt *Link) int64 {\n\ta := *flagEntrySymbol\n\tif a[0] >= '0' && a[0] <= '9' {\n\t\treturn atolwhex(a)\n\t}\n\ts := ctxt.Syms.Lookup(a, 0)\n\tif s.Type == 0 {\n\t\treturn *FlagTextAddr\n\t}\n\tif ctxt.HeadType != objabi.Haix && s.Type != sym.STEXT {\n\t\tErrorf(s, \"entry not text\")\n\t}\n\treturn s.Value\n}\n\nfunc undefsym(ctxt *Link, s *sym.Symbol) {\n\tvar r *sym.Reloc\n\n\tfor i := 0; i < len(s.R); i++ {\n\t\tr = &s.R[i]\n\t\tif r.Sym == nil { // happens for some external ARM relocs\n\t\t\tcontinue\n\t\t}\n\t\t// TODO(mwhudson): the test of VisibilityHidden here probably doesn't make\n\t\t// sense and should be removed when someone has thought about it properly.\n\t\tif (r.Sym.Type == sym.Sxxx || r.Sym.Type == sym.SXREF) && !r.Sym.Attr.VisibilityHidden() {\n\t\t\tErrorf(s, \"undefined: %q\", r.Sym.Name)\n\t\t}\n\t\tif !r.Sym.Attr.Reachable() && r.Type != objabi.R_WEAKADDROFF {\n\t\t\tErrorf(s, \"relocation target %q\", r.Sym.Name)\n\t\t}\n\t}\n}\n\nfunc (ctxt *Link) undef() {\n\t// undefsym performs checks (almost) identical to checks\n\t// that report undefined relocations in relocsym.\n\t// Both undefsym and relocsym can report same symbol as undefined,\n\t// which results in error message duplication (see #10978).\n\t//\n\t// The undef is run after Arch.Asmb and could detect some\n\t// programming errors there, but if object being linked is already\n\t// failed with errors, it is better to avoid duplicated errors.\n\tif nerrors > 0 {\n\t\treturn\n\t}\n\n\tfor _, s := range ctxt.Textp {\n\t\tundefsym(ctxt, s)\n\t}\n\tfor _, s := range datap {\n\t\tundefsym(ctxt, s)\n\t}\n\tif nerrors > 0 {\n\t\terrorexit()\n\t}\n}\n\nfunc (ctxt *Link) callgraph() {\n\tif !*FlagC {\n\t\treturn\n\t}\n\n\tvar i int\n\tvar r *sym.Reloc\n\tfor _, s := range ctxt.Textp {\n\t\tfor i = 0; i < len(s.R); i++ {\n\t\t\tr = &s.R[i]\n\t\t\tif r.Sym == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif (r.Type == objabi.R_CALL || r.Type == objabi.R_CALLARM || r.Type == objabi.R_CALLPOWER || r.Type == objabi.R_CALLMIPS) && r.Sym.Type == sym.STEXT {\n\t\t\t\tctxt.Logf(\"%s calls %s\\n\", s.Name, r.Sym.Name)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc Rnd(v int64, r int64) int64 {\n\tif r <= 0 {\n\t\treturn v\n\t}\n\tv += r - 1\n\tc := v % r\n\tif c < 0 {\n\t\tc += r\n\t}\n\tv -= c\n\treturn v\n}\n\nfunc bgetc(r *bio.Reader) int {\n\tc, err := r.ReadByte()\n\tif err != nil {\n\t\tif err != io.EOF {\n\t\t\tlog.Fatalf(\"reading input: %v\", err)\n\t\t}\n\t\treturn -1\n\t}\n\treturn int(c)\n}\n\ntype markKind uint8 // for postorder traversal\nconst (\n\t_ markKind = iota\n\tvisiting\n\tvisited\n)\n\nfunc postorder(libs []*sym.Library) []*sym.Library {\n\torder := make([]*sym.Library, 0, len(libs)) // hold the result\n\tmark := make(map[*sym.Library]markKind, len(libs))\n\tfor _, lib := range libs {\n\t\tdfs(lib, mark, &order)\n\t}\n\treturn order\n}\n\nfunc dfs(lib *sym.Library, mark map[*sym.Library]markKind, order *[]*sym.Library) {\n\tif mark[lib] == visited {\n\t\treturn\n\t}\n\tif mark[lib] == visiting {\n\t\tpanic(\"found import cycle while visiting \" + lib.Pkg)\n\t}\n\tmark[lib] = visiting\n\tfor _, i := range lib.Imports {\n\t\tdfs(i, mark, order)\n\t}\n\tmark[lib] = visited\n\t*order = append(*order, lib)\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/misc/cgo/testcshared/main5.c": "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// Test that a signal handler works in non-Go code when using\n// os/signal.Notify.\n// This is a lot like misc/cgo/testcarchive/main3.c.\n\n#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <sched.h>\n#include <dlfcn.h>\n\nstatic void die(const char* msg) {\n\tperror(msg);\n\texit(EXIT_FAILURE);\n}\n\nstatic volatile sig_atomic_t sigioSeen;\n\nstatic void ioHandler(int signo, siginfo_t* info, void* ctxt) {\n\tsigioSeen = 1;\n}\n\nint main(int argc, char** argv) {\n\tint verbose;\n\tstruct sigaction sa;\n\tvoid* handle;\n\tvoid (*fn1)(void);\n\tint (*sawSIGIO)(void);\n\tint i;\n\tstruct timespec ts;\n\n\tverbose = argc > 2;\n\tsetvbuf(stdout, NULL, _IONBF, 0);\n\n\tif (verbose) {\n\t\tprintf(\"calling sigaction\\n\");\n\t}\n\n\tmemset(&sa, 0, sizeof sa);\n\tsa.sa_sigaction = ioHandler;\n\tif (sigemptyset(&sa.sa_mask) < 0) {\n\t\tdie(\"sigemptyset\");\n\t}\n\tsa.sa_flags = SA_SIGINFO;\n\tif (sigaction(SIGIO, &sa, NULL) < 0) {\n\t\tdie(\"sigaction\");\n\t}\n\n\tif (verbose) {\n\t\tprintf(\"calling dlopen\\n\");\n\t}\n\n\thandle = dlopen(argv[1], RTLD_NOW | RTLD_GLOBAL);\n\tif (handle == NULL) {\n\t\tfprintf(stderr, \"%s\\n\", dlerror());\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t// At this point there should not be a Go signal handler\n\t// installed for SIGIO.\n\n\tif (verbose) {\n\t\tprintf(\"raising SIGIO\\n\");\n\t}\n\n\tif (raise(SIGIO) < 0) {\n\t\tdie(\"raise\");\n\t}\n\n\tif (verbose) {\n\t\tprintf(\"waiting for sigioSeen\\n\");\n\t}\n\n\t// Wait until the signal has been delivered.\n\ti = 0;\n\twhile (!sigioSeen) {\n\t\tts.tv_sec = 0;\n\t\tts.tv_nsec = 1000000;\n\t\tnanosleep(&ts, NULL);\n\t\ti++;\n\t\tif (i > 5000) {\n\t\t\tfprintf(stderr, \"looping too long waiting for signal\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\n\tsigioSeen = 0;\n\n\t// Tell the Go code to catch SIGIO.\n\n\tif (verbose) {\n\t\tprintf(\"calling dlsym\\n\");\n\t}\n\n\tfn1 = (void(*)(void))dlsym(handle, \"CatchSIGIO\");\n\tif (fn1 == NULL) {\n\t\tfprintf(stderr, \"%s\\n\", dlerror());\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (verbose) {\n\t\tprintf(\"calling CatchSIGIO\\n\");\n\t}\n\n\tfn1();\n\n\tif (verbose) {\n\t\tprintf(\"raising SIGIO\\n\");\n\t}\n\n\tif (raise(SIGIO) < 0) {\n\t\tdie(\"raise\");\n\t}\n\n\tif (verbose) {\n\t\tprintf(\"calling dlsym\\n\");\n\t}\n\n\t// Check that the Go code saw SIGIO.\n\tsawSIGIO = (int (*)(void))dlsym(handle, \"SawSIGIO\");\n\tif (sawSIGIO == NULL) {\n\t\tfprintf(stderr, \"%s\\n\", dlerror());\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (verbose) {\n\t\tprintf(\"calling SawSIGIO\\n\");\n\t}\n\n\tif (!sawSIGIO()) {\n\t\tfprintf(stderr, \"Go handler did not see SIGIO\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (sigioSeen != 0) {\n\t\tfprintf(stderr, \"C handler saw SIGIO when only Go handler should have\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t// Tell the Go code to stop catching SIGIO.\n\n\tif (verbose) {\n\t\tprintf(\"calling dlsym\\n\");\n\t}\n\n\tfn1 = (void(*)(void))dlsym(handle, \"ResetSIGIO\");\n\tif (fn1 == NULL) {\n\t\tfprintf(stderr, \"%s\\n\", dlerror());\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (verbose) {\n\t\tprintf(\"calling ResetSIGIO\\n\");\n\t}\n\n\tfn1();\n\n\tif (verbose) {\n\t\tprintf(\"raising SIGIO\\n\");\n\t}\n\n\tif (raise(SIGIO) < 0) {\n\t\tdie(\"raise\");\n\t}\n\n\tif (verbose) {\n\t\tprintf(\"calling SawSIGIO\\n\");\n\t}\n\n\tif (sawSIGIO()) {\n\t\tfprintf(stderr, \"Go handler saw SIGIO after Reset\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (verbose) {\n\t\tprintf(\"waiting for sigioSeen\\n\");\n\t}\n\n\t// Wait until the signal has been delivered.\n\ti = 0;\n\twhile (!sigioSeen) {\n\t\tts.tv_sec = 0;\n\t\tts.tv_nsec = 1000000;\n\t\tnanosleep(&ts, NULL);\n\t\ti++;\n\t\tif (i > 5000) {\n\t\t\tfprintf(stderr, \"looping too long waiting for signal\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\n\tprintf(\"PASS\\n\");\n\treturn 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/misc/cgo/testcshared/main1.c": "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n#include <stdint.h>\n#include <stdio.h>\n#include <dlfcn.h>\n\nint check_int8(void* handle, const char* fname, int8_t want) {\n  int8_t (*fn)();\n  fn = (int8_t (*)())dlsym(handle, fname);\n  if (!fn) {\n    fprintf(stderr, \"ERROR: missing %s: %s\\n\", fname, dlerror());\n    return 1;\n  }\n  signed char ret = fn();\n  if (ret != want) {\n    fprintf(stderr, \"ERROR: %s=%d, want %d\\n\", fname, ret, want);\n    return 1;\n  }\n  return 0;\n}\n\nint check_int32(void* handle, const char* fname, int32_t want) {\n  int32_t (*fn)();\n  fn = (int32_t (*)())dlsym(handle, fname);\n  if (!fn) {\n    fprintf(stderr, \"ERROR: missing %s: %s\\n\", fname, dlerror());\n    return 1;\n  }\n  int32_t ret = fn();\n  if (ret != want) {\n    fprintf(stderr, \"ERROR: %s=%d, want %d\\n\", fname, ret, want);\n    return 1;\n  }\n  return 0;\n}\n\n// Tests libgo.so to export the following functions.\n//   int8_t DidInitRun() // returns true\n//   int8_t DidMainRun() // returns true\n//   int32_t FromPkg() // returns 1024\nint main(int argc, char** argv) {\n  void* handle = dlopen(argv[1], RTLD_LAZY | RTLD_GLOBAL);\n  if (!handle) {\n    fprintf(stderr, \"ERROR: failed to open the shared library: %s\\n\",\n\t\t    dlerror());\n    return 2;\n  }\n\n  int ret = 0;\n  ret = check_int8(handle, \"DidInitRun\", 1);\n  if (ret != 0) {\n    return ret;\n  }\n\n  ret = check_int8(handle, \"DidMainRun\", 0);\n  if (ret != 0) {\n    return ret;\n  }\n\n  ret = check_int32(handle, \"FromPkg\", 1024);\n  if (ret != 0) {\n   return ret;\n  }\n  // test.bash looks for \"PASS\" to ensure this program has reached the end. \n  printf(\"PASS\\n\");\n  return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/misc/cgo/testcshared/main3.c": "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n#include <stdint.h>\n#include <stdio.h>\n#include <dlfcn.h>\n\n// Tests \"main.main\" is exported on android/arm,\n// which golang.org/x/mobile/app depends on.\nint main(int argc, char** argv) {\n  void* handle = dlopen(argv[1], RTLD_LAZY | RTLD_GLOBAL);\n  if (!handle) {\n    fprintf(stderr, \"ERROR: failed to open the shared library: %s\\n\",\n            dlerror());\n    return 2;\n  }\n\n  uintptr_t main_fn = (uintptr_t)dlsym(handle, \"main.main\");\n  if (!main_fn) {\n    fprintf(stderr, \"ERROR: missing main.main: %s\\n\", dlerror());\n    return 2;\n  }\n\n  // TODO(hyangah): check that main.main can run.\n\n  printf(\"PASS\\n\");\n  return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/misc/cgo/testcshared/main4.c": "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// Test that a signal handler that uses up stack space does not crash\n// if the signal is delivered to a thread running a goroutine.\n// This is a lot like misc/cgo/testcarchive/main2.c.\n\n#include <setjmp.h>\n#include <signal.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <sched.h>\n#include <time.h>\n#include <dlfcn.h>\n\nstatic void die(const char* msg) {\n\tperror(msg);\n\texit(EXIT_FAILURE);\n}\n\nstatic volatile sig_atomic_t sigioSeen;\n\n// Use up some stack space.\nstatic void recur(int i, char *p) {\n\tchar a[1024];\n\n\t*p = '\\0';\n\tif (i > 0) {\n\t\trecur(i - 1, a);\n\t}\n}\n\n// Signal handler that uses up more stack space than a goroutine will have.\nstatic void ioHandler(int signo, siginfo_t* info, void* ctxt) {\n\tchar a[1024];\n\n\trecur(4, a);\n\tsigioSeen = 1;\n}\n\nstatic jmp_buf jmp;\nstatic char* nullPointer;\n\n// Signal handler for SIGSEGV on a C thread.\nstatic void segvHandler(int signo, siginfo_t* info, void* ctxt) {\n\tsigset_t mask;\n\tint i;\n\n\tif (sigemptyset(&mask) < 0) {\n\t\tdie(\"sigemptyset\");\n\t}\n\tif (sigaddset(&mask, SIGSEGV) < 0) {\n\t\tdie(\"sigaddset\");\n\t}\n\ti = sigprocmask(SIG_UNBLOCK, &mask, NULL);\n\tif (i != 0) {\n\t\tfprintf(stderr, \"sigprocmask: %s\\n\", strerror(i));\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t// Don't try this at home.\n\tlongjmp(jmp, signo);\n\n\t// We should never get here.\n\tabort();\n}\n\nint main(int argc, char** argv) {\n\tint verbose;\n\tstruct sigaction sa;\n\tvoid* handle;\n\tvoid (*fn)(void);\n\tsigset_t mask;\n\tint i;\n\tstruct timespec ts;\n\n\tverbose = argc > 2;\n\tsetvbuf(stdout, NULL, _IONBF, 0);\n\n\t// Call setsid so that we can use kill(0, SIGIO) below.\n\t// Don't check the return value so that this works both from\n\t// a job control shell and from a shell script.\n\tsetsid();\n\n\tif (verbose) {\n\t\tprintf(\"calling sigaction\\n\");\n\t}\n\n\tmemset(&sa, 0, sizeof sa);\n\tsa.sa_sigaction = ioHandler;\n\tif (sigemptyset(&sa.sa_mask) < 0) {\n\t\tdie(\"sigemptyset\");\n\t}\n\tsa.sa_flags = SA_SIGINFO;\n\tif (sigaction(SIGIO, &sa, NULL) < 0) {\n\t\tdie(\"sigaction\");\n\t}\n\n\tsa.sa_sigaction = segvHandler;\n\tif (sigaction(SIGSEGV, &sa, NULL) < 0 || sigaction(SIGBUS, &sa, NULL) < 0) {\n\t\tdie(\"sigaction\");\n\t}\n\n\tif (verbose) {\n\t\tprintf(\"calling dlopen\\n\");\n\t}\n\n\thandle = dlopen(argv[1], RTLD_NOW | RTLD_GLOBAL);\n\tif (handle == NULL) {\n\t\tfprintf(stderr, \"%s\\n\", dlerror());\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (verbose) {\n\t\tprintf(\"calling dlsym\\n\");\n\t}\n\n\t// Start some goroutines.\n\tfn = (void(*)(void))dlsym(handle, \"RunGoroutines\");\n\tif (fn == NULL) {\n\t\tfprintf(stderr, \"%s\\n\", dlerror());\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (verbose) {\n\t\tprintf(\"calling RunGoroutines\\n\");\n\t}\n\n\tfn();\n\n\t// Block SIGIO in this thread to make it more likely that it\n\t// will be delivered to a goroutine.\n\n\tif (verbose) {\n\t\tprintf(\"calling pthread_sigmask\\n\");\n\t}\n\n\tif (sigemptyset(&mask) < 0) {\n\t\tdie(\"sigemptyset\");\n\t}\n\tif (sigaddset(&mask, SIGIO) < 0) {\n\t\tdie(\"sigaddset\");\n\t}\n\ti = pthread_sigmask(SIG_BLOCK, &mask, NULL);\n\tif (i != 0) {\n\t\tfprintf(stderr, \"pthread_sigmask: %s\\n\", strerror(i));\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (verbose) {\n\t\tprintf(\"calling kill\\n\");\n\t}\n\n\tif (kill(0, SIGIO) < 0) {\n\t\tdie(\"kill\");\n\t}\n\n\tif (verbose) {\n\t\tprintf(\"waiting for sigioSeen\\n\");\n\t}\n\n\t// Wait until the signal has been delivered.\n\ti = 0;\n\twhile (!sigioSeen) {\n\t\tts.tv_sec = 0;\n\t\tts.tv_nsec = 1000000;\n\t\tnanosleep(&ts, NULL);\n\t\ti++;\n\t\tif (i > 5000) {\n\t\t\tfprintf(stderr, \"looping too long waiting for signal\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\n\tif (verbose) {\n\t\tprintf(\"calling setjmp\\n\");\n\t}\n\n\t// Test that a SIGSEGV on this thread is delivered to us.\n\tif (setjmp(jmp) == 0) {\n\t\tif (verbose) {\n\t\t\tprintf(\"triggering SIGSEGV\\n\");\n\t\t}\n\n\t\t*nullPointer = '\\0';\n\n\t\tfprintf(stderr, \"continued after address error\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (verbose) {\n\t\tprintf(\"calling dlsym\\n\");\n\t}\n\n\t// Make sure that a SIGSEGV in Go causes a run-time panic.\n\tfn = (void (*)(void))dlsym(handle, \"TestSEGV\");\n\tif (fn == NULL) {\n\t\tfprintf(stderr, \"%s\\n\", dlerror());\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (verbose) {\n\t\tprintf(\"calling TestSEGV\\n\");\n\t}\n\n\tfn();\n\n\tprintf(\"PASS\\n\");\n\treturn 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/misc/cgo/test/issue4029.go": "// Copyright 2012 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// +build !windows,!static\n\npackage cgotest\n\n/*\n#include <stdint.h>\n#include <dlfcn.h>\n#cgo linux LDFLAGS: -ldl\n\nextern uintptr_t dlopen4029(char*, int);\nextern uintptr_t dlsym4029(uintptr_t, char*);\nextern int dlclose4029(uintptr_t);\n\nextern void call4029(uintptr_t arg);\n*/\nimport \"C\"\n\nimport (\n\t\"testing\"\n)\n\nvar callbacks int\n\n//export IMPIsOpaque\nfunc IMPIsOpaque() {\n\tcallbacks++\n}\n\n//export IMPInitWithFrame\nfunc IMPInitWithFrame() {\n\tcallbacks++\n}\n\n//export IMPDrawRect\nfunc IMPDrawRect() {\n\tcallbacks++\n}\n\n//export IMPWindowResize\nfunc IMPWindowResize() {\n\tcallbacks++\n}\n\nfunc test4029(t *testing.T) {\n\tloadThySelf(t, \"IMPWindowResize\")\n\tloadThySelf(t, \"IMPDrawRect\")\n\tloadThySelf(t, \"IMPInitWithFrame\")\n\tloadThySelf(t, \"IMPIsOpaque\")\n\tif callbacks != 4 {\n\t\tt.Errorf(\"got %d callbacks, expected 4\", callbacks)\n\t}\n}\n\nfunc loadThySelf(t *testing.T, symbol string) {\n\tthis_process := C.dlopen4029(nil, C.RTLD_NOW)\n\tif this_process == 0 {\n\t\tt.Error(\"dlopen:\", C.GoString(C.dlerror()))\n\t\treturn\n\t}\n\tdefer C.dlclose4029(this_process)\n\n\tsymbol_address := C.dlsym4029(this_process, C.CString(symbol))\n\tif symbol_address == 0 {\n\t\tt.Error(\"dlsym:\", C.GoString(C.dlerror()))\n\t\treturn\n\t}\n\tt.Log(symbol, symbol_address)\n\tC.call4029(symbol_address)\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/misc/cgo/test/issue4029.c": "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// +build !windows,!static\n\n#include <stdint.h>\n#include <dlfcn.h>\n\n// Write our own versions of dlopen/dlsym/dlclose so that we represent\n// the opaque handle as a Go uintptr rather than a Go pointer to avoid\n// garbage collector confusion.  See issue 23663.\n\nuintptr_t dlopen4029(char* name, int flags) {\n\treturn (uintptr_t)(dlopen(name, flags));\n}\n\nuintptr_t dlsym4029(uintptr_t handle, char* name) {\n\treturn (uintptr_t)(dlsym((void*)(handle), name));\n}\n\nint dlclose4029(uintptr_t handle) {\n\treturn dlclose((void*)(handle));\n}\n\nvoid call4029(void *arg) {\n\tvoid (*fn)(void) = arg;\n\tfn();\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/favicon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/compress/bzip2/testdata/pass-sawtooth.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/compress/bzip2/testdata/fail-issue5747.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/compress/bzip2/testdata/pass-random2.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/compress/bzip2/testdata/e.txt.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/compress/bzip2/testdata/random.data.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/compress/bzip2/testdata/pass-random2.bin",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/compress/bzip2/testdata/pass-random1.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/compress/bzip2/testdata/pass-random1.bin",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/compress/bzip2/testdata/Isaac.Newton-Opticks.txt.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/compress/gzip/testdata/issue6550.gz",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/compress/flate/testdata/huffman-rand-limit.wb.expect-noinput",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/compress/flate/testdata/huffman-shifts.wb.expect-noinput",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/compress/flate/testdata/huffman-rand-max.golden",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/compress/flate/testdata/huffman-text-shift.wb.expect",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/compress/flate/testdata/huffman-null-max.golden",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/compress/flate/testdata/huffman-rand-max.in",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/compress/flate/testdata/huffman-rand-1k.golden",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/compress/flate/testdata/huffman-pi.golden",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/compress/flate/testdata/huffman-rand-limit.wb.expect",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/compress/flate/testdata/huffman-rand-1k.dyn.expect-noinput",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/compress/flate/testdata/huffman-zero.golden",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/compress/flate/testdata/huffman-null-max.wb.expect",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/compress/flate/testdata/null-long-match.wb.expect-noinput",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/compress/flate/testdata/huffman-shifts.golden",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/compress/flate/testdata/huffman-text.golden",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/compress/flate/testdata/huffman-zero.dyn.expect-noinput",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/compress/flate/testdata/huffman-rand-1k.wb.expect-noinput",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/compress/flate/testdata/huffman-pi.wb.expect-noinput",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/compress/flate/testdata/huffman-pi.dyn.expect-noinput",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/compress/flate/testdata/huffman-rand-1k.dyn.expect",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/compress/flate/testdata/huffman-text-shift.golden",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/compress/flate/testdata/huffman-null-max.dyn.expect-noinput",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/compress/flate/testdata/huffman-text.dyn.expect",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/compress/flate/testdata/huffman-shifts.dyn.expect-noinput",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/compress/flate/testdata/huffman-rand-1k.wb.expect",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/compress/flate/testdata/huffman-rand-limit.dyn.expect-noinput",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/compress/flate/testdata/huffman-null-max.wb.expect-noinput",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/compress/flate/testdata/huffman-text-shift.wb.expect-noinput",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/compress/flate/testdata/huffman-text-shift.dyn.expect",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/compress/flate/testdata/huffman-null-max.dyn.expect",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/compress/flate/testdata/huffman-shifts.wb.expect",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/compress/flate/testdata/huffman-zero.dyn.expect",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/compress/flate/testdata/null-long-match.dyn.expect-noinput",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/compress/flate/testdata/huffman-text.wb.expect",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/compress/flate/testdata/huffman-rand-limit.golden",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/compress/flate/testdata/huffman-text.wb.expect-noinput",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/compress/flate/testdata/huffman-text.dyn.expect-noinput",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/compress/flate/testdata/huffman-rand-1k.in",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/compress/flate/testdata/huffman-pi.dyn.expect",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/compress/flate/testdata/huffman-rand-limit.dyn.expect",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/compress/flate/testdata/huffman-shifts.dyn.expect",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/compress/flate/testdata/huffman-pi.wb.expect",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/compress/flate/testdata/huffman-text-shift.dyn.expect-noinput",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/compress/flate/testdata/huffman-rand-limit.in",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/regexp/testdata/re2-exhaustive.txt.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/go/internal/gcimporter/testdata/versions/test_go1.11_999i.a",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/go/internal/gcimporter/testdata/versions/test_go1.7_1.a",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/go/internal/gcimporter/testdata/versions/test_go1.8_5.a",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/go/internal/gcimporter/testdata/versions/test_go1.11_6b.a",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/go/internal/gcimporter/testdata/versions/test_go1.8_4.a",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/go/internal/gcimporter/testdata/versions/test_go1.11_0i.a",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/go/internal/gcimporter/testdata/versions/test_go1.7_0.a",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/go/internal/gccgoimporter/testdata/unicode.gox",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/go/internal/gccgoimporter/testdata/escapeinfo.gox",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/go/internal/gccgoimporter/testdata/libimportsar.a",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/go/internal/gccgoimporter/testdata/v1reflect.gox",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/go/internal/gccgoimporter/testdata/time.gox",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/encoding/json/testdata/code.json.gz",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/testdata/video-001.progressive.truncated.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/testdata/video-005.gray.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/testdata/video-001.cmyk.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/testdata/video-001.separate.dc.progression.progressive.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/testdata/video-001.221212.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/testdata/video-001.cmyk.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/testdata/video-005.gray.q50.2x2.progressive.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/testdata/video-001.q50.440.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/testdata/video-001.q50.411.progressive.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/testdata/video-001.q50.422.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/testdata/video-001.rgb.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/testdata/video-005.gray.q50.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/testdata/video-001.5bpp.gif",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/testdata/video-005.gray.q50.2x2.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/testdata/video-001.separate.dc.progression.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/testdata/video-005.gray.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/testdata/video-001.q50.410.progressive.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/testdata/video-001.gif",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/testdata/video-001.rgb.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/testdata/video-001.q50.410.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/testdata/video-001.q50.444.progressive.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/testdata/video-001.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/testdata/video-001.progressive.truncated.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/testdata/video-001.221212.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/testdata/video-005.gray.gif",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/testdata/video-001.q50.411.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/testdata/video-001.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/testdata/video-001.q50.440.progressive.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/testdata/video-001.q50.420.progressive.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/testdata/video-001.q50.444.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/testdata/video-001.q50.422.progressive.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/testdata/video-001.progressive.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/testdata/video-005.gray.q50.progressive.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/testdata/video-001.q50.420.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/testdata/video-001.interlaced.gif",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/png/testdata/benchPaletted.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/png/testdata/invalid-zlib.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/png/testdata/benchRGB-interlace.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/png/testdata/gray-gradient.interlaced.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/png/testdata/benchNRGBA-gradient.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/png/testdata/invalid-crc32.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/png/testdata/benchNRGBA-opaque.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/png/testdata/invalid-trunc.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/png/testdata/benchGray.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/png/testdata/gray-gradient.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/png/testdata/benchRGB.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/png/testdata/invalid-noend.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/png/testdata/pngsuite/ftbbn0g04.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/png/testdata/pngsuite/ftbbn2c16.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/png/testdata/pngsuite/basn4a16.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/png/testdata/pngsuite/basn0g04-31.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/png/testdata/pngsuite/ftbbn3p08.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/png/testdata/pngsuite/basn2c08.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/png/testdata/pngsuite/ftp0n2c08.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/png/testdata/pngsuite/basn4a08.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/png/testdata/pngsuite/basn0g08.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/png/testdata/pngsuite/ftbgn3p08.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/png/testdata/pngsuite/basn3p02.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/png/testdata/pngsuite/basn3p08.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/png/testdata/pngsuite/ftbwn3p08.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/png/testdata/pngsuite/ftp0n0g08.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/png/testdata/pngsuite/ftbbn0g01.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/png/testdata/pngsuite/ftbwn0g16.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/png/testdata/pngsuite/basn0g02.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/png/testdata/pngsuite/basn0g04.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/png/testdata/pngsuite/basn0g16.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/png/testdata/pngsuite/ftbyn3p08.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/png/testdata/pngsuite/ftbgn2c16.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/png/testdata/pngsuite/basn0g02-29.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/png/testdata/pngsuite/basn3p08-trns.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/png/testdata/pngsuite/basn3p01.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/png/testdata/pngsuite/basn6a16.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/png/testdata/pngsuite/ftp0n3p08.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/png/testdata/pngsuite/ftbrn2c08.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/png/testdata/pngsuite/basn3p04-31i.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/png/testdata/pngsuite/basn0g01-30.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/png/testdata/pngsuite/basn3p04.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/png/testdata/pngsuite/ftbbn0g02.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/png/testdata/pngsuite/basn2c16.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/png/testdata/pngsuite/basn6a08.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/png/testdata/pngsuite/basn0g01.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/image/png/testdata/pngsuite/ftp1n3p08.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/runtime/race/race_linux_arm64.syso",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/runtime/race/race_darwin_amd64.syso",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/runtime/race/race_freebsd_amd64.syso",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/runtime/race/race_windows_amd64.syso",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/runtime/race/race_netbsd_amd64.syso",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/runtime/race/race_linux_amd64.syso",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/runtime/race/race_linux_ppc64le.syso",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/archive/zip/testdata/test-trailing-junk.zip",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/archive/zip/testdata/symlink.zip",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/archive/zip/testdata/time-7zip.zip",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/archive/zip/testdata/crc32-not-streamed.zip",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/archive/zip/testdata/go-with-datadesc-sig.zip",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/archive/zip/testdata/readme.notzip",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/archive/zip/testdata/utf8-7zip.zip",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/archive/zip/testdata/test.zip",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/archive/zip/testdata/time-winrar.zip",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/archive/zip/testdata/zip64.zip",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/archive/zip/testdata/time-infozip.zip",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/archive/zip/testdata/gophercolor16x16.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/archive/zip/testdata/time-22738.zip",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/archive/zip/testdata/time-winzip.zip",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/archive/zip/testdata/utf8-winzip.zip",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/archive/zip/testdata/time-osx.zip",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/archive/zip/testdata/utf8-osx.zip",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/archive/zip/testdata/utf8-infozip.zip",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/archive/zip/testdata/winxp.zip",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/archive/zip/testdata/time-win7.zip",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/archive/zip/testdata/time-go.zip",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/archive/zip/testdata/unix.zip",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/archive/zip/testdata/go-no-datadesc-sig.zip",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/archive/zip/testdata/dd.zip",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/archive/zip/testdata/zip64-2.zip",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/archive/zip/testdata/readme.zip",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/archive/zip/testdata/utf8-winrar.zip",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/archive/tar/testdata/invalid-go17.tar",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/archive/tar/testdata/writer-big.tar",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/archive/tar/testdata/gnu-sparse-big.tar",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/archive/tar/testdata/gnu-utf8.tar",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/archive/tar/testdata/issue10968.tar",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/archive/tar/testdata/v7.tar",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/archive/tar/testdata/issue12435.tar",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/archive/tar/testdata/neg-size.tar",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/archive/tar/testdata/gnu-not-utf8.tar",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/crypto/rsa/testdata/pss-vect.txt.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/crypto/ecdsa/testdata/SigVer.rsp.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/cmd/vendor/github.com/google/pprof/internal/report/testdata/sample.cpu",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/cmd/vendor/github.com/google/pprof/internal/report/testdata/sample.bin",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/cmd/vendor/github.com/google/pprof/internal/driver/testdata/go.crc32.cpu",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/cmd/vendor/github.com/google/pprof/internal/driver/testdata/go.nomappings.crash",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/cmd/vendor/github.com/google/pprof/internal/driver/testdata/cppbench.cpu",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/cmd/vendor/github.com/google/pprof/profile/testdata/go.crc32.cpu",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/cmd/vendor/github.com/google/pprof/profile/testdata/gobench.cpu",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/cmd/vendor/github.com/google/pprof/profile/testdata/cppbench.cpu",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/cmd/internal/buildid/testdata/a.elf",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/cmd/internal/buildid/testdata/a.macho",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/cmd/internal/buildid/testdata/p.a",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/cmd/internal/buildid/testdata/a.pe",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/debug/elf/testdata/go-relocation-test-gcc720-riscv64.obj",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/debug/elf/testdata/go-relocation-test-gcc620-sparc64.obj",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/debug/elf/testdata/go-relocation-test-gcc492-arm.obj",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/debug/elf/testdata/go-relocation-test-gcc441-x86.obj",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/debug/elf/testdata/go-relocation-test-gcc493-mips64le.obj",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/debug/elf/testdata/go-relocation-test-gcc492-mipsle.obj",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/debug/elf/testdata/hello-world-core.gz",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/debug/elf/testdata/go-relocation-test-gcc482-aarch64.obj",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/debug/elf/testdata/go-relocation-test-clang-arm.obj",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/debug/elf/testdata/zdebug-test-gcc484-x86-64.obj",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/debug/elf/testdata/gcc-amd64-openbsd-debug-with-rela.obj",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/debug/elf/testdata/go-relocation-test-gcc5-ppc.obj",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/debug/elf/testdata/go-relocation-test-gcc492-mips64.obj",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/debug/elf/testdata/go-relocation-test-gcc531-s390x.obj",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/debug/elf/testdata/compressed-32.obj",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/debug/elf/testdata/go-relocation-test-gcc482-ppc64le.obj",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/debug/elf/testdata/go-relocation-test-gcc441-x86-64.obj",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/debug/elf/testdata/go-relocation-test-gcc540-mips.obj",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/debug/elf/testdata/go-relocation-test-gcc424-x86-64.obj",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/debug/elf/testdata/compressed-64.obj",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/debug/elf/testdata/go-relocation-test-clang-x86.obj",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/debug/macho/testdata/clang-amd64-darwin.obj",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/debug/macho/testdata/clang-386-darwin.obj",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/debug/dwarf/testdata/line-clang.elf",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/debug/dwarf/testdata/typedef.macho",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/debug/dwarf/testdata/ranges.elf",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/debug/dwarf/testdata/typedef.elf",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/debug/dwarf/testdata/typedef.elf4",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/debug/dwarf/testdata/line-gcc-win.bin",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/debug/dwarf/testdata/line-gcc.elf",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/debug/dwarf/testdata/split.elf",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/src/debug/dwarf/testdata/cycle.elf",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/lib/time/zoneinfo.zip",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/misc/chrome/gophertool/gopher.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/doc/go-logo-blue.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/doc/go-logo-black.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/doc/go-logo-white.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/doc/share.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/doc/gopher/help.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/doc/gopher/bumper192x108.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/doc/gopher/appenginegophercolor.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/doc/gopher/gopherbw.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/doc/gopher/project.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/doc/gopher/ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/doc/gopher/bumper.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/doc/gopher/bumper640x360.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/doc/gopher/gophercolor.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/doc/gopher/modelsheet.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/doc/gopher/gophercolor16x16.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/doc/gopher/pkg.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/doc/gopher/biplane.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/doc/gopher/fiveyears.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/doc/gopher/talks.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/doc/gopher/appenginegopher.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/doc/gopher/run.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/doc/gopher/bumper480x270.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/doc/gopher/doc.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/doc/gopher/appenginelogo.gif",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/doc/gopher/frontpage.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/doc/gopher/bumper320x180.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/doc/gopher/pencil/gopherswrench.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/doc/gopher/pencil/gophermega.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/doc/gopher/pencil/gopherhat.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/doc/gopher/pencil/gopherswim.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/doc/gopher/pencil/gopherhelmet.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/doc/gopher/pencil/gopherrunning.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.12.13-hmk3w7wxzmroepvikyktqiki2njwnsld/spack-src/doc/codewalk/popout.png"
    ],
    "total_files": 8368
}