{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/runtime/rt0_linux_arm.s": "// Copyright 2009 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n#include \"textflag.h\"\n\nTEXT _rt0_arm_linux(SB),NOSPLIT,$-4\n\tMOVW\t(R13), R0\t// argc\n\tMOVW\t$4(R13), R1\t\t// argv\n\tMOVW\t$_rt0_arm_linux1(SB), R4\n\tB\t\t(R4)\n\n// When building with -buildmode=c-shared, this symbol is called when the shared\n// library is loaded.\nTEXT _rt0_arm_linux_lib(SB),NOSPLIT,$104\n\t// Preserve callee-save registers. Raspberry Pi's dlopen(), for example,\n\t// actually cares that R11 is preserved.\n\tMOVW\tR4, 12(R13)\n\tMOVW\tR5, 16(R13)\n\tMOVW\tR6, 20(R13)\n\tMOVW\tR7, 24(R13)\n\tMOVW\tR8, 28(R13)\n\tMOVW\tR11, 32(R13)\n\n\t// Skip floating point registers on GOARM < 6.\n\tMOVB    runtime\u00b7goarm(SB), R11\n\tCMP $6, R11\n\tBLT skipfpsave\n\tMOVD\tF8, (32+8*1)(R13)\n\tMOVD\tF9, (32+8*2)(R13)\n\tMOVD\tF10, (32+8*3)(R13)\n\tMOVD\tF11, (32+8*4)(R13)\n\tMOVD\tF12, (32+8*5)(R13)\n\tMOVD\tF13, (32+8*6)(R13)\n\tMOVD\tF14, (32+8*7)(R13)\n\tMOVD\tF15, (32+8*8)(R13)\nskipfpsave:\n\t// Save argc/argv.\n\tMOVW\tR0, _rt0_arm_linux_lib_argc<>(SB)\n\tMOVW\tR1, _rt0_arm_linux_lib_argv<>(SB)\n\n\t// Synchronous initialization.\n\tMOVW\t$runtime\u00b7libpreinit(SB), R2\n\tCALL\t(R2)\n\n\t// Create a new thread to do the runtime initialization.\n\tMOVW\t_cgo_sys_thread_create(SB), R2\n\tCMP\t$0, R2\n\tBEQ\tnocgo\n\tMOVW\t$_rt0_arm_linux_lib_go<>(SB), R0\n\tMOVW\t$0, R1\n\tBL\t(R2)\n\tB\trr\nnocgo:\n\tMOVW\t$0x800000, R0                     // stacksize = 8192KB\n\tMOVW\t$_rt0_arm_linux_lib_go<>(SB), R1  // fn\n\tMOVW\tR0, 4(R13)\n\tMOVW\tR1, 8(R13)\n\tBL\truntime\u00b7newosproc0(SB)\nrr:\n\t// Restore callee-save registers and return.\n\tMOVB    runtime\u00b7goarm(SB), R11\n\tCMP $6, R11\n\tBLT skipfprest\n\tMOVD\t(32+8*1)(R13), F8\n\tMOVD\t(32+8*2)(R13), F9\n\tMOVD\t(32+8*3)(R13), F10\n\tMOVD\t(32+8*4)(R13), F11\n\tMOVD\t(32+8*5)(R13), F12\n\tMOVD\t(32+8*6)(R13), F13\n\tMOVD\t(32+8*7)(R13), F14\n\tMOVD\t(32+8*8)(R13), F15\nskipfprest:\n\tMOVW\t12(R13), R4\n\tMOVW\t16(R13), R5\n\tMOVW\t20(R13), R6\n\tMOVW\t24(R13), R7\n\tMOVW\t28(R13), R8\n\tMOVW\t32(R13), R11\n\tRET\n\nTEXT _rt0_arm_linux_lib_go<>(SB),NOSPLIT,$8\n\tMOVW\t_rt0_arm_linux_lib_argc<>(SB), R0\n\tMOVW\t_rt0_arm_linux_lib_argv<>(SB), R1\n\tMOVW\tR0, 0(R13)\n\tMOVW\tR1, 4(R13)\n\tB\truntime\u00b7rt0_go(SB)\n\nDATA _rt0_arm_linux_lib_argc<>(SB)/4,$0\nGLOBL _rt0_arm_linux_lib_argc<>(SB),NOPTR,$4\nDATA _rt0_arm_linux_lib_argv<>(SB)/4,$0\nGLOBL _rt0_arm_linux_lib_argv<>(SB),NOPTR,$4\n\nTEXT _rt0_arm_linux1(SB),NOSPLIT,$-4\n\t// We first need to detect the kernel ABI, and warn the user\n\t// if the system only supports OABI\n\t// The strategy here is to call some EABI syscall to see if\n\t// SIGILL is received.\n\t// To catch SIGILL, we have to first setup sigaction, this is\n\t// a chicken-and-egg problem, because we can't do syscall if\n\t// we don't know the kernel ABI... Oh, not really, we can do\n\t// syscall in Thumb mode.\n\n\t// Save argc and argv\n\tMOVM.DB.W [R0-R1], (R13)\n\n\t// Thumb mode OABI check disabled because there are some\n\t// EABI systems that do not support Thumb execution.\n\t// We can run on them except for this check!\n\n\t// // set up sa_handler\n\t// MOVW\t$bad_abi<>(SB), R0 // sa_handler\n\t// MOVW\t$0, R1 // sa_flags\n\t// MOVW\t$0, R2 // sa_restorer\n\t// MOVW\t$0, R3 // sa_mask\n\t// MOVM.DB.W [R0-R3], (R13)\n\t// MOVW\t$4, R0 // SIGILL\n\t// MOVW\tR13, R1 // sa\n\t// SUB\t$16, R13\n\t// MOVW\tR13, R2 // old_sa\n\t// MOVW\t$8, R3 // c\n\t// MOVW\t$174, R7 // sys_sigaction\n\t// BL\toabi_syscall<>(SB)\n\n\t// do an EABI syscall\n\tMOVW\t$20, R7 // sys_getpid\n\tSWI\t$0 // this will trigger SIGILL on OABI systems\n\t\n\t// MOVW\t$4, R0  // SIGILL\n\t// MOVW\tR13, R1 // sa\n\t// MOVW\t$0, R2 // old_sa\n\t// MOVW\t$8, R3 // c\n\t// MOVW\t$174, R7 // sys_sigaction\n\t// SWI\t$0 // restore signal handler\n\t// ADD\t$32, R13\n\n\tB\truntime\u00b7rt0_go(SB)\n\nTEXT bad_abi<>(SB),NOSPLIT,$-4\n\t// give diagnosis and exit\n\tMOVW\t$2, R0 // stderr\n\tMOVW\t$bad_abi_msg(SB), R1 // data\n\tMOVW\t$45, R2 // len\n\tMOVW\t$4, R7 // sys_write\n\tBL\toabi_syscall<>(SB)\n\tMOVW\t$1, R0\n\tMOVW\t$1, R7 // sys_exit\n\tBL\toabi_syscall<>(SB)\n\tB  \t0(PC)\n\nDATA bad_abi_msg+0x00(SB)/8, $\"This pro\"\nDATA bad_abi_msg+0x08(SB)/8, $\"gram can\"\nDATA bad_abi_msg+0x10(SB)/8, $\" only be\"\nDATA bad_abi_msg+0x18(SB)/8, $\" run on \"\nDATA bad_abi_msg+0x20(SB)/8, $\"EABI ker\"\nDATA bad_abi_msg+0x28(SB)/4, $\"nels\"\nDATA bad_abi_msg+0x2c(SB)/1, $0xa\nGLOBL bad_abi_msg(SB), RODATA, $45\n\nTEXT oabi_syscall<>(SB),NOSPLIT,$-4\n\tADD $1, R15, R4 // R15 is hardware PC\n\tWORD $0xe12fff14 //BX\t(R4) // enter thumb mode\n\t// TODO(minux): only supports little-endian CPUs\n\tWORD $0x4770df01 // swi $1; bx lr\n\nTEXT main(SB),NOSPLIT,$-4\n\tMOVW\t$_rt0_arm_linux1(SB), R4\n\tB\t\t(R4)\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/runtime/cgo/gcc_openbsd_386.c": "// Copyright 2009 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <errno.h>\n#include <pthread.h>\n#include <signal.h>\n#include <string.h>\n#include \"libcgo.h\"\n\nstatic void* threadentry(void*);\nstatic void (*setg_gcc)(void*);\n\n// TCB_SIZE is sizeof(struct thread_control_block), as defined in\n// /usr/src/lib/librthread/tcb.h on OpenBSD 5.9 and earlier.\n#define TCB_SIZE (4 * sizeof(void *))\n\n// TIB_SIZE is sizeof(struct tib), as defined in\n// /usr/include/tib.h on OpenBSD 6.0 and later.\n#define TIB_SIZE (4 * sizeof(void *) + 6 * sizeof(int))\n\n// TLS_SIZE is the size of TLS needed for Go.\n#define TLS_SIZE (2 * sizeof(void *))\n\nvoid *__get_tcb(void);\nvoid __set_tcb(void *);\n\nstatic int (*sys_pthread_create)(pthread_t *thread, const pthread_attr_t *attr,\n\tvoid *(*start_routine)(void *), void *arg);\n\nstruct thread_args {\n\tvoid *(*func)(void *);\n\tvoid *arg;\n};\n\nstatic int has_tib = 0;\n\nstatic void\ntcb_fixup(int mainthread)\n{\n\tvoid *tls, *newtcb, *oldtcb;\n\tsize_t tls_size, tcb_size;\n\n\t// TODO(jsing): Remove once OpenBSD 6.1 is released and OpenBSD 5.9 is\n\t// no longer supported.\n\n\t// The OpenBSD ld.so(1) does not currently support PT_TLS. As a result,\n\t// we need to allocate our own TLS space while preserving the existing\n\t// TCB or TIB that has been setup via librthread.\n\n\ttcb_size = has_tib ? TIB_SIZE : TCB_SIZE;\n\ttls_size = TLS_SIZE + tcb_size;\n\ttls = malloc(tls_size);\n\tif(tls == NULL)\n\t\tabort();\n\n\t// The signal trampoline expects the TLS slots to be zeroed.\n\tbzero(tls, TLS_SIZE);\n\n\toldtcb = __get_tcb();\n\tnewtcb = tls + TLS_SIZE;\n\tbcopy(oldtcb, newtcb, tcb_size);\n\tif(has_tib) {\n\t\t // Fix up self pointer.\n\t\t*(uintptr_t *)(newtcb) = (uintptr_t)newtcb;\n\t}\n\t__set_tcb(newtcb);\n\n\t// NOTE(jsing, minux): we can't free oldtcb without causing double-free\n\t// problem. so newtcb will be memory leaks. Get rid of this when OpenBSD\n\t// has proper support for PT_TLS.\n}\n\nstatic void *\nthread_start_wrapper(void *arg)\n{\n\tstruct thread_args args = *(struct thread_args *)arg;\n\n\tfree(arg);\n\ttcb_fixup(0);\n\n\treturn args.func(args.arg);\n}\n\nstatic void init_pthread_wrapper(void) {\n\tvoid *handle;\n\n\t// Locate symbol for the system pthread_create function.\n\thandle = dlopen(\"libpthread.so\", RTLD_LAZY);\n\tif(handle == NULL) {\n\t\tfprintf(stderr, \"runtime/cgo: dlopen failed to load libpthread: %s\\n\", dlerror());\n\t\tabort();\n\t}\n\tsys_pthread_create = dlsym(handle, \"pthread_create\");\n\tif(sys_pthread_create == NULL) {\n\t\tfprintf(stderr, \"runtime/cgo: dlsym failed to find pthread_create: %s\\n\", dlerror());\n\t\tabort();\n\t}\n\t// _rthread_init is hidden in OpenBSD librthread that has TIB.\n\tif(dlsym(handle, \"_rthread_init\") == NULL) {\n\t\thas_tib = 1;\n\t}\n\tdlclose(handle);\n}\n\nstatic pthread_once_t init_pthread_wrapper_once = PTHREAD_ONCE_INIT;\n\nint\npthread_create(pthread_t *thread, const pthread_attr_t *attr,\n\tvoid *(*start_routine)(void *), void *arg)\n{\n\tstruct thread_args *p;\n\n\t// we must initialize our wrapper in pthread_create, because it is valid to call\n\t// pthread_create in a static constructor, and in fact, our test for issue 9456\n\t// does just that.\n\tif(pthread_once(&init_pthread_wrapper_once, init_pthread_wrapper) != 0) {\n\t\tfprintf(stderr, \"runtime/cgo: failed to initialize pthread_create wrapper\\n\");\n\t\tabort();\n\t}\n\n\tp = malloc(sizeof(*p));\n\tif(p == NULL) {\n\t\terrno = ENOMEM;\n\t\treturn -1;\n\t}\n\tp->func = start_routine;\n\tp->arg = arg;\n\n\treturn sys_pthread_create(thread, attr, thread_start_wrapper, p);\n}\n\nvoid\nx_cgo_init(G *g, void (*setg)(void*))\n{\n\tpthread_attr_t attr;\n\tsize_t size;\n\n\tsetg_gcc = setg;\n\tpthread_attr_init(&attr);\n\tpthread_attr_getstacksize(&attr, &size);\n\tg->stacklo = (uintptr)&attr - size + 4096;\n\tpthread_attr_destroy(&attr);\n\n\tif(pthread_once(&init_pthread_wrapper_once, init_pthread_wrapper) != 0) {\n\t\tfprintf(stderr, \"runtime/cgo: failed to initialize pthread_create wrapper\\n\");\n\t\tabort();\n\t}\n\n\ttcb_fixup(1);\n}\n\n\nvoid\n_cgo_sys_thread_start(ThreadStart *ts)\n{\n\tpthread_attr_t attr;\n\tsigset_t ign, oset;\n\tpthread_t p;\n\tsize_t size;\n\tint err;\n\n\tsigfillset(&ign);\n\tpthread_sigmask(SIG_SETMASK, &ign, &oset);\n\n\tpthread_attr_init(&attr);\n\tpthread_attr_getstacksize(&attr, &size);\n\n\t// Leave stacklo=0 and set stackhi=size; mstack will do the rest.\n\tts->g->stackhi = size;\n\terr = sys_pthread_create(&p, &attr, threadentry, ts);\n\n\tpthread_sigmask(SIG_SETMASK, &oset, nil);\n\n\tif (err != 0) {\n\t\tfprintf(stderr, \"runtime/cgo: pthread_create failed: %s\\n\", strerror(err));\n\t\tabort();\n\t}\n}\n\nstatic void*\nthreadentry(void *v)\n{\n\tThreadStart ts;\n\n\ttcb_fixup(0);\n\n\tts = *(ThreadStart*)v;\n\tfree(v);\n\n\t/*\n\t * Set specific keys.\n\t */\n\tsetg_gcc((void*)ts.g);\n\n\tcrosscall_386(ts.fn);\n\treturn nil;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/runtime/cgo/gcc_openbsd_amd64.c": "// Copyright 2009 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <errno.h>\n#include <pthread.h>\n#include <signal.h>\n#include <string.h>\n#include \"libcgo.h\"\n\nstatic void* threadentry(void*);\nstatic void (*setg_gcc)(void*);\n\n// TCB_SIZE is sizeof(struct thread_control_block), as defined in\n// /usr/src/lib/librthread/tcb.h on OpenBSD 5.9 and earlier.\n#define TCB_SIZE (4 * sizeof(void *))\n\n// TIB_SIZE is sizeof(struct tib), as defined in\n// /usr/include/tib.h on OpenBSD 6.0 and later.\n#define TIB_SIZE (4 * sizeof(void *) + 6 * sizeof(int))\n\n// TLS_SIZE is the size of TLS needed for Go.\n#define TLS_SIZE (2 * sizeof(void *))\n\nvoid *__get_tcb(void);\nvoid __set_tcb(void *);\n\nstatic int (*sys_pthread_create)(pthread_t *thread, const pthread_attr_t *attr,\n\tvoid *(*start_routine)(void *), void *arg);\n\nstruct thread_args {\n\tvoid *(*func)(void *);\n\tvoid *arg;\n};\n\nstatic int has_tib = 0;\n\nstatic void\ntcb_fixup(int mainthread)\n{\n\tvoid *tls, *newtcb, *oldtcb;\n\tsize_t tls_size, tcb_size;\n\n\t// TODO(jsing): Remove once OpenBSD 6.1 is released and OpenBSD 5.9 is\n\t// no longer supported.\n\n\t// The OpenBSD ld.so(1) does not currently support PT_TLS. As a result,\n\t// we need to allocate our own TLS space while preserving the existing\n\t// TCB or TIB that has been setup via librthread.\n\n\ttcb_size = has_tib ? TIB_SIZE : TCB_SIZE;\n\ttls_size = TLS_SIZE + tcb_size;\n\ttls = malloc(tls_size);\n\tif(tls == NULL)\n\t\tabort();\n\n\t// The signal trampoline expects the TLS slots to be zeroed.\n\tbzero(tls, TLS_SIZE);\n\n\toldtcb = __get_tcb();\n\tnewtcb = tls + TLS_SIZE;\n\tbcopy(oldtcb, newtcb, tcb_size);\n\tif(has_tib) {\n\t\t // Fix up self pointer.\n\t\t*(uintptr_t *)(newtcb) = (uintptr_t)newtcb;\n\t}\n\t__set_tcb(newtcb);\n\n\t// NOTE(jsing, minux): we can't free oldtcb without causing double-free\n\t// problem. so newtcb will be memory leaks. Get rid of this when OpenBSD\n\t// has proper support for PT_TLS.\n}\n\nstatic void *\nthread_start_wrapper(void *arg)\n{\n\tstruct thread_args args = *(struct thread_args *)arg;\n\n\tfree(arg);\n\ttcb_fixup(0);\n\n\treturn args.func(args.arg);\n}\n\nstatic void init_pthread_wrapper(void) {\n\tvoid *handle;\n\n\t// Locate symbol for the system pthread_create function.\n\thandle = dlopen(\"libpthread.so\", RTLD_LAZY);\n\tif(handle == NULL) {\n\t\tfprintf(stderr, \"runtime/cgo: dlopen failed to load libpthread: %s\\n\", dlerror());\n\t\tabort();\n\t}\n\tsys_pthread_create = dlsym(handle, \"pthread_create\");\n\tif(sys_pthread_create == NULL) {\n\t\tfprintf(stderr, \"runtime/cgo: dlsym failed to find pthread_create: %s\\n\", dlerror());\n\t\tabort();\n\t}\n\t// _rthread_init is hidden in OpenBSD librthread that has TIB.\n\tif(dlsym(handle, \"_rthread_init\") == NULL) {\n\t\thas_tib = 1;\n\t}\n\tdlclose(handle);\n}\n\nstatic pthread_once_t init_pthread_wrapper_once = PTHREAD_ONCE_INIT;\n\nint\npthread_create(pthread_t *thread, const pthread_attr_t *attr,\n\tvoid *(*start_routine)(void *), void *arg)\n{\n\tstruct thread_args *p;\n\n\t// we must initialize our wrapper in pthread_create, because it is valid to call\n\t// pthread_create in a static constructor, and in fact, our test for issue 9456\n\t// does just that.\n\tif(pthread_once(&init_pthread_wrapper_once, init_pthread_wrapper) != 0) {\n\t\tfprintf(stderr, \"runtime/cgo: failed to initialize pthread_create wrapper\\n\");\n\t\tabort();\n\t}\n\n\tp = malloc(sizeof(*p));\n\tif(p == NULL) {\n\t\terrno = ENOMEM;\n\t\treturn -1;\n\t}\n\tp->func = start_routine;\n\tp->arg = arg;\n\n\treturn sys_pthread_create(thread, attr, thread_start_wrapper, p);\n}\n\nvoid\nx_cgo_init(G *g, void (*setg)(void*))\n{\n\tpthread_attr_t attr;\n\tsize_t size;\n\n\tsetg_gcc = setg;\n\tpthread_attr_init(&attr);\n\tpthread_attr_getstacksize(&attr, &size);\n\tg->stacklo = (uintptr)&attr - size + 4096;\n\tpthread_attr_destroy(&attr);\n\n\tif(pthread_once(&init_pthread_wrapper_once, init_pthread_wrapper) != 0) {\n\t\tfprintf(stderr, \"runtime/cgo: failed to initialize pthread_create wrapper\\n\");\n\t\tabort();\n\t}\n\n\ttcb_fixup(1);\n}\n\n\nvoid\n_cgo_sys_thread_start(ThreadStart *ts)\n{\n\tpthread_attr_t attr;\n\tsigset_t ign, oset;\n\tpthread_t p;\n\tsize_t size;\n\tint err;\n\n\tsigfillset(&ign);\n\tpthread_sigmask(SIG_SETMASK, &ign, &oset);\n\n\tpthread_attr_init(&attr);\n\tpthread_attr_getstacksize(&attr, &size);\n\n\t// Leave stacklo=0 and set stackhi=size; mstack will do the rest.\n\tts->g->stackhi = size;\n\terr = sys_pthread_create(&p, &attr, threadentry, ts);\n\n\tpthread_sigmask(SIG_SETMASK, &oset, nil);\n\n\tif (err != 0) {\n\t\tfprintf(stderr, \"runtime/cgo: pthread_create failed: %s\\n\", strerror(err));\n\t\tabort();\n\t}\n}\n\nstatic void*\nthreadentry(void *v)\n{\n\tThreadStart ts;\n\n\ttcb_fixup(0);\n\n\tts = *(ThreadStart*)v;\n\tfree(v);\n\n\t/*\n\t * Set specific keys.\n\t */\n\tsetg_gcc((void*)ts.g);\n\n\tcrosscall_amd64(ts.fn);\n\treturn nil;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/cmd/link/internal/ld/lib.go": "// Inferno utils/8l/asm.c\n// http://code.google.com/p/inferno-os/source/browse/utils/8l/asm.c\n//\n//\tCopyright \u00a9 1994-1999 Lucent Technologies Inc.  All rights reserved.\n//\tPortions Copyright \u00a9 1995-1997 C H Forsyth (forsyth@terzarima.net)\n//\tPortions Copyright \u00a9 1997-1999 Vita Nuova Limited\n//\tPortions Copyright \u00a9 2000-2007 Vita Nuova Holdings Limited (www.vitanuova.com)\n//\tPortions Copyright \u00a9 2004,2006 Bruce Ellis\n//\tPortions Copyright \u00a9 2005-2007 C H Forsyth (forsyth@terzarima.net)\n//\tRevisions Copyright \u00a9 2000-2007 Lucent Technologies Inc. and others\n//\tPortions Copyright \u00a9 2009 The Go Authors. All rights reserved.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage ld\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"cmd/internal/bio\"\n\t\"cmd/internal/obj\"\n\t\"cmd/internal/sys\"\n\t\"crypto/sha1\"\n\t\"debug/elf\"\n\t\"encoding/binary\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strings\"\n\t\"sync\"\n)\n\n// Data layout and relocation.\n\n// Derived from Inferno utils/6l/l.h\n// http://code.google.com/p/inferno-os/source/browse/utils/6l/l.h\n//\n//\tCopyright \u00a9 1994-1999 Lucent Technologies Inc.  All rights reserved.\n//\tPortions Copyright \u00a9 1995-1997 C H Forsyth (forsyth@terzarima.net)\n//\tPortions Copyright \u00a9 1997-1999 Vita Nuova Limited\n//\tPortions Copyright \u00a9 2000-2007 Vita Nuova Holdings Limited (www.vitanuova.com)\n//\tPortions Copyright \u00a9 2004,2006 Bruce Ellis\n//\tPortions Copyright \u00a9 2005-2007 C H Forsyth (forsyth@terzarima.net)\n//\tRevisions Copyright \u00a9 2000-2007 Lucent Technologies Inc. and others\n//\tPortions Copyright \u00a9 2009 The Go Authors. All rights reserved.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\ntype Arch struct {\n\tFuncalign        int\n\tMaxalign         int\n\tMinalign         int\n\tDwarfregsp       int\n\tDwarfreglr       int\n\tLinuxdynld       string\n\tFreebsddynld     string\n\tNetbsddynld      string\n\tOpenbsddynld     string\n\tDragonflydynld   string\n\tSolarisdynld     string\n\tAdddynrel        func(*LSym, *Reloc)\n\tArchinit         func()\n\tArchreloc        func(*Reloc, *LSym, *int64) int\n\tArchrelocvariant func(*Reloc, *LSym, int64) int64\n\tAsmb             func()\n\tElfreloc1        func(*Reloc, int64) int\n\tElfsetupplt      func()\n\tGentext          func()\n\tMachoreloc1      func(*Reloc, int64) int\n\tPEreloc1         func(*Reloc, int64) bool\n\tWput             func(uint16)\n\tLput             func(uint32)\n\tVput             func(uint64)\n\tAppend16         func(b []byte, v uint16) []byte\n\tAppend32         func(b []byte, v uint32) []byte\n\tAppend64         func(b []byte, v uint64) []byte\n}\n\ntype Rpath struct {\n\tset bool\n\tval string\n}\n\nfunc (r *Rpath) Set(val string) error {\n\tr.set = true\n\tr.val = val\n\treturn nil\n}\n\nfunc (r *Rpath) String() string {\n\treturn r.val\n}\n\nvar (\n\tThearch Arch\n\tDebug   [128]int\n\tLcsize  int32\n\trpath   Rpath\n\tSpsize  int32\n\tSymsize int32\n)\n\n// Terrible but standard terminology.\n// A segment describes a block of file to load into memory.\n// A section further describes the pieces of that block for\n// use in debuggers and such.\n\nconst (\n\tMINFUNC = 16 // minimum size for a function\n)\n\ntype Segment struct {\n\tRwx     uint8  // permission as usual unix bits (5 = r-x etc)\n\tVaddr   uint64 // virtual address\n\tLength  uint64 // length in memory\n\tFileoff uint64 // file offset\n\tFilelen uint64 // length on disk\n\tSect    *Section\n}\n\ntype Section struct {\n\tRwx     uint8\n\tExtnum  int16\n\tAlign   int32\n\tName    string\n\tVaddr   uint64\n\tLength  uint64\n\tNext    *Section\n\tSeg     *Segment\n\tElfsect *ElfShdr\n\tReloff  uint64\n\tRellen  uint64\n}\n\n// DynlinkingGo returns whether we are producing Go code that can live\n// in separate shared libraries linked together at runtime.\nfunc DynlinkingGo() bool {\n\treturn Buildmode == BuildmodeShared || Linkshared\n}\n\n// UseRelro returns whether to make use of \"read only relocations\" aka\n// relro.\nfunc UseRelro() bool {\n\tswitch Buildmode {\n\tcase BuildmodeCShared, BuildmodeShared, BuildmodePIE:\n\t\treturn Iself\n\tdefault:\n\t\treturn Linkshared\n\t}\n}\n\nvar (\n\tSysArch            *sys.Arch\n\toutfile            string\n\tdynexp             []*LSym\n\tdynlib             []string\n\tldflag             []string\n\thavedynamic        int\n\tFuncalign          int\n\tiscgo              bool\n\telfglobalsymndx    int\n\tflag_dumpdep       bool\n\tflag_installsuffix string\n\tflag_race          int\n\tflag_msan          int\n\tBuildmode          BuildMode\n\tLinkshared         bool\n\ttracksym           string\n\tinterpreter        string\n\ttmpdir             string\n\textld              string\n\textldflags         string\n\textar              string\n\tlibgccfile         string\n\tdebug_s            int // backup old value of debug['s']\n\tCtxt               *Link\n\tHEADR              int32\n\tHEADTYPE           int32\n\tINITRND            int32\n\tINITTEXT           int64\n\tINITDAT            int64\n\tINITENTRY          string /* entry point */\n\tnerrors            int\n\tLinkmode           int\n\tliveness           int64\n)\n\nvar (\n\tSegtext   Segment\n\tSegrodata Segment\n\tSegdata   Segment\n\tSegdwarf  Segment\n)\n\n/* set by call to mywhatsys() */\n\n/* whence for ldpkg */\nconst (\n\tFileObj = 0 + iota\n\tArchiveObj\n\tPkgdef\n)\n\nvar (\n\theadstring string\n\t// buffered output\n\tBso *bufio.Writer\n)\n\n// TODO(dfc) outBuf duplicates bio.Writer\ntype outBuf struct {\n\tw   *bufio.Writer\n\tf   *os.File\n\toff int64\n}\n\nfunc (w *outBuf) Write(p []byte) (n int, err error) {\n\tn, err = w.w.Write(p)\n\tw.off += int64(n)\n\treturn n, err\n}\n\nfunc (w *outBuf) WriteString(s string) (n int, err error) {\n\tn, err = coutbuf.w.WriteString(s)\n\tw.off += int64(n)\n\treturn n, err\n}\n\nvar coutbuf outBuf\n\nconst pkgname = \"__.PKGDEF\"\n\nvar (\n\t// Set if we see an object compiled by the host compiler that is not\n\t// from a package that is known to support internal linking mode.\n\texternalobj = false\n\tgoroot      string\n\tgoarch      string\n\tgoos        string\n\ttheline     string\n)\n\nfunc Lflag(arg string) {\n\tCtxt.Libdir = append(Ctxt.Libdir, arg)\n}\n\n// A BuildMode indicates the sort of object we are building:\n//   \"exe\": build a main package and everything it imports into an executable.\n//   \"c-shared\": build a main package, plus all packages that it imports, into a\n//     single C shared library. The only callable symbols will be those functions\n//     marked as exported.\n//   \"shared\": combine all packages passed on the command line, and their\n//     dependencies, into a single shared library that will be used when\n//     building with the -linkshared option.\ntype BuildMode uint8\n\nconst (\n\tBuildmodeUnset BuildMode = iota\n\tBuildmodeExe\n\tBuildmodePIE\n\tBuildmodeCArchive\n\tBuildmodeCShared\n\tBuildmodeShared\n)\n\nfunc (mode *BuildMode) Set(s string) error {\n\tgoos := obj.Getgoos()\n\tgoarch := obj.Getgoarch()\n\tbadmode := func() error {\n\t\treturn fmt.Errorf(\"buildmode %s not supported on %s/%s\", s, goos, goarch)\n\t}\n\tswitch s {\n\tdefault:\n\t\treturn fmt.Errorf(\"invalid buildmode: %q\", s)\n\tcase \"exe\":\n\t\t*mode = BuildmodeExe\n\tcase \"pie\":\n\t\tswitch goos {\n\t\tcase \"android\", \"linux\":\n\t\tdefault:\n\t\t\treturn badmode()\n\t\t}\n\t\t*mode = BuildmodePIE\n\tcase \"c-archive\":\n\t\tswitch goos {\n\t\tcase \"darwin\", \"linux\":\n\t\tcase \"windows\":\n\t\t\tswitch goarch {\n\t\t\tcase \"amd64\", \"386\":\n\t\t\tdefault:\n\t\t\t\treturn badmode()\n\t\t\t}\n\t\tdefault:\n\t\t\treturn badmode()\n\t\t}\n\t\t*mode = BuildmodeCArchive\n\tcase \"c-shared\":\n\t\tswitch goarch {\n\t\tcase \"386\", \"amd64\", \"arm\", \"arm64\":\n\t\tdefault:\n\t\t\treturn badmode()\n\t\t}\n\t\t*mode = BuildmodeCShared\n\tcase \"shared\":\n\t\tswitch goos {\n\t\tcase \"linux\":\n\t\t\tswitch goarch {\n\t\t\tcase \"386\", \"amd64\", \"arm\", \"arm64\", \"ppc64le\", \"s390x\":\n\t\t\tdefault:\n\t\t\t\treturn badmode()\n\t\t\t}\n\t\tdefault:\n\t\t\treturn badmode()\n\t\t}\n\t\t*mode = BuildmodeShared\n\t}\n\treturn nil\n}\n\nfunc (mode *BuildMode) String() string {\n\tswitch *mode {\n\tcase BuildmodeUnset:\n\t\treturn \"\" // avoid showing a default in usage message\n\tcase BuildmodeExe:\n\t\treturn \"exe\"\n\tcase BuildmodePIE:\n\t\treturn \"pie\"\n\tcase BuildmodeCArchive:\n\t\treturn \"c-archive\"\n\tcase BuildmodeCShared:\n\t\treturn \"c-shared\"\n\tcase BuildmodeShared:\n\t\treturn \"shared\"\n\t}\n\treturn fmt.Sprintf(\"BuildMode(%d)\", uint8(*mode))\n}\n\n/*\n * Unix doesn't like it when we write to a running (or, sometimes,\n * recently run) binary, so remove the output file before writing it.\n * On Windows 7, remove() can force a subsequent create() to fail.\n * S_ISREG() does not exist on Plan 9.\n */\nfunc mayberemoveoutfile() {\n\tif fi, err := os.Lstat(outfile); err == nil && !fi.Mode().IsRegular() {\n\t\treturn\n\t}\n\tos.Remove(outfile)\n}\n\nfunc libinit() {\n\tFuncalign = Thearch.Funcalign\n\tmywhatsys() // get goroot, goarch, goos\n\n\t// add goroot to the end of the libdir list.\n\tsuffix := \"\"\n\n\tsuffixsep := \"\"\n\tif flag_installsuffix != \"\" {\n\t\tsuffixsep = \"_\"\n\t\tsuffix = flag_installsuffix\n\t} else if flag_race != 0 {\n\t\tsuffixsep = \"_\"\n\t\tsuffix = \"race\"\n\t} else if flag_msan != 0 {\n\t\tsuffixsep = \"_\"\n\t\tsuffix = \"msan\"\n\t}\n\n\tLflag(filepath.Join(goroot, \"pkg\", fmt.Sprintf(\"%s_%s%s%s\", goos, goarch, suffixsep, suffix)))\n\n\tmayberemoveoutfile()\n\tf, err := os.OpenFile(outfile, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0775)\n\tif err != nil {\n\t\tExitf(\"cannot create %s: %v\", outfile, err)\n\t}\n\n\tcoutbuf.w = bufio.NewWriter(f)\n\tcoutbuf.f = f\n\n\tif INITENTRY == \"\" {\n\t\tswitch Buildmode {\n\t\tcase BuildmodeCShared, BuildmodeCArchive:\n\t\t\tINITENTRY = fmt.Sprintf(\"_rt0_%s_%s_lib\", goarch, goos)\n\t\tcase BuildmodeExe, BuildmodePIE:\n\t\t\tINITENTRY = fmt.Sprintf(\"_rt0_%s_%s\", goarch, goos)\n\t\tcase BuildmodeShared:\n\t\t\t// No INITENTRY for -buildmode=shared\n\t\tdefault:\n\t\t\tDiag(\"unknown INITENTRY for buildmode %v\", Buildmode)\n\t\t}\n\t}\n\n\tif !DynlinkingGo() {\n\t\tLinklookup(Ctxt, INITENTRY, 0).Type = obj.SXREF\n\t}\n}\n\nfunc Exitf(format string, a ...interface{}) {\n\tfmt.Fprintf(os.Stderr, os.Args[0]+\": \"+format+\"\\n\", a...)\n\tif coutbuf.f != nil {\n\t\tcoutbuf.f.Close()\n\t\tmayberemoveoutfile()\n\t}\n\tExit(2)\n}\n\nfunc errorexit() {\n\tif coutbuf.f != nil {\n\t\tif nerrors != 0 {\n\t\t\tCflush()\n\t\t}\n\t\t// For rmtemp run at atexit time on Windows.\n\t\tif err := coutbuf.f.Close(); err != nil {\n\t\t\tExitf(\"close: %v\", err)\n\t\t}\n\t}\n\n\tif nerrors != 0 {\n\t\tif coutbuf.f != nil {\n\t\t\tmayberemoveoutfile()\n\t\t}\n\t\tExit(2)\n\t}\n\n\tExit(0)\n}\n\nfunc loadinternal(name string) {\n\tfound := 0\n\tfor i := 0; i < len(Ctxt.Libdir); i++ {\n\t\tif Linkshared {\n\t\t\tshlibname := filepath.Join(Ctxt.Libdir[i], name+\".shlibname\")\n\t\t\tif Debug['v'] != 0 {\n\t\t\t\tfmt.Fprintf(Bso, \"searching for %s.a in %s\\n\", name, shlibname)\n\t\t\t}\n\t\t\tif _, err := os.Stat(shlibname); err == nil {\n\t\t\t\taddlibpath(Ctxt, \"internal\", \"internal\", \"\", name, shlibname)\n\t\t\t\tfound = 1\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tpname := filepath.Join(Ctxt.Libdir[i], name+\".a\")\n\t\tif Debug['v'] != 0 {\n\t\t\tfmt.Fprintf(Bso, \"searching for %s.a in %s\\n\", name, pname)\n\t\t}\n\t\tif _, err := os.Stat(pname); err == nil {\n\t\t\taddlibpath(Ctxt, \"internal\", \"internal\", pname, name, \"\")\n\t\t\tfound = 1\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif found == 0 {\n\t\tfmt.Fprintf(Bso, \"warning: unable to find %s.a\\n\", name)\n\t}\n}\n\nfunc loadlib() {\n\tswitch Buildmode {\n\tcase BuildmodeCShared:\n\t\ts := Linklookup(Ctxt, \"runtime.islibrary\", 0)\n\t\ts.Attr |= AttrDuplicateOK\n\t\tAdduint8(Ctxt, s, 1)\n\tcase BuildmodeCArchive:\n\t\ts := Linklookup(Ctxt, \"runtime.isarchive\", 0)\n\t\ts.Attr |= AttrDuplicateOK\n\t\tAdduint8(Ctxt, s, 1)\n\t}\n\n\tloadinternal(\"runtime\")\n\tif SysArch.Family == sys.ARM {\n\t\tloadinternal(\"math\")\n\t}\n\tif flag_race != 0 {\n\t\tloadinternal(\"runtime/race\")\n\t}\n\tif flag_msan != 0 {\n\t\tloadinternal(\"runtime/msan\")\n\t}\n\n\tvar i int\n\tfor i = 0; i < len(Ctxt.Library); i++ {\n\t\tiscgo = iscgo || Ctxt.Library[i].Pkg == \"runtime/cgo\"\n\t\tif Ctxt.Library[i].Shlib == \"\" {\n\t\t\tif Debug['v'] > 1 {\n\t\t\t\tfmt.Fprintf(Bso, \"%5.2f autolib: %s (from %s)\\n\", obj.Cputime(), Ctxt.Library[i].File, Ctxt.Library[i].Objref)\n\t\t\t}\n\t\t\tobjfile(Ctxt.Library[i])\n\t\t}\n\t}\n\n\tfor i = 0; i < len(Ctxt.Library); i++ {\n\t\tif Ctxt.Library[i].Shlib != \"\" {\n\t\t\tif Debug['v'] > 1 {\n\t\t\t\tfmt.Fprintf(Bso, \"%5.2f autolib: %s (from %s)\\n\", obj.Cputime(), Ctxt.Library[i].Shlib, Ctxt.Library[i].Objref)\n\t\t\t}\n\t\t\tldshlibsyms(Ctxt.Library[i].Shlib)\n\t\t}\n\t}\n\n\tif Linkmode == LinkAuto {\n\t\tif iscgo && externalobj {\n\t\t\tLinkmode = LinkExternal\n\t\t} else {\n\t\t\tLinkmode = LinkInternal\n\t\t}\n\n\t\t// Force external linking for android.\n\t\tif goos == \"android\" {\n\t\t\tLinkmode = LinkExternal\n\t\t}\n\n\t\t// Force external linking for PIE executables, as\n\t\t// internal linking does not support TLS_IE.\n\t\tif Buildmode == BuildmodePIE {\n\t\t\tLinkmode = LinkExternal\n\t\t}\n\n\t\t// cgo on Darwin must use external linking\n\t\t// we can always use external linking, but then there will be circular\n\t\t// dependency problems when compiling natively (external linking requires\n\t\t// runtime/cgo, runtime/cgo requires cmd/cgo, but cmd/cgo needs to be\n\t\t// compiled using external linking.)\n\t\tif SysArch.InFamily(sys.ARM, sys.ARM64) && HEADTYPE == obj.Hdarwin && iscgo {\n\t\t\tLinkmode = LinkExternal\n\t\t}\n\n\t\t// Force external linking for msan.\n\t\tif flag_msan != 0 {\n\t\t\tLinkmode = LinkExternal\n\t\t}\n\t}\n\n\t// cmd/7l doesn't support cgo internal linking\n\t// This is https://golang.org/issue/10373.\n\t// mips64x doesn't support cgo internal linking either (golang.org/issue/14449)\n\tif iscgo && (goarch == \"arm64\" || goarch == \"mips64\" || goarch == \"mips64le\") {\n\t\tLinkmode = LinkExternal\n\t}\n\n\tif Linkmode == LinkExternal && !iscgo {\n\t\t// This indicates a user requested -linkmode=external.\n\t\t// The startup code uses an import of runtime/cgo to decide\n\t\t// whether to initialize the TLS.  So give it one. This could\n\t\t// be handled differently but it's an unusual case.\n\t\tloadinternal(\"runtime/cgo\")\n\n\t\tif i < len(Ctxt.Library) {\n\t\t\tif Ctxt.Library[i].Shlib != \"\" {\n\t\t\t\tldshlibsyms(Ctxt.Library[i].Shlib)\n\t\t\t} else {\n\t\t\t\tif DynlinkingGo() {\n\t\t\t\t\tExitf(\"cannot implicitly include runtime/cgo in a shared library\")\n\t\t\t\t}\n\t\t\t\tobjfile(Ctxt.Library[i])\n\t\t\t}\n\t\t}\n\t}\n\n\tif Linkmode == LinkInternal {\n\t\t// Drop all the cgo_import_static declarations.\n\t\t// Turns out we won't be needing them.\n\t\tfor _, s := range Ctxt.Allsym {\n\t\t\tif s.Type == obj.SHOSTOBJ {\n\t\t\t\t// If a symbol was marked both\n\t\t\t\t// cgo_import_static and cgo_import_dynamic,\n\t\t\t\t// then we want to make it cgo_import_dynamic\n\t\t\t\t// now.\n\t\t\t\tif s.Extname != \"\" && s.Dynimplib != \"\" && !s.Attr.CgoExport() {\n\t\t\t\t\ts.Type = obj.SDYNIMPORT\n\t\t\t\t} else {\n\t\t\t\t\ts.Type = 0\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\ttlsg := Linklookup(Ctxt, \"runtime.tlsg\", 0)\n\n\t// runtime.tlsg is used for external linking on platforms that do not define\n\t// a variable to hold g in assembly (currently only intel).\n\tif tlsg.Type == 0 {\n\t\ttlsg.Type = obj.STLSBSS\n\t\ttlsg.Size = int64(SysArch.PtrSize)\n\t} else if tlsg.Type != obj.SDYNIMPORT {\n\t\tDiag(\"internal error: runtime declared tlsg variable %d\", tlsg.Type)\n\t}\n\ttlsg.Attr |= AttrReachable\n\tCtxt.Tlsg = tlsg\n\n\tmoduledata := Linklookup(Ctxt, \"runtime.firstmoduledata\", 0)\n\tif moduledata.Type != 0 && moduledata.Type != obj.SDYNIMPORT {\n\t\t// If the module (toolchain-speak for \"executable or shared\n\t\t// library\") we are linking contains the runtime package, it\n\t\t// will define the runtime.firstmoduledata symbol and we\n\t\t// truncate it back to 0 bytes so we can define its entire\n\t\t// contents in symtab.go:symtab().\n\t\tmoduledata.Size = 0\n\n\t\t// In addition, on ARM, the runtime depends on the linker\n\t\t// recording the value of GOARM.\n\t\tif SysArch.Family == sys.ARM {\n\t\t\ts := Linklookup(Ctxt, \"runtime.goarm\", 0)\n\t\t\ts.Type = obj.SRODATA\n\t\t\ts.Size = 0\n\t\t\tAdduint8(Ctxt, s, uint8(Ctxt.Goarm))\n\t\t}\n\n\t\tif obj.Framepointer_enabled(obj.Getgoos(), obj.Getgoarch()) {\n\t\t\ts := Linklookup(Ctxt, \"runtime.framepointer_enabled\", 0)\n\t\t\ts.Type = obj.SRODATA\n\t\t\ts.Size = 0\n\t\t\tAdduint8(Ctxt, s, 1)\n\t\t}\n\t} else {\n\t\t// If OTOH the module does not contain the runtime package,\n\t\t// create a local symbol for the moduledata.\n\t\tmoduledata = Linklookup(Ctxt, \"local.moduledata\", 0)\n\t\tmoduledata.Attr |= AttrLocal\n\t}\n\t// In all cases way we mark the moduledata as noptrdata to hide it from\n\t// the GC.\n\tmoduledata.Type = obj.SNOPTRDATA\n\tmoduledata.Attr |= AttrReachable\n\tCtxt.Moduledata = moduledata\n\n\t// Now that we know the link mode, trim the dynexp list.\n\tx := AttrCgoExportDynamic\n\n\tif Linkmode == LinkExternal {\n\t\tx = AttrCgoExportStatic\n\t}\n\tw := 0\n\tfor i := 0; i < len(dynexp); i++ {\n\t\tif dynexp[i].Attr&x != 0 {\n\t\t\tdynexp[w] = dynexp[i]\n\t\t\tw++\n\t\t}\n\t}\n\tdynexp = dynexp[:w]\n\n\t// In internal link mode, read the host object files.\n\tif Linkmode == LinkInternal {\n\t\thostobjs()\n\n\t\t// If we have any undefined symbols in external\n\t\t// objects, try to read them from the libgcc file.\n\t\tany := false\n\t\tfor _, s := range Ctxt.Allsym {\n\t\t\tfor _, r := range s.R {\n\t\t\t\tif r.Sym != nil && r.Sym.Type&obj.SMASK == obj.SXREF && r.Sym.Name != \".got\" {\n\t\t\t\t\tany = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif any {\n\t\t\tif libgccfile == \"\" {\n\t\t\t\tif extld == \"\" {\n\t\t\t\t\textld = \"gcc\"\n\t\t\t\t}\n\t\t\t\targs := hostlinkArchArgs()\n\t\t\t\targs = append(args, \"--print-libgcc-file-name\")\n\t\t\t\tif Debug['v'] != 0 {\n\t\t\t\t\tfmt.Fprintf(Bso, \"%s %v\\n\", extld, args)\n\t\t\t\t}\n\t\t\t\tout, err := exec.Command(extld, args...).Output()\n\t\t\t\tif err != nil {\n\t\t\t\t\tif Debug['v'] != 0 {\n\t\t\t\t\t\tfmt.Fprintln(Bso, \"not using a libgcc file because compiler failed\")\n\t\t\t\t\t\tfmt.Fprintf(Bso, \"%v\\n%s\\n\", err, out)\n\t\t\t\t\t}\n\t\t\t\t\tlibgccfile = \"none\"\n\t\t\t\t} else {\n\t\t\t\t\tlibgccfile = strings.TrimSpace(string(out))\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif libgccfile != \"none\" {\n\t\t\t\thostArchive(libgccfile)\n\t\t\t}\n\t\t}\n\t} else {\n\t\thostlinksetup()\n\t}\n\n\t// We've loaded all the code now.\n\t// If there are no dynamic libraries needed, gcc disables dynamic linking.\n\t// Because of this, glibc's dynamic ELF loader occasionally (like in version 2.13)\n\t// assumes that a dynamic binary always refers to at least one dynamic library.\n\t// Rather than be a source of test cases for glibc, disable dynamic linking\n\t// the same way that gcc would.\n\t//\n\t// Exception: on OS X, programs such as Shark only work with dynamic\n\t// binaries, so leave it enabled on OS X (Mach-O) binaries.\n\t// Also leave it enabled on Solaris which doesn't support\n\t// statically linked binaries.\n\tswitch Buildmode {\n\tcase BuildmodeExe, BuildmodePIE:\n\t\tif havedynamic == 0 && HEADTYPE != obj.Hdarwin && HEADTYPE != obj.Hsolaris {\n\t\t\tDebug['d'] = 1\n\t\t}\n\t}\n\n\timportcycles()\n}\n\n/*\n * look for the next file in an archive.\n * adapted from libmach.\n */\nfunc nextar(bp *bio.Reader, off int64, a *ArHdr) int64 {\n\tif off&1 != 0 {\n\t\toff++\n\t}\n\tbp.Seek(off, 0)\n\tvar buf [SAR_HDR]byte\n\tif n, err := io.ReadFull(bp, buf[:]); err != nil {\n\t\tif n == 0 && err != io.EOF {\n\t\t\treturn -1\n\t\t}\n\t\treturn 0\n\t}\n\n\ta.name = artrim(buf[0:16])\n\ta.date = artrim(buf[16:28])\n\ta.uid = artrim(buf[28:34])\n\ta.gid = artrim(buf[34:40])\n\ta.mode = artrim(buf[40:48])\n\ta.size = artrim(buf[48:58])\n\ta.fmag = artrim(buf[58:60])\n\n\tarsize := atolwhex(a.size)\n\tif arsize&1 != 0 {\n\t\tarsize++\n\t}\n\treturn arsize + SAR_HDR\n}\n\nfunc objfile(lib *Library) {\n\tpkg := pathtoprefix(lib.Pkg)\n\n\tif Debug['v'] > 1 {\n\t\tfmt.Fprintf(Bso, \"%5.2f ldobj: %s (%s)\\n\", obj.Cputime(), lib.File, pkg)\n\t}\n\tBso.Flush()\n\tf, err := bio.Open(lib.File)\n\tif err != nil {\n\t\tExitf(\"cannot open file %s: %v\", lib.File, err)\n\t}\n\n\tfor i := 0; i < len(ARMAG); i++ {\n\t\tif c, err := f.ReadByte(); err == nil && c == ARMAG[i] {\n\t\t\tcontinue\n\t\t}\n\n\t\t/* load it as a regular file */\n\t\tl := f.Seek(0, 2)\n\n\t\tf.Seek(0, 0)\n\t\tldobj(f, pkg, l, lib.File, lib.File, FileObj)\n\t\tf.Close()\n\n\t\treturn\n\t}\n\n\t/* process __.PKGDEF */\n\toff := f.Offset()\n\n\tvar arhdr ArHdr\n\tl := nextar(f, off, &arhdr)\n\tvar pname string\n\tif l <= 0 {\n\t\tDiag(\"%s: short read on archive file symbol header\", lib.File)\n\t\tgoto out\n\t}\n\n\tif !strings.HasPrefix(arhdr.name, pkgname) {\n\t\tDiag(\"%s: cannot find package header\", lib.File)\n\t\tgoto out\n\t}\n\n\tif Buildmode == BuildmodeShared {\n\t\tbefore := f.Offset()\n\t\tpkgdefBytes := make([]byte, atolwhex(arhdr.size))\n\t\tif _, err := io.ReadFull(f, pkgdefBytes); err != nil {\n\t\t\tDiag(\"%s: short read on archive file symbol header: %v\", lib.File, err)\n\t\t}\n\t\thash := sha1.Sum(pkgdefBytes)\n\t\tlib.hash = hash[:]\n\t\tf.Seek(before, 0)\n\t}\n\n\toff += l\n\n\tldpkg(f, pkg, atolwhex(arhdr.size), lib.File, Pkgdef)\n\n\t/*\n\t * load all the object files from the archive now.\n\t * this gives us sequential file access and keeps us\n\t * from needing to come back later to pick up more\n\t * objects.  it breaks the usual C archive model, but\n\t * this is Go, not C.  the common case in Go is that\n\t * we need to load all the objects, and then we throw away\n\t * the individual symbols that are unused.\n\t *\n\t * loading every object will also make it possible to\n\t * load foreign objects not referenced by __.PKGDEF.\n\t */\n\tfor {\n\t\tl = nextar(f, off, &arhdr)\n\t\tif l == 0 {\n\t\t\tbreak\n\t\t}\n\t\tif l < 0 {\n\t\t\tExitf(\"%s: malformed archive\", lib.File)\n\t\t}\n\n\t\toff += l\n\n\t\tpname = fmt.Sprintf(\"%s(%s)\", lib.File, arhdr.name)\n\t\tl = atolwhex(arhdr.size)\n\t\tldobj(f, pkg, l, pname, lib.File, ArchiveObj)\n\t}\n\nout:\n\tf.Close()\n}\n\ntype Hostobj struct {\n\tld     func(*bio.Reader, string, int64, string)\n\tpkg    string\n\tpn     string\n\tfile   string\n\toff    int64\n\tlength int64\n}\n\nvar hostobj []Hostobj\n\n// These packages can use internal linking mode.\n// Others trigger external mode.\nvar internalpkg = []string{\n\t\"crypto/x509\",\n\t\"net\",\n\t\"os/user\",\n\t\"runtime/cgo\",\n\t\"runtime/race\",\n\t\"runtime/msan\",\n}\n\nfunc ldhostobj(ld func(*bio.Reader, string, int64, string), f *bio.Reader, pkg string, length int64, pn string, file string) *Hostobj {\n\tisinternal := false\n\tfor i := 0; i < len(internalpkg); i++ {\n\t\tif pkg == internalpkg[i] {\n\t\t\tisinternal = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// DragonFly declares errno with __thread, which results in a symbol\n\t// type of R_386_TLS_GD or R_X86_64_TLSGD. The Go linker does not\n\t// currently know how to handle TLS relocations, hence we have to\n\t// force external linking for any libraries that link in code that\n\t// uses errno. This can be removed if the Go linker ever supports\n\t// these relocation types.\n\tif HEADTYPE == obj.Hdragonfly {\n\t\tif pkg == \"net\" || pkg == \"os/user\" {\n\t\t\tisinternal = false\n\t\t}\n\t}\n\n\tif !isinternal {\n\t\texternalobj = true\n\t}\n\n\thostobj = append(hostobj, Hostobj{})\n\th := &hostobj[len(hostobj)-1]\n\th.ld = ld\n\th.pkg = pkg\n\th.pn = pn\n\th.file = file\n\th.off = f.Offset()\n\th.length = length\n\treturn h\n}\n\nfunc hostobjs() {\n\tvar h *Hostobj\n\n\tfor i := 0; i < len(hostobj); i++ {\n\t\th = &hostobj[i]\n\t\tf, err := bio.Open(h.file)\n\t\tif err != nil {\n\t\t\tExitf(\"cannot reopen %s: %v\", h.pn, err)\n\t\t}\n\n\t\tf.Seek(h.off, 0)\n\t\th.ld(f, h.pkg, h.length, h.pn)\n\t\tf.Close()\n\t}\n}\n\n// provided by lib9\n\nfunc rmtemp() {\n\tos.RemoveAll(tmpdir)\n}\n\nfunc hostlinksetup() {\n\tif Linkmode != LinkExternal {\n\t\treturn\n\t}\n\n\t// For external link, record that we need to tell the external linker -s,\n\t// and turn off -s internally: the external linker needs the symbol\n\t// information for its final link.\n\tdebug_s = Debug['s']\n\tDebug['s'] = 0\n\n\t// create temporary directory and arrange cleanup\n\tif tmpdir == \"\" {\n\t\tdir, err := ioutil.TempDir(\"\", \"go-link-\")\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\ttmpdir = dir\n\t\tAtExit(rmtemp)\n\t}\n\n\t// change our output to temporary object file\n\tcoutbuf.f.Close()\n\tmayberemoveoutfile()\n\n\tp := filepath.Join(tmpdir, \"go.o\")\n\tvar err error\n\tf, err := os.OpenFile(p, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0775)\n\tif err != nil {\n\t\tExitf(\"cannot create %s: %v\", p, err)\n\t}\n\n\tcoutbuf.w = bufio.NewWriter(f)\n\tcoutbuf.f = f\n}\n\n// hostobjCopy creates a copy of the object files in hostobj in a\n// temporary directory.\nfunc hostobjCopy() (paths []string) {\n\tvar wg sync.WaitGroup\n\tsema := make(chan struct{}, runtime.NumCPU()) // limit open file descriptors\n\tfor i, h := range hostobj {\n\t\th := h\n\t\tdst := filepath.Join(tmpdir, fmt.Sprintf(\"%06d.o\", i))\n\t\tpaths = append(paths, dst)\n\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tsema <- struct{}{}\n\t\t\tdefer func() {\n\t\t\t\t<-sema\n\t\t\t\twg.Done()\n\t\t\t}()\n\t\t\tf, err := os.Open(h.file)\n\t\t\tif err != nil {\n\t\t\t\tExitf(\"cannot reopen %s: %v\", h.pn, err)\n\t\t\t}\n\t\t\tif _, err := f.Seek(h.off, 0); err != nil {\n\t\t\t\tExitf(\"cannot seek %s: %v\", h.pn, err)\n\t\t\t}\n\n\t\t\tw, err := os.Create(dst)\n\t\t\tif err != nil {\n\t\t\t\tExitf(\"cannot create %s: %v\", dst, err)\n\t\t\t}\n\t\t\tif _, err := io.CopyN(w, f, h.length); err != nil {\n\t\t\t\tExitf(\"cannot write %s: %v\", dst, err)\n\t\t\t}\n\t\t\tif err := w.Close(); err != nil {\n\t\t\t\tExitf(\"cannot close %s: %v\", dst, err)\n\t\t\t}\n\t\t}()\n\t}\n\twg.Wait()\n\treturn paths\n}\n\n// archive builds a .a archive from the hostobj object files.\nfunc archive() {\n\tif Buildmode != BuildmodeCArchive {\n\t\treturn\n\t}\n\n\tif extar == \"\" {\n\t\textar = \"ar\"\n\t}\n\n\tmayberemoveoutfile()\n\n\t// Force the buffer to flush here so that external\n\t// tools will see a complete file.\n\tCflush()\n\tif err := coutbuf.f.Close(); err != nil {\n\t\tExitf(\"close: %v\", err)\n\t}\n\tcoutbuf.f = nil\n\n\targv := []string{extar, \"-q\", \"-c\", \"-s\", outfile}\n\targv = append(argv, filepath.Join(tmpdir, \"go.o\"))\n\targv = append(argv, hostobjCopy()...)\n\n\tif Debug['v'] != 0 {\n\t\tfmt.Fprintf(Bso, \"archive: %s\\n\", strings.Join(argv, \" \"))\n\t\tBso.Flush()\n\t}\n\n\tif out, err := exec.Command(argv[0], argv[1:]...).CombinedOutput(); err != nil {\n\t\tExitf(\"running %s failed: %v\\n%s\", argv[0], err, out)\n\t}\n}\n\nfunc hostlink() {\n\tif Linkmode != LinkExternal || nerrors > 0 {\n\t\treturn\n\t}\n\tif Buildmode == BuildmodeCArchive {\n\t\treturn\n\t}\n\n\tif extld == \"\" {\n\t\textld = \"gcc\"\n\t}\n\n\tvar argv []string\n\targv = append(argv, extld)\n\targv = append(argv, hostlinkArchArgs()...)\n\n\tif Debug['s'] == 0 && debug_s == 0 {\n\t\targv = append(argv, \"-gdwarf-2\")\n\t} else {\n\t\targv = append(argv, \"-s\")\n\t}\n\n\tif HEADTYPE == obj.Hdarwin {\n\t\targv = append(argv, \"-Wl,-no_pie,-headerpad,1144\")\n\t}\n\tif HEADTYPE == obj.Hopenbsd {\n\t\targv = append(argv, \"-Wl,-nopie\")\n\t}\n\tif HEADTYPE == obj.Hwindows {\n\t\tif headstring == \"windowsgui\" {\n\t\t\targv = append(argv, \"-mwindows\")\n\t\t} else {\n\t\t\targv = append(argv, \"-mconsole\")\n\t\t}\n\t}\n\n\tswitch Buildmode {\n\tcase BuildmodeExe:\n\t\tif HEADTYPE == obj.Hdarwin {\n\t\t\targv = append(argv, \"-Wl,-pagezero_size,4000000\")\n\t\t}\n\tcase BuildmodePIE:\n\t\tif UseRelro() {\n\t\t\targv = append(argv, \"-Wl,-z,relro\")\n\t\t}\n\t\targv = append(argv, \"-pie\")\n\tcase BuildmodeCShared:\n\t\tif HEADTYPE == obj.Hdarwin {\n\t\t\targv = append(argv, \"-dynamiclib\", \"-Wl,-read_only_relocs,suppress\")\n\t\t} else {\n\t\t\t// ELF.\n\t\t\targv = append(argv, \"-Wl,-Bsymbolic\")\n\t\t\tif UseRelro() {\n\t\t\t\targv = append(argv, \"-Wl,-z,relro\")\n\t\t\t}\n\t\t\t// Pass -z nodelete to mark the shared library as\n\t\t\t// non-closeable: a dlclose will do nothing.\n\t\t\targv = append(argv, \"-shared\", \"-Wl,-z,nodelete\")\n\t\t}\n\tcase BuildmodeShared:\n\t\tif UseRelro() {\n\t\t\targv = append(argv, \"-Wl,-z,relro\")\n\t\t}\n\t\targv = append(argv, \"-shared\")\n\t}\n\n\tif Iself && DynlinkingGo() {\n\t\t// We force all symbol resolution to be done at program startup\n\t\t// because lazy PLT resolution can use large amounts of stack at\n\t\t// times we cannot allow it to do so.\n\t\targv = append(argv, \"-Wl,-znow\")\n\n\t\t// Do not let the host linker generate COPY relocations. These\n\t\t// can move symbols out of sections that rely on stable offsets\n\t\t// from the beginning of the section (like STYPE).\n\t\targv = append(argv, \"-Wl,-znocopyreloc\")\n\n\t\tif SysArch.InFamily(sys.ARM, sys.ARM64) {\n\t\t\t// On ARM, the GNU linker will generate COPY relocations\n\t\t\t// even with -znocopyreloc set.\n\t\t\t// https://sourceware.org/bugzilla/show_bug.cgi?id=19962\n\t\t\t//\n\t\t\t// On ARM64, the GNU linker will fail instead of\n\t\t\t// generating COPY relocations.\n\t\t\t//\n\t\t\t// In both cases, switch to gold.\n\t\t\targv = append(argv, \"-fuse-ld=gold\")\n\n\t\t\t// If gold is not installed, gcc will silently switch\n\t\t\t// back to ld.bfd. So we parse the version information\n\t\t\t// and provide a useful error if gold is missing.\n\t\t\tcmd := exec.Command(extld, \"-fuse-ld=gold\", \"-Wl,--version\")\n\t\t\tif out, err := cmd.CombinedOutput(); err == nil {\n\t\t\t\tif !bytes.Contains(out, []byte(\"GNU gold\")) {\n\t\t\t\t\tlog.Fatalf(\"ARM external linker must be gold (issue #15696), but is not: %s\", out)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif Iself && len(buildinfo) > 0 {\n\t\targv = append(argv, fmt.Sprintf(\"-Wl,--build-id=0x%x\", buildinfo))\n\t}\n\n\t// On Windows, given -o foo, GCC will append \".exe\" to produce\n\t// \"foo.exe\".  We have decided that we want to honor the -o\n\t// option. To make this work, we append a '.' so that GCC\n\t// will decide that the file already has an extension. We\n\t// only want to do this when producing a Windows output file\n\t// on a Windows host.\n\toutopt := outfile\n\tif goos == \"windows\" && runtime.GOOS == \"windows\" && filepath.Ext(outopt) == \"\" {\n\t\toutopt += \".\"\n\t}\n\targv = append(argv, \"-o\")\n\targv = append(argv, outopt)\n\n\tif rpath.val != \"\" {\n\t\targv = append(argv, fmt.Sprintf(\"-Wl,-rpath,%s\", rpath.val))\n\t}\n\n\t// Force global symbols to be exported for dlopen, etc.\n\tif Iself {\n\t\targv = append(argv, \"-rdynamic\")\n\t}\n\n\tif strings.Contains(argv[0], \"clang\") {\n\t\targv = append(argv, \"-Qunused-arguments\")\n\t}\n\n\targv = append(argv, filepath.Join(tmpdir, \"go.o\"))\n\targv = append(argv, hostobjCopy()...)\n\n\tif Linkshared {\n\t\tseenDirs := make(map[string]bool)\n\t\tseenLibs := make(map[string]bool)\n\t\taddshlib := func(path string) {\n\t\t\tdir, base := filepath.Split(path)\n\t\t\tif !seenDirs[dir] {\n\t\t\t\targv = append(argv, \"-L\"+dir)\n\t\t\t\tif !rpath.set {\n\t\t\t\t\targv = append(argv, \"-Wl,-rpath=\"+dir)\n\t\t\t\t}\n\t\t\t\tseenDirs[dir] = true\n\t\t\t}\n\t\t\tbase = strings.TrimSuffix(base, \".so\")\n\t\t\tbase = strings.TrimPrefix(base, \"lib\")\n\t\t\tif !seenLibs[base] {\n\t\t\t\targv = append(argv, \"-l\"+base)\n\t\t\t\tseenLibs[base] = true\n\t\t\t}\n\t\t}\n\t\tfor _, shlib := range Ctxt.Shlibs {\n\t\t\taddshlib(shlib.Path)\n\t\t\tfor _, dep := range shlib.Deps {\n\t\t\t\tif dep == \"\" {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tlibpath := findshlib(dep)\n\t\t\t\tif libpath != \"\" {\n\t\t\t\t\taddshlib(libpath)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tsanitizers := flag_race != 0\n\n\tfor _, flag := range ldflag {\n\t\tif strings.HasPrefix(flag, \"-fsanitize=\") {\n\t\t\tsanitizers = true\n\t\t}\n\t}\n\n\targv = append(argv, ldflag...)\n\n\tif sanitizers {\n\t\t// On a system where the toolchain creates position independent\n\t\t// executables by default, tsan/msan/asan/etc initialization can\n\t\t// fail. So we pass -no-pie here, but support for that flag is quite\n\t\t// new and we test for its support first.\n\t\tsrc := filepath.Join(tmpdir, \"trivial.c\")\n\t\tif err := ioutil.WriteFile(src, []byte{}, 0666); err != nil {\n\t\t\tCtxt.Diag(\"WriteFile trivial.c failed: %v\", err)\n\t\t}\n\t\tcmd := exec.Command(argv[0], \"-c\", \"-no-pie\", \"trivial.c\")\n\t\tcmd.Dir = tmpdir\n\t\tcmd.Env = append([]string{\"LC_ALL=C\"}, os.Environ()...)\n\t\tout, err := cmd.CombinedOutput()\n\t\tsupported := err == nil && !bytes.Contains(out, []byte(\"unrecognized\"))\n\t\tif supported {\n\t\t\targv = append(argv, \"-no-pie\")\n\t\t}\n\t}\n\n\tfor _, p := range strings.Fields(extldflags) {\n\t\targv = append(argv, p)\n\n\t\t// clang, unlike GCC, passes -rdynamic to the linker\n\t\t// even when linking with -static, causing a linker\n\t\t// error when using GNU ld. So take out -rdynamic if\n\t\t// we added it. We do it in this order, rather than\n\t\t// only adding -rdynamic later, so that -extldflags\n\t\t// can override -rdynamic without using -static.\n\t\tif Iself && p == \"-static\" {\n\t\t\tfor i := range argv {\n\t\t\t\tif argv[i] == \"-rdynamic\" {\n\t\t\t\t\targv[i] = \"-static\"\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif HEADTYPE == obj.Hwindows {\n\t\targv = append(argv, peimporteddlls()...)\n\t}\n\n\tif Debug['v'] != 0 {\n\t\tfmt.Fprintf(Bso, \"host link:\")\n\t\tfor _, v := range argv {\n\t\t\tfmt.Fprintf(Bso, \" %q\", v)\n\t\t}\n\t\tfmt.Fprintf(Bso, \"\\n\")\n\t\tBso.Flush()\n\t}\n\n\tif out, err := exec.Command(argv[0], argv[1:]...).CombinedOutput(); err != nil {\n\t\tExitf(\"running %s failed: %v\\n%s\", argv[0], err, out)\n\t} else if Debug['v'] != 0 && len(out) > 0 {\n\t\tfmt.Fprintf(Bso, \"%s\", out)\n\t\tBso.Flush()\n\t}\n\n\tif Debug['s'] == 0 && debug_s == 0 && HEADTYPE == obj.Hdarwin {\n\t\t// Skip combining dwarf on arm.\n\t\tif !SysArch.InFamily(sys.ARM, sys.ARM64) {\n\t\t\tdsym := filepath.Join(tmpdir, \"go.dwarf\")\n\t\t\tif out, err := exec.Command(\"dsymutil\", \"-f\", outfile, \"-o\", dsym).CombinedOutput(); err != nil {\n\t\t\t\tCtxt.Cursym = nil\n\t\t\t\tExitf(\"%s: running dsymutil failed: %v\\n%s\", os.Args[0], err, out)\n\t\t\t}\n\t\t\t// Skip combining if `dsymutil` didn't generate a file. See #11994.\n\t\t\tif _, err := os.Stat(dsym); os.IsNotExist(err) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\t// For os.Rename to work reliably, must be in same directory as outfile.\n\t\t\tcombinedOutput := outfile + \"~\"\n\t\t\tif err := machoCombineDwarf(outfile, dsym, combinedOutput); err != nil {\n\t\t\t\tCtxt.Cursym = nil\n\t\t\t\tExitf(\"%s: combining dwarf failed: %v\", os.Args[0], err)\n\t\t\t}\n\t\t\tos.Remove(outfile)\n\t\t\tif err := os.Rename(combinedOutput, outfile); err != nil {\n\t\t\t\tCtxt.Cursym = nil\n\t\t\t\tExitf(\"%s: %v\", os.Args[0], err)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// hostlinkArchArgs returns arguments to pass to the external linker\n// based on the architecture.\nfunc hostlinkArchArgs() []string {\n\tswitch SysArch.Family {\n\tcase sys.I386:\n\t\treturn []string{\"-m32\"}\n\tcase sys.AMD64, sys.PPC64, sys.S390X:\n\t\treturn []string{\"-m64\"}\n\tcase sys.ARM:\n\t\treturn []string{\"-marm\"}\n\tcase sys.ARM64:\n\t\t// nothing needed\n\tcase sys.MIPS64:\n\t\treturn []string{\"-mabi=64\"}\n\t}\n\treturn nil\n}\n\n// ldobj loads an input object. If it is a host object (an object\n// compiled by a non-Go compiler) it returns the Hostobj pointer. If\n// it is a Go object, it returns nil.\nfunc ldobj(f *bio.Reader, pkg string, length int64, pn string, file string, whence int) *Hostobj {\n\teof := f.Offset() + length\n\n\tstart := f.Offset()\n\tc1 := bgetc(f)\n\tc2 := bgetc(f)\n\tc3 := bgetc(f)\n\tc4 := bgetc(f)\n\tf.Seek(start, 0)\n\n\tmagic := uint32(c1)<<24 | uint32(c2)<<16 | uint32(c3)<<8 | uint32(c4)\n\tif magic == 0x7f454c46 { // \\x7F E L F\n\t\treturn ldhostobj(ldelf, f, pkg, length, pn, file)\n\t}\n\n\tif magic&^1 == 0xfeedface || magic&^0x01000000 == 0xcefaedfe {\n\t\treturn ldhostobj(ldmacho, f, pkg, length, pn, file)\n\t}\n\n\tif c1 == 0x4c && c2 == 0x01 || c1 == 0x64 && c2 == 0x86 {\n\t\treturn ldhostobj(ldpe, f, pkg, length, pn, file)\n\t}\n\n\t/* check the header */\n\tline, err := f.ReadString('\\n')\n\tif err != nil {\n\t\tDiag(\"truncated object file: %s: %v\", pn, err)\n\t\treturn nil\n\t}\n\n\tif !strings.HasPrefix(line, \"go object \") {\n\t\tif strings.HasSuffix(pn, \".go\") {\n\t\t\tExitf(\"%s: uncompiled .go source file\", pn)\n\t\t\treturn nil\n\t\t}\n\n\t\tif line == SysArch.Name {\n\t\t\t// old header format: just $GOOS\n\t\t\tDiag(\"%s: stale object file\", pn)\n\t\t\treturn nil\n\t\t}\n\n\t\tDiag(\"%s: not an object file\", pn)\n\t\treturn nil\n\t}\n\n\t// First, check that the basic goos, goarch, and version match.\n\tt := fmt.Sprintf(\"%s %s %s \", goos, obj.Getgoarch(), obj.Getgoversion())\n\n\tline = strings.TrimRight(line, \"\\n\")\n\tif !strings.HasPrefix(line[10:]+\" \", t) && Debug['f'] == 0 {\n\t\tDiag(\"%s: object is [%s] expected [%s]\", pn, line[10:], t)\n\t\treturn nil\n\t}\n\n\t// Second, check that longer lines match each other exactly,\n\t// so that the Go compiler and write additional information\n\t// that must be the same from run to run.\n\tif len(line) >= len(t)+10 {\n\t\tif theline == \"\" {\n\t\t\ttheline = line[10:]\n\t\t} else if theline != line[10:] {\n\t\t\tDiag(\"%s: object is [%s] expected [%s]\", pn, line[10:], theline)\n\t\t\treturn nil\n\t\t}\n\t}\n\n\t/* skip over exports and other info -- ends with \\n!\\n */\n\timport0 := f.Offset()\n\n\tc1 = '\\n' // the last line ended in \\n\n\tc2 = bgetc(f)\n\tc3 = bgetc(f)\n\tfor c1 != '\\n' || c2 != '!' || c3 != '\\n' {\n\t\tc1 = c2\n\t\tc2 = c3\n\t\tc3 = bgetc(f)\n\t\tif c3 == -1 {\n\t\t\tDiag(\"truncated object file: %s\", pn)\n\t\t\treturn nil\n\t\t}\n\t}\n\n\timport1 := f.Offset()\n\n\tf.Seek(import0, 0)\n\tldpkg(f, pkg, import1-import0-2, pn, whence) // -2 for !\\n\n\tf.Seek(import1, 0)\n\n\tLoadObjFile(Ctxt, f, pkg, eof-f.Offset(), pn)\n\treturn nil\n}\n\nfunc readelfsymboldata(f *elf.File, sym *elf.Symbol) []byte {\n\tdata := make([]byte, sym.Size)\n\tsect := f.Sections[sym.Section]\n\tif sect.Type != elf.SHT_PROGBITS && sect.Type != elf.SHT_NOTE {\n\t\tDiag(\"reading %s from non-data section\", sym.Name)\n\t}\n\tn, err := sect.ReadAt(data, int64(sym.Value-sect.Addr))\n\tif uint64(n) != sym.Size {\n\t\tDiag(\"reading contents of %s: %v\", sym.Name, err)\n\t}\n\treturn data\n}\n\nfunc readwithpad(r io.Reader, sz int32) ([]byte, error) {\n\tdata := make([]byte, Rnd(int64(sz), 4))\n\t_, err := io.ReadFull(r, data)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdata = data[:sz]\n\treturn data, nil\n}\n\nfunc readnote(f *elf.File, name []byte, typ int32) ([]byte, error) {\n\tfor _, sect := range f.Sections {\n\t\tif sect.Type != elf.SHT_NOTE {\n\t\t\tcontinue\n\t\t}\n\t\tr := sect.Open()\n\t\tfor {\n\t\t\tvar namesize, descsize, noteType int32\n\t\t\terr := binary.Read(r, f.ByteOrder, &namesize)\n\t\t\tif err != nil {\n\t\t\t\tif err == io.EOF {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\treturn nil, fmt.Errorf(\"read namesize failed: %v\", err)\n\t\t\t}\n\t\t\terr = binary.Read(r, f.ByteOrder, &descsize)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"read descsize failed: %v\", err)\n\t\t\t}\n\t\t\terr = binary.Read(r, f.ByteOrder, &noteType)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"read type failed: %v\", err)\n\t\t\t}\n\t\t\tnoteName, err := readwithpad(r, namesize)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"read name failed: %v\", err)\n\t\t\t}\n\t\t\tdesc, err := readwithpad(r, descsize)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"read desc failed: %v\", err)\n\t\t\t}\n\t\t\tif string(name) == string(noteName) && typ == noteType {\n\t\t\t\treturn desc, nil\n\t\t\t}\n\t\t}\n\t}\n\treturn nil, nil\n}\n\nfunc findshlib(shlib string) string {\n\tfor _, libdir := range Ctxt.Libdir {\n\t\tlibpath := filepath.Join(libdir, shlib)\n\t\tif _, err := os.Stat(libpath); err == nil {\n\t\t\treturn libpath\n\t\t}\n\t}\n\tDiag(\"cannot find shared library: %s\", shlib)\n\treturn \"\"\n}\n\nfunc ldshlibsyms(shlib string) {\n\tlibpath := findshlib(shlib)\n\tif libpath == \"\" {\n\t\treturn\n\t}\n\tfor _, processedlib := range Ctxt.Shlibs {\n\t\tif processedlib.Path == libpath {\n\t\t\treturn\n\t\t}\n\t}\n\tif Ctxt.Debugvlog > 1 && Ctxt.Bso != nil {\n\t\tfmt.Fprintf(Ctxt.Bso, \"%5.2f ldshlibsyms: found library with name %s at %s\\n\", obj.Cputime(), shlib, libpath)\n\t\tCtxt.Bso.Flush()\n\t}\n\n\tf, err := elf.Open(libpath)\n\tif err != nil {\n\t\tDiag(\"cannot open shared library: %s\", libpath)\n\t\treturn\n\t}\n\n\thash, err := readnote(f, ELF_NOTE_GO_NAME, ELF_NOTE_GOABIHASH_TAG)\n\tif err != nil {\n\t\tDiag(\"cannot read ABI hash from shared library %s: %v\", libpath, err)\n\t\treturn\n\t}\n\n\tdepsbytes, err := readnote(f, ELF_NOTE_GO_NAME, ELF_NOTE_GODEPS_TAG)\n\tif err != nil {\n\t\tDiag(\"cannot read dep list from shared library %s: %v\", libpath, err)\n\t\treturn\n\t}\n\tdeps := strings.Split(string(depsbytes), \"\\n\")\n\n\tsyms, err := f.DynamicSymbols()\n\tif err != nil {\n\t\tDiag(\"cannot read symbols from shared library: %s\", libpath)\n\t\treturn\n\t}\n\tgcdata_locations := make(map[uint64]*LSym)\n\tfor _, elfsym := range syms {\n\t\tif elf.ST_TYPE(elfsym.Info) == elf.STT_NOTYPE || elf.ST_TYPE(elfsym.Info) == elf.STT_SECTION {\n\t\t\tcontinue\n\t\t}\n\t\tlsym := Linklookup(Ctxt, elfsym.Name, 0)\n\t\t// Because loadlib above loads all .a files before loading any shared\n\t\t// libraries, any non-dynimport symbols we find that duplicate symbols\n\t\t// already loaded should be ignored (the symbols from the .a files\n\t\t// \"win\").\n\t\tif lsym.Type != 0 && lsym.Type != obj.SDYNIMPORT {\n\t\t\tcontinue\n\t\t}\n\t\tlsym.Type = obj.SDYNIMPORT\n\t\tlsym.ElfType = elf.ST_TYPE(elfsym.Info)\n\t\tlsym.Size = int64(elfsym.Size)\n\t\tif elfsym.Section != elf.SHN_UNDEF {\n\t\t\t// Set .File for the library that actually defines the symbol.\n\t\t\tlsym.File = libpath\n\t\t\t// The decodetype_* functions in decodetype.go need access to\n\t\t\t// the type data.\n\t\t\tif strings.HasPrefix(lsym.Name, \"type.\") && !strings.HasPrefix(lsym.Name, \"type..\") {\n\t\t\t\tlsym.P = readelfsymboldata(f, &elfsym)\n\t\t\t\tgcdata_locations[elfsym.Value+2*uint64(SysArch.PtrSize)+8+1*uint64(SysArch.PtrSize)] = lsym\n\t\t\t}\n\t\t}\n\t}\n\tgcdata_addresses := make(map[*LSym]uint64)\n\tif SysArch.Family == sys.ARM64 {\n\t\tfor _, sect := range f.Sections {\n\t\t\tif sect.Type == elf.SHT_RELA {\n\t\t\t\tvar rela elf.Rela64\n\t\t\t\trdr := sect.Open()\n\t\t\t\tfor {\n\t\t\t\t\terr := binary.Read(rdr, f.ByteOrder, &rela)\n\t\t\t\t\tif err == io.EOF {\n\t\t\t\t\t\tbreak\n\t\t\t\t\t} else if err != nil {\n\t\t\t\t\t\tDiag(\"reading relocation failed %v\", err)\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tt := elf.R_AARCH64(rela.Info & 0xffff)\n\t\t\t\t\tif t != elf.R_AARCH64_RELATIVE {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tif lsym, ok := gcdata_locations[rela.Off]; ok {\n\t\t\t\t\t\tgcdata_addresses[lsym] = uint64(rela.Addend)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// We might have overwritten some functions above (this tends to happen for the\n\t// autogenerated type equality/hashing functions) and we don't want to generated\n\t// pcln table entries for these any more so remove them from Textp.\n\ttextp := make([]*LSym, 0, len(Ctxt.Textp))\n\tfor _, s := range Ctxt.Textp {\n\t\tif s.Type != obj.SDYNIMPORT {\n\t\t\ttextp = append(textp, s)\n\t\t}\n\t}\n\tCtxt.Textp = textp\n\n\tCtxt.Shlibs = append(Ctxt.Shlibs, Shlib{Path: libpath, Hash: hash, Deps: deps, File: f, gcdata_addresses: gcdata_addresses})\n}\n\nfunc mywhatsys() {\n\tgoroot = obj.Getgoroot()\n\tgoos = obj.Getgoos()\n\tgoarch = obj.Getgoarch()\n}\n\n// Copied from ../gc/subr.c:/^pathtoprefix; must stay in sync.\n/*\n * Convert raw string to the prefix that will be used in the symbol table.\n * Invalid bytes turn into %xx.\t Right now the only bytes that need\n * escaping are %, ., and \", but we escape all control characters too.\n *\n * If you edit this, edit ../gc/subr.c:/^pathtoprefix too.\n * If you edit this, edit ../../debug/goobj/read.go:/importPathToPrefix too.\n */\nfunc pathtoprefix(s string) string {\n\tslash := strings.LastIndex(s, \"/\")\n\tfor i := 0; i < len(s); i++ {\n\t\tc := s[i]\n\t\tif c <= ' ' || i >= slash && c == '.' || c == '%' || c == '\"' || c >= 0x7F {\n\t\t\tvar buf bytes.Buffer\n\t\t\tfor i := 0; i < len(s); i++ {\n\t\t\t\tc := s[i]\n\t\t\t\tif c <= ' ' || i >= slash && c == '.' || c == '%' || c == '\"' || c >= 0x7F {\n\t\t\t\t\tfmt.Fprintf(&buf, \"%%%02x\", c)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tbuf.WriteByte(c)\n\t\t\t}\n\t\t\treturn buf.String()\n\t\t}\n\t}\n\treturn s\n}\n\nfunc addsection(seg *Segment, name string, rwx int) *Section {\n\tvar l **Section\n\n\tfor l = &seg.Sect; *l != nil; l = &(*l).Next {\n\t}\n\tsect := new(Section)\n\tsect.Rwx = uint8(rwx)\n\tsect.Name = name\n\tsect.Seg = seg\n\tsect.Align = int32(SysArch.PtrSize) // everything is at least pointer-aligned\n\t*l = sect\n\treturn sect\n}\n\nfunc Le16(b []byte) uint16 {\n\treturn uint16(b[0]) | uint16(b[1])<<8\n}\n\nfunc Le32(b []byte) uint32 {\n\treturn uint32(b[0]) | uint32(b[1])<<8 | uint32(b[2])<<16 | uint32(b[3])<<24\n}\n\nfunc Le64(b []byte) uint64 {\n\treturn uint64(Le32(b)) | uint64(Le32(b[4:]))<<32\n}\n\nfunc Be16(b []byte) uint16 {\n\treturn uint16(b[0])<<8 | uint16(b[1])\n}\n\nfunc Be32(b []byte) uint32 {\n\treturn uint32(b[0])<<24 | uint32(b[1])<<16 | uint32(b[2])<<8 | uint32(b[3])\n}\n\ntype Chain struct {\n\tsym   *LSym\n\tup    *Chain\n\tlimit int // limit on entry to sym\n}\n\nvar morestack *LSym\n\n// TODO: Record enough information in new object files to\n// allow stack checks here.\n\nfunc haslinkregister() bool {\n\treturn Ctxt.FixedFrameSize() != 0\n}\n\nfunc callsize() int {\n\tif haslinkregister() {\n\t\treturn 0\n\t}\n\treturn SysArch.RegSize\n}\n\nfunc dostkcheck() {\n\tvar ch Chain\n\n\tmorestack = Linklookup(Ctxt, \"runtime.morestack\", 0)\n\n\t// Every splitting function ensures that there are at least StackLimit\n\t// bytes available below SP when the splitting prologue finishes.\n\t// If the splitting function calls F, then F begins execution with\n\t// at least StackLimit - callsize() bytes available.\n\t// Check that every function behaves correctly with this amount\n\t// of stack, following direct calls in order to piece together chains\n\t// of non-splitting functions.\n\tch.up = nil\n\n\tch.limit = obj.StackLimit - callsize()\n\n\t// Check every function, but do the nosplit functions in a first pass,\n\t// to make the printed failure chains as short as possible.\n\tfor _, s := range Ctxt.Textp {\n\t\t// runtime.racesymbolizethunk is called from gcc-compiled C\n\t\t// code running on the operating system thread stack.\n\t\t// It uses more than the usual amount of stack but that's okay.\n\t\tif s.Name == \"runtime.racesymbolizethunk\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tif s.Attr.NoSplit() {\n\t\t\tCtxt.Cursym = s\n\t\t\tch.sym = s\n\t\t\tstkcheck(&ch, 0)\n\t\t}\n\t}\n\n\tfor _, s := range Ctxt.Textp {\n\t\tif !s.Attr.NoSplit() {\n\t\t\tCtxt.Cursym = s\n\t\t\tch.sym = s\n\t\t\tstkcheck(&ch, 0)\n\t\t}\n\t}\n}\n\nfunc stkcheck(up *Chain, depth int) int {\n\tlimit := up.limit\n\ts := up.sym\n\n\t// Don't duplicate work: only need to consider each\n\t// function at top of safe zone once.\n\ttop := limit == obj.StackLimit-callsize()\n\tif top {\n\t\tif s.Attr.StackCheck() {\n\t\t\treturn 0\n\t\t}\n\t\ts.Attr |= AttrStackCheck\n\t}\n\n\tif depth > 100 {\n\t\tDiag(\"nosplit stack check too deep\")\n\t\tstkbroke(up, 0)\n\t\treturn -1\n\t}\n\n\tif s.Attr.External() || s.FuncInfo == nil {\n\t\t// external function.\n\t\t// should never be called directly.\n\t\t// only diagnose the direct caller.\n\t\t// TODO(mwhudson): actually think about this.\n\t\tif depth == 1 && s.Type != obj.SXREF && !DynlinkingGo() &&\n\t\t\tBuildmode != BuildmodePIE && Buildmode != BuildmodeCShared {\n\t\t\tDiag(\"call to external function %s\", s.Name)\n\t\t}\n\t\treturn -1\n\t}\n\n\tif limit < 0 {\n\t\tstkbroke(up, limit)\n\t\treturn -1\n\t}\n\n\t// morestack looks like it calls functions,\n\t// but it switches the stack pointer first.\n\tif s == morestack {\n\t\treturn 0\n\t}\n\n\tvar ch Chain\n\tch.up = up\n\n\tif !s.Attr.NoSplit() {\n\t\t// Ensure we have enough stack to call morestack.\n\t\tch.limit = limit - callsize()\n\t\tch.sym = morestack\n\t\tif stkcheck(&ch, depth+1) < 0 {\n\t\t\treturn -1\n\t\t}\n\t\tif !top {\n\t\t\treturn 0\n\t\t}\n\t\t// Raise limit to allow frame.\n\t\tlocals := int32(0)\n\t\tif s.FuncInfo != nil {\n\t\t\tlocals = s.FuncInfo.Locals\n\t\t}\n\t\tlimit = int(obj.StackLimit+locals) + int(Ctxt.FixedFrameSize())\n\t}\n\n\t// Walk through sp adjustments in function, consuming relocs.\n\tri := 0\n\n\tendr := len(s.R)\n\tvar ch1 Chain\n\tvar pcsp Pciter\n\tvar r *Reloc\n\tfor pciterinit(Ctxt, &pcsp, &s.FuncInfo.Pcsp); pcsp.done == 0; pciternext(&pcsp) {\n\t\t// pcsp.value is in effect for [pcsp.pc, pcsp.nextpc).\n\n\t\t// Check stack size in effect for this span.\n\t\tif int32(limit)-pcsp.value < 0 {\n\t\t\tstkbroke(up, int(int32(limit)-pcsp.value))\n\t\t\treturn -1\n\t\t}\n\n\t\t// Process calls in this span.\n\t\tfor ; ri < endr && uint32(s.R[ri].Off) < pcsp.nextpc; ri++ {\n\t\t\tr = &s.R[ri]\n\t\t\tswitch r.Type {\n\t\t\t// Direct call.\n\t\t\tcase obj.R_CALL, obj.R_CALLARM, obj.R_CALLARM64, obj.R_CALLPOWER, obj.R_CALLMIPS:\n\t\t\t\tch.limit = int(int32(limit) - pcsp.value - int32(callsize()))\n\t\t\t\tch.sym = r.Sym\n\t\t\t\tif stkcheck(&ch, depth+1) < 0 {\n\t\t\t\t\treturn -1\n\t\t\t\t}\n\n\t\t\t// Indirect call. Assume it is a call to a splitting function,\n\t\t\t// so we have to make sure it can call morestack.\n\t\t\t// Arrange the data structures to report both calls, so that\n\t\t\t// if there is an error, stkprint shows all the steps involved.\n\t\t\tcase obj.R_CALLIND:\n\t\t\t\tch.limit = int(int32(limit) - pcsp.value - int32(callsize()))\n\n\t\t\t\tch.sym = nil\n\t\t\t\tch1.limit = ch.limit - callsize() // for morestack in called prologue\n\t\t\t\tch1.up = &ch\n\t\t\t\tch1.sym = morestack\n\t\t\t\tif stkcheck(&ch1, depth+2) < 0 {\n\t\t\t\t\treturn -1\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0\n}\n\nfunc stkbroke(ch *Chain, limit int) {\n\tDiag(\"nosplit stack overflow\")\n\tstkprint(ch, limit)\n}\n\nfunc stkprint(ch *Chain, limit int) {\n\tvar name string\n\n\tif ch.sym != nil {\n\t\tname = ch.sym.Name\n\t\tif ch.sym.Attr.NoSplit() {\n\t\t\tname += \" (nosplit)\"\n\t\t}\n\t} else {\n\t\tname = \"function pointer\"\n\t}\n\n\tif ch.up == nil {\n\t\t// top of chain.  ch->sym != nil.\n\t\tif ch.sym.Attr.NoSplit() {\n\t\t\tfmt.Printf(\"\\t%d\\tassumed on entry to %s\\n\", ch.limit, name)\n\t\t} else {\n\t\t\tfmt.Printf(\"\\t%d\\tguaranteed after split check in %s\\n\", ch.limit, name)\n\t\t}\n\t} else {\n\t\tstkprint(ch.up, ch.limit+callsize())\n\t\tif !haslinkregister() {\n\t\t\tfmt.Printf(\"\\t%d\\ton entry to %s\\n\", ch.limit, name)\n\t\t}\n\t}\n\n\tif ch.limit != limit {\n\t\tfmt.Printf(\"\\t%d\\tafter %s uses %d\\n\", limit, name, ch.limit-limit)\n\t}\n}\n\nfunc Cflush() {\n\tif err := coutbuf.w.Flush(); err != nil {\n\t\tExitf(\"flushing %s: %v\", coutbuf.f.Name(), err)\n\t}\n}\n\nfunc Cpos() int64 {\n\treturn coutbuf.off\n}\n\nfunc Cseek(p int64) {\n\tif p == coutbuf.off {\n\t\treturn\n\t}\n\tCflush()\n\tif _, err := coutbuf.f.Seek(p, 0); err != nil {\n\t\tExitf(\"seeking in output [0, 1]: %v\", err)\n\t}\n\tcoutbuf.off = p\n}\n\nfunc Cwritestring(s string) {\n\tcoutbuf.WriteString(s)\n}\n\nfunc Cwrite(p []byte) {\n\tcoutbuf.Write(p)\n}\n\nfunc Cput(c uint8) {\n\tcoutbuf.w.WriteByte(c)\n\tcoutbuf.off++\n}\n\nfunc usage() {\n\tfmt.Fprintf(os.Stderr, \"usage: link [options] main.o\\n\")\n\tobj.Flagprint(2)\n\tExit(2)\n}\n\nfunc setheadtype(s string) {\n\th := headtype(s)\n\tif h < 0 {\n\t\tExitf(\"unknown header type -H %s\", s)\n\t}\n\n\theadstring = s\n\tHEADTYPE = int32(headtype(s))\n}\n\nfunc setinterp(s string) {\n\tDebug['I'] = 1 // denote cmdline interpreter override\n\tinterpreter = s\n}\n\nfunc doversion() {\n\tExitf(\"version %s\", obj.Getgoversion())\n}\n\nfunc genasmsym(put func(*LSym, string, int, int64, int64, int, *LSym)) {\n\t// These symbols won't show up in the first loop below because we\n\t// skip STEXT symbols. Normal STEXT symbols are emitted by walking textp.\n\ts := Linklookup(Ctxt, \"runtime.text\", 0)\n\tif s.Type == obj.STEXT {\n\t\tput(s, s.Name, 'T', s.Value, s.Size, int(s.Version), nil)\n\t}\n\ts = Linklookup(Ctxt, \"runtime.etext\", 0)\n\tif s.Type == obj.STEXT {\n\t\tput(s, s.Name, 'T', s.Value, s.Size, int(s.Version), nil)\n\t}\n\n\tfor _, s := range Ctxt.Allsym {\n\t\tif s.Attr.Hidden() {\n\t\t\tcontinue\n\t\t}\n\t\tif (s.Name == \"\" || s.Name[0] == '.') && s.Version == 0 && s.Name != \".rathole\" && s.Name != \".TOC.\" {\n\t\t\tcontinue\n\t\t}\n\t\tswitch s.Type & obj.SMASK {\n\t\tcase obj.SCONST,\n\t\t\tobj.SRODATA,\n\t\t\tobj.SSYMTAB,\n\t\t\tobj.SPCLNTAB,\n\t\t\tobj.SINITARR,\n\t\t\tobj.SDATA,\n\t\t\tobj.SNOPTRDATA,\n\t\t\tobj.SELFROSECT,\n\t\t\tobj.SMACHOGOT,\n\t\t\tobj.STYPE,\n\t\t\tobj.SSTRING,\n\t\t\tobj.SGOSTRING,\n\t\t\tobj.SGOSTRINGHDR,\n\t\t\tobj.SGOFUNC,\n\t\t\tobj.SGCBITS,\n\t\t\tobj.STYPERELRO,\n\t\t\tobj.SSTRINGRELRO,\n\t\t\tobj.SGOSTRINGRELRO,\n\t\t\tobj.SGOSTRINGHDRRELRO,\n\t\t\tobj.SGOFUNCRELRO,\n\t\t\tobj.SGCBITSRELRO,\n\t\t\tobj.SRODATARELRO,\n\t\t\tobj.STYPELINK,\n\t\t\tobj.SITABLINK,\n\t\t\tobj.SWINDOWS:\n\t\t\tif !s.Attr.Reachable() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tput(s, s.Name, 'D', Symaddr(s), s.Size, int(s.Version), s.Gotype)\n\n\t\tcase obj.SBSS, obj.SNOPTRBSS:\n\t\t\tif !s.Attr.Reachable() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif len(s.P) > 0 {\n\t\t\t\tDiag(\"%s should not be bss (size=%d type=%d special=%v)\", s.Name, len(s.P), s.Type, s.Attr.Special())\n\t\t\t}\n\t\t\tput(s, s.Name, 'B', Symaddr(s), s.Size, int(s.Version), s.Gotype)\n\n\t\tcase obj.SFILE:\n\t\t\tput(nil, s.Name, 'f', s.Value, 0, int(s.Version), nil)\n\n\t\tcase obj.SHOSTOBJ:\n\t\t\tif HEADTYPE == obj.Hwindows || Iself {\n\t\t\t\tput(s, s.Name, 'U', s.Value, 0, int(s.Version), nil)\n\t\t\t}\n\n\t\tcase obj.SDYNIMPORT:\n\t\t\tif !s.Attr.Reachable() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tput(s, s.Extname, 'U', 0, 0, int(s.Version), nil)\n\n\t\tcase obj.STLSBSS:\n\t\t\tif Linkmode == LinkExternal && HEADTYPE != obj.Hopenbsd {\n\t\t\t\tput(s, s.Name, 't', Symaddr(s), s.Size, int(s.Version), s.Gotype)\n\t\t\t}\n\t\t}\n\t}\n\n\tvar off int32\n\tfor _, s := range Ctxt.Textp {\n\t\tput(s, s.Name, 'T', s.Value, s.Size, int(s.Version), s.Gotype)\n\n\t\tlocals := int32(0)\n\t\tif s.FuncInfo != nil {\n\t\t\tlocals = s.FuncInfo.Locals\n\t\t}\n\t\t// NOTE(ality): acid can't produce a stack trace without .frame symbols\n\t\tput(nil, \".frame\", 'm', int64(locals)+int64(SysArch.PtrSize), 0, 0, nil)\n\n\t\tif s.FuncInfo == nil {\n\t\t\tcontinue\n\t\t}\n\t\tfor _, a := range s.FuncInfo.Autom {\n\t\t\t// Emit a or p according to actual offset, even if label is wrong.\n\t\t\t// This avoids negative offsets, which cannot be encoded.\n\t\t\tif a.Name != obj.A_AUTO && a.Name != obj.A_PARAM {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// compute offset relative to FP\n\t\t\tif a.Name == obj.A_PARAM {\n\t\t\t\toff = a.Aoffset\n\t\t\t} else {\n\t\t\t\toff = a.Aoffset - int32(SysArch.PtrSize)\n\t\t\t}\n\n\t\t\t// FP\n\t\t\tif off >= 0 {\n\t\t\t\tput(nil, a.Asym.Name, 'p', int64(off), 0, 0, a.Gotype)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// SP\n\t\t\tif off <= int32(-SysArch.PtrSize) {\n\t\t\t\tput(nil, a.Asym.Name, 'a', -(int64(off) + int64(SysArch.PtrSize)), 0, 0, a.Gotype)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t}\n\n\t// Otherwise, off is addressing the saved program counter.\n\t// Something underhanded is going on. Say nothing.\n\tif Debug['v'] != 0 || Debug['n'] != 0 {\n\t\tfmt.Fprintf(Bso, \"%5.2f symsize = %d\\n\", obj.Cputime(), uint32(Symsize))\n\t}\n\tBso.Flush()\n}\n\nfunc Symaddr(s *LSym) int64 {\n\tif !s.Attr.Reachable() {\n\t\tDiag(\"unreachable symbol in symaddr - %s\", s.Name)\n\t}\n\treturn s.Value\n}\n\nfunc xdefine(p string, t int, v int64) {\n\ts := Linklookup(Ctxt, p, 0)\n\ts.Type = int16(t)\n\ts.Value = v\n\ts.Attr |= AttrReachable\n\ts.Attr |= AttrSpecial\n\ts.Attr |= AttrLocal\n}\n\nfunc datoff(addr int64) int64 {\n\tif uint64(addr) >= Segdata.Vaddr {\n\t\treturn int64(uint64(addr) - Segdata.Vaddr + Segdata.Fileoff)\n\t}\n\tif uint64(addr) >= Segtext.Vaddr {\n\t\treturn int64(uint64(addr) - Segtext.Vaddr + Segtext.Fileoff)\n\t}\n\tDiag(\"datoff %#x\", addr)\n\treturn 0\n}\n\nfunc Entryvalue() int64 {\n\ta := INITENTRY\n\tif a[0] >= '0' && a[0] <= '9' {\n\t\treturn atolwhex(a)\n\t}\n\ts := Linklookup(Ctxt, a, 0)\n\tif s.Type == 0 {\n\t\treturn INITTEXT\n\t}\n\tif s.Type != obj.STEXT {\n\t\tDiag(\"entry not text: %s\", s.Name)\n\t}\n\treturn s.Value\n}\n\nfunc undefsym(s *LSym) {\n\tvar r *Reloc\n\n\tCtxt.Cursym = s\n\tfor i := 0; i < len(s.R); i++ {\n\t\tr = &s.R[i]\n\t\tif r.Sym == nil { // happens for some external ARM relocs\n\t\t\tcontinue\n\t\t}\n\t\tif r.Sym.Type == obj.Sxxx || r.Sym.Type == obj.SXREF {\n\t\t\tDiag(\"undefined: %s\", r.Sym.Name)\n\t\t}\n\t\tif !r.Sym.Attr.Reachable() {\n\t\t\tDiag(\"use of unreachable symbol: %s\", r.Sym.Name)\n\t\t}\n\t}\n}\n\nfunc undef() {\n\tfor _, s := range Ctxt.Textp {\n\t\tundefsym(s)\n\t}\n\tfor _, s := range datap {\n\t\tundefsym(s)\n\t}\n\tif nerrors > 0 {\n\t\terrorexit()\n\t}\n}\n\nfunc callgraph() {\n\tif Debug['c'] == 0 {\n\t\treturn\n\t}\n\n\tvar i int\n\tvar r *Reloc\n\tfor _, s := range Ctxt.Textp {\n\t\tfor i = 0; i < len(s.R); i++ {\n\t\t\tr = &s.R[i]\n\t\t\tif r.Sym == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif (r.Type == obj.R_CALL || r.Type == obj.R_CALLARM || r.Type == obj.R_CALLPOWER || r.Type == obj.R_CALLMIPS) && r.Sym.Type == obj.STEXT {\n\t\t\t\tfmt.Fprintf(Bso, \"%s calls %s\\n\", s.Name, r.Sym.Name)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc Diag(format string, args ...interface{}) {\n\ttn := \"\"\n\tsep := \"\"\n\tif Ctxt.Cursym != nil {\n\t\ttn = Ctxt.Cursym.Name\n\t\tsep = \": \"\n\t}\n\tfmt.Printf(\"%s%s%s\\n\", tn, sep, fmt.Sprintf(format, args...))\n\tnerrors++\n\tif Debug['h'] != 0 {\n\t\tpanic(\"error\")\n\t}\n\tif nerrors > 20 {\n\t\tExitf(\"too many errors\")\n\t}\n}\n\nfunc Rnd(v int64, r int64) int64 {\n\tif r <= 0 {\n\t\treturn v\n\t}\n\tv += r - 1\n\tc := v % r\n\tif c < 0 {\n\t\tc += r\n\t}\n\tv -= c\n\treturn v\n}\n\nfunc bgetc(r *bio.Reader) int {\n\tc, err := r.ReadByte()\n\tif err != nil {\n\t\tif err != io.EOF {\n\t\t\tlog.Fatalf(\"reading input: %v\", err)\n\t\t}\n\t\treturn -1\n\t}\n\treturn int(c)\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/misc/cgo/testcshared/main5.c": "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// Test that a signal handler works in non-Go code when using\n// os/signal.Notify.\n// This is a lot like misc/cgo/testcarchive/main3.c.\n\n#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sched.h>\n#include <dlfcn.h>\n\nstatic void die(const char* msg) {\n\tperror(msg);\n\texit(EXIT_FAILURE);\n}\n\nstatic volatile sig_atomic_t sigioSeen;\n\nstatic void ioHandler(int signo, siginfo_t* info, void* ctxt) {\n\tsigioSeen = 1;\n}\n\nint main(int argc, char** argv) {\n\tint verbose;\n\tstruct sigaction sa;\n\tvoid* handle;\n\tvoid (*fn1)(void);\n\tint (*sawSIGIO)(void);\n\tint i;\n\n\tverbose = argc > 2;\n\tsetvbuf(stdout, NULL, _IONBF, 0);\n\n\tif (verbose) {\n\t\tprintf(\"calling sigaction\\n\");\n\t}\n\n\tmemset(&sa, 0, sizeof sa);\n\tsa.sa_sigaction = ioHandler;\n\tif (sigemptyset(&sa.sa_mask) < 0) {\n\t\tdie(\"sigemptyset\");\n\t}\n\tsa.sa_flags = SA_SIGINFO;\n\tif (sigaction(SIGIO, &sa, NULL) < 0) {\n\t\tdie(\"sigaction\");\n\t}\n\n\tif (verbose) {\n\t\tprintf(\"calling dlopen\\n\");\n\t}\n\n\thandle = dlopen(argv[1], RTLD_NOW | RTLD_GLOBAL);\n\tif (handle == NULL) {\n\t\tfprintf(stderr, \"%s\\n\", dlerror());\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t// At this point there should not be a Go signal handler\n\t// installed for SIGIO.\n\n\tif (verbose) {\n\t\tprintf(\"raising SIGIO\\n\");\n\t}\n\n\tif (raise(SIGIO) < 0) {\n\t\tdie(\"raise\");\n\t}\n\n\tif (verbose) {\n\t\tprintf(\"waiting for sigioSeen\\n\");\n\t}\n\n\t// Wait until the signal has been delivered.\n\ti = 0;\n\twhile (!sigioSeen) {\n\t\tif (sched_yield() < 0) {\n\t\t\tperror(\"sched_yield\");\n\t\t}\n\t\ti++;\n\t\tif (i > 100000) {\n\t\t\tfprintf(stderr, \"looping too long waiting for signal\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\n\tsigioSeen = 0;\n\n\t// Tell the Go code to catch SIGIO.\n\n\tif (verbose) {\n\t\tprintf(\"calling dlsym\\n\");\n\t}\n\n\tfn1 = (void(*)(void))dlsym(handle, \"CatchSIGIO\");\n\tif (fn1 == NULL) {\n\t\tfprintf(stderr, \"%s\\n\", dlerror());\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (verbose) {\n\t\tprintf(\"calling CatchSIGIO\\n\");\n\t}\n\n\tfn1();\n\n\tif (verbose) {\n\t\tprintf(\"raising SIGIO\\n\");\n\t}\n\n\tif (raise(SIGIO) < 0) {\n\t\tdie(\"raise\");\n\t}\n\n\tif (verbose) {\n\t\tprintf(\"calling dlsym\\n\");\n\t}\n\n\t// Check that the Go code saw SIGIO.\n\tsawSIGIO = (int (*)(void))dlsym(handle, \"SawSIGIO\");\n\tif (sawSIGIO == NULL) {\n\t\tfprintf(stderr, \"%s\\n\", dlerror());\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (verbose) {\n\t\tprintf(\"calling SawSIGIO\\n\");\n\t}\n\n\tif (!sawSIGIO()) {\n\t\tfprintf(stderr, \"Go handler did not see SIGIO\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (sigioSeen != 0) {\n\t\tfprintf(stderr, \"C handler saw SIGIO when only Go handler should have\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t// Tell the Go code to stop catching SIGIO.\n\n\tif (verbose) {\n\t\tprintf(\"calling dlsym\\n\");\n\t}\n\n\tfn1 = (void(*)(void))dlsym(handle, \"ResetSIGIO\");\n\tif (fn1 == NULL) {\n\t\tfprintf(stderr, \"%s\\n\", dlerror());\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (verbose) {\n\t\tprintf(\"calling ResetSIGIO\\n\");\n\t}\n\n\tfn1();\n\n\tif (verbose) {\n\t\tprintf(\"raising SIGIO\\n\");\n\t}\n\n\tif (raise(SIGIO) < 0) {\n\t\tdie(\"raise\");\n\t}\n\n\tif (verbose) {\n\t\tprintf(\"calling SawSIGIO\\n\");\n\t}\n\n\tif (sawSIGIO()) {\n\t\tfprintf(stderr, \"Go handler saw SIGIO after Reset\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (verbose) {\n\t\tprintf(\"waiting for sigioSeen\\n\");\n\t}\n\n\t// Wait until the signal has been delivered.\n\ti = 0;\n\twhile (!sigioSeen) {\n\t\tif (sched_yield() < 0) {\n\t\t\tperror(\"sched_yield\");\n\t\t}\n\t\ti++;\n\t\tif (i > 100000) {\n\t\t\tfprintf(stderr, \"looping too long waiting for signal\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\n\tprintf(\"PASS\\n\");\n\treturn 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/misc/cgo/testcshared/main1.c": "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n#include <stdint.h>\n#include <stdio.h>\n#include <dlfcn.h>\n\nint check_int8(void* handle, const char* fname, int8_t want) {\n  int8_t (*fn)();\n  fn = (int8_t (*)())dlsym(handle, fname);\n  if (!fn) {\n    fprintf(stderr, \"ERROR: missing %s: %s\\n\", fname, dlerror());\n    return 1;\n  }\n  signed char ret = fn();\n  if (ret != want) {\n    fprintf(stderr, \"ERROR: %s=%d, want %d\\n\", fname, ret, want);\n    return 1;\n  }\n  return 0;\n}\n\nint check_int32(void* handle, const char* fname, int32_t want) {\n  int32_t (*fn)();\n  fn = (int32_t (*)())dlsym(handle, fname);\n  if (!fn) {\n    fprintf(stderr, \"ERROR: missing %s: %s\\n\", fname, dlerror());\n    return 1;\n  }\n  int32_t ret = fn();\n  if (ret != want) {\n    fprintf(stderr, \"ERROR: %s=%d, want %d\\n\", fname, ret, want);\n    return 1;\n  }\n  return 0;\n}\n\n// Tests libgo.so to export the following functions.\n//   int8_t DidInitRun() // returns true\n//   int8_t DidMainRun() // returns true\n//   int32_t FromPkg() // returns 1024\nint main(int argc, char** argv) {\n  void* handle = dlopen(argv[1], RTLD_LAZY | RTLD_GLOBAL);\n  if (!handle) {\n    fprintf(stderr, \"ERROR: failed to open the shared library: %s\\n\",\n\t\t    dlerror());\n    return 2;\n  }\n\n  int ret = 0;\n  ret = check_int8(handle, \"DidInitRun\", 1);\n  if (ret != 0) {\n    return ret;\n  }\n\n  ret = check_int8(handle, \"DidMainRun\", 0);\n  if (ret != 0) {\n    return ret;\n  }\n\n  ret = check_int32(handle, \"FromPkg\", 1024);\n  if (ret != 0) {\n   return ret;\n  }\n  // test.bash looks for \"PASS\" to ensure this program has reached the end. \n  printf(\"PASS\\n\");\n  return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/misc/cgo/testcshared/main3.c": "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n#include <stdint.h>\n#include <stdio.h>\n#include <dlfcn.h>\n\n// Tests \"main.main\" is exported on android/arm,\n// which golang.org/x/mobile/app depends on.\nint main(int argc, char** argv) {\n  void* handle = dlopen(argv[1], RTLD_LAZY | RTLD_GLOBAL);\n  if (!handle) {\n    fprintf(stderr, \"ERROR: failed to open the shared library: %s\\n\",\n            dlerror());\n    return 2;\n  }\n\n  uintptr_t main_fn = (uintptr_t)dlsym(handle, \"main.main\");\n  if (!main_fn) {\n    fprintf(stderr, \"ERROR: missing main.main: %s\\n\", dlerror());\n    return 2;\n  }\n\n  // TODO(hyangah): check that main.main can run.\n\n  printf(\"PASS\\n\");\n  return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/misc/cgo/testcshared/main4.c": "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// Test that a signal handler that uses up stack space does not crash\n// if the signal is delivered to a thread running a goroutine.\n// This is a lot like misc/cgo/testcarchive/main2.c.\n\n#include <setjmp.h>\n#include <signal.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <sched.h>\n#include <time.h>\n#include <dlfcn.h>\n\nstatic void die(const char* msg) {\n\tperror(msg);\n\texit(EXIT_FAILURE);\n}\n\nstatic volatile sig_atomic_t sigioSeen;\n\n// Use up some stack space.\nstatic void recur(int i, char *p) {\n\tchar a[1024];\n\n\t*p = '\\0';\n\tif (i > 0) {\n\t\trecur(i - 1, a);\n\t}\n}\n\n// Signal handler that uses up more stack space than a goroutine will have.\nstatic void ioHandler(int signo, siginfo_t* info, void* ctxt) {\n\tchar a[1024];\n\n\trecur(4, a);\n\tsigioSeen = 1;\n}\n\nstatic jmp_buf jmp;\nstatic char* nullPointer;\n\n// Signal handler for SIGSEGV on a C thread.\nstatic void segvHandler(int signo, siginfo_t* info, void* ctxt) {\n\tsigset_t mask;\n\tint i;\n\n\tif (sigemptyset(&mask) < 0) {\n\t\tdie(\"sigemptyset\");\n\t}\n\tif (sigaddset(&mask, SIGSEGV) < 0) {\n\t\tdie(\"sigaddset\");\n\t}\n\ti = sigprocmask(SIG_UNBLOCK, &mask, NULL);\n\tif (i != 0) {\n\t\tfprintf(stderr, \"sigprocmask: %s\\n\", strerror(i));\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t// Don't try this at home.\n\tlongjmp(jmp, signo);\n\n\t// We should never get here.\n\tabort();\n}\n\nint main(int argc, char** argv) {\n\tint verbose;\n\tstruct sigaction sa;\n\tvoid* handle;\n\tvoid (*fn)(void);\n\tsigset_t mask;\n\tint i;\n\n\tverbose = argc > 2;\n\tsetvbuf(stdout, NULL, _IONBF, 0);\n\n\t// Call setsid so that we can use kill(0, SIGIO) below.\n\t// Don't check the return value so that this works both from\n\t// a job control shell and from a shell script.\n\tsetsid();\n\n\tif (verbose) {\n\t\tprintf(\"calling sigaction\\n\");\n\t}\n\n\tmemset(&sa, 0, sizeof sa);\n\tsa.sa_sigaction = ioHandler;\n\tif (sigemptyset(&sa.sa_mask) < 0) {\n\t\tdie(\"sigemptyset\");\n\t}\n\tsa.sa_flags = SA_SIGINFO;\n\tif (sigaction(SIGIO, &sa, NULL) < 0) {\n\t\tdie(\"sigaction\");\n\t}\n\n\tsa.sa_sigaction = segvHandler;\n\tif (sigaction(SIGSEGV, &sa, NULL) < 0 || sigaction(SIGBUS, &sa, NULL) < 0) {\n\t\tdie(\"sigaction\");\n\t}\n\n\tif (verbose) {\n\t\tprintf(\"calling dlopen\\n\");\n\t}\n\n\thandle = dlopen(argv[1], RTLD_NOW | RTLD_GLOBAL);\n\tif (handle == NULL) {\n\t\tfprintf(stderr, \"%s\\n\", dlerror());\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (verbose) {\n\t\tprintf(\"calling dlsym\\n\");\n\t}\n\n\t// Start some goroutines.\n\tfn = (void(*)(void))dlsym(handle, \"RunGoroutines\");\n\tif (fn == NULL) {\n\t\tfprintf(stderr, \"%s\\n\", dlerror());\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (verbose) {\n\t\tprintf(\"calling RunGoroutines\\n\");\n\t}\n\n\tfn();\n\n\t// Block SIGIO in this thread to make it more likely that it\n\t// will be delivered to a goroutine.\n\n\tif (verbose) {\n\t\tprintf(\"calling pthread_sigmask\\n\");\n\t}\n\n\tif (sigemptyset(&mask) < 0) {\n\t\tdie(\"sigemptyset\");\n\t}\n\tif (sigaddset(&mask, SIGIO) < 0) {\n\t\tdie(\"sigaddset\");\n\t}\n\ti = pthread_sigmask(SIG_BLOCK, &mask, NULL);\n\tif (i != 0) {\n\t\tfprintf(stderr, \"pthread_sigmask: %s\\n\", strerror(i));\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (verbose) {\n\t\tprintf(\"calling kill\\n\");\n\t}\n\n\tif (kill(0, SIGIO) < 0) {\n\t\tdie(\"kill\");\n\t}\n\n\tif (verbose) {\n\t\tprintf(\"waiting for sigioSeen\\n\");\n\t}\n\n\t// Wait until the signal has been delivered.\n\ti = 0;\n\twhile (!sigioSeen) {\n\t\tif (sched_yield() < 0) {\n\t\t\tperror(\"sched_yield\");\n\t\t}\n\t\ti++;\n\t\tif (i > 100000) {\n\t\t\tfprintf(stderr, \"looping too long waiting for signal\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\n\tif (verbose) {\n\t\tprintf(\"calling setjmp\\n\");\n\t}\n\n\t// Test that a SIGSEGV on this thread is delivered to us.\n\tif (setjmp(jmp) == 0) {\n\t\tif (verbose) {\n\t\t\tprintf(\"triggering SIGSEGV\\n\");\n\t\t}\n\n\t\t*nullPointer = '\\0';\n\n\t\tfprintf(stderr, \"continued after address error\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (verbose) {\n\t\tprintf(\"calling dlsym\\n\");\n\t}\n\n\t// Make sure that a SIGSEGV in Go causes a run-time panic.\n\tfn = (void (*)(void))dlsym(handle, \"TestSEGV\");\n\tif (fn == NULL) {\n\t\tfprintf(stderr, \"%s\\n\", dlerror());\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (verbose) {\n\t\tprintf(\"calling TestSEGV\\n\");\n\t}\n\n\tfn();\n\n\tprintf(\"PASS\\n\");\n\treturn 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/misc/cgo/test/issue4029.go": "// Copyright 2012 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// +build !windows\n\npackage cgotest\n\n/*\n#include <dlfcn.h>\n#cgo linux LDFLAGS: -ldl\n\nextern void call4029(void *arg);\n*/\nimport \"C\"\n\nimport (\n\t\"testing\"\n)\n\nvar callbacks int\n\n//export IMPIsOpaque\nfunc IMPIsOpaque() {\n\tcallbacks++\n}\n\n//export IMPInitWithFrame\nfunc IMPInitWithFrame() {\n\tcallbacks++\n}\n\n//export IMPDrawRect\nfunc IMPDrawRect() {\n\tcallbacks++\n}\n\n//export IMPWindowResize\nfunc IMPWindowResize() {\n\tcallbacks++\n}\n\nfunc test4029(t *testing.T) {\n\tloadThySelf(t, \"IMPWindowResize\")\n\tloadThySelf(t, \"IMPDrawRect\")\n\tloadThySelf(t, \"IMPInitWithFrame\")\n\tloadThySelf(t, \"IMPIsOpaque\")\n\tif callbacks != 4 {\n\t\tt.Errorf(\"got %d callbacks, expected 4\", callbacks)\n\t}\n}\n\nfunc loadThySelf(t *testing.T, symbol string) {\n\tthis_process := C.dlopen(nil, C.RTLD_NOW)\n\tif this_process == nil {\n\t\tt.Error(\"dlopen:\", C.GoString(C.dlerror()))\n\t\treturn\n\t}\n\tdefer C.dlclose(this_process)\n\n\tsymbol_address := C.dlsym(this_process, C.CString(symbol))\n\tif symbol_address == nil {\n\t\tt.Error(\"dlsym:\", C.GoString(C.dlerror()))\n\t\treturn\n\t}\n\tt.Log(symbol, symbol_address)\n\tC.call4029(symbol_address)\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/favicon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/compress/bzip2/testdata/pass-sawtooth.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/compress/bzip2/testdata/Mark.Twain-Tom.Sawyer.txt.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/compress/bzip2/testdata/fail-issue5747.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/compress/bzip2/testdata/pass-random2.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/compress/bzip2/testdata/e.txt.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/compress/bzip2/testdata/random.data.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/compress/bzip2/testdata/pass-random2.bin",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/compress/bzip2/testdata/pass-random1.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/compress/bzip2/testdata/pass-random1.bin",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/compress/gzip/testdata/issue6550.gz",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/compress/flate/testdata/huffman-rand-limit.wb.expect-noinput",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/compress/flate/testdata/huffman-shifts.wb.expect-noinput",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/compress/flate/testdata/huffman-rand-max.golden",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/compress/flate/testdata/huffman-text-shift.wb.expect",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/compress/flate/testdata/huffman-null-max.golden",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/compress/flate/testdata/huffman-rand-max.in",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/compress/flate/testdata/huffman-rand-1k.golden",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/compress/flate/testdata/huffman-pi.golden",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/compress/flate/testdata/huffman-rand-limit.wb.expect",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/compress/flate/testdata/huffman-rand-1k.dyn.expect-noinput",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/compress/flate/testdata/huffman-zero.golden",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/compress/flate/testdata/huffman-null-max.wb.expect",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/compress/flate/testdata/null-long-match.wb.expect-noinput",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/compress/flate/testdata/huffman-shifts.golden",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/compress/flate/testdata/huffman-text.golden",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/compress/flate/testdata/huffman-zero.dyn.expect-noinput",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/compress/flate/testdata/huffman-rand-1k.wb.expect-noinput",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/compress/flate/testdata/huffman-pi.wb.expect-noinput",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/compress/flate/testdata/huffman-pi.dyn.expect-noinput",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/compress/flate/testdata/huffman-rand-1k.dyn.expect",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/compress/flate/testdata/huffman-text-shift.golden",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/compress/flate/testdata/huffman-null-max.dyn.expect-noinput",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/compress/flate/testdata/huffman-text.dyn.expect",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/compress/flate/testdata/huffman-shifts.dyn.expect-noinput",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/compress/flate/testdata/huffman-rand-1k.wb.expect",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/compress/flate/testdata/huffman-rand-limit.dyn.expect-noinput",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/compress/flate/testdata/huffman-null-max.wb.expect-noinput",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/compress/flate/testdata/huffman-text-shift.wb.expect-noinput",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/compress/flate/testdata/huffman-text-shift.dyn.expect",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/compress/flate/testdata/huffman-null-max.dyn.expect",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/compress/flate/testdata/huffman-shifts.wb.expect",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/compress/flate/testdata/huffman-zero.dyn.expect",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/compress/flate/testdata/null-long-match.dyn.expect-noinput",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/compress/flate/testdata/huffman-text.wb.expect",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/compress/flate/testdata/huffman-rand-limit.golden",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/compress/flate/testdata/huffman-text.wb.expect-noinput",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/compress/flate/testdata/huffman-text.dyn.expect-noinput",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/compress/flate/testdata/huffman-rand-1k.in",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/compress/flate/testdata/huffman-pi.dyn.expect",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/compress/flate/testdata/huffman-rand-limit.dyn.expect",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/compress/flate/testdata/huffman-shifts.dyn.expect",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/compress/flate/testdata/huffman-pi.wb.expect",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/compress/flate/testdata/huffman-text-shift.dyn.expect-noinput",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/compress/flate/testdata/huffman-rand-limit.in",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/regexp/testdata/re2-exhaustive.txt.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/encoding/json/testdata/code.json.gz",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/image/testdata/video-001.progressive.truncated.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/image/testdata/video-005.gray.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/image/testdata/video-001.cmyk.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/image/testdata/video-001.separate.dc.progression.progressive.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/image/testdata/video-001.221212.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/image/testdata/video-001.cmyk.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/image/testdata/video-005.gray.q50.2x2.progressive.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/image/testdata/video-001.q50.440.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/image/testdata/video-001.q50.411.progressive.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/image/testdata/video-001.q50.422.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/image/testdata/video-001.rgb.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/image/testdata/video-005.gray.q50.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/image/testdata/video-001.5bpp.gif",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/image/testdata/video-005.gray.q50.2x2.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/image/testdata/video-001.separate.dc.progression.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/image/testdata/video-005.gray.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/image/testdata/video-001.q50.410.progressive.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/image/testdata/video-001.gif",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/image/testdata/video-001.rgb.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/image/testdata/video-001.q50.410.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/image/testdata/video-001.q50.444.progressive.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/image/testdata/video-001.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/image/testdata/video-001.progressive.truncated.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/image/testdata/video-001.221212.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/image/testdata/video-005.gray.gif",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/image/testdata/video-001.q50.411.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/image/testdata/video-001.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/image/testdata/video-001.q50.440.progressive.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/image/testdata/video-001.q50.420.progressive.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/image/testdata/video-001.q50.444.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/image/testdata/video-001.q50.422.progressive.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/image/testdata/video-001.progressive.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/image/testdata/video-005.gray.q50.progressive.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/image/testdata/video-001.q50.420.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/image/testdata/video-001.interlaced.gif",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/image/png/testdata/benchPaletted.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/image/png/testdata/invalid-zlib.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/image/png/testdata/benchRGB-interlace.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/image/png/testdata/gray-gradient.interlaced.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/image/png/testdata/benchNRGBA-gradient.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/image/png/testdata/invalid-crc32.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/image/png/testdata/benchNRGBA-opaque.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/image/png/testdata/invalid-trunc.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/image/png/testdata/benchGray.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/image/png/testdata/gray-gradient.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/image/png/testdata/benchRGB.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/image/png/testdata/invalid-noend.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/image/png/testdata/pngsuite/basn4a16.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/image/png/testdata/pngsuite/basn0g04-31.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/image/png/testdata/pngsuite/basn2c08.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/image/png/testdata/pngsuite/basn4a08.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/image/png/testdata/pngsuite/basn0g08.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/image/png/testdata/pngsuite/basn3p02.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/image/png/testdata/pngsuite/basn3p08.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/image/png/testdata/pngsuite/basn0g02.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/image/png/testdata/pngsuite/basn0g04.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/image/png/testdata/pngsuite/basn0g16.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/image/png/testdata/pngsuite/basn0g02-29.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/image/png/testdata/pngsuite/basn3p08-trns.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/image/png/testdata/pngsuite/basn3p01.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/image/png/testdata/pngsuite/basn6a16.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/image/png/testdata/pngsuite/basn3p04-31i.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/image/png/testdata/pngsuite/basn0g01-30.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/image/png/testdata/pngsuite/basn3p04.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/image/png/testdata/pngsuite/basn2c16.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/image/png/testdata/pngsuite/basn6a08.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/image/png/testdata/pngsuite/basn0g01.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/runtime/race/race_darwin_amd64.syso",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/runtime/race/race_freebsd_amd64.syso",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/runtime/race/race_windows_amd64.syso",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/runtime/race/race_linux_amd64.syso",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/archive/zip/testdata/test-trailing-junk.zip",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/archive/zip/testdata/symlink.zip",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/archive/zip/testdata/crc32-not-streamed.zip",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/archive/zip/testdata/go-with-datadesc-sig.zip",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/archive/zip/testdata/readme.notzip",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/archive/zip/testdata/test.zip",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/archive/zip/testdata/zip64.zip",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/archive/zip/testdata/gophercolor16x16.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/archive/zip/testdata/winxp.zip",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/archive/zip/testdata/unix.zip",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/archive/zip/testdata/go-no-datadesc-sig.zip",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/archive/zip/testdata/dd.zip",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/archive/zip/testdata/zip64-2.zip",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/archive/zip/testdata/readme.zip",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/archive/tar/testdata/writer-big.tar",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/archive/tar/testdata/writer-big-long.tar",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/archive/tar/testdata/issue10968.tar",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/archive/tar/testdata/v7.tar",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/archive/tar/testdata/issue12435.tar",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/archive/tar/testdata/neg-size.tar",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/crypto/rsa/testdata/pss-vect.txt.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/crypto/ecdsa/testdata/SigVer.rsp.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/debug/elf/testdata/go-relocation-test-gcc492-arm.obj",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/debug/elf/testdata/go-relocation-test-gcc441-x86.obj",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/debug/elf/testdata/go-relocation-test-gcc493-mips64le.obj",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/debug/elf/testdata/hello-world-core.gz",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/debug/elf/testdata/go-relocation-test-gcc482-aarch64.obj",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/debug/elf/testdata/go-relocation-test-clang-arm.obj",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/debug/elf/testdata/zdebug-test-gcc484-x86-64.obj",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/debug/elf/testdata/gcc-amd64-openbsd-debug-with-rela.obj",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/debug/elf/testdata/go-relocation-test-gcc5-ppc.obj",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/debug/elf/testdata/go-relocation-test-gcc492-mips64.obj",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/debug/elf/testdata/go-relocation-test-gcc531-s390x.obj",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/debug/elf/testdata/compressed-32.obj",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/debug/elf/testdata/go-relocation-test-gcc482-ppc64le.obj",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/debug/elf/testdata/go-relocation-test-gcc441-x86-64.obj",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/debug/elf/testdata/go-relocation-test-gcc424-x86-64.obj",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/debug/elf/testdata/compressed-64.obj",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/debug/elf/testdata/go-relocation-test-clang-x86.obj",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/debug/dwarf/testdata/line-clang.elf",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/debug/dwarf/testdata/typedef.macho",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/debug/dwarf/testdata/ranges.elf",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/debug/dwarf/testdata/typedef.elf",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/debug/dwarf/testdata/typedef.elf4",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/debug/dwarf/testdata/line-gcc.elf",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/debug/dwarf/testdata/split.elf",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/src/debug/dwarf/testdata/cycle.elf",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/lib/time/zoneinfo.zip",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/misc/chrome/gophertool/gopher.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/doc/go-logo-blue.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/doc/go-logo-black.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/doc/go-logo-white.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/doc/share.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/doc/gopher/help.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/doc/gopher/bumper192x108.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/doc/gopher/appenginegophercolor.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/doc/gopher/gopherbw.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/doc/gopher/project.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/doc/gopher/ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/doc/gopher/bumper.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/doc/gopher/bumper640x360.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/doc/gopher/gophercolor.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/doc/gopher/gophercolor16x16.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/doc/gopher/pkg.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/doc/gopher/biplane.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/doc/gopher/fiveyears.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/doc/gopher/talks.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/doc/gopher/appenginegopher.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/doc/gopher/run.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/doc/gopher/bumper480x270.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/doc/gopher/doc.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/doc/gopher/appenginelogo.gif",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/doc/gopher/frontpage.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/doc/gopher/bumper320x180.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/doc/gopher/pencil/gopherswrench.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/doc/gopher/pencil/gophermega.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/doc/gopher/pencil/gopherhat.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/doc/gopher/pencil/gopherswim.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/doc/gopher/pencil/gopherhelmet.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/doc/gopher/pencil/gopherrunning.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.7.4-ynytb2lbnqgdhoweasteowwazdjindry/spack-src/doc/codewalk/popout.png"
    ],
    "total_files": 5524
}