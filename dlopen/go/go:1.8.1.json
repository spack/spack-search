{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/plugin/plugin_dlopen.go": "// Copyright 2016 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// +build linux,cgo darwin,cgo\n\npackage plugin\n\n/*\n#cgo linux LDFLAGS: -ldl\n#include <dlfcn.h>\n#include <limits.h>\n#include <stdlib.h>\n#include <stdint.h>\n\n#include <stdio.h>\n\nstatic uintptr_t pluginOpen(const char* path, char** err) {\n\tvoid* h = dlopen(path, RTLD_NOW|RTLD_GLOBAL);\n\tif (h == NULL) {\n\t\t*err = (char*)dlerror();\n\t}\n\treturn (uintptr_t)h;\n}\n\nstatic void* pluginLookup(uintptr_t h, const char* name, char** err) {\n\tvoid* r = dlsym((void*)h, name);\n\tif (r == NULL) {\n\t\t*err = (char*)dlerror();\n\t}\n\treturn r;\n}\n*/\nimport \"C\"\n\nimport (\n\t\"errors\"\n\t\"sync\"\n\t\"unsafe\"\n)\n\nfunc open(name string) (*Plugin, error) {\n\tcPath := (*C.char)(C.malloc(C.PATH_MAX + 1))\n\tdefer C.free(unsafe.Pointer(cPath))\n\n\tcRelName := C.CString(name)\n\tdefer C.free(unsafe.Pointer(cRelName))\n\tif C.realpath(cRelName, cPath) == nil {\n\t\treturn nil, errors.New(\"plugin.Open(\" + name + \"): realpath failed\")\n\t}\n\n\tfilepath := C.GoString(cPath)\n\n\tpluginsMu.Lock()\n\tif p := plugins[filepath]; p != nil {\n\t\tpluginsMu.Unlock()\n\t\t<-p.loaded\n\t\treturn p, nil\n\t}\n\tvar cErr *C.char\n\th := C.pluginOpen(cPath, &cErr)\n\tif h == 0 {\n\t\tpluginsMu.Unlock()\n\t\treturn nil, errors.New(\"plugin.Open: \" + C.GoString(cErr))\n\t}\n\t// TODO(crawshaw): look for plugin note, confirm it is a Go plugin\n\t// and it was built with the correct toolchain.\n\tif len(name) > 3 && name[len(name)-3:] == \".so\" {\n\t\tname = name[:len(name)-3]\n\t}\n\n\tpluginpath, syms, mismatchpkg := lastmoduleinit()\n\tif mismatchpkg != \"\" {\n\t\tpluginsMu.Unlock()\n\t\treturn nil, errors.New(\"plugin.Open: plugin was built with a different version of package \" + mismatchpkg)\n\t}\n\tif plugins == nil {\n\t\tplugins = make(map[string]*Plugin)\n\t}\n\t// This function can be called from the init function of a plugin.\n\t// Drop a placeholder in the map so subsequent opens can wait on it.\n\tp := &Plugin{\n\t\tpluginpath: pluginpath,\n\t\tloaded:     make(chan struct{}),\n\t\tsyms:       syms,\n\t}\n\tplugins[filepath] = p\n\tpluginsMu.Unlock()\n\n\tinitStr := C.CString(pluginpath + \".init\")\n\tinitFuncPC := C.pluginLookup(h, initStr, &cErr)\n\tC.free(unsafe.Pointer(initStr))\n\tif initFuncPC != nil {\n\t\tinitFuncP := &initFuncPC\n\t\tinitFunc := *(*func())(unsafe.Pointer(&initFuncP))\n\t\tinitFunc()\n\t}\n\n\t// Fill out the value of each plugin symbol.\n\tfor symName, sym := range syms {\n\t\tisFunc := symName[0] == '.'\n\t\tif isFunc {\n\t\t\tdelete(syms, symName)\n\t\t\tsymName = symName[1:]\n\t\t}\n\n\t\tcname := C.CString(pluginpath + \".\" + symName)\n\t\tp := C.pluginLookup(h, cname, &cErr)\n\t\tC.free(unsafe.Pointer(cname))\n\t\tif p == nil {\n\t\t\treturn nil, errors.New(\"plugin.Open: could not find symbol \" + symName + \": \" + C.GoString(cErr))\n\t\t}\n\t\tvalp := (*[2]unsafe.Pointer)(unsafe.Pointer(&sym))\n\t\tif isFunc {\n\t\t\t(*valp)[1] = unsafe.Pointer(&p)\n\t\t} else {\n\t\t\t(*valp)[1] = p\n\t\t}\n\t\tsyms[symName] = sym\n\t}\n\tclose(p.loaded)\n\treturn p, nil\n}\n\nfunc lookup(p *Plugin, symName string) (Symbol, error) {\n\tif s := p.syms[symName]; s != nil {\n\t\treturn s, nil\n\t}\n\treturn nil, errors.New(\"plugin: symbol \" + symName + \" not found in plugin \" + p.pluginpath)\n}\n\nvar (\n\tpluginsMu sync.Mutex\n\tplugins   map[string]*Plugin\n)\n\n// lastmoduleinit is defined in package runtime\nfunc lastmoduleinit() (pluginpath string, syms map[string]interface{}, mismatchpkg string)\n",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/runtime/rt0_linux_arm.s": "// Copyright 2009 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n#include \"textflag.h\"\n\nTEXT _rt0_arm_linux(SB),NOSPLIT,$-4\n\tMOVW\t(R13), R0\t// argc\n\tMOVW\t$4(R13), R1\t\t// argv\n\tMOVW\t$_rt0_arm_linux1(SB), R4\n\tB\t\t(R4)\n\n// When building with -buildmode=c-shared, this symbol is called when the shared\n// library is loaded.\nTEXT _rt0_arm_linux_lib(SB),NOSPLIT,$104\n\t// Preserve callee-save registers. Raspberry Pi's dlopen(), for example,\n\t// actually cares that R11 is preserved.\n\tMOVW\tR4, 12(R13)\n\tMOVW\tR5, 16(R13)\n\tMOVW\tR6, 20(R13)\n\tMOVW\tR7, 24(R13)\n\tMOVW\tR8, 28(R13)\n\tMOVW\tR11, 32(R13)\n\n\t// Skip floating point registers on GOARM < 6.\n\tMOVB    runtime\u00b7goarm(SB), R11\n\tCMP $6, R11\n\tBLT skipfpsave\n\tMOVD\tF8, (32+8*1)(R13)\n\tMOVD\tF9, (32+8*2)(R13)\n\tMOVD\tF10, (32+8*3)(R13)\n\tMOVD\tF11, (32+8*4)(R13)\n\tMOVD\tF12, (32+8*5)(R13)\n\tMOVD\tF13, (32+8*6)(R13)\n\tMOVD\tF14, (32+8*7)(R13)\n\tMOVD\tF15, (32+8*8)(R13)\nskipfpsave:\n\t// Save argc/argv.\n\tMOVW\tR0, _rt0_arm_linux_lib_argc<>(SB)\n\tMOVW\tR1, _rt0_arm_linux_lib_argv<>(SB)\n\n\t// Synchronous initialization.\n\tMOVW\t$runtime\u00b7libpreinit(SB), R2\n\tCALL\t(R2)\n\n\t// Create a new thread to do the runtime initialization.\n\tMOVW\t_cgo_sys_thread_create(SB), R2\n\tCMP\t$0, R2\n\tBEQ\tnocgo\n\tMOVW\t$_rt0_arm_linux_lib_go<>(SB), R0\n\tMOVW\t$0, R1\n\tBL\t(R2)\n\tB\trr\nnocgo:\n\tMOVW\t$0x800000, R0                     // stacksize = 8192KB\n\tMOVW\t$_rt0_arm_linux_lib_go<>(SB), R1  // fn\n\tMOVW\tR0, 4(R13)\n\tMOVW\tR1, 8(R13)\n\tBL\truntime\u00b7newosproc0(SB)\nrr:\n\t// Restore callee-save registers and return.\n\tMOVB    runtime\u00b7goarm(SB), R11\n\tCMP $6, R11\n\tBLT skipfprest\n\tMOVD\t(32+8*1)(R13), F8\n\tMOVD\t(32+8*2)(R13), F9\n\tMOVD\t(32+8*3)(R13), F10\n\tMOVD\t(32+8*4)(R13), F11\n\tMOVD\t(32+8*5)(R13), F12\n\tMOVD\t(32+8*6)(R13), F13\n\tMOVD\t(32+8*7)(R13), F14\n\tMOVD\t(32+8*8)(R13), F15\nskipfprest:\n\tMOVW\t12(R13), R4\n\tMOVW\t16(R13), R5\n\tMOVW\t20(R13), R6\n\tMOVW\t24(R13), R7\n\tMOVW\t28(R13), R8\n\tMOVW\t32(R13), R11\n\tRET\n\nTEXT _rt0_arm_linux_lib_go<>(SB),NOSPLIT,$8\n\tMOVW\t_rt0_arm_linux_lib_argc<>(SB), R0\n\tMOVW\t_rt0_arm_linux_lib_argv<>(SB), R1\n\tMOVW\tR0, 0(R13)\n\tMOVW\tR1, 4(R13)\n\tB\truntime\u00b7rt0_go(SB)\n\nDATA _rt0_arm_linux_lib_argc<>(SB)/4,$0\nGLOBL _rt0_arm_linux_lib_argc<>(SB),NOPTR,$4\nDATA _rt0_arm_linux_lib_argv<>(SB)/4,$0\nGLOBL _rt0_arm_linux_lib_argv<>(SB),NOPTR,$4\n\nTEXT _rt0_arm_linux1(SB),NOSPLIT,$-4\n\t// We first need to detect the kernel ABI, and warn the user\n\t// if the system only supports OABI\n\t// The strategy here is to call some EABI syscall to see if\n\t// SIGILL is received.\n\t// To catch SIGILL, we have to first setup sigaction, this is\n\t// a chicken-and-egg problem, because we can't do syscall if\n\t// we don't know the kernel ABI... Oh, not really, we can do\n\t// syscall in Thumb mode.\n\n\t// Save argc and argv\n\tMOVM.DB.W [R0-R1], (R13)\n\n\t// Thumb mode OABI check disabled because there are some\n\t// EABI systems that do not support Thumb execution.\n\t// We can run on them except for this check!\n\n\t// // set up sa_handler\n\t// MOVW\t$bad_abi<>(SB), R0 // sa_handler\n\t// MOVW\t$0, R1 // sa_flags\n\t// MOVW\t$0, R2 // sa_restorer\n\t// MOVW\t$0, R3 // sa_mask\n\t// MOVM.DB.W [R0-R3], (R13)\n\t// MOVW\t$4, R0 // SIGILL\n\t// MOVW\tR13, R1 // sa\n\t// SUB\t$16, R13\n\t// MOVW\tR13, R2 // old_sa\n\t// MOVW\t$8, R3 // c\n\t// MOVW\t$174, R7 // sys_sigaction\n\t// BL\toabi_syscall<>(SB)\n\n\t// do an EABI syscall\n\tMOVW\t$20, R7 // sys_getpid\n\tSWI\t$0 // this will trigger SIGILL on OABI systems\n\t\n\t// MOVW\t$4, R0  // SIGILL\n\t// MOVW\tR13, R1 // sa\n\t// MOVW\t$0, R2 // old_sa\n\t// MOVW\t$8, R3 // c\n\t// MOVW\t$174, R7 // sys_sigaction\n\t// SWI\t$0 // restore signal handler\n\t// ADD\t$32, R13\n\n\tB\truntime\u00b7rt0_go(SB)\n\nTEXT bad_abi<>(SB),NOSPLIT,$-4\n\t// give diagnosis and exit\n\tMOVW\t$2, R0 // stderr\n\tMOVW\t$bad_abi_msg(SB), R1 // data\n\tMOVW\t$45, R2 // len\n\tMOVW\t$4, R7 // sys_write\n\tBL\toabi_syscall<>(SB)\n\tMOVW\t$1, R0\n\tMOVW\t$1, R7 // sys_exit\n\tBL\toabi_syscall<>(SB)\n\tB  \t0(PC)\n\nDATA bad_abi_msg+0x00(SB)/8, $\"This pro\"\nDATA bad_abi_msg+0x08(SB)/8, $\"gram can\"\nDATA bad_abi_msg+0x10(SB)/8, $\" only be\"\nDATA bad_abi_msg+0x18(SB)/8, $\" run on \"\nDATA bad_abi_msg+0x20(SB)/8, $\"EABI ker\"\nDATA bad_abi_msg+0x28(SB)/4, $\"nels\"\nDATA bad_abi_msg+0x2c(SB)/1, $0xa\nGLOBL bad_abi_msg(SB), RODATA, $45\n\nTEXT oabi_syscall<>(SB),NOSPLIT,$-4\n\tADD $1, R15, R4 // R15 is hardware PC\n\tWORD $0xe12fff14 //BX\t(R4) // enter thumb mode\n\t// TODO(minux): only supports little-endian CPUs\n\tWORD $0x4770df01 // swi $1; bx lr\n\nTEXT main(SB),NOSPLIT,$-4\n\tMOVW\t$_rt0_arm_linux1(SB), R4\n\tB\t\t(R4)\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/runtime/cgo/gcc_openbsd_386.c": "// Copyright 2009 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <errno.h>\n#include <pthread.h>\n#include <signal.h>\n#include <string.h>\n#include \"libcgo.h\"\n#include \"libcgo_unix.h\"\n\nstatic void* threadentry(void*);\nstatic void (*setg_gcc)(void*);\n\n// TCB_SIZE is sizeof(struct thread_control_block), as defined in\n// /usr/src/lib/librthread/tcb.h on OpenBSD 5.9 and earlier.\n#define TCB_SIZE (4 * sizeof(void *))\n\n// TIB_SIZE is sizeof(struct tib), as defined in\n// /usr/include/tib.h on OpenBSD 6.0 and later.\n#define TIB_SIZE (4 * sizeof(void *) + 6 * sizeof(int))\n\n// TLS_SIZE is the size of TLS needed for Go.\n#define TLS_SIZE (2 * sizeof(void *))\n\nvoid *__get_tcb(void);\nvoid __set_tcb(void *);\n\nstatic int (*sys_pthread_create)(pthread_t *thread, const pthread_attr_t *attr,\n\tvoid *(*start_routine)(void *), void *arg);\n\nstruct thread_args {\n\tvoid *(*func)(void *);\n\tvoid *arg;\n};\n\nstatic int has_tib = 0;\n\nstatic void\ntcb_fixup(int mainthread)\n{\n\tvoid *tls, *newtcb, *oldtcb;\n\tsize_t tls_size, tcb_size;\n\n\t// TODO(jsing): Remove once OpenBSD 6.1 is released and OpenBSD 5.9 is\n\t// no longer supported.\n\n\t// The OpenBSD ld.so(1) does not currently support PT_TLS. As a result,\n\t// we need to allocate our own TLS space while preserving the existing\n\t// TCB or TIB that has been setup via librthread.\n\n\ttcb_size = has_tib ? TIB_SIZE : TCB_SIZE;\n\ttls_size = TLS_SIZE + tcb_size;\n\ttls = malloc(tls_size);\n\tif(tls == NULL)\n\t\tabort();\n\n\t// The signal trampoline expects the TLS slots to be zeroed.\n\tbzero(tls, TLS_SIZE);\n\n\toldtcb = __get_tcb();\n\tnewtcb = tls + TLS_SIZE;\n\tbcopy(oldtcb, newtcb, tcb_size);\n\tif(has_tib) {\n\t\t // Fix up self pointer.\n\t\t*(uintptr_t *)(newtcb) = (uintptr_t)newtcb;\n\t}\n\t__set_tcb(newtcb);\n\n\t// NOTE(jsing, minux): we can't free oldtcb without causing double-free\n\t// problem. so newtcb will be memory leaks. Get rid of this when OpenBSD\n\t// has proper support for PT_TLS.\n}\n\nstatic void *\nthread_start_wrapper(void *arg)\n{\n\tstruct thread_args args = *(struct thread_args *)arg;\n\n\tfree(arg);\n\ttcb_fixup(0);\n\n\treturn args.func(args.arg);\n}\n\nstatic void init_pthread_wrapper(void) {\n\tvoid *handle;\n\n\t// Locate symbol for the system pthread_create function.\n\thandle = dlopen(\"libpthread.so\", RTLD_LAZY);\n\tif(handle == NULL) {\n\t\tfprintf(stderr, \"runtime/cgo: dlopen failed to load libpthread: %s\\n\", dlerror());\n\t\tabort();\n\t}\n\tsys_pthread_create = dlsym(handle, \"pthread_create\");\n\tif(sys_pthread_create == NULL) {\n\t\tfprintf(stderr, \"runtime/cgo: dlsym failed to find pthread_create: %s\\n\", dlerror());\n\t\tabort();\n\t}\n\t// _rthread_init is hidden in OpenBSD librthread that has TIB.\n\tif(dlsym(handle, \"_rthread_init\") == NULL) {\n\t\thas_tib = 1;\n\t}\n\tdlclose(handle);\n}\n\nstatic pthread_once_t init_pthread_wrapper_once = PTHREAD_ONCE_INIT;\n\nint\npthread_create(pthread_t *thread, const pthread_attr_t *attr,\n\tvoid *(*start_routine)(void *), void *arg)\n{\n\tstruct thread_args *p;\n\n\t// we must initialize our wrapper in pthread_create, because it is valid to call\n\t// pthread_create in a static constructor, and in fact, our test for issue 9456\n\t// does just that.\n\tif(pthread_once(&init_pthread_wrapper_once, init_pthread_wrapper) != 0) {\n\t\tfprintf(stderr, \"runtime/cgo: failed to initialize pthread_create wrapper\\n\");\n\t\tabort();\n\t}\n\n\tp = malloc(sizeof(*p));\n\tif(p == NULL) {\n\t\terrno = ENOMEM;\n\t\treturn -1;\n\t}\n\tp->func = start_routine;\n\tp->arg = arg;\n\n\treturn sys_pthread_create(thread, attr, thread_start_wrapper, p);\n}\n\nvoid\nx_cgo_init(G *g, void (*setg)(void*))\n{\n\tpthread_attr_t attr;\n\tsize_t size;\n\n\tsetg_gcc = setg;\n\tpthread_attr_init(&attr);\n\tpthread_attr_getstacksize(&attr, &size);\n\tg->stacklo = (uintptr)&attr - size + 4096;\n\tpthread_attr_destroy(&attr);\n\n\tif(pthread_once(&init_pthread_wrapper_once, init_pthread_wrapper) != 0) {\n\t\tfprintf(stderr, \"runtime/cgo: failed to initialize pthread_create wrapper\\n\");\n\t\tabort();\n\t}\n\n\ttcb_fixup(1);\n}\n\n\nvoid\n_cgo_sys_thread_start(ThreadStart *ts)\n{\n\tpthread_attr_t attr;\n\tsigset_t ign, oset;\n\tpthread_t p;\n\tsize_t size;\n\tint err;\n\n\tsigfillset(&ign);\n\tpthread_sigmask(SIG_SETMASK, &ign, &oset);\n\n\tpthread_attr_init(&attr);\n\tpthread_attr_getstacksize(&attr, &size);\n\n\t// Leave stacklo=0 and set stackhi=size; mstack will do the rest.\n\tts->g->stackhi = size;\n\terr = _cgo_openbsd_try_pthread_create(sys_pthread_create, &p, &attr, threadentry, ts);\n\n\tpthread_sigmask(SIG_SETMASK, &oset, nil);\n\n\tif (err != 0) {\n\t\tfprintf(stderr, \"runtime/cgo: pthread_create failed: %s\\n\", strerror(err));\n\t\tabort();\n\t}\n}\n\nstatic void*\nthreadentry(void *v)\n{\n\tThreadStart ts;\n\n\ttcb_fixup(0);\n\n\tts = *(ThreadStart*)v;\n\tfree(v);\n\n\t/*\n\t * Set specific keys.\n\t */\n\tsetg_gcc((void*)ts.g);\n\n\tcrosscall_386(ts.fn);\n\treturn nil;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/runtime/cgo/gcc_openbsd_amd64.c": "// Copyright 2009 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <errno.h>\n#include <pthread.h>\n#include <signal.h>\n#include <string.h>\n#include \"libcgo.h\"\n#include \"libcgo_unix.h\"\n\nstatic void* threadentry(void*);\nstatic void (*setg_gcc)(void*);\n\n// TCB_SIZE is sizeof(struct thread_control_block), as defined in\n// /usr/src/lib/librthread/tcb.h on OpenBSD 5.9 and earlier.\n#define TCB_SIZE (4 * sizeof(void *))\n\n// TIB_SIZE is sizeof(struct tib), as defined in\n// /usr/include/tib.h on OpenBSD 6.0 and later.\n#define TIB_SIZE (4 * sizeof(void *) + 6 * sizeof(int))\n\n// TLS_SIZE is the size of TLS needed for Go.\n#define TLS_SIZE (2 * sizeof(void *))\n\nvoid *__get_tcb(void);\nvoid __set_tcb(void *);\n\nstatic int (*sys_pthread_create)(pthread_t *thread, const pthread_attr_t *attr,\n\tvoid *(*start_routine)(void *), void *arg);\n\nstruct thread_args {\n\tvoid *(*func)(void *);\n\tvoid *arg;\n};\n\nstatic int has_tib = 0;\n\nstatic void\ntcb_fixup(int mainthread)\n{\n\tvoid *tls, *newtcb, *oldtcb;\n\tsize_t tls_size, tcb_size;\n\n\t// TODO(jsing): Remove once OpenBSD 6.1 is released and OpenBSD 5.9 is\n\t// no longer supported.\n\n\t// The OpenBSD ld.so(1) does not currently support PT_TLS. As a result,\n\t// we need to allocate our own TLS space while preserving the existing\n\t// TCB or TIB that has been setup via librthread.\n\n\ttcb_size = has_tib ? TIB_SIZE : TCB_SIZE;\n\ttls_size = TLS_SIZE + tcb_size;\n\ttls = malloc(tls_size);\n\tif(tls == NULL)\n\t\tabort();\n\n\t// The signal trampoline expects the TLS slots to be zeroed.\n\tbzero(tls, TLS_SIZE);\n\n\toldtcb = __get_tcb();\n\tnewtcb = tls + TLS_SIZE;\n\tbcopy(oldtcb, newtcb, tcb_size);\n\tif(has_tib) {\n\t\t // Fix up self pointer.\n\t\t*(uintptr_t *)(newtcb) = (uintptr_t)newtcb;\n\t}\n\t__set_tcb(newtcb);\n\n\t// NOTE(jsing, minux): we can't free oldtcb without causing double-free\n\t// problem. so newtcb will be memory leaks. Get rid of this when OpenBSD\n\t// has proper support for PT_TLS.\n}\n\nstatic void *\nthread_start_wrapper(void *arg)\n{\n\tstruct thread_args args = *(struct thread_args *)arg;\n\n\tfree(arg);\n\ttcb_fixup(0);\n\n\treturn args.func(args.arg);\n}\n\nstatic void init_pthread_wrapper(void) {\n\tvoid *handle;\n\n\t// Locate symbol for the system pthread_create function.\n\thandle = dlopen(\"libpthread.so\", RTLD_LAZY);\n\tif(handle == NULL) {\n\t\tfprintf(stderr, \"runtime/cgo: dlopen failed to load libpthread: %s\\n\", dlerror());\n\t\tabort();\n\t}\n\tsys_pthread_create = dlsym(handle, \"pthread_create\");\n\tif(sys_pthread_create == NULL) {\n\t\tfprintf(stderr, \"runtime/cgo: dlsym failed to find pthread_create: %s\\n\", dlerror());\n\t\tabort();\n\t}\n\t// _rthread_init is hidden in OpenBSD librthread that has TIB.\n\tif(dlsym(handle, \"_rthread_init\") == NULL) {\n\t\thas_tib = 1;\n\t}\n\tdlclose(handle);\n}\n\nstatic pthread_once_t init_pthread_wrapper_once = PTHREAD_ONCE_INIT;\n\nint\npthread_create(pthread_t *thread, const pthread_attr_t *attr,\n\tvoid *(*start_routine)(void *), void *arg)\n{\n\tstruct thread_args *p;\n\n\t// we must initialize our wrapper in pthread_create, because it is valid to call\n\t// pthread_create in a static constructor, and in fact, our test for issue 9456\n\t// does just that.\n\tif(pthread_once(&init_pthread_wrapper_once, init_pthread_wrapper) != 0) {\n\t\tfprintf(stderr, \"runtime/cgo: failed to initialize pthread_create wrapper\\n\");\n\t\tabort();\n\t}\n\n\tp = malloc(sizeof(*p));\n\tif(p == NULL) {\n\t\terrno = ENOMEM;\n\t\treturn -1;\n\t}\n\tp->func = start_routine;\n\tp->arg = arg;\n\n\treturn sys_pthread_create(thread, attr, thread_start_wrapper, p);\n}\n\nvoid\nx_cgo_init(G *g, void (*setg)(void*))\n{\n\tpthread_attr_t attr;\n\tsize_t size;\n\n\tsetg_gcc = setg;\n\tpthread_attr_init(&attr);\n\tpthread_attr_getstacksize(&attr, &size);\n\tg->stacklo = (uintptr)&attr - size + 4096;\n\tpthread_attr_destroy(&attr);\n\n\tif(pthread_once(&init_pthread_wrapper_once, init_pthread_wrapper) != 0) {\n\t\tfprintf(stderr, \"runtime/cgo: failed to initialize pthread_create wrapper\\n\");\n\t\tabort();\n\t}\n\n\ttcb_fixup(1);\n}\n\n\nvoid\n_cgo_sys_thread_start(ThreadStart *ts)\n{\n\tpthread_attr_t attr;\n\tsigset_t ign, oset;\n\tpthread_t p;\n\tsize_t size;\n\tint err;\n\n\tsigfillset(&ign);\n\tpthread_sigmask(SIG_SETMASK, &ign, &oset);\n\n\tpthread_attr_init(&attr);\n\tpthread_attr_getstacksize(&attr, &size);\n\n\t// Leave stacklo=0 and set stackhi=size; mstack will do the rest.\n\tts->g->stackhi = size;\n\terr = _cgo_openbsd_try_pthread_create(sys_pthread_create, &p, &attr, threadentry, ts);\n\n\tpthread_sigmask(SIG_SETMASK, &oset, nil);\n\n\tif (err != 0) {\n\t\tfprintf(stderr, \"runtime/cgo: pthread_create failed: %s\\n\", strerror(err));\n\t\tabort();\n\t}\n}\n\nstatic void*\nthreadentry(void *v)\n{\n\tThreadStart ts;\n\n\ttcb_fixup(0);\n\n\tts = *(ThreadStart*)v;\n\tfree(v);\n\n\t/*\n\t * Set specific keys.\n\t */\n\tsetg_gcc((void*)ts.g);\n\n\tcrosscall_amd64(ts.fn);\n\treturn nil;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/cmd/link/internal/ld/lib.go": "// Inferno utils/8l/asm.c\n// https://bitbucket.org/inferno-os/inferno-os/src/default/utils/8l/asm.c\n//\n//\tCopyright \u00a9 1994-1999 Lucent Technologies Inc.  All rights reserved.\n//\tPortions Copyright \u00a9 1995-1997 C H Forsyth (forsyth@terzarima.net)\n//\tPortions Copyright \u00a9 1997-1999 Vita Nuova Limited\n//\tPortions Copyright \u00a9 2000-2007 Vita Nuova Holdings Limited (www.vitanuova.com)\n//\tPortions Copyright \u00a9 2004,2006 Bruce Ellis\n//\tPortions Copyright \u00a9 2005-2007 C H Forsyth (forsyth@terzarima.net)\n//\tRevisions Copyright \u00a9 2000-2007 Lucent Technologies Inc. and others\n//\tPortions Copyright \u00a9 2009 The Go Authors. All rights reserved.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage ld\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"cmd/internal/bio\"\n\t\"cmd/internal/obj\"\n\t\"cmd/internal/sys\"\n\t\"crypto/sha1\"\n\t\"debug/elf\"\n\t\"encoding/binary\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strings\"\n\t\"sync\"\n)\n\n// Data layout and relocation.\n\n// Derived from Inferno utils/6l/l.h\n// https://bitbucket.org/inferno-os/inferno-os/src/default/utils/6l/l.h\n//\n//\tCopyright \u00a9 1994-1999 Lucent Technologies Inc.  All rights reserved.\n//\tPortions Copyright \u00a9 1995-1997 C H Forsyth (forsyth@terzarima.net)\n//\tPortions Copyright \u00a9 1997-1999 Vita Nuova Limited\n//\tPortions Copyright \u00a9 2000-2007 Vita Nuova Holdings Limited (www.vitanuova.com)\n//\tPortions Copyright \u00a9 2004,2006 Bruce Ellis\n//\tPortions Copyright \u00a9 2005-2007 C H Forsyth (forsyth@terzarima.net)\n//\tRevisions Copyright \u00a9 2000-2007 Lucent Technologies Inc. and others\n//\tPortions Copyright \u00a9 2009 The Go Authors. All rights reserved.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\ntype Arch struct {\n\tFuncalign        int\n\tMaxalign         int\n\tMinalign         int\n\tDwarfregsp       int\n\tDwarfreglr       int\n\tLinuxdynld       string\n\tFreebsddynld     string\n\tNetbsddynld      string\n\tOpenbsddynld     string\n\tDragonflydynld   string\n\tSolarisdynld     string\n\tAdddynrel        func(*Link, *Symbol, *Reloc) bool\n\tArchinit         func(*Link)\n\tArchreloc        func(*Link, *Reloc, *Symbol, *int64) int\n\tArchrelocvariant func(*Link, *Reloc, *Symbol, int64) int64\n\tTrampoline       func(*Link, *Reloc, *Symbol)\n\tAsmb             func(*Link)\n\tElfreloc1        func(*Link, *Reloc, int64) int\n\tElfsetupplt      func(*Link)\n\tGentext          func(*Link)\n\tMachoreloc1      func(*Symbol, *Reloc, int64) int\n\tPEreloc1         func(*Symbol, *Reloc, int64) bool\n\tWput             func(uint16)\n\tLput             func(uint32)\n\tVput             func(uint64)\n\tAppend16         func(b []byte, v uint16) []byte\n\tAppend32         func(b []byte, v uint32) []byte\n\tAppend64         func(b []byte, v uint64) []byte\n\n\t// TLSIEtoLE converts a TLS Initial Executable relocation to\n\t// a TLS Local Executable relocation.\n\t//\n\t// This is possible when a TLS IE relocation refers to a local\n\t// symbol in an executable, which is typical when internally\n\t// linking PIE binaries.\n\tTLSIEtoLE func(s *Symbol, off, size int)\n}\n\nvar (\n\tThearch Arch\n\tLcsize  int32\n\trpath   Rpath\n\tSpsize  int32\n\tSymsize int32\n)\n\n// Terrible but standard terminology.\n// A segment describes a block of file to load into memory.\n// A section further describes the pieces of that block for\n// use in debuggers and such.\n\nconst (\n\tMINFUNC = 16 // minimum size for a function\n)\n\ntype Segment struct {\n\tRwx     uint8  // permission as usual unix bits (5 = r-x etc)\n\tVaddr   uint64 // virtual address\n\tLength  uint64 // length in memory\n\tFileoff uint64 // file offset\n\tFilelen uint64 // length on disk\n\tSect    *Section\n}\n\ntype Section struct {\n\tRwx     uint8\n\tExtnum  int16\n\tAlign   int32\n\tName    string\n\tVaddr   uint64\n\tLength  uint64\n\tNext    *Section\n\tSeg     *Segment\n\tElfsect *ElfShdr\n\tReloff  uint64\n\tRellen  uint64\n}\n\n// DynlinkingGo returns whether we are producing Go code that can live\n// in separate shared libraries linked together at runtime.\nfunc (ctxt *Link) DynlinkingGo() bool {\n\tif !ctxt.Loaded {\n\t\tpanic(\"DynlinkingGo called before all symbols loaded\")\n\t}\n\tcanUsePlugins := ctxt.Syms.ROLookup(\"plugin.Open\", 0) != nil\n\treturn Buildmode == BuildmodeShared || *FlagLinkshared || Buildmode == BuildmodePlugin || canUsePlugins\n}\n\n// UseRelro returns whether to make use of \"read only relocations\" aka\n// relro.\nfunc UseRelro() bool {\n\tswitch Buildmode {\n\tcase BuildmodeCArchive, BuildmodeCShared, BuildmodeShared, BuildmodePIE, BuildmodePlugin:\n\t\treturn Iself\n\tdefault:\n\t\treturn *FlagLinkshared\n\t}\n}\n\nvar (\n\tSysArch         *sys.Arch\n\tdynexp          []*Symbol\n\tdynlib          []string\n\tldflag          []string\n\thavedynamic     int\n\tFuncalign       int\n\tiscgo           bool\n\telfglobalsymndx int\n\tinterpreter     string\n\n\tdebug_s  bool // backup old value of debug['s']\n\tHEADR    int32\n\tHeadtype obj.HeadType\n\n\tnerrors  int\n\tliveness int64\n)\n\nvar (\n\tSegtext      Segment\n\tSegrodata    Segment\n\tSegrelrodata Segment\n\tSegdata      Segment\n\tSegdwarf     Segment\n)\n\n/* whence for ldpkg */\nconst (\n\tFileObj = 0 + iota\n\tArchiveObj\n\tPkgdef\n)\n\n// TODO(dfc) outBuf duplicates bio.Writer\ntype outBuf struct {\n\tw   *bufio.Writer\n\tf   *os.File\n\toff int64\n}\n\nfunc (w *outBuf) Write(p []byte) (n int, err error) {\n\tn, err = w.w.Write(p)\n\tw.off += int64(n)\n\treturn n, err\n}\n\nfunc (w *outBuf) WriteString(s string) (n int, err error) {\n\tn, err = coutbuf.w.WriteString(s)\n\tw.off += int64(n)\n\treturn n, err\n}\n\nfunc (w *outBuf) Offset() int64 {\n\treturn w.off\n}\n\nvar coutbuf outBuf\n\nconst pkgname = \"__.PKGDEF\"\n\nvar (\n\t// Set if we see an object compiled by the host compiler that is not\n\t// from a package that is known to support internal linking mode.\n\texternalobj = false\n\ttheline     string\n)\n\nfunc Lflag(ctxt *Link, arg string) {\n\tctxt.Libdir = append(ctxt.Libdir, arg)\n}\n\n/*\n * Unix doesn't like it when we write to a running (or, sometimes,\n * recently run) binary, so remove the output file before writing it.\n * On Windows 7, remove() can force a subsequent create() to fail.\n * S_ISREG() does not exist on Plan 9.\n */\nfunc mayberemoveoutfile() {\n\tif fi, err := os.Lstat(*flagOutfile); err == nil && !fi.Mode().IsRegular() {\n\t\treturn\n\t}\n\tos.Remove(*flagOutfile)\n}\n\nfunc libinit(ctxt *Link) {\n\tFuncalign = Thearch.Funcalign\n\n\t// add goroot to the end of the libdir list.\n\tsuffix := \"\"\n\n\tsuffixsep := \"\"\n\tif *flagInstallSuffix != \"\" {\n\t\tsuffixsep = \"_\"\n\t\tsuffix = *flagInstallSuffix\n\t} else if *flagRace {\n\t\tsuffixsep = \"_\"\n\t\tsuffix = \"race\"\n\t} else if *flagMsan {\n\t\tsuffixsep = \"_\"\n\t\tsuffix = \"msan\"\n\t}\n\n\tLflag(ctxt, filepath.Join(obj.GOROOT, \"pkg\", fmt.Sprintf(\"%s_%s%s%s\", obj.GOOS, obj.GOARCH, suffixsep, suffix)))\n\n\tmayberemoveoutfile()\n\tf, err := os.OpenFile(*flagOutfile, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0775)\n\tif err != nil {\n\t\tExitf(\"cannot create %s: %v\", *flagOutfile, err)\n\t}\n\n\tcoutbuf.w = bufio.NewWriter(f)\n\tcoutbuf.f = f\n\n\tif *flagEntrySymbol == \"\" {\n\t\tswitch Buildmode {\n\t\tcase BuildmodeCShared, BuildmodeCArchive:\n\t\t\t*flagEntrySymbol = fmt.Sprintf(\"_rt0_%s_%s_lib\", obj.GOARCH, obj.GOOS)\n\t\tcase BuildmodeExe, BuildmodePIE:\n\t\t\t*flagEntrySymbol = fmt.Sprintf(\"_rt0_%s_%s\", obj.GOARCH, obj.GOOS)\n\t\tcase BuildmodeShared, BuildmodePlugin:\n\t\t\t// No *flagEntrySymbol for -buildmode=shared and plugin\n\t\tdefault:\n\t\t\tErrorf(nil, \"unknown *flagEntrySymbol for buildmode %v\", Buildmode)\n\t\t}\n\t}\n}\n\nfunc errorexit() {\n\tif coutbuf.f != nil {\n\t\tif nerrors != 0 {\n\t\t\tCflush()\n\t\t}\n\t\t// For rmtemp run at atexit time on Windows.\n\t\tif err := coutbuf.f.Close(); err != nil {\n\t\t\tExitf(\"close: %v\", err)\n\t\t}\n\t}\n\n\tif nerrors != 0 {\n\t\tif coutbuf.f != nil {\n\t\t\tmayberemoveoutfile()\n\t\t}\n\t\tExit(2)\n\t}\n\n\tExit(0)\n}\n\nfunc loadinternal(ctxt *Link, name string) *Library {\n\tfor i := 0; i < len(ctxt.Libdir); i++ {\n\t\tif *FlagLinkshared {\n\t\t\tshlibname := filepath.Join(ctxt.Libdir[i], name+\".shlibname\")\n\t\t\tif ctxt.Debugvlog != 0 {\n\t\t\t\tctxt.Logf(\"searching for %s.a in %s\\n\", name, shlibname)\n\t\t\t}\n\t\t\tif _, err := os.Stat(shlibname); err == nil {\n\t\t\t\treturn addlibpath(ctxt, \"internal\", \"internal\", \"\", name, shlibname)\n\t\t\t}\n\t\t}\n\t\tpname := filepath.Join(ctxt.Libdir[i], name+\".a\")\n\t\tif ctxt.Debugvlog != 0 {\n\t\t\tctxt.Logf(\"searching for %s.a in %s\\n\", name, pname)\n\t\t}\n\t\tif _, err := os.Stat(pname); err == nil {\n\t\t\treturn addlibpath(ctxt, \"internal\", \"internal\", pname, name, \"\")\n\t\t}\n\t}\n\n\tctxt.Logf(\"warning: unable to find %s.a\\n\", name)\n\treturn nil\n}\n\n// findLibPathCmd uses cmd command to find gcc library libname.\n// It returns library full path if found, or \"none\" if not found.\nfunc (ctxt *Link) findLibPathCmd(cmd, libname string) string {\n\tif *flagExtld == \"\" {\n\t\t*flagExtld = \"gcc\"\n\t}\n\targs := hostlinkArchArgs()\n\targs = append(args, cmd)\n\tif ctxt.Debugvlog != 0 {\n\t\tctxt.Logf(\"%s %v\\n\", *flagExtld, args)\n\t}\n\tout, err := exec.Command(*flagExtld, args...).Output()\n\tif err != nil {\n\t\tif ctxt.Debugvlog != 0 {\n\t\t\tctxt.Logf(\"not using a %s file because compiler failed\\n%v\\n%s\\n\", libname, err, out)\n\t\t}\n\t\treturn \"none\"\n\t}\n\treturn strings.TrimSpace(string(out))\n}\n\n// findLibPath searches for library libname.\n// It returns library full path if found, or \"none\" if not found.\nfunc (ctxt *Link) findLibPath(libname string) string {\n\treturn ctxt.findLibPathCmd(\"--print-file-name=\"+libname, libname)\n}\n\nfunc (ctxt *Link) loadlib() {\n\tswitch Buildmode {\n\tcase BuildmodeCShared, BuildmodePlugin:\n\t\ts := ctxt.Syms.Lookup(\"runtime.islibrary\", 0)\n\t\ts.Attr |= AttrDuplicateOK\n\t\tAdduint8(ctxt, s, 1)\n\tcase BuildmodeCArchive:\n\t\ts := ctxt.Syms.Lookup(\"runtime.isarchive\", 0)\n\t\ts.Attr |= AttrDuplicateOK\n\t\tAdduint8(ctxt, s, 1)\n\t}\n\n\tloadinternal(ctxt, \"runtime\")\n\tif SysArch.Family == sys.ARM {\n\t\tloadinternal(ctxt, \"math\")\n\t}\n\tif *flagRace {\n\t\tloadinternal(ctxt, \"runtime/race\")\n\t}\n\tif *flagMsan {\n\t\tloadinternal(ctxt, \"runtime/msan\")\n\t}\n\n\tvar i int\n\tfor i = 0; i < len(ctxt.Library); i++ {\n\t\tiscgo = iscgo || ctxt.Library[i].Pkg == \"runtime/cgo\"\n\t\tif ctxt.Library[i].Shlib == \"\" {\n\t\t\tif ctxt.Debugvlog > 1 {\n\t\t\t\tctxt.Logf(\"%5.2f autolib: %s (from %s)\\n\", obj.Cputime(), ctxt.Library[i].File, ctxt.Library[i].Objref)\n\t\t\t}\n\t\t\tobjfile(ctxt, ctxt.Library[i])\n\t\t}\n\t}\n\n\tfor i = 0; i < len(ctxt.Library); i++ {\n\t\tif ctxt.Library[i].Shlib != \"\" {\n\t\t\tif ctxt.Debugvlog > 1 {\n\t\t\t\tctxt.Logf(\"%5.2f autolib: %s (from %s)\\n\", obj.Cputime(), ctxt.Library[i].Shlib, ctxt.Library[i].Objref)\n\t\t\t}\n\t\t\tldshlibsyms(ctxt, ctxt.Library[i].Shlib)\n\t\t}\n\t}\n\n\t// We now have enough information to determine the link mode.\n\tdetermineLinkMode(ctxt)\n\n\tif Headtype == obj.Hdarwin && Linkmode == LinkExternal {\n\t\t*FlagTextAddr = 0\n\t}\n\n\tif Linkmode == LinkExternal && SysArch.Family == sys.PPC64 {\n\t\ttoc := ctxt.Syms.Lookup(\".TOC.\", 0)\n\t\ttoc.Type = obj.SDYNIMPORT\n\t}\n\n\tif Linkmode == LinkExternal && !iscgo {\n\t\t// This indicates a user requested -linkmode=external.\n\t\t// The startup code uses an import of runtime/cgo to decide\n\t\t// whether to initialize the TLS.  So give it one. This could\n\t\t// be handled differently but it's an unusual case.\n\t\tloadinternal(ctxt, \"runtime/cgo\")\n\n\t\tif i < len(ctxt.Library) {\n\t\t\tif ctxt.Library[i].Shlib != \"\" {\n\t\t\t\tldshlibsyms(ctxt, ctxt.Library[i].Shlib)\n\t\t\t} else {\n\t\t\t\tif Buildmode == BuildmodeShared || *FlagLinkshared {\n\t\t\t\t\tExitf(\"cannot implicitly include runtime/cgo in a shared library\")\n\t\t\t\t}\n\t\t\t\tobjfile(ctxt, ctxt.Library[i])\n\t\t\t}\n\t\t}\n\t}\n\n\tif Linkmode == LinkInternal {\n\t\t// Drop all the cgo_import_static declarations.\n\t\t// Turns out we won't be needing them.\n\t\tfor _, s := range ctxt.Syms.Allsym {\n\t\t\tif s.Type == obj.SHOSTOBJ {\n\t\t\t\t// If a symbol was marked both\n\t\t\t\t// cgo_import_static and cgo_import_dynamic,\n\t\t\t\t// then we want to make it cgo_import_dynamic\n\t\t\t\t// now.\n\t\t\t\tif s.Extname != \"\" && s.Dynimplib != \"\" && !s.Attr.CgoExport() {\n\t\t\t\t\ts.Type = obj.SDYNIMPORT\n\t\t\t\t} else {\n\t\t\t\t\ts.Type = 0\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\ttlsg := ctxt.Syms.Lookup(\"runtime.tlsg\", 0)\n\n\t// runtime.tlsg is used for external linking on platforms that do not define\n\t// a variable to hold g in assembly (currently only intel).\n\tif tlsg.Type == 0 {\n\t\ttlsg.Type = obj.STLSBSS\n\t\ttlsg.Size = int64(SysArch.PtrSize)\n\t} else if tlsg.Type != obj.SDYNIMPORT {\n\t\tErrorf(nil, \"runtime declared tlsg variable %v\", tlsg.Type)\n\t}\n\ttlsg.Attr |= AttrReachable\n\tctxt.Tlsg = tlsg\n\n\tvar moduledata *Symbol\n\tif Buildmode == BuildmodePlugin {\n\t\tmoduledata = ctxt.Syms.Lookup(\"local.pluginmoduledata\", 0)\n\t\tmoduledata.Attr |= AttrLocal\n\t} else {\n\t\tmoduledata = ctxt.Syms.Lookup(\"runtime.firstmoduledata\", 0)\n\t}\n\tif moduledata.Type != 0 && moduledata.Type != obj.SDYNIMPORT {\n\t\t// If the module (toolchain-speak for \"executable or shared\n\t\t// library\") we are linking contains the runtime package, it\n\t\t// will define the runtime.firstmoduledata symbol and we\n\t\t// truncate it back to 0 bytes so we can define its entire\n\t\t// contents in symtab.go:symtab().\n\t\tmoduledata.Size = 0\n\n\t\t// In addition, on ARM, the runtime depends on the linker\n\t\t// recording the value of GOARM.\n\t\tif SysArch.Family == sys.ARM {\n\t\t\ts := ctxt.Syms.Lookup(\"runtime.goarm\", 0)\n\t\t\ts.Type = obj.SRODATA\n\t\t\ts.Size = 0\n\t\t\tAdduint8(ctxt, s, uint8(obj.GOARM))\n\t\t}\n\n\t\tif obj.Framepointer_enabled(obj.GOOS, obj.GOARCH) {\n\t\t\ts := ctxt.Syms.Lookup(\"runtime.framepointer_enabled\", 0)\n\t\t\ts.Type = obj.SRODATA\n\t\t\ts.Size = 0\n\t\t\tAdduint8(ctxt, s, 1)\n\t\t}\n\t} else {\n\t\t// If OTOH the module does not contain the runtime package,\n\t\t// create a local symbol for the moduledata.\n\t\tmoduledata = ctxt.Syms.Lookup(\"local.moduledata\", 0)\n\t\tmoduledata.Attr |= AttrLocal\n\t}\n\t// In all cases way we mark the moduledata as noptrdata to hide it from\n\t// the GC.\n\tmoduledata.Type = obj.SNOPTRDATA\n\tmoduledata.Attr |= AttrReachable\n\tctxt.Moduledata = moduledata\n\n\t// Now that we know the link mode, trim the dynexp list.\n\tx := AttrCgoExportDynamic\n\n\tif Linkmode == LinkExternal {\n\t\tx = AttrCgoExportStatic\n\t}\n\tw := 0\n\tfor i := 0; i < len(dynexp); i++ {\n\t\tif dynexp[i].Attr&x != 0 {\n\t\t\tdynexp[w] = dynexp[i]\n\t\t\tw++\n\t\t}\n\t}\n\tdynexp = dynexp[:w]\n\n\t// In internal link mode, read the host object files.\n\tif Linkmode == LinkInternal {\n\t\thostobjs(ctxt)\n\n\t\t// If we have any undefined symbols in external\n\t\t// objects, try to read them from the libgcc file.\n\t\tany := false\n\t\tfor _, s := range ctxt.Syms.Allsym {\n\t\t\tfor _, r := range s.R {\n\t\t\t\tif r.Sym != nil && r.Sym.Type&obj.SMASK == obj.SXREF && r.Sym.Name != \".got\" {\n\t\t\t\t\tany = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif any {\n\t\t\tif *flagLibGCC == \"\" {\n\t\t\t\t*flagLibGCC = ctxt.findLibPathCmd(\"--print-libgcc-file-name\", \"libgcc\")\n\t\t\t}\n\t\t\tif *flagLibGCC != \"none\" {\n\t\t\t\thostArchive(ctxt, *flagLibGCC)\n\t\t\t}\n\t\t\tif Headtype == obj.Hwindows || Headtype == obj.Hwindowsgui {\n\t\t\t\tif p := ctxt.findLibPath(\"libmingwex.a\"); p != \"none\" {\n\t\t\t\t\thostArchive(ctxt, p)\n\t\t\t\t}\n\t\t\t\tif p := ctxt.findLibPath(\"libmingw32.a\"); p != \"none\" {\n\t\t\t\t\thostArchive(ctxt, p)\n\t\t\t\t}\n\t\t\t\t// TODO: maybe do something similar to peimporteddlls to collect all lib names\n\t\t\t\t// and try link them all to final exe just like libmingwex.a and libmingw32.a:\n\t\t\t\t/*\n\t\t\t\t\tfor:\n\t\t\t\t\t#cgo windows LDFLAGS: -lmsvcrt -lm\n\t\t\t\t\timport:\n\t\t\t\t\tlibmsvcrt.a libm.a\n\t\t\t\t*/\n\t\t\t}\n\t\t}\n\t} else {\n\t\thostlinksetup()\n\t}\n\n\t// We've loaded all the code now.\n\tctxt.Loaded = true\n\n\t// If there are no dynamic libraries needed, gcc disables dynamic linking.\n\t// Because of this, glibc's dynamic ELF loader occasionally (like in version 2.13)\n\t// assumes that a dynamic binary always refers to at least one dynamic library.\n\t// Rather than be a source of test cases for glibc, disable dynamic linking\n\t// the same way that gcc would.\n\t//\n\t// Exception: on OS X, programs such as Shark only work with dynamic\n\t// binaries, so leave it enabled on OS X (Mach-O) binaries.\n\t// Also leave it enabled on Solaris which doesn't support\n\t// statically linked binaries.\n\tif Buildmode == BuildmodeExe {\n\t\tif havedynamic == 0 && Headtype != obj.Hdarwin && Headtype != obj.Hsolaris {\n\t\t\t*FlagD = true\n\t\t}\n\t}\n\n\t// If package versioning is required, generate a hash of the\n\t// the packages used in the link.\n\tif Buildmode == BuildmodeShared || Buildmode == BuildmodePlugin || ctxt.Syms.ROLookup(\"plugin.Open\", 0) != nil {\n\t\tfor i = 0; i < len(ctxt.Library); i++ {\n\t\t\tif ctxt.Library[i].Shlib == \"\" {\n\t\t\t\tgenhash(ctxt, ctxt.Library[i])\n\t\t\t}\n\t\t}\n\t}\n\n\tif SysArch == sys.Arch386 {\n\t\tif (Buildmode == BuildmodeCArchive && Iself) || Buildmode == BuildmodeCShared || Buildmode == BuildmodePIE || ctxt.DynlinkingGo() {\n\t\t\tgot := ctxt.Syms.Lookup(\"_GLOBAL_OFFSET_TABLE_\", 0)\n\t\t\tgot.Type = obj.SDYNIMPORT\n\t\t\tgot.Attr |= AttrReachable\n\t\t}\n\t}\n\n\timportcycles()\n\n\t// put symbols into Textp\n\t// do it in postorder so that packages are laid down in dependency order\n\t// internal first, then everything else\n\tctxt.Library = postorder(ctxt.Library)\n\tfor _, doInternal := range [2]bool{true, false} {\n\t\tfor _, lib := range ctxt.Library {\n\t\t\tif isRuntimeDepPkg(lib.Pkg) != doInternal {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tctxt.Textp = append(ctxt.Textp, lib.textp...)\n\t\t\tfor _, s := range lib.dupTextSyms {\n\t\t\t\tif !s.Attr.OnList() {\n\t\t\t\t\tctxt.Textp = append(ctxt.Textp, s)\n\t\t\t\t\ts.Attr |= AttrOnList\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif len(ctxt.Shlibs) > 0 {\n\t\t// We might have overwritten some functions above (this tends to happen for the\n\t\t// autogenerated type equality/hashing functions) and we don't want to generated\n\t\t// pcln table entries for these any more so remove them from Textp.\n\t\ttextp := make([]*Symbol, 0, len(ctxt.Textp))\n\t\tfor _, s := range ctxt.Textp {\n\t\t\tif s.Type != obj.SDYNIMPORT {\n\t\t\t\ttextp = append(textp, s)\n\t\t\t}\n\t\t}\n\t\tctxt.Textp = textp\n\t}\n}\n\n/*\n * look for the next file in an archive.\n * adapted from libmach.\n */\nfunc nextar(bp *bio.Reader, off int64, a *ArHdr) int64 {\n\tif off&1 != 0 {\n\t\toff++\n\t}\n\tbp.Seek(off, 0)\n\tvar buf [SAR_HDR]byte\n\tif n, err := io.ReadFull(bp, buf[:]); err != nil {\n\t\tif n == 0 && err != io.EOF {\n\t\t\treturn -1\n\t\t}\n\t\treturn 0\n\t}\n\n\ta.name = artrim(buf[0:16])\n\ta.date = artrim(buf[16:28])\n\ta.uid = artrim(buf[28:34])\n\ta.gid = artrim(buf[34:40])\n\ta.mode = artrim(buf[40:48])\n\ta.size = artrim(buf[48:58])\n\ta.fmag = artrim(buf[58:60])\n\n\tarsize := atolwhex(a.size)\n\tif arsize&1 != 0 {\n\t\tarsize++\n\t}\n\treturn arsize + SAR_HDR\n}\n\nfunc genhash(ctxt *Link, lib *Library) {\n\tf, err := bio.Open(lib.File)\n\tif err != nil {\n\t\tErrorf(nil, \"cannot open file %s for hash generation: %v\", lib.File, err)\n\t\treturn\n\t}\n\tdefer f.Close()\n\n\tvar arhdr ArHdr\n\tl := nextar(f, int64(len(ARMAG)), &arhdr)\n\tif l <= 0 {\n\t\tErrorf(nil, \"%s: short read on archive file symbol header\", lib.File)\n\t\treturn\n\t}\n\n\th := sha1.New()\n\tif _, err := io.CopyN(h, f, atolwhex(arhdr.size)); err != nil {\n\t\tErrorf(nil, \"bad read of %s for hash generation: %v\", lib.File, err)\n\t\treturn\n\t}\n\tlib.hash = hex.EncodeToString(h.Sum(nil))\n}\n\nfunc objfile(ctxt *Link, lib *Library) {\n\tpkg := pathtoprefix(lib.Pkg)\n\n\tif ctxt.Debugvlog > 1 {\n\t\tctxt.Logf(\"%5.2f ldobj: %s (%s)\\n\", obj.Cputime(), lib.File, pkg)\n\t}\n\tf, err := bio.Open(lib.File)\n\tif err != nil {\n\t\tExitf(\"cannot open file %s: %v\", lib.File, err)\n\t}\n\n\tfor i := 0; i < len(ARMAG); i++ {\n\t\tif c, err := f.ReadByte(); err == nil && c == ARMAG[i] {\n\t\t\tcontinue\n\t\t}\n\n\t\t/* load it as a regular file */\n\t\tl := f.Seek(0, 2)\n\n\t\tf.Seek(0, 0)\n\t\tldobj(ctxt, f, lib, l, lib.File, lib.File, FileObj)\n\t\tf.Close()\n\n\t\treturn\n\t}\n\n\t/* process __.PKGDEF */\n\toff := f.Offset()\n\n\tvar arhdr ArHdr\n\tl := nextar(f, off, &arhdr)\n\tvar pname string\n\tif l <= 0 {\n\t\tErrorf(nil, \"%s: short read on archive file symbol header\", lib.File)\n\t\tgoto out\n\t}\n\n\tif !strings.HasPrefix(arhdr.name, pkgname) {\n\t\tErrorf(nil, \"%s: cannot find package header\", lib.File)\n\t\tgoto out\n\t}\n\n\toff += l\n\n\tldpkg(ctxt, f, pkg, atolwhex(arhdr.size), lib.File, Pkgdef)\n\n\t/*\n\t * load all the object files from the archive now.\n\t * this gives us sequential file access and keeps us\n\t * from needing to come back later to pick up more\n\t * objects.  it breaks the usual C archive model, but\n\t * this is Go, not C.  the common case in Go is that\n\t * we need to load all the objects, and then we throw away\n\t * the individual symbols that are unused.\n\t *\n\t * loading every object will also make it possible to\n\t * load foreign objects not referenced by __.PKGDEF.\n\t */\n\tfor {\n\t\tl = nextar(f, off, &arhdr)\n\t\tif l == 0 {\n\t\t\tbreak\n\t\t}\n\t\tif l < 0 {\n\t\t\tExitf(\"%s: malformed archive\", lib.File)\n\t\t}\n\n\t\toff += l\n\n\t\tpname = fmt.Sprintf(\"%s(%s)\", lib.File, arhdr.name)\n\t\tl = atolwhex(arhdr.size)\n\t\tldobj(ctxt, f, lib, l, pname, lib.File, ArchiveObj)\n\t}\n\nout:\n\tf.Close()\n}\n\ntype Hostobj struct {\n\tld     func(*Link, *bio.Reader, string, int64, string)\n\tpkg    string\n\tpn     string\n\tfile   string\n\toff    int64\n\tlength int64\n}\n\nvar hostobj []Hostobj\n\n// These packages can use internal linking mode.\n// Others trigger external mode.\nvar internalpkg = []string{\n\t\"crypto/x509\",\n\t\"net\",\n\t\"os/user\",\n\t\"runtime/cgo\",\n\t\"runtime/race\",\n\t\"runtime/msan\",\n}\n\nfunc ldhostobj(ld func(*Link, *bio.Reader, string, int64, string), f *bio.Reader, pkg string, length int64, pn string, file string) *Hostobj {\n\tisinternal := false\n\tfor i := 0; i < len(internalpkg); i++ {\n\t\tif pkg == internalpkg[i] {\n\t\t\tisinternal = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// DragonFly declares errno with __thread, which results in a symbol\n\t// type of R_386_TLS_GD or R_X86_64_TLSGD. The Go linker does not\n\t// currently know how to handle TLS relocations, hence we have to\n\t// force external linking for any libraries that link in code that\n\t// uses errno. This can be removed if the Go linker ever supports\n\t// these relocation types.\n\tif Headtype == obj.Hdragonfly {\n\t\tif pkg == \"net\" || pkg == \"os/user\" {\n\t\t\tisinternal = false\n\t\t}\n\t}\n\n\tif !isinternal {\n\t\texternalobj = true\n\t}\n\n\thostobj = append(hostobj, Hostobj{})\n\th := &hostobj[len(hostobj)-1]\n\th.ld = ld\n\th.pkg = pkg\n\th.pn = pn\n\th.file = file\n\th.off = f.Offset()\n\th.length = length\n\treturn h\n}\n\nfunc hostobjs(ctxt *Link) {\n\tvar h *Hostobj\n\n\tfor i := 0; i < len(hostobj); i++ {\n\t\th = &hostobj[i]\n\t\tf, err := bio.Open(h.file)\n\t\tif err != nil {\n\t\t\tExitf(\"cannot reopen %s: %v\", h.pn, err)\n\t\t}\n\n\t\tf.Seek(h.off, 0)\n\t\th.ld(ctxt, f, h.pkg, h.length, h.pn)\n\t\tf.Close()\n\t}\n}\n\n// provided by lib9\n\nfunc rmtemp() {\n\tos.RemoveAll(*flagTmpdir)\n}\n\nfunc hostlinksetup() {\n\tif Linkmode != LinkExternal {\n\t\treturn\n\t}\n\n\t// For external link, record that we need to tell the external linker -s,\n\t// and turn off -s internally: the external linker needs the symbol\n\t// information for its final link.\n\tdebug_s = *FlagS\n\t*FlagS = false\n\n\t// create temporary directory and arrange cleanup\n\tif *flagTmpdir == \"\" {\n\t\tdir, err := ioutil.TempDir(\"\", \"go-link-\")\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\t*flagTmpdir = dir\n\t\tAtExit(rmtemp)\n\t}\n\n\t// change our output to temporary object file\n\tcoutbuf.f.Close()\n\tmayberemoveoutfile()\n\n\tp := filepath.Join(*flagTmpdir, \"go.o\")\n\tvar err error\n\tf, err := os.OpenFile(p, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0775)\n\tif err != nil {\n\t\tExitf(\"cannot create %s: %v\", p, err)\n\t}\n\n\tcoutbuf.w = bufio.NewWriter(f)\n\tcoutbuf.f = f\n}\n\n// hostobjCopy creates a copy of the object files in hostobj in a\n// temporary directory.\nfunc hostobjCopy() (paths []string) {\n\tvar wg sync.WaitGroup\n\tsema := make(chan struct{}, runtime.NumCPU()) // limit open file descriptors\n\tfor i, h := range hostobj {\n\t\th := h\n\t\tdst := filepath.Join(*flagTmpdir, fmt.Sprintf(\"%06d.o\", i))\n\t\tpaths = append(paths, dst)\n\n\t\twg.Add(1)\n\t\tgo func() {\n\t\t\tsema <- struct{}{}\n\t\t\tdefer func() {\n\t\t\t\t<-sema\n\t\t\t\twg.Done()\n\t\t\t}()\n\t\t\tf, err := os.Open(h.file)\n\t\t\tif err != nil {\n\t\t\t\tExitf(\"cannot reopen %s: %v\", h.pn, err)\n\t\t\t}\n\t\t\tif _, err := f.Seek(h.off, 0); err != nil {\n\t\t\t\tExitf(\"cannot seek %s: %v\", h.pn, err)\n\t\t\t}\n\n\t\t\tw, err := os.Create(dst)\n\t\t\tif err != nil {\n\t\t\t\tExitf(\"cannot create %s: %v\", dst, err)\n\t\t\t}\n\t\t\tif _, err := io.CopyN(w, f, h.length); err != nil {\n\t\t\t\tExitf(\"cannot write %s: %v\", dst, err)\n\t\t\t}\n\t\t\tif err := w.Close(); err != nil {\n\t\t\t\tExitf(\"cannot close %s: %v\", dst, err)\n\t\t\t}\n\t\t}()\n\t}\n\twg.Wait()\n\treturn paths\n}\n\n// archive builds a .a archive from the hostobj object files.\nfunc (ctxt *Link) archive() {\n\tif Buildmode != BuildmodeCArchive {\n\t\treturn\n\t}\n\n\tif *flagExtar == \"\" {\n\t\t*flagExtar = \"ar\"\n\t}\n\n\tmayberemoveoutfile()\n\n\t// Force the buffer to flush here so that external\n\t// tools will see a complete file.\n\tCflush()\n\tif err := coutbuf.f.Close(); err != nil {\n\t\tExitf(\"close: %v\", err)\n\t}\n\tcoutbuf.f = nil\n\n\targv := []string{*flagExtar, \"-q\", \"-c\", \"-s\", *flagOutfile}\n\targv = append(argv, filepath.Join(*flagTmpdir, \"go.o\"))\n\targv = append(argv, hostobjCopy()...)\n\n\tif ctxt.Debugvlog != 0 {\n\t\tctxt.Logf(\"archive: %s\\n\", strings.Join(argv, \" \"))\n\t}\n\n\tif out, err := exec.Command(argv[0], argv[1:]...).CombinedOutput(); err != nil {\n\t\tExitf(\"running %s failed: %v\\n%s\", argv[0], err, out)\n\t}\n}\n\nfunc (l *Link) hostlink() {\n\tif Linkmode != LinkExternal || nerrors > 0 {\n\t\treturn\n\t}\n\tif Buildmode == BuildmodeCArchive {\n\t\treturn\n\t}\n\n\tif *flagExtld == \"\" {\n\t\t*flagExtld = \"gcc\"\n\t}\n\n\tvar argv []string\n\targv = append(argv, *flagExtld)\n\targv = append(argv, hostlinkArchArgs()...)\n\n\tif !*FlagS && !debug_s {\n\t\targv = append(argv, \"-gdwarf-2\")\n\t} else if Headtype == obj.Hdarwin {\n\t\t// Recent versions of macOS print\n\t\t//\tld: warning: option -s is obsolete and being ignored\n\t\t// so do not pass any arguments.\n\t} else {\n\t\targv = append(argv, \"-s\")\n\t}\n\n\tswitch Headtype {\n\tcase obj.Hdarwin:\n\t\targv = append(argv, \"-Wl,-headerpad,1144\")\n\t\tif l.DynlinkingGo() {\n\t\t\targv = append(argv, \"-Wl,-flat_namespace\")\n\t\t} else {\n\t\t\targv = append(argv, \"-Wl,-no_pie\")\n\t\t}\n\tcase obj.Hopenbsd:\n\t\targv = append(argv, \"-Wl,-nopie\")\n\tcase obj.Hwindows:\n\t\targv = append(argv, \"-mconsole\")\n\tcase obj.Hwindowsgui:\n\t\targv = append(argv, \"-mwindows\")\n\t}\n\n\tswitch Buildmode {\n\tcase BuildmodeExe:\n\t\tif Headtype == obj.Hdarwin {\n\t\t\targv = append(argv, \"-Wl,-pagezero_size,4000000\")\n\t\t}\n\tcase BuildmodePIE:\n\t\tif UseRelro() {\n\t\t\targv = append(argv, \"-Wl,-z,relro\")\n\t\t}\n\t\targv = append(argv, \"-pie\")\n\tcase BuildmodeCShared:\n\t\tif Headtype == obj.Hdarwin {\n\t\t\targv = append(argv, \"-dynamiclib\", \"-Wl,-read_only_relocs,suppress\")\n\t\t} else {\n\t\t\t// ELF.\n\t\t\targv = append(argv, \"-Wl,-Bsymbolic\")\n\t\t\tif UseRelro() {\n\t\t\t\targv = append(argv, \"-Wl,-z,relro\")\n\t\t\t}\n\t\t\t// Pass -z nodelete to mark the shared library as\n\t\t\t// non-closeable: a dlclose will do nothing.\n\t\t\targv = append(argv, \"-shared\", \"-Wl,-z,nodelete\")\n\t\t}\n\tcase BuildmodeShared:\n\t\tif UseRelro() {\n\t\t\targv = append(argv, \"-Wl,-z,relro\")\n\t\t}\n\t\targv = append(argv, \"-shared\")\n\tcase BuildmodePlugin:\n\t\tif Headtype == obj.Hdarwin {\n\t\t\targv = append(argv, \"-dynamiclib\")\n\t\t} else {\n\t\t\tif UseRelro() {\n\t\t\t\targv = append(argv, \"-Wl,-z,relro\")\n\t\t\t}\n\t\t\targv = append(argv, \"-shared\")\n\t\t}\n\t}\n\n\tif Iself && l.DynlinkingGo() {\n\t\t// We force all symbol resolution to be done at program startup\n\t\t// because lazy PLT resolution can use large amounts of stack at\n\t\t// times we cannot allow it to do so.\n\t\targv = append(argv, \"-Wl,-znow\")\n\n\t\t// Do not let the host linker generate COPY relocations. These\n\t\t// can move symbols out of sections that rely on stable offsets\n\t\t// from the beginning of the section (like STYPE).\n\t\targv = append(argv, \"-Wl,-znocopyreloc\")\n\n\t\tif SysArch.InFamily(sys.ARM, sys.ARM64) {\n\t\t\t// On ARM, the GNU linker will generate COPY relocations\n\t\t\t// even with -znocopyreloc set.\n\t\t\t// https://sourceware.org/bugzilla/show_bug.cgi?id=19962\n\t\t\t//\n\t\t\t// On ARM64, the GNU linker will fail instead of\n\t\t\t// generating COPY relocations.\n\t\t\t//\n\t\t\t// In both cases, switch to gold.\n\t\t\targv = append(argv, \"-fuse-ld=gold\")\n\n\t\t\t// If gold is not installed, gcc will silently switch\n\t\t\t// back to ld.bfd. So we parse the version information\n\t\t\t// and provide a useful error if gold is missing.\n\t\t\tcmd := exec.Command(*flagExtld, \"-fuse-ld=gold\", \"-Wl,--version\")\n\t\t\tif out, err := cmd.CombinedOutput(); err == nil {\n\t\t\t\tif !bytes.Contains(out, []byte(\"GNU gold\")) {\n\t\t\t\t\tlog.Fatalf(\"ARM external linker must be gold (issue #15696), but is not: %s\", out)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif Iself && len(buildinfo) > 0 {\n\t\targv = append(argv, fmt.Sprintf(\"-Wl,--build-id=0x%x\", buildinfo))\n\t}\n\n\t// On Windows, given -o foo, GCC will append \".exe\" to produce\n\t// \"foo.exe\".  We have decided that we want to honor the -o\n\t// option. To make this work, we append a '.' so that GCC\n\t// will decide that the file already has an extension. We\n\t// only want to do this when producing a Windows output file\n\t// on a Windows host.\n\toutopt := *flagOutfile\n\tif obj.GOOS == \"windows\" && runtime.GOOS == \"windows\" && filepath.Ext(outopt) == \"\" {\n\t\toutopt += \".\"\n\t}\n\targv = append(argv, \"-o\")\n\targv = append(argv, outopt)\n\n\tif rpath.val != \"\" {\n\t\targv = append(argv, fmt.Sprintf(\"-Wl,-rpath,%s\", rpath.val))\n\t}\n\n\t// Force global symbols to be exported for dlopen, etc.\n\tif Iself {\n\t\targv = append(argv, \"-rdynamic\")\n\t}\n\n\tif strings.Contains(argv[0], \"clang\") {\n\t\targv = append(argv, \"-Qunused-arguments\")\n\t}\n\n\targv = append(argv, filepath.Join(*flagTmpdir, \"go.o\"))\n\targv = append(argv, hostobjCopy()...)\n\n\tif *FlagLinkshared {\n\t\tseenDirs := make(map[string]bool)\n\t\tseenLibs := make(map[string]bool)\n\t\taddshlib := func(path string) {\n\t\t\tdir, base := filepath.Split(path)\n\t\t\tif !seenDirs[dir] {\n\t\t\t\targv = append(argv, \"-L\"+dir)\n\t\t\t\tif !rpath.set {\n\t\t\t\t\targv = append(argv, \"-Wl,-rpath=\"+dir)\n\t\t\t\t}\n\t\t\t\tseenDirs[dir] = true\n\t\t\t}\n\t\t\tbase = strings.TrimSuffix(base, \".so\")\n\t\t\tbase = strings.TrimPrefix(base, \"lib\")\n\t\t\tif !seenLibs[base] {\n\t\t\t\targv = append(argv, \"-l\"+base)\n\t\t\t\tseenLibs[base] = true\n\t\t\t}\n\t\t}\n\t\tfor _, shlib := range l.Shlibs {\n\t\t\taddshlib(shlib.Path)\n\t\t\tfor _, dep := range shlib.Deps {\n\t\t\t\tif dep == \"\" {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tlibpath := findshlib(l, dep)\n\t\t\t\tif libpath != \"\" {\n\t\t\t\t\taddshlib(libpath)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\targv = append(argv, ldflag...)\n\n\t// When building a program with the default -buildmode=exe the\n\t// gc compiler generates code requires DT_TEXTREL in a\n\t// position independent executable (PIE). On systems where the\n\t// toolchain creates PIEs by default, and where DT_TEXTREL\n\t// does not work, the resulting programs will not run. See\n\t// issue #17847. To avoid this problem pass -no-pie to the\n\t// toolchain if it is supported.\n\tif Buildmode == BuildmodeExe {\n\t\tsrc := filepath.Join(*flagTmpdir, \"trivial.c\")\n\t\tif err := ioutil.WriteFile(src, []byte{}, 0666); err != nil {\n\t\t\tErrorf(nil, \"WriteFile trivial.c failed: %v\", err)\n\t\t}\n\t\tcmd := exec.Command(argv[0], \"-c\", \"-no-pie\", \"trivial.c\")\n\t\tcmd.Dir = *flagTmpdir\n\t\tcmd.Env = append([]string{\"LC_ALL=C\"}, os.Environ()...)\n\t\tout, err := cmd.CombinedOutput()\n\t\tsupported := err == nil && !bytes.Contains(out, []byte(\"unrecognized\"))\n\t\tif supported {\n\t\t\targv = append(argv, \"-no-pie\")\n\t\t}\n\t}\n\n\tfor _, p := range strings.Fields(*flagExtldflags) {\n\t\targv = append(argv, p)\n\n\t\t// clang, unlike GCC, passes -rdynamic to the linker\n\t\t// even when linking with -static, causing a linker\n\t\t// error when using GNU ld. So take out -rdynamic if\n\t\t// we added it. We do it in this order, rather than\n\t\t// only adding -rdynamic later, so that -*extldflags\n\t\t// can override -rdynamic without using -static.\n\t\tif Iself && p == \"-static\" {\n\t\t\tfor i := range argv {\n\t\t\t\tif argv[i] == \"-rdynamic\" {\n\t\t\t\t\targv[i] = \"-static\"\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif Headtype == obj.Hwindows || Headtype == obj.Hwindowsgui {\n\t\t// libmingw32 and libmingwex have some inter-dependencies,\n\t\t// so must use linker groups.\n\t\targv = append(argv, \"-Wl,--start-group\", \"-lmingwex\", \"-lmingw32\", \"-Wl,--end-group\")\n\t\targv = append(argv, peimporteddlls()...)\n\t}\n\n\tif l.Debugvlog != 0 {\n\t\tl.Logf(\"%5.2f host link:\", obj.Cputime())\n\t\tfor _, v := range argv {\n\t\t\tl.Logf(\" %q\", v)\n\t\t}\n\t\tl.Logf(\"\\n\")\n\t}\n\n\tif out, err := exec.Command(argv[0], argv[1:]...).CombinedOutput(); err != nil {\n\t\tExitf(\"running %s failed: %v\\n%s\", argv[0], err, out)\n\t} else if l.Debugvlog != 0 && len(out) > 0 {\n\t\tl.Logf(\"%s\", out)\n\t}\n\n\tif !*FlagS && !*FlagW && !debug_s && Headtype == obj.Hdarwin {\n\t\t// Skip combining dwarf on arm.\n\t\tif !SysArch.InFamily(sys.ARM, sys.ARM64) {\n\t\t\tdsym := filepath.Join(*flagTmpdir, \"go.dwarf\")\n\t\t\tif out, err := exec.Command(\"dsymutil\", \"-f\", *flagOutfile, \"-o\", dsym).CombinedOutput(); err != nil {\n\t\t\t\tExitf(\"%s: running dsymutil failed: %v\\n%s\", os.Args[0], err, out)\n\t\t\t}\n\t\t\t// Skip combining if `dsymutil` didn't generate a file. See #11994.\n\t\t\tif _, err := os.Stat(dsym); os.IsNotExist(err) {\n\t\t\t\treturn\n\t\t\t}\n\t\t\t// For os.Rename to work reliably, must be in same directory as outfile.\n\t\t\tcombinedOutput := *flagOutfile + \"~\"\n\t\t\tif err := machoCombineDwarf(*flagOutfile, dsym, combinedOutput); err != nil {\n\t\t\t\tExitf(\"%s: combining dwarf failed: %v\", os.Args[0], err)\n\t\t\t}\n\t\t\tos.Remove(*flagOutfile)\n\t\t\tif err := os.Rename(combinedOutput, *flagOutfile); err != nil {\n\t\t\t\tExitf(\"%s: %v\", os.Args[0], err)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// hostlinkArchArgs returns arguments to pass to the external linker\n// based on the architecture.\nfunc hostlinkArchArgs() []string {\n\tswitch SysArch.Family {\n\tcase sys.I386:\n\t\treturn []string{\"-m32\"}\n\tcase sys.AMD64, sys.PPC64, sys.S390X:\n\t\treturn []string{\"-m64\"}\n\tcase sys.ARM:\n\t\treturn []string{\"-marm\"}\n\tcase sys.ARM64:\n\t\t// nothing needed\n\tcase sys.MIPS64:\n\t\treturn []string{\"-mabi=64\"}\n\tcase sys.MIPS:\n\t\treturn []string{\"-mabi=32\"}\n\t}\n\treturn nil\n}\n\n// ldobj loads an input object. If it is a host object (an object\n// compiled by a non-Go compiler) it returns the Hostobj pointer. If\n// it is a Go object, it returns nil.\nfunc ldobj(ctxt *Link, f *bio.Reader, lib *Library, length int64, pn string, file string, whence int) *Hostobj {\n\tpkg := pathtoprefix(lib.Pkg)\n\n\teof := f.Offset() + length\n\tstart := f.Offset()\n\tc1 := bgetc(f)\n\tc2 := bgetc(f)\n\tc3 := bgetc(f)\n\tc4 := bgetc(f)\n\tf.Seek(start, 0)\n\n\tmagic := uint32(c1)<<24 | uint32(c2)<<16 | uint32(c3)<<8 | uint32(c4)\n\tif magic == 0x7f454c46 { // \\x7F E L F\n\t\treturn ldhostobj(ldelf, f, pkg, length, pn, file)\n\t}\n\n\tif magic&^1 == 0xfeedface || magic&^0x01000000 == 0xcefaedfe {\n\t\treturn ldhostobj(ldmacho, f, pkg, length, pn, file)\n\t}\n\n\tif c1 == 0x4c && c2 == 0x01 || c1 == 0x64 && c2 == 0x86 {\n\t\treturn ldhostobj(ldpe, f, pkg, length, pn, file)\n\t}\n\n\t/* check the header */\n\tline, err := f.ReadString('\\n')\n\tif err != nil {\n\t\tErrorf(nil, \"truncated object file: %s: %v\", pn, err)\n\t\treturn nil\n\t}\n\n\tif !strings.HasPrefix(line, \"go object \") {\n\t\tif strings.HasSuffix(pn, \".go\") {\n\t\t\tExitf(\"%s: uncompiled .go source file\", pn)\n\t\t\treturn nil\n\t\t}\n\n\t\tif line == SysArch.Name {\n\t\t\t// old header format: just $GOOS\n\t\t\tErrorf(nil, \"%s: stale object file\", pn)\n\t\t\treturn nil\n\t\t}\n\n\t\tErrorf(nil, \"%s: not an object file\", pn)\n\t\treturn nil\n\t}\n\n\t// First, check that the basic GOOS, GOARCH, and Version match.\n\tt := fmt.Sprintf(\"%s %s %s \", obj.GOOS, obj.GOARCH, obj.Version)\n\n\tline = strings.TrimRight(line, \"\\n\")\n\tif !strings.HasPrefix(line[10:]+\" \", t) && !*flagF {\n\t\tErrorf(nil, \"%s: object is [%s] expected [%s]\", pn, line[10:], t)\n\t\treturn nil\n\t}\n\n\t// Second, check that longer lines match each other exactly,\n\t// so that the Go compiler and write additional information\n\t// that must be the same from run to run.\n\tif len(line) >= len(t)+10 {\n\t\tif theline == \"\" {\n\t\t\ttheline = line[10:]\n\t\t} else if theline != line[10:] {\n\t\t\tErrorf(nil, \"%s: object is [%s] expected [%s]\", pn, line[10:], theline)\n\t\t\treturn nil\n\t\t}\n\t}\n\n\t/* skip over exports and other info -- ends with \\n!\\n */\n\timport0 := f.Offset()\n\n\tc1 = '\\n' // the last line ended in \\n\n\tc2 = bgetc(f)\n\tc3 = bgetc(f)\n\tfor c1 != '\\n' || c2 != '!' || c3 != '\\n' {\n\t\tc1 = c2\n\t\tc2 = c3\n\t\tc3 = bgetc(f)\n\t\tif c3 == -1 {\n\t\t\tErrorf(nil, \"truncated object file: %s\", pn)\n\t\t\treturn nil\n\t\t}\n\t}\n\n\timport1 := f.Offset()\n\n\tf.Seek(import0, 0)\n\tldpkg(ctxt, f, pkg, import1-import0-2, pn, whence) // -2 for !\\n\n\tf.Seek(import1, 0)\n\n\tLoadObjFile(ctxt, f, lib, eof-f.Offset(), pn)\n\treturn nil\n}\n\nfunc readelfsymboldata(ctxt *Link, f *elf.File, sym *elf.Symbol) []byte {\n\tdata := make([]byte, sym.Size)\n\tsect := f.Sections[sym.Section]\n\tif sect.Type != elf.SHT_PROGBITS && sect.Type != elf.SHT_NOTE {\n\t\tErrorf(nil, \"reading %s from non-data section\", sym.Name)\n\t}\n\tn, err := sect.ReadAt(data, int64(sym.Value-sect.Addr))\n\tif uint64(n) != sym.Size {\n\t\tErrorf(nil, \"reading contents of %s: %v\", sym.Name, err)\n\t}\n\treturn data\n}\n\nfunc readwithpad(r io.Reader, sz int32) ([]byte, error) {\n\tdata := make([]byte, Rnd(int64(sz), 4))\n\t_, err := io.ReadFull(r, data)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdata = data[:sz]\n\treturn data, nil\n}\n\nfunc readnote(f *elf.File, name []byte, typ int32) ([]byte, error) {\n\tfor _, sect := range f.Sections {\n\t\tif sect.Type != elf.SHT_NOTE {\n\t\t\tcontinue\n\t\t}\n\t\tr := sect.Open()\n\t\tfor {\n\t\t\tvar namesize, descsize, noteType int32\n\t\t\terr := binary.Read(r, f.ByteOrder, &namesize)\n\t\t\tif err != nil {\n\t\t\t\tif err == io.EOF {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\treturn nil, fmt.Errorf(\"read namesize failed: %v\", err)\n\t\t\t}\n\t\t\terr = binary.Read(r, f.ByteOrder, &descsize)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"read descsize failed: %v\", err)\n\t\t\t}\n\t\t\terr = binary.Read(r, f.ByteOrder, &noteType)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"read type failed: %v\", err)\n\t\t\t}\n\t\t\tnoteName, err := readwithpad(r, namesize)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"read name failed: %v\", err)\n\t\t\t}\n\t\t\tdesc, err := readwithpad(r, descsize)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"read desc failed: %v\", err)\n\t\t\t}\n\t\t\tif string(name) == string(noteName) && typ == noteType {\n\t\t\t\treturn desc, nil\n\t\t\t}\n\t\t}\n\t}\n\treturn nil, nil\n}\n\nfunc findshlib(ctxt *Link, shlib string) string {\n\tfor _, libdir := range ctxt.Libdir {\n\t\tlibpath := filepath.Join(libdir, shlib)\n\t\tif _, err := os.Stat(libpath); err == nil {\n\t\t\treturn libpath\n\t\t}\n\t}\n\tErrorf(nil, \"cannot find shared library: %s\", shlib)\n\treturn \"\"\n}\n\nfunc ldshlibsyms(ctxt *Link, shlib string) {\n\tlibpath := findshlib(ctxt, shlib)\n\tif libpath == \"\" {\n\t\treturn\n\t}\n\tfor _, processedlib := range ctxt.Shlibs {\n\t\tif processedlib.Path == libpath {\n\t\t\treturn\n\t\t}\n\t}\n\tif ctxt.Debugvlog > 1 {\n\t\tctxt.Logf(\"%5.2f ldshlibsyms: found library with name %s at %s\\n\", obj.Cputime(), shlib, libpath)\n\t}\n\n\tf, err := elf.Open(libpath)\n\tif err != nil {\n\t\tErrorf(nil, \"cannot open shared library: %s\", libpath)\n\t\treturn\n\t}\n\n\thash, err := readnote(f, ELF_NOTE_GO_NAME, ELF_NOTE_GOABIHASH_TAG)\n\tif err != nil {\n\t\tErrorf(nil, \"cannot read ABI hash from shared library %s: %v\", libpath, err)\n\t\treturn\n\t}\n\n\tdepsbytes, err := readnote(f, ELF_NOTE_GO_NAME, ELF_NOTE_GODEPS_TAG)\n\tif err != nil {\n\t\tErrorf(nil, \"cannot read dep list from shared library %s: %v\", libpath, err)\n\t\treturn\n\t}\n\tdeps := strings.Split(string(depsbytes), \"\\n\")\n\n\tsyms, err := f.DynamicSymbols()\n\tif err != nil {\n\t\tErrorf(nil, \"cannot read symbols from shared library: %s\", libpath)\n\t\treturn\n\t}\n\tgcdataLocations := make(map[uint64]*Symbol)\n\tfor _, elfsym := range syms {\n\t\tif elf.ST_TYPE(elfsym.Info) == elf.STT_NOTYPE || elf.ST_TYPE(elfsym.Info) == elf.STT_SECTION {\n\t\t\tcontinue\n\t\t}\n\t\tlsym := ctxt.Syms.Lookup(elfsym.Name, 0)\n\t\t// Because loadlib above loads all .a files before loading any shared\n\t\t// libraries, any non-dynimport symbols we find that duplicate symbols\n\t\t// already loaded should be ignored (the symbols from the .a files\n\t\t// \"win\").\n\t\tif lsym.Type != 0 && lsym.Type != obj.SDYNIMPORT {\n\t\t\tcontinue\n\t\t}\n\t\tlsym.Type = obj.SDYNIMPORT\n\t\tlsym.ElfType = elf.ST_TYPE(elfsym.Info)\n\t\tlsym.Size = int64(elfsym.Size)\n\t\tif elfsym.Section != elf.SHN_UNDEF {\n\t\t\t// Set .File for the library that actually defines the symbol.\n\t\t\tlsym.File = libpath\n\t\t\t// The decodetype_* functions in decodetype.go need access to\n\t\t\t// the type data.\n\t\t\tif strings.HasPrefix(lsym.Name, \"type.\") && !strings.HasPrefix(lsym.Name, \"type..\") {\n\t\t\t\tlsym.P = readelfsymboldata(ctxt, f, &elfsym)\n\t\t\t\tgcdataLocations[elfsym.Value+2*uint64(SysArch.PtrSize)+8+1*uint64(SysArch.PtrSize)] = lsym\n\t\t\t}\n\t\t}\n\t}\n\tgcdataAddresses := make(map[*Symbol]uint64)\n\tif SysArch.Family == sys.ARM64 {\n\t\tfor _, sect := range f.Sections {\n\t\t\tif sect.Type == elf.SHT_RELA {\n\t\t\t\tvar rela elf.Rela64\n\t\t\t\trdr := sect.Open()\n\t\t\t\tfor {\n\t\t\t\t\terr := binary.Read(rdr, f.ByteOrder, &rela)\n\t\t\t\t\tif err == io.EOF {\n\t\t\t\t\t\tbreak\n\t\t\t\t\t} else if err != nil {\n\t\t\t\t\t\tErrorf(nil, \"reading relocation failed %v\", err)\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tt := elf.R_AARCH64(rela.Info & 0xffff)\n\t\t\t\t\tif t != elf.R_AARCH64_RELATIVE {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tif lsym, ok := gcdataLocations[rela.Off]; ok {\n\t\t\t\t\t\tgcdataAddresses[lsym] = uint64(rela.Addend)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tctxt.Shlibs = append(ctxt.Shlibs, Shlib{Path: libpath, Hash: hash, Deps: deps, File: f, gcdataAddresses: gcdataAddresses})\n}\n\n// Copied from ../gc/subr.c:/^pathtoprefix; must stay in sync.\n/*\n * Convert raw string to the prefix that will be used in the symbol table.\n * Invalid bytes turn into %xx.\t Right now the only bytes that need\n * escaping are %, ., and \", but we escape all control characters too.\n *\n * If you edit this, edit ../gc/subr.c:/^pathtoprefix too.\n * If you edit this, edit ../../debug/goobj/read.go:/importPathToPrefix too.\n */\nfunc pathtoprefix(s string) string {\n\tslash := strings.LastIndex(s, \"/\")\n\tfor i := 0; i < len(s); i++ {\n\t\tc := s[i]\n\t\tif c <= ' ' || i >= slash && c == '.' || c == '%' || c == '\"' || c >= 0x7F {\n\t\t\tvar buf bytes.Buffer\n\t\t\tfor i := 0; i < len(s); i++ {\n\t\t\t\tc := s[i]\n\t\t\t\tif c <= ' ' || i >= slash && c == '.' || c == '%' || c == '\"' || c >= 0x7F {\n\t\t\t\t\tfmt.Fprintf(&buf, \"%%%02x\", c)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tbuf.WriteByte(c)\n\t\t\t}\n\t\t\treturn buf.String()\n\t\t}\n\t}\n\treturn s\n}\n\nfunc addsection(seg *Segment, name string, rwx int) *Section {\n\tvar l **Section\n\n\tfor l = &seg.Sect; *l != nil; l = &(*l).Next {\n\t}\n\tsect := new(Section)\n\tsect.Rwx = uint8(rwx)\n\tsect.Name = name\n\tsect.Seg = seg\n\tsect.Align = int32(SysArch.PtrSize) // everything is at least pointer-aligned\n\t*l = sect\n\treturn sect\n}\n\nfunc Le16(b []byte) uint16 {\n\treturn uint16(b[0]) | uint16(b[1])<<8\n}\n\nfunc Le32(b []byte) uint32 {\n\treturn uint32(b[0]) | uint32(b[1])<<8 | uint32(b[2])<<16 | uint32(b[3])<<24\n}\n\nfunc Le64(b []byte) uint64 {\n\treturn uint64(Le32(b)) | uint64(Le32(b[4:]))<<32\n}\n\nfunc Be16(b []byte) uint16 {\n\treturn uint16(b[0])<<8 | uint16(b[1])\n}\n\nfunc Be32(b []byte) uint32 {\n\treturn uint32(b[0])<<24 | uint32(b[1])<<16 | uint32(b[2])<<8 | uint32(b[3])\n}\n\ntype chain struct {\n\tsym   *Symbol\n\tup    *chain\n\tlimit int // limit on entry to sym\n}\n\nvar morestack *Symbol\n\n// TODO: Record enough information in new object files to\n// allow stack checks here.\n\nfunc haslinkregister(ctxt *Link) bool {\n\treturn ctxt.FixedFrameSize() != 0\n}\n\nfunc callsize(ctxt *Link) int {\n\tif haslinkregister(ctxt) {\n\t\treturn 0\n\t}\n\treturn SysArch.RegSize\n}\n\nfunc (ctxt *Link) dostkcheck() {\n\tvar ch chain\n\n\tmorestack = ctxt.Syms.Lookup(\"runtime.morestack\", 0)\n\n\t// Every splitting function ensures that there are at least StackLimit\n\t// bytes available below SP when the splitting prologue finishes.\n\t// If the splitting function calls F, then F begins execution with\n\t// at least StackLimit - callsize() bytes available.\n\t// Check that every function behaves correctly with this amount\n\t// of stack, following direct calls in order to piece together chains\n\t// of non-splitting functions.\n\tch.up = nil\n\n\tch.limit = obj.StackLimit - callsize(ctxt)\n\n\t// Check every function, but do the nosplit functions in a first pass,\n\t// to make the printed failure chains as short as possible.\n\tfor _, s := range ctxt.Textp {\n\t\t// runtime.racesymbolizethunk is called from gcc-compiled C\n\t\t// code running on the operating system thread stack.\n\t\t// It uses more than the usual amount of stack but that's okay.\n\t\tif s.Name == \"runtime.racesymbolizethunk\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tif s.Attr.NoSplit() {\n\t\t\tch.sym = s\n\t\t\tstkcheck(ctxt, &ch, 0)\n\t\t}\n\t}\n\n\tfor _, s := range ctxt.Textp {\n\t\tif !s.Attr.NoSplit() {\n\t\t\tch.sym = s\n\t\t\tstkcheck(ctxt, &ch, 0)\n\t\t}\n\t}\n}\n\nfunc stkcheck(ctxt *Link, up *chain, depth int) int {\n\tlimit := up.limit\n\ts := up.sym\n\n\t// Don't duplicate work: only need to consider each\n\t// function at top of safe zone once.\n\ttop := limit == obj.StackLimit-callsize(ctxt)\n\tif top {\n\t\tif s.Attr.StackCheck() {\n\t\t\treturn 0\n\t\t}\n\t\ts.Attr |= AttrStackCheck\n\t}\n\n\tif depth > 100 {\n\t\tErrorf(s, \"nosplit stack check too deep\")\n\t\tstkbroke(ctxt, up, 0)\n\t\treturn -1\n\t}\n\n\tif s.Attr.External() || s.FuncInfo == nil {\n\t\t// external function.\n\t\t// should never be called directly.\n\t\t// onlyctxt.Diagnose the direct caller.\n\t\t// TODO(mwhudson): actually think about this.\n\t\tif depth == 1 && s.Type != obj.SXREF && !ctxt.DynlinkingGo() &&\n\t\t\tBuildmode != BuildmodeCArchive && Buildmode != BuildmodePIE && Buildmode != BuildmodeCShared && Buildmode != BuildmodePlugin {\n\n\t\t\tErrorf(s, \"call to external function\")\n\t\t}\n\t\treturn -1\n\t}\n\n\tif limit < 0 {\n\t\tstkbroke(ctxt, up, limit)\n\t\treturn -1\n\t}\n\n\t// morestack looks like it calls functions,\n\t// but it switches the stack pointer first.\n\tif s == morestack {\n\t\treturn 0\n\t}\n\n\tvar ch chain\n\tch.up = up\n\n\tif !s.Attr.NoSplit() {\n\t\t// Ensure we have enough stack to call morestack.\n\t\tch.limit = limit - callsize(ctxt)\n\t\tch.sym = morestack\n\t\tif stkcheck(ctxt, &ch, depth+1) < 0 {\n\t\t\treturn -1\n\t\t}\n\t\tif !top {\n\t\t\treturn 0\n\t\t}\n\t\t// Raise limit to allow frame.\n\t\tlocals := int32(0)\n\t\tif s.FuncInfo != nil {\n\t\t\tlocals = s.FuncInfo.Locals\n\t\t}\n\t\tlimit = int(obj.StackLimit+locals) + int(ctxt.FixedFrameSize())\n\t}\n\n\t// Walk through sp adjustments in function, consuming relocs.\n\tri := 0\n\n\tendr := len(s.R)\n\tvar ch1 chain\n\tvar pcsp Pciter\n\tvar r *Reloc\n\tfor pciterinit(ctxt, &pcsp, &s.FuncInfo.Pcsp); pcsp.done == 0; pciternext(&pcsp) {\n\t\t// pcsp.value is in effect for [pcsp.pc, pcsp.nextpc).\n\n\t\t// Check stack size in effect for this span.\n\t\tif int32(limit)-pcsp.value < 0 {\n\t\t\tstkbroke(ctxt, up, int(int32(limit)-pcsp.value))\n\t\t\treturn -1\n\t\t}\n\n\t\t// Process calls in this span.\n\t\tfor ; ri < endr && uint32(s.R[ri].Off) < pcsp.nextpc; ri++ {\n\t\t\tr = &s.R[ri]\n\t\t\tswitch r.Type {\n\t\t\t// Direct call.\n\t\t\tcase obj.R_CALL, obj.R_CALLARM, obj.R_CALLARM64, obj.R_CALLPOWER, obj.R_CALLMIPS:\n\t\t\t\tch.limit = int(int32(limit) - pcsp.value - int32(callsize(ctxt)))\n\t\t\t\tch.sym = r.Sym\n\t\t\t\tif stkcheck(ctxt, &ch, depth+1) < 0 {\n\t\t\t\t\treturn -1\n\t\t\t\t}\n\n\t\t\t// Indirect call. Assume it is a call to a splitting function,\n\t\t\t// so we have to make sure it can call morestack.\n\t\t\t// Arrange the data structures to report both calls, so that\n\t\t\t// if there is an error, stkprint shows all the steps involved.\n\t\t\tcase obj.R_CALLIND:\n\t\t\t\tch.limit = int(int32(limit) - pcsp.value - int32(callsize(ctxt)))\n\n\t\t\t\tch.sym = nil\n\t\t\t\tch1.limit = ch.limit - callsize(ctxt) // for morestack in called prologue\n\t\t\t\tch1.up = &ch\n\t\t\t\tch1.sym = morestack\n\t\t\t\tif stkcheck(ctxt, &ch1, depth+2) < 0 {\n\t\t\t\t\treturn -1\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0\n}\n\nfunc stkbroke(ctxt *Link, ch *chain, limit int) {\n\tErrorf(ch.sym, \"nosplit stack overflow\")\n\tstkprint(ctxt, ch, limit)\n}\n\nfunc stkprint(ctxt *Link, ch *chain, limit int) {\n\tvar name string\n\n\tif ch.sym != nil {\n\t\tname = ch.sym.Name\n\t\tif ch.sym.Attr.NoSplit() {\n\t\t\tname += \" (nosplit)\"\n\t\t}\n\t} else {\n\t\tname = \"function pointer\"\n\t}\n\n\tif ch.up == nil {\n\t\t// top of chain.  ch->sym != nil.\n\t\tif ch.sym.Attr.NoSplit() {\n\t\t\tfmt.Printf(\"\\t%d\\tassumed on entry to %s\\n\", ch.limit, name)\n\t\t} else {\n\t\t\tfmt.Printf(\"\\t%d\\tguaranteed after split check in %s\\n\", ch.limit, name)\n\t\t}\n\t} else {\n\t\tstkprint(ctxt, ch.up, ch.limit+callsize(ctxt))\n\t\tif !haslinkregister(ctxt) {\n\t\t\tfmt.Printf(\"\\t%d\\ton entry to %s\\n\", ch.limit, name)\n\t\t}\n\t}\n\n\tif ch.limit != limit {\n\t\tfmt.Printf(\"\\t%d\\tafter %s uses %d\\n\", limit, name, ch.limit-limit)\n\t}\n}\n\nfunc Cflush() {\n\tif err := coutbuf.w.Flush(); err != nil {\n\t\tExitf(\"flushing %s: %v\", coutbuf.f.Name(), err)\n\t}\n}\n\nfunc Cseek(p int64) {\n\tif p == coutbuf.off {\n\t\treturn\n\t}\n\tCflush()\n\tif _, err := coutbuf.f.Seek(p, 0); err != nil {\n\t\tExitf(\"seeking in output [0, 1]: %v\", err)\n\t}\n\tcoutbuf.off = p\n}\n\nfunc Cwritestring(s string) {\n\tcoutbuf.WriteString(s)\n}\n\nfunc Cwrite(p []byte) {\n\tcoutbuf.Write(p)\n}\n\nfunc Cput(c uint8) {\n\tcoutbuf.w.WriteByte(c)\n\tcoutbuf.off++\n}\n\nfunc usage() {\n\tfmt.Fprintf(os.Stderr, \"usage: link [options] main.o\\n\")\n\tobj.Flagprint(2)\n\tExit(2)\n}\n\nfunc doversion() {\n\tExitf(\"version %s\", obj.Version)\n}\n\ntype SymbolType int8\n\nconst (\n\tTextSym      SymbolType = 'T'\n\tDataSym                 = 'D'\n\tBSSSym                  = 'B'\n\tUndefinedSym            = 'U'\n\tTLSSym                  = 't'\n\tFileSym                 = 'f'\n\tFrameSym                = 'm'\n\tParamSym                = 'p'\n\tAutoSym                 = 'a'\n)\n\nfunc genasmsym(ctxt *Link, put func(*Link, *Symbol, string, SymbolType, int64, *Symbol)) {\n\t// These symbols won't show up in the first loop below because we\n\t// skip STEXT symbols. Normal STEXT symbols are emitted by walking textp.\n\ts := ctxt.Syms.Lookup(\"runtime.text\", 0)\n\tif s.Type == obj.STEXT {\n\t\tput(ctxt, s, s.Name, TextSym, s.Value, nil)\n\t}\n\n\tn := 0\n\n\t// Generate base addresses for all text sections if there are multiple\n\tfor sect := Segtext.Sect; sect != nil; sect = sect.Next {\n\t\tif n == 0 {\n\t\t\tn++\n\t\t\tcontinue\n\t\t}\n\t\tif sect.Name != \".text\" {\n\t\t\tbreak\n\t\t}\n\t\ts = ctxt.Syms.ROLookup(fmt.Sprintf(\"runtime.text.%d\", n), 0)\n\t\tif s == nil {\n\t\t\tbreak\n\t\t}\n\t\tif s.Type == obj.STEXT {\n\t\t\tput(ctxt, s, s.Name, TextSym, s.Value, nil)\n\t\t}\n\t\tn++\n\t}\n\n\ts = ctxt.Syms.Lookup(\"runtime.etext\", 0)\n\tif s.Type == obj.STEXT {\n\t\tput(ctxt, s, s.Name, TextSym, s.Value, nil)\n\t}\n\n\tfor _, s := range ctxt.Syms.Allsym {\n\t\tif s.Attr.Hidden() {\n\t\t\tcontinue\n\t\t}\n\t\tif (s.Name == \"\" || s.Name[0] == '.') && s.Version == 0 && s.Name != \".rathole\" && s.Name != \".TOC.\" {\n\t\t\tcontinue\n\t\t}\n\t\tswitch s.Type & obj.SMASK {\n\t\tcase obj.SCONST,\n\t\t\tobj.SRODATA,\n\t\t\tobj.SSYMTAB,\n\t\t\tobj.SPCLNTAB,\n\t\t\tobj.SINITARR,\n\t\t\tobj.SDATA,\n\t\t\tobj.SNOPTRDATA,\n\t\t\tobj.SELFROSECT,\n\t\t\tobj.SMACHOGOT,\n\t\t\tobj.STYPE,\n\t\t\tobj.SSTRING,\n\t\t\tobj.SGOSTRING,\n\t\t\tobj.SGOFUNC,\n\t\t\tobj.SGCBITS,\n\t\t\tobj.STYPERELRO,\n\t\t\tobj.SSTRINGRELRO,\n\t\t\tobj.SGOSTRINGRELRO,\n\t\t\tobj.SGOFUNCRELRO,\n\t\t\tobj.SGCBITSRELRO,\n\t\t\tobj.SRODATARELRO,\n\t\t\tobj.STYPELINK,\n\t\t\tobj.SITABLINK,\n\t\t\tobj.SWINDOWS:\n\t\t\tif !s.Attr.Reachable() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tput(ctxt, s, s.Name, DataSym, Symaddr(s), s.Gotype)\n\n\t\tcase obj.SBSS, obj.SNOPTRBSS:\n\t\t\tif !s.Attr.Reachable() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif len(s.P) > 0 {\n\t\t\t\tErrorf(s, \"should not be bss (size=%d type=%d special=%v)\", len(s.P), s.Type, s.Attr.Special())\n\t\t\t}\n\t\t\tput(ctxt, s, s.Name, BSSSym, Symaddr(s), s.Gotype)\n\n\t\tcase obj.SFILE:\n\t\t\tput(ctxt, nil, s.Name, FileSym, s.Value, nil)\n\n\t\tcase obj.SHOSTOBJ:\n\t\t\tif Headtype == obj.Hwindows || Headtype == obj.Hwindowsgui || Iself {\n\t\t\t\tput(ctxt, s, s.Name, UndefinedSym, s.Value, nil)\n\t\t\t}\n\n\t\tcase obj.SDYNIMPORT:\n\t\t\tif !s.Attr.Reachable() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tput(ctxt, s, s.Extname, UndefinedSym, 0, nil)\n\n\t\tcase obj.STLSBSS:\n\t\t\tif Linkmode == LinkExternal && Headtype != obj.Hopenbsd {\n\t\t\t\tput(ctxt, s, s.Name, TLSSym, Symaddr(s), s.Gotype)\n\t\t\t}\n\t\t}\n\t}\n\n\tvar off int32\n\tfor _, s := range ctxt.Textp {\n\t\tput(ctxt, s, s.Name, TextSym, s.Value, s.Gotype)\n\n\t\tlocals := int32(0)\n\t\tif s.FuncInfo != nil {\n\t\t\tlocals = s.FuncInfo.Locals\n\t\t}\n\t\t// NOTE(ality): acid can't produce a stack trace without .frame symbols\n\t\tput(ctxt, nil, \".frame\", FrameSym, int64(locals)+int64(SysArch.PtrSize), nil)\n\n\t\tif s.FuncInfo == nil {\n\t\t\tcontinue\n\t\t}\n\t\tfor _, a := range s.FuncInfo.Autom {\n\t\t\t// Emit a or p according to actual offset, even if label is wrong.\n\t\t\t// This avoids negative offsets, which cannot be encoded.\n\t\t\tif a.Name != obj.A_AUTO && a.Name != obj.A_PARAM {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// compute offset relative to FP\n\t\t\tif a.Name == obj.A_PARAM {\n\t\t\t\toff = a.Aoffset\n\t\t\t} else {\n\t\t\t\toff = a.Aoffset - int32(SysArch.PtrSize)\n\t\t\t}\n\n\t\t\t// FP\n\t\t\tif off >= 0 {\n\t\t\t\tput(ctxt, nil, a.Asym.Name, ParamSym, int64(off), a.Gotype)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\t// SP\n\t\t\tif off <= int32(-SysArch.PtrSize) {\n\t\t\t\tput(ctxt, nil, a.Asym.Name, AutoSym, -(int64(off) + int64(SysArch.PtrSize)), a.Gotype)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// Otherwise, off is addressing the saved program counter.\n\t\t\t// Something underhanded is going on. Say nothing.\n\t\t}\n\t}\n\n\tif ctxt.Debugvlog != 0 || *flagN {\n\t\tctxt.Logf(\"%5.2f symsize = %d\\n\", obj.Cputime(), uint32(Symsize))\n\t}\n}\n\nfunc Symaddr(s *Symbol) int64 {\n\tif !s.Attr.Reachable() {\n\t\tErrorf(s, \"unreachable symbol in symaddr\")\n\t}\n\treturn s.Value\n}\n\nfunc (ctxt *Link) xdefine(p string, t obj.SymKind, v int64) {\n\ts := ctxt.Syms.Lookup(p, 0)\n\ts.Type = t\n\ts.Value = v\n\ts.Attr |= AttrReachable\n\ts.Attr |= AttrSpecial\n\ts.Attr |= AttrLocal\n}\n\nfunc datoff(s *Symbol, addr int64) int64 {\n\tif uint64(addr) >= Segdata.Vaddr {\n\t\treturn int64(uint64(addr) - Segdata.Vaddr + Segdata.Fileoff)\n\t}\n\tif uint64(addr) >= Segtext.Vaddr {\n\t\treturn int64(uint64(addr) - Segtext.Vaddr + Segtext.Fileoff)\n\t}\n\tErrorf(s, \"invalid datoff %#x\", addr)\n\treturn 0\n}\n\nfunc Entryvalue(ctxt *Link) int64 {\n\ta := *flagEntrySymbol\n\tif a[0] >= '0' && a[0] <= '9' {\n\t\treturn atolwhex(a)\n\t}\n\ts := ctxt.Syms.Lookup(a, 0)\n\tif s.Type == 0 {\n\t\treturn *FlagTextAddr\n\t}\n\tif s.Type != obj.STEXT {\n\t\tErrorf(s, \"entry not text\")\n\t}\n\treturn s.Value\n}\n\nfunc undefsym(ctxt *Link, s *Symbol) {\n\tvar r *Reloc\n\n\tfor i := 0; i < len(s.R); i++ {\n\t\tr = &s.R[i]\n\t\tif r.Sym == nil { // happens for some external ARM relocs\n\t\t\tcontinue\n\t\t}\n\t\tif r.Sym.Type == obj.Sxxx || r.Sym.Type == obj.SXREF {\n\t\t\tErrorf(s, \"undefined: %q\", r.Sym.Name)\n\t\t}\n\t\tif !r.Sym.Attr.Reachable() && r.Type != obj.R_WEAKADDROFF {\n\t\t\tErrorf(s, \"relocation target %q\", r.Sym.Name)\n\t\t}\n\t}\n}\n\nfunc (ctxt *Link) undef() {\n\tfor _, s := range ctxt.Textp {\n\t\tundefsym(ctxt, s)\n\t}\n\tfor _, s := range datap {\n\t\tundefsym(ctxt, s)\n\t}\n\tif nerrors > 0 {\n\t\terrorexit()\n\t}\n}\n\nfunc (ctxt *Link) callgraph() {\n\tif !*FlagC {\n\t\treturn\n\t}\n\n\tvar i int\n\tvar r *Reloc\n\tfor _, s := range ctxt.Textp {\n\t\tfor i = 0; i < len(s.R); i++ {\n\t\t\tr = &s.R[i]\n\t\t\tif r.Sym == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif (r.Type == obj.R_CALL || r.Type == obj.R_CALLARM || r.Type == obj.R_CALLPOWER || r.Type == obj.R_CALLMIPS) && r.Sym.Type == obj.STEXT {\n\t\t\t\tctxt.Logf(\"%s calls %s\\n\", s.Name, r.Sym.Name)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc Rnd(v int64, r int64) int64 {\n\tif r <= 0 {\n\t\treturn v\n\t}\n\tv += r - 1\n\tc := v % r\n\tif c < 0 {\n\t\tc += r\n\t}\n\tv -= c\n\treturn v\n}\n\nfunc bgetc(r *bio.Reader) int {\n\tc, err := r.ReadByte()\n\tif err != nil {\n\t\tif err != io.EOF {\n\t\t\tlog.Fatalf(\"reading input: %v\", err)\n\t\t}\n\t\treturn -1\n\t}\n\treturn int(c)\n}\n\ntype markKind uint8 // for postorder traversal\nconst (\n\tunvisited markKind = iota\n\tvisiting\n\tvisited\n)\n\nfunc postorder(libs []*Library) []*Library {\n\torder := make([]*Library, 0, len(libs)) // hold the result\n\tmark := make(map[*Library]markKind, len(libs))\n\tfor _, lib := range libs {\n\t\tdfs(lib, mark, &order)\n\t}\n\treturn order\n}\n\nfunc dfs(lib *Library, mark map[*Library]markKind, order *[]*Library) {\n\tif mark[lib] == visited {\n\t\treturn\n\t}\n\tif mark[lib] == visiting {\n\t\tpanic(\"found import cycle while visiting \" + lib.Pkg)\n\t}\n\tmark[lib] = visiting\n\tfor _, i := range lib.imports {\n\t\tdfs(i, mark, order)\n\t}\n\tmark[lib] = visited\n\t*order = append(*order, lib)\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/misc/cgo/testcshared/main5.c": "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// Test that a signal handler works in non-Go code when using\n// os/signal.Notify.\n// This is a lot like misc/cgo/testcarchive/main3.c.\n\n#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <sched.h>\n#include <dlfcn.h>\n\nstatic void die(const char* msg) {\n\tperror(msg);\n\texit(EXIT_FAILURE);\n}\n\nstatic volatile sig_atomic_t sigioSeen;\n\nstatic void ioHandler(int signo, siginfo_t* info, void* ctxt) {\n\tsigioSeen = 1;\n}\n\nint main(int argc, char** argv) {\n\tint verbose;\n\tstruct sigaction sa;\n\tvoid* handle;\n\tvoid (*fn1)(void);\n\tint (*sawSIGIO)(void);\n\tint i;\n\tstruct timespec ts;\n\n\tverbose = argc > 2;\n\tsetvbuf(stdout, NULL, _IONBF, 0);\n\n\tif (verbose) {\n\t\tprintf(\"calling sigaction\\n\");\n\t}\n\n\tmemset(&sa, 0, sizeof sa);\n\tsa.sa_sigaction = ioHandler;\n\tif (sigemptyset(&sa.sa_mask) < 0) {\n\t\tdie(\"sigemptyset\");\n\t}\n\tsa.sa_flags = SA_SIGINFO;\n\tif (sigaction(SIGIO, &sa, NULL) < 0) {\n\t\tdie(\"sigaction\");\n\t}\n\n\tif (verbose) {\n\t\tprintf(\"calling dlopen\\n\");\n\t}\n\n\thandle = dlopen(argv[1], RTLD_NOW | RTLD_GLOBAL);\n\tif (handle == NULL) {\n\t\tfprintf(stderr, \"%s\\n\", dlerror());\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t// At this point there should not be a Go signal handler\n\t// installed for SIGIO.\n\n\tif (verbose) {\n\t\tprintf(\"raising SIGIO\\n\");\n\t}\n\n\tif (raise(SIGIO) < 0) {\n\t\tdie(\"raise\");\n\t}\n\n\tif (verbose) {\n\t\tprintf(\"waiting for sigioSeen\\n\");\n\t}\n\n\t// Wait until the signal has been delivered.\n\ti = 0;\n\twhile (!sigioSeen) {\n\t\tts.tv_sec = 0;\n\t\tts.tv_nsec = 1000000;\n\t\tnanosleep(&ts, NULL);\n\t\ti++;\n\t\tif (i > 5000) {\n\t\t\tfprintf(stderr, \"looping too long waiting for signal\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\n\tsigioSeen = 0;\n\n\t// Tell the Go code to catch SIGIO.\n\n\tif (verbose) {\n\t\tprintf(\"calling dlsym\\n\");\n\t}\n\n\tfn1 = (void(*)(void))dlsym(handle, \"CatchSIGIO\");\n\tif (fn1 == NULL) {\n\t\tfprintf(stderr, \"%s\\n\", dlerror());\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (verbose) {\n\t\tprintf(\"calling CatchSIGIO\\n\");\n\t}\n\n\tfn1();\n\n\tif (verbose) {\n\t\tprintf(\"raising SIGIO\\n\");\n\t}\n\n\tif (raise(SIGIO) < 0) {\n\t\tdie(\"raise\");\n\t}\n\n\tif (verbose) {\n\t\tprintf(\"calling dlsym\\n\");\n\t}\n\n\t// Check that the Go code saw SIGIO.\n\tsawSIGIO = (int (*)(void))dlsym(handle, \"SawSIGIO\");\n\tif (sawSIGIO == NULL) {\n\t\tfprintf(stderr, \"%s\\n\", dlerror());\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (verbose) {\n\t\tprintf(\"calling SawSIGIO\\n\");\n\t}\n\n\tif (!sawSIGIO()) {\n\t\tfprintf(stderr, \"Go handler did not see SIGIO\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (sigioSeen != 0) {\n\t\tfprintf(stderr, \"C handler saw SIGIO when only Go handler should have\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t// Tell the Go code to stop catching SIGIO.\n\n\tif (verbose) {\n\t\tprintf(\"calling dlsym\\n\");\n\t}\n\n\tfn1 = (void(*)(void))dlsym(handle, \"ResetSIGIO\");\n\tif (fn1 == NULL) {\n\t\tfprintf(stderr, \"%s\\n\", dlerror());\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (verbose) {\n\t\tprintf(\"calling ResetSIGIO\\n\");\n\t}\n\n\tfn1();\n\n\tif (verbose) {\n\t\tprintf(\"raising SIGIO\\n\");\n\t}\n\n\tif (raise(SIGIO) < 0) {\n\t\tdie(\"raise\");\n\t}\n\n\tif (verbose) {\n\t\tprintf(\"calling SawSIGIO\\n\");\n\t}\n\n\tif (sawSIGIO()) {\n\t\tfprintf(stderr, \"Go handler saw SIGIO after Reset\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (verbose) {\n\t\tprintf(\"waiting for sigioSeen\\n\");\n\t}\n\n\t// Wait until the signal has been delivered.\n\ti = 0;\n\twhile (!sigioSeen) {\n\t\tts.tv_sec = 0;\n\t\tts.tv_nsec = 1000000;\n\t\tnanosleep(&ts, NULL);\n\t\ti++;\n\t\tif (i > 5000) {\n\t\t\tfprintf(stderr, \"looping too long waiting for signal\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\n\tprintf(\"PASS\\n\");\n\treturn 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/misc/cgo/testcshared/main1.c": "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n#include <stdint.h>\n#include <stdio.h>\n#include <dlfcn.h>\n\nint check_int8(void* handle, const char* fname, int8_t want) {\n  int8_t (*fn)();\n  fn = (int8_t (*)())dlsym(handle, fname);\n  if (!fn) {\n    fprintf(stderr, \"ERROR: missing %s: %s\\n\", fname, dlerror());\n    return 1;\n  }\n  signed char ret = fn();\n  if (ret != want) {\n    fprintf(stderr, \"ERROR: %s=%d, want %d\\n\", fname, ret, want);\n    return 1;\n  }\n  return 0;\n}\n\nint check_int32(void* handle, const char* fname, int32_t want) {\n  int32_t (*fn)();\n  fn = (int32_t (*)())dlsym(handle, fname);\n  if (!fn) {\n    fprintf(stderr, \"ERROR: missing %s: %s\\n\", fname, dlerror());\n    return 1;\n  }\n  int32_t ret = fn();\n  if (ret != want) {\n    fprintf(stderr, \"ERROR: %s=%d, want %d\\n\", fname, ret, want);\n    return 1;\n  }\n  return 0;\n}\n\n// Tests libgo.so to export the following functions.\n//   int8_t DidInitRun() // returns true\n//   int8_t DidMainRun() // returns true\n//   int32_t FromPkg() // returns 1024\nint main(int argc, char** argv) {\n  void* handle = dlopen(argv[1], RTLD_LAZY | RTLD_GLOBAL);\n  if (!handle) {\n    fprintf(stderr, \"ERROR: failed to open the shared library: %s\\n\",\n\t\t    dlerror());\n    return 2;\n  }\n\n  int ret = 0;\n  ret = check_int8(handle, \"DidInitRun\", 1);\n  if (ret != 0) {\n    return ret;\n  }\n\n  ret = check_int8(handle, \"DidMainRun\", 0);\n  if (ret != 0) {\n    return ret;\n  }\n\n  ret = check_int32(handle, \"FromPkg\", 1024);\n  if (ret != 0) {\n   return ret;\n  }\n  // test.bash looks for \"PASS\" to ensure this program has reached the end. \n  printf(\"PASS\\n\");\n  return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/misc/cgo/testcshared/main3.c": "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n#include <stdint.h>\n#include <stdio.h>\n#include <dlfcn.h>\n\n// Tests \"main.main\" is exported on android/arm,\n// which golang.org/x/mobile/app depends on.\nint main(int argc, char** argv) {\n  void* handle = dlopen(argv[1], RTLD_LAZY | RTLD_GLOBAL);\n  if (!handle) {\n    fprintf(stderr, \"ERROR: failed to open the shared library: %s\\n\",\n            dlerror());\n    return 2;\n  }\n\n  uintptr_t main_fn = (uintptr_t)dlsym(handle, \"main.main\");\n  if (!main_fn) {\n    fprintf(stderr, \"ERROR: missing main.main: %s\\n\", dlerror());\n    return 2;\n  }\n\n  // TODO(hyangah): check that main.main can run.\n\n  printf(\"PASS\\n\");\n  return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/misc/cgo/testcshared/main4.c": "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// Test that a signal handler that uses up stack space does not crash\n// if the signal is delivered to a thread running a goroutine.\n// This is a lot like misc/cgo/testcarchive/main2.c.\n\n#include <setjmp.h>\n#include <signal.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <sched.h>\n#include <time.h>\n#include <dlfcn.h>\n\nstatic void die(const char* msg) {\n\tperror(msg);\n\texit(EXIT_FAILURE);\n}\n\nstatic volatile sig_atomic_t sigioSeen;\n\n// Use up some stack space.\nstatic void recur(int i, char *p) {\n\tchar a[1024];\n\n\t*p = '\\0';\n\tif (i > 0) {\n\t\trecur(i - 1, a);\n\t}\n}\n\n// Signal handler that uses up more stack space than a goroutine will have.\nstatic void ioHandler(int signo, siginfo_t* info, void* ctxt) {\n\tchar a[1024];\n\n\trecur(4, a);\n\tsigioSeen = 1;\n}\n\nstatic jmp_buf jmp;\nstatic char* nullPointer;\n\n// Signal handler for SIGSEGV on a C thread.\nstatic void segvHandler(int signo, siginfo_t* info, void* ctxt) {\n\tsigset_t mask;\n\tint i;\n\n\tif (sigemptyset(&mask) < 0) {\n\t\tdie(\"sigemptyset\");\n\t}\n\tif (sigaddset(&mask, SIGSEGV) < 0) {\n\t\tdie(\"sigaddset\");\n\t}\n\ti = sigprocmask(SIG_UNBLOCK, &mask, NULL);\n\tif (i != 0) {\n\t\tfprintf(stderr, \"sigprocmask: %s\\n\", strerror(i));\n\t\texit(EXIT_FAILURE);\n\t}\n\n\t// Don't try this at home.\n\tlongjmp(jmp, signo);\n\n\t// We should never get here.\n\tabort();\n}\n\nint main(int argc, char** argv) {\n\tint verbose;\n\tstruct sigaction sa;\n\tvoid* handle;\n\tvoid (*fn)(void);\n\tsigset_t mask;\n\tint i;\n\tstruct timespec ts;\n\n\tverbose = argc > 2;\n\tsetvbuf(stdout, NULL, _IONBF, 0);\n\n\t// Call setsid so that we can use kill(0, SIGIO) below.\n\t// Don't check the return value so that this works both from\n\t// a job control shell and from a shell script.\n\tsetsid();\n\n\tif (verbose) {\n\t\tprintf(\"calling sigaction\\n\");\n\t}\n\n\tmemset(&sa, 0, sizeof sa);\n\tsa.sa_sigaction = ioHandler;\n\tif (sigemptyset(&sa.sa_mask) < 0) {\n\t\tdie(\"sigemptyset\");\n\t}\n\tsa.sa_flags = SA_SIGINFO;\n\tif (sigaction(SIGIO, &sa, NULL) < 0) {\n\t\tdie(\"sigaction\");\n\t}\n\n\tsa.sa_sigaction = segvHandler;\n\tif (sigaction(SIGSEGV, &sa, NULL) < 0 || sigaction(SIGBUS, &sa, NULL) < 0) {\n\t\tdie(\"sigaction\");\n\t}\n\n\tif (verbose) {\n\t\tprintf(\"calling dlopen\\n\");\n\t}\n\n\thandle = dlopen(argv[1], RTLD_NOW | RTLD_GLOBAL);\n\tif (handle == NULL) {\n\t\tfprintf(stderr, \"%s\\n\", dlerror());\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (verbose) {\n\t\tprintf(\"calling dlsym\\n\");\n\t}\n\n\t// Start some goroutines.\n\tfn = (void(*)(void))dlsym(handle, \"RunGoroutines\");\n\tif (fn == NULL) {\n\t\tfprintf(stderr, \"%s\\n\", dlerror());\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (verbose) {\n\t\tprintf(\"calling RunGoroutines\\n\");\n\t}\n\n\tfn();\n\n\t// Block SIGIO in this thread to make it more likely that it\n\t// will be delivered to a goroutine.\n\n\tif (verbose) {\n\t\tprintf(\"calling pthread_sigmask\\n\");\n\t}\n\n\tif (sigemptyset(&mask) < 0) {\n\t\tdie(\"sigemptyset\");\n\t}\n\tif (sigaddset(&mask, SIGIO) < 0) {\n\t\tdie(\"sigaddset\");\n\t}\n\ti = pthread_sigmask(SIG_BLOCK, &mask, NULL);\n\tif (i != 0) {\n\t\tfprintf(stderr, \"pthread_sigmask: %s\\n\", strerror(i));\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (verbose) {\n\t\tprintf(\"calling kill\\n\");\n\t}\n\n\tif (kill(0, SIGIO) < 0) {\n\t\tdie(\"kill\");\n\t}\n\n\tif (verbose) {\n\t\tprintf(\"waiting for sigioSeen\\n\");\n\t}\n\n\t// Wait until the signal has been delivered.\n\ti = 0;\n\twhile (!sigioSeen) {\n\t\tts.tv_sec = 0;\n\t\tts.tv_nsec = 1000000;\n\t\tnanosleep(&ts, NULL);\n\t\ti++;\n\t\tif (i > 5000) {\n\t\t\tfprintf(stderr, \"looping too long waiting for signal\\n\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\n\tif (verbose) {\n\t\tprintf(\"calling setjmp\\n\");\n\t}\n\n\t// Test that a SIGSEGV on this thread is delivered to us.\n\tif (setjmp(jmp) == 0) {\n\t\tif (verbose) {\n\t\t\tprintf(\"triggering SIGSEGV\\n\");\n\t\t}\n\n\t\t*nullPointer = '\\0';\n\n\t\tfprintf(stderr, \"continued after address error\\n\");\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (verbose) {\n\t\tprintf(\"calling dlsym\\n\");\n\t}\n\n\t// Make sure that a SIGSEGV in Go causes a run-time panic.\n\tfn = (void (*)(void))dlsym(handle, \"TestSEGV\");\n\tif (fn == NULL) {\n\t\tfprintf(stderr, \"%s\\n\", dlerror());\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif (verbose) {\n\t\tprintf(\"calling TestSEGV\\n\");\n\t}\n\n\tfn();\n\n\tprintf(\"PASS\\n\");\n\treturn 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/misc/cgo/test/issue4029.go": "// Copyright 2012 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// +build !windows\n\npackage cgotest\n\n/*\n#include <dlfcn.h>\n#cgo linux LDFLAGS: -ldl\n\nextern void call4029(void *arg);\n*/\nimport \"C\"\n\nimport (\n\t\"testing\"\n)\n\nvar callbacks int\n\n//export IMPIsOpaque\nfunc IMPIsOpaque() {\n\tcallbacks++\n}\n\n//export IMPInitWithFrame\nfunc IMPInitWithFrame() {\n\tcallbacks++\n}\n\n//export IMPDrawRect\nfunc IMPDrawRect() {\n\tcallbacks++\n}\n\n//export IMPWindowResize\nfunc IMPWindowResize() {\n\tcallbacks++\n}\n\nfunc test4029(t *testing.T) {\n\tloadThySelf(t, \"IMPWindowResize\")\n\tloadThySelf(t, \"IMPDrawRect\")\n\tloadThySelf(t, \"IMPInitWithFrame\")\n\tloadThySelf(t, \"IMPIsOpaque\")\n\tif callbacks != 4 {\n\t\tt.Errorf(\"got %d callbacks, expected 4\", callbacks)\n\t}\n}\n\nfunc loadThySelf(t *testing.T, symbol string) {\n\tthis_process := C.dlopen(nil, C.RTLD_NOW)\n\tif this_process == nil {\n\t\tt.Error(\"dlopen:\", C.GoString(C.dlerror()))\n\t\treturn\n\t}\n\tdefer C.dlclose(this_process)\n\n\tsymbol_address := C.dlsym(this_process, C.CString(symbol))\n\tif symbol_address == nil {\n\t\tt.Error(\"dlsym:\", C.GoString(C.dlerror()))\n\t\treturn\n\t}\n\tt.Log(symbol, symbol_address)\n\tC.call4029(symbol_address)\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/favicon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/compress/bzip2/testdata/pass-sawtooth.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/compress/bzip2/testdata/Mark.Twain-Tom.Sawyer.txt.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/compress/bzip2/testdata/fail-issue5747.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/compress/bzip2/testdata/pass-random2.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/compress/bzip2/testdata/e.txt.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/compress/bzip2/testdata/random.data.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/compress/bzip2/testdata/pass-random2.bin",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/compress/bzip2/testdata/pass-random1.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/compress/bzip2/testdata/pass-random1.bin",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/compress/gzip/testdata/issue6550.gz",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/compress/flate/testdata/huffman-rand-limit.wb.expect-noinput",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/compress/flate/testdata/huffman-shifts.wb.expect-noinput",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/compress/flate/testdata/huffman-rand-max.golden",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/compress/flate/testdata/huffman-text-shift.wb.expect",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/compress/flate/testdata/huffman-null-max.golden",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/compress/flate/testdata/huffman-rand-max.in",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/compress/flate/testdata/huffman-rand-1k.golden",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/compress/flate/testdata/huffman-pi.golden",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/compress/flate/testdata/huffman-rand-limit.wb.expect",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/compress/flate/testdata/huffman-rand-1k.dyn.expect-noinput",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/compress/flate/testdata/huffman-zero.golden",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/compress/flate/testdata/huffman-null-max.wb.expect",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/compress/flate/testdata/null-long-match.wb.expect-noinput",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/compress/flate/testdata/huffman-shifts.golden",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/compress/flate/testdata/huffman-text.golden",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/compress/flate/testdata/huffman-zero.dyn.expect-noinput",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/compress/flate/testdata/huffman-rand-1k.wb.expect-noinput",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/compress/flate/testdata/huffman-pi.wb.expect-noinput",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/compress/flate/testdata/huffman-pi.dyn.expect-noinput",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/compress/flate/testdata/huffman-rand-1k.dyn.expect",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/compress/flate/testdata/huffman-text-shift.golden",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/compress/flate/testdata/huffman-null-max.dyn.expect-noinput",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/compress/flate/testdata/huffman-text.dyn.expect",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/compress/flate/testdata/huffman-shifts.dyn.expect-noinput",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/compress/flate/testdata/huffman-rand-1k.wb.expect",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/compress/flate/testdata/huffman-rand-limit.dyn.expect-noinput",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/compress/flate/testdata/huffman-null-max.wb.expect-noinput",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/compress/flate/testdata/huffman-text-shift.wb.expect-noinput",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/compress/flate/testdata/huffman-text-shift.dyn.expect",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/compress/flate/testdata/huffman-null-max.dyn.expect",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/compress/flate/testdata/huffman-shifts.wb.expect",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/compress/flate/testdata/huffman-zero.dyn.expect",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/compress/flate/testdata/null-long-match.dyn.expect-noinput",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/compress/flate/testdata/huffman-text.wb.expect",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/compress/flate/testdata/huffman-rand-limit.golden",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/compress/flate/testdata/huffman-text.wb.expect-noinput",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/compress/flate/testdata/huffman-text.dyn.expect-noinput",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/compress/flate/testdata/huffman-rand-1k.in",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/compress/flate/testdata/huffman-pi.dyn.expect",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/compress/flate/testdata/huffman-rand-limit.dyn.expect",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/compress/flate/testdata/huffman-shifts.dyn.expect",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/compress/flate/testdata/huffman-pi.wb.expect",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/compress/flate/testdata/huffman-text-shift.dyn.expect-noinput",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/compress/flate/testdata/huffman-rand-limit.in",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/regexp/testdata/re2-exhaustive.txt.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/go/internal/gcimporter/testdata/versions/test_go1.7_1.a",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/go/internal/gcimporter/testdata/versions/test_go1.7_0.a",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/go/internal/gccgoimporter/testdata/unicode.gox",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/go/internal/gccgoimporter/testdata/time.gox",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/encoding/json/testdata/code.json.gz",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/testdata/video-001.progressive.truncated.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/testdata/video-005.gray.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/testdata/video-001.cmyk.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/testdata/video-001.separate.dc.progression.progressive.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/testdata/video-001.221212.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/testdata/video-001.cmyk.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/testdata/video-005.gray.q50.2x2.progressive.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/testdata/video-001.q50.440.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/testdata/video-001.q50.411.progressive.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/testdata/video-001.q50.422.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/testdata/video-001.rgb.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/testdata/video-005.gray.q50.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/testdata/video-001.5bpp.gif",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/testdata/video-005.gray.q50.2x2.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/testdata/video-001.separate.dc.progression.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/testdata/video-005.gray.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/testdata/video-001.q50.410.progressive.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/testdata/video-001.gif",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/testdata/video-001.rgb.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/testdata/video-001.q50.410.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/testdata/video-001.q50.444.progressive.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/testdata/video-001.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/testdata/video-001.progressive.truncated.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/testdata/video-001.221212.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/testdata/video-005.gray.gif",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/testdata/video-001.q50.411.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/testdata/video-001.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/testdata/video-001.q50.440.progressive.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/testdata/video-001.q50.420.progressive.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/testdata/video-001.q50.444.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/testdata/video-001.q50.422.progressive.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/testdata/video-001.progressive.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/testdata/video-005.gray.q50.progressive.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/testdata/video-001.q50.420.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/testdata/video-001.interlaced.gif",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/png/testdata/benchPaletted.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/png/testdata/invalid-zlib.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/png/testdata/benchRGB-interlace.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/png/testdata/gray-gradient.interlaced.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/png/testdata/benchNRGBA-gradient.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/png/testdata/invalid-crc32.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/png/testdata/benchNRGBA-opaque.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/png/testdata/invalid-trunc.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/png/testdata/benchGray.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/png/testdata/gray-gradient.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/png/testdata/benchRGB.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/png/testdata/invalid-noend.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/png/testdata/pngsuite/ftbbn0g04.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/png/testdata/pngsuite/ftbbn2c16.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/png/testdata/pngsuite/basn4a16.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/png/testdata/pngsuite/basn0g04-31.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/png/testdata/pngsuite/ftbbn3p08.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/png/testdata/pngsuite/basn2c08.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/png/testdata/pngsuite/ftp0n2c08.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/png/testdata/pngsuite/basn4a08.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/png/testdata/pngsuite/basn0g08.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/png/testdata/pngsuite/ftbgn3p08.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/png/testdata/pngsuite/basn3p02.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/png/testdata/pngsuite/basn3p08.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/png/testdata/pngsuite/ftbwn3p08.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/png/testdata/pngsuite/ftp0n0g08.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/png/testdata/pngsuite/ftbbn0g01.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/png/testdata/pngsuite/ftbwn0g16.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/png/testdata/pngsuite/basn0g02.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/png/testdata/pngsuite/basn0g04.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/png/testdata/pngsuite/basn0g16.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/png/testdata/pngsuite/ftbyn3p08.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/png/testdata/pngsuite/ftbgn2c16.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/png/testdata/pngsuite/basn0g02-29.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/png/testdata/pngsuite/basn3p08-trns.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/png/testdata/pngsuite/basn3p01.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/png/testdata/pngsuite/basn6a16.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/png/testdata/pngsuite/ftp0n3p08.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/png/testdata/pngsuite/ftbrn2c08.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/png/testdata/pngsuite/basn3p04-31i.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/png/testdata/pngsuite/basn0g01-30.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/png/testdata/pngsuite/basn3p04.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/png/testdata/pngsuite/ftbbn0g02.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/png/testdata/pngsuite/basn2c16.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/png/testdata/pngsuite/basn6a08.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/png/testdata/pngsuite/basn0g01.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/image/png/testdata/pngsuite/ftp1n3p08.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/runtime/race/race_darwin_amd64.syso",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/runtime/race/race_freebsd_amd64.syso",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/runtime/race/race_windows_amd64.syso",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/runtime/race/race_linux_amd64.syso",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/archive/zip/testdata/test-trailing-junk.zip",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/archive/zip/testdata/symlink.zip",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/archive/zip/testdata/crc32-not-streamed.zip",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/archive/zip/testdata/go-with-datadesc-sig.zip",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/archive/zip/testdata/readme.notzip",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/archive/zip/testdata/test.zip",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/archive/zip/testdata/zip64.zip",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/archive/zip/testdata/gophercolor16x16.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/archive/zip/testdata/winxp.zip",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/archive/zip/testdata/unix.zip",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/archive/zip/testdata/go-no-datadesc-sig.zip",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/archive/zip/testdata/dd.zip",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/archive/zip/testdata/zip64-2.zip",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/archive/zip/testdata/readme.zip",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/archive/tar/testdata/writer-big.tar",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/archive/tar/testdata/writer-big-long.tar",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/archive/tar/testdata/issue10968.tar",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/archive/tar/testdata/v7.tar",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/archive/tar/testdata/issue12435.tar",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/archive/tar/testdata/neg-size.tar",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/crypto/rsa/testdata/pss-vect.txt.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/crypto/ecdsa/testdata/SigVer.rsp.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/debug/elf/testdata/go-relocation-test-gcc620-sparc64.obj",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/debug/elf/testdata/go-relocation-test-gcc492-arm.obj",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/debug/elf/testdata/go-relocation-test-gcc441-x86.obj",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/debug/elf/testdata/go-relocation-test-gcc493-mips64le.obj",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/debug/elf/testdata/go-relocation-test-gcc492-mipsle.obj",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/debug/elf/testdata/hello-world-core.gz",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/debug/elf/testdata/go-relocation-test-gcc482-aarch64.obj",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/debug/elf/testdata/go-relocation-test-clang-arm.obj",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/debug/elf/testdata/zdebug-test-gcc484-x86-64.obj",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/debug/elf/testdata/gcc-amd64-openbsd-debug-with-rela.obj",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/debug/elf/testdata/go-relocation-test-gcc5-ppc.obj",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/debug/elf/testdata/go-relocation-test-gcc492-mips64.obj",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/debug/elf/testdata/go-relocation-test-gcc531-s390x.obj",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/debug/elf/testdata/compressed-32.obj",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/debug/elf/testdata/go-relocation-test-gcc482-ppc64le.obj",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/debug/elf/testdata/go-relocation-test-gcc441-x86-64.obj",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/debug/elf/testdata/go-relocation-test-gcc540-mips.obj",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/debug/elf/testdata/go-relocation-test-gcc424-x86-64.obj",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/debug/elf/testdata/compressed-64.obj",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/debug/elf/testdata/go-relocation-test-clang-x86.obj",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/debug/dwarf/testdata/line-clang.elf",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/debug/dwarf/testdata/typedef.macho",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/debug/dwarf/testdata/ranges.elf",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/debug/dwarf/testdata/typedef.elf",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/debug/dwarf/testdata/typedef.elf4",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/debug/dwarf/testdata/line-gcc.elf",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/debug/dwarf/testdata/split.elf",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/src/debug/dwarf/testdata/cycle.elf",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/lib/time/zoneinfo.zip",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/misc/chrome/gophertool/gopher.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/doc/go-logo-blue.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/doc/go-logo-black.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/doc/go-logo-white.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/doc/share.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/doc/gopher/help.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/doc/gopher/bumper192x108.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/doc/gopher/appenginegophercolor.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/doc/gopher/gopherbw.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/doc/gopher/project.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/doc/gopher/ref.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/doc/gopher/bumper.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/doc/gopher/bumper640x360.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/doc/gopher/gophercolor.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/doc/gopher/gophercolor16x16.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/doc/gopher/pkg.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/doc/gopher/biplane.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/doc/gopher/fiveyears.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/doc/gopher/talks.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/doc/gopher/appenginegopher.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/doc/gopher/run.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/doc/gopher/bumper480x270.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/doc/gopher/doc.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/doc/gopher/appenginelogo.gif",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/doc/gopher/frontpage.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/doc/gopher/bumper320x180.png",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/doc/gopher/pencil/gopherswrench.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/doc/gopher/pencil/gophermega.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/doc/gopher/pencil/gopherhat.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/doc/gopher/pencil/gopherswim.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/doc/gopher/pencil/gopherhelmet.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/doc/gopher/pencil/gopherrunning.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-go-1.8.1-o5urqbehiyw43lc4swil6e6zq5pdufuo/spack-src/doc/codewalk/popout.png"
    ],
    "total_files": 6030
}