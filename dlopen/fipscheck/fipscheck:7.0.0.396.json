{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-fipscheck-7.0.0.396-fsg32gyapclfk55lfzknueyxjzywvasa/spack-src/configure.ac": "# Copyright (C) 2008, 2009, 2010, 2012, 2013 Red Hat, Inc. All rights reserved.\n# Copyright (C) 2016 Andrew Cagney\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are met:\n#\n# 1. Redistributions of source code must retain the above copyright notice,\n# this list of conditions and the following disclaimer.\n# 2. Redistributions in binary form must reproduce the above copyright notice,\n# this list of conditions and the following disclaimer in the documentation\n# and/or other materials provided with the distribution.\n#\n# THIS SOFTWARE IS PROVIDED BY RED HAT, INC. ''AS IS'' AND ANY EXPRESS OR\n# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n# EVENT SHALL THE FREEBSD PROJECT OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n# INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n# LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n# OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n#\n# The views and conclusions contained in the software and documentation are those\n# of the authors and should not be interpreted as representing official policies,\n# either expressed or implied, of Red Hat, Inc.\n\nAC_INIT([fipscheck],[1.6.0],[support@lairdconnect.com])\nAC_CONFIG_HEADER([config.h])\nAC_PREREQ(2.60)\n\nAC_CONFIG_MACRO_DIR([m4])\nAM_INIT_AUTOMAKE([dist-bzip2 no-dist-gzip])\n\nAC_ARG_ENABLE([docs],\n    AS_HELP_STRING([--enable-docs], [Enable man genereation @<:@default=yes@:>@]),\n    [case \"${enableval}\" in\n        yes) enable_docs=true ;;\n        no)  enable_docs=false ;;\n        *) AC_MSG_ERROR([bad value ${enableval} for --enable-docs]) ;;\n     esac],[enable_docs=true])\nAM_CONDITIONAL([ENABLE_DOCS], [test x$enable_docs = xtrue])\n\ndnl Check for _GNU_SOURCE\nAC_USE_SYSTEM_EXTENSIONS\n\nAM_PROG_LIBTOOL\n\n_LT_TAGVAR(hardcode_libdir_flag_spec, )=\"\"\n_LT_TAGVAR(hardcode_minus_L, )=yes\n\nPKG_PROG_PKG_CONFIG()\n\ndnl Checks for programs.\n\nAC_PROG_CC\nAC_PROG_INSTALL\nAC_PROG_LN_S\nAM_PROG_CC_C_O\n\nAC_CHECK_HEADERS( \\\n        fcntl.h \\\n        stddef.h \\\n        stdint.h \\\n        sys/stat.h \\\n        sys/time.h \\\n        sys/types.h \\\n        time.h \\\n        unistd.h \\\n        syslog.h\n)\n\nAC_CHECK_FUNCS( \\\n       fcntl \\\n       vasprintf \\\n       syslog\n)\n\ndnl Checks for typedefs, structures, and compiler characteristics.\nAC_C_CONST\nAC_TYPE_SIGNAL\nAC_TYPE_UID_T\nAC_TYPE_MODE_T\nAC_TYPE_OFF_T\nAC_TYPE_PID_T\nAC_TYPE_SIZE_T\nAC_STRUCT_TM\n\ndnl Checks for the existence of libdl - on BSD and Tru64 its part of libc\nAC_CHECK_LIB([dl], [dlopen], LIBDL=\"-ldl\", LIBDL=\"\")\nAC_SUBST(LIBDL)\n\ndnl This is not a strictly correct use of --with, OTOH it is better\ndnl than having separate and conflicting --with-nss and --with-openssl\ndnl options.  Rather than be \"smart\" and guess the crypto library\ndnl based on what is installed, this logic simply barfs on an error.\n\nAC_ARG_WITH([crypto],\n            [AS_HELP_STRING([--with-crypto],\n\t                    [specify the crypto library to use when computing the HMAC, OpenSSL (the default) and NSS are supported])],\n            [],\n            [with_crypto=openssl])\n\ndnl Check for the existence of the slected crypto library with FIPS mode\nAS_CASE($with_crypto,\n    [openssl|ssl], [\n        AC_DEFINE([WITH_OPENSSL], [1], [use HMAC from the OpenSSL crypto library])\n        AC_CHECK_LIB([crypto], [FIPS_mode], [CRYPTO_LIBS=-lcrypto],\n                     [AC_MSG_ERROR([OpenSSL library with FIPS mode support is required])])\n\t],\n    [nss], [\n\tPKG_CHECK_MODULES([CRYPTO],[nss],[],[AC_MSG_ERROR([NSS library with FIPS mode support is required])])\n\tCRYPTO_LIBS=\"$CRYPTO_LIBS -lfreebl\"\n        AC_DEFINE([WITH_NSS], [1], [use HMAC from the NSS crypto library])\n\t],\n    [AC_MSG_ERROR([The --with-crypto library \"$with_crypto\" is not known])])\n\nAC_SUBST(CRYPTO_LIBS)\nAC_SUBST(CRYPTO_CFLAGS)\n\nAC_MSG_CHECKING(sysconfdir)\nAC_ARG_WITH(sysconfdir,\n[AS_HELP_STRING([--with-sysconfdir=PATH], [Directory containing permission files (default /etc).])],\n[ case \"$withval\" in\n  no)\n    AC_MSG_ERROR([Need SYSCONFDIR.])\n    ;;\n  yes)\n    SYSCONFDIR=/etc\n    AC_MSG_RESULT(/etc)\n    ;;\n  *)\n    SYSCONFDIR=\"$withval\"\n    AC_MSG_RESULT($withval)\n    ;;\n  esac ],\n  SYSCONFDIR=\"/etc\"\n  AC_MSG_RESULT(/etc)\n)\nAC_SUBST(SYSCONFDIR)\n\nAC_CONFIG_FILES([Makefile src/Makefile man/Makefile])\nAC_OUTPUT\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-fipscheck-7.0.0.396-fsg32gyapclfk55lfzknueyxjzywvasa/spack-src/src/library.c": "/* library.c */\n/*\n * Copyright (C) 2008, 2009, 2013 Red Hat Inc. All rights reserved.\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * \n * 1. Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n * \n * THIS SOFTWARE IS PROVIDED BY RED HAT, INC. ''AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO\n * EVENT SHALL THE FREEBSD PROJECT OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n * \n * The views and conclusions contained in the software and documentation are those\n * of the authors and should not be interpreted as representing official policies,\n * either expressed or implied, of Red Hat, Inc.\n */\n\n#include \"config.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <dlfcn.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <signal.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n\n#include \"fipscheck.h\"\n#include \"filehmac.h\"\n\n#define MAX_PATH_LEN 4096\n#define SELFLINK \"/proc/self/exe\"\n#ifndef PATH_FIPSCHECK\n#define PATH_FIPSCHECK \"/usr/bin/fipscheck\"\n#endif\n#define FIPS_MODE_SWITCH_FILE \"/proc/sys/crypto/fips_enabled\"\n\nint\nFIPSCHECK_get_binary_path(char *path, size_t pathlen)\n{\n\tssize_t len;\n\n\tlen = readlink(SELFLINK, path, pathlen-1);\n\t\n\tif (len < 0) {\n\t\treturn -1;\n\t}\n\t\n\tpath[len] = '\\0';\n\treturn 0;\n}\n\n\nint\nFIPSCHECK_get_library_path(const char *libname, const char *symbolname, char *path, size_t pathlen)\n{\n\tDl_info info;\n\tvoid *dl, *sym;\n\tint rv = -1;\n\n        dl = dlopen(libname, RTLD_NODELETE|RTLD_NOLOAD|RTLD_LAZY);\n        if (dl == NULL) {\n\t        return -1;\n        }       \n\n\tsym = dlsym(dl, symbolname);\n\n\tif (sym != NULL && dladdr(sym, &info)) {\n\t\tstrncpy(path, info.dli_fname, pathlen-1);\n\t\tpath[pathlen-1] = '\\0';\n\t\trv = 0;\n\t}\n\n\tdlclose(dl);\n\t\n\treturn rv;\n}\n\n\nstatic int\nrun_fipscheck_helper(const char *hmac_suffix, const char *paths[])\n{\n\tint rv = -1, child;\n\tvoid (*sighandler)(int) = NULL;\n\n\tsighandler = signal(SIGCHLD, SIG_DFL);\n\n\t/* fork */\n\tchild = fork();\n\tif (child == 0) {\n\t\tstatic char *envp[] = { NULL };\n\t\tchar **args;\n\t\tint i, offset = 1;\n\n\t\tfor (i = 0; paths[i] != NULL; i++);\n\n\t\tif (i < 1) /* nothing to check */\n\t\t\t_exit(127);\n\n\t\targs = calloc(i + 4, sizeof(*args));\n\n\t\tif (args == NULL)\n\t\t\t_exit(127);\n\n\t\targs[0] = PATH_FIPSCHECK;\n\t\tif (hmac_suffix) {\n\t\t\targs[1] = \"-s\";\n\t\t\targs[2] = (char *)hmac_suffix;\n\t\t\toffset = 3;\n\t\t}\n\t\tmemcpy(&args[offset], paths, sizeof(*args)*(i + 1));\n\n\t\texecve(PATH_FIPSCHECK, args, envp);\n\n\t\t/* if we get here: exit with error */\n\t\t_exit(127);\n\n\t} else if (child > 0) {\n\t\tint status;\n\n\t\twhile ((rv=waitpid(child, &status, 0)) == -1 &&   /* wait for fipscheck to complete */\n\t\t\terrno == EINTR);\n\t\tif (rv > 0 && WIFEXITED(status) && WEXITSTATUS(status) == 0) {\n\t\t\trv = 0;\n\t\t} else {\n\t\t\trv = -1;\n\t\t}\n\t} /* else failed fork */\n\n\tif (sighandler != SIG_ERR) {\n\t\t(void) signal(SIGCHLD, sighandler);   /* restore old signal handler */\n\t}\n\n\treturn rv;\n}\n\nstatic int\ntest_hmac_installed(const char *path, const char *hmac_suffix)\n{\n\tconst char *hmacdir = PATH_HMACDIR;\n\tchar *hmacpath;\n\tint rv;\n\n\tdo {\n\t\thmacpath = make_hmac_path(path, hmacdir, hmac_suffix);\n\t\tif (hmacpath == NULL) {\n\t\t\t/* we must fail later */\n\t\t\treturn 1;\n\t\t}\n\n\t\trv = access(hmacpath, F_OK);\n\t\tif (rv < 0 && errno != ENOENT) {\n\t\t\trv = 0;\n\t\t}\n\n\t\tfree(hmacpath);\n\n\t\tif (rv < 0 && hmacdir == NULL) {\n\t\t\t/* hmac not found */\n\t\t\treturn 0;\n\t\t}\n\n\t\thmacdir = NULL;\n        } while (rv < 0);\n\t/* hmac found */\n        return 1;\n}\n\nint\nFIPSCHECK_verify(const char *libname, const char *symbolname)\n{\n\treturn FIPSCHECK_verify_ex(libname, symbolname, NULL, 1);\n}\n\nint\nFIPSCHECK_verify_ex(const char *libname, const char *symbolname, const char *hmac_suffix, int fail_if_missing)\n{\n\tchar path[MAX_PATH_LEN];\n\tconst char *files[] = {path, NULL};\n\tint rv;\n\n\tif (libname == NULL || symbolname == NULL) {\n\t\trv = FIPSCHECK_get_binary_path(path, sizeof(path));\n\t} else {\n\t\trv = FIPSCHECK_get_library_path(libname, symbolname, path, sizeof(path));\n\t}\n\n\tif (rv < 0)\n\t\treturn 0;\n\n\tif (!fail_if_missing && !test_hmac_installed(path, hmac_suffix))\n\t\treturn 1;\n\n\trv = run_fipscheck_helper(hmac_suffix, files);\n\n\tif (rv < 0)\n\t\treturn 0;\n\n\t/* check successful */\n\treturn 1;\n}\n\nint\nFIPSCHECK_verify_files(const char *files[])\n{\n\treturn FIPSCHECK_verify_files_ex(NULL, 1, files);\n}\n\nint\nFIPSCHECK_verify_files_ex(const char *hmac_suffix, int fail_if_missing, const char *files[])\n{\n\tint rv;\n\n\tif (!fail_if_missing && !test_hmac_installed(files[0], hmac_suffix))\n\t\treturn 1;\n\n\trv = run_fipscheck_helper(hmac_suffix, files);\n\n\tif (rv < 0)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nint\nFIPSCHECK_fips_module_installed(const char *libname, const char *symbolname, const char *hmac_suffix)\n{\n\tchar path[MAX_PATH_LEN];\n\tint rv;\n\n\tif (libname == NULL || symbolname == NULL) {\n\t\trv = FIPSCHECK_get_binary_path(path, sizeof(path));\n\t} else {\n\t\trv = FIPSCHECK_get_library_path(libname, symbolname, path, sizeof(path));\n\t}\n\n\tif (rv < 0)\n\t\t/* Fail safe - that is as if the module was installed */\n\t\treturn 1;\n\n\treturn test_hmac_installed(path, hmac_suffix);\n}\n\nint\nFIPSCHECK_kernel_fips_mode(void)\n{\n\tint fd;\n\tchar buf[1] = \"\";\n\n\tif ((fd=open(FIPS_MODE_SWITCH_FILE, O_RDONLY)) >= 0) {\n\t\twhile (read(fd, buf, sizeof(buf)) < 0 && errno == EINTR);\n\t\tclose(fd);\n\t}\n\tif (buf[0] == '1')\n\t\treturn 1;\n\treturn 0;\n}\n"
    },
    "skipped": [],
    "total_files": 18
}