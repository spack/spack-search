{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/Documentation/filesystems/ramfs-rootfs-initramfs.txt": "ramfs, rootfs and initramfs\nOctober 17, 2005\nRob Landley <rob@landley.net>\n=============================\n\nWhat is ramfs?\n--------------\n\nRamfs is a very simple filesystem that exports Linux's disk caching\nmechanisms (the page cache and dentry cache) as a dynamically resizable\nRAM-based filesystem.\n\nNormally all files are cached in memory by Linux.  Pages of data read from\nbacking store (usually the block device the filesystem is mounted on) are kept\naround in case it's needed again, but marked as clean (freeable) in case the\nVirtual Memory system needs the memory for something else.  Similarly, data\nwritten to files is marked clean as soon as it has been written to backing\nstore, but kept around for caching purposes until the VM reallocates the\nmemory.  A similar mechanism (the dentry cache) greatly speeds up access to\ndirectories.\n\nWith ramfs, there is no backing store.  Files written into ramfs allocate\ndentries and page cache as usual, but there's nowhere to write them to.\nThis means the pages are never marked clean, so they can't be freed by the\nVM when it's looking to recycle memory.\n\nThe amount of code required to implement ramfs is tiny, because all the\nwork is done by the existing Linux caching infrastructure.  Basically,\nyou're mounting the disk cache as a filesystem.  Because of this, ramfs is not\nan optional component removable via menuconfig, since there would be negligible\nspace savings.\n\nramfs and ramdisk:\n------------------\n\nThe older \"ram disk\" mechanism created a synthetic block device out of\nan area of RAM and used it as backing store for a filesystem.  This block\ndevice was of fixed size, so the filesystem mounted on it was of fixed\nsize.  Using a ram disk also required unnecessarily copying memory from the\nfake block device into the page cache (and copying changes back out), as well\nas creating and destroying dentries.  Plus it needed a filesystem driver\n(such as ext2) to format and interpret this data.\n\nCompared to ramfs, this wastes memory (and memory bus bandwidth), creates\nunnecessary work for the CPU, and pollutes the CPU caches.  (There are tricks\nto avoid this copying by playing with the page tables, but they're unpleasantly\ncomplicated and turn out to be about as expensive as the copying anyway.)\nMore to the point, all the work ramfs is doing has to happen _anyway_,\nsince all file access goes through the page and dentry caches.  The RAM\ndisk is simply unnecessary; ramfs is internally much simpler.\n\nAnother reason ramdisks are semi-obsolete is that the introduction of\nloopback devices offered a more flexible and convenient way to create\nsynthetic block devices, now from files instead of from chunks of memory.\nSee losetup (8) for details.\n\nramfs and tmpfs:\n----------------\n\nOne downside of ramfs is you can keep writing data into it until you fill\nup all memory, and the VM can't free it because the VM thinks that files\nshould get written to backing store (rather than swap space), but ramfs hasn't\ngot any backing store.  Because of this, only root (or a trusted user) should\nbe allowed write access to a ramfs mount.\n\nA ramfs derivative called tmpfs was created to add size limits, and the ability\nto write the data to swap space.  Normal users can be allowed write access to\ntmpfs mounts.  See Documentation/filesystems/tmpfs.txt for more information.\n\nWhat is rootfs?\n---------------\n\nRootfs is a special instance of ramfs (or tmpfs, if that's enabled), which is\nalways present in 2.6 systems.  You can't unmount rootfs for approximately the\nsame reason you can't kill the init process; rather than having special code\nto check for and handle an empty list, it's smaller and simpler for the kernel\nto just make sure certain lists can't become empty.\n\nMost systems just mount another filesystem over rootfs and ignore it.  The\namount of space an empty instance of ramfs takes up is tiny.\n\nIf CONFIG_TMPFS is enabled, rootfs will use tmpfs instead of ramfs by\ndefault.  To force ramfs, add \"rootfstype=ramfs\" to the kernel command\nline.\n\nWhat is initramfs?\n------------------\n\nAll 2.6 Linux kernels contain a gzipped \"cpio\" format archive, which is\nextracted into rootfs when the kernel boots up.  After extracting, the kernel\nchecks to see if rootfs contains a file \"init\", and if so it executes it as PID\n1.  If found, this init process is responsible for bringing the system the\nrest of the way up, including locating and mounting the real root device (if\nany).  If rootfs does not contain an init program after the embedded cpio\narchive is extracted into it, the kernel will fall through to the older code\nto locate and mount a root partition, then exec some variant of /sbin/init\nout of that.\n\nAll this differs from the old initrd in several ways:\n\n  - The old initrd was always a separate file, while the initramfs archive is\n    linked into the linux kernel image.  (The directory linux-*/usr is devoted\n    to generating this archive during the build.)\n\n  - The old initrd file was a gzipped filesystem image (in some file format,\n    such as ext2, that needed a driver built into the kernel), while the new\n    initramfs archive is a gzipped cpio archive (like tar only simpler,\n    see cpio(1) and Documentation/early-userspace/buffer-format.txt).  The\n    kernel's cpio extraction code is not only extremely small, it's also\n    __init text and data that can be discarded during the boot process.\n\n  - The program run by the old initrd (which was called /initrd, not /init) did\n    some setup and then returned to the kernel, while the init program from\n    initramfs is not expected to return to the kernel.  (If /init needs to hand\n    off control it can overmount / with a new root device and exec another init\n    program.  See the switch_root utility, below.)\n\n  - When switching another root device, initrd would pivot_root and then\n    umount the ramdisk.  But initramfs is rootfs: you can neither pivot_root\n    rootfs, nor unmount it.  Instead delete everything out of rootfs to\n    free up the space (find -xdev / -exec rm '{}' ';'), overmount rootfs\n    with the new root (cd /newmount; mount --move . /; chroot .), attach\n    stdin/stdout/stderr to the new /dev/console, and exec the new init.\n\n    Since this is a remarkably persnickety process (and involves deleting\n    commands before you can run them), the klibc package introduced a helper\n    program (utils/run_init.c) to do all this for you.  Most other packages\n    (such as busybox) have named this command \"switch_root\".\n\nPopulating initramfs:\n---------------------\n\nThe 2.6 kernel build process always creates a gzipped cpio format initramfs\narchive and links it into the resulting kernel binary.  By default, this\narchive is empty (consuming 134 bytes on x86).\n\nThe config option CONFIG_INITRAMFS_SOURCE (in General Setup in menuconfig,\nand living in usr/Kconfig) can be used to specify a source for the\ninitramfs archive, which will automatically be incorporated into the\nresulting binary.  This option can point to an existing gzipped cpio\narchive, a directory containing files to be archived, or a text file\nspecification such as the following example:\n\n  dir /dev 755 0 0\n  nod /dev/console 644 0 0 c 5 1\n  nod /dev/loop0 644 0 0 b 7 0\n  dir /bin 755 1000 1000\n  slink /bin/sh busybox 777 0 0\n  file /bin/busybox initramfs/busybox 755 0 0\n  dir /proc 755 0 0\n  dir /sys 755 0 0\n  dir /mnt 755 0 0\n  file /init initramfs/init.sh 755 0 0\n\nRun \"usr/gen_init_cpio\" (after the kernel build) to get a usage message\ndocumenting the above file format.\n\nOne advantage of the configuration file is that root access is not required to\nset permissions or create device nodes in the new archive.  (Note that those\ntwo example \"file\" entries expect to find files named \"init.sh\" and \"busybox\" in\na directory called \"initramfs\", under the linux-2.6.* directory.  See\nDocumentation/early-userspace/README for more details.)\n\nThe kernel does not depend on external cpio tools.  If you specify a\ndirectory instead of a configuration file, the kernel's build infrastructure\ncreates a configuration file from that directory (usr/Makefile calls\nscripts/gen_initramfs_list.sh), and proceeds to package up that directory\nusing the config file (by feeding it to usr/gen_init_cpio, which is created\nfrom usr/gen_init_cpio.c).  The kernel's build-time cpio creation code is\nentirely self-contained, and the kernel's boot-time extractor is also\n(obviously) self-contained.\n\nThe one thing you might need external cpio utilities installed for is creating\nor extracting your own preprepared cpio files to feed to the kernel build\n(instead of a config file or directory).\n\nThe following command line can extract a cpio image (either by the above script\nor by the kernel build) back into its component files:\n\n  cpio -i -d -H newc -F initramfs_data.cpio --no-absolute-filenames\n\nThe following shell script can create a prebuilt cpio archive you can\nuse in place of the above config file:\n\n  #!/bin/sh\n\n  # Copyright 2006 Rob Landley <rob@landley.net> and TimeSys Corporation.\n  # Licensed under GPL version 2\n\n  if [ $# -ne 2 ]\n  then\n    echo \"usage: mkinitramfs directory imagename.cpio.gz\"\n    exit 1\n  fi\n\n  if [ -d \"$1\" ]\n  then\n    echo \"creating $2 from $1\"\n    (cd \"$1\"; find . | cpio -o -H newc | gzip) > \"$2\"\n  else\n    echo \"First argument must be a directory\"\n    exit 1\n  fi\n\nNote: The cpio man page contains some bad advice that will break your initramfs\narchive if you follow it.  It says \"A typical way to generate the list\nof filenames is with the find command; you should give find the -depth option\nto minimize problems with permissions on directories that are unwritable or not\nsearchable.\"  Don't do this when creating initramfs.cpio.gz images, it won't\nwork.  The Linux kernel cpio extractor won't create files in a directory that\ndoesn't exist, so the directory entries must go before the files that go in\nthose directories.  The above script gets them in the right order.\n\nExternal initramfs images:\n--------------------------\n\nIf the kernel has initrd support enabled, an external cpio.gz archive can also\nbe passed into a 2.6 kernel in place of an initrd.  In this case, the kernel\nwill autodetect the type (initramfs, not initrd) and extract the external cpio\narchive into rootfs before trying to run /init.\n\nThis has the memory efficiency advantages of initramfs (no ramdisk block\ndevice) but the separate packaging of initrd (which is nice if you have\nnon-GPL code you'd like to run from initramfs, without conflating it with\nthe GPL licensed Linux kernel binary).\n\nIt can also be used to supplement the kernel's built-in initramfs image.  The\nfiles in the external archive will overwrite any conflicting files in\nthe built-in initramfs archive.  Some distributors also prefer to customize\na single kernel image with task-specific initramfs images, without recompiling.\n\nContents of initramfs:\n----------------------\n\nAn initramfs archive is a complete self-contained root filesystem for Linux.\nIf you don't already understand what shared libraries, devices, and paths\nyou need to get a minimal root filesystem up and running, here are some\nreferences:\nhttp://www.tldp.org/HOWTO/Bootdisk-HOWTO/\nhttp://www.tldp.org/HOWTO/From-PowerUp-To-Bash-Prompt-HOWTO.html\nhttp://www.linuxfromscratch.org/lfs/view/stable/\n\nThe \"klibc\" package (http://www.kernel.org/pub/linux/libs/klibc) is\ndesigned to be a tiny C library to statically link early userspace\ncode against, along with some related utilities.  It is BSD licensed.\n\nI use uClibc (http://www.uclibc.org) and busybox (http://www.busybox.net)\nmyself.  These are LGPL and GPL, respectively.  (A self-contained initramfs\npackage is planned for the busybox 1.3 release.)\n\nIn theory you could use glibc, but that's not well suited for small embedded\nuses like this.  (A \"hello world\" program statically linked against glibc is\nover 400k.  With uClibc it's 7k.  Also note that glibc dlopens libnss to do\nname lookups, even when otherwise statically linked.)\n\nA good first step is to get initramfs to run a statically linked \"hello world\"\nprogram as init, and test it under an emulator like qemu (www.qemu.org) or\nUser Mode Linux, like so:\n\n  cat > hello.c << EOF\n  #include <stdio.h>\n  #include <unistd.h>\n\n  int main(int argc, char *argv[])\n  {\n    printf(\"Hello world!\\n\");\n    sleep(999999999);\n  }\n  EOF\n  gcc -static hello.c -o init\n  echo init | cpio -o -H newc | gzip > test.cpio.gz\n  # Testing external initramfs using the initrd loading mechanism.\n  qemu -kernel /boot/vmlinuz -initrd test.cpio.gz /dev/zero\n\nWhen debugging a normal root filesystem, it's nice to be able to boot with\n\"init=/bin/sh\".  The initramfs equivalent is \"rdinit=/bin/sh\", and it's\njust as useful.\n\nWhy cpio rather than tar?\n-------------------------\n\nThis decision was made back in December, 2001.  The discussion started here:\n\n  http://www.uwsg.iu.edu/hypermail/linux/kernel/0112.2/1538.html\n\nAnd spawned a second thread (specifically on tar vs cpio), starting here:\n\n  http://www.uwsg.iu.edu/hypermail/linux/kernel/0112.2/1587.html\n\nThe quick and dirty summary version (which is no substitute for reading\nthe above threads) is:\n\n1) cpio is a standard.  It's decades old (from the AT&T days), and already\n   widely used on Linux (inside RPM, Red Hat's device driver disks).  Here's\n   a Linux Journal article about it from 1996:\n\n      http://www.linuxjournal.com/article/1213\n\n   It's not as popular as tar because the traditional cpio command line tools\n   require _truly_hideous_ command line arguments.  But that says nothing\n   either way about the archive format, and there are alternative tools,\n   such as:\n\n     http://freecode.com/projects/afio\n\n2) The cpio archive format chosen by the kernel is simpler and cleaner (and\n   thus easier to create and parse) than any of the (literally dozens of)\n   various tar archive formats.  The complete initramfs archive format is\n   explained in buffer-format.txt, created in usr/gen_init_cpio.c, and\n   extracted in init/initramfs.c.  All three together come to less than 26k\n   total of human-readable text.\n\n3) The GNU project standardizing on tar is approximately as relevant as\n   Windows standardizing on zip.  Linux is not part of either, and is free\n   to make its own technical decisions.\n\n4) Since this is a kernel internal format, it could easily have been\n   something brand new.  The kernel provides its own tools to create and\n   extract this format anyway.  Using an existing standard was preferable,\n   but not essential.\n\n5) Al Viro made the decision (quote: \"tar is ugly as hell and not going to be\n   supported on the kernel side\"):\n\n      http://www.uwsg.iu.edu/hypermail/linux/kernel/0112.2/1540.html\n\n   explained his reasoning:\n\n      http://www.uwsg.iu.edu/hypermail/linux/kernel/0112.2/1550.html\n      http://www.uwsg.iu.edu/hypermail/linux/kernel/0112.2/1638.html\n\n   and, most importantly, designed and implemented the initramfs code.\n\nFuture directions:\n------------------\n\nToday (2.6.16), initramfs is always compiled in, but not always used.  The\nkernel falls back to legacy boot code that is reached only if initramfs does\nnot contain an /init program.  The fallback is legacy code, there to ensure a\nsmooth transition and allowing early boot functionality to gradually move to\n\"early userspace\" (I.E. initramfs).\n\nThe move to early userspace is necessary because finding and mounting the real\nroot device is complex.  Root partitions can span multiple devices (raid or\nseparate journal).  They can be out on the network (requiring dhcp, setting a\nspecific MAC address, logging into a server, etc).  They can live on removable\nmedia, with dynamically allocated major/minor numbers and persistent naming\nissues requiring a full udev implementation to sort out.  They can be\ncompressed, encrypted, copy-on-write, loopback mounted, strangely partitioned,\nand so on.\n\nThis kind of complexity (which inevitably includes policy) is rightly handled\nin userspace.  Both klibc and busybox/uClibc are working on simple initramfs\npackages to drop into a kernel build.\n\nThe klibc package has now been accepted into Andrew Morton's 2.6.17-mm tree.\nThe kernel's current early boot code (partition detection, etc) will probably\nbe migrated into a default initramfs, automatically created and used by the\nkernel build.\n",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/tools/testing/selftests/x86/test_syscall_vdso.c": "/*\n * 32-bit syscall ABI conformance test.\n *\n * Copyright (c) 2015 Denys Vlasenko\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms and conditions of the GNU General Public License,\n * version 2, as published by the Free Software Foundation.\n *\n * This program is distributed in the hope it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n */\n/*\n * Can be built statically:\n * gcc -Os -Wall -static -m32 test_syscall_vdso.c thunks_32.S\n */\n#undef _GNU_SOURCE\n#define _GNU_SOURCE 1\n#undef __USE_GNU\n#define __USE_GNU 1\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <signal.h>\n#include <sys/types.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <elf.h>\n#include <sys/ptrace.h>\n#include <sys/wait.h>\n\n#if !defined(__i386__)\nint main(int argc, char **argv, char **envp)\n{\n\tprintf(\"[SKIP]\\tNot a 32-bit x86 userspace\\n\");\n\treturn 0;\n}\n#else\n\nlong syscall_addr;\nlong get_syscall(char **envp)\n{\n\tElf32_auxv_t *auxv;\n\twhile (*envp++ != NULL)\n\t\tcontinue;\n\tfor (auxv = (void *)envp; auxv->a_type != AT_NULL; auxv++)\n\t\tif (auxv->a_type == AT_SYSINFO)\n\t\t\treturn auxv->a_un.a_val;\n\tprintf(\"[WARN]\\tAT_SYSINFO not supplied\\n\");\n\treturn 0;\n}\n\nasm (\n\t\"\t.pushsection .text\\n\"\n\t\"\t.global\tint80\\n\"\n\t\"int80:\\n\"\n\t\"\tint\t$0x80\\n\"\n\t\"\tret\\n\"\n\t\"\t.popsection\\n\"\n);\nextern char int80;\n\nstruct regs64 {\n\tuint64_t rax, rbx, rcx, rdx;\n\tuint64_t rsi, rdi, rbp, rsp;\n\tuint64_t r8,  r9,  r10, r11;\n\tuint64_t r12, r13, r14, r15;\n};\nstruct regs64 regs64;\nint kernel_is_64bit;\n\nasm (\n\t\"\t.pushsection .text\\n\"\n\t\"\t.code64\\n\"\n\t\"get_regs64:\\n\"\n\t\"\tpush\t%rax\\n\"\n\t\"\tmov\t$regs64, %eax\\n\"\n\t\"\tpop\t0*8(%rax)\\n\"\n\t\"\tmovq\t%rbx, 1*8(%rax)\\n\"\n\t\"\tmovq\t%rcx, 2*8(%rax)\\n\"\n\t\"\tmovq\t%rdx, 3*8(%rax)\\n\"\n\t\"\tmovq\t%rsi, 4*8(%rax)\\n\"\n\t\"\tmovq\t%rdi, 5*8(%rax)\\n\"\n\t\"\tmovq\t%rbp, 6*8(%rax)\\n\"\n\t\"\tmovq\t%rsp, 7*8(%rax)\\n\"\n\t\"\tmovq\t%r8,  8*8(%rax)\\n\"\n\t\"\tmovq\t%r9,  9*8(%rax)\\n\"\n\t\"\tmovq\t%r10, 10*8(%rax)\\n\"\n\t\"\tmovq\t%r11, 11*8(%rax)\\n\"\n\t\"\tmovq\t%r12, 12*8(%rax)\\n\"\n\t\"\tmovq\t%r13, 13*8(%rax)\\n\"\n\t\"\tmovq\t%r14, 14*8(%rax)\\n\"\n\t\"\tmovq\t%r15, 15*8(%rax)\\n\"\n\t\"\tret\\n\"\n\t\"poison_regs64:\\n\"\n\t\"\tmovq\t$0x7f7f7f7f, %r8\\n\"\n\t\"\tshl\t$32, %r8\\n\"\n\t\"\torq\t$0x7f7f7f7f, %r8\\n\"\n\t\"\tmovq\t%r8, %r9\\n\"\n\t\"\tmovq\t%r8, %r10\\n\"\n\t\"\tmovq\t%r8, %r11\\n\"\n\t\"\tmovq\t%r8, %r12\\n\"\n\t\"\tmovq\t%r8, %r13\\n\"\n\t\"\tmovq\t%r8, %r14\\n\"\n\t\"\tmovq\t%r8, %r15\\n\"\n\t\"\tret\\n\"\n\t\"\t.code32\\n\"\n\t\"\t.popsection\\n\"\n);\nextern void get_regs64(void);\nextern void poison_regs64(void);\nextern unsigned long call64_from_32(void (*function)(void));\nvoid print_regs64(void)\n{\n\tif (!kernel_is_64bit)\n\t\treturn;\n\tprintf(\"ax:%016llx bx:%016llx cx:%016llx dx:%016llx\\n\", regs64.rax,  regs64.rbx,  regs64.rcx,  regs64.rdx);\n\tprintf(\"si:%016llx di:%016llx bp:%016llx sp:%016llx\\n\", regs64.rsi,  regs64.rdi,  regs64.rbp,  regs64.rsp);\n\tprintf(\" 8:%016llx  9:%016llx 10:%016llx 11:%016llx\\n\", regs64.r8 ,  regs64.r9 ,  regs64.r10,  regs64.r11);\n\tprintf(\"12:%016llx 13:%016llx 14:%016llx 15:%016llx\\n\", regs64.r12,  regs64.r13,  regs64.r14,  regs64.r15);\n}\n\nint check_regs64(void)\n{\n\tint err = 0;\n\tint num = 8;\n\tuint64_t *r64 = &regs64.r8;\n\n\tif (!kernel_is_64bit)\n\t\treturn 0;\n\n\tdo {\n\t\tif (*r64 == 0x7f7f7f7f7f7f7f7fULL)\n\t\t\tcontinue; /* register did not change */\n\t\tif (syscall_addr != (long)&int80) {\n\t\t\t/*\n\t\t\t * Non-INT80 syscall entrypoints are allowed to clobber R8+ regs:\n\t\t\t * either clear them to 0, or for R11, load EFLAGS.\n\t\t\t */\n\t\t\tif (*r64 == 0)\n\t\t\t\tcontinue;\n\t\t\tif (num == 11) {\n\t\t\t\tprintf(\"[NOTE]\\tR11 has changed:%016llx - assuming clobbered by SYSRET insn\\n\", *r64);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t} else {\n\t\t\t/* INT80 syscall entrypoint can be used by\n\t\t\t * 64-bit programs too, unlike SYSCALL/SYSENTER.\n\t\t\t * Therefore it must preserve R12+\n\t\t\t * (they are callee-saved registers in 64-bit C ABI).\n\t\t\t *\n\t\t\t * This was probably historically not intended,\n\t\t\t * but R8..11 are clobbered (cleared to 0).\n\t\t\t * IOW: they are the only registers which aren't\n\t\t\t * preserved across INT80 syscall.\n\t\t\t */\n\t\t\tif (*r64 == 0 && num <= 11)\n\t\t\t\tcontinue;\n\t\t}\n\t\tprintf(\"[FAIL]\\tR%d has changed:%016llx\\n\", num, *r64);\n\t\terr++;\n\t} while (r64++, ++num < 16);\n\n\tif (!err)\n\t\tprintf(\"[OK]\\tR8..R15 did not leak kernel data\\n\");\n\treturn err;\n}\n\nint nfds;\nfd_set rfds;\nfd_set wfds;\nfd_set efds;\nstruct timespec timeout;\nsigset_t sigmask;\nstruct {\n\tsigset_t *sp;\n\tint sz;\n} sigmask_desc;\n\nvoid prep_args()\n{\n\tnfds = 42;\n\tFD_ZERO(&rfds);\n\tFD_ZERO(&wfds);\n\tFD_ZERO(&efds);\n\tFD_SET(0, &rfds);\n\tFD_SET(1, &wfds);\n\tFD_SET(2, &efds);\n\ttimeout.tv_sec = 0;\n\ttimeout.tv_nsec = 123;\n\tsigemptyset(&sigmask);\n\tsigaddset(&sigmask, SIGINT);\n\tsigaddset(&sigmask, SIGUSR2);\n\tsigaddset(&sigmask, SIGRTMAX);\n\tsigmask_desc.sp = &sigmask;\n\tsigmask_desc.sz = 8; /* bytes */\n}\n\nstatic void print_flags(const char *name, unsigned long r)\n{\n\tstatic const char *bitarray[] = {\n\t\"\\n\" ,\"c\\n\" ,/* Carry Flag */\n\t\"0 \" ,\"1 \"  ,/* Bit 1 - always on */\n\t\"\"   ,\"p \"  ,/* Parity Flag */\n\t\"0 \" ,\"3? \" ,\n\t\"\"   ,\"a \"  ,/* Auxiliary carry Flag */\n\t\"0 \" ,\"5? \" ,\n\t\"\"   ,\"z \"  ,/* Zero Flag */\n\t\"\"   ,\"s \"  ,/* Sign Flag */\n\t\"\"   ,\"t \"  ,/* Trap Flag */\n\t\"\"   ,\"i \"  ,/* Interrupt Flag */\n\t\"\"   ,\"d \"  ,/* Direction Flag */\n\t\"\"   ,\"o \"  ,/* Overflow Flag */\n\t\"0 \" ,\"1 \"  ,/* I/O Privilege Level (2 bits) */\n\t\"0\"  ,\"1\"   ,/* I/O Privilege Level (2 bits) */\n\t\"\"   ,\"n \"  ,/* Nested Task */\n\t\"0 \" ,\"15? \",\n\t\"\"   ,\"r \"  ,/* Resume Flag */\n\t\"\"   ,\"v \"  ,/* Virtual Mode */\n\t\"\"   ,\"ac \" ,/* Alignment Check/Access Control */\n\t\"\"   ,\"vif \",/* Virtual Interrupt Flag */\n\t\"\"   ,\"vip \",/* Virtual Interrupt Pending */\n\t\"\"   ,\"id \" ,/* CPUID detection */\n\tNULL\n\t};\n\tconst char **bitstr;\n\tint bit;\n\n\tprintf(\"%s=%016lx \", name, r);\n\tbitstr = bitarray + 42;\n\tbit = 21;\n\tif ((r >> 22) != 0)\n\t\tprintf(\"(extra bits are set) \");\n\tdo {\n\t\tif (bitstr[(r >> bit) & 1][0])\n\t\t\tfputs(bitstr[(r >> bit) & 1], stdout);\n\t\tbitstr -= 2;\n\t\tbit--;\n\t} while (bit >= 0);\n}\n\nint run_syscall(void)\n{\n\tlong flags, bad_arg;\n\n\tprep_args();\n\n\tif (kernel_is_64bit)\n\t\tcall64_from_32(poison_regs64);\n\t/*print_regs64();*/\n\n\tasm(\"\\n\"\n\t/* Try 6-arg syscall: pselect. It should return quickly */\n\t\"\tpush\t%%ebp\\n\"\n\t\"\tmov\t$308, %%eax\\n\"     /* PSELECT */\n\t\"\tmov\tnfds, %%ebx\\n\"     /* ebx  arg1 */\n\t\"\tmov\t$rfds, %%ecx\\n\"    /* ecx  arg2 */\n\t\"\tmov\t$wfds, %%edx\\n\"    /* edx  arg3 */\n\t\"\tmov\t$efds, %%esi\\n\"    /* esi  arg4 */\n\t\"\tmov\t$timeout, %%edi\\n\" /* edi  arg5 */\n\t\"\tmov\t$sigmask_desc, %%ebp\\n\" /* %ebp arg6 */\n\t\"\tpush\t$0x200ed7\\n\"      /* set almost all flags */\n\t\"\tpopf\\n\"\t\t/* except TF, IOPL, NT, RF, VM, AC, VIF, VIP */\n\t\"\tcall\t*syscall_addr\\n\"\n\t/* Check that registers are not clobbered */\n\t\"\tpushf\\n\"\n\t\"\tpop\t%%eax\\n\"\n\t\"\tcld\\n\"\n\t\"\tcmp\tnfds, %%ebx\\n\"     /* ebx  arg1 */\n\t\"\tmov\t$1, %%ebx\\n\"\n\t\"\tjne\t1f\\n\"\n\t\"\tcmp\t$rfds, %%ecx\\n\"    /* ecx  arg2 */\n\t\"\tmov\t$2, %%ebx\\n\"\n\t\"\tjne\t1f\\n\"\n\t\"\tcmp\t$wfds, %%edx\\n\"    /* edx  arg3 */\n\t\"\tmov\t$3, %%ebx\\n\"\n\t\"\tjne\t1f\\n\"\n\t\"\tcmp\t$efds, %%esi\\n\"    /* esi  arg4 */\n\t\"\tmov\t$4, %%ebx\\n\"\n\t\"\tjne\t1f\\n\"\n\t\"\tcmp\t$timeout, %%edi\\n\" /* edi  arg5 */\n\t\"\tmov\t$5, %%ebx\\n\"\n\t\"\tjne\t1f\\n\"\n\t\"\tcmpl\t$sigmask_desc, %%ebp\\n\" /* %ebp arg6 */\n\t\"\tmov\t$6, %%ebx\\n\"\n\t\"\tjne\t1f\\n\"\n\t\"\tmov\t$0, %%ebx\\n\"\n\t\"1:\\n\"\n\t\"\tpop\t%%ebp\\n\"\n\t: \"=a\" (flags), \"=b\" (bad_arg)\n\t:\n\t: \"cx\", \"dx\", \"si\", \"di\"\n\t);\n\n\tif (kernel_is_64bit) {\n\t\tmemset(&regs64, 0x77, sizeof(regs64));\n\t\tcall64_from_32(get_regs64);\n\t\t/*print_regs64();*/\n\t}\n\n\t/*\n\t * On paravirt kernels, flags are not preserved across syscalls.\n\t * Thus, we do not consider it a bug if some are changed.\n\t * We just show ones which do.\n\t */\n\tif ((0x200ed7 ^ flags) != 0) {\n\t\tprint_flags(\"[WARN]\\tFlags before\", 0x200ed7);\n\t\tprint_flags(\"[WARN]\\tFlags  after\", flags);\n\t\tprint_flags(\"[WARN]\\tFlags change\", (0x200ed7 ^ flags));\n\t}\n\n\tif (bad_arg) {\n\t\tprintf(\"[FAIL]\\targ#%ld clobbered\\n\", bad_arg);\n\t\treturn 1;\n\t}\n\tprintf(\"[OK]\\tArguments are preserved across syscall\\n\");\n\n\treturn check_regs64();\n}\n\nint run_syscall_twice()\n{\n\tint exitcode = 0;\n\tlong sv;\n\n\tif (syscall_addr) {\n\t\tprintf(\"[RUN]\\tExecuting 6-argument 32-bit syscall via VDSO\\n\");\n\t\texitcode = run_syscall();\n\t}\n\tsv = syscall_addr;\n\tsyscall_addr = (long)&int80;\n\tprintf(\"[RUN]\\tExecuting 6-argument 32-bit syscall via INT 80\\n\");\n\texitcode += run_syscall();\n\tsyscall_addr = sv;\n\treturn exitcode;\n}\n\nvoid ptrace_me()\n{\n\tpid_t pid;\n\n\tfflush(NULL);\n\tpid = fork();\n\tif (pid < 0)\n\t\texit(1);\n\tif (pid == 0) {\n\t\t/* child */\n\t\tif (ptrace(PTRACE_TRACEME, 0L, 0L, 0L) != 0)\n\t\t\texit(0);\n\t\traise(SIGSTOP);\n\t\treturn;\n\t}\n\t/* parent */\n\tprintf(\"[RUN]\\tRunning tests under ptrace\\n\");\n\twhile (1) {\n\t\tint status;\n\t\tpid = waitpid(-1, &status, __WALL);\n\t\tif (WIFEXITED(status))\n\t\t\texit(WEXITSTATUS(status));\n\t\tif (WIFSIGNALED(status))\n\t\t\texit(WTERMSIG(status));\n\t\tif (pid <= 0 || !WIFSTOPPED(status)) /* paranoia */\n\t\t\texit(255);\n\t\t/*\n\t\t * Note: we do not inject sig = WSTOPSIG(status).\n\t\t * We probably should, but careful: do not inject SIGTRAP\n\t\t * generated by syscall entry/exit stops.\n\t\t * That kills the child.\n\t\t */\n\t\tptrace(PTRACE_SYSCALL, pid, 0L, 0L /*sig*/);\n\t}\n}\n\nint main(int argc, char **argv, char **envp)\n{\n\tint exitcode = 0;\n\tint cs;\n\n\tasm(\"\\n\"\n\t\"\tmovl\t%%cs, %%eax\\n\"\n\t: \"=a\" (cs)\n\t);\n\tkernel_is_64bit = (cs == 0x23);\n\tif (!kernel_is_64bit)\n\t\tprintf(\"[NOTE]\\tNot a 64-bit kernel, won't test R8..R15 leaks\\n\");\n\n\t/* This only works for non-static builds:\n\t * syscall_addr = dlsym(dlopen(\"linux-gate.so.1\", RTLD_NOW), \"__kernel_vsyscall\");\n\t */\n\tsyscall_addr = get_syscall(envp);\n\n\texitcode += run_syscall_twice();\n\tptrace_me();\n\texitcode += run_syscall_twice();\n\n\treturn exitcode;\n}\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/tools/lib/traceevent/event-plugin.c": "/*\n * Copyright (C) 2009, 2010 Red Hat Inc, Steven Rostedt <srostedt@redhat.com>\n *\n * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation;\n * version 2.1 of the License (not later!)\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this program; if not,  see <http://www.gnu.org/licenses>\n *\n * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n */\n\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <dlfcn.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <dirent.h>\n#include \"event-parse.h\"\n#include \"event-utils.h\"\n\n#define LOCAL_PLUGIN_DIR \".traceevent/plugins\"\n\nstatic struct registered_plugin_options {\n\tstruct registered_plugin_options\t*next;\n\tstruct pevent_plugin_option\t\t*options;\n} *registered_options;\n\nstatic struct trace_plugin_options {\n\tstruct trace_plugin_options\t*next;\n\tchar\t\t\t\t*plugin;\n\tchar\t\t\t\t*option;\n\tchar\t\t\t\t*value;\n} *trace_plugin_options;\n\nstruct plugin_list {\n\tstruct plugin_list\t*next;\n\tchar\t\t\t*name;\n\tvoid\t\t\t*handle;\n};\n\nstatic void lower_case(char *str)\n{\n\tif (!str)\n\t\treturn;\n\tfor (; *str; str++)\n\t\t*str = tolower(*str);\n}\n\nstatic int update_option_value(struct pevent_plugin_option *op, const char *val)\n{\n\tchar *op_val;\n\n\tif (!val) {\n\t\t/* toggle, only if option is boolean */\n\t\tif (op->value)\n\t\t\t/* Warn? */\n\t\t\treturn 0;\n\t\top->set ^= 1;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If the option has a value then it takes a string\n\t * otherwise the option is a boolean.\n\t */\n\tif (op->value) {\n\t\top->value = val;\n\t\treturn 0;\n\t}\n\n\t/* Option is boolean, must be either \"1\", \"0\", \"true\" or \"false\" */\n\n\top_val = strdup(val);\n\tif (!op_val)\n\t\treturn -1;\n\tlower_case(op_val);\n\n\tif (strcmp(val, \"1\") == 0 || strcmp(val, \"true\") == 0)\n\t\top->set = 1;\n\telse if (strcmp(val, \"0\") == 0 || strcmp(val, \"false\") == 0)\n\t\top->set = 0;\n\tfree(op_val);\n\n\treturn 0;\n}\n\n/**\n * traceevent_plugin_list_options - get list of plugin options\n *\n * Returns an array of char strings that list the currently registered\n * plugin options in the format of <plugin>:<option>. This list can be\n * used by toggling the option.\n *\n * Returns NULL if there's no options registered. On error it returns\n * INVALID_PLUGIN_LIST_OPTION\n *\n * Must be freed with traceevent_plugin_free_options_list().\n */\nchar **traceevent_plugin_list_options(void)\n{\n\tstruct registered_plugin_options *reg;\n\tstruct pevent_plugin_option *op;\n\tchar **list = NULL;\n\tchar *name;\n\tint count = 0;\n\n\tfor (reg = registered_options; reg; reg = reg->next) {\n\t\tfor (op = reg->options; op->name; op++) {\n\t\t\tchar *alias = op->plugin_alias ? op->plugin_alias : op->file;\n\t\t\tchar **temp = list;\n\n\t\t\tname = malloc(strlen(op->name) + strlen(alias) + 2);\n\t\t\tif (!name)\n\t\t\t\tgoto err;\n\n\t\t\tsprintf(name, \"%s:%s\", alias, op->name);\n\t\t\tlist = realloc(list, count + 2);\n\t\t\tif (!list) {\n\t\t\t\tlist = temp;\n\t\t\t\tfree(name);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tlist[count++] = name;\n\t\t\tlist[count] = NULL;\n\t\t}\n\t}\n\treturn list;\n\n err:\n\twhile (--count >= 0)\n\t\tfree(list[count]);\n\tfree(list);\n\n\treturn INVALID_PLUGIN_LIST_OPTION;\n}\n\nvoid traceevent_plugin_free_options_list(char **list)\n{\n\tint i;\n\n\tif (!list)\n\t\treturn;\n\n\tif (list == INVALID_PLUGIN_LIST_OPTION)\n\t\treturn;\n\n\tfor (i = 0; list[i]; i++)\n\t\tfree(list[i]);\n\n\tfree(list);\n}\n\nstatic int\nupdate_option(const char *file, struct pevent_plugin_option *option)\n{\n\tstruct trace_plugin_options *op;\n\tchar *plugin;\n\tint ret = 0;\n\n\tif (option->plugin_alias) {\n\t\tplugin = strdup(option->plugin_alias);\n\t\tif (!plugin)\n\t\t\treturn -1;\n\t} else {\n\t\tchar *p;\n\t\tplugin = strdup(file);\n\t\tif (!plugin)\n\t\t\treturn -1;\n\t\tp = strstr(plugin, \".\");\n\t\tif (p)\n\t\t\t*p = '\\0';\n\t}\n\n\t/* first look for named options */\n\tfor (op = trace_plugin_options; op; op = op->next) {\n\t\tif (!op->plugin)\n\t\t\tcontinue;\n\t\tif (strcmp(op->plugin, plugin) != 0)\n\t\t\tcontinue;\n\t\tif (strcmp(op->option, option->name) != 0)\n\t\t\tcontinue;\n\n\t\tret = update_option_value(option, op->value);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\tbreak;\n\t}\n\n\t/* first look for unnamed options */\n\tfor (op = trace_plugin_options; op; op = op->next) {\n\t\tif (op->plugin)\n\t\t\tcontinue;\n\t\tif (strcmp(op->option, option->name) != 0)\n\t\t\tcontinue;\n\n\t\tret = update_option_value(option, op->value);\n\t\tbreak;\n\t}\n\n out:\n\tfree(plugin);\n\treturn ret;\n}\n\n/**\n * traceevent_plugin_add_options - Add a set of options by a plugin\n * @name: The name of the plugin adding the options\n * @options: The set of options being loaded\n *\n * Sets the options with the values that have been added by user.\n */\nint traceevent_plugin_add_options(const char *name,\n\t\t\t\t  struct pevent_plugin_option *options)\n{\n\tstruct registered_plugin_options *reg;\n\n\treg = malloc(sizeof(*reg));\n\tif (!reg)\n\t\treturn -1;\n\treg->next = registered_options;\n\treg->options = options;\n\tregistered_options = reg;\n\n\twhile (options->name) {\n\t\tupdate_option(name, options);\n\t\toptions++;\n\t}\n\treturn 0;\n}\n\n/**\n * traceevent_plugin_remove_options - remove plugin options that were registered\n * @options: Options to removed that were registered with traceevent_plugin_add_options\n */\nvoid traceevent_plugin_remove_options(struct pevent_plugin_option *options)\n{\n\tstruct registered_plugin_options **last;\n\tstruct registered_plugin_options *reg;\n\n\tfor (last = &registered_options; *last; last = &(*last)->next) {\n\t\tif ((*last)->options == options) {\n\t\t\treg = *last;\n\t\t\t*last = reg->next;\n\t\t\tfree(reg);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\n/**\n * traceevent_print_plugins - print out the list of plugins loaded\n * @s: the trace_seq descripter to write to\n * @prefix: The prefix string to add before listing the option name\n * @suffix: The suffix string ot append after the option name\n * @list: The list of plugins (usually returned by traceevent_load_plugins()\n *\n * Writes to the trace_seq @s the list of plugins (files) that is\n * returned by traceevent_load_plugins(). Use @prefix and @suffix for formating:\n * @prefix = \"  \", @suffix = \"\\n\".\n */\nvoid traceevent_print_plugins(struct trace_seq *s,\n\t\t\t      const char *prefix, const char *suffix,\n\t\t\t      const struct plugin_list *list)\n{\n\twhile (list) {\n\t\ttrace_seq_printf(s, \"%s%s%s\", prefix, list->name, suffix);\n\t\tlist = list->next;\n\t}\n}\n\nstatic void\nload_plugin(struct pevent *pevent, const char *path,\n\t    const char *file, void *data)\n{\n\tstruct plugin_list **plugin_list = data;\n\tpevent_plugin_load_func func;\n\tstruct plugin_list *list;\n\tconst char *alias;\n\tchar *plugin;\n\tvoid *handle;\n\n\tplugin = malloc(strlen(path) + strlen(file) + 2);\n\tif (!plugin) {\n\t\twarning(\"could not allocate plugin memory\\n\");\n\t\treturn;\n\t}\n\n\tstrcpy(plugin, path);\n\tstrcat(plugin, \"/\");\n\tstrcat(plugin, file);\n\n\thandle = dlopen(plugin, RTLD_NOW | RTLD_GLOBAL);\n\tif (!handle) {\n\t\twarning(\"could not load plugin '%s'\\n%s\\n\",\n\t\t\tplugin, dlerror());\n\t\tgoto out_free;\n\t}\n\n\talias = dlsym(handle, PEVENT_PLUGIN_ALIAS_NAME);\n\tif (!alias)\n\t\talias = file;\n\n\tfunc = dlsym(handle, PEVENT_PLUGIN_LOADER_NAME);\n\tif (!func) {\n\t\twarning(\"could not find func '%s' in plugin '%s'\\n%s\\n\",\n\t\t\tPEVENT_PLUGIN_LOADER_NAME, plugin, dlerror());\n\t\tgoto out_free;\n\t}\n\n\tlist = malloc(sizeof(*list));\n\tif (!list) {\n\t\twarning(\"could not allocate plugin memory\\n\");\n\t\tgoto out_free;\n\t}\n\n\tlist->next = *plugin_list;\n\tlist->handle = handle;\n\tlist->name = plugin;\n\t*plugin_list = list;\n\n\tpr_stat(\"registering plugin: %s\", plugin);\n\tfunc(pevent);\n\treturn;\n\n out_free:\n\tfree(plugin);\n}\n\nstatic void\nload_plugins_dir(struct pevent *pevent, const char *suffix,\n\t\t const char *path,\n\t\t void (*load_plugin)(struct pevent *pevent,\n\t\t\t\t     const char *path,\n\t\t\t\t     const char *name,\n\t\t\t\t     void *data),\n\t\t void *data)\n{\n\tstruct dirent *dent;\n\tstruct stat st;\n\tDIR *dir;\n\tint ret;\n\n\tret = stat(path, &st);\n\tif (ret < 0)\n\t\treturn;\n\n\tif (!S_ISDIR(st.st_mode))\n\t\treturn;\n\n\tdir = opendir(path);\n\tif (!dir)\n\t\treturn;\n\n\twhile ((dent = readdir(dir))) {\n\t\tconst char *name = dent->d_name;\n\n\t\tif (strcmp(name, \".\") == 0 ||\n\t\t    strcmp(name, \"..\") == 0)\n\t\t\tcontinue;\n\n\t\t/* Only load plugins that end in suffix */\n\t\tif (strcmp(name + (strlen(name) - strlen(suffix)), suffix) != 0)\n\t\t\tcontinue;\n\n\t\tload_plugin(pevent, path, name, data);\n\t}\n\n\tclosedir(dir);\n}\n\nstatic void\nload_plugins(struct pevent *pevent, const char *suffix,\n\t     void (*load_plugin)(struct pevent *pevent,\n\t\t\t\t const char *path,\n\t\t\t\t const char *name,\n\t\t\t\t void *data),\n\t     void *data)\n{\n\tchar *home;\n\tchar *path;\n\tchar *envdir;\n\n\tif (pevent->flags & PEVENT_DISABLE_PLUGINS)\n\t\treturn;\n\n\t/*\n\t * If a system plugin directory was defined,\n\t * check that first.\n\t */\n#ifdef PLUGIN_DIR\n\tif (!(pevent->flags & PEVENT_DISABLE_SYS_PLUGINS))\n\t\tload_plugins_dir(pevent, suffix, PLUGIN_DIR,\n\t\t\t\t load_plugin, data);\n#endif\n\n\t/*\n\t * Next let the environment-set plugin directory\n\t * override the system defaults.\n\t */\n\tenvdir = getenv(\"TRACEEVENT_PLUGIN_DIR\");\n\tif (envdir)\n\t\tload_plugins_dir(pevent, suffix, envdir, load_plugin, data);\n\n\t/*\n\t * Now let the home directory override the environment\n\t * or system defaults.\n\t */\n\thome = getenv(\"HOME\");\n\tif (!home)\n\t\treturn;\n\n\tpath = malloc(strlen(home) + strlen(LOCAL_PLUGIN_DIR) + 2);\n\tif (!path) {\n\t\twarning(\"could not allocate plugin memory\\n\");\n\t\treturn;\n\t}\n\n\tstrcpy(path, home);\n\tstrcat(path, \"/\");\n\tstrcat(path, LOCAL_PLUGIN_DIR);\n\n\tload_plugins_dir(pevent, suffix, path, load_plugin, data);\n\n\tfree(path);\n}\n\nstruct plugin_list*\ntraceevent_load_plugins(struct pevent *pevent)\n{\n\tstruct plugin_list *list = NULL;\n\n\tload_plugins(pevent, \".so\", load_plugin, &list);\n\treturn list;\n}\n\nvoid\ntraceevent_unload_plugins(struct plugin_list *plugin_list, struct pevent *pevent)\n{\n\tpevent_plugin_unload_func func;\n\tstruct plugin_list *list;\n\n\twhile (plugin_list) {\n\t\tlist = plugin_list;\n\t\tplugin_list = list->next;\n\t\tfunc = dlsym(list->handle, PEVENT_PLUGIN_UNLOADER_NAME);\n\t\tif (func)\n\t\t\tfunc(pevent);\n\t\tdlclose(list->handle);\n\t\tfree(list->name);\n\t\tfree(list);\n\t}\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/tools/perf/ui/setup.c": "#include <pthread.h>\n#include <dlfcn.h>\n\n#include \"../util/cache.h\"\n#include \"../util/debug.h\"\n#include \"../util/hist.h\"\n\npthread_mutex_t ui__lock = PTHREAD_MUTEX_INITIALIZER;\nvoid *perf_gtk_handle;\n\n#ifdef HAVE_GTK2_SUPPORT\nstatic int setup_gtk_browser(void)\n{\n\tint (*perf_ui_init)(void);\n\n\tif (perf_gtk_handle)\n\t\treturn 0;\n\n\tperf_gtk_handle = dlopen(PERF_GTK_DSO, RTLD_LAZY);\n\tif (perf_gtk_handle == NULL) {\n\t\tchar buf[PATH_MAX];\n\t\tscnprintf(buf, sizeof(buf), \"%s/%s\", LIBDIR, PERF_GTK_DSO);\n\t\tperf_gtk_handle = dlopen(buf, RTLD_LAZY);\n\t}\n\tif (perf_gtk_handle == NULL)\n\t\treturn -1;\n\n\tperf_ui_init = dlsym(perf_gtk_handle, \"perf_gtk__init\");\n\tif (perf_ui_init == NULL)\n\t\tgoto out_close;\n\n\tif (perf_ui_init() == 0)\n\t\treturn 0;\n\nout_close:\n\tdlclose(perf_gtk_handle);\n\treturn -1;\n}\n\nstatic void exit_gtk_browser(bool wait_for_ok)\n{\n\tvoid (*perf_ui_exit)(bool);\n\n\tif (perf_gtk_handle == NULL)\n\t\treturn;\n\n\tperf_ui_exit = dlsym(perf_gtk_handle, \"perf_gtk__exit\");\n\tif (perf_ui_exit == NULL)\n\t\tgoto out_close;\n\n\tperf_ui_exit(wait_for_ok);\n\nout_close:\n\tdlclose(perf_gtk_handle);\n\n\tperf_gtk_handle = NULL;\n}\n#else\nstatic inline int setup_gtk_browser(void) { return -1; }\nstatic inline void exit_gtk_browser(bool wait_for_ok __maybe_unused) {}\n#endif\n\nint stdio__config_color(const struct option *opt __maybe_unused,\n\t\t\tconst char *mode, int unset __maybe_unused)\n{\n\tperf_use_color_default = perf_config_colorbool(\"color.ui\", mode, -1);\n\treturn 0;\n}\n\nvoid setup_browser(bool fallback_to_pager)\n{\n\tif (use_browser < 2 && (!isatty(1) || dump_trace))\n\t\tuse_browser = 0;\n\n\t/* default to TUI */\n\tif (use_browser < 0)\n\t\tuse_browser = 1;\n\n\tswitch (use_browser) {\n\tcase 2:\n\t\tif (setup_gtk_browser() == 0)\n\t\t\tbreak;\n\t\tprintf(\"GTK browser requested but could not find %s\\n\",\n\t\t       PERF_GTK_DSO);\n\t\tsleep(1);\n\t\t/* fall through */\n\tcase 1:\n\t\tuse_browser = 1;\n\t\tif (ui__init() == 0)\n\t\t\tbreak;\n\t\t/* fall through */\n\tdefault:\n\t\tuse_browser = 0;\n\t\tif (fallback_to_pager)\n\t\t\tsetup_pager();\n\t\tbreak;\n\t}\n}\n\nvoid exit_browser(bool wait_for_ok)\n{\n\tswitch (use_browser) {\n\tcase 2:\n\t\texit_gtk_browser(wait_for_ok);\n\t\tbreak;\n\n\tcase 1:\n\t\tui__exit(wait_for_ok);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/tools/perf/util/usage.c": "/*\n * usage.c\n *\n * Various reporting routines.\n * Originally copied from GIT source.\n *\n * Copyright (C) Linus Torvalds, 2005\n */\n#include \"util.h\"\n#include \"debug.h\"\n\nstatic void report(const char *prefix, const char *err, va_list params)\n{\n\tchar msg[1024];\n\tvsnprintf(msg, sizeof(msg), err, params);\n\tfprintf(stderr, \" %s%s\\n\", prefix, msg);\n}\n\nstatic NORETURN void usage_builtin(const char *err)\n{\n\tfprintf(stderr, \"\\n Usage: %s\\n\", err);\n\texit(129);\n}\n\nstatic NORETURN void die_builtin(const char *err, va_list params)\n{\n\treport(\" Fatal: \", err, params);\n\texit(128);\n}\n\nstatic void error_builtin(const char *err, va_list params)\n{\n\treport(\" Error: \", err, params);\n}\n\nstatic void warn_builtin(const char *warn, va_list params)\n{\n\treport(\" Warning: \", warn, params);\n}\n\n/* If we are in a dlopen()ed .so write to a global variable would segfault\n * (ugh), so keep things static. */\nstatic void (*usage_routine)(const char *err) NORETURN = usage_builtin;\nstatic void (*error_routine)(const char *err, va_list params) = error_builtin;\nstatic void (*warn_routine)(const char *err, va_list params) = warn_builtin;\n\nvoid set_warning_routine(void (*routine)(const char *err, va_list params))\n{\n\twarn_routine = routine;\n}\n\nvoid usage(const char *err)\n{\n\tusage_routine(err);\n}\n\nvoid die(const char *err, ...)\n{\n\tva_list params;\n\n\tva_start(params, err);\n\tdie_builtin(err, params);\n\tva_end(params);\n}\n\nint error(const char *err, ...)\n{\n\tva_list params;\n\n\tva_start(params, err);\n\terror_routine(err, params);\n\tva_end(params);\n\treturn -1;\n}\n\nvoid warning(const char *warn, ...)\n{\n\tva_list params;\n\n\tva_start(params, warn);\n\twarn_routine(warn, params);\n\tva_end(params);\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/arch/arm/crypto/sha256_neon_glue.c",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/arch/arm/crypto/sha256_glue.c",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/arch/arm/boot/dts/sun4i-a10-inet97fv2.dts",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/arch/m68k/hp300/hp300map.map",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/arch/s390/kernel/ebcdic.c",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/lib/fonts/font_7x14.c",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/lib/fonts/font_8x8.c",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/lib/fonts/font_pearl_8x8.c",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/lib/fonts/font_8x16.c",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/kernel/events/callchain.c",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/drivers/staging/rtl8188eu/include/odm.h",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/drivers/power/reset/ltc2952-poweroff.c",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/drivers/crypto/vmx/ghashp8-ppc.pl",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/drivers/tty/vt/defkeymap.map",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/Documentation/logo.gif",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/Documentation/media/uapi/dvb/intro_files/dvbstb.png",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/Documentation/media/uapi/dvb/intro_files/dvbstb.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/Documentation/media/uapi/v4l/dev-raw-vbi_files/vbi_625.gif",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/Documentation/media/uapi/v4l/dev-raw-vbi_files/vbi_525.gif",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/Documentation/media/uapi/v4l/dev-raw-vbi_files/vbi_hsync.gif",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/Documentation/media/uapi/v4l/dev-raw-vbi_files/vbi_525.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/Documentation/media/uapi/v4l/dev-raw-vbi_files/vbi_hsync.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/Documentation/media/uapi/v4l/dev-raw-vbi_files/vbi_625.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/Documentation/media/uapi/v4l/selection-api-003_files/selection.png",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/Documentation/media/uapi/v4l/crop_files/crop.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/Documentation/media/uapi/v4l/crop_files/crop.gif",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/Documentation/media/uapi/v4l/pixfmt-nv12mt_files/nv12mt.png",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/Documentation/media/uapi/v4l/pixfmt-nv12mt_files/nv12mt_example.png",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/Documentation/media/uapi/v4l/subdev-formats_files/bayer.png",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/Documentation/media/uapi/v4l/field-order_files/fieldseq_tb.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/Documentation/media/uapi/v4l/field-order_files/fieldseq_bt.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/Documentation/media/uapi/v4l/field-order_files/fieldseq_tb.gif",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/Documentation/media/uapi/v4l/field-order_files/fieldseq_bt.gif",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/Documentation/media/uapi/v4l/dev-subdev_files/pipeline.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/Documentation/media/uapi/v4l/dev-subdev_files/subdev-image-processing-crop.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/Documentation/media/uapi/v4l/dev-subdev_files/subdev-image-processing-full.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/Documentation/media/uapi/v4l/dev-subdev_files/subdev-image-processing-scaling-multi-source.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/Documentation/media/uapi/v4l/dev-subdev_files/pipeline.png",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/Documentation/media/uapi/v4l/vidioc-g-selection_files/constraints.png",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/Documentation/media/media_api_files/typical_media_device.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/Documentation/devicetree/bindings/net/nfc/pn544.txt",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/tools/power/cpupower/po/fr.po",
        "/tmp/vanessa/spack-stage/spack-stage-linux-headers-4.9.10-txaztkf254pyjrjqp5r4xuve64keh72k/spack-src/tools/power/cpupower/po/de.po"
    ],
    "total_files": 50920
}