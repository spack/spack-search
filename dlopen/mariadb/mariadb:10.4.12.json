{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/configure.cmake": "# Copyright (c) 2009, 2013, Oracle and/or its affiliates. All rights reserved.\n# \n# This program is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation; version 2 of the License.\n# \n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n# \n# You should have received a copy of the GNU General Public License\n# along with this program; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1335  USA\n#\n\nINCLUDE (CheckCSourceCompiles)\nINCLUDE (CheckCXXSourceCompiles)\nINCLUDE (CheckStructHasMember)\nINCLUDE (CheckLibraryExists)\nINCLUDE (CheckFunctionExists)\nINCLUDE (CheckCCompilerFlag)\nINCLUDE (CheckCSourceRuns)\nINCLUDE (CheckSymbolExists)\n\n\n# WITH_PIC options.Not of much use, PIC is taken care of on platforms\n# where it makes sense anyway.\nIF(UNIX)\n  IF(APPLE)  \n    # OSX  executable are always PIC\n    SET(WITH_PIC ON)\n  ELSE()\n    OPTION(WITH_PIC \"Generate PIC objects\" OFF)\n    IF(WITH_PIC)\n      SET(CMAKE_C_FLAGS \n        \"${CMAKE_C_FLAGS} ${CMAKE_SHARED_LIBRARY_C_FLAGS}\")\n      SET(CMAKE_CXX_FLAGS \n        \"${CMAKE_CXX_FLAGS} ${CMAKE_SHARED_LIBRARY_CXX_FLAGS}\")\n    ENDIF()\n  ENDIF()\nENDIF()\n\n\n\n# System type affects version_compile_os variable \nIF(NOT SYSTEM_TYPE)\n  IF(PLATFORM)\n    SET(SYSTEM_TYPE ${PLATFORM})\n  ELSE()\n    SET(SYSTEM_TYPE ${CMAKE_SYSTEM_NAME})\n  ENDIF()\nENDIF()\n\nIF(CMAKE_CXX_COMPILER_ID MATCHES \"GNU|Clang\" AND (NOT MSVC))\n  IF (CMAKE_EXE_LINKER_FLAGS MATCHES \" -static \" \n     OR CMAKE_EXE_LINKER_FLAGS MATCHES \" -static$\")\n     SET(HAVE_DLOPEN FALSE CACHE \"Disable dlopen due to -static flag\" FORCE)\n     SET(WITHOUT_DYNAMIC_PLUGINS TRUE)\n  ENDIF()\nENDIF()\n\n# workaround for old gcc on x86, gcc atomic ops only work under -march=i686\nIF(CMAKE_SYSTEM_PROCESSOR STREQUAL \"i686\" AND CMAKE_COMPILER_IS_GNUCC AND\n   CMAKE_C_COMPILER_VERSION VERSION_LESS \"4.4.0\")\n  SET(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -march=i686\")\n  SET(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -march=i686\")\n  # query_response_time.cc causes \"error: unable to find a register to spill\"\n  SET(PLUGIN_QUERY_RESPONSE_TIME NO CACHE BOOL \"Disabled, gcc is too old\")\nENDIF()\n\nIF(WITHOUT_DYNAMIC_PLUGINS)\n  MESSAGE(\"Dynamic plugins are disabled.\")\nENDIF(WITHOUT_DYNAMIC_PLUGINS)\n\n# Large files, common flag\nSET(_LARGEFILE_SOURCE  1)\n\n# If finds the size of a type, set SIZEOF_<type> and HAVE_<type>\nFUNCTION(MY_CHECK_TYPE_SIZE type defbase)\n  CHECK_TYPE_SIZE(\"${type}\" SIZEOF_${defbase})\n  IF(SIZEOF_${defbase})\n    SET(HAVE_${defbase} 1 PARENT_SCOPE)\n  ENDIF()\nENDFUNCTION()\n\n# Same for structs, setting HAVE_STRUCT_<name> instead\nFUNCTION(MY_CHECK_STRUCT_SIZE type defbase)\n  CHECK_TYPE_SIZE(\"struct ${type}\" SIZEOF_${defbase})\n  IF(SIZEOF_${defbase})\n    SET(HAVE_STRUCT_${defbase} 1 PARENT_SCOPE)\n  ENDIF()\nENDFUNCTION()\n\n# Searches function in libraries\n# if function is found, sets output parameter result to the name of the library\n# if function is found in libc, result will be empty \nFUNCTION(MY_SEARCH_LIBS func libs result)\n  IF(${${result}})\n    # Library is already found or was predefined\n    RETURN()\n  ENDIF()\n  CHECK_FUNCTION_EXISTS(${func} HAVE_${func}_IN_LIBC)\n  IF(HAVE_${func}_IN_LIBC)\n    SET(${result} \"\" PARENT_SCOPE)\n    RETURN()\n  ENDIF()\n  FOREACH(lib  ${libs})\n    CHECK_LIBRARY_EXISTS(${lib} ${func} \"\" HAVE_${func}_IN_${lib}) \n    IF(HAVE_${func}_IN_${lib})\n      SET(${result} ${lib} PARENT_SCOPE)\n      SET(HAVE_${result} 1 PARENT_SCOPE)\n      RETURN()\n    ENDIF()\n  ENDFOREACH()\nENDFUNCTION()\n\n# Find out which libraries to use.\nIF(UNIX)\n  MY_SEARCH_LIBS(floor m LIBM)\n  IF(NOT LIBM)\n    MY_SEARCH_LIBS(__infinity m LIBM)\n  ENDIF()\n  MY_SEARCH_LIBS(gethostbyname_r  \"nsl_r;nsl\" LIBNSL)\n  MY_SEARCH_LIBS(bind \"bind;socket\" LIBBIND)\n  MY_SEARCH_LIBS(crypt crypt LIBCRYPT)\n  MY_SEARCH_LIBS(setsockopt socket LIBSOCKET)\n  MY_SEARCH_LIBS(dlopen dl LIBDL)\n  MY_SEARCH_LIBS(sched_yield rt LIBRT)\n  IF(NOT LIBRT)\n    MY_SEARCH_LIBS(clock_gettime rt LIBRT)\n  ENDIF()\n  FIND_PACKAGE(Threads)\n\n  SET(CMAKE_REQUIRED_LIBRARIES \n    ${LIBM} ${LIBNSL} ${LIBBIND} ${LIBCRYPT} ${LIBSOCKET} ${LIBDL} ${CMAKE_THREAD_LIBS_INIT} ${LIBRT} ${LIBEXECINFO})\n  # Need explicit pthread for gcc -fsanitize=address\n  IF(CMAKE_USE_PTHREADS_INIT AND CMAKE_C_FLAGS MATCHES \"-fsanitize=\")\n    SET(CMAKE_REQUIRED_LIBRARIES ${CMAKE_REQUIRED_LIBRARIES} pthread)\n  ENDIF()\n\n  IF(CMAKE_REQUIRED_LIBRARIES)\n    LIST(REMOVE_DUPLICATES CMAKE_REQUIRED_LIBRARIES)\n  ENDIF()  \n  LINK_LIBRARIES(${CMAKE_THREAD_LIBS_INIT})\n  \n  OPTION(WITH_LIBWRAP \"Compile with tcp wrappers support\" OFF)\n  IF(WITH_LIBWRAP)\n    SET(SAVE_CMAKE_REQUIRED_LIBRARIES ${CMAKE_REQUIRED_LIBRARIES})\n    SET(CMAKE_REQUIRED_LIBRARIES ${CMAKE_REQUIRED_LIBRARIES} wrap)\n    CHECK_C_SOURCE_COMPILES(\n    \"\n    #include <sys/types.h>\n    #include <tcpd.h>\n    int allow_severity = 0;\n    int deny_severity  = 0;\n    int main()\n    {\n      hosts_access(0);\n    }\"\n    HAVE_LIBWRAP)\n    SET(CMAKE_REQUIRED_LIBRARIES ${SAVE_CMAKE_REQUIRED_LIBRARIES})\n    IF(HAVE_LIBWRAP)\n      SET(MYSYS_LIBWRAP_SOURCE  ${CMAKE_SOURCE_DIR}/mysys/my_libwrap.c)\n      SET(LIBWRAP \"wrap\")\n    ENDIF()\n  ENDIF()\nENDIF()\n\n#\n# Tests for header files\n#\nINCLUDE (CheckIncludeFiles)\nINCLUDE (CheckIncludeFileCXX)\n\nCHECK_INCLUDE_FILES (\"stdlib.h;stdarg.h;string.h;float.h\" STDC_HEADERS)\nCHECK_INCLUDE_FILES (sys/types.h HAVE_SYS_TYPES_H)\nCHECK_INCLUDE_FILES (alloca.h HAVE_ALLOCA_H)\nCHECK_INCLUDE_FILES (arpa/inet.h HAVE_ARPA_INET_H)\nCHECK_INCLUDE_FILES (crypt.h HAVE_CRYPT_H)\nCHECK_INCLUDE_FILES (dirent.h HAVE_DIRENT_H)\nCHECK_INCLUDE_FILES (dlfcn.h HAVE_DLFCN_H)\nCHECK_INCLUDE_FILES (execinfo.h HAVE_EXECINFO_H)\nCHECK_INCLUDE_FILES (fcntl.h HAVE_FCNTL_H)\nCHECK_INCLUDE_FILES (fenv.h HAVE_FENV_H)\nCHECK_INCLUDE_FILES (float.h HAVE_FLOAT_H)\nCHECK_INCLUDE_FILES (fpu_control.h HAVE_FPU_CONTROL_H)\nCHECK_INCLUDE_FILES (grp.h HAVE_GRP_H)\nCHECK_INCLUDE_FILES (ieeefp.h HAVE_IEEEFP_H)\nCHECK_INCLUDE_FILES (inttypes.h HAVE_INTTYPES_H)\nCHECK_INCLUDE_FILES (langinfo.h HAVE_LANGINFO_H)\nCHECK_INCLUDE_FILES (link.h HAVE_LINK_H)\nCHECK_INCLUDE_FILES (linux/unistd.h HAVE_LINUX_UNISTD_H)\nCHECK_INCLUDE_FILES (limits.h HAVE_LIMITS_H)\nCHECK_INCLUDE_FILES (locale.h HAVE_LOCALE_H)\nCHECK_INCLUDE_FILES (malloc.h HAVE_MALLOC_H)\nCHECK_INCLUDE_FILES (memory.h HAVE_MEMORY_H)\nCHECK_INCLUDE_FILES (ndir.h HAVE_NDIR_H)\nCHECK_INCLUDE_FILES (netinet/in.h HAVE_NETINET_IN_H)\nCHECK_INCLUDE_FILES (paths.h HAVE_PATHS_H)\nCHECK_INCLUDE_FILES (poll.h HAVE_POLL_H)\nCHECK_INCLUDE_FILES (sys/poll.h HAVE_SYS_POLL_H)\nCHECK_INCLUDE_FILES (pwd.h HAVE_PWD_H)\nCHECK_INCLUDE_FILES (sched.h HAVE_SCHED_H)\nCHECK_INCLUDE_FILES (select.h HAVE_SELECT_H)\nCHECK_INCLUDE_FILES (\"sys/types.h;sys/dir.h\" HAVE_SYS_DIR_H)\nCHECK_INCLUDE_FILES (\"sys/types.h;sys/event.h\" HAVE_SYS_EVENT_H)\nCHECK_INCLUDE_FILES (sys/ndir.h HAVE_SYS_NDIR_H)\nCHECK_INCLUDE_FILES (sys/pte.h HAVE_SYS_PTE_H)\nCHECK_INCLUDE_FILES (stddef.h HAVE_STDDEF_H)\nCHECK_INCLUDE_FILES (stdint.h HAVE_STDINT_H)\nCHECK_INCLUDE_FILES (stdlib.h HAVE_STDLIB_H)\nCHECK_INCLUDE_FILES (strings.h HAVE_STRINGS_H)\nCHECK_INCLUDE_FILES (string.h HAVE_STRING_H)\nCHECK_INCLUDE_FILES (synch.h HAVE_SYNCH_H)\nCHECK_INCLUDE_FILES (sysent.h HAVE_SYSENT_H)\nCHECK_INCLUDE_FILES (sys/file.h HAVE_SYS_FILE_H)\nCHECK_INCLUDE_FILES (sys/fpu.h HAVE_SYS_FPU_H)\nCHECK_INCLUDE_FILES (sys/ioctl.h HAVE_SYS_IOCTL_H)\nCHECK_INCLUDE_FILES (\"sys/types.h;sys/ipc.h\" HAVE_SYS_IPC_H)\nCHECK_INCLUDE_FILES (\"sys/types.h;sys/malloc.h\" HAVE_SYS_MALLOC_H)\nCHECK_INCLUDE_FILES (sys/mman.h HAVE_SYS_MMAN_H)\nCHECK_INCLUDE_FILES (sys/prctl.h HAVE_SYS_PRCTL_H)\nCHECK_INCLUDE_FILES (sys/resource.h HAVE_SYS_RESOURCE_H)\nCHECK_INCLUDE_FILES (sys/select.h HAVE_SYS_SELECT_H)\nCHECK_INCLUDE_FILES (\"sys/types.h;sys/shm.h\" HAVE_SYS_SHM_H)\nCHECK_INCLUDE_FILES (sys/socket.h HAVE_SYS_SOCKET_H)\nCHECK_INCLUDE_FILES (sys/stat.h HAVE_SYS_STAT_H)\nCHECK_INCLUDE_FILES (sys/stream.h HAVE_SYS_STREAM_H)\nCHECK_INCLUDE_FILES (sys/syscall.h HAVE_SYS_SYSCALL_H)\nCHECK_INCLUDE_FILES (asm/termbits.h HAVE_ASM_TERMBITS_H)\nCHECK_INCLUDE_FILES (termbits.h HAVE_TERMBITS_H)\nCHECK_INCLUDE_FILES (termios.h HAVE_TERMIOS_H)\nCHECK_INCLUDE_FILES (termio.h HAVE_TERMIO_H)\nCHECK_INCLUDE_FILES (termcap.h HAVE_TERMCAP_H)\nCHECK_INCLUDE_FILES (unistd.h HAVE_UNISTD_H)\nCHECK_INCLUDE_FILES (utime.h HAVE_UTIME_H)\nCHECK_INCLUDE_FILES (varargs.h HAVE_VARARGS_H)\nCHECK_INCLUDE_FILES (sys/time.h HAVE_SYS_TIME_H)\nCHECK_INCLUDE_FILES (sys/utime.h HAVE_SYS_UTIME_H)\nCHECK_INCLUDE_FILES (sys/wait.h HAVE_SYS_WAIT_H)\nCHECK_INCLUDE_FILES (sys/param.h HAVE_SYS_PARAM_H)\nCHECK_INCLUDE_FILES (sys/vadvise.h HAVE_SYS_VADVISE_H)\nCHECK_INCLUDE_FILES (fnmatch.h HAVE_FNMATCH_H)\nCHECK_INCLUDE_FILES (stdarg.h  HAVE_STDARG_H)\nCHECK_INCLUDE_FILES (\"stdlib.h;sys/un.h\" HAVE_SYS_UN_H)\nCHECK_INCLUDE_FILES (wchar.h HAVE_WCHAR_H)\nCHECK_INCLUDE_FILES (wctype.h HAVE_WCTYPE_H)\nCHECK_INCLUDE_FILES (sys/sockio.h HAVE_SYS_SOCKIO_H)\nCHECK_INCLUDE_FILES (sys/utsname.h HAVE_SYS_UTSNAME_H)\nCHECK_INCLUDE_FILES (sys/statvfs.h HAVE_SYS_STATVFS_H)\n\nSET(CMAKE_REQUIRED_DEFINITIONS ${CMAKE_REQUIRED_DEFINITIONS} -DPACKAGE=test) # bfd.h is picky\nCHECK_INCLUDE_FILES (bfd.h BFD_H_EXISTS)\nIF(BFD_H_EXISTS)\n  IF(NOT_FOR_DISTRIBUTION)\n    SET(NON_DISTRIBUTABLE_WARNING \"GPLv3\" CACHE INTERNAL \"\")\n    SET(HAVE_BFD_H 1)\n  ENDIF()\nENDIF()\n\nIF(HAVE_SYS_STREAM_H)\n  # Needs sys/stream.h on Solaris\n  CHECK_INCLUDE_FILES (\"sys/stream.h;sys/ptem.h\" HAVE_SYS_PTEM_H)\nELSE()\n  CHECK_INCLUDE_FILES (sys/ptem.h HAVE_SYS_PTEM_H)\nENDIF()\n\n# Figure out threading library\n#\nFIND_PACKAGE (Threads)\n\nFUNCTION(MY_CHECK_PTHREAD_ONCE_INIT)\n  MY_CHECK_C_COMPILER_FLAG(\"-Werror\")\n  IF(NOT have_C__Werror)\n    RETURN()\n  ENDIF()\n  SET(CMAKE_REQUIRED_FLAGS \"${CMAKE_REQUIRED_FLAGS} -Werror\")\n  CHECK_C_SOURCE_COMPILES(\"\n    #include <pthread.h>\n    void foo(void) {}\n    int main()\n    {\n      pthread_once_t once_control = PTHREAD_ONCE_INIT;\n      pthread_once(&once_control, foo);\n      return 0;\n    }\"\n    HAVE_PTHREAD_ONCE_INIT\n  )\n  # http://bugs.opensolaris.org/bugdatabase/printableBug.do?bug_id=6611808\n  IF(NOT HAVE_PTHREAD_ONCE_INIT)\n    CHECK_C_SOURCE_COMPILES(\"\n      #include <pthread.h>\n      void foo(void) {}\n      int main()\n      {\n        pthread_once_t once_control = { PTHREAD_ONCE_INIT };\n        pthread_once(&once_control, foo);\n        return 0;\n      }\"\n      HAVE_ARRAY_PTHREAD_ONCE_INIT\n    )\n  ENDIF()\n  IF(HAVE_PTHREAD_ONCE_INIT)\n    SET(PTHREAD_ONCE_INITIALIZER \"PTHREAD_ONCE_INIT\" PARENT_SCOPE)\n  ENDIF()\n  IF(HAVE_ARRAY_PTHREAD_ONCE_INIT)\n    SET(PTHREAD_ONCE_INITIALIZER \"{ PTHREAD_ONCE_INIT }\" PARENT_SCOPE)\n  ENDIF()\nENDFUNCTION()\n\nIF(CMAKE_USE_PTHREADS_INIT)\n  MY_CHECK_PTHREAD_ONCE_INIT()\nENDIF()\n\n#\n# Tests for functions\n#\nCHECK_FUNCTION_EXISTS (accept4 HAVE_ACCEPT4)\nCHECK_FUNCTION_EXISTS (access HAVE_ACCESS)\n#CHECK_FUNCTION_EXISTS (aiowait HAVE_AIOWAIT)\nCHECK_FUNCTION_EXISTS (alarm HAVE_ALARM)\nSET(HAVE_ALLOCA 1)\nCHECK_FUNCTION_EXISTS (backtrace HAVE_BACKTRACE)\nCHECK_FUNCTION_EXISTS (backtrace_symbols HAVE_BACKTRACE_SYMBOLS)\nCHECK_FUNCTION_EXISTS (backtrace_symbols_fd HAVE_BACKTRACE_SYMBOLS_FD)\nCHECK_FUNCTION_EXISTS (printstack HAVE_PRINTSTACK)\nCHECK_FUNCTION_EXISTS (bfill HAVE_BFILL)\nCHECK_FUNCTION_EXISTS (index HAVE_INDEX)\nCHECK_FUNCTION_EXISTS (clock_gettime HAVE_CLOCK_GETTIME)\nCHECK_FUNCTION_EXISTS (cuserid HAVE_CUSERID)\nCHECK_FUNCTION_EXISTS (ftruncate HAVE_FTRUNCATE)\nCHECK_FUNCTION_EXISTS (compress HAVE_COMPRESS)\nCHECK_FUNCTION_EXISTS (crypt HAVE_CRYPT)\nCHECK_FUNCTION_EXISTS (dladdr HAVE_DLADDR)\nCHECK_FUNCTION_EXISTS (dlerror HAVE_DLERROR)\nCHECK_FUNCTION_EXISTS (dlopen HAVE_DLOPEN)\nCHECK_FUNCTION_EXISTS (fchmod HAVE_FCHMOD)\nCHECK_FUNCTION_EXISTS (fcntl HAVE_FCNTL)\nCHECK_FUNCTION_EXISTS (fdatasync HAVE_FDATASYNC)\nCHECK_SYMBOL_EXISTS(fdatasync \"unistd.h\" HAVE_DECL_FDATASYNC)\nCHECK_FUNCTION_EXISTS (fesetround HAVE_FESETROUND)\nCHECK_FUNCTION_EXISTS (fedisableexcept HAVE_FEDISABLEEXCEPT)\nCHECK_FUNCTION_EXISTS (fseeko HAVE_FSEEKO)\nCHECK_FUNCTION_EXISTS (fsync HAVE_FSYNC)\nCHECK_FUNCTION_EXISTS (getcwd HAVE_GETCWD)\nCHECK_FUNCTION_EXISTS (gethostbyaddr_r HAVE_GETHOSTBYADDR_R)\nCHECK_FUNCTION_EXISTS (gethrtime HAVE_GETHRTIME)\nCHECK_FUNCTION_EXISTS (getpass HAVE_GETPASS)\nCHECK_FUNCTION_EXISTS (getpassphrase HAVE_GETPASSPHRASE)\nCHECK_FUNCTION_EXISTS (getpwnam HAVE_GETPWNAM)\nCHECK_FUNCTION_EXISTS (getpwuid HAVE_GETPWUID)\nCHECK_FUNCTION_EXISTS (getrlimit HAVE_GETRLIMIT)\nCHECK_FUNCTION_EXISTS (getifaddrs HAVE_GETIFADDRS)\nCHECK_FUNCTION_EXISTS (getrusage HAVE_GETRUSAGE)\nCHECK_FUNCTION_EXISTS (getwd HAVE_GETWD)\nCHECK_FUNCTION_EXISTS (gmtime_r HAVE_GMTIME_R)\nCHECK_FUNCTION_EXISTS (initgroups HAVE_INITGROUPS)\nCHECK_FUNCTION_EXISTS (ldiv HAVE_LDIV)\nCHECK_FUNCTION_EXISTS (localtime_r HAVE_LOCALTIME_R)\nCHECK_FUNCTION_EXISTS (lstat HAVE_LSTAT)\nCHECK_FUNCTION_EXISTS (madvise HAVE_MADVISE)\nCHECK_FUNCTION_EXISTS (mallinfo HAVE_MALLINFO)\nCHECK_FUNCTION_EXISTS (memcpy HAVE_MEMCPY)\nCHECK_FUNCTION_EXISTS (memmove HAVE_MEMMOVE)\nCHECK_FUNCTION_EXISTS (mkstemp HAVE_MKSTEMP)\nCHECK_FUNCTION_EXISTS (mkostemp HAVE_MKOSTEMP)\nCHECK_FUNCTION_EXISTS (mlock HAVE_MLOCK)\nCHECK_FUNCTION_EXISTS (mlockall HAVE_MLOCKALL)\nCHECK_FUNCTION_EXISTS (mmap HAVE_MMAP)\nCHECK_FUNCTION_EXISTS (mmap64 HAVE_MMAP64)\nCHECK_FUNCTION_EXISTS (perror HAVE_PERROR)\nCHECK_FUNCTION_EXISTS (poll HAVE_POLL)\nCHECK_FUNCTION_EXISTS (posix_fallocate HAVE_POSIX_FALLOCATE)\nCHECK_FUNCTION_EXISTS (pread HAVE_PREAD)\nCHECK_FUNCTION_EXISTS (pthread_attr_create HAVE_PTHREAD_ATTR_CREATE)\nCHECK_FUNCTION_EXISTS (pthread_attr_getstacksize HAVE_PTHREAD_ATTR_GETSTACKSIZE)\nCHECK_FUNCTION_EXISTS (pthread_attr_setscope HAVE_PTHREAD_ATTR_SETSCOPE)\nCHECK_FUNCTION_EXISTS (pthread_attr_getguardsize HAVE_PTHREAD_ATTR_GETGUARDSIZE)\nCHECK_FUNCTION_EXISTS (pthread_attr_setstacksize HAVE_PTHREAD_ATTR_SETSTACKSIZE)\nCHECK_FUNCTION_EXISTS (pthread_condattr_create HAVE_PTHREAD_CONDATTR_CREATE)\nCHECK_FUNCTION_EXISTS (pthread_key_delete HAVE_PTHREAD_KEY_DELETE)\nCHECK_FUNCTION_EXISTS (pthread_rwlock_rdlock HAVE_PTHREAD_RWLOCK_RDLOCK)\nCHECK_FUNCTION_EXISTS (pthread_sigmask HAVE_PTHREAD_SIGMASK)\nCHECK_FUNCTION_EXISTS (pthread_yield_np HAVE_PTHREAD_YIELD_NP)\nCHECK_FUNCTION_EXISTS (putenv HAVE_PUTENV)\nCHECK_FUNCTION_EXISTS (readlink HAVE_READLINK)\nCHECK_FUNCTION_EXISTS (realpath HAVE_REALPATH)\nCHECK_FUNCTION_EXISTS (rename HAVE_RENAME)\nCHECK_FUNCTION_EXISTS (rwlock_init HAVE_RWLOCK_INIT)\nCHECK_FUNCTION_EXISTS (sched_yield HAVE_SCHED_YIELD)\nCHECK_FUNCTION_EXISTS (setenv HAVE_SETENV)\nCHECK_FUNCTION_EXISTS (setlocale HAVE_SETLOCALE)\nCHECK_FUNCTION_EXISTS (sigaction HAVE_SIGACTION)\nCHECK_FUNCTION_EXISTS (sigthreadmask HAVE_SIGTHREADMASK)\nCHECK_FUNCTION_EXISTS (sigwait HAVE_SIGWAIT)\nCHECK_FUNCTION_EXISTS (sigwaitinfo HAVE_SIGWAITINFO)\nCHECK_FUNCTION_EXISTS (sigset HAVE_SIGSET)\nCHECK_FUNCTION_EXISTS (sleep HAVE_SLEEP)\nCHECK_FUNCTION_EXISTS (snprintf HAVE_SNPRINTF)\nCHECK_FUNCTION_EXISTS (stpcpy HAVE_STPCPY)\nCHECK_FUNCTION_EXISTS (strcoll HAVE_STRCOLL)\nCHECK_FUNCTION_EXISTS (strerror HAVE_STRERROR)\nCHECK_FUNCTION_EXISTS (strnlen HAVE_STRNLEN)\nCHECK_FUNCTION_EXISTS (strpbrk HAVE_STRPBRK)\nCHECK_FUNCTION_EXISTS (strtok_r HAVE_STRTOK_R)\nCHECK_FUNCTION_EXISTS (strtoll HAVE_STRTOLL)\nCHECK_FUNCTION_EXISTS (strtoul HAVE_STRTOUL)\nCHECK_FUNCTION_EXISTS (strtoull HAVE_STRTOULL)\nCHECK_FUNCTION_EXISTS (strcasecmp HAVE_STRCASECMP)\nCHECK_FUNCTION_EXISTS (tell HAVE_TELL)\nCHECK_FUNCTION_EXISTS (thr_setconcurrency HAVE_THR_SETCONCURRENCY)\nCHECK_FUNCTION_EXISTS (thr_yield HAVE_THR_YIELD)\nCHECK_FUNCTION_EXISTS (vasprintf HAVE_VASPRINTF)\nCHECK_FUNCTION_EXISTS (vsnprintf HAVE_VSNPRINTF)\nCHECK_FUNCTION_EXISTS (memalign HAVE_MEMALIGN)\nCHECK_FUNCTION_EXISTS (nl_langinfo HAVE_NL_LANGINFO)\n\nIF(HAVE_SYS_EVENT_H)\nCHECK_FUNCTION_EXISTS (kqueue HAVE_KQUEUE)\nENDIF()\n\n# readdir_r might exist, but be marked deprecated\nSET(CMAKE_REQUIRED_FLAGS -Werror)\nCHECK_CXX_SOURCE_COMPILES(\n\"#include  <dirent.h>\nint main() {\n  readdir_r(0,0,0);\n  return 0;\n  }\" HAVE_READDIR_R)\nSET(CMAKE_REQUIRED_FLAGS)\n\n#--------------------------------------------------------------------\n# Support for WL#2373 (Use cycle counter for timing)\n#--------------------------------------------------------------------\n\nCHECK_INCLUDE_FILES(time.h HAVE_TIME_H)\nCHECK_INCLUDE_FILES(sys/time.h HAVE_SYS_TIME_H)\nCHECK_INCLUDE_FILES(sys/times.h HAVE_SYS_TIMES_H)\n\nCHECK_INCLUDE_FILES(ia64intrin.h HAVE_IA64INTRIN_H)\n\nCHECK_FUNCTION_EXISTS(times HAVE_TIMES)\nCHECK_FUNCTION_EXISTS(gettimeofday HAVE_GETTIMEOFDAY)\nCHECK_FUNCTION_EXISTS(read_real_time HAVE_READ_REAL_TIME)\n# This should work on AIX.\n\nCHECK_FUNCTION_EXISTS(ftime HAVE_FTIME)\n# This is still a normal call for milliseconds.\n\nCHECK_FUNCTION_EXISTS(time HAVE_TIME)\n# We can use time() on Macintosh if there is no ftime().\n\n\n#\n# Tests for symbols\n#\n\n#CHECK_SYMBOL_EXISTS(sys_errlist \"stdio.h\" HAVE_SYS_ERRLIST)\nCHECK_SYMBOL_EXISTS(madvise \"sys/mman.h\" HAVE_DECL_MADVISE)\nCHECK_SYMBOL_EXISTS(tzname \"time.h\" HAVE_TZNAME)\nCHECK_SYMBOL_EXISTS(lrand48 \"stdlib.h\" HAVE_LRAND48)\nCHECK_SYMBOL_EXISTS(getpagesize \"unistd.h\" HAVE_GETPAGESIZE)\nCHECK_SYMBOL_EXISTS(TIOCGWINSZ \"sys/ioctl.h\" GWINSZ_IN_SYS_IOCTL)\nCHECK_SYMBOL_EXISTS(FIONREAD \"sys/ioctl.h\" FIONREAD_IN_SYS_IOCTL)\nCHECK_SYMBOL_EXISTS(TIOCSTAT \"sys/ioctl.h\" TIOCSTAT_IN_SYS_IOCTL)\nCHECK_SYMBOL_EXISTS(FIONREAD \"sys/filio.h\" FIONREAD_IN_SYS_FILIO)\nCHECK_SYMBOL_EXISTS(gettimeofday \"sys/time.h\" HAVE_GETTIMEOFDAY)\n\n#\n# Test for endianness\n#\nINCLUDE(TestBigEndian)\nIF(APPLE)\n  # Cannot run endian test on universal PPC/Intel binaries \n  # would return inconsistent result.\n  # config.h.cmake includes a special #ifdef for Darwin\nELSE()\n  TEST_BIG_ENDIAN(WORDS_BIGENDIAN)\nENDIF()\n\n#\n# Tests for type sizes (and presence)\n#\nINCLUDE (CheckTypeSize)\nset(CMAKE_REQUIRED_DEFINITIONS ${CMAKE_REQUIRED_DEFINITIONS}\n        -D_LARGEFILE_SOURCE -D_LARGE_FILES -D_FILE_OFFSET_BITS=64\n        -D__STDC_LIMIT_MACROS -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS)\nSET(CMAKE_EXTRA_INCLUDE_FILES signal.h)\nMY_CHECK_TYPE_SIZE(sigset_t SIGSET_T)\nIF(NOT SIZEOF_SIGSET_T)\n SET(sigset_t int)\nENDIF()\nMY_CHECK_TYPE_SIZE(mode_t MODE_T)\nIF(NOT SIZEOF_MODE_T)\n SET(mode_t int)\nENDIF()\nMY_CHECK_TYPE_SIZE(sighandler_t SIGHANDLER_T)\n\nIF(HAVE_NETINET_IN_H)\n  SET(CMAKE_EXTRA_INCLUDE_FILES netinet/in.h)\n  MY_CHECK_TYPE_SIZE(in_addr_t IN_ADDR_T)\nENDIF(HAVE_NETINET_IN_H)\n\nIF(HAVE_STDINT_H)\n  SET(CMAKE_EXTRA_INCLUDE_FILES stdint.h)\nENDIF(HAVE_STDINT_H)\n\nSET(HAVE_VOIDP 1)\nSET(HAVE_CHARP 1)\nSET(HAVE_LONG 1)\n\nIF(NOT APPLE)\nMY_CHECK_TYPE_SIZE(\"void *\" VOIDP)\nMY_CHECK_TYPE_SIZE(\"char *\" CHARP)\nMY_CHECK_TYPE_SIZE(long LONG)\nMY_CHECK_TYPE_SIZE(size_t SIZE_T)\nENDIF()\n\nMY_CHECK_TYPE_SIZE(short SHORT)\nMY_CHECK_TYPE_SIZE(int INT)\nMY_CHECK_TYPE_SIZE(\"long long\" LONG_LONG)\nSET(CMAKE_EXTRA_INCLUDE_FILES stdio.h sys/types.h)\nMY_CHECK_TYPE_SIZE(off_t OFF_T)\nMY_CHECK_TYPE_SIZE(uchar UCHAR)\nMY_CHECK_TYPE_SIZE(uint UINT)\nMY_CHECK_TYPE_SIZE(ulong ULONG)\nMY_CHECK_TYPE_SIZE(int8 INT8)\nMY_CHECK_TYPE_SIZE(uint8 UINT8)\nMY_CHECK_TYPE_SIZE(int16 INT16)\nMY_CHECK_TYPE_SIZE(uint16 UINT16)\nMY_CHECK_TYPE_SIZE(int32 INT32)\nMY_CHECK_TYPE_SIZE(uint32 UINT32)\nMY_CHECK_TYPE_SIZE(int64 INT64)\nMY_CHECK_TYPE_SIZE(uint64 UINT64)\nMY_CHECK_TYPE_SIZE(time_t TIME_T)\nSET (CMAKE_EXTRA_INCLUDE_FILES sys/types.h)\nSET(CMAKE_EXTRA_INCLUDE_FILES)\nIF(HAVE_SYS_SOCKET_H)\n  SET(CMAKE_EXTRA_INCLUDE_FILES sys/socket.h)\nENDIF(HAVE_SYS_SOCKET_H)\nSET(CMAKE_EXTRA_INCLUDE_FILES)\n\nIF(HAVE_IEEEFP_H)\n  SET(CMAKE_EXTRA_INCLUDE_FILES ieeefp.h)\n  MY_CHECK_TYPE_SIZE(fp_except FP_EXCEPT)\nENDIF()\n\n\n#\n# Code tests\n#\n\n# check whether time_t is unsigned\nCHECK_C_SOURCE_COMPILES(\"\n#include <time.h>\nint main()\n{\n  int array[(((time_t)-1) > 0) ? 1 : -1];\n  return 0;\n}\"\nTIME_T_UNSIGNED)\n\nCHECK_C_SOURCE_COMPILES(\"\n#ifdef _WIN32\n#include <winsock2.h>\n#include <ws2tcpip.h>\n#else\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netdb.h>\n#endif\nint main()\n{\n  select(0,0,0,0,0);\n  return 0;\n}\"\nHAVE_SELECT)\n\n#\n# Check if timespec has ts_sec and ts_nsec fields\n#\n\nCHECK_C_SOURCE_COMPILES(\"\n#include <pthread.h>\n\nint main(int ac, char **av)\n{\n  struct timespec abstime;\n  abstime.ts_sec = time(NULL)+1;\n  abstime.ts_nsec = 0;\n}\n\" HAVE_TIMESPEC_TS_SEC)\n\n\n#\n# Check return type of qsort()\n#\nCHECK_C_SOURCE_COMPILES(\"\n#include <stdlib.h>\n#ifdef __cplusplus\nextern \\\"C\\\"\n#endif\nvoid qsort(void *base, size_t nel, size_t width,\n  int (*compar) (const void *, const void *));\nint main(int ac, char **av) {}\n\" QSORT_TYPE_IS_VOID)\nIF(QSORT_TYPE_IS_VOID)\n  SET(RETQSORTTYPE \"void\")\nELSE(QSORT_TYPE_IS_VOID)\n  SET(RETQSORTTYPE \"int\")\nENDIF(QSORT_TYPE_IS_VOID)\n\nIF(WIN32)\nSET(SOCKET_SIZE_TYPE int)\nELSE()\nCHECK_CXX_SOURCE_COMPILES(\"\n#include <sys/socket.h>\nint main(int argc, char **argv)\n{\n  getsockname(0,0,(socklen_t *) 0);\n  return 0; \n}\"\nHAVE_SOCKET_SIZE_T_AS_socklen_t)\n\nIF(HAVE_SOCKET_SIZE_T_AS_socklen_t)\n  SET(SOCKET_SIZE_TYPE socklen_t)\nELSE()\n  CHECK_CXX_SOURCE_COMPILES(\"\n  #include <sys/socket.h>\n  int main(int argc, char **argv)\n  {\n    getsockname(0,0,(int *) 0);\n    return 0; \n  }\"\n  HAVE_SOCKET_SIZE_T_AS_int)\n  IF(HAVE_SOCKET_SIZE_T_AS_int)\n    SET(SOCKET_SIZE_TYPE int)\n  ELSE()\n    CHECK_CXX_SOURCE_COMPILES(\"\n    #include <sys/socket.h>\n    int main(int argc, char **argv)\n    {\n      getsockname(0,0,(size_t *) 0);\n      return 0; \n    }\"\n    HAVE_SOCKET_SIZE_T_AS_size_t)\n    IF(HAVE_SOCKET_SIZE_T_AS_size_t)\n      SET(SOCKET_SIZE_TYPE size_t)\n    ELSE()\n      SET(SOCKET_SIZE_TYPE int)\n    ENDIF()\n  ENDIF()\nENDIF()\nENDIF()\n\nCHECK_CXX_SOURCE_COMPILES(\"\n#include <pthread.h>\nint main()\n{\n  pthread_yield();\n  return 0;\n}\n\" HAVE_PTHREAD_YIELD_ZERO_ARG)\n\nIF(NOT STACK_DIRECTION)\n  IF(CMAKE_CROSSCOMPILING)\n   MESSAGE(FATAL_ERROR \n   \"STACK_DIRECTION is not defined.  Please specify -DSTACK_DIRECTION=1 \"\n   \"or -DSTACK_DIRECTION=-1 when calling cmake.\")\n  ELSE()\n    TRY_RUN(STACKDIR_RUN_RESULT STACKDIR_COMPILE_RESULT    \n     ${CMAKE_BINARY_DIR} \n     ${CMAKE_SOURCE_DIR}/cmake/stack_direction.c\n     )\n     # Test program returns 0 (down) or 1 (up).\n     # Convert to -1 or 1\n     IF(STACKDIR_RUN_RESULT EQUAL 0)\n       SET(STACK_DIRECTION -1 CACHE INTERNAL \"Stack grows direction\")\n     ELSE()\n       SET(STACK_DIRECTION 1 CACHE INTERNAL \"Stack grows direction\")\n     ENDIF()\n     MESSAGE(STATUS \"Checking stack direction : ${STACK_DIRECTION}\")\n   ENDIF()\nENDIF()\n\n#\n# Check return type of signal handlers\n#\nCHECK_C_SOURCE_COMPILES(\"\n#include <signal.h>\n#ifdef signal\n# undef signal\n#endif\n#ifdef __cplusplus\nextern \\\"C\\\" void (*signal (int, void (*)(int)))(int);\n#else\nvoid (*signal ()) ();\n#endif\nint main(int ac, char **av) {}\n\" SIGNAL_RETURN_TYPE_IS_VOID)\nIF(SIGNAL_RETURN_TYPE_IS_VOID)\n  SET(RETSIGTYPE void)\n  SET(VOID_SIGHANDLER 1)\nELSE(SIGNAL_RETURN_TYPE_IS_VOID)\n  SET(RETSIGTYPE int)\nENDIF(SIGNAL_RETURN_TYPE_IS_VOID)\n\n\nCHECK_INCLUDE_FILES(\"time.h;sys/time.h\" TIME_WITH_SYS_TIME)\nCHECK_SYMBOL_EXISTS(O_NONBLOCK \"unistd.h;fcntl.h\" HAVE_FCNTL_NONBLOCK)\nIF(NOT HAVE_FCNTL_NONBLOCK)\n SET(NO_FCNTL_NONBLOCK 1)\nENDIF()\n\n#\n# Test for how the C compiler does inline, if at all\n#\n# SunPro is weird, apparently it only supports inline at -xO3 or -xO4.\n# And if CMAKE_C_FLAGS has -xO4 but CMAKE_C_FLAGS_${CMAKE_BUILD_TYPE} has -xO2\n# then CHECK_C_SOURCE_COMPILES will succeed but the built will fail.\n# We must test all flags here.\n# XXX actually, we can do this for all compilers, not only SunPro\nIF (CMAKE_CXX_COMPILER_ID MATCHES \"SunPro\" AND\n    CMAKE_GENERATOR MATCHES \"Makefiles\")\n  STRING(TOUPPER \"CMAKE_C_FLAGS_${CMAKE_BUILD_TYPE}\" flags)\n  SET(CMAKE_REQUIRED_FLAGS \"${${flags}}\")\nENDIF()\nCHECK_C_SOURCE_COMPILES(\"\nextern int bar(int x);\nstatic inline int foo(){return bar(1);}\nint main(int argc, char *argv[]){return 0;}\"\n                            C_HAS_inline)\nIF(NOT C_HAS_inline)\n  CHECK_C_SOURCE_COMPILES(\"\n  extern int bar(int x);\n  static __inline int foo(){return bar(1);}\n  int main(int argc, char *argv[]){return 0;}\"\n                            C_HAS___inline)\n  IF(C_HAS___inline)\n    SET(C_INLINE __inline)\n  ElSE()\n    SET(C_INLINE)\n    MESSAGE(WARNING \"C compiler does not support funcion inlining\")\n    IF(NOT NOINLINE)\n      MESSAGE(FATAL_ERROR \"Use -DNOINLINE=TRUE to allow compilation without inlining\")\n    ENDIF()\n  ENDIF()\nENDIF()\n\nCHECK_SYMBOL_EXISTS(tcgetattr \"termios.h\" HAVE_TCGETATTR 1)\n\n#\n# Check type of signal routines (posix, 4.2bsd, 4.1bsd or v7)\n#\nCHECK_C_SOURCE_COMPILES(\"\n  #include <signal.h>\n  int main(int ac, char **av)\n  {\n    sigset_t ss;\n    struct sigaction sa;\n    sigemptyset(&ss); sigsuspend(&ss);\n    sigaction(SIGINT, &sa, (struct sigaction *) 0);\n    sigprocmask(SIG_BLOCK, &ss, (sigset_t *) 0);\n  }\"\n  HAVE_POSIX_SIGNALS)\n\nIF(NOT HAVE_POSIX_SIGNALS)\n CHECK_C_SOURCE_COMPILES(\"\n  #include <signal.h>\n  int main(int ac, char **av)\n  {\n    int mask = sigmask(SIGINT);\n    sigsetmask(mask); sigblock(mask); sigpause(mask);\n  }\"\n  HAVE_BSD_SIGNALS)\nENDIF(NOT HAVE_POSIX_SIGNALS)\n\n# Assume regular sprintf\nSET(SPRINTFS_RETURNS_INT 1)\n\nIF(CMAKE_CXX_COMPILER_ID MATCHES \"GNU|Clang\")\nCHECK_CXX_SOURCE_COMPILES(\"\n #include <cxxabi.h>\n int main(int argc, char **argv) \n  {\n    char *foo= 0; int bar= 0;\n    foo= abi::__cxa_demangle(foo, foo, 0, &bar);\n    return 0;\n  }\"\n  HAVE_ABI_CXA_DEMANGLE)\nENDIF()\n\nCHECK_C_SOURCE_COMPILES(\"\n  int main(int argc, char **argv) \n  {\n    extern char *__bss_start;\n    return __bss_start ? 1 : 0;\n  }\"\nHAVE_BSS_START)\n\nCHECK_C_SOURCE_COMPILES(\"\n    int main()\n    {\n      extern void __attribute__((weak)) foo(void);\n      return 0;\n    }\"\n    HAVE_WEAK_SYMBOL\n)\n\nCHECK_C_SOURCE_COMPILES(\"\n    void foo(int *x) { }\n    int main() {\n      int a __attribute__((cleanup(foo)));\n      return 0;\n    }\"\n    HAVE_ATTRIBUTE_CLEANUP\n)\n\nCHECK_CXX_SOURCE_COMPILES(\"\n    #include <new>\n    int main()\n    {\n     char *c = new char;\n     return 0;\n    }\"\n    HAVE_CXX_NEW\n)\n\nCHECK_CXX_SOURCE_COMPILES(\"\n    #undef inline\n    #if !defined(SCO) && !defined(__osf__) && !defined(_REENTRANT)\n    #define _REENTRANT\n    #endif\n    #include <pthread.h>\n    #include <sys/types.h>\n    #include <sys/socket.h>\n    #include <netinet/in.h>\n    #include <arpa/inet.h>\n    #include <netdb.h>\n    int main()\n    {\n\n       struct hostent *foo =\n       gethostbyaddr_r((const char *) 0,\n          0, 0, (struct hostent *) 0, (char *) NULL,  0, (int *)0);\n       return 0;\n    }\n  \"\n  HAVE_SOLARIS_STYLE_GETHOST)\n\nSET(NO_ALARM 1 CACHE BOOL  \"No need to use alarm to implement timeout\")\n\n# As a consequence of ALARMs no longer being used, thread\n# notification for KILL must close the socket to wake up\n# other threads.\nSET(SIGNAL_WITH_VIO_CLOSE 1)\n\nMARK_AS_ADVANCED(NO_ALARM)\n\n\nCHECK_CXX_SOURCE_COMPILES(\"\nint main()\n{\n  long long int var= 1;\n  long long int *ptr= &var;\n  return (int)__atomic_load_n(ptr, __ATOMIC_SEQ_CST);\n}\"\nHAVE_GCC_C11_ATOMICS)\n\nIF(WITH_VALGRIND)\n  SET(HAVE_valgrind 1)\nENDIF()\n\nCHECK_INCLUDE_FILES(\"valgrind/memcheck.h;valgrind/valgrind.h\" \n  HAVE_VALGRIND_MEMCHECK_H)\n\n#--------------------------------------------------------------------\n# Check for IPv6 support\n#--------------------------------------------------------------------\nCHECK_INCLUDE_FILE(netinet/in6.h HAVE_NETINET_IN6_H)\n\nIF(UNIX)\n  SET(CMAKE_EXTRA_INCLUDE_FILES sys/types.h netinet/in.h sys/socket.h)\n  IF(HAVE_NETINET_IN6_H)\n    SET(CMAKE_EXTRA_INCLUDE_FILES ${CMAKE_EXTRA_INCLUDE_FILES} netinet/in6.h)\n  ENDIF()\nELSEIF(WIN32)\n  SET(CMAKE_EXTRA_INCLUDE_FILES ${CMAKE_EXTRA_INCLUDE_FILES} winsock2.h ws2ipdef.h)\nENDIF()\n\nMY_CHECK_STRUCT_SIZE(\"sockaddr_in6\" SOCKADDR_IN6)\nMY_CHECK_STRUCT_SIZE(\"in6_addr\" IN6_ADDR)\n\nIF(HAVE_STRUCT_SOCKADDR_IN6 OR HAVE_STRUCT_IN6_ADDR)\n  SET(HAVE_IPV6 TRUE CACHE INTERNAL \"\")\nENDIF()\n\n\n# Check for sockaddr_storage.ss_family\n# It is called differently under OS400 and older AIX\n\nCHECK_STRUCT_HAS_MEMBER(\"struct sockaddr_storage\"\n ss_family \"${CMAKE_EXTRA_INCLUDE_FILES}\" HAVE_SOCKADDR_STORAGE_SS_FAMILY)\nIF(NOT HAVE_SOCKADDR_STORAGE_SS_FAMILY)\n  CHECK_STRUCT_HAS_MEMBER(\"struct sockaddr_storage\"\n  __ss_family \"${CMAKE_EXTRA_INCLUDE_FILES}\" HAVE_SOCKADDR_STORAGE___SS_FAMILY)\n  IF(HAVE_SOCKADDR_STORAGE___SS_FAMILY)\n    SET(ss_family __ss_family)\n  ENDIF()\nENDIF()\n\n#\n# Check if struct sockaddr_in::sin_len is available.\n#\n\nCHECK_STRUCT_HAS_MEMBER(\"struct sockaddr_in\" sin_len\n  \"${CMAKE_EXTRA_INCLUDE_FILES}\" HAVE_SOCKADDR_IN_SIN_LEN)\n\n#\n# Check if struct sockaddr_in6::sin6_len is available.\n#\n\nCHECK_STRUCT_HAS_MEMBER(\"struct sockaddr_in6\" sin6_len\n  \"${CMAKE_EXTRA_INCLUDE_FILES}\" HAVE_SOCKADDR_IN6_SIN6_LEN)\n\nSET(CMAKE_EXTRA_INCLUDE_FILES) \n\nCHECK_STRUCT_HAS_MEMBER(\"struct dirent\" d_ino \"dirent.h\"  STRUCT_DIRENT_HAS_D_INO)\nCHECK_STRUCT_HAS_MEMBER(\"struct dirent\" d_namlen \"dirent.h\"  STRUCT_DIRENT_HAS_D_NAMLEN)\nSET(SPRINTF_RETURNS_INT 1)\nCHECK_INCLUDE_FILE(ucontext.h HAVE_FILE_UCONTEXT_H)\nIF(NOT HAVE_FILE_UCONTEXT_H)\n  CHECK_INCLUDE_FILE(sys/ucontext.h HAVE_FILE_UCONTEXT_H)\nENDIF()\nIF(HAVE_FILE_UCONTEXT_H)\n  CHECK_FUNCTION_EXISTS(makecontext HAVE_UCONTEXT_H)\nENDIF()\n\nCHECK_STRUCT_HAS_MEMBER(\"struct timespec\" tv_sec \"time.h\" STRUCT_TIMESPEC_HAS_TV_SEC)\nCHECK_STRUCT_HAS_MEMBER(\"struct timespec\" tv_nsec \"time.h\" STRUCT_TIMESPEC_HAS_TV_NSEC)\n\nIF(NOT MSVC)\n  CHECK_C_SOURCE_COMPILES(\n  \"\n  #define _GNU_SOURCE\n  #include <fcntl.h>\n  #include <linux/falloc.h>\n  int main()\n  {\n    /* Ignore the return value for now. Check if the flags exist.\n    The return value is checked  at runtime. */\n    fallocate(0, FALLOC_FL_PUNCH_HOLE | FALLOC_FL_KEEP_SIZE, 0, 0);\n\n    return(0);\n  }\"\n  HAVE_FALLOC_PUNCH_HOLE_AND_KEEP_SIZE\n  )\nENDIF()\n",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/rocksdb/rocksdb/env/env_posix.cc": "//  Copyright (c) 2011-present, Facebook, Inc.  All rights reserved.\n//  This source code is licensed under both the GPLv2 (found in the\n//  COPYING file in the root directory) and Apache 2.0 License\n//  (found in the LICENSE.Apache file in the root directory).\n//\n// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file. See the AUTHORS file for names of contributors\n#include <dirent.h>\n#ifndef ROCKSDB_NO_DYNAMIC_EXTENSION\n#include <dlfcn.h>\n#endif\n#include <errno.h>\n#include <fcntl.h>\n\n#if defined(OS_LINUX)\n#include <linux/fs.h>\n#endif\n#include <pthread.h>\n#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/ioctl.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#if defined(OS_LINUX) || defined(OS_SOLARIS) || defined(OS_ANDROID)\n#include <sys/statfs.h>\n#include <sys/syscall.h>\n#include <sys/sysmacros.h>\n#endif\n#include <sys/statvfs.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <time.h>\n#include <algorithm>\n// Get nano time includes\n#if defined(OS_LINUX) || defined(OS_FREEBSD)\n#elif defined(__MACH__)\n#include <mach/clock.h>\n#include <mach/mach.h>\n#else\n#include <chrono>\n#endif\n#include <deque>\n#include <set>\n#include <vector>\n\n#include \"env/io_posix.h\"\n#include \"logging/logging.h\"\n#include \"logging/posix_logger.h\"\n#include \"monitoring/iostats_context_imp.h\"\n#include \"monitoring/thread_status_updater.h\"\n#include \"port/port.h\"\n#include \"rocksdb/options.h\"\n#include \"rocksdb/slice.h\"\n#include \"test_util/sync_point.h\"\n#include \"util/coding.h\"\n#include \"util/compression_context_cache.h\"\n#include \"util/random.h\"\n#include \"util/string_util.h\"\n#include \"util/thread_local.h\"\n#include \"util/threadpool_imp.h\"\n\n#if !defined(TMPFS_MAGIC)\n#define TMPFS_MAGIC 0x01021994\n#endif\n#if !defined(XFS_SUPER_MAGIC)\n#define XFS_SUPER_MAGIC 0x58465342\n#endif\n#if !defined(EXT4_SUPER_MAGIC)\n#define EXT4_SUPER_MAGIC 0xEF53\n#endif\n\nnamespace rocksdb {\n#if defined(OS_WIN)\nstatic const std::string kSharedLibExt = \".dll\";\nstatic const char kPathSeparator = ';';\n#else\nstatic const char kPathSeparator = ':';\n#if defined(OS_MACOSX)\nstatic const std::string kSharedLibExt = \".dylib\";\n#else\nstatic const std::string kSharedLibExt = \".so\";\n#endif\n#endif\n\nnamespace {\n\nThreadStatusUpdater* CreateThreadStatusUpdater() {\n  return new ThreadStatusUpdater();\n}\n\ninline mode_t GetDBFileMode(bool allow_non_owner_access) {\n  return allow_non_owner_access ? 0644 : 0600;\n}\n\n// list of pathnames that are locked\nstatic std::set<std::string> lockedFiles;\nstatic port::Mutex mutex_lockedFiles;\n\nstatic int LockOrUnlock(int fd, bool lock) {\n  errno = 0;\n  struct flock f;\n  memset(&f, 0, sizeof(f));\n  f.l_type = (lock ? F_WRLCK : F_UNLCK);\n  f.l_whence = SEEK_SET;\n  f.l_start = 0;\n  f.l_len = 0;        // Lock/unlock entire file\n  int value = fcntl(fd, F_SETLK, &f);\n\n  return value;\n}\n\nclass PosixFileLock : public FileLock {\n public:\n  int fd_;\n  std::string filename;\n};\n\nint cloexec_flags(int flags, const EnvOptions* options) {\n  // If the system supports opening the file with cloexec enabled,\n  // do so, as this avoids a race condition if a db is opened around\n  // the same time that a child process is forked\n#ifdef O_CLOEXEC\n  if (options == nullptr || options->set_fd_cloexec) {\n    flags |= O_CLOEXEC;\n  }\n#endif\n  return flags;\n}\n\n#ifndef ROCKSDB_NO_DYNAMIC_EXTENSION\nclass PosixDynamicLibrary : public DynamicLibrary {\n public:\n  PosixDynamicLibrary(const std::string& name, void* handle)\n      : name_(name), handle_(handle) {}\n  ~PosixDynamicLibrary() override { dlclose(handle_); }\n\n  Status LoadSymbol(const std::string& sym_name, void** func) override {\n    assert(nullptr != func);\n    dlerror();  // Clear any old error\n    *func = dlsym(handle_, sym_name.c_str());\n    if (*func != nullptr) {\n      return Status::OK();\n    } else {\n      char* err = dlerror();\n      return Status::NotFound(\"Error finding symbol: \" + sym_name, err);\n    }\n  }\n\n  const char* Name() const override { return name_.c_str(); }\n\n private:\n  std::string name_;\n  void* handle_;\n};\n#endif  // !ROCKSDB_NO_DYNAMIC_EXTENSION\n\nclass PosixEnv : public Env {\n public:\n  PosixEnv();\n\n  ~PosixEnv() override {\n    for (const auto tid : threads_to_join_) {\n      pthread_join(tid, nullptr);\n    }\n    for (int pool_id = 0; pool_id < Env::Priority::TOTAL; ++pool_id) {\n      thread_pools_[pool_id].JoinAllThreads();\n    }\n    // Delete the thread_status_updater_ only when the current Env is not\n    // Env::Default().  This is to avoid the free-after-use error when\n    // Env::Default() is destructed while some other child threads are\n    // still trying to update thread status.\n    if (this != Env::Default()) {\n      delete thread_status_updater_;\n    }\n  }\n\n  void SetFD_CLOEXEC(int fd, const EnvOptions* options) {\n    if ((options == nullptr || options->set_fd_cloexec) && fd > 0) {\n      fcntl(fd, F_SETFD, fcntl(fd, F_GETFD) | FD_CLOEXEC);\n    }\n  }\n\n  Status NewSequentialFile(const std::string& fname,\n                           std::unique_ptr<SequentialFile>* result,\n                           const EnvOptions& options) override {\n    result->reset();\n    int fd = -1;\n    int flags = cloexec_flags(O_RDONLY, &options);\n    FILE* file = nullptr;\n\n    if (options.use_direct_reads && !options.use_mmap_reads) {\n#ifdef ROCKSDB_LITE\n      return Status::IOError(fname, \"Direct I/O not supported in RocksDB lite\");\n#endif  // !ROCKSDB_LITE\n#if !defined(OS_MACOSX) && !defined(OS_OPENBSD) && !defined(OS_SOLARIS)\n      flags |= O_DIRECT;\n#endif\n    }\n\n    do {\n      IOSTATS_TIMER_GUARD(open_nanos);\n      fd = open(fname.c_str(), flags, GetDBFileMode(allow_non_owner_access_));\n    } while (fd < 0 && errno == EINTR);\n    if (fd < 0) {\n      return IOError(\"While opening a file for sequentially reading\", fname,\n                     errno);\n    }\n\n    SetFD_CLOEXEC(fd, &options);\n\n    if (options.use_direct_reads && !options.use_mmap_reads) {\n#ifdef OS_MACOSX\n      if (fcntl(fd, F_NOCACHE, 1) == -1) {\n        close(fd);\n        return IOError(\"While fcntl NoCache\", fname, errno);\n      }\n#endif\n    } else {\n      do {\n        IOSTATS_TIMER_GUARD(open_nanos);\n        file = fdopen(fd, \"r\");\n      } while (file == nullptr && errno == EINTR);\n      if (file == nullptr) {\n        close(fd);\n        return IOError(\"While opening file for sequentially read\", fname,\n                       errno);\n      }\n    }\n    result->reset(new PosixSequentialFile(fname, file, fd, options));\n    return Status::OK();\n  }\n\n  Status NewRandomAccessFile(const std::string& fname,\n                             std::unique_ptr<RandomAccessFile>* result,\n                             const EnvOptions& options) override {\n    result->reset();\n    Status s;\n    int fd;\n    int flags = cloexec_flags(O_RDONLY, &options);\n\n    if (options.use_direct_reads && !options.use_mmap_reads) {\n#ifdef ROCKSDB_LITE\n      return Status::IOError(fname, \"Direct I/O not supported in RocksDB lite\");\n#endif  // !ROCKSDB_LITE\n#if !defined(OS_MACOSX) && !defined(OS_OPENBSD) && !defined(OS_SOLARIS)\n      flags |= O_DIRECT;\n      TEST_SYNC_POINT_CALLBACK(\"NewRandomAccessFile:O_DIRECT\", &flags);\n#endif\n    }\n\n    do {\n      IOSTATS_TIMER_GUARD(open_nanos);\n      fd = open(fname.c_str(), flags, GetDBFileMode(allow_non_owner_access_));\n    } while (fd < 0 && errno == EINTR);\n    if (fd < 0) {\n      return IOError(\"While open a file for random read\", fname, errno);\n    }\n    SetFD_CLOEXEC(fd, &options);\n\n    if (options.use_mmap_reads && sizeof(void*) >= 8) {\n      // Use of mmap for random reads has been removed because it\n      // kills performance when storage is fast.\n      // Use mmap when virtual address-space is plentiful.\n      uint64_t size;\n      s = GetFileSize(fname, &size);\n      if (s.ok()) {\n        void* base = mmap(nullptr, size, PROT_READ, MAP_SHARED, fd, 0);\n        if (base != MAP_FAILED) {\n          result->reset(new PosixMmapReadableFile(fd, fname, base,\n                                                  size, options));\n        } else {\n          s = IOError(\"while mmap file for read\", fname, errno);\n          close(fd);\n        }\n      }\n    } else {\n      if (options.use_direct_reads && !options.use_mmap_reads) {\n#ifdef OS_MACOSX\n        if (fcntl(fd, F_NOCACHE, 1) == -1) {\n          close(fd);\n          return IOError(\"while fcntl NoCache\", fname, errno);\n        }\n#endif\n      }\n      result->reset(new PosixRandomAccessFile(fname, fd, options));\n    }\n    return s;\n  }\n\n  virtual Status OpenWritableFile(const std::string& fname,\n                                  std::unique_ptr<WritableFile>* result,\n                                  const EnvOptions& options,\n                                  bool reopen = false) {\n    result->reset();\n    Status s;\n    int fd = -1;\n    int flags = (reopen) ? (O_CREAT | O_APPEND) : (O_CREAT | O_TRUNC);\n    // Direct IO mode with O_DIRECT flag or F_NOCAHCE (MAC OSX)\n    if (options.use_direct_writes && !options.use_mmap_writes) {\n      // Note: we should avoid O_APPEND here due to ta the following bug:\n      // POSIX requires that opening a file with the O_APPEND flag should\n      // have no affect on the location at which pwrite() writes data.\n      // However, on Linux, if a file is opened with O_APPEND, pwrite()\n      // appends data to the end of the file, regardless of the value of\n      // offset.\n      // More info here: https://linux.die.net/man/2/pwrite\n#ifdef ROCKSDB_LITE\n      return Status::IOError(fname, \"Direct I/O not supported in RocksDB lite\");\n#endif  // ROCKSDB_LITE\n      flags |= O_WRONLY;\n#if !defined(OS_MACOSX) && !defined(OS_OPENBSD) && !defined(OS_SOLARIS)\n      flags |= O_DIRECT;\n#endif\n      TEST_SYNC_POINT_CALLBACK(\"NewWritableFile:O_DIRECT\", &flags);\n    } else if (options.use_mmap_writes) {\n      // non-direct I/O\n      flags |= O_RDWR;\n    } else {\n      flags |= O_WRONLY;\n    }\n\n    flags = cloexec_flags(flags, &options);\n\n    do {\n      IOSTATS_TIMER_GUARD(open_nanos);\n      fd = open(fname.c_str(), flags, GetDBFileMode(allow_non_owner_access_));\n    } while (fd < 0 && errno == EINTR);\n\n    if (fd < 0) {\n      s = IOError(\"While open a file for appending\", fname, errno);\n      return s;\n    }\n    SetFD_CLOEXEC(fd, &options);\n\n    if (options.use_mmap_writes) {\n      if (!checkedDiskForMmap_) {\n        // this will be executed once in the program's lifetime.\n        // do not use mmapWrite on non ext-3/xfs/tmpfs systems.\n        if (!SupportsFastAllocate(fname)) {\n          forceMmapOff_ = true;\n        }\n        checkedDiskForMmap_ = true;\n      }\n    }\n    if (options.use_mmap_writes && !forceMmapOff_) {\n      result->reset(new PosixMmapFile(fname, fd, page_size_, options));\n    } else if (options.use_direct_writes && !options.use_mmap_writes) {\n#ifdef OS_MACOSX\n      if (fcntl(fd, F_NOCACHE, 1) == -1) {\n        close(fd);\n        s = IOError(\"While fcntl NoCache an opened file for appending\", fname,\n                    errno);\n        return s;\n      }\n#elif defined(OS_SOLARIS)\n      if (directio(fd, DIRECTIO_ON) == -1) {\n        if (errno != ENOTTY) { // ZFS filesystems don't support DIRECTIO_ON\n          close(fd);\n          s = IOError(\"While calling directio()\", fname, errno);\n          return s;\n        }\n      }\n#endif\n      result->reset(new PosixWritableFile(fname, fd, options));\n    } else {\n      // disable mmap writes\n      EnvOptions no_mmap_writes_options = options;\n      no_mmap_writes_options.use_mmap_writes = false;\n      result->reset(new PosixWritableFile(fname, fd, no_mmap_writes_options));\n    }\n    return s;\n  }\n\n  Status NewWritableFile(const std::string& fname,\n                         std::unique_ptr<WritableFile>* result,\n                         const EnvOptions& options) override {\n    return OpenWritableFile(fname, result, options, false);\n  }\n\n  Status ReopenWritableFile(const std::string& fname,\n                            std::unique_ptr<WritableFile>* result,\n                            const EnvOptions& options) override {\n    return OpenWritableFile(fname, result, options, true);\n  }\n\n  Status ReuseWritableFile(const std::string& fname,\n                           const std::string& old_fname,\n                           std::unique_ptr<WritableFile>* result,\n                           const EnvOptions& options) override {\n    result->reset();\n    Status s;\n    int fd = -1;\n\n    int flags = 0;\n    // Direct IO mode with O_DIRECT flag or F_NOCAHCE (MAC OSX)\n    if (options.use_direct_writes && !options.use_mmap_writes) {\n#ifdef ROCKSDB_LITE\n      return Status::IOError(fname, \"Direct I/O not supported in RocksDB lite\");\n#endif  // !ROCKSDB_LITE\n      flags |= O_WRONLY;\n#if !defined(OS_MACOSX) && !defined(OS_OPENBSD) && !defined(OS_SOLARIS)\n      flags |= O_DIRECT;\n#endif\n      TEST_SYNC_POINT_CALLBACK(\"NewWritableFile:O_DIRECT\", &flags);\n    } else if (options.use_mmap_writes) {\n      // mmap needs O_RDWR mode\n      flags |= O_RDWR;\n    } else {\n      flags |= O_WRONLY;\n    }\n\n    flags = cloexec_flags(flags, &options);\n\n    do {\n      IOSTATS_TIMER_GUARD(open_nanos);\n      fd = open(old_fname.c_str(), flags,\n                GetDBFileMode(allow_non_owner_access_));\n    } while (fd < 0 && errno == EINTR);\n    if (fd < 0) {\n      s = IOError(\"while reopen file for write\", fname, errno);\n      return s;\n    }\n\n    SetFD_CLOEXEC(fd, &options);\n    // rename into place\n    if (rename(old_fname.c_str(), fname.c_str()) != 0) {\n      s = IOError(\"while rename file to \" + fname, old_fname, errno);\n      close(fd);\n      return s;\n    }\n\n    if (options.use_mmap_writes) {\n      if (!checkedDiskForMmap_) {\n        // this will be executed once in the program's lifetime.\n        // do not use mmapWrite on non ext-3/xfs/tmpfs systems.\n        if (!SupportsFastAllocate(fname)) {\n          forceMmapOff_ = true;\n        }\n        checkedDiskForMmap_ = true;\n      }\n    }\n    if (options.use_mmap_writes && !forceMmapOff_) {\n      result->reset(new PosixMmapFile(fname, fd, page_size_, options));\n    } else if (options.use_direct_writes && !options.use_mmap_writes) {\n#ifdef OS_MACOSX\n      if (fcntl(fd, F_NOCACHE, 1) == -1) {\n        close(fd);\n        s = IOError(\"while fcntl NoCache for reopened file for append\", fname,\n                    errno);\n        return s;\n      }\n#elif defined(OS_SOLARIS)\n      if (directio(fd, DIRECTIO_ON) == -1) {\n        if (errno != ENOTTY) { // ZFS filesystems don't support DIRECTIO_ON\n          close(fd);\n          s = IOError(\"while calling directio()\", fname, errno);\n          return s;\n        }\n      }\n#endif\n      result->reset(new PosixWritableFile(fname, fd, options));\n    } else {\n      // disable mmap writes\n      EnvOptions no_mmap_writes_options = options;\n      no_mmap_writes_options.use_mmap_writes = false;\n      result->reset(new PosixWritableFile(fname, fd, no_mmap_writes_options));\n    }\n    return s;\n  }\n\n  Status NewRandomRWFile(const std::string& fname,\n                         std::unique_ptr<RandomRWFile>* result,\n                         const EnvOptions& options) override {\n    int fd = -1;\n    int flags = cloexec_flags(O_RDWR, &options);\n\n    while (fd < 0) {\n      IOSTATS_TIMER_GUARD(open_nanos);\n\n      fd = open(fname.c_str(), flags, GetDBFileMode(allow_non_owner_access_));\n      if (fd < 0) {\n        // Error while opening the file\n        if (errno == EINTR) {\n          continue;\n        }\n        return IOError(\"While open file for random read/write\", fname, errno);\n      }\n    }\n\n    SetFD_CLOEXEC(fd, &options);\n    result->reset(new PosixRandomRWFile(fname, fd, options));\n    return Status::OK();\n  }\n\n  Status NewMemoryMappedFileBuffer(\n      const std::string& fname,\n      std::unique_ptr<MemoryMappedFileBuffer>* result) override {\n    int fd = -1;\n    Status status;\n    int flags = cloexec_flags(O_RDWR, nullptr);\n\n    while (fd < 0) {\n      IOSTATS_TIMER_GUARD(open_nanos);\n      fd = open(fname.c_str(), flags, 0644);\n      if (fd < 0) {\n        // Error while opening the file\n        if (errno == EINTR) {\n          continue;\n        }\n        status =\n            IOError(\"While open file for raw mmap buffer access\", fname, errno);\n        break;\n      }\n    }\n    uint64_t size;\n    if (status.ok()) {\n      status = GetFileSize(fname, &size);\n    }\n    void* base = nullptr;\n    if (status.ok()) {\n      base = mmap(nullptr, static_cast<size_t>(size), PROT_READ | PROT_WRITE,\n                  MAP_SHARED, fd, 0);\n      if (base == MAP_FAILED) {\n        status = IOError(\"while mmap file for read\", fname, errno);\n      }\n    }\n    if (status.ok()) {\n      result->reset(\n          new PosixMemoryMappedFileBuffer(base, static_cast<size_t>(size)));\n    }\n    if (fd >= 0) {\n      // don't need to keep it open after mmap has been called\n      close(fd);\n    }\n    return status;\n  }\n\n  Status NewDirectory(const std::string& name,\n                      std::unique_ptr<Directory>* result) override {\n    result->reset();\n    int fd;\n    int flags = cloexec_flags(0, nullptr);\n    {\n      IOSTATS_TIMER_GUARD(open_nanos);\n      fd = open(name.c_str(), flags);\n    }\n    if (fd < 0) {\n      return IOError(\"While open directory\", name, errno);\n    } else {\n      result->reset(new PosixDirectory(fd));\n    }\n    return Status::OK();\n  }\n\n  Status FileExists(const std::string& fname) override {\n    int result = access(fname.c_str(), F_OK);\n\n    if (result == 0) {\n      return Status::OK();\n    }\n\n    int err = errno;\n    switch (err) {\n      case EACCES:\n      case ELOOP:\n      case ENAMETOOLONG:\n      case ENOENT:\n      case ENOTDIR:\n        return Status::NotFound();\n      default:\n        assert(err == EIO || err == ENOMEM);\n        return Status::IOError(\"Unexpected error(\" + ToString(err) +\n                               \") accessing file `\" + fname + \"' \");\n    }\n  }\n\n  Status GetChildren(const std::string& dir,\n                     std::vector<std::string>* result) override {\n    result->clear();\n    DIR* d = opendir(dir.c_str());\n    if (d == nullptr) {\n      switch (errno) {\n        case EACCES:\n        case ENOENT:\n        case ENOTDIR:\n          return Status::NotFound();\n        default:\n          return IOError(\"While opendir\", dir, errno);\n      }\n    }\n    struct dirent* entry;\n    while ((entry = readdir(d)) != nullptr) {\n      result->push_back(entry->d_name);\n    }\n    closedir(d);\n    return Status::OK();\n  }\n\n  Status DeleteFile(const std::string& fname) override {\n    Status result;\n    if (unlink(fname.c_str()) != 0) {\n      result = IOError(\"while unlink() file\", fname, errno);\n    }\n    return result;\n  };\n\n  Status CreateDir(const std::string& name) override {\n    Status result;\n    if (mkdir(name.c_str(), 0755) != 0) {\n      result = IOError(\"While mkdir\", name, errno);\n    }\n    return result;\n  };\n\n  Status CreateDirIfMissing(const std::string& name) override {\n    Status result;\n    if (mkdir(name.c_str(), 0755) != 0) {\n      if (errno != EEXIST) {\n        result = IOError(\"While mkdir if missing\", name, errno);\n      } else if (!DirExists(name)) { // Check that name is actually a\n                                     // directory.\n        // Message is taken from mkdir\n        result = Status::IOError(\"`\"+name+\"' exists but is not a directory\");\n      }\n    }\n    return result;\n  };\n\n  Status DeleteDir(const std::string& name) override {\n    Status result;\n    if (rmdir(name.c_str()) != 0) {\n      result = IOError(\"file rmdir\", name, errno);\n    }\n    return result;\n  };\n\n  Status GetFileSize(const std::string& fname, uint64_t* size) override {\n    Status s;\n    struct stat sbuf;\n    if (stat(fname.c_str(), &sbuf) != 0) {\n      *size = 0;\n      s = IOError(\"while stat a file for size\", fname, errno);\n    } else {\n      *size = sbuf.st_size;\n    }\n    return s;\n  }\n\n  Status GetFileModificationTime(const std::string& fname,\n                                 uint64_t* file_mtime) override {\n    struct stat s;\n    if (stat(fname.c_str(), &s) !=0) {\n      return IOError(\"while stat a file for modification time\", fname, errno);\n    }\n    *file_mtime = static_cast<uint64_t>(s.st_mtime);\n    return Status::OK();\n  }\n  Status RenameFile(const std::string& src,\n                    const std::string& target) override {\n    Status result;\n    if (rename(src.c_str(), target.c_str()) != 0) {\n      result = IOError(\"While renaming a file to \" + target, src, errno);\n    }\n    return result;\n  }\n\n  Status LinkFile(const std::string& src, const std::string& target) override {\n    Status result;\n    if (link(src.c_str(), target.c_str()) != 0) {\n      if (errno == EXDEV) {\n        return Status::NotSupported(\"No cross FS links allowed\");\n      }\n      result = IOError(\"while link file to \" + target, src, errno);\n    }\n    return result;\n  }\n\n  Status NumFileLinks(const std::string& fname, uint64_t* count) override {\n    struct stat s;\n    if (stat(fname.c_str(), &s) != 0) {\n      return IOError(\"while stat a file for num file links\", fname, errno);\n    }\n    *count = static_cast<uint64_t>(s.st_nlink);\n    return Status::OK();\n  }\n\n  Status AreFilesSame(const std::string& first, const std::string& second,\n                      bool* res) override {\n    struct stat statbuf[2];\n    if (stat(first.c_str(), &statbuf[0]) != 0) {\n      return IOError(\"stat file\", first, errno);\n    }\n    if (stat(second.c_str(), &statbuf[1]) != 0) {\n      return IOError(\"stat file\", second, errno);\n    }\n\n    if (major(statbuf[0].st_dev) != major(statbuf[1].st_dev) ||\n        minor(statbuf[0].st_dev) != minor(statbuf[1].st_dev) ||\n        statbuf[0].st_ino != statbuf[1].st_ino) {\n      *res = false;\n    } else {\n      *res = true;\n    }\n    return Status::OK();\n  }\n\n  Status LockFile(const std::string& fname, FileLock** lock) override {\n    *lock = nullptr;\n    Status result;\n\n    mutex_lockedFiles.Lock();\n    // If it already exists in the lockedFiles set, then it is already locked,\n    // and fail this lock attempt. Otherwise, insert it into lockedFiles.\n    // This check is needed because fcntl() does not detect lock conflict\n    // if the fcntl is issued by the same thread that earlier acquired\n    // this lock.\n    // We must do this check *before* opening the file:\n    // Otherwise, we will open a new file descriptor. Locks are associated with\n    // a process, not a file descriptor and when *any* file descriptor is closed,\n    // all locks the process holds for that *file* are released\n    if (lockedFiles.insert(fname).second == false) {\n      mutex_lockedFiles.Unlock();\n      errno = ENOLCK;\n      return IOError(\"lock \", fname, errno);\n    }\n\n    int fd;\n    int flags = cloexec_flags(O_RDWR | O_CREAT, nullptr);\n\n    {\n      IOSTATS_TIMER_GUARD(open_nanos);\n      fd = open(fname.c_str(), flags, 0644);\n    }\n    if (fd < 0) {\n      result = IOError(\"while open a file for lock\", fname, errno);\n    } else if (LockOrUnlock(fd, true) == -1) {\n      // if there is an error in locking, then remove the pathname from lockedfiles\n      lockedFiles.erase(fname);\n      result = IOError(\"While lock file\", fname, errno);\n      close(fd);\n    } else {\n      SetFD_CLOEXEC(fd, nullptr);\n      PosixFileLock* my_lock = new PosixFileLock;\n      my_lock->fd_ = fd;\n      my_lock->filename = fname;\n      *lock = my_lock;\n    }\n\n    mutex_lockedFiles.Unlock();\n    return result;\n  }\n\n  Status UnlockFile(FileLock* lock) override {\n    PosixFileLock* my_lock = reinterpret_cast<PosixFileLock*>(lock);\n    Status result;\n    mutex_lockedFiles.Lock();\n    // If we are unlocking, then verify that we had locked it earlier,\n    // it should already exist in lockedFiles. Remove it from lockedFiles.\n    if (lockedFiles.erase(my_lock->filename) != 1) {\n      errno = ENOLCK;\n      result = IOError(\"unlock\", my_lock->filename, errno);\n    } else if (LockOrUnlock(my_lock->fd_, false) == -1) {\n      result = IOError(\"unlock\", my_lock->filename, errno);\n    }\n    close(my_lock->fd_);\n    delete my_lock;\n    mutex_lockedFiles.Unlock();\n    return result;\n  }\n\n#ifndef ROCKSDB_NO_DYNAMIC_EXTENSION\n  // Loads the named library into the result.\n  // If the input name is empty, the current executable is loaded\n  // On *nix systems, a \"lib\" prefix is added to the name if one is not supplied\n  // Comparably, the appropriate shared library extension is added to the name\n  // if not supplied. If search_path is not specified, the shared library will\n  // be loaded using the default path (LD_LIBRARY_PATH) If search_path is\n  // specified, the shared library will be searched for in the directories\n  // provided by the search path\n  Status LoadLibrary(const std::string& name, const std::string& path,\n                     std::shared_ptr<DynamicLibrary>* result) override {\n    Status status;\n    assert(result != nullptr);\n    if (name.empty()) {\n      void* hndl = dlopen(NULL, RTLD_NOW);\n      if (hndl != nullptr) {\n        result->reset(new PosixDynamicLibrary(name, hndl));\n        return Status::OK();\n      }\n    } else {\n      std::string library_name = name;\n      if (library_name.find(kSharedLibExt) == std::string::npos) {\n        library_name = library_name + kSharedLibExt;\n      }\n#if !defined(OS_WIN)\n      if (library_name.find('/') == std::string::npos &&\n          library_name.compare(0, 3, \"lib\") != 0) {\n        library_name = \"lib\" + library_name;\n      }\n#endif\n      if (path.empty()) {\n        void* hndl = dlopen(library_name.c_str(), RTLD_NOW);\n        if (hndl != nullptr) {\n          result->reset(new PosixDynamicLibrary(library_name, hndl));\n          return Status::OK();\n        }\n      } else {\n        std::string local_path;\n        std::stringstream ss(path);\n        while (getline(ss, local_path, kPathSeparator)) {\n          if (!path.empty()) {\n            std::string full_name = local_path + \"/\" + library_name;\n            void* hndl = dlopen(full_name.c_str(), RTLD_NOW);\n            if (hndl != nullptr) {\n              result->reset(new PosixDynamicLibrary(full_name, hndl));\n              return Status::OK();\n            }\n          }\n        }\n      }\n    }\n    return Status::IOError(\n        IOErrorMsg(\"Failed to open shared library: xs\", name), dlerror());\n  }\n#endif  // !ROCKSDB_NO_DYNAMIC_EXTENSION\n\n  void Schedule(void (*function)(void* arg1), void* arg, Priority pri = LOW,\n                void* tag = nullptr,\n                void (*unschedFunction)(void* arg) = nullptr) override;\n\n  int UnSchedule(void* arg, Priority pri) override;\n\n  void StartThread(void (*function)(void* arg), void* arg) override;\n\n  void WaitForJoin() override;\n\n  unsigned int GetThreadPoolQueueLen(Priority pri = LOW) const override;\n\n  Status GetTestDirectory(std::string* result) override {\n    const char* env = getenv(\"TEST_TMPDIR\");\n    if (env && env[0] != '\\0') {\n      *result = env;\n    } else {\n      char buf[100];\n      snprintf(buf, sizeof(buf), \"/tmp/rocksdbtest-%d\", int(geteuid()));\n      *result = buf;\n    }\n    // Directory may already exist\n    CreateDir(*result);\n    return Status::OK();\n  }\n\n  Status GetThreadList(std::vector<ThreadStatus>* thread_list) override {\n    assert(thread_status_updater_);\n    return thread_status_updater_->GetThreadList(thread_list);\n  }\n\n  static uint64_t gettid(pthread_t tid) {\n    uint64_t thread_id = 0;\n    memcpy(&thread_id, &tid, std::min(sizeof(thread_id), sizeof(tid)));\n    return thread_id;\n  }\n\n  static uint64_t gettid() {\n    pthread_t tid = pthread_self();\n    return gettid(tid);\n  }\n\n  uint64_t GetThreadID() const override { return gettid(pthread_self()); }\n\n  Status GetFreeSpace(const std::string& fname, uint64_t* free_space) override {\n    struct statvfs sbuf;\n\n    if (statvfs(fname.c_str(), &sbuf) < 0) {\n      return IOError(\"While doing statvfs\", fname, errno);\n    }\n\n    *free_space = ((uint64_t)sbuf.f_bsize * sbuf.f_bfree);\n    return Status::OK();\n  }\n\n  Status NewLogger(const std::string& fname,\n                   std::shared_ptr<Logger>* result) override {\n    FILE* f;\n    {\n      IOSTATS_TIMER_GUARD(open_nanos);\n      f = fopen(fname.c_str(), \"w\"\n#ifdef __GLIBC_PREREQ\n#if __GLIBC_PREREQ(2, 7)\n          \"e\" // glibc extension to enable O_CLOEXEC\n#endif\n#endif\n          );\n    }\n    if (f == nullptr) {\n      result->reset();\n      return IOError(\"when fopen a file for new logger\", fname, errno);\n    } else {\n      int fd = fileno(f);\n#ifdef ROCKSDB_FALLOCATE_PRESENT\n      fallocate(fd, FALLOC_FL_KEEP_SIZE, 0, 4 * 1024);\n#endif\n      SetFD_CLOEXEC(fd, nullptr);\n      result->reset(new PosixLogger(f, &PosixEnv::gettid, this));\n      return Status::OK();\n    }\n  }\n\n  uint64_t NowMicros() override {\n    struct timeval tv;\n    gettimeofday(&tv, nullptr);\n    return static_cast<uint64_t>(tv.tv_sec) * 1000000 + tv.tv_usec;\n  }\n\n  uint64_t NowNanos() override {\n#if defined(OS_LINUX) || defined(OS_FREEBSD) || defined(OS_AIX)\n    struct timespec ts;\n    clock_gettime(CLOCK_MONOTONIC, &ts);\n    return static_cast<uint64_t>(ts.tv_sec) * 1000000000 + ts.tv_nsec;\n#elif defined(OS_SOLARIS)\n    return gethrtime();\n#elif defined(__MACH__)\n    clock_serv_t cclock;\n    mach_timespec_t ts;\n    host_get_clock_service(mach_host_self(), CALENDAR_CLOCK, &cclock);\n    clock_get_time(cclock, &ts);\n    mach_port_deallocate(mach_task_self(), cclock);\n    return static_cast<uint64_t>(ts.tv_sec) * 1000000000 + ts.tv_nsec;\n#else\n    return std::chrono::duration_cast<std::chrono::nanoseconds>(\n       std::chrono::steady_clock::now().time_since_epoch()).count();\n#endif\n  }\n\n  uint64_t NowCPUNanos() override {\n#if defined(OS_LINUX) || defined(OS_FREEBSD) || defined(OS_AIX) || \\\n    defined(__MACH__)\n    struct timespec ts;\n    clock_gettime(CLOCK_THREAD_CPUTIME_ID, &ts);\n    return static_cast<uint64_t>(ts.tv_sec) * 1000000000 + ts.tv_nsec;\n#endif\n    return 0;\n  }\n\n  void SleepForMicroseconds(int micros) override { usleep(micros); }\n\n  Status GetHostName(char* name, uint64_t len) override {\n    int ret = gethostname(name, static_cast<size_t>(len));\n    if (ret < 0) {\n      if (errno == EFAULT || errno == EINVAL)\n        return Status::InvalidArgument(strerror(errno));\n      else\n        return IOError(\"GetHostName\", name, errno);\n    }\n    return Status::OK();\n  }\n\n  Status GetCurrentTime(int64_t* unix_time) override {\n    time_t ret = time(nullptr);\n    if (ret == (time_t) -1) {\n      return IOError(\"GetCurrentTime\", \"\", errno);\n    }\n    *unix_time = (int64_t) ret;\n    return Status::OK();\n  }\n\n  Status GetAbsolutePath(const std::string& db_path,\n                         std::string* output_path) override {\n    if (!db_path.empty() && db_path[0] == '/') {\n      *output_path = db_path;\n      return Status::OK();\n    }\n\n    char the_path[256];\n    char* ret = getcwd(the_path, 256);\n    if (ret == nullptr) {\n      return Status::IOError(strerror(errno));\n    }\n\n    *output_path = ret;\n    return Status::OK();\n  }\n\n  // Allow increasing the number of worker threads.\n  void SetBackgroundThreads(int num, Priority pri) override {\n    assert(pri >= Priority::BOTTOM && pri <= Priority::HIGH);\n    thread_pools_[pri].SetBackgroundThreads(num);\n  }\n\n  int GetBackgroundThreads(Priority pri) override {\n    assert(pri >= Priority::BOTTOM && pri <= Priority::HIGH);\n    return thread_pools_[pri].GetBackgroundThreads();\n  }\n\n  Status SetAllowNonOwnerAccess(bool allow_non_owner_access) override {\n    allow_non_owner_access_ = allow_non_owner_access;\n    return Status::OK();\n  }\n\n  // Allow increasing the number of worker threads.\n  void IncBackgroundThreadsIfNeeded(int num, Priority pri) override {\n    assert(pri >= Priority::BOTTOM && pri <= Priority::HIGH);\n    thread_pools_[pri].IncBackgroundThreadsIfNeeded(num);\n  }\n\n  void LowerThreadPoolIOPriority(Priority pool = LOW) override {\n    assert(pool >= Priority::BOTTOM && pool <= Priority::HIGH);\n#ifdef OS_LINUX\n    thread_pools_[pool].LowerIOPriority();\n#else\n    (void)pool;\n#endif\n  }\n\n  void LowerThreadPoolCPUPriority(Priority pool = LOW) override {\n    assert(pool >= Priority::BOTTOM && pool <= Priority::HIGH);\n#ifdef OS_LINUX\n    thread_pools_[pool].LowerCPUPriority();\n#else\n    (void)pool;\n#endif\n  }\n\n  std::string TimeToString(uint64_t secondsSince1970) override {\n    const time_t seconds = (time_t)secondsSince1970;\n    struct tm t;\n    int maxsize = 64;\n    std::string dummy;\n    dummy.reserve(maxsize);\n    dummy.resize(maxsize);\n    char* p = &dummy[0];\n    localtime_r(&seconds, &t);\n    snprintf(p, maxsize,\n             \"%04d/%02d/%02d-%02d:%02d:%02d \",\n             t.tm_year + 1900,\n             t.tm_mon + 1,\n             t.tm_mday,\n             t.tm_hour,\n             t.tm_min,\n             t.tm_sec);\n    return dummy;\n  }\n\n  EnvOptions OptimizeForLogWrite(const EnvOptions& env_options,\n                                 const DBOptions& db_options) const override {\n    EnvOptions optimized = env_options;\n    optimized.use_mmap_writes = false;\n    optimized.use_direct_writes = false;\n    optimized.bytes_per_sync = db_options.wal_bytes_per_sync;\n    // TODO(icanadi) it's faster if fallocate_with_keep_size is false, but it\n    // breaks TransactionLogIteratorStallAtLastRecord unit test. Fix the unit\n    // test and make this false\n    optimized.fallocate_with_keep_size = true;\n    optimized.writable_file_max_buffer_size =\n        db_options.writable_file_max_buffer_size;\n    return optimized;\n  }\n\n  EnvOptions OptimizeForManifestWrite(\n      const EnvOptions& env_options) const override {\n    EnvOptions optimized = env_options;\n    optimized.use_mmap_writes = false;\n    optimized.use_direct_writes = false;\n    optimized.fallocate_with_keep_size = true;\n    return optimized;\n  }\n\n private:\n  bool checkedDiskForMmap_;\n  bool forceMmapOff_;  // do we override Env options?\n\n  // Returns true iff the named directory exists and is a directory.\n  virtual bool DirExists(const std::string& dname) {\n    struct stat statbuf;\n    if (stat(dname.c_str(), &statbuf) == 0) {\n      return S_ISDIR(statbuf.st_mode);\n    }\n    return false; // stat() failed return false\n  }\n\n  bool SupportsFastAllocate(const std::string& path) {\n#ifdef ROCKSDB_FALLOCATE_PRESENT\n    struct statfs s;\n    if (statfs(path.c_str(), &s)){\n      return false;\n    }\n    switch (s.f_type) {\n      case EXT4_SUPER_MAGIC:\n        return true;\n      case XFS_SUPER_MAGIC:\n        return true;\n      case TMPFS_MAGIC:\n        return true;\n      default:\n        return false;\n    }\n#else\n    (void)path;\n    return false;\n#endif\n  }\n\n  size_t page_size_;\n\n  std::vector<ThreadPoolImpl> thread_pools_;\n  pthread_mutex_t mu_;\n  std::vector<pthread_t> threads_to_join_;\n  // If true, allow non owner read access for db files. Otherwise, non-owner\n  //  has no access to db files.\n  bool allow_non_owner_access_;\n};\n\nPosixEnv::PosixEnv()\n    : checkedDiskForMmap_(false),\n      forceMmapOff_(false),\n      page_size_(getpagesize()),\n      thread_pools_(Priority::TOTAL),\n      allow_non_owner_access_(true) {\n  ThreadPoolImpl::PthreadCall(\"mutex_init\", pthread_mutex_init(&mu_, nullptr));\n  for (int pool_id = 0; pool_id < Env::Priority::TOTAL; ++pool_id) {\n    thread_pools_[pool_id].SetThreadPriority(\n        static_cast<Env::Priority>(pool_id));\n    // This allows later initializing the thread-local-env of each thread.\n    thread_pools_[pool_id].SetHostEnv(this);\n  }\n  thread_status_updater_ = CreateThreadStatusUpdater();\n}\n\nvoid PosixEnv::Schedule(void (*function)(void* arg1), void* arg, Priority pri,\n                        void* tag, void (*unschedFunction)(void* arg)) {\n  assert(pri >= Priority::BOTTOM && pri <= Priority::HIGH);\n  thread_pools_[pri].Schedule(function, arg, tag, unschedFunction);\n}\n\nint PosixEnv::UnSchedule(void* arg, Priority pri) {\n  return thread_pools_[pri].UnSchedule(arg);\n}\n\nunsigned int PosixEnv::GetThreadPoolQueueLen(Priority pri) const {\n  assert(pri >= Priority::BOTTOM && pri <= Priority::HIGH);\n  return thread_pools_[pri].GetQueueLen();\n}\n\nstruct StartThreadState {\n  void (*user_function)(void*);\n  void* arg;\n};\n\nstatic void* StartThreadWrapper(void* arg) {\n  StartThreadState* state = reinterpret_cast<StartThreadState*>(arg);\n  state->user_function(state->arg);\n  delete state;\n  return nullptr;\n}\n\nvoid PosixEnv::StartThread(void (*function)(void* arg), void* arg) {\n  pthread_t t;\n  StartThreadState* state = new StartThreadState;\n  state->user_function = function;\n  state->arg = arg;\n  ThreadPoolImpl::PthreadCall(\n      \"start thread\", pthread_create(&t, nullptr, &StartThreadWrapper, state));\n  ThreadPoolImpl::PthreadCall(\"lock\", pthread_mutex_lock(&mu_));\n  threads_to_join_.push_back(t);\n  ThreadPoolImpl::PthreadCall(\"unlock\", pthread_mutex_unlock(&mu_));\n}\n\nvoid PosixEnv::WaitForJoin() {\n  for (const auto tid : threads_to_join_) {\n    pthread_join(tid, nullptr);\n  }\n  threads_to_join_.clear();\n}\n\n}  // namespace\n\nstd::string Env::GenerateUniqueId() {\n  std::string uuid_file = \"/proc/sys/kernel/random/uuid\";\n\n  Status s = FileExists(uuid_file);\n  if (s.ok()) {\n    std::string uuid;\n    s = ReadFileToString(this, uuid_file, &uuid);\n    if (s.ok()) {\n      return uuid;\n    }\n  }\n  // Could not read uuid_file - generate uuid using \"nanos-random\"\n  Random64 r(time(nullptr));\n  uint64_t random_uuid_portion =\n    r.Uniform(std::numeric_limits<uint64_t>::max());\n  uint64_t nanos_uuid_portion = NowNanos();\n  char uuid2[200];\n  snprintf(uuid2,\n           200,\n           \"%lx-%lx\",\n           (unsigned long)nanos_uuid_portion,\n           (unsigned long)random_uuid_portion);\n  return uuid2;\n}\n\n//\n// Default Posix Env\n//\nEnv* Env::Default() {\n  // The following function call initializes the singletons of ThreadLocalPtr\n  // right before the static default_env.  This guarantees default_env will\n  // always being destructed before the ThreadLocalPtr singletons get\n  // destructed as C++ guarantees that the destructions of static variables\n  // is in the reverse order of their constructions.\n  //\n  // Since static members are destructed in the reverse order\n  // of their construction, having this call here guarantees that\n  // the destructor of static PosixEnv will go first, then the\n  // the singletons of ThreadLocalPtr.\n  ThreadLocalPtr::InitSingletons();\n  CompressionContextCache::InitSingleton();\n  INIT_SYNC_POINT_SINGLETONS();\n  static PosixEnv default_env;\n  return &default_env;\n}\n\n}  // namespace rocksdb\n",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/rocksdb/rocksdb/port/jemalloc_helper.h": "//  Copyright (c) 2011-present, Facebook, Inc.  All rights reserved.\n//  This source code is licensed under both the GPLv2 (found in the\n//  COPYING file in the root directory) and Apache 2.0 License\n//  (found in the LICENSE.Apache file in the root directory).\n\n#pragma once\n\n#ifdef ROCKSDB_JEMALLOC\n#ifdef __FreeBSD__\n#include <malloc_np.h>\n#else\n#include <jemalloc/jemalloc.h>\n#endif\n\n#ifndef JEMALLOC_CXX_THROW\n#define JEMALLOC_CXX_THROW\n#endif\n\n#if defined(OS_WIN) && defined(_MSC_VER)\n\n// MSVC does not have weak symbol support. As long as ROCKSDB_JEMALLOC is defined,\n// Jemalloc memory allocator is used.\nstatic inline bool HasJemalloc() { return true; }\n\n#else\n\n// Declare non-standard jemalloc APIs as weak symbols. We can null-check these\n// symbols to detect whether jemalloc is linked with the binary.\nextern \"C\" void* mallocx(size_t, int) __attribute__((__weak__));\nextern \"C\" void* rallocx(void*, size_t, int) __attribute__((__weak__));\nextern \"C\" size_t xallocx(void*, size_t, size_t, int) __attribute__((__weak__));\nextern \"C\" size_t sallocx(const void*, int) __attribute__((__weak__));\nextern \"C\" void dallocx(void*, int) __attribute__((__weak__));\nextern \"C\" void sdallocx(void*, size_t, int) __attribute__((__weak__));\nextern \"C\" size_t nallocx(size_t, int) __attribute__((__weak__));\nextern \"C\" int mallctl(const char*, void*, size_t*, void*, size_t)\n    __attribute__((__weak__));\nextern \"C\" int mallctlnametomib(const char*, size_t*, size_t*)\n    __attribute__((__weak__));\nextern \"C\" int mallctlbymib(const size_t*, size_t, void*, size_t*, void*,\n                            size_t) __attribute__((__weak__));\nextern \"C\" void malloc_stats_print(void (*)(void*, const char*), void*,\n                                   const char*) __attribute__((__weak__));\nextern \"C\" size_t malloc_usable_size(JEMALLOC_USABLE_SIZE_CONST void*)\n    JEMALLOC_CXX_THROW __attribute__((__weak__));\n\n// Check if Jemalloc is linked with the binary. Note the main program might be\n// using a different memory allocator even this method return true.\n// It is loosely based on folly::usingJEMalloc(), minus the check that actually\n// allocate memory and see if it is through jemalloc, to handle the dlopen()\n// case:\n// https://github.com/facebook/folly/blob/76cf8b5841fb33137cfbf8b224f0226437c855bc/folly/memory/Malloc.h#L147\nstatic inline bool HasJemalloc() {\n  return mallocx != nullptr && rallocx != nullptr && xallocx != nullptr &&\n         sallocx != nullptr && dallocx != nullptr && sdallocx != nullptr &&\n         nallocx != nullptr && mallctl != nullptr &&\n         mallctlnametomib != nullptr && mallctlbymib != nullptr &&\n         malloc_stats_print != nullptr && malloc_usable_size != nullptr;\n}\n\n#endif\n\n#endif  // ROCKSDB_JEMALLOC\n",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/mroonga/vendor/groonga/configure.ac": "AC_PREREQ(2.59)\nm4_define([groonga_version], m4_include(base_version))\nAC_INIT([groonga], groonga_version, [groonga@razil.jp])\nAC_CONFIG_MACRO_DIR([m4])\nAM_CONFIG_HEADER(config.h)\n\nGRN_VERSION_RC=`echo groonga_version | sed -e 's/\\./,/g'`\nAC_SUBST(GRN_VERSION_RC)\n\nAM_INIT_AUTOMAKE([foreign tar-pax subdir-objects])\nm4_ifdef([AM_SILENT_RULES], [AM_SILENT_RULES([yes])])\n\nPACKAGE_LABEL=Groonga\nAC_SUBST(PACKAGE_LABEL)\nAC_DEFINE_UNQUOTED(PACKAGE_LABEL, [\"$PACKAGE_LABEL\"], [Label of package])\n\n# for Autoconf 2.60 or earlier.\nif test -z \"${datarootdir}\"; then\n   datarootdir=\"\\${prefix}/share\"\n   AC_SUBST(datarootdir)\nfi\n\n# for Autoconf 2.59 or earlier.\nif test -z \"${docdir}\"; then\n   docdir=\"\\${datarootdir}/doc/\\${PACKAGE_TARNAME}\"\n   AC_SUBST(docdir)\nfi\n\nAC_CANONICAL_HOST\nAC_DEFINE_UNQUOTED(HOST_CPU, [\"$host_cpu\"], [host CPU])\nAC_DEFINE_UNQUOTED(HOST_OS, [\"$host_os\"], [host OS])\n\nAC_MSG_CHECKING([for native Win32])\ncase \"$host_os\" in\n  mingw*)\n    os_win32=yes\n    ;;\n  *)\n    os_win32=no\n    ;;\nesac\nAC_MSG_RESULT([$os_win32])\n\nAC_MSG_CHECKING([for some Win32 platform])\ncase \"$host_os\" in\n  mingw*|cygwin*)\n    platform_win32=yes\n    ;;\n  *)\n    platform_win32=no\n    ;;\nesac\nAC_MSG_RESULT([$platform_win32])\n\nAM_CONDITIONAL(OS_WIN32, test \"$os_win32\" = \"yes\")\nAM_CONDITIONAL(PLATFORM_WIN32, test \"$platform_win32\" = \"yes\")\n\nAC_MSG_CHECKING([for NetBSD.])\ncase \"$host_os\" in\n  netbsd*)\n    netbsd=yes\n    ;;\n  *)\n    netbsd=no\n    ;;\nesac\nAC_MSG_RESULT([$netbsd])\n\nAC_MSG_CHECKING([for Solaris.])\ncase \"$host_os\" in\n  solaris*)\n    solaris=yes\n    ;;\n  *)\n    solaris=no\n    ;;\nesac\nAC_MSG_RESULT([$solaris])\n\nAC_C_BIGENDIAN\nAC_PROG_CXX\nm4_ifdef([AX_CXX_COMPILE_STDCXX_11],\n         [AX_CXX_COMPILE_STDCXX_11([ext], [optional])])\nAC_PROG_CC\nm4_ifdef([AC_PROG_CC_C99],\n         [AC_PROG_CC_C99])\nAM_PROG_CC_C_O\nm4_ifdef([PKG_PROG_PKG_CONFIG],\n         [PKG_PROG_PKG_CONFIG([0.19])\n          m4_pattern_allow(PKG_CONFIG_LIBDIR)])\n\nAC_MSG_CHECKING([for clang])\nif test \"$CC\" = \"clang\"; then\n  CLANG=yes\nelse\n  CLANG=no\nfi\nAC_MSG_RESULT([$CLANG])\n\nAC_DEFUN([CHECK_CFLAG], [\n  AC_MSG_CHECKING([if gcc supports $1])\n  old_CFLAGS=$CFLAGS\n  flag=`echo '$1' | sed -e 's,^-Wno-,-W,'`\n  CFLAGS=\"$CFLAGS $flag -Werror\"\n  AC_COMPILE_IFELSE([AC_LANG_PROGRAM([])],\n    [check_cflag=yes],\n    [check_cflag=no])\n  CFLAGS=\"$old_CFLAGS\"\n  if test \"x$check_cflag\" = \"xyes\"; then\n    CFLAGS=\"$CFLAGS $1\"\n  fi\n  AC_MSG_RESULT([$check_cflag])\n])\n\nAC_DEFUN([CHECK_CXXFLAG], [\n  AC_MSG_CHECKING([if g++ supports $1])\n  old_CXXFLAGS=$CXXFLAGS\n  flag=`echo '$1' | sed -e 's,^-Wno-,-W,'`\n  CXXFLAGS=\"$CXXFLAGS $flag -Werror\"\n  AC_LANG_PUSH([C++])\n  AC_COMPILE_IFELSE([AC_LANG_PROGRAM([])],\n    [check_cxxflag=yes],\n    [check_cxxflag=no])\n  AC_LANG_POP([C++])\n  CXXFLAGS=\"$old_CXXFLAGS\"\n  if test \"x$check_cxxflag\" = \"xyes\"; then\n    CXXFLAGS=\"$CXXFLAGS $1\"\n  fi\n  AC_MSG_RESULT([$check_cxxflag])\n])\n\nAC_DEFUN([CHECK_BUILD_FLAG], [\n  CHECK_CFLAG([$1])\n  CHECK_CXXFLAG([$1])\n])\n\nAC_DEFUN([REMOVE_CXXFLAG], [\n  AC_MSG_CHECKING([whether g++ option $1 is needed to be removed])\n  if echo \"$CXXFLAGS\" | grep -q -- \"$1\"; then\n    CXXFLAGS=`echo \"$CXXFLAGS\" | sed -e 's,$1,,'`\n    remove_cxxflag=yes\n  else\n    remove_cxxflag=no\n  fi\n  AC_MSG_RESULT([$remove_cxxflag])\n])\n\nTEST_CFLAGS=\"\"\nTEST_CXXFLAGS=\"\"\nNO_STRICT_ALIASING_CFLAGS=\"\"\nNO_FLOAT_EQUAL_CFLAGS=\"\"\nNO_BAD_FUNCTION_CAST_CFLAGS=\"\"\nif test \"$GCC\" = \"yes\"; then\n  CHECK_BUILD_FLAG([-Wall])\n  if test \"x$check_cflag\" = \"xno\"; then\n    CHECK_BUILD_FLAG([-W])\n  fi\n  CHECK_BUILD_FLAG([-Wno-unused-but-set-variable]) # FIXME: enable it.\n  CHECK_CFLAG([-Wno-pointer-sign])\n  CHECK_CFLAG([-Wno-declaration-after-statement])\n\n  CHECK_BUILD_FLAG([-Wformat])\n  CHECK_BUILD_FLAG([-Wstrict-aliasing=2])\n  if test \"x$check_cflag\" = \"xyes\"; then\n    NO_STRICT_ALIASING_CFLAGS=\"-fno-strict-aliasing\"\n  fi\n  CHECK_BUILD_FLAG([-Wdisabled-optimization])\n  CHECK_BUILD_FLAG([-Wfloat-equal])\n  if test \"x$check_cflag\" = \"xyes\"; then\n    NO_FLOAT_EQUAL_CFLAGS=\"-Wno-float-equal\"\n  fi\n  CHECK_BUILD_FLAG([-Wpointer-arith])\n  CHECK_CFLAG([-Wbad-function-cast])\n  if test \"x$check_cflag\" = \"xyes\"; then\n    NO_BAD_FUNCTION_CAST_CFLAGS=\"-Wno-bad-function-cast\"\n  fi\n  if test \"$CLANG\" = \"no\"; then\n    CHECK_BUILD_FLAG([-Wcast-align])\n  fi\n#  CHECK_BUILD_FLAG([-Wredundant-decls])\n#  CHECK_BUILD_FLAG([-Wunsafe-loop-optimizations])\n#  CHECK_BUILD_FLAG([-Wunreachable-code])\n#  CHECK_BUILD_FLAG([-Wswitch-enum])\n#  CHECK_BUILD_FLAG([-Wshadow])\n#  CHECK_BUILD_FLAG([-Wconversion])\n  CHECK_BUILD_FLAG([-Wwrite-strings])\n#  CHECK_BUILD_FLAG([-Winline])\n\n  CHECK_CXXFLAG([-fexceptions])\n  CHECK_CXXFLAG([-fimplicit-templates])\nfi\nAC_SUBST(TEST_CFLAGS)\nAC_SUBST(TEST_CXXFLAGS)\nAC_SUBST(NO_STRICT_ALIASING_CFLAGS)\nAC_SUBST(NO_FLOAT_EQUAL_CFLAGS)\nAC_SUBST(NO_BAD_FUNCTION_CAST_CFLAGS)\n\nLT_INIT([dlopen win32-dll])\nLT_LANG([Windows Resource])\nLT_OUTPUT\n\nLT_CURRENT=0\nLT_REVISION=0\nLT_AGE=0\nLT_VERSION_INFO=\"\\$(LT_CURRENT):\\$(LT_REVISION):\\$(LT_AGE)\"\nAC_SUBST(LT_CURRENT)\nAC_SUBST(LT_REVISION)\nAC_SUBST(LT_AGE)\nAC_SUBST(LT_VERSION_INFO)\n\nGRN_DLL_FILENAME=\"libgroonga-\\$(LT_CURRENT).dll\"\nAC_SUBST(GRN_DLL_FILENAME)\n\nif test \"$srcdir/version.sh\"; then\n  . \"$srcdir/version.sh\"\n  AC_SUBST(GRN_VERSION)\n  AC_DEFINE_UNQUOTED(GRN_VERSION, [\"$GRN_VERSION\"], [groonga version])\nfi\n\nAC_CONFIG_FILES([\n  Makefile\n  build/Makefile\n  build/cmake_modules/Makefile\n  src/Makefile\n  src/suggest/Makefile\n  src/httpd/Makefile\n  lib/Makefile\n  lib/dat/Makefile\n  lib/mrb/Makefile\n  lib/mrb/scripts/Makefile\n  lib/mrb/scripts/command_line/Makefile\n  lib/mrb/scripts/context/Makefile\n  lib/mrb/scripts/expression_tree/Makefile\n  lib/mrb/scripts/initialize/Makefile\n  lib/mrb/scripts/logger/Makefile\n  lib/mrb/scripts/query_logger/Makefile\n  lib/proc/Makefile\n  lib/ts/Makefile\n  include/Makefile\n  include/groonga/Makefile\n  plugins/Makefile\n  plugins/tokenizers/Makefile\n  plugins/suggest/Makefile\n  plugins/query_expanders/Makefile\n  plugins/ruby/Makefile\n  plugins/token_filters/Makefile\n  plugins/sharding/Makefile\n  plugins/functions/Makefile\n  plugins/expression_rewriters/Makefile\n  examples/Makefile\n  examples/dictionary/Makefile\n  examples/dictionary/edict/Makefile\n  examples/dictionary/eijiro/Makefile\n  examples/dictionary/gene95/Makefile\n  examples/dictionary/jmdict/Makefile\n  packages/Makefile\n  packages/apt/Makefile\n  packages/ubuntu/Makefile\n  packages/rpm/Makefile\n  packages/rpm/centos/Makefile\n  packages/yum/Makefile\n  packages/source/Makefile\n  packages/windows/Makefile\n  packages/windows/patches/Makefile\n  packages/windows/language-files/Makefile\n  packages/windows/setup-x64.nsi\n  data/Makefile\n  data/html/Makefile\n  data/munin/Makefile\n  data/init.d/Makefile\n  data/init.d/centos/Makefile\n  data/init.d/centos/sysconfig/Makefile\n  data/logrotate.d/Makefile\n  data/logrotate.d/centos/Makefile\n  data/systemd/Makefile\n  data/systemd/centos/Makefile\n  data/systemd/centos/sysconfig/Makefile\n  data/scripts/Makefile\n  data/tmpfiles.d/Makefile\n  tools/Makefile\n  doc/Makefile\n  doc/locale/Makefile\n  doc/locale/en/Makefile\n  doc/locale/en/LC_MESSAGES/Makefile\n  doc/locale/ja/Makefile\n  doc/locale/ja/LC_MESSAGES/Makefile\n  test/Makefile\n  test/unit/Makefile\n  test/unit/lib/Makefile\n  test/unit/fixtures/Makefile\n  test/unit/fixtures/inverted-index/Makefile\n  test/unit/fixtures/stress/Makefile\n  test/unit/fixtures/plugins/Makefile\n  test/unit/fixtures/geo/Makefile\n  test/unit/fixtures/story/Makefile\n  test/unit/fixtures/story/taiyaki/Makefile\n  test/unit/util/Makefile\n  test/unit/core/Makefile\n  test/unit/core/dat/Makefile\n  test/unit/story/Makefile\n  test/command/Makefile\n  benchmark/Makefile\n  benchmark/fixtures/Makefile\n  benchmark/fixtures/geo-select/Makefile\n  benchmark/lib/Makefile\n  vendor/Makefile\n  vendor/lz4/Makefile\n  vendor/onigmo/Makefile\n  vendor/mecab/Makefile\n  vendor/message_pack/Makefile\n  vendor/mruby/Makefile\n])\n\nif test \"$GCC\" = \"yes\"; then\n  AC_DEFINE(_GNU_SOURCE, [1], [Define to 1 if you use GCC.])\nfi\n\nif test \"$netbsd\" = \"yes\"; then\n  AC_DEFINE(_NETBSD_SOURCE, [1], [Define to 1 if you are on NetBSD.])\nfi\n\nif test \"$solaris\" = \"yes\"; then\n  AC_DEFINE(_XPG4_2, [1],\n            [Define to 1 for msghdr.msg_control if you are on Solaris.])\n  AC_DEFINE(__EXTENSIONS__, [1],\n            [Define to 1 for singal.h with _XPG4_2 if you are on Solaris.])\nfi\n\n# For debug\nAC_ARG_ENABLE(debug,\n  [AS_HELP_STRING([--enable-debug],\n                  [use debug flags (default=no)])],\n  [grn_debug=\"$enableval\"],\n  [grn_debug=\"no\"])\nif test \"x$grn_debug\" != \"xno\"; then\n  grn_debug=\"yes\"\n  if test \"$CLANG\" = \"yes\"; then\n    CFLAGS=\"$CFLAGS -O0 -g\"\n    CXXFLAGS=\"$CXXFLAGS -O0 -g\"\n  elif test \"$GCC\" = \"yes\"; then\n    CFLAGS=\"$CFLAGS -O0 -g3\"\n    CXXFLAGS=\"$CXXFLAGS -O0 -g3\"\n  fi\nfi\nAC_SUBST(grn_debug)\n\nAC_SEARCH_LIBS(log, m, [], [AC_MSG_ERROR(\"No libm found\")])\nAC_MSG_CHECKING([for fpclassify])\nAC_LINK_IFELSE(\n  [AC_LANG_PROGRAM(\n    [#include <math.h>],\n    [if (fpclassify(0.0)) {return 0;}]\n   )],\n  [\n    AC_DEFINE(HAVE_FPCLASSIFY, [1], [use fpclassify])\n    AC_MSG_RESULT(yes)\n  ],\n  [\n    AC_LINK_IFELSE(\n      [AC_LANG_PROGRAM(\n        [#define _ISOC99_SOURCE\n         #include <math.h>],\n        [if (fpclassify(0.0)) {return 0;}]\n       )],\n      [\n        AC_DEFINE(_ISOC99_SOURCE, [1], [Define to 1 for fpclassify])\n        AC_DEFINE(HAVE_FPCLASSIFY, [1], [use fpclassify with _ISOC99_SOURCE])\n        AC_MSG_RESULT(yes)\n      ],\n      [\n        AC_MSG_RESULT(no)\n      ])\n  ])\n\nm4_include(build/ac_macros/check_headers.m4)\nm4_include(build/ac_macros/check_functions.m4)\n\nAC_SEARCH_LIBS(backtrace, execinfo,\n               [AC_DEFINE(HAVE_BACKTRACE, [1],\n                          [Define to 1 if you have the `backtrace' function.])])\nAC_SEARCH_LIBS(clock_gettime, rt,\n               [AC_DEFINE(HAVE_CLOCK_GETTIME, [1], [use clock_gettime])])\nAC_SYS_LARGEFILE\nAC_TYPE_OFF_T\nAC_TYPE_SIZE_T\nAC_CHECK_SIZEOF(off_t)\n\n# MAP_HUGETLB\nAC_ARG_ENABLE(map-hugetlb,\n  [AS_HELP_STRING([--enable-map-hugetlb],\n                  [use MAP_HUGETLB. [default=no]])],\n  ,\n  [enable_map_hugetlb=\"no\"])\nif test \"x$enable_map_hugetlb\" != \"xno\"; then\n  AC_MSG_CHECKING([for MAP_HUGETLB])\n  AC_COMPILE_IFELSE(\n    [AC_LANG_PROGRAM(\n       [\n#ifdef HAVE_SYS_MMAN_H\n#  include <sys/mman.h>\n#endif /* HAVE_SYS_MMAN_H */\n       ],\n       [MAP_HUGETLB;]\n     )],\n    [\n     AC_DEFINE(USE_MAP_HUGETLB, [1], [use MAP_HUGETLB])\n     AC_MSG_RESULT(yes)\n    ],\n    [\n     AC_MSG_RESULT(no)\n     AC_MSG_ERROR(\"MAP_HUGETLB isn't available.\")\n    ]\n  )\nfi\n\n# log path\nAC_ARG_WITH(log_path,\n  [AS_HELP_STRING([--with-log-path=PATH],\n    [specify groonga log path.])],\n  grn_log_path=\"$withval\",\n  grn_log_path=\"\\$(localstatedir)/log/\\$(PACKAGE_NAME)/\\$(PACKAGE_NAME).log\")\nAC_SUBST(grn_log_path)\n\n# default encoding\nAC_ARG_WITH(default_encoding,\n  [AS_HELP_STRING([--with-default-encoding=ENCODING],\n    [specify groonga default encoding(euc_jp/sjis/utf8/latin1/koi8r/none)])],\n  GRN_DEFAULT_ENCODING=\"$withval\",\n  GRN_DEFAULT_ENCODING=\"utf8\")\nAC_DEFINE_UNQUOTED(GRN_DEFAULT_ENCODING, \"$GRN_DEFAULT_ENCODING\", \"specified default encoding\")\n\n# default match escalation threshold\nAC_ARG_WITH(match_escalation_threshold,\n  [AS_HELP_STRING([--with-match-escalation-threshold=NUMBER],\n    [specify groonga default match escalation threshold])],\n  GRN_DEFAULT_MATCH_ESCALATION_THRESHOLD=\"$withval\",\n  GRN_DEFAULT_MATCH_ESCALATION_THRESHOLD=\"0\")\nAC_DEFINE_UNQUOTED(GRN_DEFAULT_MATCH_ESCALATION_THRESHOLD, $GRN_DEFAULT_MATCH_ESCALATION_THRESHOLD, \"specified match escalation threshold\")\n\n# default DB key management algorithm\nAC_ARG_WITH(default_db_key,\n  [AS_HELP_STRING([--with-default-db-key=ALGORITHM],\n    [specify groonga default DB key (pat/dat/auto)])],\n  GRN_DEFAULT_DB_KEY=\"$withval\",\n  GRN_DEFAULT_DB_KEY=\"auto\")\nAC_DEFINE_UNQUOTED(GRN_DEFAULT_DB_KEY, \"$GRN_DEFAULT_DB_KEY\",\n                   \"specified default DB key management algorithm\")\n\n# DANGER!!!: stack size\nGRN_STACK_SIZE=1024\nAC_ARG_WITH(stack_size,\n  [AS_HELP_STRING([--with-stack-size=SIZE],\n    [DANGER!!!\n     This option specifies stack size. (default=$GRN_STACK_SIZE)\n     Normally, you should not use this option.])],\n  GRN_STACK_SIZE=\"$withval\")\nAC_DEFINE_UNQUOTED(GRN_STACK_SIZE, [$GRN_STACK_SIZE], [stack size])\n\n# lock timeout\nGRN_LOCK_TIMEOUT=900000\nAC_ARG_WITH(lock_timeout,\n  [AS_HELP_STRING([--with-lock-timeout=N],\n    [This option specifies how many times Groonga tries to acquire a lock.\n     Each try waits --with-lock-wait-time nanoseconds to acquire a lock.\n     It means that Groonga gives up after\n     (--with-lock-wait-time * --with-lock-timeout) nanoseconds.\n     (default=$GRN_LOCK_TIMEOUT)])],\n  GRN_LOCK_TIMEOUT=\"$withval\")\nAC_DEFINE_UNQUOTED(GRN_LOCK_TIMEOUT,\n                   [$GRN_LOCK_TIMEOUT],\n                   [lock timeout])\n\n# lock wait time\nGRN_LOCK_WAIT_TIME_NANOSECOND=1000000\nAC_ARG_WITH(lock_wait_time,\n  [AS_HELP_STRING([--with-lock-wait-time=NANOSECONDS],\n    [This option specifies wait time in nanosecond to acquire a lock.\n     (default=$GRN_LOCK_WAIT_TIME_NANOSECOND)])],\n  GRN_LOCK_WAIT_TIME_NANOSECOND=\"$withval\")\nAC_DEFINE_UNQUOTED(GRN_LOCK_WAIT_TIME_NANOSECOND,\n                   [$GRN_LOCK_WAIT_TIME_NANOSECOND],\n                   [lock wait time in nanosecond])\n\nif test \"$os_win32\" != \"yes\"; then\n  AC_CHECK_HEADERS(pthread.h)\n  AC_SEARCH_LIBS(pthread_create, pthread,\n                 [],\n                 [AC_MSG_ERROR(\"No libpthread found\")])\n  AC_CHECK_FUNCS(pthread_mutexattr_setpshared)\n  AC_CHECK_FUNCS(pthread_condattr_setpshared)\nfi\nAC_SEARCH_LIBS(gethostbyname, nsl)\nAC_SEARCH_LIBS(socket, socket)\nAC_SEARCH_LIBS(dlopen, dl)\n\n# nfkc\nAC_ARG_ENABLE(nfkc,\n  [AS_HELP_STRING([--enable-nfkc],\n    [use nfkc based utf8 normalization. [default=yes]])],,\n  [enable_nfkc=\"yes\"])\nif test \"x$enable_nfkc\" = \"xyes\"; then\n  AC_DEFINE(GRN_WITH_NFKC, [1], [compile with nfkc.c])\nfi\n\n# coverage\nm4_ifdef([AC_CHECK_COVERAGE], [AC_CHECK_COVERAGE])\nGENHTML_OPTIONS=\"--title 'groonga Code Coverage'\"\n\n# microyield\nAC_MSG_CHECKING([whether enable uyield])\nAC_ARG_ENABLE(uyield,\n  [AS_HELP_STRING([--enable-uyield],\n    [build for detecting race conditions. [default=no]])],\n  ,\n  [enable_uyield=\"no\"])\nAC_MSG_RESULT($enable_uyield)\n\n## malloc\nforce_enable_dynamic_malloc_change=\"no\"\n\n# exact-alloc-count\nAC_MSG_CHECKING([whether enable exact-alloc-count])\nAC_ARG_ENABLE(exact-alloc-count,\n  [AS_HELP_STRING([--enable-exact-alloc-count],\n    [atomic counting for memory alloc count. [default=yes]])],,\n  [enable_exact_alloc_count=\"yes\"])\nif test \"x$enable_exact_alloc_count\" != \"xno\"; then\n  AC_DEFINE(USE_EXACT_ALLOC_COUNT, [1], [alloc_count with atomic])\nfi\nAC_MSG_RESULT($enable_exact_alloc_count)\n\n# failmalloc\nAC_MSG_CHECKING([whether enable fmalloc])\nAC_ARG_ENABLE(fmalloc,\n  [AS_HELP_STRING([--enable-fmalloc],\n    [make memory allocation failed in specified condition for debug. [default=no]])],\n  ,\n  [enable_fmalloc=\"no\"])\nif test \"x$enable_fmalloc\" != \"xno\"; then\n  force_enable_dynamic_malloc_change=\"yes\"\n  AC_DEFINE(USE_FAIL_MALLOC, [1], [use fmalloc])\nfi\nAC_MSG_RESULT($enable_fmalloc)\n\n# abort\nAC_MSG_CHECKING([whether enable abort])\nAC_ARG_ENABLE(abort,\n  [AS_HELP_STRING([--enable-abort],\n    [enable query abortion. [default=no]])],\n  ,\n  [enable_abort=\"no\"])\nif test \"x$enable_abort\" != \"xno\"; then\n  force_enable_dynamic_malloc_change=\"yes\"\n  AC_DEFINE(USE_QUERY_ABORT, [1], [use abort])\nfi\nAC_MSG_RESULT($enable_abort)\n\n# dynamic malloc change\nAC_MSG_CHECKING([whether allow dynamic memory allocation change])\nAC_ARG_ENABLE(dynamic-malloc-change,\n  [AS_HELP_STRING([--enable-dynamic-malloc-change],\n    [allow dynamic memory allocation change for testing. [default=no]])],\n  ,\n  [enable_dynamic_malloc_change=\"no\"])\nif test \"x$enable_dynamic_malloc_change\" != \"xyes\" -a \\\n     \"x$force_enable_dynamic_malloc_change\" = \"xyes\"; then\n  enable_dynamic_malloc_change=\"yes\"\n  AC_MSG_RESULT([$enable_dynamic_malloc_change (force)])\nelse\n  AC_MSG_RESULT([$enable_dynamic_malloc_change])\nfi\n\nif test \"x$enable_dynamic_malloc_change\" = \"xyes\"; then\n  AC_DEFINE(USE_DYNAMIC_MALLOC_CHANGE, [1],\n            [Define to 1 if you enable dynamic malloc change])\nfi\n\n# memory debug\nAC_MSG_CHECKING([whether debug memory management])\nAC_ARG_ENABLE(memory-debug,\n  [AS_HELP_STRING([--enable-memory-debug],\n    [debug memory management. [default=no]])],\n  ,\n  [enable_memory_debug=\"no\"])\nAC_MSG_RESULT([$enable_memory_debug])\n\nif test \"x$enable_memory_debug\" = \"xyes\"; then\n  AC_DEFINE(USE_MEMORY_DEBUG, [1],\n            [Define to 1 if you enable debuging memory management])\nfi\n\n# epoll/kqueue/poll/select check\nAC_CHECK_HEADER(sys/epoll.h, [\n  AC_CHECK_FUNC(epoll_create, [\n    AC_TRY_RUN([\n#include <sys/epoll.h>\nint main(int argc, char **argv) { return (epoll_create(16) < 0); }\n    ],\n    [\n      have_epoll=\"yes\"\n      AC_DEFINE(USE_EPOLL, [1], [use epoll])\n    ]\n    )\n  ])\n])\n\nif test \"x$have_epoll\" != \"xyes\"; then\n  AC_CHECK_HEADER(sys/event.h, [\n    AC_CHECK_FUNC(kevent, [\n      have_kqueue=\"yes\"\n      AC_DEFINE(USE_KQUEUE, [1], [use kqueue])\n    ])\n  ])\n  if test \"x$have_kqueue\" != \"xyes\"; then\n    AC_CHECK_HEADER(poll.h, [\n      AC_CHECK_FUNC(poll, [\n        have_poll=\"yes\"\n        AC_DEFINE(USE_POLL, [1], [use poll])\n      ])\n    ])\n    if test \"x$have_poll\" != \"xyes\"; then\n      if test \"$os_win32\" = \"yes\"; then\n        AC_CHECK_HEADER(winsock2.h, [have_select=\"yes\"])\n      else\n        AC_CHECK_FUNC(select, [\n          have_select=\"yes\"\n          AC_CHECK_HEADERS(sys/select.h)\n        ])\n      fi\n      if test \"x$have_select\" = \"xyes\"; then\n        AC_DEFINE(USE_SELECT, [1], [use select])\n      else\n        AC_MSG_ERROR([epoll/kqueue/poll/select is missing.])\n      fi\n    fi\n  fi\nfi\n\n# check MSG_MORE defined\nAC_MSG_CHECKING([whether MSG_MORE defined])\nAC_COMPILE_IFELSE([AC_LANG_PROGRAM([\n#include <sys/types.h>\n#include <sys/socket.h>\n\nint main(int argc, char **argv)\n{\n  return MSG_MORE;\n}\n    ])],\n    [\n      AC_MSG_RESULT(yes)\n      AC_DEFINE(USE_MSG_MORE, [1], [use MSG_MORE])\n    ],\n    [\n      AC_MSG_RESULT(no)\n    ])\n\n# check MSG_NOSIGNAL defined\nAC_MSG_CHECKING([whether MSG_NOSIGNAL defined])\nAC_COMPILE_IFELSE([AC_LANG_PROGRAM([\n#include <sys/types.h>\n#include <sys/socket.h>\n\nint main(int argc, char **argv)\n{\n  return MSG_NOSIGNAL;\n}\n    ])],\n    [\n      AC_MSG_RESULT(yes)\n      AC_DEFINE(USE_MSG_NOSIGNAL, [1], [use MSG_NOSIGNAL])\n    ],\n    [\n      AC_MSG_RESULT(no)\n    ])\n\n# MinGW\nif test \"$os_win32\" = \"yes\"; then\n  WINDOWS_LDFLAGS=\"-mwindows\"\n  WINDOWS_LIBS=\"-ladvapi32 -lws2_32\"\nelse\n  WINDOWS_LDFLAGS=\n  WINDOWS_LIBS=\nfi\nAC_SUBST(WINDOWS_LDFLAGS)\nAC_SUBST(WINDOWS_LIBS)\n\n# groonga binary path\nGROONGA=\"${ac_pwd}/src/groonga\"\nAC_SUBST(GROONGA)\n\n# groonga-benchmark binary path\nGROONGA_BENCHMARK=\"${ac_pwd}/src/groonga-benchmark\"\nAC_SUBST(GROONGA_BENCHMARK)\n\n# groonga-suggest-create-dataset binary path\nGROONGA_SUGGEST_CREATE_DATASET=\"${ac_pwd}/src/suggest/groonga-suggest-create-dataset\"\nAC_SUBST(GROONGA_SUGGEST_CREATE_DATASET)\n\n# groonga-mruby binary path\nGROONGA_MRUBY=\"${ac_pwd}/src/groonga-mruby\"\nAC_SUBST(GROONGA_MRUBY)\n\n# check Cutter with GLib support if available\nREQUIRED_MINIMUM_CUTTER_VERSION=1.1.6\nREQUIRED_MINIMUM_CPPCUTTER_VERSION=1.2.0\nm4_ifdef([AC_CHECK_GCUTTER],\n         [AC_CHECK_GCUTTER(>= $REQUIRED_MINIMUM_CUTTER_VERSION)],\n         [cutter_use_cutter=\"no\"])\nm4_ifdef([AC_CHECK_CPPCUTTER],\n         [AC_CHECK_CPPCUTTER(>= $REQUIRED_MINIMUM_CPPCUTTER_VERSION)],\n         [cutter_use_cppcutter=\"no\"])\n\nAM_CONDITIONAL([WITH_CUTTER], [test \"$cutter_use_cutter\" = \"yes\"])\nAM_CONDITIONAL([WITH_CPPCUTTER], [test \"$cutter_use_cppcutter\" = \"yes\"])\nif test \"$cutter_use_cutter\" = \"yes\"; then\n  AC_DEFINE(GRN_WITH_CUTTER, 1, [Define to 1 if you use Cutter])\nfi\n\n# check for benchmark\nAC_ARG_ENABLE(benchmark,\n  [AS_HELP_STRING([--disable-benchmark],\n    [don't build benchmark programs.])],,\n  [enable_benchmark=\"yes\"])\nif test \"x$enable_benchmark\" = \"xno\"; then\n  benchmark_available=\"no\"\nelse\n  REQUIRED_GLIB_VERSION=2.14.0\n  m4_ifdef([AM_PATH_GLIB_2_0],\n           [AM_PATH_GLIB_2_0($REQUIRED_GLIB_VERSION,\n                             [benchmark_available=\"yes\"],\n                             [benchmark_available=\"no\"],\n                             [gobject gthread])],\n           [benchmark_available=\"no\"])\n  AC_MSG_CHECKING(for benchmark availablity)\n  AC_MSG_RESULT($ac_benchmark_available)\nfi\nif test \"$benchmark_available\" = \"yes\"; then\n  AC_DEFINE(GRN_WITH_BENCHMARK, 1, [Define to 1 if benchamrk is available])\nfi\nAM_CONDITIONAL([WITH_BENCHMARK], [test \"$benchmark_available\" = \"yes\"])\n\n# check Ruby for HTTP test\nac_cv_ruby_available=\"no\"\nAC_ARG_WITH([ruby],\n            AS_HELP_STRING([--with-ruby=PATH],\n                           [Ruby interpreter path (default: no)]),\n            [RUBY=\"$withval\"],\n            [RUBY=\"no\"])\n\nif test \"x$RUBY\" = \"xno\"; then\n  RUBY=\nelse\n  if test \"x$RUBY\" = \"xyes\"; then\n    AC_PATH_PROGS(RUBY,\n                  [ dnl\n                    ruby2.3 ruby23 dnl\n                    ruby2.2 ruby22 dnl\n                    ruby2.1 ruby21 dnl\n                    ruby dnl\n                  ],\n                  ruby-not-found)\n    if test \"$RUBY\" != \"ruby-not-found\"; then\n      ruby_version=\"`$RUBY --version`\"\n      if echo \"$ruby_version\" | grep -q -- 'ruby \\(2\\.\\)'; then\n        ac_cv_ruby_available=\"yes\"\n      else\n        AC_MSG_WARN([$RUBY isn't Ruby 2.0 or later ($ruby_version)])\n      fi\n    fi\n  else\n    ruby_not_found_warning_message=\"$RUBY is not found.\"\n    case \"$RUBY\" in\n    /*)\n      AC_CHECK_FILE([$RUBY],\n                    [ac_cv_ruby_available=\"yes\"],\n                    [AC_MSG_WARN([$ruby_not_found_warning_message])\n                     RUBY=\"$RUBY-not-found\"])\n      ;;\n    *)\n      ruby_not_found=\"$RUBY-not-found\"\n      AC_PATH_PROGS(RUBY, \"$RUBY\", \"$ruby_not_found\")\n      if test \"$RUBY\" = \"$ruby_not_found\"; then\n        AC_MSG_WARN([$ruby_not_found_warning_message])\n      else\n        ac_cv_ruby_available=\"yes\"\n      fi\n      ;;\n    esac\n  fi\nfi\nAC_SUBST(RUBY)\nAM_CONDITIONAL([WITH_RUBY], [test \"$ac_cv_ruby_available\" = \"yes\"])\n\nAM_CONDITIONAL([WITH_UNIT_TEST],\n               [test \"$cutter_use_cutter\" = \"yes\" -o \\\n                     \"$ac_cv_ruby_available\" = \"yes\"])\n\nAM_CONDITIONAL([WITH_COMMAND_TEST],\n               [test \"$ac_cv_ruby_available\" = \"yes\"])\n\n# check Lemon for generating .c and .h files from .y file\nlemon_available=\"no\"\nAC_ARG_WITH([lemon],\n            AS_HELP_STRING([--with-lemon=PATH],\n                           [Lemon path (default: auto)]),\n            [LEMON=\"$withval\"],\n            [: ${LEMON:=auto}])\n\nif test \"$LEMON\" = \"no\"; then\n  LEMON=\nelse\n  if test \"$LEMON\" = \"auto\"; then\n    AC_PATH_PROGS(LEMON, [lemon], none)\n    if test \"$LEMON\" != \"none\"; then\n      lemon_available=\"yes\"\n    fi\n  elif test \"$LEMON\" = \"yes\"; then\n    AC_PATH_PROGS(LEMON, [lemon], none)\n    if test \"$LEMON\" = \"none\"; then\n      AC_MSG_WARN([lemon is not found. Disable .y compilation.])\n    else\n      lemon_available=\"yes\"\n    fi\n  else\n    AC_CHECK_FILE([$LEMON],\n                  [lemon_available=\"yes\"],\n                  [AC_MSG_WARN([$LEMON is not found. Disable .y compilation.])])\n  fi\nfi\nAC_SUBST(LEMON)\nAM_CONDITIONAL([WITH_LEMON], [test \"$lemon_available\" = \"yes\"])\n\n# libedit\nAC_ARG_ENABLE(libedit,\n  [AS_HELP_STRING([--disable-libedit],\n    [use libedit for console. [default=auto-detect]])],\n  [enable_libedit=\"$enableval\"],\n  [enable_libedit=\"auto\"])\nif test \"x$enable_libedit\" != \"xno\"; then\n  m4_ifdef([PKG_CHECK_MODULES], [\n    PKG_CHECK_MODULES([LIBEDIT], [libedit >= 3.0],\n      [LIBS_SAVE=\"$LIBS\"\n       LDFLAGS_SAVE=\"$LDFLAGS\"\n       LDFLAGS=\"$LIBEDIT_LIBS $LDFLAGS\"\n       AC_SEARCH_LIBS(el_wline, edit,\n                      [libedit_available=yes],\n                      [libedit_available=no])\n       LIBS=\"$LIBS_SAVE\"\n       LDFLAGS=\"$LDFLAGS_SAVE\"],\n      [libedit_available=no])\n    ],\n    [libedit_available=no])\n  if test \"x$libedit_available\" = \"xyes\"; then\n    AC_DEFINE(GRN_WITH_LIBEDIT, [1], [Use libedit with multibyte support.])\n  else\n    if test \"x$enable_editline\" = \"xyes\"; then\n      AC_MSG_ERROR(\"No libedit found\")\n    fi\n  fi\nfi\n\n# zlib\nAC_ARG_WITH(zlib,\n  [AS_HELP_STRING([--with-zlib],\n    [Support data compression by zlib. [default=auto]])],\n  [with_zlib=\"$withval\"],\n  [with_zlib=\"auto\"])\nGRN_WITH_ZLIB=no\nif test \"x$with_zlib\" != \"xno\"; then\n  # TODO: Support custom zlib include and lib directory by --with-zlib.\n  AC_SEARCH_LIBS(compress, z,\n                 [\n                   GRN_WITH_ZLIB=yes\n                   AC_DEFINE(GRN_WITH_ZLIB, [1],\n                             [Support data compression by zlib.])\n                 ],\n                 [\n                   if test \"x$with_zlib\" != \"xauto\"; then\n                     AC_MSG_ERROR(\"No libz found\")\n                   fi\n                 ])\nfi\nAC_SUBST(GRN_WITH_ZLIB)\n\n# LZ4\nAC_ARG_WITH(lz4,\n  [AS_HELP_STRING([--with-lz4],\n    [Support data compression by LZ4. [default=auto]])],\n  [with_lz4=\"$withval\"],\n  [with_lz4=\"auto\"])\nif test \"x$with_lz4\" != \"xno\"; then\n  m4_ifdef([PKG_CHECK_MODULES], [\n    PKG_CHECK_MODULES([LIBLZ4],\n                      [liblz4],\n                      [GRN_WITH_LZ4=yes],\n                      [GRN_WITH_LZ4=no])\n  ],\n  [GRN_WITH_LZ4=no])\n  if test \"$GRN_WITH_LZ4\" = \"yes\"; then\n    AC_DEFINE(GRN_WITH_LZ4, [1],\n              [Support data compression by LZ4.])\n  else\n    if test \"x$with_lz4\" != \"xauto\"; then\n      AC_MSG_ERROR(\"No liblz4 found\")\n    fi\n  fi\nfi\n\n# Zstandard\nAC_ARG_WITH(zstd,\n  [AS_HELP_STRING([--with-zstd],\n    [Support data compression by Zstandard. [default=auto]])],\n  [with_zstd=\"$withval\"],\n  [with_zstd=\"auto\"])\nif test \"x$with_zstd\" != \"xno\"; then\n  m4_ifdef([PKG_CHECK_MODULES], [\n    PKG_CHECK_MODULES([LIBZSTD],\n                      [libzstd],\n                      [GRN_WITH_ZSTD=yes],\n                      [GRN_WITH_ZSTD=no])\n  ],\n  [GRN_WITH_ZSTD=no])\n  if test \"$GRN_WITH_ZSTD\" = \"yes\"; then\n    AC_DEFINE(GRN_WITH_ZSTD, [1],\n              [Support data compression by Zstandard.])\n  else\n    if test \"x$with_zstd\" != \"xauto\"; then\n      AC_MSG_ERROR(\"No libzstd found\")\n    fi\n  fi\nfi\n\n# jemalloc\nAC_ARG_WITH(jemalloc,\n  [AS_HELP_STRING([--with-jemalloc],\n    [Use jemalloc for memory allocation. [default=no]])],\n  [with_jemalloc=\"$withval\"],\n  [with_jemalloc=\"no\"])\njemalloc_available=\"no\"\nif test \"x$with_jemalloc\" != \"xno\"; then\n  if test \"x$with_jemalloc\" != \"xyes\"; then\n    LDFLAGS=\"-L$with_jemalloc $LDFLAGS\"\n  fi\n  AC_SEARCH_LIBS(malloc_conf, jemalloc,\n                 [jemalloc_available=\"yes\"],\n                 [AC_MSG_ERROR(\"No libjemalloc found\")])\nfi\n\n# Apache Arrow\nAC_ARG_ENABLE(arrow,\n  [AS_HELP_STRING([--disable-arrow],\n    [enable Apache Arrow support. [default=auto-detect]])],\n  [enable_arrow=\"$enableval\"],\n  [enable_arrow=\"auto\"])\nif test \"x$enable_arrow\" != \"xno\"; then\n  m4_ifdef([PKG_CHECK_MODULES], [\n    PKG_CHECK_MODULES([ARROW],\n                      [arrow >= 0.5.0],\n                      [arrow_available=yes],\n                      [arrow_available=no])\n  ],\n  [arrow_available=no])\n  if test \"x$arrow_available\" = \"xyes\"; then\n    AC_DEFINE(GRN_WITH_ARROW, [1], [Enable Apache Arrow support.])\n  else\n    if test \"x$enable_arrow\" = \"xyes\"; then\n      AC_MSG_ERROR(\"No Apache Arrow found\")\n    fi\n  fi\nfi\nAM_CONDITIONAL([GRN_WITH_ARROW], [test \"$arrow_available\" = \"yes\"])\n\n# MeCab\n# NOTE: MUST be checked last\n\nBUNDLED_MECAB_VERSION=m4_include([bundled_mecab_version])\nAC_SUBST(BUNDLED_MECAB_VERSION)\nBUNDLED_MECAB_NAIST_JDIC_VERSION=m4_include([bundled_mecab_naist_jdic_version])\nAC_SUBST(BUNDLED_MECAB_NAIST_JDIC_VERSION)\n\nAC_ARG_WITH(mecab,\n  [AS_HELP_STRING([--with-mecab],\n    [use MeCab for morphological analysis. [default=yes]])],\n  [with_mecab=\"$withval\"],\n  [with_mecab=\"yes\"])\nAC_MSG_CHECKING([whether enable MeCab])\nAC_MSG_RESULT($with_mecab)\nif test \"x$with_mecab\" = \"xyes\"; then\n  # mecab-config\n  AC_ARG_WITH(mecab-config,\n    [AS_HELP_STRING([--with-mecab-config=PATH],\n      [set mecab-config location. [default=auto-detect]])],\n    [if test \"$cross_compiling\" = \"yes\"; then\n       MECAB_CONFIG=\"$withval\"\n     else\n       AC_CHECK_FILE(\"$withval\", MECAB_CONFIG=\"$withval\", MECAB_CONFIG=no)\n     fi],\n    [AC_PATH_PROG(MECAB_CONFIG, mecab-config, no)])\n  if test \"x$MECAB_CONFIG\" = \"xno\"; then\n    with_mecab=\"no\"\n  else\n    MECAB_CPPFLAGS=\"-I`$MECAB_CONFIG --inc-dir`\"\n    MECAB_LDFLAGS=\"-L`$MECAB_CONFIG --libs-only-L`\"\n    _SAVE_LIBS=\"$LIBS\"\n    _SAVE_LDFLAGS=\"$LDFLAGS\"\n    LDFLAGS=\"$LDFLAGS $MECAB_LDFLAGS\"\n    AC_SEARCH_LIBS(mecab_new,\n                   mecab,\n                   [MECAB_LIBS=\"-lmecab $PTHREAD_LIBS\"],\n                   [AC_MSG_ERROR(\"No libmecab found\")],\n                   $PTHREAD_LIBS)\n    LDFLAGS=\"$_SAVE_LDFLAGS\"\n    LIBS=\"$_SAVE_LIBS\"\n    _SAVE_CPPFLAGS=\"$CPPFLAGS\"\n    CPPFLAGS=\"$CPPFLAGS $MECAB_CPPFLAGS\"\n    AC_CHECK_HEADER(mecab.h, , [AC_MSG_ERROR(\"No mecab.h found\")])\n    AC_CHECK_TYPE([mecab_dictionary_info_t],\n                  [AC_DEFINE([HAVE_MECAB_DICTIONARY_INFO_T],\n                             [1],\n                             [Define to 1 if MeCab has the type `mecab_dictionary_info_t'.])],\n                  [],\n                  [[#include <mecab.h>]])\n    CPPFLAGS=\"$_SAVE_CPPFLAGS\"\n    AC_SUBST(MECAB_CPPFLAGS)\n    AC_SUBST(MECAB_LDFLAGS)\n    AC_SUBST(MECAB_LIBS)\n  fi\nfi\nif test \"x$with_mecab\" = \"xyes\"; then\n  AC_DEFINE(GRN_WITH_MECAB, [1], [use MeCab])\nfi\nAM_CONDITIONAL(WITH_MECAB, test \"x$with_mecab\" = \"xyes\")\n\n# KyTea\nREQUIRED_MINIMUM_KYTEA_VERSION=0.4.2\nAC_ARG_WITH(kytea,\n  [AS_HELP_STRING([--with-kytea],\n    [use KyTea for morphological analysis. [default=auto]])],\n  [with_kytea=\"$withval\"],\n  [with_kytea=\"auto\"])\nAC_MSG_CHECKING([whether enable KyTea])\nAC_MSG_RESULT($with_kytea)\nif test \"x$with_kytea\" != \"xno\"; then\n  m4_ifdef([PKG_CHECK_MODULES], [\n    PKG_CHECK_MODULES([KYTEA],\n                      [kytea >= $REQUIRED_MINIMUM_KYTEA_VERSION],\n                      [kytea_exists=yes],\n                      [kytea_exists=no])\n    ],\n    [kytea_exists=no])\n  if test \"$kytea_exists\" = \"no\" -a \"x$with_kytea\" = \"xyes\"; then\n    AC_MSG_ERROR(\"No KyTea found.\")\n  fi\n  with_kytea=\"$kytea_exists\"\nfi\nif test \"x$with_kytea\" = \"xyes\"; then\n  AC_DEFINE(GRN_WITH_KYTEA, [1], [use KyTea])\nfi\nAM_CONDITIONAL(WITH_KYTEA, test \"x$with_kytea\" = \"xyes\")\n\n# libstemmer\nAC_ARG_WITH(libstemmer,\n  [AS_HELP_STRING([--with-libstemmer],\n    [use libstemmer for stemming. [default=auto]])],\n  [with_libstemmer=\"$withval\"],\n  [with_libstemmer=\"auto\"])\nAC_ARG_WITH(libstemmer-include,\n  [AS_HELP_STRING([--with-libstemmer-include],\n    [path to libstemmer.h. [default=auto]])])\nAC_ARG_WITH(libstemmer-lib,\n  [AS_HELP_STRING([--with-libstemmer-lib],\n    [path to libstemmer.so. [default=auto]])])\nAC_MSG_CHECKING([whether enable libstemmer])\nAC_MSG_RESULT($with_libstemmer)\nif test \"x$with_libstemmer\" != \"xno\"; then\n  LIBSTEMMER_CFLAGS=\"\"\n  LIBSTEMMER_LDFLAGS=\"\"\n  LIBSTEMMER_LIBS=\"\"\n\n  CFLAGS_save=\"${CFLAGS}\"\n  LDFLAGS_save=\"${LDFLAGS}\"\n  if test \"x$with_libstemmer\" != \"xauto\"; then\n    if test -z \"${with_libstemmer_include}\"; then\n      with_libstemmer_include=\"${with_libstemmer}/include\"\n    fi\n    LIBSTEMMER_CFLAGS=\"-I${with_libstemmer_include}\"\n    if test -z \"${with_libstemmer_lib}\"; then\n      with_libstemmer_lib=\"${with_libstemmer}/lib\"\n    fi\n    LIBSTEMMER_LDFLAGS=\"-L${with_libstemmer_lib}\"\n    CFLAGS=\"${CFLAGS} ${LIBSTEMMER_CFLAGS}\"\n    LDFLAGS=\"${LDFLAGS} ${LIBSTEMMER_LDFLAGS}\"\n  fi\n  AC_CHECK_HEADERS(libstemmer.h,\n                   [libstemmer_exists=yes],\n                   [libstemmer_exists=no])\n  if test \"$libstemmer_exists\" = \"yes\"; then\n    AC_CHECK_LIB(stemmer, sb_stemmer_list,\n                 [LIBSTEMMER_LIBS=\"-lstemmer\"],\n                 [libstemmer_exists=no])\n  fi\n  CFLAGS=\"${CFLAGS_save}\"\n  LDFLAGS=\"${LDFLAGS_save}\"\n\n  if test \"$libstemmer_exists\" = \"no\" -a \"x$with_libstemmer\" != \"xauto\"; then\n    AC_MSG_ERROR(\"No libstemmer found at ${with_libstemmer_include} and ${with_libstemmer_lib}.\")\n  fi\n  with_libstemmer=\"$libstemmer_exists\"\nfi\nif test \"x$with_libstemmer\" = \"xyes\"; then\n  AC_SUBST(LIBSTEMMER_CFLAGS)\n  AC_SUBST(LIBSTEMMER_LDFLAGS)\n  AC_SUBST(LIBSTEMMER_LIBS)\n  AC_DEFINE(GRN_WITH_LIBSTEMMER, [1], [use libstemmer])\nfi\nAM_CONDITIONAL(WITH_LIBSTEMMER, test \"x$with_libstemmer\" = \"xyes\")\n\n# futex check\nAC_ARG_ENABLE(futex,\n  [AS_HELP_STRING([--enable-futex],\n    [use futex. [default=no]])],\n  ,\n  [enable_futex=\"no\"])\nif test \"x$enable_futex\" != \"xno\"; then\n  AC_CHECK_HEADERS(linux/futex.h sys/syscall.h, [\n    AC_DEFINE(USE_FUTEX, [1], [use futex])\n  ], [\n    AC_MSG_ERROR(\"linux/futex.h or sys/syscall.h not found\")\n  ])\nfi\nAC_MSG_CHECKING([whether enable futex])\nAC_MSG_RESULT($enable_futex)\n\n# ZeroMQ\nAC_ARG_ENABLE(zeromq,\n  [AS_HELP_STRING([--disable-zeromq],\n    [Disable ZeroMQ used for suggestion. [default=auto-detect]])],\n  [enable_zeromq=\"$enableval\"],\n  [enable_zeromq=\"auto\"])\nif test \"x$enable_zeromq\" != \"xno\"; then\n  m4_ifdef([PKG_CHECK_MODULES], [\n    PKG_CHECK_MODULES([LIBZMQ],\n                      [libzmq],\n                      [zeromq_available=yes],\n                      [zeromq_available=no])\n    ],\n    [zeromq_available=no])\n  if test \"x$zeromq_available\" = \"xyes\"; then\n    AC_DEFINE(GRN_WITH_ZEROMQ, [1], [Define to 1 if ZeroMQ is available.])\n  else\n    if test \"x$enable_zeromq\" = \"xyes\"; then\n      AC_MSG_ERROR(\"No ZeroMQ found\")\n    fi\n  fi\nfi\n\n# libevent\nAC_ARG_WITH(libevent,\n  [AS_HELP_STRING([--without-libevent],\n    [Disable libevent used for suggestion. [default=auto]])],\n  [with_libevent=\"$withval\"],\n  [with_libevent=\"auto\"])\n\n# workaround for bundled groonga in MariaDB.\nif test \"x$with_libevent\" = \"xbundled\"; then\n  with_libevent=no\nfi\n\nif test \"x$with_libevent\" != \"xno\"; then\n  if test \"x$with_libevent\" = \"xyes\" -o \"x$with_libevent\" = \"xauto\"; then\n    libevent_cflags=\"\"\n    libevent_ldflags=\"-levent\"\n  else\n    libevent_include_dir=\"$with_libevent/include\"\n    libevent_lib_dir=\"$with_libevent/lib\"\n    if ! test -d \"$libevent_include_dir\" -a -d \"$libevent_lib_dir\"; then\n      AC_MSG_ERROR(\"No libevent found in $with_libevent.\")\n    fi\n    libevent_cflags=\"-I$libevent_include_dir\"\n    libevent_ldflags=\"-L$libevent_lib_dir -levent\"\n  fi\n\n  _SAVE_CFLAGS=\"$CFLAGS\"\n  _SAVE_LDFLAGS=\"$LDFLAGS\"\n  _SAVE_LIBS=\"$LIBS\"\n  CFLAGS=\"$CFLAGS $libevent_cflags\"\n  LDFLAGS=\"$LDFLAGS $libevent_ldflags\"\n  AC_SEARCH_LIBS(event_init, event,\n                 [libevent_available=yes],\n                 [libevent_available=no])\n  CFLAGS=\"$_SAVE_CFLAGS\"\n  LDFLAGS=\"$_SAVE_LDFLAGS\"\n  LIBS=\"$_SAVE_LIBS\"\n  if test \"$libevent_available\" = \"yes\"; then\n    AC_DEFINE(GRN_WITH_LIBEVENT, [1], [Define to 1 if libevent is available.])\n    LIBEVENT_CFLAGS=\"$libevent_cflags\"\n    LIBEVENT_LIBS=\"$libevent_ldflags\"\n  else\n    if test \"$enable_option_checking\" != \"no\" -a \"x$with_libevent\" = \"xyes\"; then\n      AC_MSG_ERROR(\"No libevent found\")\n    fi\n  fi\nfi\nAC_SUBST(LIBEVENT_CFLAGS)\nAC_SUBST(LIBEVENT_LIBS)\n\n# MessagePack\nBUNDLED_MESSAGE_PACK_VERSION=m4_include([bundled_message_pack_version])\nAC_SUBST(BUNDLED_MESSAGE_PACK_VERSION)\n\nAC_ARG_ENABLE(message-pack,\n  [AS_HELP_STRING([--disable-message-pack],\n    [Disable MessagePack support. [default=auto-detect]])],\n  [enable_message_pack=\"$enableval\"],\n  [enable_message_pack=\"auto\"])\nif test \"x$enable_message_pack\" != \"xno\"; then\n  m4_ifdef([PKG_CHECK_MODULES], [\n    PKG_CHECK_MODULES([MESSAGE_PACK], [msgpack],\n      [message_pack_available=yes],\n      [message_pack_available=no])\n    ],\n    [message_pack_vailable=no])\n\n  if test \"$message_pack_available\" = \"no\"; then\n    AC_ARG_WITH(message-pack,\n      [AS_HELP_STRING([--with-message-pack],\n        [Specify prefix where MessagePack is installed. [default=/usr]])],\n      [with_message_pack=\"$withval\"],\n      [with_message_pack=\"/usr\"])\n    _SAVE_CFLAGS=\"$CFLAGS\"\n    _SAVE_LDFLAGS=\"$LDFLAGS\"\n    _SAVE_LIBS=\"$LIBS\"\n    CFLAGS=\"$CFLAGS -I$with_message_pack/include\"\n    LDFLAGS=\"$LDFLAGS -L$with_message_pack/lib\"\n    AC_SEARCH_LIBS(msgpack_version, msgpack,\n                   [message_pack_available=yes],\n                   [message_pack_available=no])\n    CFLAGS=\"$_SAVE_CFLAGS\"\n    LDFLAGS=\"$_SAVE_LDFLAGS\"\n    LIBS=\"$_SAVE_LIBS\"\n\n    if test \"x$message_pack_available\" = \"xyes\"; then\n      MESSAGE_PACK_CFLAGS=\"-I$with_message_pack/include\"\n      MESSAGE_PACK_LIBS=\"-L$with_message_pack/lib -lmsgpackc\"\n    fi\n  fi\n\n  if test \"x$message_pack_available\" = \"xyes\"; then\n    AC_DEFINE(GRN_WITH_MESSAGE_PACK, [1],\n              [Define to 1 if MessagePack is available.])\n  else\n    if test \"x$enable_message_pack\" = \"xyes\"; then\n      AC_MSG_ERROR(\"No MessagePack found\")\n    fi\n  fi\nfi\nAC_SUBST(MESSAGE_PACK_CFLAGS)\nAC_SUBST(MESSAGE_PACK_LIBS)\n\nAM_CONDITIONAL([ENABLE_SUGGEST_LEARNER],\n               [test \"$zeromq_available\" = \"yes\" -a \\\n                     \"$libevent_available\" = \"yes\" -a \\\n                     \"$message_pack_available\" = \"yes\"])\n\n# Check built-in atomic\ncase \"$host\" in\n  i*86*|x86_64*)\n    ;;\n  *)\n    AC_MSG_CHECKING([for platform which requires libatomic])\n    AC_CHECK_LIB(atomic, __atomic_store_8, [ATOMIC_LIBS=\"-latomic\"])\n    AC_SUBST(ATOMIC_LIBS)\n    ;;\nesac\n\n# Document\nAC_MSG_CHECKING([whether enable document])\nAC_ARG_ENABLE(document,\n  [AS_HELP_STRING([--enable-document],\n    [enable document generation by Sphinx. [default=auto]])],\n  [enable_document=\"$enableval\"],\n  [enable_document=\"auto\"])\nAC_MSG_RESULT($enable_document)\n\ndocument_available=no\ndocument_buildable=no\nhave_built_document=no\nif test x\"$enable_document\" != x\"no\"; then\n  if test -f \"$srcdir/doc/build-stamp\"; then\n    document_available=yes\n    have_built_document=yes\n  fi\n\n  if test x\"$enable_document\" = x\"yes\"; then\n    AC_PATH_PROG(SPHINX_BUILD, sphinx-build, [])\n    if test -n \"$SPHINX_BUILD\"; then\n      sphinx_build_version=`\"$SPHINX_BUILD\" --version`\n      if ! echo \"$sphinx_build_version\" | grep -q ' 1\\.[[3-6]]'; then\n        AC_MSG_ERROR([\nsphinx-build is old: $sphinx_build_version\nSphinx 1.3 or later is required.])\n      fi\n      document_available=yes\n      document_buildable=yes\n    else\n      AC_MSG_ERROR([\nNo sphinx-build found.\nInstall it and try again.\n\nHow to install sphinx-build:\n\nFor Debian GNU/Linux based system like Ubuntu:\n  % sudo apt-get install -y python-sphinx\n\nFor Red Hat based system like CentOS:\n  % sudo yum install -y python-pip\n  % sudo pip install sphinx\n\nFor OS X with Homebrew:\n  % brew install python\n  % brew install gettext\n  % export PATH=\"`brew --prefix gettext`/bin:\\$PATH\"\n  % pip install sphinx])\n    fi\n    AC_SUBST(SPHINX_BUILD)\n  fi\nfi\n\n# Check for misc.\nAC_ARG_WITH([cutter-source-path],\n            AS_HELP_STRING([--with-cutter-source-path=PATH],\n                           [Specify Cutter source path for\n                            groonga's release manager.]),\n                           [CUTTER_SOURCE_PATH=\"$withval\"])\ncase \"$CUTTER_SOURCE_PATH\" in\n  \"\"|/*)\n    : # do nothing\n    ;;\n  *)\n    CUTTER_SOURCE_PATH=\"\\$(top_builddir)/${CUTTER_SOURCE_PATH}\"\n    ;;\nesac\nAC_SUBST(CUTTER_SOURCE_PATH)\n\nAM_CONDITIONAL([DOCUMENT_AVAILABLE],\n               [test \"${document_available}\" = \"yes\"])\nAC_MSG_CHECKING([whether document available])\nAC_MSG_RESULT($document_available)\n\nAM_CONDITIONAL([DOCUMENT_BUILDABLE],\n               [test \"${document_buildable}\" = \"yes\"])\nAC_MSG_CHECKING([whether document buildable])\nAC_MSG_RESULT($document_buildable)\n\nAM_CONDITIONAL([HAVE_BUILT_DOCUMENT],\n               [test \"${have_built_document}\" = \"yes\"])\nAC_MSG_CHECKING([whether having built document])\nAC_MSG_RESULT($have_built_document)\n\nDOCUMENT_VERSION=groonga_version\nDOCUMENT_VERSION_FULL=\"$GRN_VERSION\"\nAC_SUBST(DOCUMENT_VERSION)\nAC_SUBST(DOCUMENT_VERSION_FULL)\n\n# Munin plugins\nAC_MSG_CHECKING([whether install munin plugins])\nAC_ARG_WITH(munin-plugins,\n  [AS_HELP_STRING([--with-munin-plugins],\n    [install Munin plugins. [default=no]])],\n  [install_munin_plugins=\"$withval\"],\n  [install_munin_plugins=\"no\"])\nAC_MSG_RESULT($install_munin_plugins)\n\nAM_CONDITIONAL([INSTALL_MUNIN_PLUGINS],\n               [test \"${install_munin_plugins}\" = \"yes\"])\n\n# platform\nAC_MSG_CHECKING([whether package platform])\nAC_ARG_WITH(package-platform,\n  [AS_HELP_STRING([--with-package-platform=PLATFORM],\n    [install package platform related files. [default=no]\n     (supported package platforms: centos, centos5, centos6, centos7, fedora)])],\n  [package_platform=\"$withval\"],\n  [package_platform=\"no\"])\nif test \"$package_platform\" = \"centos\"; then\n  distribution=$(cut -d \" \" -f 1 /etc/redhat-release | tr \"A-Z\" \"a-z\")\n  if grep -q Linux /etc/redhat-release; then\n    distribution_version=$(cut -d \" \" -f 4 /etc/redhat-release)\n  else\n    distribution_version=$(cut -d \" \" -f 3 /etc/redhat-release)\n  fi\n  distribution_version=$(echo ${distribution_version} | sed -e 's/\\..*$//g')\n  package_platform=\"${package_platform}${distribution_version}\"\nfi\nAC_MSG_RESULT($package_platform)\n\nAM_CONDITIONAL([CENTOS_PLATFORM],\n               [test \"${package_platform}\" != \"no\"])\nAM_CONDITIONAL([CENTOS_INIT_PLATFORM],\n               [test \"${package_platform}\" = \"centos5\" ||\n                test \"${package_platform}\" = \"centos6\"])\nAM_CONDITIONAL([CENTOS_SYSTEMD_PLATFORM],\n               [test \"${package_platform}\" = \"centos7\" ||\n                test \"${package_platform}\" = \"fedora\"])\n\n# plugins check\nrelative_pluginsdir_base=\"\\$(PACKAGE)/plugins\"\nAC_SUBST(relative_pluginsdir_base)\nexpanded_relative_pluginsdir_base=\"${PACKAGE}/plugins\"\nAC_SUBST(expanded_relative_pluginsdir_base)\n\nrelative_pluginsdir=\"lib/\\$(relative_pluginsdir_base)\"\nAC_SUBST(relative_pluginsdir)\n\npluginsdir=\"\\${libdir}/\\$(relative_pluginsdir_base)\"\nAC_SUBST(pluginsdir)\nexpanded_pluginsdir=\"\\${libdir}/${expanded_relative_pluginsdir_base}\"\nAC_SUBST(expanded_pluginsdir)\n\ntokenizer_pluginsdir=\"\\${pluginsdir}/tokenizers\"\nAC_SUBST(tokenizer_pluginsdir)\n\nquery_expander_pluginsdir=\"\\${pluginsdir}/query_expanders\"\nAC_SUBST(query_expander_pluginsdir)\n\nsuggest_pluginsdir=\"\\${pluginsdir}/suggest\"\nAC_SUBST(suggest_pluginsdir)\n\nruby_pluginsdir=\"\\${pluginsdir}/ruby\"\nAC_SUBST(ruby_pluginsdir)\n\ntoken_filter_pluginsdir=\"\\${pluginsdir}/token_filters\"\nAC_SUBST(token_filter_pluginsdir)\n\nsharding_pluginsdir=\"\\${pluginsdir}/sharding\"\nAC_SUBST(sharding_pluginsdir)\n\nfunction_pluginsdir=\"\\${pluginsdir}/functions\"\nAC_SUBST(function_pluginsdir)\n\nexpression_rewriter_pluginsdir=\"\\${pluginsdir}/expression_rewriters\"\nAC_SUBST(expression_rewriter_pluginsdir)\n\nAC_MSG_CHECKING(for the suffix of plugin shared libraries)\nshrext_cmds=$(./libtool --config | grep '^shrext_cmds=')\neval $shrext_cmds\nmodule=yes eval suffix=\"$shrext_cmds\"\nAC_MSG_RESULT($suffix)\nif test -z \"$suffix\"; then\n  AC_MSG_ERROR([can't detect plugin suffix])\nfi\nAC_DEFINE_UNQUOTED(GRN_PLUGIN_SUFFIX, [\"$suffix\"], \"plugin suffix\")\n\n# for query expanders\nGRN_QUERY_EXPANDER_TSV_RELATIVE_SYNONYMS_FILE_BASE=\"synonyms.tsv\"\nGRN_QUERY_EXPANDER_TSV_RELATIVE_SYNONYMS_FILE=\"etc/${PACKAGE}/${GRN_QUERY_EXPANDER_TSV_RELATIVE_SYNONYMS_FILE_BASE}\"\nAC_DEFINE_UNQUOTED(GRN_QUERY_EXPANDER_TSV_RELATIVE_SYNONYMS_FILE,\n                   [\"$GRN_QUERY_EXPANDER_TSV_RELATIVE_SYNONYMS_FILE\"],\n                   \"The relative synonyms file for TSV query expander\")\nGRN_QUERY_EXPANDER_TSV_SYNONYMS_PATH=\"`\n  eval echo ${sysconfdir}/${PACKAGE}/${GRN_QUERY_EXPANDER_TSV_RELATIVE_SYNONYMS_FILE_BASE}\n`\"\nAC_DEFINE_UNQUOTED(GRN_QUERY_EXPANDER_TSV_SYNONYMS_FILE,\n                   [\"$GRN_QUERY_EXPANDER_TSV_SYNONYMS_PATH\"],\n                   \"The default synonyms file for TSV query expander\")\n\n# for examples\nexamplesdir=\"\\$(pkgdatadir)/examples\"\nAC_SUBST(examplesdir)\n\nexamples_dictionarydir=\"\\$(examplesdir)/dictionary\"\nAC_SUBST(examples_dictionarydir)\n\n# for ruby scripts\nrelative_ruby_scriptsdir_base=\"\\$(PACKAGE)/scripts/ruby\"\nAC_SUBST(relative_ruby_scriptsdir_base)\nrelative_ruby_scriptsdir=\"lib/\\$(relative_ruby_scriptsdir_base)\"\nAC_SUBST(relative_ruby_scriptsdir)\nruby_scriptsdir=\"\\${libdir}/\\$(relative_ruby_scriptsdir_base)\"\nAC_SUBST(ruby_scriptsdir)\n\n# for document root\nGRN_DEFAULT_DOCUMENT_ROOT_BASE=\"html/admin\"\nGRN_DEFAULT_DOCUMENT_ROOT=\"\\${pkgdatadir}/\\${GRN_DEFAULT_DOCUMENT_ROOT_BASE}\"\nGRN_EXPANDED_DEFAULT_DOCUMENT_ROOT=\"\\${datadir}/${PACKAGE}/${GRN_DEFAULT_DOCUMENT_ROOT_BASE}\"\nGRN_DEFAULT_RELATIVE_DOCUMENT_ROOT=\"share/\\$(PACKAGE)/\\$(GRN_DEFAULT_DOCUMENT_ROOT_BASE)\"\nAC_SUBST(GRN_DEFAULT_DOCUMENT_ROOT_BASE)\nAC_SUBST(GRN_DEFAULT_DOCUMENT_ROOT)\nAC_SUBST(GRN_EXPANDED_DEFAULT_DOCUMENT_ROOT)\nAC_SUBST(GRN_DEFAULT_RELATIVE_DOCUMENT_ROOT)\n\n# flags for compile groonga\nGRN_CFLAGS=\"\"\nAC_SUBST(GRN_CFLAGS)\nGRN_DEFS=\"\"\nGRN_DEFS=\"$GRN_DEFS -DGRN_DLL_FILENAME=L\\\\\\\"\\\"\\$(GRN_DLL_FILENAME)\\\"\\\\\\\"\"\nGRN_DEFS=\"$GRN_DEFS -DGRN_PLUGINS_DIR=\\\\\\\"\\\"\\$(pluginsdir)\\\"\\\\\\\"\"\nGRN_DEFS=\"$GRN_DEFS -DGRN_RELATIVE_PLUGINS_DIR=\\\\\\\"\\\"\\$(relative_pluginsdir)\\\"\\\\\\\"\"\nGRN_DEFS=\"$GRN_DEFS -DGRN_RUBY_SCRIPTS_DIR=\\\\\\\"\\\"\\$(ruby_scriptsdir)\\\"\\\\\\\"\"\nGRN_DEFS=\"$GRN_DEFS -DGRN_RELATIVE_RUBY_SCRIPTS_DIR=\\\\\\\"\\\"\\$(relative_ruby_scriptsdir)\\\"\\\\\\\"\"\nGRN_DEFS=\"$GRN_DEFS -DGRN_LOG_PATH=\\\\\\\"\\\"\\$(grn_log_path)\\\"\\\\\\\"\"\nGRN_DEFS=\"$GRN_DEFS -DGRN_DEFAULT_DOCUMENT_ROOT=\\\\\\\"\\\"\\$(GRN_DEFAULT_DOCUMENT_ROOT)\\\"\\\\\\\"\"\nGRN_DEFS=\"$GRN_DEFS -DGRN_DEFAULT_RELATIVE_DOCUMENT_ROOT=\\\\\\\"\\\"\\$(GRN_DEFAULT_RELATIVE_DOCUMENT_ROOT)\\\"\\\\\\\"\"\nAC_SUBST(GRN_DEFS)\nCFLAGS=\"$CFLAGS $OPT_CFLAGS \"\nLIBS=\"$LIBS $WINDOWS_LIBS\"\nAC_DEFINE_UNQUOTED(CONFIGURE_OPTIONS, \"$ac_configure_args\", \"specified configure options\")\n\n# For groonga.org\nAC_ARG_WITH(groonga-org-path,\n            [AS_HELP_STRING([--with-groonga-org-path=PATH],\n              [specify a path of the groonga.org repository to update groonga.org.])],\n            [GROONGA_ORG_PATH=\"$withval\"],\n            [GROONGA_ORG_PATH=\"\"])\nAC_SUBST(GROONGA_ORG_PATH)\n\n# groonga-httpd\nNGINX_VERSION=m4_include([nginx_version])\nAC_SUBST(NGINX_VERSION)\n\n# groonga-httpd binary path\nGROONGA_HTTPD=\"${ac_pwd}/vendor/nginx-${NGINX_VERSION}/objs/nginx\"\nAC_SUBST(GROONGA_HTTPD)\n\nAC_ARG_ENABLE(groonga_httpd,\n  [AS_HELP_STRING([--enable-groonga-httpd],\n    [enable nginx used for groonga-httpd. [default=yes]])],\n  [enable_groonga_httpd=\"$enableval\"],\n  [enable_groonga_httpd=\"yes\"])\nif test \"x$enable_groonga_httpd\" != \"xno\"; then\n  enable_groonga_httpd=\"yes\"\n  AC_CONFIG_SUBDIRS([src/httpd])\nelse\n  enable_groonga_httpd=\"no\"\nfi\nAM_CONDITIONAL(WITH_GROONGA_HTTPD, test \"$enable_groonga_httpd\" = \"yes\")\n\nGROONGA_HTTPD_PID_PATH=\"`\n  test \\\"$prefix\\\" = NONE && prefix=/usr/local\n  eval echo ${localstatedir}/run/groonga/groonga-httpd.pid\n`\"\nAC_SUBST(GROONGA_HTTPD_PID_PATH)\n\n# mruby\nAC_ARG_ENABLE(mruby,\n  [AS_HELP_STRING([--enable-mruby],\n    [enable mruby. [default=no]])],\n  [enable_mruby=\"$enableval\"],\n  [enable_mruby=\"no\"])\n\nAC_MSG_CHECKING([whether enable mruby])\nif test \"x$enable_mruby\" != \"xyes\"; then\n  enable_mruby=\"no\"\nfi\nAC_MSG_RESULT($enable_mruby)\n\nif test \"$enable_mruby\" = \"yes\"; then\n  if test ! -f \"$srcdir/vendor/mruby/mruby_build.timestamp\" -a \\\n          \"$ac_cv_ruby_available\" != \"yes\"; then\n    AC_MSG_ERROR(--enable-mruby requires --with-ruby)\n  fi\n  AC_DEFINE(GRN_WITH_MRUBY, [1], [Define to 1 if mruby is enabled.])\n  MRUBY_CFLAGS=\"-I\\$(top_srcdir)/vendor/mruby-source/include\"\n  GRN_WITH_MRUBY=\"yes\"\nelse\n  MRUBY_CFLAGS=\"\"\nfi\nAC_SUBST(GRN_WITH_MRUBY)\nAC_SUBST(MRUBY_CFLAGS)\nAM_CONDITIONAL(WITH_MRUBY, test \"$enable_mruby\" = \"yes\")\n\nMRUBY_CPPFLAGS=\"-DMRB_INT64\"\nAC_SUBST(MRUBY_CPPFLAGS)\n\n# This option is used in vendor/onigmo/configure\nAC_ARG_ENABLE(shared-onigmo,\n  [AS_HELP_STRING([--enable-shared-onigmo],\n    [use Onigmo as shared library instead of static library. [default=no]])],\n  [enable_shared_onigmo=\"$enableval\"],\n  [enable_shared_onigmo=\"no\"])\nAM_CONDITIONAL(WITH_SHARED_ONIGMO, test \"$enable_shared_onigmo\" = \"yes\")\n\nAC_ARG_WITH(onigmo,\n  [AS_HELP_STRING([--without-onigmo],\n    [Don't Use Onigmo. [default=bundled]])],\n  [with_onigmo=\"$withval\"],\n  [with_onigmo=\"bundled\"])\nif test \"x$with_onigmo\" != \"xno\"; then\n  GRN_WITH_ONIGMO=\"yes\"\n  if test \"x$with_onigmo\" != \"xbundled\"; then\n    m4_ifdef([PKG_CHECK_MODULES], [\n      PKG_CHECK_MODULES([ONIGMO], [onigmo],\n        [have_onigmo=yes],\n        [have_onigmo=no])\n      ],\n      [have_onigmo=no])\n  fi\n  if test \"x$with_onigmo\" = \"xsystem\" -a \"$have_onigmo\" = \"no\"; then\n    AC_MSG_ERROR(\"No Onigmo found\")\n  fi\n  if test \"x$with_onigmo\" = \"xbundled\" -o \"$have_onigmo\" = \"no\"; then\n    AC_CONFIG_SUBDIRS([vendor/onigmo])\n    ONIGMO_CFLAGS=\"-I\\$(top_srcdir)/vendor/onigmo-source\"\n    ONIGMO_LIBS=\"\\$(top_builddir)/vendor/onigmo-source/libonigmo.la\"\n  fi\n  AC_DEFINE(GRN_WITH_ONIGMO, [1], [Use Onigmo.])\nelse\n  GRN_WITH_ONIGMO=\"no\"\nfi\nAC_SUBST(GRN_WITH_ONIGMO)\nAC_SUBST(ONIGMO_CFLAGS)\nAC_SUBST(ONIGMO_LIBS)\nAM_CONDITIONAL(WITH_BUNDLED_ONIGMO, test \"$with_onigmo\" != \"no\" -a \"x$have_onigmo\" != \"xyes\")\n\n# PCRE\nGRN_WITH_PCRE=no\nAC_ARG_WITH(pcre,\n  [AS_HELP_STRING([--without-pcre],\n    [Don't use PCRE for groonga-httpd. [default=auto-detect]])],\n  [with_pcre=\"$withval\"],\n  [with_pcre=\"auto\"])\nif test \"x$with_pcre\" != \"xno\"; then\n  m4_ifdef([PKG_CHECK_MODULES], [\n    PKG_CHECK_MODULES([PCRE], [libpcre],\n      [_PKG_CONFIG(PCRE_LIBS_ONLY_L, [libs-only-L], [libpcre])\n       PCRE_LIBS_ONLY_L=\"$pkg_cv_PCRE_LIBS_ONLY_L\"\n       GRN_WITH_PCRE=yes],\n      [GRN_WITH_PCRE=no])\n    ],\n    [GRN_WITH_PCRE=no])\n  if test \"x$with_pcre\" = \"xyes\" -a \"$GRN_WITH_PCRE\" != \"yes\"; then\n    AC_MSG_ERROR(\"No PCRE found\")\n  fi\nfi\nAC_SUBST(GRN_WITH_PCRE)\nAC_SUBST(PCRE_CFLAGS)\nAC_SUBST(PCRE_LIBS_ONLY_L)\n\n# SSL\nGRN_WITH_SSL=no\nAC_ARG_WITH(ssl,\n  [AS_HELP_STRING([--without-ssl],\n    [Don't use SSL module for groonga-httpd. [default=auto-detect]])],\n  [with_ssl=\"$withval\"],\n  [with_ssl=\"auto\"])\nif test \"x$with_ssl\" != \"xno\"; then\n  m4_ifdef([PKG_CHECK_MODULES], [\n    PKG_CHECK_MODULES([SSL], [libssl],\n      [_PKG_CONFIG(SSL_LIBS_ONLY_L, [libs-only-L], [libssl])\n       SSL_LIBS_ONLY_L=\"$pkg_cv_SSL_LIBS_ONLY_L\"\n       GRN_WITH_SSL=yes],\n      [GRN_WITH_SSL=no])\n    ],\n    [GRN_WITH_SSL=no])\n  if test \"x$with_ssl\" = \"xyes\" -a \"$GRN_WITH_SSL\" != \"yes\"; then\n    AC_MSG_ERROR(\"No SSL found\")\n  fi\nfi\nAC_SUBST(GRN_WITH_SSL)\nAC_SUBST(SSL_CFLAGS)\nAC_SUBST(SSL_LIBS_ONLY_L)\n\n# For package\nAC_ARG_WITH(rsync-path,\n            [AS_HELP_STRING([--with-rsync-path=PATH],\n            [specify rsync path to upload groonga packages.])],\n            [RSYNC_PATH=\"$withval\"],\n            [RSYNC_PATH=\"packages@packages.groonga.org:public\"])\nAC_SUBST(RSYNC_PATH)\n\nAC_ARG_WITH(launchpad-ppa,\n            [AS_HELP_STRING([--with-launchpad-ppa=PPA],\n            [specify Launchpad Personal Package Archive. [default=groonga-ppa]])],\n            [LAUNCHPAD_PPA=\"$withval\"],\n            [LAUNCHPAD_PPA=\"groonga-ppa\"])\nAC_SUBST(LAUNCHPAD_PPA)\n\nAC_ARG_WITH(launchpad-uploader-pgp-key,\n            [AS_HELP_STRING([--with-launchpad-uploader-pgp-key=KEY],\n            [specify PGP key UID to upload Groonga packages to Launchpad.])],\n            [LAUNCHPAD_UPLOADER_PGP_KEY=\"$withval\"],\n            [LAUNCHPAD_UPLOADER_PGP_KEY=\"\"])\nAC_SUBST(LAUNCHPAD_UPLOADER_PGP_KEY)\n\nGPG_UID=m4_include(gpg_uid)\nAC_SUBST(GPG_UID)\n\npkgsysconfdir=\"\\${sysconfdir}/$PACKAGE_NAME\"\nAC_SUBST(pkgsysconfdir)\n\nGRN_CONFIG_PATH=\"`\n  test \\\"$prefix\\\" = NONE && prefix=/usr/local\n  eval echo ${sysconfdir}/groonga/groonga.conf\n`\"\nAC_DEFINE_UNQUOTED(GRN_CONFIG_PATH, [\"$GRN_CONFIG_PATH\"],\n  [Default command line option configuration file.])\n\nGROONGA_HTTPD_DOCUMENT_ROOT=\"`\n  test \\\"$prefix\\\" = NONE && prefix=/usr/local\n  eval eval eval echo ${GRN_EXPANDED_DEFAULT_DOCUMENT_ROOT}\n`\"\nAC_SUBST(GROONGA_HTTPD_DOCUMENT_ROOT)\n\nGROONGA_HTTPD_DEFAULT_DATABASE_PATH=\"`\n  test \\\"$prefix\\\" = NONE && prefix=/usr/local\n  eval eval eval echo ${localstatedir}/lib/${PACKAGE}/db/db\n`\"\nAC_SUBST(GROONGA_HTTPD_DEFAULT_DATABASE_PATH)\n\nAC_OUTPUT([\n  lib/metadata.rc\n  packages/rpm/centos/groonga.spec\n  packages/apt/debian/groonga-keyring.postrm\n  packages/apt/env.sh\n  packages/yum/env.sh\n  groonga.pc\n  groonga-arrow.pc\n  config.sh\n  groonga-httpd-conf.sh\n  data/groonga-httpd.conf\n  data/logrotate.d/centos/groonga-httpd\n  data/scripts/groonga-httpd-restart\n  data/systemd/centos/groonga-httpd.service\n  ])\n\necho \"$PACKAGE_NAME $PACKAGE_VERSION configuration:\"\necho \"-----------------------\"\necho \"  Compiler:              ${CC}\"\necho \"  CFLAGS:                ${CFLAGS}\"\necho \"  CXXFLAGS:              ${CXXFLAGS}\"\necho \"  Libraries:             ${LIBS}\"\necho \"  Stack size:            ${GRN_STACK_SIZE}\"\necho \"  Document:              ${document_available}\"\necho \"    buildable:           ${document_buildable}\"\necho \"    built:               ${have_built_document}\"\necho \"  Munin plugins:         ${install_munin_plugins}\"\necho \"  Package platform:      ${package_platform}\"\necho\necho \"Paths:\"\necho \"  Install path prefix:   ${prefix}\"\necho \"  Configuration file:    ${GRN_CONFIG_PATH}\"\necho\n\necho \"Tokenizers:\"\necho \"  MeCab:                 $with_mecab\"\nif test \"x$with_mecab\" = \"xyes\"; then\n  echo \"    CPPFLAGS:            $MECAB_CPPFLAGS\"\n  echo \"    LDFLAGS:             $MECAB_LDFLAGS\"\n  echo \"    LIBS:                $MECAB_LIBS\"\nfi\necho \"  KyTea:                 $with_kytea\"\nif test \"x$with_kytea\" = \"xyes\"; then\n  echo \"    CFLAGS:              $KYTEA_CFLAGS\"\n  echo \"    LIBS:                $KYTEA_LIBS\"\nfi\necho\n\necho \"Token filters:\"\necho \"  libstemmer:            $with_libstemmer\"\nif test \"x$with_libstemmer\" = \"xyes\"; then\n  echo \"    CFLAGS:              $LIBSTEMMER_CFLAGS\"\n  echo \"    LIBS:                $LIBSTEMMER_LIBS\"\nfi\necho\n\necho \"Libraries:\"\necho \"  ZeroMQ:                $zeromq_available\"\nif test \"x$zeromq_available\" = \"xyes\"; then\n  echo \"    CFLAGS:              ${LIBZMQ_CFLAGS}\"\n  echo \"    LIBS:                ${LIBZMQ_LIBS}\"\nfi\necho \"  libevent:              $libevent_available\"\nif test \"x$libevent_available\" = \"xyes\"; then\n  echo \"    CFLAGS:              ${LIBEVENT_CFLAGS}\"\n  echo \"    LIBS:                ${LIBEVENT_LIBS}\"\nfi\necho \"  MessagePack:           $message_pack_available\"\nif test \"x$message_pack_available\" = \"xyes\"; then\n  echo \"    CFLAGS:              ${MESSAGE_PACK_CFLAGS}\"\n  echo \"    LIBS:                ${MESSAGE_PACK_LIBS}\"\nfi\necho \"  mruby:                 $enable_mruby\"\necho \"  jemalloc:              $jemalloc_available\"\necho\n\necho \"groonga-httpd:\"\necho \"  enable:                $enable_groonga_httpd\"\nif test \"$enable_groonga_httpd\" = \"yes\"; then\n  echo \"  default database path: $GROONGA_HTTPD_DEFAULT_DATABASE_PATH\"\n  echo \"  PCRE:                  $GRN_WITH_PCRE\"\n  if test \"$GRN_WITH_PCRE\" = \"yes\"; then\n    echo \"    CFLAGS:              $PCRE_CFLAGS\"\n    echo \"    LIBS only -L:        $PCRE_LIBS_ONLY_L\"\n  fi\n  echo \"   SSL:                  $GRN_WITH_SSL\"\n  if test \"$GRN_WITH_SSL\" = \"yes\"; then\n    echo \"    CFLAGS:              $SSL_CFLAGS\"\n    echo \"    LIBS only -L:        $SSL_LIBS_ONLY_L\"\n  fi\nfi\necho\n\necho \"Tools:\"\necho \"  Sphinx:                ${SPHINX_BUILD}\"\necho \"  lemon:                 ${LEMON}\"\necho \"  Ruby:                  ${RUBY}\"\necho \"  Cutter:                ${CUTTER}\"\necho\n\necho \"For packages:\"\necho \"  rsync path:            ${RSYNC_PATH}\"\necho \"  Launchpad PGP key:     ${LAUNCHPAD_UPLOADER_PGP_KEY}\"\necho \"  GPG UID:               ${GPG_UID}\"\necho\n\necho \"Now type 'make' to build $PACKAGE_NAME $PACKAGE_VERSION!\"\n",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/mroonga/vendor/groonga/CMakeLists.txt": "# Copyright(C) 2012-2016 Brazil\n#\n# This library is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Lesser General Public\n# License version 2.1 as published by the Free Software Foundation.\n#\n# This library is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public\n# License along with this library; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1335  USA\n\n# https://buildbot.askmonty.org/buildbot/builders/work-amd64-valgrind/builds/5263/steps/compile/logs/stdio\n# says CMake 2.6.2... We want to drop old software support...\ncmake_minimum_required(VERSION 2.6.2)\n# cmake_minimum_required(VERSION 2.6.4) # CentOS 5\nset(GRN_PROJECT_NAME \"groonga\")\nset(GRN_PROJECT_LABEL \"Groonga\")\nproject(\"${GRN_PROJECT_NAME}\")\n\nif(\"${CMAKE_SOURCE_DIR}\" STREQUAL \"${CMAKE_CURRENT_SOURCE_DIR}\")\n  set(GRN_BUNDLED FALSE)\nelse()\n  set(GRN_BUNDLED TRUE)\nendif()\n\nif(MSVC)\n  if(MSVC_VERSION LESS 1800)\n    set(GRN_OLD_MSVC_MESSAGE \"Groonga supports only MSVC 2013 or later\")\n    if(GRN_BUNDLED)\n      message(STATUS ${GRN_OLD_MSVC_MESSAGE})\n      return()\n    else()\n      message(FATAL_ERROR ${GRN_OLD_MSVC_MESSAGE})\n    endif()\n  endif()\nendif()\n\nif(CMAKE_C_COMPILER_ID STREQUAL \"Clang\")\n  set(CMAKE_COMPILER_IS_CLANGCC ON)\nendif()\nif(CMAKE_CXX_COMPILER_ID STREQUAL \"Clang\")\n  set(CMAKE_COMPILER_IS_CLANGCXX ON)\nendif()\n\nfile(READ \"${CMAKE_CURRENT_SOURCE_DIR}/base_version\" VERSION)\nif(EXISTS \"${CMAKE_CURRENT_SOURCE_DIR}/version.sh\")\n  file(READ \"${CMAKE_CURRENT_SOURCE_DIR}/version.sh\" GRN_VERSION)\nelse()\n  if(NOT EXISTS \"${CMAKE_CURRENT_BINARY_DIR}/version.sh\")\n    if(EXISTS \"${CMAKE_CURRENT_SOURCE_DIR}/.git\" AND EXISTS \"/bin/sh\")\n      execute_process(COMMAND \"${CMAKE_CURRENT_SOURCE_DIR}/version-gen.sh\")\n      file(READ \"${CMAKE_CURRENT_BINARY_DIR}/version.sh\" GRN_VERSION)\n    else()\n      set(GRN_VERSION \"${VERSION}\")\n    endif()\n  endif()\nendif()\nstring(REGEX REPLACE \"(^.*=|\\n)\" \"\" GRN_VERSION \"${GRN_VERSION}\")\nstring(REGEX REPLACE \"\\\\.\" \",\" GRN_VERSION_RC \"${GRN_VERSION}\")\nstring(REGEX REPLACE \"-.*$\" \"\" GRN_VERSION_RC \"${GRN_VERSION_RC}\")\n\ninclude(CheckIncludeFile)\ninclude(CheckFunctionExists)\ninclude(CheckLibraryExists)\ninclude(CheckSymbolExists)\ninclude(CheckCCompilerFlag)\ninclude(CheckCXXCompilerFlag)\ninclude(FindPkgConfig)\ninclude(${CMAKE_CURRENT_SOURCE_DIR}/build/cmake_modules/ReadFileList.cmake)\n\nif(DEFINED GRN_EMBED)\n  set(GRN_EMBED_DEFAULT ${GRN_EMBED})\nelse()\n  set(GRN_EMBED_DEFAULT OFF)\nendif()\nset(GRN_EMBED ${GRN_EMBED_DEFAULT} CACHE BOOL\n  \"Build as a static library to embed into an application\")\n\nset(BIN_DIR \"bin\")\nset(SBIN_DIR \"sbin\")\nset(LIB_DIR \"lib\")\nset(INCLUDE_DIR \"include\")\nset(GRN_INCLUDE_DIR \"include/groonga\")\nset(DATA_DIR \"share\")\nset(GRN_DATA_DIR \"${DATA_DIR}/${GRN_PROJECT_NAME}\")\nset(CONFIG_DIR \"etc\")\nset(GRN_CONFIG_DIR \"${CONFIG_DIR}/${GRN_PROJECT_NAME}\")\nset(GRN_CONFIG_PATH \"${CMAKE_INSTALL_PREFIX}/${GRN_CONFIG_DIR}/groonga.conf\")\n\nset(GRN_LOG_PATH\n  \"${CMAKE_INSTALL_PREFIX}/var/log/${GRN_PROJECT_NAME}/${GRN_PROJECT_NAME}.log\"\n  CACHE FILEPATH \"log file path\")\nset(GRN_DEFAULT_ENCODING\n  \"utf8\"\n  CACHE STRING \"Groonga's default encoding\")\nset(GRN_DEFAULT_MATCH_ESCALATION_THRESHOLD\n  0\n  CACHE STRING \"Groonga's default match escalation threshold\")\nset(GRN_DEFAULT_DOCUMENT_ROOT_BASE\n  \"html/admin\"\n  CACHE PATH \"Groonga's default document root base path\")\nset(GRN_DEFAULT_RELATIVE_DOCUMENT_ROOT\n  \"share/${GRN_PROJECT_NAME}/${GRN_DEFAULT_DOCUMENT_ROOT_BASE}\"\n  CACHE PATH \"Groonga's default relative document root\")\nset(GRN_DEFAULT_DOCUMENT_ROOT\n  \"${CMAKE_INSTALL_PREFIX}/${GRN_DATA_DIR}/${GRN_DEFAULT_DOCUMENT_ROOT_BASE}\"\n  CACHE PATH \"Groonga's default document root\")\nset(GRN_DEFAULT_DB_KEY\n  \"auto\"\n  CACHE STRING \"Groonga's default DB key management algorithm\")\nset(GRN_STACK_SIZE\n  1024\n  CACHE STRING\n  \"DANGER!!! Groonga's stack size. Normarlly, you should not change this variable.\")\nset(GRN_LOCK_TIMEOUT\n  900000\n  CACHE STRING\n  \"timeout to acquire a lock.\")\nset(GRN_LOCK_WAIT_TIME_NANOSECOND\n  1000000\n  CACHE STRING\n  \"wait time in nanosecond to acquire a lock.\")\nset(GRN_RELATIVE_PLUGINS_DIR\n  \"${LIB_DIR}/${GRN_PROJECT_NAME}/plugins\")\nset(GRN_PLUGINS_DIR\n  \"${CMAKE_INSTALL_PREFIX}/${GRN_RELATIVE_PLUGINS_DIR}\")\nset(GRN_PLUGIN_SUFFIX \"${CMAKE_SHARED_MODULE_SUFFIX}\")\nset(GRN_DLL_FILENAME\n  \"${CMAKE_SHARED_LIBRARY_PREFIX}groonga${CMAKE_SHARED_LIBRARY_SUFFIX}\")\nset(GRN_QUERY_EXPANDER_TSV_RELATIVE_SYNONYMS_FILE\n  \"${GRN_CONFIG_DIR}/synonyms.tsv\")\nset(GRN_QUERY_EXPANDER_TSV_SYNONYMS_FILE\n  \"${CMAKE_INSTALL_PREFIX}/${GRN_QUERY_EXPANDER_TSV_RELATIVE_SYNONYMS_FILE}\")\nset(GRN_RELATIVE_RUBY_SCRIPTS_DIR\n  \"${LIB_DIR}/${GRN_PROJECT_NAME}/scripts/ruby\")\nset(GRN_RUBY_SCRIPTS_DIR\n  \"${CMAKE_INSTALL_PREFIX}/${GRN_RELATIVE_RUBY_SCRIPTS_DIR}\")\n\n\nif(CMAKE_COMPILER_IS_GNUCC OR CMAKE_COMPILER_IS_GNUCXX)\n  set(GRN_C_COMPILE_FLAGS \"${GRN_C_COMPILE_FLAGS} -std=gnu99\")\nendif()\n\n\nif(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_COMPILER_IS_CLANGCXX)\n  MY_CHECK_AND_SET_COMPILER_FLAG(\"-Wall\")\n  MY_CHECK_AND_SET_COMPILER_FLAG(\"-Wno-unused-but-set-variable\")\n  MY_CHECK_AND_SET_COMPILER_FLAG(\"-Wno-pointer-sign\")\n  MY_CHECK_AND_SET_COMPILER_FLAG(\"-Wformat\")\n  MY_CHECK_AND_SET_COMPILER_FLAG(\"-Wstrict-aliasing=2\")\n  MY_CHECK_AND_SET_COMPILER_FLAG(\"-fno-strict-aliasing\")\n  MY_CHECK_AND_SET_COMPILER_FLAG(\"-Wno-disabled-optimization\")\n  MY_CHECK_AND_SET_COMPILER_FLAG(\"-Wfloat-equal\")\n  MY_CHECK_AND_SET_COMPILER_FLAG(\"-Wpointer-arith\")\n  MY_CHECK_AND_SET_COMPILER_FLAG(\"-Wbad-function-cast\")\n  if(NOT CMAKE_COMPILER_IS_CLANGCXX)\n    MY_CHECK_AND_SET_COMPILER_FLAG(\"-Wcast-align\")\n  endif()\n  # MY_CHECK_AND_SET_COMPILER_FLAG(\"-Wredundant-decls\")\n  MY_CHECK_AND_SET_COMPILER_FLAG(\"-Wwrite-strings\")\n  MY_CHECK_AND_SET_COMPILER_FLAG(\"-fexceptions\")\n  MY_CHECK_AND_SET_COMPILER_FLAG(\"-fimplicit-templates\")\n  MY_CHECK_AND_SET_COMPILER_FLAG(\"-Wno-unused-parameter\")\n  MY_CHECK_AND_SET_COMPILER_FLAG(\"-Wno-sign-compare\")\n  MY_CHECK_AND_SET_COMPILER_FLAG(\"-Wno-missing-field-initializers\")\n  MY_CHECK_AND_SET_COMPILER_FLAG(\"-Wno-implicit-fallthrough\")\nendif()\n\nif(NOT DEFINED CMAKE_C_COMPILE_OPTIONS_PIC)\n  # For old CMake\n  if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_COMPILER_IS_CLANGCXX)\n    MY_CHECK_AND_SET_COMPILER_FLAG(\"-fPIC\")\n  endif()\nendif()\n\noption(GRN_WITH_DEBUG \"enable debug build.\" OFF)\nif(GRN_WITH_DEBUG)\n  if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_COMPILER_IS_CLANGCXX)\n    set(GRN_C_COMPILE_FLAGS \"${GRN_C_COMPILE_FLAGS} -g3 -O0\")\n    set(GRN_CXX_COMPILE_FLAGS \"${GRN_CXX_COMPILE_FLAGS} -g3 -O0\")\n  endif()\nendif()\n\nadd_definitions(\n  -DHAVE_CONFIG_H\n  )\nif(GRN_EMBED)\n  add_definitions(-DGRN_EMBEDDED)\nendif()\n\nif(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_COMPILER_IS_CLANGCXX)\n  set(_GNU_SOURCE TRUE)\nendif()\n\ninclude_directories(\n  BEFORE\n  ${CMAKE_CURRENT_BINARY_DIR}\n  ${CMAKE_CURRENT_SOURCE_DIR}/include\n  ${CMAKE_CURRENT_SOURCE_DIR}/lib\n  )\n\nmacro(ac_check_headers header)\n  string(REGEX REPLACE \"[/.]\" \"_\" output_variable_name ${header})\n  string(TOUPPER \"${output_variable_name}\" output_variable_name)\n  set(output_variable_name \"HAVE_${output_variable_name}\")\n  check_include_file(${header} ${output_variable_name})\nendmacro()\n\nmacro(ac_check_funcs function)\n  string(TOUPPER \"${function}\" output_variable_name)\n  set(output_variable_name \"HAVE_${output_variable_name}\")\n  check_function_exists(${function} ${output_variable_name})\nendmacro()\n\nmacro(ac_check_symbols symbol files)\n  string(TOUPPER \"${symbol}\" output_variable_name)\n  set(output_variable_name \"HAVE_${output_variable_name}\")\n  check_symbol_exists(${symbol} ${files} ${output_variable_name})\nendmacro()\n\nmacro(ac_check_lib library function)\n  string(REGEX REPLACE \"[/.]\" \"_\" output_variable_base_name ${library})\n  string(TOUPPER \"${output_variable_base_name}\" output_variable_base_name)\n  set(output_variable_name \"HAVE_LIB${output_variable_base_name}\")\n  set(location \"${ARG2}\")\n  check_library_exists(${library} ${function} \"${location}\"\n    ${output_variable_name})\n  if(${output_variable_name})\n    set(${output_variable_base_name}_LIBS \"${library}\")\n  endif()\nendmacro()\n\ninclude(build/ac_macros/check_headers.m4)\ninclude(build/ac_macros/check_functions.m4)\n\nac_check_symbols(fpclassify math.h)\nac_check_lib(m fpclassify)\n\nac_check_lib(dl dlopen)\nac_check_lib(execinfo backtrace)\nif(HAVE_LIBEXECINFO)\n  set(HAVE_BACKTRACE TRUE)\nelse()\n  ac_check_funcs(backtrace)\nendif()\nac_check_lib(rt clock_gettime)\nif(HAVE_LIBRT)\n  set(HAVE_CLOCK_GETTIME TRUE)\nendif()\nif(GRN_EMBED)\n  check_library_exists(stdc++ __cxa_begin_catch \"${ARG2}\"\n    STDCPP)\n  if(STDCPP)\n    set(STDCPP_LIBS \"stdc++\")\n  endif()\nendif()\n\nif(UNIX)\n  ac_check_headers(pthread.h)\n  ac_check_lib(pthread pthread_mutex_init)\n  if(NOT ${HAVE_LIBPTHREAD})\n    message(FATAL_ERROR \"No libpthread found\")\n  endif()\n  ac_check_funcs(pthread_mutexattr_setpshared)\n  ac_check_funcs(pthread_condattr_setpshared)\nendif()\n\noption(GRN_WITH_NFKC \"use NFKC based UTF8 normalization.\" ON)\n\nif(WIN32)\n  ac_check_headers(winsock2.h)\n  if(NOT ${HAVE_WINSOCK2_H})\n    message(FATAL_ERROR \"No winsock2.h found\")\n  endif()\n\n  # FIXME: CMake couldn't detect ws2_32.lib on Windows 8 64bit.\n  # It may be caused by missing library search path for ws2_32.lib.\n  # It seems that Visual Studio (devenv.exe) can find it but link.exe\n  # can't. \"cmake --build\" can find it because it uses Visual Studio\n  # internally. So we assume that we always have ws2_32.lib on Windows.\n  # ac_check_lib(ws2_32 select)\n  set(HAVE_LIBWS2_32 TRUE)\n  set(WS2_32_LIBS \"ws2_32.lib\")\n\n  set(USE_SELECT TRUE)\nelse()\n  ac_check_headers(sys/epoll.h)\n  if(${HAVE_SYS_EPOLL_H})\n    ac_check_funcs(epoll_create)\n    if(${HAVE_EPOLL_CREATE})\n      set(USE_EPOLL TRUE)\n    endif()\n  endif()\n\n  if(NOT USE_EPOLL)\n    ac_check_headers(sys/event.h)\n    if(${HAVE_SYS_EVENT_H})\n      ac_check_funcs(kevent)\n      if(${HAVE_KEVENT})\n        set(USE_KQUEUE TRUE)\n      endif()\n    endif()\n\n    if(NOT USE_KQUEUE)\n      ac_check_headers(poll.h)\n      if(${HAVE_SYS_POLL_H})\n        ac_check_funcs(poll)\n        if(${HAVE_POLL})\n          set(USE_POLL TRUE)\n        endif()\n      endif()\n\n      if(NOT USE_POLL)\n        ac_check_funcs(select)\n        if(${HAVE_SELECT})\n          set(USE_SELECT TRUE)\n          ac_check_headers(sys/select.h)\n        endif()\n\n        if(NOT USE_SELECT)\n          message(FATAL_ERROR \"All epoll/kqueue/poll/select are missing\")\n        endif()\n      endif()\n    endif()\n  endif()\nendif()\n\nset(GRN_WITH_ZLIB \"auto\"\n  CACHE STRING \"Support data compression by zlib.\")\nif(NOT ${GRN_WITH_ZLIB} STREQUAL \"no\")\n  ac_check_lib(z compress)\n  if(NOT HAVE_LIBZ)\n    if(${GRN_WITH_ZLIB} STREQUAL \"yes\")\n      message(FATAL_ERROR \"No libz found\")\n    endif()\n    set(GRN_WITH_ZLIB \"no\")\n  endif()\nendif()\n\nfile(READ \"${CMAKE_CURRENT_SOURCE_DIR}/bundled_lz4_version\"\n  GRN_BUNDLED_LZ4_VERSION)\nstring(STRIP\n  \"${GRN_BUNDLED_LZ4_VERSION}\"\n  GRN_BUNDLED_LZ4_VERSION)\noption(GRN_WITH_BUNDLED_LZ4 \"use bundled LZ4\" OFF)\n\nset(GRN_WITH_LZ4 \"auto\"\n  CACHE STRING \"Support data compression by LZ4.\")\nif(NOT ${GRN_WITH_LZ4} STREQUAL \"no\")\n  if(GRN_WITH_BUNDLED_LZ4)\n    set(LIBLZ4_INCLUDE_DIRS\n      \"${CMAKE_CURRENT_SOURCE_DIR}/vendor/lz4-${GRN_BUNDLED_LZ4_VERSION}/lib\")\n    set(LZ4_LIBS liblz4)\n  else()\n    if(NOT DEFINED LIBLZ4_FOUND)\n      pkg_check_modules(LIBLZ4 liblz4)\n    endif()\n    if(LIBLZ4_FOUND)\n      # According to CMake documentation, this is the recommended way to force\n      # looking in LIBRARY_DIRS first and in regular system paths otherwise.\n      #\n      # pkg_check_modules does not guarantee that LIBLZ4_LIBRARY_DIRS will be\n      # set. If it's not set we won't find the library without looking through\n      # the regular system paths.\n      find_library(LZ4_LIBS\n        NAMES ${LIBLZ4_LIBRARIES}\n        PATHS ${LIBLZ4_LIBRARY_DIRS}\n        NO_DEFAULT_PATH)\n      find_library(LZ4_LIBS\n        NAMES ${LIBLZ4_LIBRARIES})\n      set(GRN_WITH_LZ4 TRUE)\n    else()\n      if(${GRN_WITH_LZ4} STREQUAL \"yes\")\n\tmessage(FATAL_ERROR \"No LZ4 found\")\n      endif()\n      set(GRN_WITH_LZ4 FALSE)\n    endif()\n  endif()\nendif()\n\n\nfile(READ \"${CMAKE_CURRENT_SOURCE_DIR}/bundled_mecab_version\"\n  GRN_BUNDLED_MECAB_VERSION)\nstring(STRIP\n  \"${GRN_BUNDLED_MECAB_VERSION}\"\n  GRN_BUNDLED_MECAB_VERSION)\nfile(READ \"${CMAKE_CURRENT_SOURCE_DIR}/bundled_mecab_naist_jdic_version\"\n  GRN_BUNDLED_MECAB_NAIST_JDIC_VERSION)\nstring(STRIP\n  \"${GRN_BUNDLED_MECAB_NAIST_JDIC_VERSION}\"\n  GRN_BUNDLED_MECAB_NAIST_JDIC_VERSION)\noption(GRN_WITH_BUNDLED_MECAB \"use bundled MeCab\" OFF)\n\nset(GRN_WITH_MECAB \"auto\"\n  CACHE STRING \"use MeCab for morphological analysis\")\nif(NOT ${GRN_WITH_MECAB} STREQUAL \"no\")\n  if(GRN_WITH_BUNDLED_MECAB)\n    set(MECAB_INCLUDE_DIRS\n      \"${CMAKE_CURRENT_SOURCE_DIR}/vendor/mecab-${GRN_BUNDLED_MECAB_VERSION}/src\")\n    set(MECAB_LIBRARY_DIRS\n      \"${CMAKE_CURRENT_BUILD_DIR}/vendor/mecab\")\n    set(MECAB_LIBRARIES libmecab)\n  else()\n    set(GRN_MECAB_CONFIG \"mecab-config\" CACHE FILEPATH \"mecab-config path\")\n    if(NOT CMAKE_CROSSCOMPILING)\n      find_program(GRN_MECAB_CONFIG_ABSOLUTE_PATH \"${GRN_MECAB_CONFIG}\")\n    endif()\n    if(EXISTS \"${GRN_MECAB_CONFIG_ABSOLUTE_PATH}\")\n      execute_process(COMMAND \"${GRN_MECAB_CONFIG_ABSOLUTE_PATH}\" --inc-dir\n\tOUTPUT_VARIABLE MECAB_INCLUDE_DIRS\n\tOUTPUT_STRIP_TRAILING_WHITESPACE)\n      execute_process(COMMAND \"${GRN_MECAB_CONFIG_ABSOLUTE_PATH}\" --libs-only-L\n\tOUTPUT_VARIABLE MECAB_LIBRARY_DIRS\n\tOUTPUT_STRIP_TRAILING_WHITESPACE)\n      set(MECAB_LIBRARIES \"mecab\")\n      ac_check_lib(${MECAB_LIBRARIES} mecab_new)\n      if(HAVE_LIBMECAB)\n\tset(GRN_WITH_MECAB TRUE)\n      else()\n\tif(${GRN_WITH_MECAB} STREQUAL \"yes\")\n\t  message(FATAL_ERROR\n\t    \"No MeCab library found: \"\n\t    \"include directories: <${MECAB_INCLUDE_DIRS}>, \"\n\t    \"library directories: <${MECAB_LIBRARY_DIRS}>\")\n\tendif()\n\tset(GRN_WITH_MECAB FALSE)\n      endif()\n    else()\n      if(${GRN_WITH_MECAB} STREQUAL \"yes\")\n\tmessage(FATAL_ERROR \"No mecab-config found: <${GRN_MECAB_CONFIG}>\")\n      endif()\n      set(GRN_WITH_MECAB FALSE)\n    endif()\n  endif()\nelse()\n  set(GRN_WITH_MECAB FALSE)\nendif()\n\nset(GRN_WITH_KYTEA \"auto\"\n  CACHE STRING \"use KyTea for morphological analysis\")\nif(NOT ${GRN_WITH_KYTEA} STREQUAL \"no\")\n  if(NOT DEFINED KYTEA_FOUND)\n    pkg_check_modules(KYTEA kytea)\n  endif()\n  if(KYTEA_FOUND)\n    set(GRN_WITH_KYTEA TRUE)\n  else()\n    if(${GRN_WITH_KYTEA} STREQUAL \"yes\")\n      message(FATAL_ERROR \"No KyTea found\")\n    endif()\n    set(GRN_WITH_KYTEA FALSE)\n  endif()\nelse()\n  set(GRN_WITH_KYTEA FALSE)\nendif()\n\nset(GRN_WITH_LIBSTEMMER \"auto\"\n  CACHE STRING \"use libstemmer for stemming token filter\")\nif(NOT ${GRN_WITH_LIBSTEMMER} STREQUAL \"no\")\n  if(NOT (\"${GRN_WITH_LIBSTEMMER}\" STREQUAL \"yes\" OR\n\t\"${GRN_WITH_LIBSTEMMER}\" STREQUAL \"auto\"))\n    if(\"${LIBSTEMMER_INCLUDE_DIRS}\" STREQUAL \"\")\n      set(LIBSTEMMER_INCLUDE_DIRS \"${GRN_WITH_LIBSTEMMER}/include\")\n    endif()\n    if(\"${LIBSTEMMER_LIBRARY_DIRS}\" STREQUAL \"\")\n      set(LIBSTEMMER_LIBRARY_DIRS \"${GRN_WITH_LIBSTEMMER}/lib\")\n    endif()\n  endif()\n  set(CMAKE_REQUIRED_INCLUDES_SAVE ${CMAKE_REQUIRED_INCLUDES})\n  set(CMAKE_REQUIRED_INCLUDES\n    ${CMAKE_REQUIRED_INCLUDES}\n    ${LIBSTEMMER_INCLUDE_DIRS})\n  ac_check_headers(libstemmer.h)\n  ac_check_lib(stemmer sb_stemmer_list \"${LIBSTEMMER_LIBRARY_DIRS}\")\n  set(CMAKE_REQUIRED_INCLUDES ${CMAKE_REQUIRED_INCLUDES_SAVE})\n  if(HAVE_LIBSTEMMER_H AND HAVE_LIBSTEMMER)\n    set(LIBSTEMMER_LIBRARIES \"stemmer\")\n    set(GRN_WITH_LIBSTEMMER TRUE)\n  else()\n    if(${GRN_WITH_LIBSTEMMER} STREQUAL \"yes\")\n      message(FATAL_ERROR \"No libstemmer found\")\n    endif()\n    set(GRN_WITH_LIBSTEMMER FALSE)\n  endif()\nelse()\n  set(GRN_WITH_LIBSTEMMER FALSE)\nendif()\n\nset(GRN_WITH_ZEROMQ \"auto\"\n  CACHE STRING \"use ZeroMQ for suggestion\")\nif(NOT ${GRN_WITH_ZEROMQ} STREQUAL \"no\")\n  if(NOT DEFINED ZEROMQ_FOUND)\n    pkg_check_modules(ZEROMQ libzmq)\n  endif()\n  if(ZEROMQ_FOUND)\n    set(GRN_WITH_ZEROMQ TRUE)\n  else()\n    if(${GRN_WITH_ZEROMQ} STREQUAL \"yes\")\n      message(FATAL_ERROR \"No ZeroMQ found\")\n    endif()\n    set(GRN_WITH_ZEROMQ FALSE)\n  endif()\nelse()\n  set(GRN_WITH_ZEROMQ FALSE)\nendif()\n\nset(GRN_WITH_LIBEVENT \"auto\"\n  CACHE STRING \"use libevent for suggestion\")\nif(NOT ${GRN_WITH_LIBEVENT} STREQUAL \"no\")\n  if(\"${GRN_WITH_LIBEVENT}\" STREQUAL \"yes\" OR\n      \"${GRN_WITH_LIBEVENT}\" STREQUAL \"auto\")\n    set(LIBEVENT_INCLUDE_DIRS \"\")\n    set(LIBEVENT_LIBRARY_DIRS \"\")\n  else()\n    set(LIBEVENT_INCLUDE_DIRS \"${GRN_WITH_LIBEVENT}/include\")\n    set(LIBEVENT_LIBRARY_DIRS \"${GRN_WITH_LIBEVENT}/lib\")\n  endif()\n  set(CMAKE_REQUIRED_INCLUDES_SAVE ${CMAKE_REQUIRED_INCLUDES})\n  ac_check_lib(event event_init \"${LIBEVENT_LIBRARY_DIRS}\")\n  set(CMAKE_REQUIRED_INCLUDES ${CMAKE_REQUIRED_INCLUDES_SAVE})\n  if(HAVE_LIBEVENT)\n    set(LIBEVENT_LIBRARIES \"event\")\n    set(GRN_WITH_LIBEVENT TRUE)\n  else()\n    if(${GRN_WITH_LIBEVENT} STREQUAL \"yes\")\n      message(FATAL_ERROR \"No libevent found\")\n    endif()\n    set(GRN_WITH_LIBEVENT FALSE)\n  endif()\nelse()\n  set(GRN_WITH_LIBEVENT FALSE)\nendif()\n\nfile(READ \"${CMAKE_CURRENT_SOURCE_DIR}/bundled_message_pack_version\"\n  GRN_BUNDLED_MESSAGE_PACK_VERSION)\nstring(STRIP\n  \"${GRN_BUNDLED_MESSAGE_PACK_VERSION}\"\n  GRN_BUNDLED_MESSAGE_PACK_VERSION)\noption(GRN_WITH_BUNDLED_MESSAGE_PACK \"use bundled MessagePack\" OFF)\n\nset(GRN_WITH_MESSAGE_PACK \"auto\"\n  CACHE STRING \"use MessagePack for suggestion\")\nif(NOT ${GRN_WITH_MESSAGE_PACK} STREQUAL \"no\")\n  if(GRN_WITH_BUNDLED_MESSAGE_PACK)\n    set(MESSAGE_PACK_INCLUDE_DIRS\n      \"${CMAKE_CURRENT_SOURCE_DIR}/vendor/msgpack-${GRN_BUNDLED_MESSAGE_PACK_VERSION}/include\")\n    set(MESSAGE_PACK_LIBS msgpackc)\n  else()\n    if(NOT DEFINED MESSAGE_PACK_FOUND)\n      pkg_check_modules(MESSAGE_PACK msgpack)\n    endif()\n    if(MESSAGE_PACK_FOUND)\n      find_library(MESSAGE_PACK_LIBS\n\tNAMES ${MESSAGE_PACK_LIBRARIES}\n\tPATHS ${MESSAGE_PACK_LIBRARY_DIRS}\n\tNO_DEFAULT_PATH)\n      set(GRN_WITH_MESSAGE_PACK TRUE)\n    else()\n      if(\"${GRN_WITH_MESSAGE_PACK}\" STREQUAL \"yes\" OR\n\t  \"${GRN_WITH_MESSAGE_PACK}\" STREQUAL \"auto\")\n\tset(MESSAGE_PACK_INCLUDE_DIRS \"\")\n\tset(MESSAGE_PACK_LIBRARY_DIRS \"\")\n      else()\n\tset(MESSAGE_PACK_INCLUDE_DIRS \"${GRN_WITH_MESSAGE_PACK}/include\")\n\tset(MESSAGE_PACK_LIBRARY_DIRS \"${GRN_WITH_MESSAGE_PACK}/lib\")\n      endif()\n      set(CMAKE_REQUIRED_INCLUDES_SAVE ${CMAKE_REQUIRED_INCLUDES})\n      ac_check_lib(msgpack msgpack_version \"${MESSAGE_PACK_LIBRARY_DIRS}\")\n      set(CMAKE_REQUIRED_INCLUDES ${CMAKE_REQUIRED_INCLUDES_SAVE})\n      if(HAVE_LIBMSGPACK)\n\tfind_library(MESSAGE_PACK_LIBS\n\t  NAMES \"msgpack\"\n\t  PATHS ${MESSAGE_PACK_LIBRARY_DIRS}\n\t  NO_DEFAULT_PATH)\n\tset(GRN_WITH_MESSAGE_PACK TRUE)\n      else()\n\tif(${GRN_WITH_MESSAGE_PACK} STREQUAL \"yes\")\n\t  message(FATAL_ERROR \"No MessagePack found\")\n\tendif()\n\tset(GRN_WITH_MESSAGE_PACK FALSE)\n      endif()\n    endif()\n  endif()\nelse()\n  set(GRN_WITH_MESSAGE_PACK FALSE)\nendif()\n\nfind_program(RUBY NAMES\n  \"ruby2.3\" \"ruby23\"\n  \"ruby2.2\" \"ruby22\"\n  \"ruby2.1\" \"ruby21\"\n  \"ruby\")\n\noption(GRN_WITH_MRUBY \"use mruby\" OFF)\nif(GRN_WITH_MRUBY)\n  set(MRUBY_INCLUDE_DIRS\n    \"${CMAKE_CURRENT_SOURCE_DIR}/vendor/mruby-source/include\")\n  set(MRUBY_LIBS mruby)\nelse()\n  set(MRUBY_INCLUDE_DIRS \"\")\n  set(MRUBY_LIBS \"\")\nendif()\nset(MRUBY_DEFINITIONS \"MRB_INT64\" \"HAVE_ONIGMO_H\")\n\n# TODO: Support using system Onigmo instead of bundled Onigmo.\n# set(GRN_WITH_ONIGMO ON)\n# set(ONIGMO_INCLUDE_DIRS \"${CMAKE_CURRENT_SOURCE_DIR}/vendor/onigmo-source\")\n# set(ONIGMO_LIBS onigmo)\n\n# TODO: It's for Onigmo static link case. If we support system Onigmo,\n# we need to remove it and add -DEXPORT to Onigmo build.\nadd_definitions(-DONIG_EXTERN=extern)\n\nadd_subdirectory(vendor)\nif(GRN_EMBED)\n  add_subdirectory(plugins)\nendif()\nadd_subdirectory(lib)\nif(NOT GRN_EMBED)\n  add_subdirectory(src)\n  add_subdirectory(plugins)\n  add_subdirectory(include)\n  add_subdirectory(data)\nendif()\n\nconfigure_file(config.h.cmake ${CMAKE_CURRENT_BINARY_DIR}/config.h)\n\nset(GROONGA \"${CMAKE_CURRENT_BINARY_DIR}/src/groonga\")\nset(GROONGA_SUGGEST_CREATE_DATASET\n  \"${CMAKE_CURRENT_BINARY_DIR}/src/suggest/groonga-suggest-create-dataset\")\nset(GROONGA_BENCHMARK \"${CMAKE_CURRENT_BINARY_DIR}/src/groonga-benchmark\")\nconfigure_file(config.sh.in \"${CMAKE_CURRENT_BINARY_DIR}/config.sh\" @ONLY)\n\nset(prefix \"${CMAKE_INSTALL_PREFIX}\")\nset(exec_prefix \"${prefix}\")\nset(bindir \"${CMAKE_INSTALL_PREFIX}/${BIN_DIR}\")\nset(sbindir \"${CMAKE_INSTALL_PREFIX}/${SBIN_DIR}\")\nset(libdir \"${CMAKE_INSTALL_PREFIX}/${LIB_DIR}\")\nset(includedir \"${CMAKE_INSTALL_PREFIX}/${INCLUDE_DIR}\")\nset(datarootdir \"${CMAKE_INSTALL_PREFIX}/${DATA_DIR}\")\nset(datadir \"${datarootdir}\")\nset(expanded_pluginsdir \"${GRN_PLUGINS_DIR}\")\nset(GRN_EXPANDED_DEFAULT_DOCUMENT_ROOT \"${GRN_DEFAULT_DOCUMENT_ROOT}\")\nset(EXEEXT \"${CMAKE_EXECUTABLE_SUFFIX}\")\nconfigure_file(groonga.pc.in \"${CMAKE_CURRENT_BINARY_DIR}/groonga.pc\" @ONLY)\n\nif(NOT GRN_EMBED)\n  install(\n    FILES \"${CMAKE_CURRENT_BINARY_DIR}/groonga.pc\"\n    DESTINATION \"${LIB_DIR}/pkgconfig/\")\nendif()\n\ninstall(FILES\n  \"COPYING\"\n  \"README.md\"\n  DESTINATION \"${GRN_DATA_DIR}\")\n\nadd_subdirectory(vendor/plugins)\n",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/mroonga/vendor/groonga/lib/plugin.c": "/* -*- c-basic-offset: 2 -*- */\n/*\n  Copyright(C) 2012-2017 Brazil\n\n  This library is free software; you can redistribute it and/or\n  modify it under the terms of the GNU Lesser General Public\n  License version 2.1 as published by the Free Software Foundation.\n\n  This library is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n  Lesser General Public License for more details.\n\n  You should have received a copy of the GNU Lesser General Public\n  License along with this library; if not, write to the Free Software\n  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1335  USA\n*/\n#include \"grn.h\"\n#include \"grn_ctx_impl_mrb.h\"\n#include \"grn_proc.h\"\n#include <groonga/plugin.h>\n\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n\n#include <sys/stat.h>\n#ifdef HAVE_DIRENT_H\n# include <dirent.h>\n#endif /* HAVE_DIRENT_H */\n\n#ifndef S_ISREG\n# ifdef _S_IFREG\n#  define S_ISREG(mode) (mode & _S_IFREG)\n# endif /* _S_IFREG */\n#endif /* !S_ISREG */\n\n#include \"grn_db.h\"\n#include \"grn_plugin.h\"\n#include \"grn_ctx_impl.h\"\n#include \"grn_util.h\"\n\n#ifdef GRN_WITH_MRUBY\n# include <mruby.h>\n#endif /* GRN_WITH_MRUBY */\n\nstatic grn_hash *grn_plugins = NULL;\nstatic grn_critical_section grn_plugins_lock;\nstatic grn_ctx grn_plugins_ctx;\n\n#ifdef HAVE_DLFCN_H\n#  include <dlfcn.h>\n#  define grn_dl_open(filename)      dlopen(filename, RTLD_LAZY | RTLD_LOCAL)\n#  define grn_dl_open_error_label()  dlerror()\n#  define grn_dl_close(dl)           (dlclose(dl) == 0)\n#  define grn_dl_close_error_label() dlerror()\n#  define grn_dl_sym(dl, symbol)     dlsym(dl, symbol)\n#  define grn_dl_sym_error_label()   dlerror()\n#  define grn_dl_clear_error()       dlerror()\n#else\n#  define grn_dl_open(filename)      LoadLibrary(filename)\n#  define grn_dl_open_error_label()  \"LoadLibrary\"\n#  define grn_dl_close(dl)           (FreeLibrary(dl) != 0)\n#  define grn_dl_close_error_label() \"FreeLibrary\"\n#  define grn_dl_sym(dl, symbol)     ((void *)GetProcAddress(dl, symbol))\n#  define grn_dl_sym_error_label()   \"GetProcAddress\"\n#  define grn_dl_clear_error()\n#endif\n\n#define GRN_PLUGIN_KEY_SIZE(filename) (strlen((filename)) + 1)\n\nstatic char grn_plugins_dir[GRN_ENV_BUFFER_SIZE];\n\nvoid\ngrn_plugin_init_from_env(void)\n{\n  grn_getenv(\"GRN_PLUGINS_DIR\",\n             grn_plugins_dir,\n             GRN_ENV_BUFFER_SIZE);\n}\n\nstatic int\ncompute_name_size(const char *name, int name_size)\n{\n  if (name_size < 0) {\n    if (name) {\n      name_size = strlen(name);\n    } else {\n      name_size = 0;\n    }\n  }\n  return name_size;\n}\n\ngrn_id\ngrn_plugin_reference(grn_ctx *ctx, const char *filename)\n{\n  grn_id id;\n  grn_plugin **plugin = NULL;\n\n  CRITICAL_SECTION_ENTER(grn_plugins_lock);\n  id = grn_hash_get(&grn_plugins_ctx, grn_plugins,\n                    filename, GRN_PLUGIN_KEY_SIZE(filename),\n                    (void **)&plugin);\n  if (plugin) {\n    (*plugin)->refcount++;\n  }\n  CRITICAL_SECTION_LEAVE(grn_plugins_lock);\n\n  return id;\n}\n\nconst char *\ngrn_plugin_path(grn_ctx *ctx, grn_id id)\n{\n  const char *path;\n  grn_plugin *plugin;\n  int value_size;\n  const char *system_plugins_dir;\n  size_t system_plugins_dir_size;\n\n  if (id == GRN_ID_NIL) {\n    return NULL;\n  }\n\n  CRITICAL_SECTION_ENTER(grn_plugins_lock);\n  value_size = grn_hash_get_value(&grn_plugins_ctx, grn_plugins, id, &plugin);\n  CRITICAL_SECTION_LEAVE(grn_plugins_lock);\n\n  if (!plugin) {\n    return NULL;\n  }\n\n  path = plugin->path;\n  system_plugins_dir = grn_plugin_get_system_plugins_dir();\n  system_plugins_dir_size = strlen(system_plugins_dir);\n  if (strncmp(system_plugins_dir, path, system_plugins_dir_size) == 0) {\n    const char *plugin_name = path + system_plugins_dir_size;\n    while (plugin_name[0] == '/') {\n      plugin_name++;\n    }\n    /* TODO: remove suffix too? */\n    return plugin_name;\n  } else {\n    return path;\n  }\n}\n\n#define GRN_PLUGIN_FUNC_PREFIX \"grn_plugin_impl_\"\n\nstatic grn_rc\ngrn_plugin_call_init(grn_ctx *ctx, grn_id id)\n{\n  grn_plugin *plugin;\n  int size;\n\n  size = grn_hash_get_value(&grn_plugins_ctx, grn_plugins, id, &plugin);\n  if (size == 0) {\n    return GRN_INVALID_ARGUMENT;\n  }\n\n  if (plugin->init_func) {\n    return plugin->init_func(ctx);\n  }\n\n  return GRN_SUCCESS;\n}\n\n#ifdef GRN_WITH_MRUBY\nstatic grn_rc\ngrn_plugin_call_register_mrb(grn_ctx *ctx, grn_id id, grn_plugin *plugin)\n{\n  grn_mrb_data *data;\n  mrb_state *mrb;\n  struct RClass *module;\n  struct RClass *plugin_loader_class;\n  int arena_index;\n\n  grn_ctx_impl_mrb_ensure_init(ctx);\n  if (ctx->rc != GRN_SUCCESS) {\n    return ctx->rc;\n  }\n\n  data = &(ctx->impl->mrb);\n  mrb = data->state;\n  module = data->module;\n\n  {\n    int added;\n    grn_hash_add(ctx, ctx->impl->mrb.registered_plugins,\n                 &id, sizeof(grn_id), NULL, &added);\n    if (!added) {\n      return ctx->rc;\n    }\n  }\n\n  arena_index = mrb_gc_arena_save(mrb);\n  plugin_loader_class = mrb_class_get_under(mrb, module, \"PluginLoader\");\n  mrb_funcall(mrb, mrb_obj_value(plugin_loader_class),\n              \"load_file\", 1, mrb_str_new_cstr(mrb, ctx->impl->plugin_path));\n  mrb_gc_arena_restore(mrb, arena_index);\n  return ctx->rc;\n}\n#endif /*GRN_WITH_MRUBY */\n\nstatic grn_rc\ngrn_plugin_call_register(grn_ctx *ctx, grn_id id)\n{\n  grn_plugin *plugin;\n  int size;\n\n  CRITICAL_SECTION_ENTER(grn_plugins_lock);\n  size = grn_hash_get_value(&grn_plugins_ctx, grn_plugins, id, &plugin);\n  CRITICAL_SECTION_LEAVE(grn_plugins_lock);\n\n  if (size == 0) {\n    return GRN_INVALID_ARGUMENT;\n  }\n\n#ifdef GRN_WITH_MRUBY\n  if (!plugin->dl) {\n    return grn_plugin_call_register_mrb(ctx, id, plugin);\n  }\n#endif /* GRN_WITH_MRUBY */\n\n  if (plugin->register_func) {\n    return plugin->register_func(ctx);\n  }\n\n  return GRN_SUCCESS;\n}\n\nstatic grn_rc\ngrn_plugin_call_fin(grn_ctx *ctx, grn_id id)\n{\n  grn_plugin *plugin;\n  int size;\n\n  size = grn_hash_get_value(&grn_plugins_ctx, grn_plugins, id, &plugin);\n  if (size == 0) {\n    return GRN_INVALID_ARGUMENT;\n  }\n\n  if (plugin->fin_func) {\n    return plugin->fin_func(ctx);\n  }\n\n  return GRN_SUCCESS;\n}\n\nstatic grn_rc\ngrn_plugin_initialize(grn_ctx *ctx, grn_plugin *plugin,\n                      grn_dl dl, grn_id id, const char *path)\n{\n  plugin->dl = dl;\n\n#define GET_SYMBOL(type) do {                                           \\\n  grn_dl_clear_error();                                                 \\\n  plugin->type ## _func = grn_dl_sym(dl, GRN_PLUGIN_FUNC_PREFIX #type); \\\n  if (!plugin->type ## _func) {                                         \\\n    const char *label;                                                  \\\n    label = grn_dl_sym_error_label();                                   \\\n    SERR(\"%s\", label);                                                  \\\n  }                                                                     \\\n} while (0)\n\n  GET_SYMBOL(init);\n  GET_SYMBOL(register);\n  GET_SYMBOL(fin);\n\n#undef GET_SYMBOL\n\n  if (!plugin->init_func || !plugin->register_func || !plugin->fin_func) {\n    ERR(GRN_INVALID_FORMAT,\n        \"init func (%s) %sfound, \"\n        \"register func (%s) %sfound and \"\n        \"fin func (%s) %sfound\",\n        GRN_PLUGIN_FUNC_PREFIX \"init\", plugin->init_func ? \"\" : \"not \",\n        GRN_PLUGIN_FUNC_PREFIX \"register\", plugin->register_func ? \"\" : \"not \",\n        GRN_PLUGIN_FUNC_PREFIX \"fin\", plugin->fin_func ? \"\" : \"not \");\n  }\n\n  if (!ctx->rc) {\n    ctx->impl->plugin_path = path;\n    grn_plugin_call_init(ctx, id);\n    ctx->impl->plugin_path = NULL;\n  }\n\n  return ctx->rc;\n}\n\n#ifdef GRN_WITH_MRUBY\nstatic grn_id\ngrn_plugin_open_mrb(grn_ctx *ctx, const char *filename, size_t filename_size)\n{\n  grn_ctx *plugins_ctx = &grn_plugins_ctx;\n  grn_id id = GRN_ID_NIL;\n  grn_plugin **plugin = NULL;\n\n  grn_ctx_impl_mrb_ensure_init(ctx);\n  if (ctx->rc != GRN_SUCCESS) {\n    return GRN_ID_NIL;\n  }\n\n  if (!ctx->impl->mrb.state) {\n    ERR(GRN_FUNCTION_NOT_IMPLEMENTED, \"mruby support isn't enabled\");\n    return GRN_ID_NIL;\n  }\n\n  id = grn_hash_add(plugins_ctx, grn_plugins, filename, filename_size,\n                    (void **)&plugin, NULL);\n  if (!id) {\n    return id;\n  }\n\n  {\n    grn_ctx *ctx = plugins_ctx;\n    *plugin = GRN_MALLOCN(grn_plugin, 1);\n  }\n  if (!*plugin) {\n    grn_hash_delete_by_id(plugins_ctx, grn_plugins, id, NULL);\n    return GRN_ID_NIL;\n  }\n\n  grn_memcpy((*plugin)->path, filename, filename_size);\n  (*plugin)->dl = NULL;\n  (*plugin)->init_func = NULL;\n  (*plugin)->register_func = NULL;\n  (*plugin)->fin_func = NULL;\n  (*plugin)->refcount = 1;\n\n  return id;\n}\n#endif /* GRN_WITH_MRUBY */\n\ngrn_id\ngrn_plugin_open(grn_ctx *ctx, const char *filename)\n{\n  grn_ctx *plugins_ctx = &grn_plugins_ctx;\n  grn_id id = GRN_ID_NIL;\n  grn_dl dl;\n  grn_plugin **plugin = NULL;\n  size_t filename_size;\n\n  filename_size = GRN_PLUGIN_KEY_SIZE(filename);\n\n  CRITICAL_SECTION_ENTER(grn_plugins_lock);\n  if ((id = grn_hash_get(plugins_ctx, grn_plugins, filename, filename_size,\n                         (void **)&plugin))) {\n    (*plugin)->refcount++;\n    goto exit;\n  }\n\n#ifdef GRN_WITH_MRUBY\n  {\n    const char *mrb_suffix;\n    mrb_suffix = grn_plugin_get_ruby_suffix();\n    if (filename_size > strlen(mrb_suffix) &&\n      strcmp(filename + (strlen(filename) - strlen(mrb_suffix)),\n             mrb_suffix) == 0) {\n      id = grn_plugin_open_mrb(ctx, filename, filename_size);\n      goto exit;\n    }\n  }\n#endif /* GRN_WITH_MRUBY */\n\n  if ((dl = grn_dl_open(filename))) {\n    if ((id = grn_hash_add(plugins_ctx, grn_plugins, filename, filename_size,\n                           (void **)&plugin, NULL))) {\n      {\n        grn_ctx *ctx = plugins_ctx;\n        *plugin = GRN_MALLOCN(grn_plugin, 1);\n      }\n      if (*plugin) {\n        grn_memcpy((*plugin)->path, filename, filename_size);\n        if (grn_plugin_initialize(ctx, *plugin, dl, id, filename)) {\n          {\n            grn_ctx *ctx = plugins_ctx;\n            GRN_FREE(*plugin);\n          }\n          *plugin = NULL;\n        }\n      }\n      if (!*plugin) {\n        grn_hash_delete_by_id(plugins_ctx, grn_plugins, id, NULL);\n        if (grn_dl_close(dl)) {\n          /* Now, __FILE__ set in plugin is invalid. */\n          ctx->errline = 0;\n          ctx->errfile = NULL;\n        } else {\n          const char *label;\n          label = grn_dl_close_error_label();\n          SERR(\"%s\", label);\n        }\n        id = GRN_ID_NIL;\n      } else {\n        (*plugin)->refcount = 1;\n      }\n    } else {\n      if (!grn_dl_close(dl)) {\n        const char *label;\n        label = grn_dl_close_error_label();\n        SERR(\"%s\", label);\n      }\n    }\n  } else {\n    const char *label;\n    label = grn_dl_open_error_label();\n    SERR(\"%s\", label);\n  }\n\nexit:\n  CRITICAL_SECTION_LEAVE(grn_plugins_lock);\n\n  return id;\n}\n\ngrn_rc\ngrn_plugin_close(grn_ctx *ctx, grn_id id)\n{\n  grn_ctx *plugins_ctx = &grn_plugins_ctx;\n  grn_rc rc;\n  grn_plugin *plugin;\n\n  if (id == GRN_ID_NIL) {\n    return GRN_INVALID_ARGUMENT;\n  }\n\n  CRITICAL_SECTION_ENTER(grn_plugins_lock);\n  if (!grn_hash_get_value(plugins_ctx, grn_plugins, id, &plugin)) {\n    rc = GRN_INVALID_ARGUMENT;\n    goto exit;\n  }\n  if (--plugin->refcount) {\n    rc = GRN_SUCCESS;\n    goto exit;\n  }\n  if (plugin->dl) {\n    grn_plugin_call_fin(ctx, id);\n    if (!grn_dl_close(plugin->dl)) {\n      const char *label;\n      label = grn_dl_close_error_label();\n      SERR(\"%s\", label);\n    }\n  }\n  {\n    grn_ctx *ctx = plugins_ctx;\n    GRN_FREE(plugin);\n  }\n  rc = grn_hash_delete_by_id(plugins_ctx, grn_plugins, id, NULL);\n\nexit:\n  CRITICAL_SECTION_LEAVE(grn_plugins_lock);\n\n  return rc;\n}\n\nvoid *\ngrn_plugin_sym(grn_ctx *ctx, grn_id id, const char *symbol)\n{\n  grn_plugin *plugin;\n  grn_dl_symbol func;\n\n  if (id == GRN_ID_NIL) {\n    return NULL;\n  }\n\n  CRITICAL_SECTION_ENTER(grn_plugins_lock);\n  if (!grn_hash_get_value(&grn_plugins_ctx, grn_plugins, id, &plugin)) {\n    func = NULL;\n    goto exit;\n  }\n  grn_dl_clear_error();\n  if (!(func = grn_dl_sym(plugin->dl, symbol))) {\n    const char *label;\n    label = grn_dl_sym_error_label();\n    SERR(\"%s\", label);\n  }\n\nexit:\n  CRITICAL_SECTION_LEAVE(grn_plugins_lock);\n\n  return func;\n}\n\ngrn_rc\ngrn_plugins_init(void)\n{\n  CRITICAL_SECTION_INIT(grn_plugins_lock);\n  grn_ctx_init(&grn_plugins_ctx, 0);\n  grn_plugins = grn_hash_create(&grn_plugins_ctx, NULL,\n                                PATH_MAX, sizeof(grn_plugin *),\n                                GRN_OBJ_KEY_VAR_SIZE);\n  if (!grn_plugins) {\n    grn_ctx_fin(&grn_plugins_ctx);\n    return GRN_NO_MEMORY_AVAILABLE;\n  }\n  return GRN_SUCCESS;\n}\n\ngrn_rc\ngrn_plugins_fin(void)\n{\n  grn_rc rc;\n  if (!grn_plugins) { return GRN_INVALID_ARGUMENT; }\n  GRN_HASH_EACH(&grn_plugins_ctx, grn_plugins, id, NULL, NULL, NULL, {\n    grn_plugin_close(&grn_plugins_ctx, id);\n  });\n  rc = grn_hash_close(&grn_plugins_ctx, grn_plugins);\n  grn_ctx_fin(&grn_plugins_ctx);\n  CRITICAL_SECTION_FIN(grn_plugins_lock);\n  return rc;\n}\n\nconst char *\ngrn_plugin_get_suffix(void)\n{\n  return GRN_PLUGIN_SUFFIX;\n}\n\nconst char *\ngrn_plugin_get_ruby_suffix(void)\n{\n  return \".rb\";\n}\n\ngrn_rc\ngrn_plugin_register_by_path(grn_ctx *ctx, const char *path)\n{\n  grn_obj *db;\n  if (!ctx || !ctx->impl || !(db = ctx->impl->db)) {\n    ERR(GRN_INVALID_ARGUMENT, \"db not initialized\");\n    return ctx->rc;\n  }\n  GRN_API_ENTER;\n  if (GRN_DB_P(db)) {\n    grn_id id;\n    id = grn_plugin_open(ctx, path);\n    if (id) {\n      ctx->impl->plugin_path = path;\n      ctx->rc = grn_plugin_call_register(ctx, id);\n      ctx->impl->plugin_path = NULL;\n      grn_plugin_close(ctx, id);\n    }\n  } else {\n    ERR(GRN_INVALID_ARGUMENT, \"invalid db assigned\");\n  }\n  GRN_API_RETURN(ctx->rc);\n}\n\n#ifdef WIN32\nstatic char *windows_plugins_dir = NULL;\nstatic char windows_plugins_dir_buffer[PATH_MAX];\nstatic const char *\ngrn_plugin_get_default_system_plugins_dir(void)\n{\n  if (!windows_plugins_dir) {\n    const char *base_dir;\n    const char *relative_path = GRN_RELATIVE_PLUGINS_DIR;\n    size_t base_dir_length;\n\n    base_dir = grn_windows_base_dir();\n    base_dir_length = strlen(base_dir);\n    grn_strcpy(windows_plugins_dir_buffer, PATH_MAX, base_dir);\n    grn_strcat(windows_plugins_dir_buffer, PATH_MAX, \"/\");\n    grn_strcat(windows_plugins_dir_buffer, PATH_MAX, relative_path);\n    windows_plugins_dir = windows_plugins_dir_buffer;\n  }\n  return windows_plugins_dir;\n}\n\n#else /* WIN32 */\nstatic const char *\ngrn_plugin_get_default_system_plugins_dir(void)\n{\n  return GRN_PLUGINS_DIR;\n}\n#endif /* WIN32 */\n\nconst char *\ngrn_plugin_get_system_plugins_dir(void)\n{\n  if (grn_plugins_dir[0]) {\n    return grn_plugins_dir;\n  } else {\n    return grn_plugin_get_default_system_plugins_dir();\n  }\n}\n\nstatic char *\ngrn_plugin_find_path_raw(grn_ctx *ctx, const char *path)\n{\n  struct stat path_stat;\n\n  if (stat(path, &path_stat) != 0) {\n    return NULL;\n  }\n\n  if (!S_ISREG(path_stat.st_mode)) {\n    return NULL;\n  }\n\n  return GRN_STRDUP(path);\n}\n\n#ifdef GRN_WITH_MRUBY\nstatic char *\ngrn_plugin_find_path_mrb(grn_ctx *ctx, const char *path, size_t path_len)\n{\n  char mrb_path[PATH_MAX];\n  const char *mrb_suffix;\n  size_t mrb_path_len;\n\n  grn_ctx_impl_mrb_ensure_init(ctx);\n  if (ctx->rc != GRN_SUCCESS) {\n    return NULL;\n  }\n\n  if (!ctx->impl->mrb.state) {\n    return NULL;\n  }\n\n  mrb_suffix = grn_plugin_get_ruby_suffix();\n  mrb_path_len = path_len + strlen(mrb_suffix);\n  if (mrb_path_len >= PATH_MAX) {\n    ERR(GRN_FILENAME_TOO_LONG,\n        \"too long plugin path: <%s%s>\",\n        path, mrb_suffix);\n    return NULL;\n  }\n\n  grn_strcpy(mrb_path, PATH_MAX, path);\n  grn_strcat(mrb_path, PATH_MAX, mrb_suffix);\n  return grn_plugin_find_path_raw(ctx, mrb_path);\n}\n#else /* GRN_WITH_MRUBY */\nstatic char *\ngrn_plugin_find_path_mrb(grn_ctx *ctx, const char *path, size_t path_len)\n{\n  return NULL;\n}\n#endif /* GRN_WITH_MRUBY */\n\nstatic char *\ngrn_plugin_find_path_so(grn_ctx *ctx, const char *path, size_t path_len)\n{\n  char so_path[PATH_MAX];\n  const char *so_suffix;\n  size_t so_path_len;\n\n  so_suffix = grn_plugin_get_suffix();\n  so_path_len = path_len + strlen(so_suffix);\n  if (so_path_len >= PATH_MAX) {\n    ERR(GRN_FILENAME_TOO_LONG,\n        \"too long plugin path: <%s%s>\",\n        path, so_suffix);\n    return NULL;\n  }\n\n  grn_strcpy(so_path, PATH_MAX, path);\n  grn_strcat(so_path, PATH_MAX, so_suffix);\n  return grn_plugin_find_path_raw(ctx, so_path);\n}\n\nstatic char *\ngrn_plugin_find_path_libs_so(grn_ctx *ctx, const char *path, size_t path_len)\n{\n  char libs_so_path[PATH_MAX];\n  const char *base_name;\n  const char *so_suffix;\n  const char *libs_path = \"/.libs\";\n  size_t libs_so_path_len;\n\n  base_name = strrchr(path, '/');\n  if (!base_name) {\n    return NULL;\n  }\n\n  so_suffix = grn_plugin_get_suffix();\n  libs_so_path_len =\n    base_name - path +\n    strlen(libs_path) +\n    strlen(base_name) +\n    strlen(so_suffix);\n  if (libs_so_path_len >= PATH_MAX) {\n    ERR(GRN_FILENAME_TOO_LONG,\n        \"too long plugin path: <%.*s/.libs%s%s>\",\n        (int)(base_name - path), path, base_name, so_suffix);\n    return NULL;\n  }\n\n  libs_so_path[0] = '\\0';\n  grn_strncat(libs_so_path, PATH_MAX, path, base_name - path);\n  grn_strcat(libs_so_path, PATH_MAX, libs_path);\n  grn_strcat(libs_so_path, PATH_MAX, base_name);\n  grn_strcat(libs_so_path, PATH_MAX, so_suffix);\n  return grn_plugin_find_path_raw(ctx, libs_so_path);\n}\n\nchar *\ngrn_plugin_find_path(grn_ctx *ctx, const char *name)\n{\n  const char *plugins_dir;\n  char dir_last_char;\n  char path[PATH_MAX];\n  int name_length, max_name_length;\n  char *found_path = NULL;\n  size_t path_len;\n\n  GRN_API_ENTER;\n  if (name[0] == '/') {\n    path[0] = '\\0';\n  } else {\n    plugins_dir = grn_plugin_get_system_plugins_dir();\n    grn_strcpy(path, PATH_MAX, plugins_dir);\n\n    dir_last_char = plugins_dir[strlen(path) - 1];\n    if (dir_last_char != '/') {\n      grn_strcat(path, PATH_MAX, \"/\");\n    }\n  }\n\n  name_length = strlen(name);\n  max_name_length = PATH_MAX - strlen(path) - 1;\n  if (name_length > max_name_length) {\n    ERR(GRN_INVALID_ARGUMENT,\n        \"plugin name is too long: %d (max: %d) <%s%s>\",\n        name_length, max_name_length,\n        path, name);\n    goto exit;\n  }\n  grn_strcat(path, PATH_MAX, name);\n\n  found_path = grn_plugin_find_path_raw(ctx, path);\n  if (found_path) {\n    goto exit;\n  }\n\n  path_len = strlen(path);\n\n  found_path = grn_plugin_find_path_so(ctx, path, path_len);\n  if (found_path) {\n    goto exit;\n  }\n  if (ctx->rc) {\n    goto exit;\n  }\n\n  found_path = grn_plugin_find_path_libs_so(ctx, path, path_len);\n  if (found_path) {\n    goto exit;\n  }\n  if (ctx->rc) {\n    goto exit;\n  }\n\n  found_path = grn_plugin_find_path_mrb(ctx, path, path_len);\n  if (found_path) {\n    goto exit;\n  }\n  if (ctx->rc) {\n    goto exit;\n  }\n\nexit :\n  GRN_API_RETURN(found_path);\n}\n\nstatic void\ngrn_plugin_set_name_resolve_error(grn_ctx *ctx, const char *name,\n                                  const char *tag)\n{\n  const char *prefix, *prefix_separator, *suffix;\n\n  if (name[0] == '/') {\n    prefix = \"\";\n    prefix_separator = \"\";\n    suffix = \"\";\n  } else {\n    prefix = grn_plugin_get_system_plugins_dir();\n    if (prefix[strlen(prefix) - 1] != '/') {\n      prefix_separator = \"/\";\n    } else {\n      prefix_separator = \"\";\n    }\n    suffix = grn_plugin_get_suffix();\n  }\n  ERR(GRN_NO_SUCH_FILE_OR_DIRECTORY,\n      \"%s cannot find plugin file: <%s%s%s%s>\",\n      tag, prefix, prefix_separator, name, suffix);\n}\n\ngrn_rc\ngrn_plugin_register(grn_ctx *ctx, const char *name)\n{\n  grn_rc rc;\n  char *path;\n\n  GRN_API_ENTER;\n  path = grn_plugin_find_path(ctx, name);\n  if (path) {\n    rc = grn_plugin_register_by_path(ctx, path);\n    GRN_FREE(path);\n  } else {\n    if (ctx->rc == GRN_SUCCESS) {\n      grn_plugin_set_name_resolve_error(ctx, name, \"[plugin][register]\");\n    }\n    rc = ctx->rc;\n  }\n  GRN_API_RETURN(rc);\n}\n\ngrn_rc\ngrn_plugin_unregister_by_path(grn_ctx *ctx, const char *path)\n{\n  grn_obj *db;\n  grn_id plugin_id;\n\n  if (!ctx || !ctx->impl) {\n    ERR(GRN_INVALID_ARGUMENT, \"[plugin][unregister] ctx isn't initialized\");\n    return ctx->rc;\n  }\n\n  db = ctx->impl->db;\n  if (!db) {\n    ERR(GRN_INVALID_ARGUMENT, \"[plugin][unregister] DB isn't initialized\");\n    return ctx->rc;\n  }\n\n  GRN_API_ENTER;\n\n  CRITICAL_SECTION_ENTER(grn_plugins_lock);\n  plugin_id = grn_hash_get(&grn_plugins_ctx, grn_plugins,\n                           path, GRN_PLUGIN_KEY_SIZE(path),\n                           NULL);\n  CRITICAL_SECTION_LEAVE(grn_plugins_lock);\n\n  if (plugin_id == GRN_ID_NIL) {\n    GRN_API_RETURN(ctx->rc);\n  }\n\n  {\n    grn_table_cursor *cursor;\n    grn_id id;\n\n    cursor = grn_table_cursor_open(ctx, db,\n                                   NULL, 0,\n                                   NULL, 0,\n                                   0, -1, GRN_CURSOR_BY_ID);\n    if (!cursor) {\n      GRN_API_RETURN(ctx->rc);\n    }\n\n    while ((id = grn_table_cursor_next(ctx, cursor))) {\n      grn_obj *obj;\n      obj = grn_ctx_at(ctx, id);\n      if (!obj) {\n        continue;\n      }\n      if (obj->header.type == GRN_PROC && DB_OBJ(obj)->range == plugin_id) {\n        grn_obj_remove(ctx, obj);\n      } else {\n        grn_obj_unlink(ctx, obj);\n      }\n    }\n    grn_table_cursor_close(ctx, cursor);\n  }\n\n  GRN_API_RETURN(ctx->rc);\n}\n\ngrn_rc\ngrn_plugin_unregister(grn_ctx *ctx, const char *name)\n{\n  grn_rc rc;\n  char *path;\n\n  GRN_API_ENTER;\n  path = grn_plugin_find_path(ctx, name);\n  if (path) {\n    rc = grn_plugin_unregister_by_path(ctx, path);\n    GRN_FREE(path);\n  } else {\n    if (ctx->rc == GRN_SUCCESS) {\n      grn_plugin_set_name_resolve_error(ctx, name, \"[plugin][unregister]\");\n    }\n    rc = ctx->rc;\n  }\n  GRN_API_RETURN(rc);\n}\n\nvoid\ngrn_plugin_ensure_registered(grn_ctx *ctx, grn_obj *proc)\n{\n#ifdef GRN_WITH_MRUBY\n  grn_id plugin_id;\n  grn_plugin *plugin = NULL;\n\n  if (!(proc->header.flags & GRN_OBJ_CUSTOM_NAME)) {\n    return;\n  }\n\n  plugin_id = DB_OBJ(proc)->range;\n  CRITICAL_SECTION_ENTER(grn_plugins_lock);\n  {\n    const char *value;\n    value = grn_hash_get_value_(&grn_plugins_ctx, grn_plugins, plugin_id, NULL);\n    if (value) {\n      plugin = *((grn_plugin **)value);\n    }\n  }\n  CRITICAL_SECTION_LEAVE(grn_plugins_lock);\n\n  if (!plugin) {\n    return;\n  }\n\n  if (plugin->dl) {\n    return;\n  }\n\n  grn_ctx_impl_mrb_ensure_init(ctx);\n  if (ctx->rc != GRN_SUCCESS) {\n    return;\n  }\n\n  if (!ctx->impl->mrb.state) {\n    return;\n  }\n\n  {\n    grn_id id;\n    int added;\n    id = DB_OBJ(proc)->id;\n    grn_hash_add(ctx, ctx->impl->mrb.checked_procs,\n                 &id, sizeof(grn_id), NULL, &added);\n    if (!added) {\n      return;\n    }\n  }\n\n  ctx->impl->plugin_path = plugin->path;\n  grn_plugin_call_register_mrb(ctx, plugin_id, plugin);\n  ctx->impl->plugin_path = NULL;\n#endif /* GRN_WITH_MRUBY */\n}\n\ngrn_rc\ngrn_plugin_get_names(grn_ctx *ctx, grn_obj *names)\n{\n  grn_hash *processed_paths;\n  const char *system_plugins_dir;\n  const char *native_plugin_suffix;\n  const char *ruby_plugin_suffix;\n  grn_bool is_close_opened_object_mode = GRN_FALSE;\n\n  GRN_API_ENTER;\n\n  if (ctx->rc) {\n    GRN_API_RETURN(ctx->rc);\n  }\n\n  if (grn_thread_get_limit() == 1) {\n    is_close_opened_object_mode = GRN_TRUE;\n  }\n\n  processed_paths = grn_hash_create(ctx, NULL, GRN_TABLE_MAX_KEY_SIZE, 0,\n                                    GRN_OBJ_TABLE_HASH_KEY |\n                                    GRN_OBJ_KEY_VAR_SIZE);\n  if (!processed_paths) {\n    GRN_API_RETURN(ctx->rc);\n  }\n\n  system_plugins_dir = grn_plugin_get_system_plugins_dir();\n  native_plugin_suffix = grn_plugin_get_suffix();\n  ruby_plugin_suffix = grn_plugin_get_ruby_suffix();\n\n  GRN_TABLE_EACH_BEGIN_FLAGS(ctx, grn_ctx_db(ctx), cursor, id,\n                             GRN_CURSOR_BY_ID | GRN_CURSOR_ASCENDING) {\n    void *name;\n    int name_size;\n    grn_obj *object;\n    const char *path;\n    grn_id processed_path_id;\n\n    if (grn_id_is_builtin(ctx, id)) {\n      continue;\n    }\n\n    name_size = grn_table_cursor_get_key(ctx, cursor, &name);\n    if (grn_obj_name_is_column(ctx, name, name_size)) {\n      continue;\n    }\n\n    if (is_close_opened_object_mode) {\n      grn_ctx_push_temporary_open_space(ctx);\n    }\n\n    object = grn_ctx_at(ctx, id);\n    if (!object) {\n      ERRCLR(ctx);\n      goto next_loop;\n    }\n\n    if (!grn_obj_is_proc(ctx, object)) {\n      goto next_loop;\n    }\n\n    path = grn_obj_path(ctx, object);\n    if (!path) {\n      goto next_loop;\n    }\n\n    processed_path_id = grn_hash_get(ctx, processed_paths,\n                                     path, strlen(path),\n                                     NULL);\n    if (processed_path_id != GRN_ID_NIL) {\n      goto next_loop;\n    }\n\n    grn_hash_add(ctx, processed_paths,\n                 path, strlen(path),\n                 NULL, NULL);\n\n    {\n      const char *relative_path;\n      const char *libs_path = \"/.libs/\";\n      const char *start_libs;\n      char name[PATH_MAX];\n\n      name[0] = '\\0';\n      if (strncmp(path, system_plugins_dir, strlen(system_plugins_dir)) == 0) {\n        relative_path = path + strlen(system_plugins_dir);\n      } else {\n        relative_path = path;\n      }\n      start_libs = strstr(relative_path, libs_path);\n      if (start_libs) {\n        grn_strncat(name, PATH_MAX, relative_path, start_libs - relative_path);\n        grn_strcat(name, PATH_MAX, \"/\");\n        grn_strcat(name, PATH_MAX, start_libs + strlen(libs_path));\n      } else {\n        grn_strcat(name, PATH_MAX, relative_path);\n      }\n      if (strlen(name) > strlen(native_plugin_suffix) &&\n          strcmp(name + strlen(name) - strlen(native_plugin_suffix),\n                 native_plugin_suffix) == 0) {\n        name[strlen(name) - strlen(native_plugin_suffix)] = '\\0';\n      } else if (strlen(name) > strlen(ruby_plugin_suffix) &&\n                 strcmp(name + strlen(name) - strlen(ruby_plugin_suffix),\n                        ruby_plugin_suffix) == 0) {\n        name[strlen(name) - strlen(ruby_plugin_suffix)] = '\\0';\n      }\n      grn_vector_add_element(ctx, names,\n                             name, strlen(name),\n                             0, GRN_DB_TEXT);\n    }\n\n  next_loop :\n    if (is_close_opened_object_mode) {\n      grn_ctx_pop_temporary_open_space(ctx);\n    }\n  } GRN_TABLE_EACH_END(ctx, cursor);\n\n  grn_hash_close(ctx, processed_paths);\n\n  GRN_API_RETURN(ctx->rc);\n}\n\nvoid *\ngrn_plugin_malloc(grn_ctx *ctx, size_t size, const char *file, int line,\n                  const char *func)\n{\n  return grn_malloc(ctx, size, file, line, func);\n}\n\nvoid *\ngrn_plugin_calloc(grn_ctx *ctx, size_t size, const char *file, int line,\n                  const char *func)\n{\n  return grn_calloc(ctx, size, file, line, func);\n}\n\nvoid *\ngrn_plugin_realloc(grn_ctx *ctx, void *ptr, size_t size,\n                   const char *file, int line, const char *func)\n{\n  return grn_realloc(ctx, ptr, size, file, line, func);\n}\n\nvoid\ngrn_plugin_free(grn_ctx *ctx, void *ptr, const char *file, int line,\n                const char *func)\n{\n  grn_free(ctx, ptr, file, line, func);\n}\n\nvoid\ngrn_plugin_set_error(grn_ctx *ctx, grn_log_level level, grn_rc error_code,\n                     const char *file, int line, const char *func,\n                     const char *format, ...)\n{\n  char old_error_message[GRN_CTX_MSGSIZE];\n\n  ctx->errlvl = level;\n  ctx->rc = error_code;\n  ctx->errfile = file;\n  ctx->errline = line;\n  ctx->errfunc = func;\n\n  grn_strcpy(old_error_message, GRN_CTX_MSGSIZE, ctx->errbuf);\n\n  {\n    va_list ap;\n    va_start(ap, format);\n    grn_ctx_logv(ctx, format, ap);\n    va_end(ap);\n  }\n\n  if (grn_ctx_impl_should_log(ctx)) {\n    grn_ctx_impl_set_current_error_message(ctx);\n    if (grn_logger_pass(ctx, level)) {\n      char new_error_message[GRN_CTX_MSGSIZE];\n      grn_strcpy(new_error_message, GRN_CTX_MSGSIZE, ctx->errbuf);\n      grn_strcpy(ctx->errbuf, GRN_CTX_MSGSIZE, old_error_message);\n      {\n        va_list ap;\n        va_start(ap, format);\n        grn_logger_putv(ctx, level, file, line, func, format, ap);\n        va_end(ap);\n      }\n      grn_strcpy(ctx->errbuf, GRN_CTX_MSGSIZE, new_error_message);\n    }\n    if (level <= GRN_LOG_ERROR) {\n      grn_plugin_logtrace(ctx, level);\n    }\n  }\n}\n\nvoid\ngrn_plugin_clear_error(grn_ctx *ctx)\n{\n  ERRCLR(ctx);\n}\n\nvoid\ngrn_plugin_backtrace(grn_ctx *ctx)\n{\n  BACKTRACE(ctx);\n}\n\nvoid\ngrn_plugin_logtrace(grn_ctx *ctx, grn_log_level level)\n{\n  if (level <= GRN_LOG_ERROR) {\n    grn_plugin_backtrace(ctx);\n    LOGTRACE(ctx, level);\n  }\n}\n\nstruct _grn_plugin_mutex {\n  grn_critical_section critical_section;\n};\n\ngrn_plugin_mutex *\ngrn_plugin_mutex_open(grn_ctx *ctx)\n{\n  grn_plugin_mutex * const mutex =\n      GRN_PLUGIN_MALLOC(ctx, sizeof(grn_plugin_mutex));\n  if (mutex != NULL) {\n    CRITICAL_SECTION_INIT(mutex->critical_section);\n  }\n  return mutex;\n}\n\ngrn_plugin_mutex *\ngrn_plugin_mutex_create(grn_ctx *ctx)\n{\n  return grn_plugin_mutex_open(ctx);\n}\n\nvoid\ngrn_plugin_mutex_close(grn_ctx *ctx, grn_plugin_mutex *mutex)\n{\n  if (mutex != NULL) {\n    CRITICAL_SECTION_FIN(mutex->critical_section);\n    GRN_PLUGIN_FREE(ctx, mutex);\n  }\n}\n\nvoid\ngrn_plugin_mutex_destroy(grn_ctx *ctx, grn_plugin_mutex *mutex)\n{\n  grn_plugin_mutex_close(ctx, mutex);\n}\n\nvoid\ngrn_plugin_mutex_lock(grn_ctx *ctx, grn_plugin_mutex *mutex)\n{\n  if (mutex != NULL) {\n    CRITICAL_SECTION_ENTER(mutex->critical_section);\n  }\n}\n\nvoid\ngrn_plugin_mutex_unlock(grn_ctx *ctx, grn_plugin_mutex *mutex)\n{\n  if (mutex != NULL) {\n    CRITICAL_SECTION_LEAVE(mutex->critical_section);\n  }\n}\n\ngrn_obj *\ngrn_plugin_proc_alloc(grn_ctx *ctx, grn_user_data *user_data,\n                      grn_id domain, unsigned char flags)\n{\n  return grn_proc_alloc(ctx, user_data, domain, flags);\n}\n\ngrn_obj *\ngrn_plugin_proc_get_vars(grn_ctx *ctx, grn_user_data *user_data)\n{\n  return grn_proc_get_vars(ctx, user_data);\n}\n\ngrn_obj *\ngrn_plugin_proc_get_var(grn_ctx *ctx, grn_user_data *user_data,\n                        const char *name, int name_size)\n{\n  name_size = compute_name_size(name, name_size);\n  return grn_proc_get_var(ctx, user_data, name, name_size);\n}\n\ngrn_bool\ngrn_plugin_proc_get_var_bool(grn_ctx *ctx,\n                             grn_user_data *user_data,\n                             const char *name,\n                             int name_size,\n                             grn_bool default_value)\n{\n  grn_obj *var;\n\n  var = grn_plugin_proc_get_var(ctx, user_data, name, name_size);\n  return grn_proc_option_value_bool(ctx, var, default_value);\n}\n\nint32_t\ngrn_plugin_proc_get_var_int32(grn_ctx *ctx,\n                              grn_user_data *user_data,\n                              const char *name,\n                              int name_size,\n                              int32_t default_value)\n{\n  grn_obj *var;\n\n  var = grn_plugin_proc_get_var(ctx, user_data, name, name_size);\n  return grn_proc_option_value_int32(ctx, var, default_value);\n}\n\nconst char *\ngrn_plugin_proc_get_var_string(grn_ctx *ctx,\n                               grn_user_data *user_data,\n                               const char *name,\n                               int name_size,\n                               size_t *size)\n{\n  grn_obj *var;\n\n  var = grn_plugin_proc_get_var(ctx, user_data, name, name_size);\n  return grn_proc_option_value_string(ctx, var, size);\n}\n\ngrn_content_type\ngrn_plugin_proc_get_var_content_type(grn_ctx *ctx,\n                                     grn_user_data *user_data,\n                                     const char *name,\n                                     int name_size,\n                                     grn_content_type default_value)\n{\n  grn_obj *var;\n\n  var = grn_plugin_proc_get_var(ctx, user_data, name, name_size);\n  return grn_proc_option_value_content_type(ctx, var, default_value);\n}\n\ngrn_obj *\ngrn_plugin_proc_get_var_by_offset(grn_ctx *ctx, grn_user_data *user_data,\n                                  unsigned int offset)\n{\n  return grn_proc_get_var_by_offset(ctx, user_data, offset);\n}\n\ngrn_obj *\ngrn_plugin_proc_get_caller(grn_ctx *ctx, grn_user_data *user_data)\n{\n  grn_obj *caller = NULL;\n  GRN_API_ENTER;\n  grn_proc_get_info(ctx, user_data, NULL, NULL, &caller);\n  GRN_API_RETURN(caller);\n}\n\nconst char *\ngrn_plugin_win32_base_dir(void)\n{\n  return grn_plugin_windows_base_dir();\n}\n\nconst char *\ngrn_plugin_windows_base_dir(void)\n{\n#ifdef WIN32\n  return grn_windows_base_dir();\n#else /* WIN32 */\n  return NULL;\n#endif /* WIN32 */\n}\n\n/*\n  grn_plugin_charlen() takes the length of a string, unlike grn_charlen_().\n */\nint\ngrn_plugin_charlen(grn_ctx *ctx, const char *str_ptr,\n                   unsigned int str_length, grn_encoding encoding)\n{\n  return grn_charlen_(ctx, str_ptr, str_ptr + str_length, encoding);\n}\n\n/*\n  grn_plugin_isspace() takes the length of a string, unlike grn_isspace().\n */\nint\ngrn_plugin_isspace(grn_ctx *ctx, const char *str_ptr,\n                   unsigned int str_length, grn_encoding encoding)\n{\n  if ((str_ptr == NULL) || (str_length == 0)) {\n    return 0;\n  }\n  switch ((unsigned char)str_ptr[0]) {\n  case ' ' :\n  case '\\f' :\n  case '\\n' :\n  case '\\r' :\n  case '\\t' :\n  case '\\v' :\n    return 1;\n  case 0x81 :\n    if ((encoding == GRN_ENC_SJIS) && (str_length >= 2) &&\n        ((unsigned char)str_ptr[1] == 0x40)) {\n      return 2;\n    }\n    break;\n  case 0xA1 :\n    if ((encoding == GRN_ENC_EUC_JP) && (str_length >= 2) &&\n        ((unsigned char)str_ptr[1] == 0xA1)) {\n      return 2;\n    }\n    break;\n  case 0xE3 :\n    if ((encoding == GRN_ENC_UTF8) && (str_length >= 3) &&\n        ((unsigned char)str_ptr[1] == 0x80) &&\n        ((unsigned char)str_ptr[2] == 0x80)) {\n      return 3;\n    }\n    break;\n  default :\n    break;\n  }\n  return 0;\n}\n\ngrn_rc\ngrn_plugin_expr_var_init(grn_ctx *ctx,\n                         grn_expr_var *var,\n                         const char *name,\n                         int name_size)\n{\n  var->name = name;\n  var->name_size = compute_name_size(name, name_size);\n  GRN_TEXT_INIT(&var->value, 0);\n  return GRN_SUCCESS;\n}\n\ngrn_obj *\ngrn_plugin_command_create(grn_ctx *ctx,\n                          const char *name,\n                          int name_size,\n                          grn_proc_func func,\n                          unsigned int n_vars,\n                          grn_expr_var *vars)\n{\n  grn_obj *proc;\n  name_size = compute_name_size(name, name_size);\n  proc = grn_proc_create(ctx, name, name_size, GRN_PROC_COMMAND,\n                         func, NULL, NULL, n_vars, vars);\n  return proc;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/connect/ha_connect.cc": "/* Copyright (C) MariaDB Corporation Ab\n\n  This program is free software; you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation; version 2 of the License.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program; if not, write to the Free Software\n\tFoundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1335 USA */\n\n/**\n  @file ha_connect.cc\n\n  @brief\n  The ha_connect engine is a stubbed storage engine that enables to create tables\n  based on external data. Principally they are based on plain files of many\n  different types, but also on collections of such files, collection of tables,\n  local or remote MySQL/MariaDB tables retrieved via MySQL API,\n  ODBC/JDBC tables retrieving data from other DBMS having an ODBC/JDBC server,\n\tand even virtual tables.\n\n  @details\n  ha_connect will let you create/open/delete tables, the created table can be\n  done specifying an already existing file, the drop table command will just\n  suppress the table definition but not the eventual data file.\n  Indexes are not supported for all table types but data can be inserted,\n  updated or deleted.\n\n  You can enable the CONNECT storage engine in your build by doing the\n  following during your build process:<br> ./configure\n  --with-connect-storage-engine\n\n  You can install the CONNECT handler as all other storage handlers.\n\n  Once this is done, MySQL will let you create tables with:<br>\n  CREATE TABLE <table name> (...) ENGINE=CONNECT;\n\n  The example storage engine does not use table locks. It\n  implements an example \"SHARE\" that is inserted into a hash by table\n  name. This is not used yet.\n\n  Please read the object definition in ha_connect.h before reading the rest\n  of this file.\n\n  @note\n  This MariaDB CONNECT handler is currently an adaptation of the XDB handler\n  that was written for MySQL version 4.1.2-alpha. Its overall design should\n  be enhanced in the future to meet MariaDB requirements.\n\n  @note\n  It was written also from the Brian's ha_example handler and contains parts\n  of it that are there, such as table and system  variables.\n\n  @note\n  When you create an CONNECT table, the MySQL Server creates a table .frm\n  (format) file in the database directory, using the table name as the file\n  name as is customary with MySQL.\n  For file based tables, if a file name is not specified, this is an inward\n  table. An empty file is made in the current data directory that you can\n  populate later like for other engine tables. This file modified on ALTER\n  and is deleted when dropping the table.\n  If a file name is specified, this in an outward table. The specified file\n  will be used as representing the table data and will not be modified or\n  deleted on command such as ALTER or DROP.\n  To get an idea of what occurs, here is an example select that would do\n  a scan of an entire table:\n\n  @code\n  ha-connect::open\n  ha_connect::store_lock\n  ha_connect::external_lock\n  ha_connect::info\n  ha_connect::rnd_init\n  ha_connect::extra\n  ENUM HA_EXTRA_CACHE        Cache record in HA_rrnd()\n  ha_connect::rnd_next\n  ha_connect::rnd_next\n  ha_connect::rnd_next\n  ha_connect::rnd_next\n  ha_connect::rnd_next\n  ha_connect::rnd_next\n  ha_connect::rnd_next\n  ha_connect::rnd_next\n  ha_connect::rnd_next\n  ha_connect::extra\n  ENUM HA_EXTRA_NO_CACHE     End caching of records (def)\n  ha_connect::external_lock\n  ha_connect::extra\n  ENUM HA_EXTRA_RESET        Reset database to after open\n  @endcode\n\n  Here you see that the connect storage engine has 9 rows called before\n  rnd_next signals that it has reached the end of its data. Calls to\n  ha_connect::extra() are hints as to what will be occuring to the request.\n\n\tAuthor  Olivier Bertrand\n\t*/\n\n#ifdef USE_PRAGMA_IMPLEMENTATION\n#pragma implementation        // gcc: Class implementation\n#endif\n\n#define MYSQL_SERVER 1\n#define DONT_DEFINE_VOID\n#include <my_global.h>\n#include \"sql_parse.h\"\n#include \"sql_base.h\"\n#include \"sql_partition.h\"\n#undef  OFFSET\n\n#define NOPARSE\n#define NJDBC\n#if defined(UNIX)\n#include \"osutil.h\"\n#endif   // UNIX\n#include \"global.h\"\n#include \"plgdbsem.h\"\n#include \"xtable.h\"\n#include \"tabext.h\"\n#if defined(ODBC_SUPPORT)\n#include \"odbccat.h\"\n#endif   // ODBC_SUPPORT\n#if defined(JAVA_SUPPORT)\n#include \"tabjdbc.h\"\n#include \"jdbconn.h\"\n#endif   // JAVA_SUPPORT\n#if defined(CMGO_SUPPORT)\n#include \"cmgoconn.h\"\n#endif   // CMGO_SUPPORT\n#include \"tabmysql.h\"\n#include \"filamdbf.h\"\n#include \"tabxcl.h\"\n#include \"tabfmt.h\"\n//#include \"reldef.h\"\n#include \"tabcol.h\"\n#include \"xindex.h\"\n#if defined(__WIN__)\n#include <io.h>\n#include \"tabwmi.h\"\n#endif   // __WIN__\n#include \"connect.h\"\n#include \"user_connect.h\"\n#include \"ha_connect.h\"\n#include \"myutil.h\"\n#include \"preparse.h\"\n#include \"inihandl.h\"\n#if defined(LIBXML2_SUPPORT)\n#include \"libdoc.h\"\n#endif   // LIBXML2_SUPPORT\n#include \"taboccur.h\"\n#include \"tabpivot.h\"\n#include \"tabfix.h\"\n\n#define my_strupr(p)    my_caseup_str(default_charset_info, (p));\n#define my_strlwr(p)    my_casedn_str(default_charset_info, (p));\n#define my_stricmp(a,b) my_strcasecmp(default_charset_info, (a), (b))\n\n\n/***********************************************************************/\n/*  Initialize the ha_connect static members.                          */\n/***********************************************************************/\n#define SZCONV     1024\t\t\t\t\t\t\t// Default converted text size\n#define SZWORK 67108864             // Default work area size 64M\n#define SZWMIN  4194304             // Minimum work area size  4M\n#define JSONMAX      10             // JSON Default max grp size\n\nextern \"C\" {\n       char version[]= \"Version 1.07.0001 November 12, 2019\";\n#if defined(__WIN__)\n       char compver[]= \"Version 1.07.0001 \" __DATE__ \" \"  __TIME__;\n       char slash= '\\\\';\n#else   // !__WIN__\n       char slash= '/';\n#endif  // !__WIN__\n} // extern \"C\"\n\n#if MYSQL_VERSION_ID > 100200\n#define stored_in_db stored_in_db()\n#endif   // MYSQL_VERSION_ID\n\n#if defined(XMAP)\n       my_bool xmap= false;\n#endif   // XMAP\n\nulong  ha_connect::num= 0;\n\n#if defined(XMSG)\nextern \"C\" {\n       char *msg_path;\n} // extern \"C\"\n#endif   // XMSG\n\n#if defined(JAVA_SUPPORT)\n\t     char *JvmPath;\n\t\t\t char *ClassPath;\n#endif   // JAVA_SUPPORT\n\npthread_mutex_t parmut;\npthread_mutex_t usrmut;\npthread_mutex_t tblmut;\n\n#if defined(DEVELOPMENT)\nchar *GetUserVariable(PGLOBAL g, const uchar *varname);\n\nchar *GetUserVariable(PGLOBAL g, const uchar *varname)\n{\n\tchar buf[1024];\n\tbool b;\n\tTHD *thd= current_thd;\n\tCHARSET_INFO *cs= system_charset_info;\n\tString *str= NULL, tmp(buf, sizeof(buf), cs);\n\tHASH uvars= thd->user_vars;\n\tuser_var_entry *uvar= (user_var_entry*)my_hash_search(&uvars, varname, 0);\n\n\tif (uvar)\n\t\tstr= uvar->val_str(&b, &tmp, NOT_FIXED_DEC);\n\n\treturn str ? PlugDup(g, str->ptr()) : NULL;\n}; // end of GetUserVariable\n#endif   // DEVELOPMENT\n\n/***********************************************************************/\n/*  Utility functions.                                                 */\n/***********************************************************************/\nPQRYRES OEMColumns(PGLOBAL g, PTOS topt, char *tab, char *db, bool info);\nPQRYRES VirColumns(PGLOBAL g, bool info);\nPQRYRES JSONColumns(PGLOBAL g, PCSZ db, PCSZ dsn, PTOS topt, bool info);\nPQRYRES XMLColumns(PGLOBAL g, char *db, char *tab, PTOS topt, bool info);\n#if defined(REST_SUPPORT)\nPQRYRES RESTColumns(PGLOBAL g, PTOS topt, char *tab, char *db, bool info);\n#endif // REST_SUPPORT\n#if defined(JAVA_SUPPORT)\nPQRYRES MGOColumns(PGLOBAL g, PCSZ db, PCSZ url, PTOS topt, bool info);\n#endif   // JAVA_SUPPORT\nint     TranslateJDBCType(int stp, char *tn, int prec, int& len, char& v);\nvoid    PushWarning(PGLOBAL g, THD *thd, int level);\nbool    CheckSelf(PGLOBAL g, TABLE_SHARE *s, PCSZ host, PCSZ db,\n\t                                           PCSZ tab, PCSZ src, int port);\n#if defined(ZIP_SUPPORT)\nbool    ZipLoadFile(PGLOBAL, PCSZ, PCSZ, PCSZ, bool, bool);\n#endif   // ZIP_SUPPORT\nbool    ExactInfo(void);\n#if defined(CMGO_SUPPORT)\n//void    mongo_init(bool);\n#endif   // CMGO_SUPPORT\nUSETEMP UseTemp(void);\nint     GetConvSize(void);\nTYPCONV GetTypeConv(void);\nchar   *GetJsonNull(void);\nuint    GetJsonGrpSize(void);\nchar   *GetJavaWrapper(void);\nuint    GetWorkSize(void);\nvoid    SetWorkSize(uint);\nextern \"C\" const char *msglang(void);\n\nstatic void PopUser(PCONNECT xp);\nstatic PCONNECT GetUser(THD *thd, PCONNECT xp);\nstatic PGLOBAL  GetPlug(THD *thd, PCONNECT& lxp);\n\nstatic handler *connect_create_handler(handlerton *hton,\n                                       TABLE_SHARE *table,\n                                       MEM_ROOT *mem_root);\n\nstatic int connect_assisted_discovery(handlerton *hton, THD* thd,\n                                      TABLE_SHARE *table_s,\n                                      HA_CREATE_INFO *info);\n\n/****************************************************************************/\n/*  Return str as a zero terminated string.                                 */\n/****************************************************************************/\nstatic char *strz(PGLOBAL g, LEX_CSTRING &ls)\n{\n  char *str= (char*)PlugSubAlloc(g, NULL, ls.length + 1);\n\n  memcpy(str, ls.str, ls.length);\n  str[ls.length]= 0;\n  return str;\n} // end of strz\n\n/***********************************************************************/\n/*  CONNECT session variables definitions.                             */\n/***********************************************************************/\n// Tracing: 0 no, 1 yes, 2 more, 4 index... 511 all\nconst char *xtrace_names[] =\n{\n\t\"YES\", \"MORE\", \"INDEX\", \"MEMORY\", \"SUBALLOC\",\n\t\"QUERY\", \"STMT\", \"HANDLER\", \"BLOCK\", \"MONGO\", NullS\n};\n\nTYPELIB xtrace_typelib =\n{\n\tarray_elements(xtrace_names) - 1, \"xtrace_typelib\",\n\txtrace_names, NULL\n};\n\nstatic MYSQL_THDVAR_SET(\n\txtrace,                    // name\n\tPLUGIN_VAR_RQCMDARG,       // opt\n\t\"Trace values.\",           // comment\n\tNULL,                      // check\n\tNULL,                      // update function\n\t0,                         // def (NO)\n\t&xtrace_typelib);          // typelib\n\n// Getting exact info values\nstatic MYSQL_THDVAR_BOOL(exact_info, PLUGIN_VAR_RQCMDARG,\n       \"Getting exact info values\",\n       NULL, NULL, 0);\n\n// Enabling cond_push\nstatic MYSQL_THDVAR_BOOL(cond_push, PLUGIN_VAR_RQCMDARG,\n\t\"Enabling cond_push\",\n\tNULL, NULL, 1);\t\t\t\t\t\t\t// YES by default\n\n/**\n  Temporary file usage:\n    no:    Not using temporary file\n    auto:  Using temporary file when needed\n    yes:   Allways using temporary file\n    force: Force using temporary file (no MAP)\n    test:  Reserved\n*/\nconst char *usetemp_names[]=\n{\n  \"NO\", \"AUTO\", \"YES\", \"FORCE\", \"TEST\", NullS\n};\n\nTYPELIB usetemp_typelib=\n{\n  array_elements(usetemp_names) - 1, \"usetemp_typelib\",\n  usetemp_names, NULL\n};\n\nstatic MYSQL_THDVAR_ENUM(\n  use_tempfile,                    // name\n  PLUGIN_VAR_RQCMDARG,             // opt\n  \"Temporary file use.\",           // comment\n  NULL,                            // check\n  NULL,                            // update function\n  1,                               // def (AUTO)\n  &usetemp_typelib);               // typelib\n\n// Size used for g->Sarea_Size\nstatic MYSQL_THDVAR_UINT(work_size,\n       PLUGIN_VAR_RQCMDARG, \n       \"Size of the CONNECT work area.\",\n       NULL, NULL, SZWORK, SZWMIN, UINT_MAX, 1);\n\n// Size used when converting TEXT columns to VARCHAR\nstatic MYSQL_THDVAR_INT(conv_size,\n       PLUGIN_VAR_RQCMDARG,             // opt\n       \"Size used when converting TEXT columns.\",\n       NULL, NULL, SZCONV, 0, 65500, 1);\n\n/**\n  Type conversion:\n    no:   Unsupported types -> TYPE_ERROR\n    yes:  TEXT -> VARCHAR\n\t\tforce: Do it also for ODBC BINARY and BLOBs\n    skip: skip unsupported type columns in Discovery\n*/\nconst char *xconv_names[]=\n{\n  \"NO\", \"YES\", \"FORCE\", \"SKIP\", NullS\n};\n\nTYPELIB xconv_typelib=\n{\n  array_elements(xconv_names) - 1, \"xconv_typelib\",\n  xconv_names, NULL\n};\n\nstatic MYSQL_THDVAR_ENUM(\n  type_conv,                       // name\n  PLUGIN_VAR_RQCMDARG,             // opt\n  \"Unsupported types conversion.\", // comment\n  NULL,                            // check\n  NULL,                            // update function\n  1,                               // def (yes)\n  &xconv_typelib);                 // typelib\n\n// Null representation for JSON values\nstatic MYSQL_THDVAR_STR(json_null,\n\tPLUGIN_VAR_RQCMDARG | PLUGIN_VAR_MEMALLOC,\n\t\"Representation of Json null values\",\n\t//     check_json_null, update_json_null,\n\tNULL, NULL, \"<null>\");\n\n// Estimate max number of rows for JSON aggregate functions\nstatic MYSQL_THDVAR_UINT(json_grp_size,\n       PLUGIN_VAR_RQCMDARG,             // opt\n       \"max number of rows for JSON aggregate functions.\",\n       NULL, NULL, JSONMAX, 1, INT_MAX, 1);\n\n#if defined(JAVA_SUPPORT)\n// Default java wrapper to use with JDBC tables\nstatic MYSQL_THDVAR_STR(java_wrapper,\n\tPLUGIN_VAR_RQCMDARG | PLUGIN_VAR_MEMALLOC,\n\t\"Java wrapper class name\",\n\t//     check_java_wrapper, update_java_wrapper,\n\tNULL, NULL, \"wrappers/JdbcInterface\");\n#endif   // JAVA_SUPPORT\n\n// This is apparently not acceptable for a plugin so it is undocumented\n#if defined(JAVA_SUPPORT) || defined(CMGO_SUPPORT)\n// Enabling MONGO table type\n#if defined(MONGO_SUPPORT) || (MYSQL_VERSION_ID > 100200)\nstatic MYSQL_THDVAR_BOOL(enable_mongo, PLUGIN_VAR_RQCMDARG,\n\t\"Enabling the MongoDB access\", NULL, NULL, 1);\n#else   // !version 2,3\nstatic MYSQL_THDVAR_BOOL(enable_mongo, PLUGIN_VAR_RQCMDARG,\n\t\"Enabling the MongoDB access\", NULL, NULL, 0);\n#endif  // !version 2,3\n#endif   // JAVA_SUPPORT || CMGO_SUPPORT   \n\n#if defined(XMSG) || defined(NEWMSG)\nconst char *language_names[]=\n{\n  \"default\", \"english\", \"french\", NullS\n};\n\nTYPELIB language_typelib=\n{\n  array_elements(language_names) - 1, \"language_typelib\",\n  language_names, NULL\n};\n\nstatic MYSQL_THDVAR_ENUM(\n  msg_lang,                        // name\n  PLUGIN_VAR_RQCMDARG,             // opt\n  \"Message language\",              // comment\n  NULL,                            // check\n  NULL,                            // update\n  1,                               // def (ENGLISH)      \n  &language_typelib);              // typelib\n#endif   // XMSG || NEWMSG\n\n/***********************************************************************/\n/*  The CONNECT handlerton object.                                     */\n/***********************************************************************/\nhandlerton *connect_hton= NULL;\n\n/***********************************************************************/\n/*  Function to export session variable values to other source files.  */\n/***********************************************************************/\nuint GetTraceValue(void)\n\t{return (uint)(connect_hton ? THDVAR(current_thd, xtrace) : 0);}\nbool ExactInfo(void) {return THDVAR(current_thd, exact_info);}\nstatic bool CondPushEnabled(void) {return THDVAR(current_thd, cond_push);}\nUSETEMP UseTemp(void) {return (USETEMP)THDVAR(current_thd, use_tempfile);}\nint GetConvSize(void) {return THDVAR(current_thd, conv_size);}\nTYPCONV GetTypeConv(void) {return (TYPCONV)THDVAR(current_thd, type_conv);}\nchar *GetJsonNull(void)\n\t{return connect_hton ? THDVAR(current_thd, json_null) : NULL;}\nuint GetJsonGrpSize(void)\n  {return connect_hton ? THDVAR(current_thd, json_grp_size) : 10;}\nuint GetWorkSize(void) {return THDVAR(current_thd, work_size);}\nvoid SetWorkSize(uint) \n{\n  // Changing the session variable value seems to be impossible here\n  // and should be done in a check function \n  push_warning(current_thd, Sql_condition::WARN_LEVEL_WARN, 0, \n    \"Work size too big, try setting a smaller value\");\n} // end of SetWorkSize\n\n#if defined(JAVA_SUPPORT)\nchar *GetJavaWrapper(void)\n{return connect_hton ? THDVAR(current_thd, java_wrapper) : (char*)\"wrappers/JdbcInterface\";}\n#endif   // JAVA_SUPPORT\n\n#if defined(JAVA_SUPPORT) || defined(CMGO_SUPPORT)\nbool MongoEnabled(void) {return THDVAR(current_thd, enable_mongo);}\n#endif   // JAVA_SUPPORT || CMGO_SUPPORT\n\n#if defined(XMSG) || defined(NEWMSG)\nextern \"C\" const char *msglang(void)\n\t{return language_names[THDVAR(current_thd, msg_lang)];}\n#else   // !XMSG && !NEWMSG\nextern \"C\" const char *msglang(void)\n{\n#if defined(FRENCH)\n  return \"french\";\n#else  // DEFAULT\n  return \"english\";\n#endif // DEFAULT\n} // end of msglang\n#endif  // !XMSG && !NEWMSG\n\n#if 0\n/***********************************************************************/\n/*  Global variables update functions.                                 */\n/***********************************************************************/\nstatic void update_connect_zconv(MYSQL_THD thd,\n                                  struct st_mysql_sys_var *var,\n                                  void *var_ptr, const void *save)\n{\n  zconv= *(int *)var_ptr= *(int *)save;\n} // end of update_connect_zconv\n\nstatic void update_connect_xconv(MYSQL_THD thd,\n                                 struct st_mysql_sys_var *var,\n                                 void *var_ptr, const void *save)\n{\n  xconv= (int)(*(ulong *)var_ptr= *(ulong *)save);\n} // end of update_connect_xconv\n\n#if defined(XMAP)\nstatic void update_connect_xmap(MYSQL_THD thd,\n                                struct st_mysql_sys_var *var,\n                                void *var_ptr, const void *save)\n{\n  xmap= (my_bool)(*(my_bool *)var_ptr= *(my_bool *)save);\n} // end of update_connect_xmap\n#endif   // XMAP\n#endif // 0\n\n#if 0 // (was XMSG) Unuseful because not called for default value\nstatic void update_msg_path(MYSQL_THD thd,\n                            struct st_mysql_sys_var *var,\n                            void *var_ptr, const void *save)\n{\n  char *value= *(char**)save;\n  char *old= *(char**)var_ptr;\n\n  if (value)\n    *(char**)var_ptr= my_strdup(value, MYF(0));\n  else\n    *(char**)var_ptr= 0;\n\n  my_free(old);\n} // end of update_msg_path\n\nstatic int check_msg_path (MYSQL_THD thd, struct st_mysql_sys_var *var,\n\t                         void *save, struct st_mysql_value *value)\n{\n\tconst char *path;\n\tchar\tbuff[512];\n\tint\t\tlen= sizeof(buff);\n\n\tpath= value->val_str(value, buff, &len);\n\n\tif (path && *path != '*') {\n\t\t/* Save a pointer to the name in the\n\t\t'file_format_name_map' constant array. */\n\t\t*(char**)save= my_strdup(path, MYF(0));\n\t\treturn(0);\n\t} else {\n\t\tpush_warning_printf(thd,\n\t\t  Sql_condition::WARN_LEVEL_WARN,\n\t\t  ER_WRONG_ARGUMENTS,\n\t\t  \"CONNECT: invalid message path\");\n\t} // endif path\n\n\t*(char**)save= NULL;\n\treturn(1);\n} // end of check_msg_path\n#endif   // 0\n\n/**\n  CREATE TABLE option list (table options)\n\n  These can be specified in the CREATE TABLE:\n  CREATE TABLE ( ... ) {...here...}\n*/\nha_create_table_option connect_table_option_list[]=\n{\n  HA_TOPTION_STRING(\"TABLE_TYPE\", type),\n  HA_TOPTION_STRING(\"FILE_NAME\", filename),\n  HA_TOPTION_STRING(\"XFILE_NAME\", optname),\n//HA_TOPTION_STRING(\"CONNECT_STRING\", connect),\n  HA_TOPTION_STRING(\"TABNAME\", tabname),\n  HA_TOPTION_STRING(\"TABLE_LIST\", tablist),\n  HA_TOPTION_STRING(\"DBNAME\", dbname),\n  HA_TOPTION_STRING(\"SEP_CHAR\", separator),\n  HA_TOPTION_STRING(\"QCHAR\", qchar),\n  HA_TOPTION_STRING(\"MODULE\", module),\n  HA_TOPTION_STRING(\"SUBTYPE\", subtype),\n  HA_TOPTION_STRING(\"CATFUNC\", catfunc),\n  HA_TOPTION_STRING(\"SRCDEF\", srcdef),\n  HA_TOPTION_STRING(\"COLIST\", colist),\n\tHA_TOPTION_STRING(\"FILTER\", filter),\n\tHA_TOPTION_STRING(\"OPTION_LIST\", oplist),\n  HA_TOPTION_STRING(\"DATA_CHARSET\", data_charset),\n\tHA_TOPTION_STRING(\"HTTP\", http),\n\tHA_TOPTION_STRING(\"URI\", uri),\n\tHA_TOPTION_NUMBER(\"LRECL\", lrecl, 0, 0, INT_MAX32, 1),\n  HA_TOPTION_NUMBER(\"BLOCK_SIZE\", elements, 0, 0, INT_MAX32, 1),\n//HA_TOPTION_NUMBER(\"ESTIMATE\", estimate, 0, 0, INT_MAX32, 1),\n  HA_TOPTION_NUMBER(\"MULTIPLE\", multiple, 0, 0, 3, 1),\n  HA_TOPTION_NUMBER(\"HEADER\", header, 0, 0, 3, 1),\n  HA_TOPTION_NUMBER(\"QUOTED\", quoted, (ulonglong) -1, 0, 3, 1),\n  HA_TOPTION_NUMBER(\"ENDING\", ending, (ulonglong) -1, 0, INT_MAX32, 1),\n  HA_TOPTION_NUMBER(\"COMPRESS\", compressed, 0, 0, 2, 1),\n  HA_TOPTION_BOOL(\"MAPPED\", mapped, 0),\n  HA_TOPTION_BOOL(\"HUGE\", huge, 0),\n  HA_TOPTION_BOOL(\"SPLIT\", split, 0),\n  HA_TOPTION_BOOL(\"READONLY\", readonly, 0),\n  HA_TOPTION_BOOL(\"SEPINDEX\", sepindex, 0),\n\tHA_TOPTION_BOOL(\"ZIPPED\", zipped, 0),\n\tHA_TOPTION_END\n};\n\n\n/**\n  CREATE TABLE option list (field options)\n\n  These can be specified in the CREATE TABLE per field:\n  CREATE TABLE ( field ... {...here...}, ... )\n*/\nha_create_table_option connect_field_option_list[]=\n{\n  HA_FOPTION_NUMBER(\"FLAG\", offset, (ulonglong) -1, 0, INT_MAX32, 1),\n  HA_FOPTION_NUMBER(\"MAX_DIST\", freq, 0, 0, INT_MAX32, 1), // BLK_INDX\n  HA_FOPTION_NUMBER(\"FIELD_LENGTH\", fldlen, 0, 0, INT_MAX32, 1),\n  HA_FOPTION_STRING(\"DATE_FORMAT\", dateformat),\n  HA_FOPTION_STRING(\"FIELD_FORMAT\", fieldformat),\n  HA_FOPTION_STRING(\"SPECIAL\", special),\n  HA_FOPTION_ENUM(\"DISTRIB\", opt, \"scattered,clustered,sorted\", 0),\n  HA_FOPTION_END\n};\n\n/*\n  CREATE TABLE option list (index options)\n\n  These can be specified in the CREATE TABLE per index:\n  CREATE TABLE ( field ..., .., INDEX .... *here*, ... )\n*/\nha_create_table_option connect_index_option_list[]=\n{\n  HA_IOPTION_BOOL(\"DYNAM\", dynamic, 0),\n  HA_IOPTION_BOOL(\"MAPPED\", mapped, 0),\n  HA_IOPTION_END\n};\n\n/***********************************************************************/\n/*  Push G->Message as a MySQL warning.                                */\n/***********************************************************************/\nbool PushWarning(PGLOBAL g, PTDB tdbp, int level)\n{\n  PHC    phc;\n  THD   *thd;\n  MYCAT *cat= (MYCAT*)tdbp->GetDef()->GetCat();\n\n  if (!cat || !(phc= cat->GetHandler()) || !phc->GetTable() ||\n      !(thd= (phc->GetTable())->in_use))\n    return true;\n\n  PushWarning(g, thd, level);\n  return false;\n} // end of PushWarning\n\nvoid PushWarning(PGLOBAL g, THD *thd, int level)\n  {\n  if (thd) {\n    Sql_condition::enum_warning_level wlvl;\n\n    wlvl= (Sql_condition::enum_warning_level)level;\n    push_warning(thd, wlvl, 0, g->Message);\n  } else\n    htrc(\"%s\\n\", g->Message);\n\n  } // end of PushWarning\n\n#ifdef HAVE_PSI_INTERFACE\nstatic PSI_mutex_key con_key_mutex_CONNECT_SHARE_mutex;\n\nstatic PSI_mutex_info all_connect_mutexes[]=\n{\n  { &con_key_mutex_CONNECT_SHARE_mutex, \"CONNECT_SHARE::mutex\", 0}\n};\n\nstatic void init_connect_psi_keys()\n{\n  const char* category= \"connect\";\n  int count;\n\n  if (PSI_server == NULL)\n    return;\n\n  count= array_elements(all_connect_mutexes);\n  PSI_server->register_mutex(category, all_connect_mutexes, count);\n}\n#else\nstatic void init_connect_psi_keys() {}\n#endif\n\n\nDllExport LPCSTR PlugSetPath(LPSTR to, LPCSTR name, LPCSTR dir)\n{\n  const char *res= PlugSetPath(to, mysql_data_home, name, dir);\n  return res;\n}\n\n\n/**\n  @brief\n  If frm_error() is called then we will use this to determine\n  the file extensions that exist for the storage engine. This is also\n  used by the default rename_table and delete_table method in\n  handler.cc.\n\n  For engines that have two file name extensions (separate meta/index file\n  and data file), the order of elements is relevant. First element of engine\n  file name extensions array should be meta/index file extention. Second\n  element - data file extention. This order is assumed by\n  prepare_for_repair() when REPAIR TABLE ... USE_FRM is issued.\n\n  @see\n  rename_table method in handler.cc and\n  delete_table method in handler.cc\n*/\nstatic const char *ha_connect_exts[]= {\n  \".dos\", \".fix\", \".csv\", \".bin\", \".fmt\", \".dbf\", \".xml\", \".json\", \".ini\",\n  \".vec\", \".dnx\", \".fnx\", \".bnx\", \".vnx\", \".dbx\", \".dop\", \".fop\", \".bop\",\n  \".vop\", NULL};\n\n/**\n  @brief\n  Plugin initialization\n*/\nstatic int connect_init_func(void *p)\n{\n  DBUG_ENTER(\"connect_init_func\");\n\n// added from Sergei mail  \n#if 0 // (defined(LINUX))\n  Dl_info dl_info;\n  if (dladdr(&connect_hton, &dl_info))\n  {\n    if (dlopen(dl_info.dli_fname, RTLD_NOLOAD | RTLD_NOW | RTLD_GLOBAL) == 0)\n    {\n      sql_print_information(\"CONNECT: dlopen() failed, OEM table type is not supported\");\n      sql_print_information(\"CONNECT: %s\", dlerror());\n    }\n  }\n  else\n  {\n    sql_print_information(\"CONNECT: dladdr() failed, OEM table type is not supported\");\n    sql_print_information(\"CONNECT: %s\", dlerror());\n  }\n#endif   // 0 (LINUX)\n\n#if defined(__WIN__)\n  sql_print_information(\"CONNECT: %s\", compver);\n#else   // !__WIN__\n  sql_print_information(\"CONNECT: %s\", version);\n#endif  // !__WIN__\n\tpthread_mutex_init(&parmut, NULL);\n\tpthread_mutex_init(&usrmut, NULL);\n\tpthread_mutex_init(&tblmut, NULL);\n\n#if defined(LIBXML2_SUPPORT)\n  XmlInitParserLib();\n#endif   // LIBXML2_SUPPORT\n\n#if 0  //defined(CMGO_SUPPORT)\n\tmongo_init(true);\n#endif   // CMGO_SUPPORT\n\n  init_connect_psi_keys();\n\n  connect_hton= (handlerton *)p;\n  connect_hton->state= SHOW_OPTION_YES;\n  connect_hton->create= connect_create_handler;\n  connect_hton->flags= HTON_TEMPORARY_NOT_SUPPORTED;\n  connect_hton->table_options= connect_table_option_list;\n  connect_hton->field_options= connect_field_option_list;\n  connect_hton->index_options= connect_index_option_list;\n  connect_hton->tablefile_extensions= ha_connect_exts;\n  connect_hton->discover_table_structure= connect_assisted_discovery;\n\n  if (trace(128))\n    sql_print_information(\"connect_init: hton=%p\", p);\n\n  DTVAL::SetTimeShift();      // Initialize time zone shift once for all\n  BINCOL::SetEndian();        // Initialize host endian setting\n#if defined(JAVA_SUPPORT)\n\tJAVAConn::SetJVM();\n#endif   // JAVA_SUPPORT\n  DBUG_RETURN(0);\n} // end of connect_init_func\n\n\n/**\n  @brief\n  Plugin clean up\n*/\nstatic int connect_done_func(void *)\n{\n  int error= 0;\n  PCONNECT pc, pn;\n  DBUG_ENTER(\"connect_done_func\");\n\n#ifdef LIBXML2_SUPPORT\n  XmlCleanupParserLib();\n#endif // LIBXML2_SUPPORT\n\n#if defined(CMGO_SUPPORT)\n\tCMgoConn::mongo_init(false);\n#endif   // CMGO_SUPPORT\n\n#ifdef JAVA_SUPPORT\n\tJAVAConn::ResetJVM();\n#endif // JAVA_SUPPORT\n\n#if\t!defined(__WIN__)\n\tPROFILE_End();\n#endif  // !__WIN__\n\n\tpthread_mutex_lock(&usrmut);\n\tfor (pc= user_connect::to_users; pc; pc= pn) {\n    if (pc->g)\n      PlugCleanup(pc->g, true);\n\n    pn= pc->next;\n    delete pc;\n    } // endfor pc\n\n\tpthread_mutex_unlock(&usrmut);\n\n\tpthread_mutex_destroy(&usrmut);\n\tpthread_mutex_destroy(&parmut);\n\tpthread_mutex_destroy(&tblmut);\n\tconnect_hton= NULL;\n  DBUG_RETURN(error);\n} // end of connect_done_func\n\n\n/**\n  @brief\n  Example of simple lock controls. The \"share\" it creates is a\n  structure we will pass to each CONNECT handler. Do you have to have\n  one of these? Well, you have pieces that are used for locking, and\n  they are needed to function.\n*/\n\nCONNECT_SHARE *ha_connect::get_share()\n{\n  CONNECT_SHARE *tmp_share;\n\n  lock_shared_ha_data();\n\n  if (!(tmp_share= static_cast<CONNECT_SHARE*>(get_ha_share_ptr()))) {\n    tmp_share= new CONNECT_SHARE;\n    if (!tmp_share)\n      goto err;\n    mysql_mutex_init(con_key_mutex_CONNECT_SHARE_mutex,\n                     &tmp_share->mutex, MY_MUTEX_INIT_FAST);\n    set_ha_share_ptr(static_cast<Handler_share*>(tmp_share));\n    } // endif tmp_share\n\n err:\n  unlock_shared_ha_data();\n  return tmp_share;\n} // end of get_share\n\n\nstatic handler* connect_create_handler(handlerton *hton,\n                                   TABLE_SHARE *table,\n                                   MEM_ROOT *mem_root)\n{\n  handler *h= new (mem_root) ha_connect(hton, table);\n\n  if (trace(128))\n    htrc(\"New CONNECT %p, table: %.*s\\n\", h,\n          table ? table->table_name.length : 6,\n          table ? table->table_name.str : \"<null>\");\n\n  return h;\n} // end of connect_create_handler\n\n/****************************************************************************/\n/*  ha_connect constructor.                                                 */\n/****************************************************************************/\nha_connect::ha_connect(handlerton *hton, TABLE_SHARE *table_arg)\n       :handler(hton, table_arg)\n{\n  hnum= ++num;\n  xp= (table) ? GetUser(ha_thd(), NULL) : NULL;\n  if (xp)\n    xp->SetHandler(this);\n#if defined(__WIN__)\n  datapath= \".\\\\\";\n#else   // !__WIN__\n  datapath= \"./\";\n#endif  // !__WIN__\n  tdbp= NULL;\n  sdvalin1= sdvalin2= sdvalin3= sdvalin4= NULL;\n  sdvalout= NULL;\n  xmod= MODE_ANY;\n  istable= false;\n  memset(partname, 0, sizeof(partname));\n  bzero((char*) &xinfo, sizeof(XINFO));\n  valid_info= false;\n  valid_query_id= 0;\n  creat_query_id= (table && table->in_use) ? table->in_use->query_id : 0;\n  stop= false;\n  alter= false;\n  mrr= false;\n  nox= true;\n  abort= false;\n  indexing= -1;\n  locked= 0;\n  part_id= NULL;\n  data_file_name= NULL;\n  index_file_name= NULL;\n  enable_activate_all_index= 0;\n  int_table_flags= (HA_NO_TRANSACTIONS | HA_NO_PREFIX_CHAR_KEYS);\n  ref_length= sizeof(int);\n  share= NULL;\n  tshp= NULL;\n} // end of ha_connect constructor\n\n\n/****************************************************************************/\n/*  ha_connect destructor.                                                  */\n/****************************************************************************/\nha_connect::~ha_connect(void)\n{\n  if (trace(128))\n    htrc(\"Delete CONNECT %p, table: %.*s, xp=%p count=%d\\n\", this,\n                         table ? table->s->table_name.length : 6,\n                         table ? table->s->table_name.str : \"<null>\",\n                         xp, xp ? xp->count : 0);\n\n\tPopUser(xp);\n} // end of ha_connect destructor\n\n\n/****************************************************************************/\n/*  Check whether this user can be removed.                                 */\n/****************************************************************************/\nstatic void PopUser(PCONNECT xp)\n{\n\tif (xp) {\n\t\tpthread_mutex_lock(&usrmut);\n\t\txp->count--;\n\n\t\tif (!xp->count) {\n\t\t\tPCONNECT p;\n\n\t\t\tfor (p= user_connect::to_users; p; p= p->next)\n\t\t\t  if (p == xp)\n\t\t\t\t  break;\n\n\t\t  if (p) {\n\t\t\t  if (p->next)\n\t\t\t\t  p->next->previous= p->previous;\n\n\t\t\t  if (p->previous)\n\t\t\t\t  p->previous->next= p->next;\n\t\t\t  else\n\t\t\t\t  user_connect::to_users= p->next;\n\n\t\t  } // endif p\n\n\t\t\tPlugCleanup(xp->g, true);\n\t\t\tdelete xp;\n\t\t} // endif count\n\n\t\tpthread_mutex_unlock(&usrmut);\n\t} // endif xp\n\n} // end of PopUser\n\n\n/****************************************************************************/\n/*  Get a pointer to the user of this handler.                              */\n/****************************************************************************/\nstatic PCONNECT GetUser(THD *thd, PCONNECT xp)\n{\n\tif (!thd)\n    return NULL;\n\n\tif (xp) {\n\t\tif (thd == xp->thdp)\n\t\t\treturn xp;\n\n\t\tPopUser(xp);\t\t// Avoid memory leak\n\t} // endif xp\n\n\tpthread_mutex_lock(&usrmut);\n\n\tfor (xp= user_connect::to_users; xp; xp= xp->next)\n    if (thd == xp->thdp)\n      break;\n\n\tif (xp)\n\t\txp->count++;\n\n\tpthread_mutex_unlock(&usrmut);\n\n\tif (!xp) {\n\t\txp= new user_connect(thd);\n\n\t\tif (xp->user_init()) {\n\t\t\tdelete xp;\n\t\t\txp= NULL;\n\t\t} // endif user_init\n\n\t}\t// endif xp\n\n  //} else\n  //  xp->count++;\n\n  return xp;\n} // end of GetUser\n\n/****************************************************************************/\n/*  Get the global pointer of the user of this handler.                     */\n/****************************************************************************/\nstatic PGLOBAL GetPlug(THD *thd, PCONNECT& lxp)\n{\n  lxp= GetUser(thd, lxp);\n  return (lxp) ? lxp->g : NULL;\n} // end of GetPlug\n\n/****************************************************************************/\n/*  Get the implied table type.                                             */\n/****************************************************************************/\nTABTYPE ha_connect::GetRealType(PTOS pos)\n{\n  TABTYPE type;\n  \n  if (pos || (pos= GetTableOptionStruct())) {\n    type= GetTypeID(pos->type);\n\n    if (type == TAB_UNDEF)\n      type= pos->srcdef ? TAB_MYSQL : pos->tabname ? TAB_PRX : TAB_DOS;\n#if defined(REST_SUPPORT)\n\t\telse if (pos->http)\n\t\t\tswitch (type) {\n\t\t\t\tcase TAB_JSON:\n\t\t\t\tcase TAB_XML:\n\t\t\t\tcase TAB_CSV:\n\t\t\t\t\ttype = TAB_REST;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TAB_REST:\n\t\t\t\t\ttype = TAB_NIY;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\t// endswitch type\n#endif   // REST_SUPPORT\n\n  } else\n    type= TAB_UNDEF;\n\n  return type;\n} // end of GetRealType\n\n/** @brief\n  The name of the index type that will be used for display.\n  Don't implement this method unless you really have indexes.\n */\nconst char *ha_connect::index_type(uint inx) \n{ \n  switch (GetIndexType(GetRealType())) {\n    case 1:\n      if (table_share)\n        return (GetIndexOption(&table_share->key_info[inx], \"Dynamic\"))\n             ? \"KINDEX\" : \"XINDEX\";\n      else\n        return \"XINDEX\";\n\n    case 2: return \"REMOTE\";\n    case 3: return \"VIRTUAL\";\n    } // endswitch\n\n  return \"Unknown\";\n} // end of index_type\n\n/** @brief\n  This is a bitmap of flags that indicates how the storage engine\n  implements indexes. The current index flags are documented in\n  handler.h. If you do not implement indexes, just return zero here.\n\n    @details\n  part is the key part to check. First key part is 0.\n  If all_parts is set, MySQL wants to know the flags for the combined\n  index, up to and including 'part'.\n*/\n//ong ha_connect::index_flags(uint inx, uint part, bool all_parts) const\nulong ha_connect::index_flags(uint, uint, bool) const\n{\n  ulong       flags= HA_READ_NEXT | HA_READ_RANGE |\n                     HA_KEYREAD_ONLY | HA_KEY_SCAN_NOT_ROR;\n  ha_connect *hp= (ha_connect*)this;\n  PTOS        pos= hp->GetTableOptionStruct();\n\n  if (pos) {\n    TABTYPE type= hp->GetRealType(pos);\n\n    switch (GetIndexType(type)) {\n      case 1: flags|= (HA_READ_ORDER | HA_READ_PREV); break;\n      case 2: flags|= HA_READ_AFTER_KEY;              break;\n      } // endswitch\n\n    } // endif pos\n\n  return flags;\n} // end of index_flags\n\n/** @brief\n  This is a list of flags that indicate what functionality the storage\n  engine implements. The current table flags are documented in handler.h\n*/\nulonglong ha_connect::table_flags() const\n{\n  ulonglong   flags= HA_CAN_VIRTUAL_COLUMNS | HA_REC_NOT_IN_SEQ |\n                     HA_NO_AUTO_INCREMENT | HA_NO_PREFIX_CHAR_KEYS |\n                     HA_BINLOG_ROW_CAPABLE | HA_BINLOG_STMT_CAPABLE |\n                     HA_PARTIAL_COLUMN_READ | HA_FILE_BASED |\n//                   HA_NULL_IN_KEY |    not implemented yet\n//                   HA_FAST_KEY_READ |  causes error when sorting (???)\n                     HA_NO_TRANSACTIONS | HA_DUPLICATE_KEY_NOT_IN_ORDER |\n                     HA_NO_BLOBS | HA_MUST_USE_TABLE_CONDITION_PUSHDOWN;\n  ha_connect *hp= (ha_connect*)this;\n  PTOS        pos= hp->GetTableOptionStruct();\n\n  if (pos) {\n    TABTYPE type= hp->GetRealType(pos);\n\n    if (IsFileType(type))\n      flags|= HA_FILE_BASED;\n\n    if (IsExactType(type))\n      flags|= (HA_HAS_RECORDS | HA_STATS_RECORDS_IS_EXACT);\n\n    // No data change on ALTER for outward tables\n    if (!IsFileType(type) || hp->FileExists(pos->filename, true))\n      flags|= HA_NO_COPY_ON_ALTER;\n\n    } // endif pos\n\n  return flags;\n} // end of table_flags\n\n/****************************************************************************/\n/*  Return the value of an option specified in an option list.              */\n/****************************************************************************/\nPCSZ GetListOption(PGLOBAL g, PCSZ opname, PCSZ oplist, PCSZ def)\n{\n  if (!oplist)\n    return (char*)def;\n\n\tchar  key[16], val[256];\n\tchar *pv, *pn, *pk= (char*)oplist;\n\tPCSZ  opval= def;\n\tint   n;\n\n\twhile (*pk == ' ')\n\t\tpk++;\n\n\tfor (; pk; pk= pn) {\n\t\tpn= strchr(pk, ',');\n\t\tpv= strchr(pk, '=');\n\n\t\tif (pv && (!pn || pv < pn)) {\n\t\t\tn= MY_MIN(static_cast<size_t>(pv - pk), sizeof(key) - 1);\n\t\t\tmemcpy(key, pk, n);\n\n\t\t\twhile (n && key[n - 1] == ' ')\n\t\t\t\tn--;\n\n\t\t\tkey[n]= 0;\n\n\t\t\twhile (*(++pv) == ' ');\n\n\t\t\tn= MY_MIN((pn ? pn - pv : strlen(pv)), sizeof(val) - 1);\n\t\t\tmemcpy(val, pv, n);\n\n\t\t\twhile (n && val[n - 1] == ' ')\n\t\t\t\tn--;\n\n\t\t\tval[n]= 0;\n\t\t} else {\n\t\t\tn= MY_MIN((pn ? pn - pk : strlen(pk)), sizeof(key) - 1);\n\t\t\tmemcpy(key, pk, n);\n\n\t\t\twhile (n && key[n - 1] == ' ')\n\t\t\t\tn--;\n\n\t\t\tkey[n]= 0;\n\t\t\tval[0]= 0;\n\t\t} // endif pv\n\n\t\tif (!stricmp(opname, key)) {\n\t\t\topval= PlugDup(g, val);\n\t\t\tbreak;\n\t\t} else if (!pn)\n\t\t\tbreak;\n\n\t\twhile (*(++pn) == ' ');\n\t} // endfor pk\n\n  return opval;\n} // end of GetListOption\n\n/****************************************************************************/\n/*  Return the value of a string option or NULL if not specified.           */\n/****************************************************************************/\nPCSZ GetStringTableOption(PGLOBAL g, PTOS options, PCSZ opname, PCSZ sdef)\n{\n\tPCSZ opval= NULL;\n\n  if (!options)\n    return sdef;\n  else if (!stricmp(opname, \"Type\"))\n    opval= options->type;\n  else if (!stricmp(opname, \"Filename\"))\n    opval= options->filename;\n  else if (!stricmp(opname, \"Optname\"))\n    opval= options->optname;\n  else if (!stricmp(opname, \"Tabname\"))\n    opval= options->tabname;\n  else if (!stricmp(opname, \"Tablist\"))\n    opval= options->tablist;\n  else if (!stricmp(opname, \"Database\") ||\n           !stricmp(opname, \"DBname\"))\n    opval= options->dbname;\n  else if (!stricmp(opname, \"Separator\"))\n    opval= options->separator;\n  else if (!stricmp(opname, \"Qchar\"))\n    opval= options->qchar;\n  else if (!stricmp(opname, \"Module\"))\n    opval= options->module;\n  else if (!stricmp(opname, \"Subtype\"))\n    opval= options->subtype;\n  else if (!stricmp(opname, \"Catfunc\"))\n    opval= options->catfunc;\n  else if (!stricmp(opname, \"Srcdef\"))\n    opval= options->srcdef;\n  else if (!stricmp(opname, \"Colist\"))\n    opval= options->colist;\n\telse if (!stricmp(opname, \"Filter\"))\n\t\topval= options->filter;\n\telse if (!stricmp(opname, \"Data_charset\"))\n    opval= options->data_charset;\n\telse if (!stricmp(opname, \"Http\") || !stricmp(opname, \"URL\"))\n\t\topval = options->http;\n\telse if (!stricmp(opname, \"Uri\"))\n\t\topval = options->uri;\n\n  if (!opval && options->oplist)\n    opval= GetListOption(g, opname, options->oplist);\n\n  return opval ? (char*)opval : sdef;\n} // end of GetStringTableOption\n\n/****************************************************************************/\n/*  Return the value of a Boolean option or bdef if not specified.          */\n/****************************************************************************/\nbool GetBooleanTableOption(PGLOBAL g, PTOS options, PCSZ opname, bool bdef)\n{\n  bool opval= bdef;\n\tPCSZ pv;\n\n  if (!options)\n    return bdef;\n  else if (!stricmp(opname, \"Mapped\"))\n    opval= options->mapped;\n  else if (!stricmp(opname, \"Huge\"))\n    opval= options->huge;\n  else if (!stricmp(opname, \"Split\"))\n    opval= options->split;\n  else if (!stricmp(opname, \"Readonly\"))\n    opval= options->readonly;\n  else if (!stricmp(opname, \"SepIndex\"))\n    opval= options->sepindex;\n  else if (!stricmp(opname, \"Header\"))\n    opval= (options->header != 0);   // Is Boolean for some table types\n\telse if (!stricmp(opname, \"Zipped\"))\n\t\topval= options->zipped;\n\telse if (options->oplist)\n    if ((pv= GetListOption(g, opname, options->oplist)))\n      opval= (!*pv || *pv == 'y' || *pv == 'Y' || atoi(pv) != 0);\n\n  return opval;\n} // end of GetBooleanTableOption\n\n/****************************************************************************/\n/*  Return the value of an integer option or NO_IVAL if not specified.      */\n/****************************************************************************/\nint GetIntegerTableOption(PGLOBAL g, PTOS options, PCSZ opname, int idef)\n{\n  ulonglong opval= (ulonglong) NO_IVAL;\n\n  if (!options)\n    return idef;\n  else if (!stricmp(opname, \"Lrecl\"))\n    opval= options->lrecl;\n  else if (!stricmp(opname, \"Elements\"))\n    opval= options->elements;\n  else if (!stricmp(opname, \"Multiple\"))\n    opval= options->multiple;\n  else if (!stricmp(opname, \"Header\"))\n    opval= options->header;\n  else if (!stricmp(opname, \"Quoted\"))\n    opval= options->quoted;\n  else if (!stricmp(opname, \"Ending\"))\n    opval= options->ending;\n  else if (!stricmp(opname, \"Compressed\"))\n    opval= (options->compressed);\n\n  if ((ulonglong) opval == (ulonglong)NO_IVAL) {\n\t\tPCSZ pv;\n\n    if ((pv= GetListOption(g, opname, options->oplist)))\n      opval= CharToNumber((char*)pv, strlen(pv), ULONGLONG_MAX, true);\n    else\n      return idef;\n\n    } // endif opval\n\n  return (int)opval;\n} // end of GetIntegerTableOption\n\n/****************************************************************************/\n/*  Return the table option structure.                                      */\n/****************************************************************************/\nPTOS ha_connect::GetTableOptionStruct(TABLE_SHARE *s)\n{\n  TABLE_SHARE *tsp= (tshp) ? tshp : (s) ? s : table_share;\n\n\treturn (tsp && (!tsp->db_plugin || \n\t\t              !stricmp(plugin_name(tsp->db_plugin)->str, \"connect\") ||\n\t\t\t\t\t\t\t\t\t!stricmp(plugin_name(tsp->db_plugin)->str, \"partition\")))\n\t\t\t\t\t\t\t\t\t? tsp->option_struct : NULL;\n} // end of GetTableOptionStruct\n\n/****************************************************************************/\n/*  Return the string eventually formatted with partition name.             */\n/****************************************************************************/\nchar *ha_connect::GetRealString(PCSZ s)\n{\n  char *sv;\n\n  if (IsPartitioned() && s && *partname) {\n    sv= (char*)PlugSubAlloc(xp->g, NULL, 0);\n    sprintf(sv, s, partname);\n    PlugSubAlloc(xp->g, NULL, strlen(sv) + 1);\n  } else\n    sv= (char*)s;\n\n  return sv;\n} // end of GetRealString\n\n/****************************************************************************/\n/*  Return the value of a string option or sdef if not specified.           */\n/****************************************************************************/\nPCSZ ha_connect::GetStringOption(PCSZ opname, PCSZ sdef)\n{\n\tPCSZ opval= NULL;\n  PTOS options= GetTableOptionStruct();\n\n  if (!stricmp(opname, \"Connect\")) {\n    LEX_CSTRING cnc= (tshp) ? tshp->connect_string \n                           : table->s->connect_string;\n\n    if (cnc.length)\n      opval= strz(xp->g, cnc);\n\t\telse\n\t\t\topval= GetListOption(xp->g, opname, options->oplist);\n\n\t} else if (!stricmp(opname, \"Query_String\")) {\n//  This escapes everything and returns a wrong query \n//\topval= thd_query_string(table->in_use)->str;\n\t\topval= (PCSZ)PlugSubAlloc(xp->g, NULL, \n\t\t\tthd_query_string(table->in_use)->length + 1);\n\t\tstrcpy((char*)opval, thd_query_string(table->in_use)->str);\n//\tsprintf((char*)opval, \"%s\", thd_query_string(table->in_use)->str);\n\t} else if (!stricmp(opname, \"Partname\"))\n    opval= partname;\n  else if (!stricmp(opname, \"Table_charset\")) {\n    const CHARSET_INFO *chif= (tshp) ? tshp->table_charset \n                                     : table->s->table_charset;\n\n    if (chif)\n      opval= (char*)chif->csname;\n\n  } else\n    opval= GetStringTableOption(xp->g, options, opname, NULL);\n\n  if (opval && (!stricmp(opname, \"connect\") \n             || !stricmp(opname, \"tabname\") \n             || !stricmp(opname, \"filename\")\n\t\t\t\t\t\t || !stricmp(opname, \"optname\")\n\t\t\t\t\t\t || !stricmp(opname, \"entry\")))\n\t\t\t\t\t\t opval= GetRealString(opval);\n\n  if (!opval) {\n    if (sdef && !strcmp(sdef, \"*\")) {\n      // Return the handler default value\n      if (!stricmp(opname, \"Dbname\") || !stricmp(opname, \"Database\"))\n        opval= (char*)GetDBName(NULL);    // Current database\n      else if (!stricmp(opname, \"Type\"))  // Default type\n        opval= (!options) ? NULL :\n               (options->srcdef)  ? (char*)\"MYSQL\" :\n               (options->tabname) ? (char*)\"PROXY\" : (char*)\"DOS\";\n      else if (!stricmp(opname, \"User\"))  // Connected user\n        opval= (char *) \"root\";\n      else if (!stricmp(opname, \"Host\"))  // Connected user host\n        opval= (char *) \"localhost\";\n      else\n        opval= sdef;                      // Caller default\n\n    } else\n      opval= sdef;                        // Caller default\n\n    } // endif !opval\n\n  return opval;\n} // end of GetStringOption\n\n/****************************************************************************/\n/*  Return the value of a Boolean option or bdef if not specified.          */\n/****************************************************************************/\nbool ha_connect::GetBooleanOption(PCSZ opname, bool bdef)\n{\n  bool  opval;\n  PTOS  options= GetTableOptionStruct();\n\n  if (!stricmp(opname, \"View\"))\n    opval= (tshp) ? tshp->is_view : table_share->is_view;\n  else\n    opval= GetBooleanTableOption(xp->g, options, opname, bdef);\n\n  return opval;\n} // end of GetBooleanOption\n\n/****************************************************************************/\n/*  Set the value of the opname option (does not work for oplist options)   */\n/*  Currently used only to set the Sepindex value.                          */\n/****************************************************************************/\nbool ha_connect::SetBooleanOption(PCSZ opname, bool b)\n{\n  PTOS options= GetTableOptionStruct();\n\n  if (!options)\n    return true;\n\n  if (!stricmp(opname, \"SepIndex\"))\n    options->sepindex= b;\n  else\n    return true;\n\n  return false;\n} // end of SetBooleanOption\n\n/****************************************************************************/\n/*  Return the value of an integer option or NO_IVAL if not specified.      */\n/****************************************************************************/\nint ha_connect::GetIntegerOption(PCSZ opname)\n{\n  int          opval;\n  PTOS         options= GetTableOptionStruct();\n  TABLE_SHARE *tsp= (tshp) ? tshp : table_share;\n\n  if (!stricmp(opname, \"Avglen\"))\n    opval= (int)tsp->avg_row_length;\n  else if (!stricmp(opname, \"Estimate\"))\n    opval= (int)tsp->max_rows;\n  else\n    opval= GetIntegerTableOption(xp->g, options, opname, NO_IVAL);\n\n  return opval;\n} // end of GetIntegerOption\n\n/****************************************************************************/\n/*  Set the value of the opname option (does not work for oplist options)   */\n/*  Currently used only to set the Lrecl value.                             */\n/****************************************************************************/\nbool ha_connect::SetIntegerOption(PCSZ opname, int n)\n{\n  PTOS options= GetTableOptionStruct();\n\n  if (!options)\n    return true;\n\n  if (!stricmp(opname, \"Lrecl\"))\n    options->lrecl= n;\n  else if (!stricmp(opname, \"Elements\"))\n    options->elements= n;\n//else if (!stricmp(opname, \"Estimate\"))\n//  options->estimate= n;\n  else if (!stricmp(opname, \"Multiple\"))\n    options->multiple= n;\n  else if (!stricmp(opname, \"Header\"))\n    options->header= n;\n  else if (!stricmp(opname, \"Quoted\"))\n    options->quoted= n;\n  else if (!stricmp(opname, \"Ending\"))\n    options->ending= n;\n  else if (!stricmp(opname, \"Compressed\"))\n    options->compressed= n;\n  else\n    return true;\n//else if (options->oplist)\n//  SetListOption(opname, options->oplist, n);\n\n  return false;\n} // end of SetIntegerOption\n\n/****************************************************************************/\n/*  Return a field option structure.                                        */\n/****************************************************************************/\nPFOS ha_connect::GetFieldOptionStruct(Field *fdp)\n{\n  return fdp->option_struct;\n} // end of GetFildOptionStruct\n\n/****************************************************************************/\n/*  Returns the column description structure used to make the column.       */\n/****************************************************************************/\nvoid *ha_connect::GetColumnOption(PGLOBAL g, void *field, PCOLINFO pcf)\n{\n  const char *cp;\n  char   *chset, v= 0;\n  ha_field_option_struct *fop;\n  Field*  fp;\n  Field* *fldp;\n\n  // Double test to be on the safe side\n  if (!table)\n    return NULL;\n\n  // Find the column to describe\n  if (field) {\n    fldp= (Field**)field;\n    fldp++;\n  } else\n    fldp= (tshp) ? tshp->field : table->field;\n\n  if (!fldp || !(fp= *fldp))\n    return NULL;\n\n  // Get the CONNECT field options structure\n  fop= GetFieldOptionStruct(fp);\n  pcf->Flags= 0;\n\n  // Now get column information\n  pcf->Name= (char*)fp->field_name.str;\n\n  if (fop && fop->special) {\n    pcf->Fieldfmt= (char*)fop->special;\n    pcf->Flags= U_SPECIAL;\n    return fldp;\n    } // endif special\n\n  pcf->Scale= 0;\n  pcf->Opt= (fop) ? (int)fop->opt : 0;\n\n  if ((pcf->Length= fp->field_length) < 0)\n    pcf->Length= 256;            // BLOB?\n\n  pcf->Precision= pcf->Length;\n\n  if (fop) {\n    pcf->Offset= (int)fop->offset;\n    pcf->Freq= (int)fop->freq;\n    pcf->Datefmt= (char*)fop->dateformat;\n    pcf->Fieldfmt= (char*)fop->fieldformat;\n  } else {\n    pcf->Offset= -1;\n    pcf->Freq= 0;\n    pcf->Datefmt= NULL;\n    pcf->Fieldfmt= NULL;\n  } // endif fop\n\n  chset= (char *)fp->charset()->name;\n\n  switch (fp->type()) {\n    case MYSQL_TYPE_BLOB:\n    case MYSQL_TYPE_VARCHAR:\n    case MYSQL_TYPE_VAR_STRING:\n      pcf->Flags |= U_VAR;\n\t\t\t// fall through\n    default:\n      pcf->Type= MYSQLtoPLG(fp->type(), &v);\n      break;\n    } // endswitch SQL type\n\n  switch (pcf->Type) {\n    case TYPE_STRING:\n\t\tcase TYPE_BIN:\n\t\t\t// Do something for case\n      cp= chset;\n\n      // Find if collation name ends by _ci\n      if (!strcmp(cp + strlen(cp) - 3, \"_ci\")) {\n        pcf->Scale= 1;     // Case insensitive\n        pcf->Opt= 0;       // Prevent index opt until it is safe\n        } // endif ci\n\n      break;\n    case TYPE_DOUBLE:\n      pcf->Scale= MY_MAX(MY_MIN(fp->decimals(), ((unsigned)pcf->Length - 2)), 0);\n      break;\n    case TYPE_DECIM:\n      pcf->Precision= ((Field_new_decimal*)fp)->precision;\n      pcf->Length= pcf->Precision;\n      pcf->Scale= fp->decimals();\n      break;\n    case TYPE_DATE:\n      // Field_length is only used for DATE columns\n      if (fop && fop->fldlen)\n        pcf->Length= (int)fop->fldlen;\n      else {\n        int len;\n\n        if (pcf->Datefmt) {\n          // Find the (max) length produced by the date format\n          char    buf[256];\n          PGLOBAL g= GetPlug(table->in_use, xp);\n          PDTP    pdtp= MakeDateFormat(g, pcf->Datefmt, false, true, 0);\n          struct tm datm;\n          bzero(&datm, sizeof(datm));\n          datm.tm_mday= 12;\n          datm.tm_mon= 11;\n          datm.tm_year= 112;\n          mktime(&datm); // set other fields get proper day name\n          len= strftime(buf, 256, pdtp->OutFmt, &datm);\n        } else\n          len= 0;\n\n        // 11 is for signed numeric representation of the date\n        pcf->Length= (len) ? len : 11;\n        } // endelse\n\n      // For Value setting\n      pcf->Precision= MY_MAX(pcf->Precision, pcf->Length);\n      break;\n    default:\n      break;\n    } // endswitch type\n\n  if (fp->flags & UNSIGNED_FLAG)\n    pcf->Flags |= U_UNSIGNED;\n\n  if (fp->flags & ZEROFILL_FLAG)\n    pcf->Flags |= U_ZEROFILL;\n\n  // This is used to skip null bit\n  if (fp->real_maybe_null())\n    pcf->Flags |= U_NULLS;\n\n  // Mark virtual columns as such\n  if (fp->vcol_info && !fp->stored_in_db)\n    pcf->Flags |= U_VIRTUAL;\n\n  pcf->Key= 0;   // Not used when called from MySQL\n\n  // Get the comment if any\n  if (fp->comment.str && fp->comment.length)\n    pcf->Remark= strz(g, fp->comment);\n  else\n    pcf->Remark= NULL;\n\n  return fldp;\n} // end of GetColumnOption\n\n/****************************************************************************/\n/*  Return an index option structure.                                       */\n/****************************************************************************/\nPXOS ha_connect::GetIndexOptionStruct(KEY *kp)\n{\n  return kp->option_struct;\n} // end of GetIndexOptionStruct\n\n/****************************************************************************/\n/*  Return a Boolean index option or false if not specified.                */\n/****************************************************************************/\nbool ha_connect::GetIndexOption(KEY *kp, PCSZ opname)\n{\n  bool opval= false;\n  PXOS options= GetIndexOptionStruct(kp);\n\n  if (options) {\n    if (!stricmp(opname, \"Dynamic\"))\n      opval= options->dynamic;\n    else if (!stricmp(opname, \"Mapped\"))\n      opval= options->mapped;\n\n  } else if (kp->comment.str && kp->comment.length) {\n\t\tPCSZ pv, oplist= strz(xp->g, kp->comment);\n\n    if ((pv= GetListOption(xp->g, opname, oplist)))\n      opval= (!*pv || *pv == 'y' || *pv == 'Y' || atoi(pv) != 0);\n\n  } // endif comment\n\n  return opval;\n} // end of GetIndexOption\n\n/****************************************************************************/\n/*  Returns the index description structure used to make the index.         */\n/****************************************************************************/\nbool ha_connect::IsUnique(uint n)\n{\n  return (table->key_info[n].flags & HA_NOSAME) != 0;\n} // end of IsUnique\n\n/****************************************************************************/\n/*  Returns the index description structure used to make the index.         */\n/****************************************************************************/\nPIXDEF ha_connect::GetIndexInfo(TABLE_SHARE *s)\n{\n  char    *name, *pn;\n  bool     unique;\n  PIXDEF   xdp, pxd=NULL, toidx= NULL;\n  PKPDEF   kpp, pkp;\n  KEY      kp;\n  PGLOBAL& g= xp->g;\n\n  if (!s)\n    s= table->s;\n\n  for (int n= 0; (unsigned)n < s->keynames.count; n++) {\n    if (trace(1))\n      htrc(\"Getting created index %d info\\n\", n + 1);\n\n    // Find the index to describe\n    kp= s->key_info[n];\n\n    // Now get index information\n    pn= (char*)s->keynames.type_names[n];\n    name= PlugDup(g, pn);\n    unique= (kp.flags & 1) != 0;\n    pkp= NULL;\n\n    // Allocate the index description block\n    xdp= new(g) INDEXDEF(name, unique, n);\n\n    // Get the the key parts info\n    for (int k= 0; (unsigned)k < kp.user_defined_key_parts; k++) {\n      pn= (char*)kp.key_part[k].field->field_name.str;\n      name= PlugDup(g, pn);\n\n      // Allocate the key part description block\n      kpp= new(g) KPARTDEF(name, k + 1);\n      kpp->SetKlen(kp.key_part[k].length);\n\n#if 0             // NIY\n    // Index on auto increment column can be an XXROW index\n    if (kp.key_part[k].field->flags & AUTO_INCREMENT_FLAG &&\n        kp.uder_defined_key_parts == 1) {\n      char   *type= GetStringOption(\"Type\", \"DOS\");\n      TABTYPE typ= GetTypeID(type);\n\n      xdp->SetAuto(IsTypeFixed(typ));\n      } // endif AUTO_INCREMENT\n#endif // 0\n\n      if (pkp)\n        pkp->SetNext(kpp);\n      else\n        xdp->SetToKeyParts(kpp);\n\n      pkp= kpp;\n      } // endfor k\n\n    xdp->SetNParts(kp.user_defined_key_parts);\n    xdp->Dynamic= GetIndexOption(&kp, \"Dynamic\");\n    xdp->Mapped= GetIndexOption(&kp, \"Mapped\");\n\n    if (pxd)\n      pxd->SetNext(xdp);\n    else\n      toidx= xdp;\n\n    pxd= xdp;\n    } // endfor n\n\n  return toidx;\n} // end of GetIndexInfo\n\n/****************************************************************************/\n/*  Returns the index description structure used to make the index.         */\n/****************************************************************************/\nbool ha_connect::CheckVirtualIndex(TABLE_SHARE *s)\n{\n\n  char    *rid;\n  KEY      kp;\n  Field   *fp;\n  PGLOBAL& g= xp->g;\n\n  if (!s)\n    s= table->s;\n\n  for (int n= 0; (unsigned)n < s->keynames.count; n++) {\n    kp= s->key_info[n];\n\n    // Now get index information\n\n    // Get the the key parts info\n    for (int k= 0; (unsigned)k < kp.user_defined_key_parts; k++) {\n      fp= kp.key_part[k].field;\n      rid= (fp->option_struct) ? fp->option_struct->special : NULL;\n\n      if (!rid || (stricmp(rid, \"ROWID\") && stricmp(rid, \"ROWNUM\"))) {\n        strcpy(g->Message, \"Invalid virtual index\");\n        return true;\n        } // endif rowid\n\n      } // endfor k\n\n    } // endfor n\n\n  return false;\n} // end of CheckVirtualIndex\n\nbool ha_connect::IsPartitioned(void)\n{\n#ifdef WITH_PARTITION_STORAGE_ENGINE\n\tif (tshp)\n    return tshp->partition_info_str_len > 0;\n  else if (table && table->part_info)\n    return true;\n  else\n#endif\n\t\treturn false;\n\n} // end of IsPartitioned\n\nPCSZ ha_connect::GetDBName(PCSZ name)\n{\n  return (name) ? name : table->s->db.str;\n} // end of GetDBName\n\nconst char *ha_connect::GetTableName(void)\n{\n  const char *path= tshp ? tshp->path.str : table_share->path.str;\n  const char *name= strrchr(path, slash);\n  return name ? name + 1 : path;\n} // end of GetTableName\n\nchar *ha_connect::GetPartName(void)\n{\n  return (IsPartitioned()) ? partname : (char*)GetTableName();\n} // end of GetTableName\n\n#if 0\n/****************************************************************************/\n/*  Returns the column real or special name length of a field.              */\n/****************************************************************************/\nint ha_connect::GetColNameLen(Field *fp)\n{\n  int n;\n  PFOS fop= GetFieldOptionStruct(fp);\n\n  // Now get the column name length\n  if (fop && fop->special)\n    n= strlen(fop->special) + 1;\n  else\n    n= fp->field_name.length;\n\n  return n;\n} // end of GetColNameLen\n\n/****************************************************************************/\n/*  Returns the column real or special name of a field.                     */\n/****************************************************************************/\nchar *ha_connect::GetColName(Field *fp)\n{\n  PFOS fop= GetFieldOptionStruct(fp);\n\n  return (fop && fop->special) ? fop->special : (char*)fp->field_name.str;\n} // end of GetColName\n\n/****************************************************************************/\n/*  Adds the column real or special name of a field to a string.            */\n/****************************************************************************/\nvoid ha_connect::AddColName(char *cp, Field *fp)\n{\n  PFOS fop= GetFieldOptionStruct(fp);\n\n  // Now add the column name\n  if (fop && fop->special)\n    // The prefix * mark the column as \"special\"\n    strcat(strcpy(cp, \"*\"), strupr(fop->special));\n  else\n    strcpy(cp, fp->field_name.str);\n\n} // end of AddColName\n#endif // 0\n\n/***********************************************************************/\n/*  This function sets the current database path.                      */\n/***********************************************************************/\nbool ha_connect::SetDataPath(PGLOBAL g, PCSZ path) \n{\n  return (!(datapath= SetPath(g, path)));\n} // end of SetDataPath\n\n/****************************************************************************/\n/*  Get the table description block of a CONNECT table.                     */\n/****************************************************************************/\nPTDB ha_connect::GetTDB(PGLOBAL g)\n{\n  const char *table_name;\n  PTDB        tp;\n\n  // Double test to be on the safe side\n  if (!g || !table)\n    return NULL;\n\n  table_name= GetTableName();\n\n  if (!xp->CheckQuery(valid_query_id) && tdbp\n                      && !stricmp(tdbp->GetName(), table_name)\n                      && (tdbp->GetMode() == xmod\n                       || (tdbp->GetMode() == MODE_READ && xmod == MODE_READX)\n                       || tdbp->GetAmType() == TYPE_AM_XML)) {\n    tp= tdbp;\n    tp->SetMode(xmod);\n  } else if ((tp= CntGetTDB(g, table_name, xmod, this))) {\n    valid_query_id= xp->last_query_id;\n//  tp->SetMode(xmod);\n  } else\n    htrc(\"GetTDB: %s\\n\", g->Message);\n\n  return tp;\n} // end of GetTDB\n\n/****************************************************************************/\n/*  Open a CONNECT table, restricting column list if cols is true.          */\n/****************************************************************************/\nint ha_connect::OpenTable(PGLOBAL g, bool del)\n{\n  bool  rc= false;\n  char *c1= NULL, *c2=NULL;\n\n  // Double test to be on the safe side\n  if (!g || !table) {\n    htrc(\"OpenTable logical error; g=%p table=%p\\n\", g, table);\n    return HA_ERR_INITIALIZATION;\n    } // endif g\n\n  if (!(tdbp= GetTDB(g)))\n    return RC_FX;\n  else if (tdbp->IsReadOnly())\n    switch (xmod) {\n      case MODE_WRITE:\n      case MODE_INSERT:\n      case MODE_UPDATE:\n      case MODE_DELETE:\n        strcpy(g->Message, MSG(READ_ONLY));\n        return HA_ERR_TABLE_READONLY;\n      default:\n        break;\n      } // endswitch xmode\n\n\t// g->More is 1 when executing commands from triggers\n  if (!g->More && (xmod != MODE_INSERT\n\t\t           || tdbp->GetAmType() == TYPE_AM_MYSQL\n               || tdbp->GetAmType() == TYPE_AM_ODBC\n\t\t\t\t\t\t\t || tdbp->GetAmType() == TYPE_AM_JDBC)) {\n\t\t// Get the list of used fields (columns)\n    char        *p;\n    unsigned int k1, k2, n1, n2;\n    Field*      *field;\n    Field*       fp;\n    MY_BITMAP   *map= (xmod == MODE_INSERT) ? table->write_set : table->read_set;\n    MY_BITMAP   *ump= (xmod == MODE_UPDATE) ? table->write_set : NULL;\n\n    k1= k2= 0;\n    n1= n2= 1;         // 1 is space for final null character\n\n    for (field= table->field; (fp= *field); field++) {\n      if (bitmap_is_set(map, fp->field_index)) {\n        n1+= (fp->field_name.length + 1);\n        k1++;\n        } // endif\n\n      if (ump && bitmap_is_set(ump, fp->field_index)) {\n        n2+= (fp->field_name.length + 1);\n        k2++;\n        } // endif\n\n      } // endfor field\n\n    if (k1) {\n      p= c1= (char*)PlugSubAlloc(g, NULL, n1);\n\n      for (field= table->field; (fp= *field); field++)\n        if (bitmap_is_set(map, fp->field_index)) {\n          strcpy(p, fp->field_name.str);\n          p+= (fp->field_name.length + 1);\n          } // endif used field\n\n      *p= '\\0';          // mark end of list\n      } // endif k1\n\n    if (k2) {\n      p= c2= (char*)PlugSubAlloc(g, NULL, n2);\n\n      for (field= table->field; (fp= *field); field++)\n        if (bitmap_is_set(ump, fp->field_index)) {\n          strcpy(p, fp->field_name.str);\n\n          if (part_id && bitmap_is_set(part_id, fp->field_index)) {\n            // Trying to update a column used for partitioning\n            // This cannot be currently done because it may require\n            // a row to be moved in another partition.\n            sprintf(g->Message, \n              \"Cannot update column %s because it is used for partitioning\",\n              p);\n            return HA_ERR_INTERNAL_ERROR;\n            } // endif part_id\n\n          p+= (strlen(p) + 1);\n          } // endif used field\n\n      *p= '\\0';          // mark end of list\n      } // endif k2\n\n    } // endif xmod\n\n  // Open the table\n  if (!(rc= CntOpenTable(g, tdbp, xmod, c1, c2, del, this))) {\n    istable= true;\n//  strmake(tname, table_name, sizeof(tname)-1);\n\n#ifdef NOT_USED_VARIABLE\n    // We may be in a create index query\n    if (xmod == MODE_ANY && *tdbp->GetName() != '#') {\n      // The current indexes\n      PIXDEF oldpix= GetIndexInfo();\n      } // endif xmod\n#endif\n\n  } else\n    htrc(\"OpenTable: %s\\n\", g->Message);\n\n  if (rc) {\n    tdbp= NULL;\n    valid_info= false;\n    } // endif rc\n\n  return (rc) ? HA_ERR_INITIALIZATION : 0;\n} // end of OpenTable\n\n\n/****************************************************************************/\n/*  CheckColumnList: check that all bitmap columns do exist.                */\n/****************************************************************************/\nbool ha_connect::CheckColumnList(PGLOBAL g)\n{\n  // Check the list of used fields (columns)\n  bool       brc= false;\n  PCOL       colp;\n  Field*    *field;\n  Field*     fp;\n  MY_BITMAP *map= table->read_set;\n\n\ttry {\n          for (field= table->field; (fp= *field); field++)\n      if (bitmap_is_set(map, fp->field_index)) {\n        if (!(colp= tdbp->ColDB(g, (PSZ)fp->field_name.str, 0))) {\n          sprintf(g->Message, \"Column %s not found in %s\", \n                  fp->field_name.str, tdbp->GetName());\n\t\t\t\t\tthrow 1;\n\t\t\t\t} // endif colp\n\n        if ((brc= colp->InitValue(g)))\n\t\t\t\t\tthrow 2;\n\n        colp->AddColUse(U_P);           // For PLG tables\n        } // endif\n\n\t} catch (int n) {\n\t\tif (trace(1))\n\t\t\thtrc(\"Exception %d: %s\\n\", n, g->Message);\n\t\tbrc= true;\n\t} catch (const char *msg) {\n\t\tstrcpy(g->Message, msg);\n\t\tbrc= true;\n\t} // end catch\n\n  return brc;\n} // end of CheckColumnList\n\n\n/****************************************************************************/\n/*  IsOpened: returns true if the table is already opened.                  */\n/****************************************************************************/\nbool ha_connect::IsOpened(void)\n{\n  return (!xp->CheckQuery(valid_query_id) && tdbp\n                                          && tdbp->GetUse() == USE_OPEN);\n} // end of IsOpened\n\n\n/****************************************************************************/\n/*  Close a CONNECT table.                                                  */\n/****************************************************************************/\nint ha_connect::CloseTable(PGLOBAL g)\n{\n  int rc= CntCloseTable(g, tdbp, nox, abort);\n  tdbp= NULL;\n  sdvalin1= sdvalin2= sdvalin3= sdvalin4= NULL;\n  sdvalout=NULL;\n  valid_info= false;\n  indexing= -1;\n  nox= true;\n  abort= false;\n  return rc;\n} // end of CloseTable\n\n\n/***********************************************************************/\n/*  Make a pseudo record from current row values. Specific to MySQL.   */\n/***********************************************************************/\nint ha_connect::MakeRecord(char *buf)\n{\n\tPCSZ           fmt;\n  char          *p, val[32];\n  int            rc= 0;\n  Field*        *field;\n  Field         *fp;\n  my_bitmap_map *org_bitmap;\n  CHARSET_INFO  *charset= tdbp->data_charset();\n//MY_BITMAP      readmap;\n  MY_BITMAP     *map;\n  PVAL           value;\n  PCOL           colp= NULL;\n  DBUG_ENTER(\"ha_connect::MakeRecord\");\n\n  if (trace(2))\n    htrc(\"Maps: read=%08X write=%08X defr=%08X defw=%08X\\n\",\n            *table->read_set->bitmap, *table->write_set->bitmap,\n            *table->def_read_set.bitmap, *table->def_write_set.bitmap);\n\n  // Avoid asserts in field::store() for columns that are not updated\n  org_bitmap= dbug_tmp_use_all_columns(table, table->write_set);\n\n  // This is for variable_length rows\n  memset(buf, 0, table->s->null_bytes);\n\n  // When sorting read_set selects all columns, so we use def_read_set\n  map= (MY_BITMAP *)&table->def_read_set;\n\n  // Make the pseudo record from field values\n  for (field= table->field; *field && !rc; field++) {\n    fp= *field;\n\n    if (fp->vcol_info && !fp->stored_in_db)\n      continue;            // This is a virtual column\n\n    if (bitmap_is_set(map, fp->field_index) || alter) {\n      // This is a used field, fill the buffer with value\n      for (colp= tdbp->GetColumns(); colp; colp= colp->GetNext())\n        if ((!mrr || colp->GetKcol()) &&\n            !stricmp(colp->GetName(), fp->field_name.str))\n          break;\n\n      if (!colp) {\n        if (mrr)\n          continue;\n\n        htrc(\"Column %s not found\\n\", fp->field_name.str);\n        dbug_tmp_restore_column_map(table->write_set, org_bitmap);\n        DBUG_RETURN(HA_ERR_WRONG_IN_RECORD);\n        } // endif colp\n\n      value= colp->GetValue();\n      p= NULL;\n\n      // All this was better optimized\n      if (!value->IsNull()) {\n        switch (value->GetType()) {\n          case TYPE_DATE:\n            if (!sdvalout)\n              sdvalout= AllocateValue(xp->g, TYPE_STRING, 20);\n\n            switch (fp->type()) {\n              case MYSQL_TYPE_DATE:\n                fmt= \"%Y-%m-%d\";\n                break;\n              case MYSQL_TYPE_TIME:\n                fmt= \"%H:%M:%S\";\n                break;\n              case MYSQL_TYPE_YEAR:\n                fmt= \"%Y\";\n                break;\n              default:\n                fmt= \"%Y-%m-%d %H:%M:%S\";\n                break;\n              } // endswitch type\n\n            // Get date in the format required by MySQL fields\n            value->FormatValue(sdvalout, fmt);\n            p= sdvalout->GetCharValue();\n            rc= fp->store(p, strlen(p), charset, CHECK_FIELD_WARN);\n            break;\n          case TYPE_STRING:\n          case TYPE_DECIM:\n            p= value->GetCharString(val);\n            charset= tdbp->data_charset();\n            rc= fp->store(p, strlen(p), charset, CHECK_FIELD_WARN);\n            break;\n\t\t\t\t\tcase TYPE_BIN:\n\t\t\t\t\t\tp= value->GetCharValue();\n\t\t\t\t\t\tcharset= &my_charset_bin;\n\t\t\t\t\t\trc= fp->store(p, strlen(p), charset, CHECK_FIELD_WARN);\n\t\t\t\t\t\tbreak;\n          case TYPE_DOUBLE:\n            rc= fp->store(value->GetFloatValue());\n            break;\n          default:\n            rc= fp->store(value->GetBigintValue(), value->IsUnsigned());\n            break;\n          } // endswitch Type\n\n        // Store functions returns 1 on overflow and -1 on fatal error\n        if (rc > 0) {\n          char buf[256];\n          THD *thd= ha_thd();\n\n          sprintf(buf, \"Out of range value %.140s for column '%s' at row %ld\",\n            value->GetCharString(val),\n            fp->field_name.str, \n            thd->get_stmt_da()->current_row_for_warning());\n\n          push_warning(thd, Sql_condition::WARN_LEVEL_WARN, 0, buf);\n          DBUG_PRINT(\"MakeRecord\", (\"%s\", buf));\n          rc= 0;\n        } else if (rc < 0)\n          rc= HA_ERR_WRONG_IN_RECORD;\n\n        fp->set_notnull();\n      } else\n        fp->set_null();\n\n      } // endif bitmap\n\n    } // endfor field\n\n  // This is sometimes required for partition tables because the buf\n  // can be different from the table->record[0] buffer\n  if (buf != (char*)table->record[0])\n    memcpy(buf, table->record[0], table->s->stored_rec_length);\n\n  // This is copied from ha_tina and is necessary to avoid asserts\n  dbug_tmp_restore_column_map(table->write_set, org_bitmap);\n  DBUG_RETURN(rc);\n} // end of MakeRecord\n\n\n/***********************************************************************/\n/*  Set row values from a MySQL pseudo record. Specific to MySQL.      */\n/***********************************************************************/\nint ha_connect::ScanRecord(PGLOBAL g, const uchar *)\n{\n  char    attr_buffer[1024];\n  char    data_buffer[1024];\n  PCSZ    fmt;\n  int     rc= 0;\n  PCOL    colp;\n  PVAL    value, sdvalin;\n  Field  *fp;\n//PTDBASE tp= (PTDBASE)tdbp;\n  String  attribute(attr_buffer, sizeof(attr_buffer),\n                    table->s->table_charset);\n  my_bitmap_map *bmap= dbug_tmp_use_all_columns(table, table->read_set);\n  const CHARSET_INFO *charset= tdbp->data_charset();\n  String  data_charset_value(data_buffer, sizeof(data_buffer),  charset);\n\n  // Scan the pseudo record for field values and set column values\n  for (Field **field=table->field ; *field ; field++) {\n    fp= *field;\n\n    if ((fp->vcol_info && !fp->stored_in_db) ||\n         fp->option_struct->special)\n      continue;            // Is a virtual column possible here ???\n\n    if ((xmod == MODE_INSERT && tdbp->GetAmType() != TYPE_AM_MYSQL\n                             && tdbp->GetAmType() != TYPE_AM_ODBC\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t && tdbp->GetAmType() != TYPE_AM_JDBC) ||\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t bitmap_is_set(table->write_set, fp->field_index)) {\n      for (colp= tdbp->GetSetCols(); colp; colp= colp->GetNext())\n        if (!stricmp(colp->GetName(), fp->field_name.str))\n          break;\n\n      if (!colp) {\n        htrc(\"Column %s not found\\n\", fp->field_name.str);\n        rc= HA_ERR_WRONG_IN_RECORD;\n        goto err;\n      } else\n        value= colp->GetValue();\n\n      // This is a used field, fill the value from the row buffer\n      // All this could be better optimized\n      if (fp->is_null()) {\n        if (colp->IsNullable())\n          value->SetNull(true);\n\n        value->Reset();\n      } else switch (value->GetType()) {\n        case TYPE_DOUBLE:\n          value->SetValue(fp->val_real());\n          break;\n        case TYPE_DATE:\n          // Get date in the format produced by MySQL fields\n          switch (fp->type()) {\n            case MYSQL_TYPE_DATE:\n              if (!sdvalin2) {\n                sdvalin2= (DTVAL*)AllocateValue(xp->g, TYPE_DATE, 19);\n                fmt= \"YYYY-MM-DD\";\n                ((DTVAL*)sdvalin2)->SetFormat(g, fmt, strlen(fmt));\n                } // endif sdvalin1\n\n              sdvalin= sdvalin2;\n              break;\n            case MYSQL_TYPE_TIME:\n              if (!sdvalin3) {\n                sdvalin3= (DTVAL*)AllocateValue(xp->g, TYPE_DATE, 19);\n                fmt= \"hh:mm:ss\";\n                ((DTVAL*)sdvalin3)->SetFormat(g, fmt, strlen(fmt));\n                } // endif sdvalin1\n\n              sdvalin= sdvalin3;\n              break;\n            case MYSQL_TYPE_YEAR:\n              if (!sdvalin4) {\n                sdvalin4= (DTVAL*)AllocateValue(xp->g, TYPE_DATE, 19);\n                fmt= \"YYYY\";\n                ((DTVAL*)sdvalin4)->SetFormat(g, fmt, strlen(fmt));\n                } // endif sdvalin1\n\n              sdvalin= sdvalin4;\n              break;\n            default:\n              if (!sdvalin1) {\n                sdvalin1= (DTVAL*)AllocateValue(xp->g, TYPE_DATE, 19);\n                fmt= \"YYYY-MM-DD hh:mm:ss\";\n                ((DTVAL*)sdvalin1)->SetFormat(g, fmt, strlen(fmt));\n                } // endif sdvalin1\n\n              sdvalin= sdvalin1;\n            } // endswitch type\n\n          sdvalin->SetNullable(colp->IsNullable());\n          fp->val_str(&attribute);\n          sdvalin->SetValue_psz(attribute.c_ptr_safe());\n          value->SetValue_pval(sdvalin);\n          break;\n        default:\n          fp->val_str(&attribute);\n\n          if (charset != &my_charset_bin) {\n            // Convert from SQL field charset to DATA_CHARSET\n            uint cnv_errors;\n\n            data_charset_value.copy(attribute.ptr(), attribute.length(),\n                                    attribute.charset(), charset, &cnv_errors);\n            value->SetValue_psz(data_charset_value.c_ptr_safe());\n          } else\n            value->SetValue_psz(attribute.c_ptr_safe());\n\n          break;\n        } // endswitch Type\n\n#ifdef NEWCHANGE\n    } else if (xmod == MODE_UPDATE) {\n      PCOL cp;\n\n      for (cp= tdbp->GetColumns(); cp; cp= cp->GetNext())\n        if (!stricmp(colp->GetName(), cp->GetName()))\n          break;\n\n      if (!cp) {\n        rc= HA_ERR_WRONG_IN_RECORD;\n        goto err;\n        } // endif cp\n\n      value->SetValue_pval(cp->GetValue());\n    } else // mode Insert\n      value->Reset();\n#else\n    } // endif bitmap_is_set\n#endif\n\n    } // endfor field\n\n err:\n  dbug_tmp_restore_column_map(table->read_set, bmap);\n  return rc;\n} // end of ScanRecord\n\n\n/***********************************************************************/\n/*  Check change in index column. Specific to MySQL.                   */\n/*  Should be elaborated to check for real changes.                    */\n/***********************************************************************/\nint ha_connect::CheckRecord(PGLOBAL g, const uchar *, const uchar *newbuf)\n{\n\treturn ScanRecord(g, newbuf);\n} // end of dummy CheckRecord\n\n\n/***********************************************************************/\n/*  Return true if this field is used in current indexing.             */\n/***********************************************************************/\nbool ha_connect::IsIndexed(Field *fp)\n{\n\tif (active_index < MAX_KEY) {\n\t\tKEY_PART_INFO *kpart;\n\t\tKEY           *kfp= &table->key_info[active_index];\n\t\tuint           rem= kfp->user_defined_key_parts;\n\n\t\tfor (kpart= kfp->key_part; rem; rem--, kpart++)\n\t\t\tif (kpart->field == fp)\n\t\t\t\treturn true;\n\n\t} // endif active_index\n\n\treturn false;\n} // end of IsIndexed\n\n\n/***********************************************************************/\n/*  Return the where clause for remote indexed read.                   */\n/***********************************************************************/\nbool ha_connect::MakeKeyWhere(PGLOBAL g, PSTRG qry, OPVAL vop, char q,\n\t                            const key_range *kr)\n{\n\tconst uchar     *ptr;\n//uint             i, rem, len, klen, stlen;\n\tuint             i, rem, len, stlen;\n\tbool             nq, both, oom;\n\tOPVAL            op;\n\tField           *fp;\n\tconst key_range *ranges[2];\n\tmy_bitmap_map   *old_map;\n\tKEY             *kfp;\n  KEY_PART_INFO   *kpart;\n\n  if (active_index == MAX_KEY)\n    return false;\n\n\tranges[0]= kr;\n\tranges[1]= (end_range && !eq_range) ? &save_end_range : NULL;\n\n\tif (!ranges[0] && !ranges[1]) {\n\t\tstrcpy(g->Message, \"MakeKeyWhere: No key\");\n\t  return true;\n\t}\telse\n\t\tboth= ranges[0] && ranges[1];\n\n\tkfp= &table->key_info[active_index];\n\told_map= dbug_tmp_use_all_columns(table, table->write_set);\n\n\tfor (i= 0; i <= 1; i++) {\n\t\tif (ranges[i] == NULL)\n\t\t\tcontinue;\n\n\t\tif (both && i > 0)\n\t\t\tqry->Append(\") AND (\");\n\t\telse\n\t\t\tqry->Append(\" WHERE (\");\n\n//\tklen= len= ranges[i]->length;\n\t\tlen= ranges[i]->length;\n\t\trem= kfp->user_defined_key_parts;\n\t\tptr= ranges[i]->key;\n\n\t\tfor (kpart= kfp->key_part; rem; rem--, kpart++) {\n\t\t\tfp= kpart->field;\n\t\t\tstlen= kpart->store_length;\n\t\t\tnq= fp->str_needs_quotes();\n\n\t\t\tif (kpart != kfp->key_part)\n\t\t\t\tqry->Append(\" AND \");\n\n\t\t\tif (q) {\n\t\t\t\tqry->Append(q);\n\t\t\t\tqry->Append((PSZ)fp->field_name.str);\n\t\t\t\tqry->Append(q);\n\t\t\t}\telse\n\t\t\t\tqry->Append((PSZ)fp->field_name.str);\n\n\t\t\tswitch (ranges[i]->flag) {\n\t\t\tcase HA_READ_KEY_EXACT:\n//\t\t\top= (stlen >= len || !nq || fp->result_type() != STRING_RESULT)\n//\t\t\t\t? OP_EQ : OP_LIKE;\n\t\t\t\top= OP_EQ;\n\t\t\t\tbreak;\n\t\t\tcase HA_READ_AFTER_KEY:\t  \n\t\t\t\top= (stlen >= len || i > 0) ? (i > 0 ? OP_LE : OP_GT) : OP_GE;\n\t\t\t\tbreak;\n\t\t\tcase HA_READ_KEY_OR_NEXT:\n\t\t\t\top= OP_GE;\n\t\t\t\tbreak;\n\t\t\tcase HA_READ_BEFORE_KEY:\t\n\t\t\t\top= (stlen >= len) ? OP_LT : OP_LE;\n\t\t\t\tbreak;\n\t\t\tcase HA_READ_KEY_OR_PREV:\n\t\t\t\top= OP_LE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tsprintf(g->Message, \"cannot handle flag %d\", ranges[i]->flag);\n\t\t\t\tgoto err;\n\t\t\t}\t// endswitch flag\n\n\t\t\tqry->Append((PSZ)GetValStr(op, false));\n\n\t\t\tif (nq)\n\t\t\t\tqry->Append('\\'');\n\n\t\t\tif (kpart->key_part_flag & HA_VAR_LENGTH_PART) {\n\t\t\t\tString varchar;\n\t\t\t\tuint   var_length= uint2korr(ptr);\n\n\t\t\t\tvarchar.set_quick((char*)ptr + HA_KEY_BLOB_LENGTH,\n\t\t\t\t\tvar_length, &my_charset_bin);\n\t\t\t\tqry->Append(varchar.ptr(), varchar.length(), nq);\n\t\t\t}\telse {\n\t\t\t\tchar   strbuff[MAX_FIELD_WIDTH];\n\t\t\t\tString str(strbuff, sizeof(strbuff), kpart->field->charset()), *res;\n\n\t\t\t\tres= fp->val_str(&str, ptr);\n\t\t\t\tqry->Append(res->ptr(), res->length(), nq);\n\t\t\t} // endif flag\n\n\t\t\tif (nq)\n\t\t\t\tqry->Append('\\'');\n\n\t\t\tif (stlen >= len)\n\t\t\t\tbreak;\n\n\t\t\tlen-= stlen;\n\n\t\t\t/* For nullable columns, null-byte is already skipped before, that is\n\t\t\tptr was incremented by 1. Since store_length still counts null-byte,\n\t\t\twe need to subtract 1 from store_length. */\n\t\t\tptr+= stlen - MY_TEST(kpart->null_bit);\n\t\t} // endfor kpart\n\n\t\t} // endfor i\n\n\tqry->Append(')');\n\n  if ((oom= qry->IsTruncated()))\n    strcpy(g->Message, \"Out of memory\");\n\n\tdbug_tmp_restore_column_map(table->write_set, old_map);\n\treturn oom;\n\nerr:\n\tdbug_tmp_restore_column_map(table->write_set, old_map);\n\treturn true;\n} // end of MakeKeyWhere\n\n\n/***********************************************************************/\n/*  Return the string representing an operator.                        */\n/***********************************************************************/\nconst char *ha_connect::GetValStr(OPVAL vop, bool neg)\n{\n  const char *val;\n\n  switch (vop) {\n    case OP_EQ:\n      val= \"= \";\n      break;\n    case OP_NE:\n      val= \" <> \";\n      break;\n    case OP_GT:\n      val= \" > \";\n      break;\n    case OP_GE:\n      val= \" >= \";\n      break;\n    case OP_LT:\n      val= \" < \";\n      break;\n    case OP_LE:\n      val= \" <= \";\n      break;\n    case OP_IN:\n      val= (neg) ? \" NOT IN (\" : \" IN (\";\n      break;\n    case OP_NULL:\n      val= (neg) ? \" IS NOT NULL\" : \" IS NULL\";\n      break;\n    case OP_LIKE:\n      val= (neg) ? \" NOT LIKE \" : \" LIKE \";\n      break;\n    case OP_XX:\n      val= (neg) ? \" NOT BETWEEN \" : \" BETWEEN \";\n      break;\n    case OP_EXIST:\n      val= (neg) ? \" NOT EXISTS \" : \" EXISTS \";\n      break;\n    case OP_AND:\n      val= \" AND \";\n      break;\n    case OP_OR:\n      val= \" OR \";\n      break;\n    case OP_NOT:\n      val= \" NOT \";\n      break;\n    case OP_CNC:\n      val= \" || \";\n      break;\n    case OP_ADD:\n      val= \" + \";\n      break;\n    case OP_SUB:\n      val= \" - \";\n      break;\n    case OP_MULT:\n      val= \" * \";\n      break;\n    case OP_DIV:\n      val= \" / \";\n      break;\n    default:\n      val= \" ? \";\n      break;\n    } /* endswitch */\n\n  return val;\n} // end of GetValStr\n\n#if 0\n/***********************************************************************/\n/*  Check the WHERE condition and return a CONNECT filter.             */\n/***********************************************************************/\nPFIL ha_connect::CheckFilter(PGLOBAL g)\n{\n  return CondFilter(g, (Item *)pushed_cond);\n} // end of CheckFilter\n#endif // 0\n\n/***********************************************************************/\n/*  Check the WHERE condition and return a CONNECT filter.             */\n/***********************************************************************/\nPFIL ha_connect::CondFilter(PGLOBAL g, Item *cond)\n{\n  unsigned int i;\n  bool  ismul= false;\n  OPVAL vop= OP_XX;\n  PFIL  filp= NULL;\n\n  if (!cond)\n    return NULL;\n\n  if (trace(1))\n    htrc(\"Cond type=%d\\n\", cond->type());\n\n  if (cond->type() == COND::COND_ITEM) {\n    PFIL       fp;\n    Item_cond *cond_item= (Item_cond *)cond;\n\n    if (trace(1))\n      htrc(\"Cond: Ftype=%d name=%s\\n\", cond_item->functype(),\n                                       cond_item->func_name());\n\n    switch (cond_item->functype()) {\n      case Item_func::COND_AND_FUNC: vop= OP_AND; break;\n      case Item_func::COND_OR_FUNC:  vop= OP_OR;  break;\n      default: return NULL;\n      } // endswitch functype\n\n    List<Item>* arglist= cond_item->argument_list();\n    List_iterator<Item> li(*arglist);\n    Item *subitem;\n\n    for (i= 0; i < arglist->elements; i++)\n      if ((subitem= li++)) {\n        if (!(fp= CondFilter(g, subitem))) {\n          if (vop == OP_OR)\n            return NULL;\n        } else\n          filp= (filp) ? MakeFilter(g, filp, vop, fp) : fp;\n\n      } else\n        return NULL;\n\n  } else if (cond->type() == COND::FUNC_ITEM) {\n    unsigned int i;\n    bool       iscol, neg= FALSE;\n    PCOL       colp[2]= {NULL,NULL};\n    PPARM      pfirst= NULL, pprec= NULL;\n    POPER      pop;\n    Item_func *condf= (Item_func *)cond;\n    Item*     *args= condf->arguments();\n\n    if (trace(1))\n      htrc(\"Func type=%d argnum=%d\\n\", condf->functype(),\n                                       condf->argument_count());\n\n    switch (condf->functype()) {\n      case Item_func::EQUAL_FUNC:\n      case Item_func::EQ_FUNC: vop= OP_EQ;  break;\n      case Item_func::NE_FUNC: vop= OP_NE;  break;\n      case Item_func::LT_FUNC: vop= OP_LT;  break;\n      case Item_func::LE_FUNC: vop= OP_LE;  break;\n      case Item_func::GE_FUNC: vop= OP_GE;  break;\n      case Item_func::GT_FUNC: vop= OP_GT;  break;\n      case Item_func::IN_FUNC: vop= OP_IN;\t/* fall through */\n      case Item_func::BETWEEN:\n        ismul= true;\n        neg= ((Item_func_opt_neg *)condf)->negated;\n        break;\n      default: return NULL;\n      } // endswitch functype\n\n    pop= (POPER)PlugSubAlloc(g, NULL, sizeof(OPER));\n    pop->Name= NULL;\n    pop->Val=vop;\n    pop->Mod= 0;\n\n    if (condf->argument_count() < 2)\n      return NULL;\n\n    for (i= 0; i < condf->argument_count(); i++) {\n      if (trace(1))\n        htrc(\"Argtype(%d)=%d\\n\", i, args[i]->type());\n\n      if (i >= 2 && !ismul) {\n        if (trace(1))\n          htrc(\"Unexpected arg for vop=%d\\n\", vop);\n\n        continue;\n        } // endif i\n\n      if ((iscol= args[i]->type() == COND::FIELD_ITEM)) {\n        Item_field *pField= (Item_field *)args[i];\n\n        // IN and BETWEEN clauses should be col VOP list\n        if (i && ismul)\n          return NULL;\n\n        if (pField->field->table != table ||\n            !(colp[i]= tdbp->ColDB(g, (PSZ)pField->field->field_name.str, 0)))\n          return NULL;  // Column does not belong to this table\n\n\t\t\t\t// These types are not yet implemented (buggy)\n\t\t\t\tswitch (pField->field->type()) {\n\t\t\t\tcase MYSQL_TYPE_TIMESTAMP:\n\t\t\t\tcase MYSQL_TYPE_DATE:\n\t\t\t\tcase MYSQL_TYPE_TIME:\n\t\t\t\tcase MYSQL_TYPE_DATETIME:\n\t\t\t\tcase MYSQL_TYPE_YEAR:\n\t\t\t\tcase MYSQL_TYPE_NEWDATE:\n\t\t\t\t\treturn NULL;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t} // endswitch type\n\n        if (trace(1)) {\n          htrc(\"Field index=%d\\n\", pField->field->field_index);\n          htrc(\"Field name=%s\\n\", pField->field->field_name.str);\n          } // endif trace\n\n      } else {\n        char    buff[256];\n        String *res, tmp(buff, sizeof(buff), &my_charset_bin);\n        Item_basic_constant *pval= (Item_basic_constant *)args[i];\n        PPARM pp= (PPARM)PlugSubAlloc(g, NULL, sizeof(PARM));\n\n        // IN and BETWEEN clauses should be col VOP list\n        if (!i && (ismul))\n          return NULL;\n\n        switch (args[i]->real_type()) {\n          case COND::CONST_ITEM:\n          switch (args[i]->cmp_type()) {\n            case STRING_RESULT:\n              res= pval->val_str(&tmp);\n              pp->Value= PlugSubAllocStr(g, NULL, res->ptr(), res->length());\n              pp->Type= (pp->Value) ? TYPE_STRING : TYPE_ERROR;\n              break;\n            case INT_RESULT:\n              pp->Type= TYPE_INT;\n              pp->Value= PlugSubAlloc(g, NULL, sizeof(int));\n              *((int*)pp->Value)= (int)pval->val_int();\n              break;\n            case TIME_RESULT:\n              pp->Type= TYPE_DATE;\n              pp->Value= PlugSubAlloc(g, NULL, sizeof(int));\n              *((int*)pp->Value)= (int) Temporal_hybrid(pval).to_longlong();\n              break;\n            case REAL_RESULT:\n            case DECIMAL_RESULT:\n              pp->Type= TYPE_DOUBLE;\n              pp->Value= PlugSubAlloc(g, NULL, sizeof(double));\n              *((double*)pp->Value)= pval->val_real();\n              break;\n            case ROW_RESULT:\n              DBUG_ASSERT(0);\n              return NULL;\n          }\n          break;\n          case COND::CACHE_ITEM:    // Possible ???\n          case COND::NULL_ITEM:     // TODO: handle this\n          default:\n            return NULL;\n        } // endswitch type\n\n\t\t\t\tif (trace(1))\n          htrc(\"Value type=%hd\\n\", pp->Type);\n\n        // Append the value to the argument list\n        if (pprec)\n          pprec->Next= pp;\n        else\n          pfirst= pp;\n\n        pp->Domain= i;\n        pp->Next= NULL;\n        pprec= pp;\n      } // endif type\n\n      } // endfor i\n\n    filp= MakeFilter(g, colp, pop, pfirst, neg);\n  } else {\n    if (trace(1))\n      htrc(\"Unsupported condition\\n\");\n\n    return NULL;\n  } // endif's type\n\n  return filp;\n} // end of CondFilter\n\n/***********************************************************************/\n/*  Check the WHERE condition and return a MYSQL/ODBC/JDBC/WQL filter. */\n/***********************************************************************/\nPCFIL ha_connect::CheckCond(PGLOBAL g, PCFIL filp, const Item *cond)\n{\n\tAMT   tty= filp->Type;\n  char *body= filp->Body;\n\tchar *havg= filp->Having;\n\tunsigned int i;\n  bool  ismul= false, x= (tty == TYPE_AM_MYX || tty == TYPE_AM_XDBC);\n  bool  nonul= ((tty == TYPE_AM_ODBC || tty == TYPE_AM_JDBC) && \n\t\t (tdbp->GetMode() == MODE_INSERT || tdbp->GetMode() == MODE_DELETE));\n  OPVAL vop= OP_XX;\n\n  if (!cond)\n    return NULL;\n\n  if (trace(1))\n    htrc(\"Cond type=%d\\n\", cond->type());\n\n  if (cond->type() == COND::COND_ITEM) {\n    char      *pb0, *pb1, *pb2, *ph0= 0, *ph1= 0, *ph2= 0;\n\t\tbool       bb= false, bh= false;\n    Item_cond *cond_item= (Item_cond *)cond;\n\n    if (x)\n      return NULL;\n\t\telse\n\t\t\tpb0= pb1= pb2= ph0= ph1= ph2= NULL;\n\n    if (trace(1))\n      htrc(\"Cond: Ftype=%d name=%s\\n\", cond_item->functype(),\n                                       cond_item->func_name());\n\n    switch (cond_item->functype()) {\n      case Item_func::COND_AND_FUNC: vop= OP_AND; break;\n      case Item_func::COND_OR_FUNC:  vop= OP_OR;  break;\n      default: return NULL;\n      } // endswitch functype\n\n    List<Item>* arglist= cond_item->argument_list();\n    List_iterator<Item> li(*arglist);\n    const Item *subitem;\n\n    pb0= pb1= body + strlen(body);\n    strcpy(pb0, \"(\");\n    pb2= pb1 + 1;\n\n\t\tif (havg) {\n\t\t\tph0= ph1= havg + strlen(havg);\n\t\t\tstrcpy(ph0, \"(\");\n\t\t\tph2= ph1 + 1;\n\t\t} // endif havg\n\n    for (i= 0; i < arglist->elements; i++)\n      if ((subitem= li++)) {\n        if (!CheckCond(g, filp, subitem)) {\n          if (vop == OP_OR || nonul)\n            return NULL;\n\t\t\t\t\telse {\n\t\t\t\t\t\t*pb2= 0;\n\t\t\t\t\t\tif (havg) *ph2= 0;\n\t\t\t\t\t}\t// endelse\n\n        } else {\n\t\t\t\t\tif (filp->Bd) {\n\t\t\t\t\t\tpb1= pb2 + strlen(pb2);\n\t\t\t\t\t\tstrcpy(pb1, GetValStr(vop, false));\n\t\t\t\t\t\tpb2= pb1 + strlen(pb1);\n\t\t\t\t\t} // endif Bd\n\n\t\t\t\t\tif (filp->Hv) {\n\t\t\t\t\t\tph1= ph2 + strlen(ph2);\n\t\t\t\t\t\tstrcpy(ph1, GetValStr(vop, false));\n\t\t\t\t\t\tph2= ph1 + strlen(ph1);\n\t\t\t\t\t} // endif Hv\n\n        } // endif CheckCond\n\n\t\t\t\tbb |= filp->Bd;\n\t\t\t\tbh |= filp->Hv;\n\t\t\t\tfilp->Bd= filp->Hv= false;\n      } else\n        return NULL;\n\n    if (bb)\t{\n      strcpy(pb1, \")\");\n\t\t\tfilp->Bd= bb;\n\t\t} else\n\t\t\t*pb0= 0;\n\n\t\tif (havg) {\n\t\t\tif (bb && bh && vop == OP_OR) {\n\t\t\t\t// Cannot or'ed a where clause with a having clause\n\t\t\t\tbb= bh= 0;\n\t\t\t\t*pb0= 0;\n\t\t\t\t*ph0= 0;\n\t\t\t} else if (bh)\t{\n\t\t\t\tstrcpy(ph1, \")\");\n\t\t\t\tfilp->Hv= bh;\n\t\t\t} else\n\t\t\t\t*ph0= 0;\n\n\t\t} // endif havg\n\n\t\tif (!bb && !bh)\n\t\t\treturn NULL;\n\n  } else if (cond->type() == COND::FUNC_ITEM) {\n    unsigned int i;\n    bool       iscol, ishav= false, neg= false;\n    Item_func *condf= (Item_func *)cond;\n    Item*     *args= condf->arguments();\n\n\t\tfilp->Bd= filp->Hv= false;\n\n    if (trace(1))\n      htrc(\"Func type=%d argnum=%d\\n\", condf->functype(),\n                                       condf->argument_count());\n\n    switch (condf->functype()) {\n      case Item_func::EQUAL_FUNC:\n\t\t\tcase Item_func::EQ_FUNC:     vop= OP_EQ;   break;\n\t\t\tcase Item_func::NE_FUNC:     vop= OP_NE;   break;\n\t\t\tcase Item_func::LT_FUNC:     vop= OP_LT;   break;\n\t\t\tcase Item_func::LE_FUNC:     vop= OP_LE;   break;\n\t\t\tcase Item_func::GE_FUNC:     vop= OP_GE;   break;\n\t\t\tcase Item_func::GT_FUNC:     vop= OP_GT;   break;\n#if MYSQL_VERSION_ID > 100200\n\t\t\tcase Item_func::LIKE_FUNC:\n\t\t\t\tvop = OP_LIKE;\n\t\t\t  neg= ((Item_func_like*)condf)->negated;\n\t\t\t  break;\n#endif // VERSION_ID > 100200\n\t\t\tcase Item_func::ISNOTNULL_FUNC:\n\t\t\t\tneg= true;\t\n\t\t\t\t// fall through\n\t\t\tcase Item_func::ISNULL_FUNC: vop= OP_NULL; break;\n\t\t\tcase Item_func::IN_FUNC:     vop= OP_IN; /* fall through */\n      case Item_func::BETWEEN:\n        ismul= true;\n        neg= ((Item_func_opt_neg *)condf)->negated;\n        break;\n      default: return NULL;\n      } // endswitch functype\n\n    if (condf->argument_count() < 2)\n      return NULL;\n    else if (ismul && tty == TYPE_AM_WMI)\n      return NULL;        // Not supported by WQL\n\n    if (x && (neg || !(vop == OP_EQ || vop == OP_IN || vop == OP_NULL)))\n      return NULL;\n\n    for (i= 0; i < condf->argument_count(); i++) {\n      if (trace(1))\n        htrc(\"Argtype(%d)=%d\\n\", i, args[i]->type());\n\n      if (i >= 2 && !ismul) {\n        if (trace(1))\n          htrc(\"Unexpected arg for vop=%d\\n\", vop);\n\n        continue;\n        } // endif i\n\n      if ((iscol= args[i]->type() == COND::FIELD_ITEM)) {\n        const char *fnm;\n        ha_field_option_struct *fop;\n        Item_field *pField= (Item_field *)args[i];\n\n\t\t\t\t// IN and BETWEEN clauses should be col VOP list\n\t\t\t\tif (i && (x || ismul))\n          return NULL;\t// IN and BETWEEN clauses should be col VOP list\n\t\t\t\telse if (pField->field->table != table)\n\t\t\t\t\treturn NULL;  // Field does not belong to this table\n\t\t\t\telse if (tty != TYPE_AM_WMI && IsIndexed(pField->field))\n\t\t\t\t\treturn NULL;  // Will be handled by ReadKey\n        else\n          fop= GetFieldOptionStruct(pField->field);\n\n        if (fop && fop->special) {\n          if (tty == TYPE_AM_TBL && !stricmp(fop->special, \"TABID\"))\n            fnm= \"TABID\";\n          else if (tty == TYPE_AM_PLG)\n            fnm= fop->special;\n          else\n            return NULL;\n\n\t\t\t\t} else if (tty == TYPE_AM_TBL) {\n\t\t\t\t\treturn NULL;\n\t\t\t\t} else {\n\t\t\t\t\tbool h;\n\n\t\t\t\t\tfnm= filp->Chk(pField->field->field_name.str, &h);\n\n\t\t\t\t\tif (h && i && !ishav)\n\t\t\t\t\t\treturn NULL;\t\t\t// Having should be\tcol VOP arg\n\t\t\t\t\telse\n\t\t\t\t\t\tishav= h;\n\n\t\t\t\t}\t// endif's\n\n        if (trace(1)) {\n          htrc(\"Field index=%d\\n\", pField->field->field_index);\n          htrc(\"Field name=%s\\n\", pField->field->field_name.str);\n          htrc(\"Field type=%d\\n\", pField->field->type());\n          htrc(\"Field_type=%d\\n\", args[i]->field_type());\n          } // endif trace\n\n        strcat((ishav ? havg : body), fnm);\n      } else if (args[i]->type() == COND::FUNC_ITEM) {\n        if (tty == TYPE_AM_MYSQL) {\n          if (!CheckCond(g, filp, args[i]))\n            return NULL;\n\n        } else\n          return NULL;\n\n      } else {\n        char    buff[256];\n        String *res, tmp(buff, sizeof(buff), &my_charset_bin);\n        Item_basic_constant *pval= (Item_basic_constant *)args[i];\n        Item::Type type= args[i]->real_type();\n\n        switch (type) {\n          case COND::CONST_ITEM:\n          case COND::NULL_ITEM:\n          case COND::CACHE_ITEM:\n            break;\n          default:\n            return NULL;\n          } // endswitch type\n\n        if ((res= pval->val_str(&tmp)) == NULL)\n          return NULL;                      // To be clarified\n\n        if (trace(1))\n          htrc(\"Value=%.*s\\n\", res->length(), res->ptr());\n\n        // IN and BETWEEN clauses should be col VOP list\n        if (!i && (x || ismul))\n          return NULL;\n\n        if (!x) {\n\t\t\t\t\tconst char *p;\n\t\t\t\t\tchar *s= (ishav) ? havg : body;\n\t\t\t\t\tuint\tj, k, n;\n\n          // Append the value to the filter\n          switch (args[i]->field_type()) {\n            case MYSQL_TYPE_TIMESTAMP:\n            case MYSQL_TYPE_DATETIME:\n              if (tty == TYPE_AM_ODBC) {\n                strcat(s, \"{ts '\");\n                strncat(s, res->ptr(), res->length());\n\n                if (res->length() < 19)\n                  strcat(s, &\"1970-01-01 00:00:00\"[res->length()]);\n\n                strcat(s, \"'}\");\n                break;\n                } // endif ODBC\n\t\t// fall through\n            case MYSQL_TYPE_DATE:\n              if (tty == TYPE_AM_ODBC) {\n                strcat(s, \"{d '\");\n                strcat(strncat(s, res->ptr(), res->length()), \"'}\");\n                break;\n                } // endif ODBC\n\t\t// fall through\n\n            case MYSQL_TYPE_TIME:\n              if (tty == TYPE_AM_ODBC) {\n                strcat(s, \"{t '\");\n                strcat(strncat(s, res->ptr(), res->length()), \"'}\");\n                break;\n                } // endif ODBC\n\t\t// fall through\n\n            case MYSQL_TYPE_VARCHAR:\n              if (tty == TYPE_AM_ODBC && i) {\n                switch (args[0]->field_type()) {\n                  case MYSQL_TYPE_TIMESTAMP:\n                  case MYSQL_TYPE_DATETIME:\n                    strcat(s, \"{ts '\");\n                    strncat(s, res->ptr(), res->length());\n\n                    if (res->length() < 19)\n                      strcat(s, &\"1970-01-01 00:00:00\"[res->length()]);\n\n                    strcat(s, \"'}\");\n                    break;\n                  case MYSQL_TYPE_DATE:\n                    strcat(s, \"{d '\");\n                    strncat(s, res->ptr(), res->length());\n                    strcat(s, \"'}\");\n                    break;\n                  case MYSQL_TYPE_TIME:\n                    strcat(s, \"{t '\");\n                    strncat(s, res->ptr(), res->length());\n                    strcat(s, \"'}\");\n                    break;\n                  default:\n\t\t\t\t\t\t\t\t\t\tj= strlen(s);\n\t\t\t\t\t\t\t\t\t\ts[j++]= '\\'';\n\t\t\t\t\t\t\t\t\t\tp= res->ptr();\n\t\t\t\t\t\t\t\t\t\tn= res->length();\n\n\t\t\t\t\t\t\t\t\t\tfor (k= 0; k < n; k++) {\n\t\t\t\t\t\t\t\t\t\t\tif (p[k] == '\\'')\n\t\t\t\t\t\t\t\t\t\t\t\ts[j++]= '\\'';\n\n\t\t\t\t\t\t\t\t\t\t\ts[j++]= p[k];\n\t\t\t\t\t\t\t\t\t\t} // endfor k\n\n\t\t\t\t\t\t\t\t\t\ts[j++]= '\\'';\n\t\t\t\t\t\t\t\t\t\ts[j]= 0;\n\t\t\t\t\t\t\t\t} // endswitch field type\n\n              } else {\n\t\t\t\t\t\t\t\tj= strlen(s);\n\t\t\t\t\t\t\t\ts[j++]= '\\'';\n\t\t\t\t\t\t\t\tp= res->ptr();\n\t\t\t\t\t\t\t\tn= res->length();\n\n\t\t\t\t\t\t\t\tfor (k= 0; k < n; k++) {\n\t\t\t\t\t\t\t\t\tif (p[k] == '\\'')\n\t\t\t\t\t\t\t\t\t\ts[j++]= '\\'';\n\n\t\t\t\t\t\t\t\t\ts[j++]= p[k];\n\t\t\t\t\t\t\t\t} // endfor k\n\n\t\t\t\t\t\t\t\ts[j++]= '\\'';\n\t\t\t\t\t\t\t\ts[j]= 0;\n\t\t\t\t\t\t\t} // endif tty\n\n              break;\n            default:\n              strncat(s, res->ptr(), res->length());\n            } // endswitch field type\n\n        } else {\n          if (args[i]->field_type() == MYSQL_TYPE_VARCHAR) {\n            // Add the command to the list\n            PCMD *ncp, cmdp= new(g) CMD(g, (char*)res->c_ptr());\n\n            for (ncp= &filp->Cmds; *ncp; ncp= &(*ncp)->Next) ;\n\n            *ncp= cmdp;\n          } else\n            return NULL;\n\n        } // endif x\n\n      } // endif's Type\n\n      if (!x) {\n\t\t\t\tchar *s= (ishav) ? havg : body;\n\n\t\t\t\tif (!i)\n          strcat(s, GetValStr(vop, neg));\n        else if (vop == OP_XX && i == 1)\n          strcat(s, \" AND \");\n        else if (vop == OP_IN)\n          strcat(s, (i == condf->argument_count() - 1) ? \")\" : \",\");\n\n        } // endif x\n\n      } // endfor i\n\n\t\t\tif (x)\n\t\t\t\tfilp->Op= vop;\n\t\t\telse if (ishav)\n\t\t\t\tfilp->Hv= true;\n\t\t\telse\n\t\t\t\tfilp->Bd= true;\n\n  } else {\n    if (trace(1))\n      htrc(\"Unsupported condition\\n\");\n\n    return NULL;\n  } // endif's type\n\n  return filp;\n} // end of CheckCond\n\n\n /**\n   Push condition down to the table handler.\n\n   @param  cond   Condition to be pushed. The condition tree must not be\n                  modified by the caller.\n\n   @return\n     The 'remainder' condition that caller must use to filter out records.\n     NULL means the handler will not return rows that do not match the\n     passed condition.\n\n   @note\n     CONNECT handles the filtering only for table types that construct\n     an SQL or WQL query, but still leaves it to MySQL because only some\n     parts of the filter may be relevant.\n     The first suballocate finds the position where the string will be\n     constructed in the sarea. The second one does make the suballocation\n     with the proper length.\n */\nconst COND *ha_connect::cond_push(const COND *cond)\n{\n  DBUG_ENTER(\"ha_connect::cond_push\");\n\n  if (tdbp && CondPushEnabled()) {\n    PGLOBAL& g= xp->g;\n    AMT      tty= tdbp->GetAmType();\n    bool     x= (tty == TYPE_AM_MYX || tty == TYPE_AM_XDBC);\n    bool     b= (tty == TYPE_AM_WMI || tty == TYPE_AM_ODBC  ||\n                 tty == TYPE_AM_TBL || tty == TYPE_AM_MYSQL ||\n\t\t\t\t\t\t\t\t tty == TYPE_AM_PLG || tty == TYPE_AM_JDBC  || x);\n\n\t\t// This should never happen but is done to avoid crashing\n\t\ttry {\n\t\t\tif (b) {\n\t\t\t\tPCFIL filp;\n\t\t\t\tint   rc;\n\n\t\t\t\tif ((filp= tdbp->GetCondFil()) && tdbp->GetCond() == cond &&\n\t\t\t\t\tfilp->Idx == active_index && filp->Type == tty)\n\t\t\t\t\tgoto fin;\n\n\t\t\t\tfilp= new(g) CONDFIL(active_index, tty);\n\t\t\t\trc= filp->Init(g, this);\n\n\t\t\t\tif (rc == RC_INFO) {\n\t\t\t\t\tfilp->Having= (char*)PlugSubAlloc(g, NULL, 256);\n\t\t\t\t\t*filp->Having= 0;\n\t\t\t\t} else if (rc == RC_FX)\n\t\t\t\t\tgoto fin;\n\n\t\t\t\tfilp->Body= (char*)PlugSubAlloc(g, NULL, (x) ? 128 : 0);\n\t\t\t\t*filp->Body= 0;\n\n\t\t\t\tif (CheckCond(g, filp, cond)) {\n\t\t\t\t\tif (filp->Having && strlen(filp->Having) > 255)\n\t\t\t\t\t\tgoto fin;\t\t\t\t\t\t\t\t// Memory collapse\n\n\t\t\t\t\tif (trace(1))\n\t\t\t\t\t\thtrc(\"cond_push: %s\\n\", filp->Body);\n\n\t\t\t\t\ttdbp->SetCond(cond);\n\n\t\t\t\t\tif (!x)\n\t\t\t\t\t\tPlugSubAlloc(g, NULL, strlen(filp->Body) + 1);\n\t\t\t\t\telse\n\t\t\t\t\t\tcond= NULL;             // Does this work?\n\n\t\t\t\t\ttdbp->SetCondFil(filp);\n\t\t\t\t} else if (x && cond)\n\t\t\t\t\ttdbp->SetCondFil(filp);   // Wrong filter\n\n\t\t\t} else if (tdbp->CanBeFiltered()) {\n\t\t\t\tif (!tdbp->GetCond() || tdbp->GetCond() != cond) {\n\t\t\t\t\ttdbp->SetFilter(CondFilter(g, (Item *)cond));\n\n\t\t\t\t\tif (tdbp->GetFilter())\n\t\t\t\t\t  tdbp->SetCond(cond);\n\n\t\t\t  } // endif cond\n\n\t\t\t}\t// endif tty\n\n\t\t} catch (int n) {\n\t\t\tif (trace(1))\n\t\t\t\thtrc(\"Exception %d: %s\\n\", n, g->Message);\n\t\t} catch (const char *msg) {\n\t\t\tstrcpy(g->Message, msg);\n\t\t} // end catch\n\n\tfin:;\n  } // endif tdbp\n\n  // Let MySQL do the filtering\n  DBUG_RETURN(cond);\n} // end of cond_push\n\n/**\n  Number of rows in table. It will only be called if\n  (table_flags() & (HA_HAS_RECORDS | HA_STATS_RECORDS_IS_EXACT)) != 0\n*/\nha_rows ha_connect::records()\n{\n  if (!valid_info)\n    info(HA_STATUS_VARIABLE);\n\n  if (tdbp)\n    return stats.records;\n  else\n    return HA_POS_ERROR;\n\n} // end of records\n\n\nint ha_connect::check(THD* thd, HA_CHECK_OPT* check_opt)\n{\n\tint     rc= HA_ADMIN_OK;\n\tPGLOBAL g= ((table && table->in_use) ? GetPlug(table->in_use, xp) :\n\t\t(xp) ? xp->g : NULL);\n\tDBUG_ENTER(\"ha_connect::check\");\n\n\tif (!g || !table || xmod != MODE_READ)\n\t\tDBUG_RETURN(HA_ADMIN_INTERNAL_ERROR);\n\n\t// Do not close the table if it was opened yet (possible?)\n\tif (IsOpened()) {\n\t\tif (IsPartitioned() && CheckColumnList(g)) // map can have been changed\n\t\t\trc= HA_ADMIN_CORRUPT;\n\t\telse if (tdbp->OpenDB(g))      // Rewind table\n\t\t\trc= HA_ADMIN_CORRUPT;\n\n\t} else if (xp->CheckQuery(valid_query_id)) {\n\t\ttdbp= NULL;       // Not valid anymore\n\n\t\tif (OpenTable(g, false))\n\t\t\trc= HA_ADMIN_CORRUPT;\n\n\t} else // possible?\n\t\tDBUG_RETURN(HA_ADMIN_INTERNAL_ERROR);\n\n\tif (rc == HA_ADMIN_OK) {\n\t\tTABTYPE type= GetTypeID(GetStringOption(\"Type\", \"*\"));\n\n\t\tif (IsFileType(type)) {\n\t\t\tif (check_opt->flags & T_MEDIUM) {\n\t\t\t\t// TO DO\n\t\t\t\tdo {\n\t\t\t\t\tif ((rc= CntReadNext(g, tdbp)) == RC_FX)\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t} while (rc != RC_EF);\n\n\t\t\t\trc= (rc == RC_EF) ? HA_ADMIN_OK : HA_ADMIN_CORRUPT;\n\t\t\t} else if (check_opt->flags & T_EXTEND) {\n\t\t\t\t// TO DO\n\t\t\t} // endif's flags\n\n\t\t} // endif file type\n\n\t} else\n\t\tPushWarning(g, thd, 1);\n\n\tDBUG_RETURN(rc);\n}\t// end of check\n\n\n/**\n  Return an error message specific to this handler.\n\n  @param error  error code previously returned by handler\n  @param buf    pointer to String where to add error message\n\n  @return\n    Returns true if this is a temporary error\n*/\nbool ha_connect::get_error_message(int error, String* buf)\n{\n  DBUG_ENTER(\"ha_connect::get_error_message\");\n\n\tif (xp && xp->g) {\n\t\tPGLOBAL g= xp->g;\n\n\t\tif (trace(1))\n\t\t\thtrc(\"GEM(%d): %s\\n\", error, g->Message);\n\n\t\tbuf->append(ErrConvString(g->Message, strlen(g->Message),\n\t\t\t&my_charset_latin1).ptr());\n\t} else\n    buf->append(\"Cannot retrieve error message\");\n\n  DBUG_RETURN(false);\n} // end of get_error_message\n\n/**\n  Convert a filename partition name to system\n*/\nstatic char *decode(PGLOBAL g, const char *pn)\n  {\n  char  *buf= (char*)PlugSubAlloc(g, NULL, strlen(pn) + 1);\n  uint   dummy_errors;\n  uint32 len= copy_and_convert(buf, strlen(pn) + 1,\n                               system_charset_info,\n                               pn, strlen(pn),\n                               &my_charset_filename,\n                               &dummy_errors);\n  buf[len]= '\\0';\n  return buf;\n  } // end of decode\n\n/**\n  @brief\n  Used for opening tables. The name will be the name of the file.\n\n  @details\n  A table is opened when it needs to be opened; e.g. when a request comes in\n  for a SELECT on the table (tables are not open and closed for each request,\n  they are cached).\n\n  Called from handler.cc by handler::ha_open(). The server opens all tables by\n  calling ha_open() which then calls the handler specific open().\n\n  @note\n  For CONNECT no open can be done here because field information is not yet\n  updated. >>>>> TO BE CHECKED <<<<<\n  (Thread information could be get by using 'ha_thd')\n\n  @see\n  handler::ha_open() in handler.cc\n*/\nint ha_connect::open(const char *name, int mode, uint test_if_locked)\n{\n  int rc= 0;\n  DBUG_ENTER(\"ha_connect::open\");\n\n  if (trace(1))\n     htrc(\"open: name=%s mode=%d test=%u\\n\", name, mode, test_if_locked);\n\n  if (!(share= get_share()))\n    DBUG_RETURN(1);\n\n  thr_lock_data_init(&share->lock,&lock,NULL);\n\n  // Try to get the user if possible\n  xp= GetUser(ha_thd(), xp);\n  PGLOBAL g= (xp) ? xp->g : NULL;\n\n  // Try to set the database environment\n  if (g) {\n    rc= (CntCheckDB(g, this, name)) ? (-2) : 0;\n\n    if (g->Mrr) {\n      // This should only happen for the mrr secondary handler\n      mrr= true;\n      g->Mrr= false;\n    } else\n      mrr= false;\n\n#if defined(WITH_PARTITION_STORAGE_ENGINE)\n    if (table->part_info) {\n      if (GetStringOption(\"Filename\") || GetStringOption(\"Tabname\")\n                                      || GetStringOption(\"Connect\")) {\n        strncpy(partname, decode(g, strrchr(name, '#') + 1), sizeof(partname) - 1);\n//      strcpy(partname, table->part_info->curr_part_elem->partition_name);\n//      part_id= &table->part_info->full_part_field_set;\n      } else       // Inward table\n        strncpy(partname, strrchr(name, slash) + 1, sizeof(partname) - 1);\n\n      part_id= &table->part_info->full_part_field_set; // Temporary\n      } // endif part_info\n#endif   // WITH_PARTITION_STORAGE_ENGINE\n  } else\n    rc= HA_ERR_INTERNAL_ERROR;\n\n  DBUG_RETURN(rc);\n} // end of open\n\n/**\n  @brief\n  Make the indexes for this table\n*/\nint ha_connect::optimize(THD* thd, HA_CHECK_OPT*)\n{\n  int      rc= 0;\n  PGLOBAL& g= xp->g;\n  PDBUSER  dup= PlgGetUser(g);\n\n\ttry {\n\t\t// Ignore error on the opt file\n\t\tdup->Check &= ~CHK_OPT;\n\t\ttdbp= GetTDB(g);\n\t\tdup->Check |= CHK_OPT;\n\n\t\tif (tdbp && !tdbp->IsRemote()) {\n\t\t\tbool dop= IsTypeIndexable(GetRealType(NULL));\n\t\t\tbool dox= (tdbp->GetDef()->Indexable() == 1);\n\n\t\t\tif ((rc= ((PTDBASE)tdbp)->ResetTableOpt(g, dop, dox))) {\n\t\t\t\tif (rc == RC_INFO) {\n\t\t\t\t\tpush_warning(thd, Sql_condition::WARN_LEVEL_WARN, 0, g->Message);\n\t\t\t\t\trc= 0;\n\t\t\t\t} else\n\t\t\t\t\trc= HA_ERR_CRASHED_ON_USAGE;\t\t// Table must be repaired\n\n\t\t\t} // endif rc\n\n\t\t} else if (!tdbp)\n\t\t\trc= HA_ERR_INTERNAL_ERROR;\n\n\t} catch (int n) {\n\t\tif (trace(1))\n\t\t\thtrc(\"Exception %d: %s\\n\", n, g->Message);\n\t\trc= HA_ERR_INTERNAL_ERROR;\n\t} catch (const char *msg) {\n\t\tstrcpy(g->Message, msg);\n\t\trc= HA_ERR_INTERNAL_ERROR;\n\t} // end catch\n\n\tif (rc)\n\t\tmy_message(ER_WARN_DATA_OUT_OF_RANGE, g->Message, MYF(0));\n\n  return rc;\n} // end of optimize\n\n/**\n  @brief\n  Closes a table.\n\n  @details\n  Called from sql_base.cc, sql_select.cc, and table.cc. In sql_select.cc it is\n  only used to close up temporary tables or during the process where a\n  temporary table is converted over to being a myisam table.\n\n  For sql_base.cc look at close_data_tables().\n\n  @see\n  sql_base.cc, sql_select.cc and table.cc\n*/\nint ha_connect::close(void)\n{\n  int rc= 0;\n  DBUG_ENTER(\"ha_connect::close\");\n\n  // If this is called by a later query, the table may have\n  // been already closed and the tdbp is not valid anymore.\n  if (tdbp && xp->last_query_id == valid_query_id)\n    rc= CloseTable(xp->g);\n\n  DBUG_RETURN(rc);\n} // end of close\n\n\n/**\n  @brief\n  write_row() inserts a row. No extra() hint is given currently if a bulk load\n  is happening. buf() is a byte array of data. You can use the field\n  information to extract the data from the native byte array type.\n\n    @details\n  Example of this would be:\n    @code\n  for (Field **field=table->field ; *field ; field++)\n  {\n    ...\n  }\n    @endcode\n\n  See ha_tina.cc for an example of extracting all of the data as strings.\n  ha_berekly.cc has an example of how to store it intact by \"packing\" it\n  for ha_berkeley's own native storage type.\n\n  See the note for update_row() on auto_increments and timestamps. This\n  case also applies to write_row().\n\n  Called from item_sum.cc, item_sum.cc, sql_acl.cc, sql_insert.cc,\n  sql_insert.cc, sql_select.cc, sql_table.cc, sql_udf.cc, and sql_update.cc.\n\n    @see\n  item_sum.cc, item_sum.cc, sql_acl.cc, sql_insert.cc,\n  sql_insert.cc, sql_select.cc, sql_table.cc, sql_udf.cc and sql_update.cc\n*/\nint ha_connect::write_row(const uchar *buf)\n{\n  int      rc= 0;\n  PGLOBAL& g= xp->g;\n  DBUG_ENTER(\"ha_connect::write_row\");\n\n  // This is not tested yet\n  if (xmod == MODE_ALTER) {\n    if (IsPartitioned() && GetStringOption(\"Filename\", NULL))\n      // Why does this happen now that check_if_supported_inplace_alter is called?\n      DBUG_RETURN(0);     // Alter table on an outward partition table\n\n    xmod= MODE_INSERT;\n  } else if (xmod == MODE_ANY)\n    DBUG_RETURN(0);       // Probably never met\n\n  // Open the table if it was not opened yet (locked)\n  if (!IsOpened() || xmod != tdbp->GetMode()) {\n    if (IsOpened())\n      CloseTable(g);\n\n    if ((rc= OpenTable(g)))\n      DBUG_RETURN(rc);\n\n    } // endif isopened\n\n#if 0                // AUTO_INCREMENT NIY\n  if (table->next_number_field && buf == table->record[0]) {\n    int error;\n\n    if ((error= update_auto_increment()))\n      return error;\n\n    } // endif nex_number_field\n#endif // 0\n\n  // Set column values from the passed pseudo record\n  if ((rc= ScanRecord(g, buf)))\n    DBUG_RETURN(rc);\n\n  // Return result code from write operation\n  if (CntWriteRow(g, tdbp)) {\n    DBUG_PRINT(\"write_row\", (\"%s\", g->Message));\n    htrc(\"write_row: %s\\n\", g->Message);\n    rc= HA_ERR_INTERNAL_ERROR;\n  } else                // Table is modified\n    nox= false;         // Indexes to be remade\n\n  DBUG_RETURN(rc);\n} // end of write_row\n\n\n/**\n  @brief\n  Yes, update_row() does what you expect, it updates a row. old_data will have\n  the previous row record in it, while new_data will have the newest data in it.\n  Keep in mind that the server can do updates based on ordering if an ORDER BY\n  clause was used. Consecutive ordering is not guaranteed.\n\n    @details\n  Currently new_data will not have an updated auto_increament record, or\n  and updated timestamp field. You can do these for example by doing:\n    @code\n  if (table->timestamp_field_type & TIMESTAMP_AUTO_SET_ON_UPDATE)\n    table->timestamp_field->set_time();\n  if (table->next_number_field && record == table->record[0])\n    update_auto_increment();\n    @endcode\n\n  Called from sql_select.cc, sql_acl.cc, sql_update.cc, and sql_insert.cc.\n\n    @see\n  sql_select.cc, sql_acl.cc, sql_update.cc and sql_insert.cc\n*/\nint ha_connect::update_row(const uchar *old_data, const uchar *new_data)\n{\n  int      rc= 0;\n  PGLOBAL& g= xp->g;\n  DBUG_ENTER(\"ha_connect::update_row\");\n\n  if (trace(2))\n    htrc(\"update_row: old=%s new=%s\\n\", old_data, new_data);\n\n  // Check values for possible change in indexed column\n  if ((rc= CheckRecord(g, old_data, new_data)))\n    DBUG_RETURN(rc);\n\n  if (CntUpdateRow(g, tdbp)) {\n    DBUG_PRINT(\"update_row\", (\"%s\", g->Message));\n    htrc(\"update_row CONNECT: %s\\n\", g->Message);\n    rc= HA_ERR_INTERNAL_ERROR;\n  } else\n    nox= false;               // Table is modified\n\n  DBUG_RETURN(rc);\n} // end of update_row\n\n\n/**\n  @brief\n  This will delete a row. buf will contain a copy of the row to be deleted.\n  The server will call this right after the current row has been called (from\n  either a previous rnd_nexT() or index call).\n\n  @details\n  If you keep a pointer to the last row or can access a primary key it will\n  make doing the deletion quite a bit easier. Keep in mind that the server does\n  not guarantee consecutive deletions. ORDER BY clauses can be used.\n\n  Called in sql_acl.cc and sql_udf.cc to manage internal table\n  information.  Called in sql_delete.cc, sql_insert.cc, and\n  sql_select.cc. In sql_select it is used for removing duplicates\n  while in insert it is used for REPLACE calls.\n\n  @see\n  sql_acl.cc, sql_udf.cc, sql_delete.cc, sql_insert.cc and sql_select.cc\n*/\nint ha_connect::delete_row(const uchar *)\n{\n  int rc= 0;\n  DBUG_ENTER(\"ha_connect::delete_row\");\n\n  if (CntDeleteRow(xp->g, tdbp, false)) {\n    rc= HA_ERR_INTERNAL_ERROR;\n    htrc(\"delete_row CONNECT: %s\\n\", xp->g->Message);\n  } else\n    nox= false;             // To remake indexes\n\n  DBUG_RETURN(rc);\n} // end of delete_row\n\n\n/****************************************************************************/\n/*  We seem to come here at the begining of an index use.                   */\n/****************************************************************************/\nint ha_connect::index_init(uint idx, bool sorted)\n{\n  int rc;\n  PGLOBAL& g= xp->g;\n  DBUG_ENTER(\"index_init\");\n\n  if (trace(1))\n    htrc(\"index_init: this=%p idx=%u sorted=%d\\n\", this, idx, sorted);\n\n  if (GetIndexType(GetRealType()) == 2) {\n    if (xmod == MODE_READ)\n      // This is a remote index\n      xmod= MODE_READX;\n\n    if (!(rc= rnd_init(0))) {\n//    if (xmod == MODE_READX) {\n        active_index= idx;\n        indexing= IsUnique(idx) ? 1 : 2;\n//    } else {\n//      active_index= MAX_KEY;\n//      indexing= 0;\n//    } // endif xmod\n\n      } //endif rc\n\n    DBUG_RETURN(rc);\n    } // endif index type\n\n  if ((rc= rnd_init(0)))\n    DBUG_RETURN(rc);\n\n  if (locked == 2) {\n    // Indexes are not updated in lock write mode\n    active_index= MAX_KEY;\n    indexing= 0;\n    DBUG_RETURN(0);\n    } // endif locked\n\n  indexing= CntIndexInit(g, tdbp, (signed)idx, sorted);\n\n  if (indexing <= 0) {\n    DBUG_PRINT(\"index_init\", (\"%s\", g->Message));\n    htrc(\"index_init CONNECT: %s\\n\", g->Message);\n    active_index= MAX_KEY;\n    rc= HA_ERR_INTERNAL_ERROR;\n  } else if (tdbp->GetKindex()) {\n    if (((PTDBDOS)tdbp)->GetKindex()->GetNum_K()) {\n      if (tdbp->GetFtype() != RECFM_NAF)\n        ((PTDBDOS)tdbp)->GetTxfp()->ResetBuffer(g);\n\n      active_index= idx;\n//  } else {        // Void table\n//    active_index= MAX_KEY;\n//    indexing= 0;\n    } // endif Num\n\n    rc= 0;\n  } // endif indexing\n\n  if (trace(1))\n    htrc(\"index_init: rc=%d indexing=%d active_index=%d\\n\",\n            rc, indexing, active_index);\n\n  DBUG_RETURN(rc);\n} // end of index_init\n\n/****************************************************************************/\n/*  We seem to come here at the end of an index use.                        */\n/****************************************************************************/\nint ha_connect::index_end()\n{\n  DBUG_ENTER(\"index_end\");\n  active_index= MAX_KEY;\n  ds_mrr.dsmrr_close();\n  DBUG_RETURN(rnd_end());\n} // end of index_end\n\n\n/****************************************************************************/\n/*  This is internally called by all indexed reading functions.             */\n/****************************************************************************/\nint ha_connect::ReadIndexed(uchar *buf, OPVAL op, const key_range *kr) \n{\n  int rc;\n\n//statistic_increment(ha_read_key_count, &LOCK_status);\n\n  switch (CntIndexRead(xp->g, tdbp, op, kr, mrr)) {\n    case RC_OK:\n      xp->fnd++;\n      rc= MakeRecord((char*)buf);\n      break;\n    case RC_EF:         // End of file\n      rc= HA_ERR_END_OF_FILE;\n      break;\n    case RC_NF:         // Not found\n      xp->nfd++;\n      rc= (op == OP_SAME) ? HA_ERR_END_OF_FILE : HA_ERR_KEY_NOT_FOUND;\n      break;\n    default:          // Read error\n      DBUG_PRINT(\"ReadIndexed\", (\"%s\", xp->g->Message));\n      htrc(\"ReadIndexed: %s\\n\", xp->g->Message);\n      rc= HA_ERR_INTERNAL_ERROR;\n      break;\n    } // endswitch RC\n\n  if (trace(2))\n    htrc(\"ReadIndexed: op=%d rc=%d\\n\", op, rc);\n\n  table->status= (rc == RC_OK) ? 0 : STATUS_NOT_FOUND;\n  return rc;\n} // end of ReadIndexed\n\n\n#ifdef NOT_USED\n/**\n  @brief\n  Positions an index cursor to the index specified in the handle. Fetches the\n  row if available. If the key value is null, begin at the first key of the\n  index.\n*/\nint ha_connect::index_read_map(uchar *buf, const uchar *key,\n                               key_part_map keypart_map __attribute__((unused)),\n                               enum ha_rkey_function find_flag\n                               __attribute__((unused)))\n{\n  DBUG_ENTER(\"ha_connect::index_read\");\n  DBUG_RETURN(HA_ERR_WRONG_COMMAND);\n}\n#endif // NOT_USED\n\n\n/****************************************************************************/\n/*  This is called by handler::index_read_map.                              */\n/****************************************************************************/\nint ha_connect::index_read(uchar * buf, const uchar * key, uint key_len,\n                           enum ha_rkey_function find_flag)\n{\n  int rc;\n  OPVAL op= OP_XX;\n  DBUG_ENTER(\"ha_connect::index_read\");\n\n  switch(find_flag) {\n    case HA_READ_KEY_EXACT:   op= OP_EQ; break;\n    case HA_READ_AFTER_KEY:   op= OP_GT; break;\n    case HA_READ_KEY_OR_NEXT: op= OP_GE; break;\n    default: DBUG_RETURN(-1);      break;\n    } // endswitch find_flag\n\n  if (trace(2))\n    htrc(\"%p index_read: op=%d\\n\", this, op);\n\n  if (indexing > 0) {\n\t\tstart_key.key= key;\n\t\tstart_key.length= key_len;\n\t\tstart_key.flag= find_flag;\n\t\tstart_key.keypart_map= 0;\n\n    rc= ReadIndexed(buf, op, &start_key);\n\n    if (rc == HA_ERR_INTERNAL_ERROR) {\n      nox= true;                  // To block making indexes\n      abort= true;                // Don't rename temp file\n      } // endif rc\n\n  } else\n    rc= HA_ERR_INTERNAL_ERROR;  // HA_ERR_KEY_NOT_FOUND ?\n\n  DBUG_RETURN(rc);\n} // end of index_read\n\n\n/**\n  @brief\n  Used to read forward through the index.\n*/\nint ha_connect::index_next(uchar *buf)\n{\n  int rc;\n  DBUG_ENTER(\"ha_connect::index_next\");\n  //statistic_increment(ha_read_next_count, &LOCK_status);\n\n  if (indexing > 0)\n    rc= ReadIndexed(buf, OP_NEXT);\n  else if (!indexing)\n    rc= rnd_next(buf);\n  else\n    rc= HA_ERR_INTERNAL_ERROR;\n\n  DBUG_RETURN(rc);\n} // end of index_next\n\n\n/**\n  @brief\n  Used to read backwards through the index.\n*/\nint ha_connect::index_prev(uchar *buf)\n{\n  DBUG_ENTER(\"ha_connect::index_prev\");\n  int rc;\n\n  if (indexing > 0) {\n    rc= ReadIndexed(buf, OP_PREV);\n  } else\n    rc= HA_ERR_WRONG_COMMAND;\n\n  DBUG_RETURN(rc);\n} // end of index_prev\n\n\n/**\n  @brief\n  index_first() asks for the first key in the index.\n\n    @details\n  Called from opt_range.cc, opt_sum.cc, sql_handler.cc, and sql_select.cc.\n\n    @see\n  opt_range.cc, opt_sum.cc, sql_handler.cc and sql_select.cc\n*/\nint ha_connect::index_first(uchar *buf)\n{\n  int rc;\n  DBUG_ENTER(\"ha_connect::index_first\");\n\n  if (indexing > 0)\n    rc= ReadIndexed(buf, OP_FIRST);\n  else if (indexing < 0)\n    rc= HA_ERR_INTERNAL_ERROR;\n  else if (CntRewindTable(xp->g, tdbp)) {\n    table->status= STATUS_NOT_FOUND;\n    rc= HA_ERR_INTERNAL_ERROR;\n  } else\n    rc= rnd_next(buf);\n\n  DBUG_RETURN(rc);\n} // end of index_first\n\n\n/**\n  @brief\n  index_last() asks for the last key in the index.\n\n    @details\n  Called from opt_range.cc, opt_sum.cc, sql_handler.cc, and sql_select.cc.\n\n    @see\n  opt_range.cc, opt_sum.cc, sql_handler.cc and sql_select.cc\n*/\nint ha_connect::index_last(uchar *buf)\n{\n  DBUG_ENTER(\"ha_connect::index_last\");\n  int rc;\n\n  if (indexing <= 0) {\n    rc= HA_ERR_INTERNAL_ERROR;\n  } else\n    rc= ReadIndexed(buf, OP_LAST);\n\n  DBUG_RETURN(rc);\n}\n\n\n/****************************************************************************/\n/*  This is called to get more rows having the same index value.            */\n/****************************************************************************/\n//t ha_connect::index_next_same(uchar *buf, const uchar *key, uint keylen)\nint ha_connect::index_next_same(uchar *buf, const uchar *, uint)\n{\n  int rc;\n  DBUG_ENTER(\"ha_connect::index_next_same\");\n//statistic_increment(ha_read_next_count, &LOCK_status);\n\n  if (!indexing)\n    rc= rnd_next(buf);\n  else if (indexing > 0)\n    rc= ReadIndexed(buf, OP_SAME);\n  else\n    rc= HA_ERR_INTERNAL_ERROR;\n\n  DBUG_RETURN(rc);\n} // end of index_next_same\n\n\n/**\n  @brief\n  rnd_init() is called when the system wants the storage engine to do a table\n  scan. See the example in the introduction at the top of this file to see when\n  rnd_init() is called.\n\n    @details\n  Called from filesort.cc, records.cc, sql_handler.cc, sql_select.cc, sql_table.cc,\n  and sql_update.cc.\n\n    @note\n  We always call open and extern_lock/start_stmt before comming here.\n\n    @see\n  filesort.cc, records.cc, sql_handler.cc, sql_select.cc, sql_table.cc and sql_update.cc\n*/\nint ha_connect::rnd_init(bool scan)\n{\n  PGLOBAL g= ((table && table->in_use) ? GetPlug(table->in_use, xp) :\n              (xp) ? xp->g : NULL);\n  DBUG_ENTER(\"ha_connect::rnd_init\");\n\n  // This is not tested yet\n  if (xmod == MODE_ALTER) {\n    xmod= MODE_READ;\n    alter= 1;\n    } // endif xmod\n\n  if (trace(1))\n    htrc(\"rnd_init: this=%p scan=%d xmod=%d alter=%d\\n\",\n            this, scan, xmod, alter);\n\n  if (!g || !table || xmod == MODE_INSERT)\n    DBUG_RETURN(HA_ERR_INITIALIZATION);\n\n  // Do not close the table if it was opened yet (locked?)\n  if (IsOpened()) {\n    if (IsPartitioned() && xmod != MODE_INSERT)\n      if (CheckColumnList(g)) // map can have been changed\n        DBUG_RETURN(HA_ERR_INTERNAL_ERROR);\n\n    if (tdbp->OpenDB(g))      // Rewind table\n      DBUG_RETURN(HA_ERR_INTERNAL_ERROR);\n    else\n      DBUG_RETURN(0);\n\n  } else if (xp->CheckQuery(valid_query_id))\n    tdbp= NULL;       // Not valid anymore\n\n  // When updating, to avoid skipped update, force the table\n  // handler to retrieve write-only fields to be able to compare\n  // records and detect data change.\n  if (xmod == MODE_UPDATE)\n    bitmap_union(table->read_set, table->write_set);\n\n  if (OpenTable(g, xmod == MODE_DELETE))\n    DBUG_RETURN(HA_ERR_INITIALIZATION);\n\n  xp->nrd= xp->fnd= xp->nfd= 0;\n  xp->tb1= my_interval_timer();\n  DBUG_RETURN(0);\n} // end of rnd_init\n\n/**\n  @brief\n  Not described.\n\n  @note\n  The previous version said:\n  Stop scanning of table. Note that this may be called several times during\n  execution of a sub select.\n  =====> This has been moved to external lock to avoid closing subselect tables.\n*/\nint ha_connect::rnd_end()\n{\n  int rc= 0;\n  DBUG_ENTER(\"ha_connect::rnd_end\");\n\n  // If this is called by a later query, the table may have\n  // been already closed and the tdbp is not valid anymore.\n//  if (tdbp && xp->last_query_id == valid_query_id)\n//    rc= CloseTable(xp->g);\n\n  ds_mrr.dsmrr_close();\n  DBUG_RETURN(rc);\n} // end of rnd_end\n\n\n/**\n  @brief\n  This is called for each row of the table scan. When you run out of records\n  you should return HA_ERR_END_OF_FILE. Fill buff up with the row information.\n  The Field structure for the table is the key to getting data into buf\n  in a manner that will allow the server to understand it.\n\n    @details\n  Called from filesort.cc, records.cc, sql_handler.cc, sql_select.cc, sql_table.cc,\n  and sql_update.cc.\n\n    @see\n  filesort.cc, records.cc, sql_handler.cc, sql_select.cc, sql_table.cc and sql_update.cc\n*/\nint ha_connect::rnd_next(uchar *buf)\n{\n  int rc;\n  DBUG_ENTER(\"ha_connect::rnd_next\");\n//statistic_increment(ha_read_rnd_next_count, &LOCK_status);\n\n  if (tdbp->GetMode() == MODE_ANY) {\n    // We will stop on next read\n    if (!stop) {\n      stop= true;\n      DBUG_RETURN(RC_OK);\n    } else\n      DBUG_RETURN(HA_ERR_END_OF_FILE);\n\n    } // endif Mode\n\n  switch (CntReadNext(xp->g, tdbp)) {\n    case RC_OK:\n      rc= MakeRecord((char*)buf);\n      break;\n    case RC_EF:         // End of file\n      rc= HA_ERR_END_OF_FILE;\n      break;\n    case RC_NF:         // Not found\n      rc= HA_ERR_RECORD_DELETED;\n      break;\n    default:            // Read error\n      htrc(\"rnd_next CONNECT: %s\\n\", xp->g->Message);\n      rc= (records()) ? HA_ERR_INTERNAL_ERROR : HA_ERR_END_OF_FILE;\n      break;\n    } // endswitch RC\n\n  if (trace(2) && (rc || !(xp->nrd++ % 16384))) {\n    ulonglong tb2= my_interval_timer();\n    double elapsed= (double) (tb2 - xp->tb1) / 1000000000ULL;\n    DBUG_PRINT(\"rnd_next\", (\"rc=%d nrd=%u fnd=%u nfd=%u sec=%.3lf\\n\",\n                             rc, (uint)xp->nrd, (uint)xp->fnd,\n                             (uint)xp->nfd, elapsed));\n    htrc(\"rnd_next: rc=%d nrd=%u fnd=%u nfd=%u sec=%.3lf\\n\",\n                             rc, (uint)xp->nrd, (uint)xp->fnd,\n                             (uint)xp->nfd, elapsed);\n    xp->tb1= tb2;\n    xp->fnd= xp->nfd= 0;\n    } // endif nrd\n\n  table->status= (!rc) ? 0 : STATUS_NOT_FOUND;\n  DBUG_RETURN(rc);\n} // end of rnd_next\n\n\n/**\n  @brief\n  position() is called after each call to rnd_next() if the data needs\n  to be ordered. You can do something like the following to store\n  the position:\n    @code\n  my_store_ptr(ref, ref_length, current_position);\n    @endcode\n\n    @details\n  The server uses ref to store data. ref_length in the above case is\n  the size needed to store current_position. ref is just a byte array\n  that the server will maintain. If you are using offsets to mark rows, then\n  current_position should be the offset. If it is a primary key like in\n  BDB, then it needs to be a primary key.\n\n  Called from filesort.cc, sql_select.cc, sql_delete.cc, and sql_update.cc.\n\n    @see\n  filesort.cc, sql_select.cc, sql_delete.cc and sql_update.cc\n*/\nvoid ha_connect::position(const uchar *)\n{\n  DBUG_ENTER(\"ha_connect::position\");\n  my_store_ptr(ref, ref_length, (my_off_t)tdbp->GetRecpos());\n\n  if (trace(2))\n    htrc(\"position: pos=%d\\n\", tdbp->GetRecpos());\n\n  DBUG_VOID_RETURN;\n} // end of position\n\n\n/**\n  @brief\n  This is like rnd_next, but you are given a position to use\n  to determine the row. The position will be of the type that you stored in\n  ref. You can use my_get_ptr(pos,ref_length) to retrieve whatever key\n  or position you saved when position() was called.\n\n    @details\n  Called from filesort.cc, records.cc, sql_insert.cc, sql_select.cc, and sql_update.cc.\n\n    @note\n  Is this really useful? It was never called even when sorting.\n\n    @see\n  filesort.cc, records.cc, sql_insert.cc, sql_select.cc and sql_update.cc\n*/\nint ha_connect::rnd_pos(uchar *buf, uchar *pos)\n{\n  int     rc;\n//PTDBASE tp= (PTDBASE)tdbp;\n  DBUG_ENTER(\"ha_connect::rnd_pos\");\n\n  if (!tdbp->SetRecpos(xp->g, (int)my_get_ptr(pos, ref_length))) {\n    if (trace(1))\n      htrc(\"rnd_pos: %d\\n\", tdbp->GetRecpos());\n\n    tdbp->SetFilter(NULL);\n    rc= rnd_next(buf);\n\t} else {\n\t\tPGLOBAL g= GetPlug((table) ? table->in_use : NULL, xp);\n//\tstrcpy(g->Message, \"Not supported by this table type\");\n\t\tmy_message(ER_ILLEGAL_HA, g->Message, MYF(0));\n\t\trc= HA_ERR_INTERNAL_ERROR;\n\t}\t// endif SetRecpos\n\n  DBUG_RETURN(rc);\n} // end of rnd_pos\n\n\n/**\n  @brief\n  ::info() is used to return information to the optimizer. See my_base.h for\n  the complete description.\n\n    @details\n  Currently this table handler doesn't implement most of the fields really needed.\n  SHOW also makes use of this data.\n\n  You will probably want to have the following in your code:\n    @code\n  if (records < 2)\n    records= 2;\n    @endcode\n  The reason is that the server will optimize for cases of only a single\n  record. If, in a table scan, you don't know the number of records, it\n  will probably be better to set records to two so you can return as many\n  records as you need. Along with records, a few more variables you may wish\n  to set are:\n    records\n    deleted\n    data_file_length\n    index_file_length\n    delete_length\n    check_time\n  Take a look at the public variables in handler.h for more information.\n\n  Called in filesort.cc, ha_heap.cc, item_sum.cc, opt_sum.cc, sql_delete.cc,\n  sql_delete.cc, sql_derived.cc, sql_select.cc, sql_select.cc, sql_select.cc,\n  sql_select.cc, sql_select.cc, sql_show.cc, sql_show.cc, sql_show.cc, sql_show.cc,\n  sql_table.cc, sql_union.cc, and sql_update.cc.\n\n    @see\n  filesort.cc, ha_heap.cc, item_sum.cc, opt_sum.cc, sql_delete.cc, sql_delete.cc,\n  sql_derived.cc, sql_select.cc, sql_select.cc, sql_select.cc, sql_select.cc,\n  sql_select.cc, sql_show.cc, sql_show.cc, sql_show.cc, sql_show.cc, sql_table.cc,\n  sql_union.cc and sql_update.cc\n*/\nint ha_connect::info(uint flag)\n{\n  bool    pure= false;\n  PGLOBAL g= GetPlug((table) ? table->in_use : NULL, xp);\n\n  DBUG_ENTER(\"ha_connect::info\");\n\n\tif (!g) {\n\t\tmy_message(ER_UNKNOWN_ERROR, \"Cannot get g pointer\", MYF(0));\n\t\tDBUG_RETURN(HA_ERR_INTERNAL_ERROR);\n\t}\t// endif g\n\n\tif (trace(1))\n    htrc(\"%p In info: flag=%u valid_info=%d\\n\", this, flag, valid_info);\n\n  // tdbp must be available to get updated info\n  if (xp->CheckQuery(valid_query_id) || !tdbp) {\n\n    if (xmod == MODE_ANY || xmod == MODE_ALTER) {\n      // Pure info, not a query\n      pure= true;\n      xp->CheckCleanup(xmod == MODE_ANY && valid_query_id == 0);\n      } // endif xmod\n\n    // This is necessary for getting file length\n\t\tif (table) {\n\t\t\tif (SetDataPath(g, table->s->db.str)) {\n\t\t\t\tmy_message(ER_UNKNOWN_ERROR, g->Message, MYF(0));\n\t\t\t\tDBUG_RETURN(HA_ERR_INTERNAL_ERROR);\n\t\t\t}\t// endif SetDataPath\n\n\t\t} else\n      DBUG_RETURN(HA_ERR_INTERNAL_ERROR);       // Should never happen\n\n\t\tif (!(tdbp= GetTDB(g))) {\n\t\t\tmy_message(ER_UNKNOWN_ERROR, g->Message, MYF(0));\n\t\t\tDBUG_RETURN(HA_ERR_INTERNAL_ERROR);\n\t\t} // endif tdbp\n\n    valid_info= false;\n    } // endif tdbp\n\n  if (!valid_info) {\n    valid_info= CntInfo(g, tdbp, &xinfo);\n\n    if (((signed)xinfo.records) < 0)\n      DBUG_RETURN(HA_ERR_INITIALIZATION);  // Error in Cardinality\n\n    } // endif valid_info\n\n  if (flag & HA_STATUS_VARIABLE) {\n    stats.records= xinfo.records;\n    stats.deleted= 0;\n    stats.data_file_length= xinfo.data_file_length;\n    stats.index_file_length= 0;\n    stats.delete_length= 0;\n    stats.check_time= 0;\n    stats.mean_rec_length= xinfo.mean_rec_length;\n    } // endif HA_STATUS_VARIABLE\n\n  if (flag & HA_STATUS_CONST) {\n    // This is imported from the previous handler and must be reconsidered\n    stats.max_data_file_length= 4294967295LL;\n    stats.max_index_file_length= 4398046510080LL;\n    stats.create_time= 0;\n    data_file_name= xinfo.data_file_name;\n    index_file_name= NULL;\n//  sortkey= (uint) - 1;           // Table is not sorted\n    ref_length= sizeof(int);      // Pointer size to row\n    table->s->db_options_in_use= 03;\n    stats.block_size= 1024;\n    table->s->keys_in_use.set_prefix(table->s->keys);\n    table->s->keys_for_keyread= table->s->keys_in_use;\n//  table->s->keys_for_keyread.subtract(table->s->read_only_keys);\n    table->s->db_record_offset= 0;\n    } // endif HA_STATUS_CONST\n\n  if (flag & HA_STATUS_ERRKEY) {\n    errkey= 0;\n    } // endif HA_STATUS_ERRKEY\n\n  if (flag & HA_STATUS_TIME)\n    stats.update_time= 0;\n\n  if (flag & HA_STATUS_AUTO)\n    stats.auto_increment_value= 1;\n\n  if (tdbp && pure)\n    CloseTable(g);        // Not used anymore\n\n  DBUG_RETURN(0);\n} // end of info\n\n\n/**\n  @brief\n  extra() is called whenever the server wishes to send a hint to\n  the storage engine. The myisam engine implements the most hints.\n  ha_innodb.cc has the most exhaustive list of these hints.\n\n  @note\n  This is not yet implemented for CONNECT.\n\n  @see\n  ha_innodb.cc\n*/\nint ha_connect::extra(enum ha_extra_function /*operation*/)\n{\n  DBUG_ENTER(\"ha_connect::extra\");\n  DBUG_RETURN(0);\n} // end of extra\n\n\n/**\n  @brief\n  Used to delete all rows in a table, including cases of truncate and cases where\n  the optimizer realizes that all rows will be removed as a result of an SQL statement.\n\n    @details\n  Called from item_sum.cc by Item_func_group_concat::clear(),\n  Item_sum_count_distinct::clear(), and Item_func_group_concat::clear().\n  Called from sql_delete.cc by mysql_delete().\n  Called from sql_select.cc by JOIN::reinit().\n  Called from sql_union.cc by st_select_lex_unit::exec().\n\n    @see\n  Item_func_group_concat::clear(), Item_sum_count_distinct::clear() and\n  Item_func_group_concat::clear() in item_sum.cc;\n  mysql_delete() in sql_delete.cc;\n  JOIN::reinit() in sql_select.cc and\n  st_select_lex_unit::exec() in sql_union.cc.\n*/\nint ha_connect::delete_all_rows()\n{\n  int     rc= 0;\n  PGLOBAL g= xp->g;\n  DBUG_ENTER(\"ha_connect::delete_all_rows\");\n\n  if (tdbp && tdbp->GetUse() == USE_OPEN &&\n      tdbp->GetAmType() != TYPE_AM_XML &&\n      tdbp->GetFtype() != RECFM_NAF)\n    // Close and reopen the table so it will be deleted\n    rc= CloseTable(g);\n\n  if (!(rc= OpenTable(g))) {\n    if (CntDeleteRow(g, tdbp, true)) {\n      htrc(\"%s\\n\", g->Message);\n      rc= HA_ERR_INTERNAL_ERROR;\n    } else\n      nox= false;\n\n    } // endif rc\n\n  DBUG_RETURN(rc);\n} // end of delete_all_rows\n\n\nbool ha_connect::check_privileges(THD *thd, PTOS options, const char *dbn, bool quick)\n{\n  const char *db= (dbn && *dbn) ? dbn : NULL;\n  TABTYPE     type=GetRealType(options);\n\n  switch (type) {\n    case TAB_UNDEF:\n//  case TAB_CATLG:\n    case TAB_PLG:\n    case TAB_JCT:\n    case TAB_DMY:\n    case TAB_NIY:\n      my_printf_error(ER_UNKNOWN_ERROR,\n                      \"Unsupported table type %s\", MYF(0), options->type);\n      return true;\n\n    case TAB_DOS:\n    case TAB_FIX:\n    case TAB_BIN:\n    case TAB_CSV:\n    case TAB_FMT:\n    case TAB_DBF:\n    case TAB_XML:\n    case TAB_INI:\n    case TAB_VEC:\n\t\tcase TAB_REST:\n    case TAB_JSON:\n\t\t\tif (options->filename && *options->filename) {\n\t\t\t\tif (!quick) {\n\t\t\t\t\tchar path[FN_REFLEN], dbpath[FN_REFLEN];\n\n \t\t\t\t\tstrcpy(dbpath, mysql_real_data_home);\n\n\t\t\t\t\tif (db)\n#if defined(__WIN__)\n\t\t\t\t\t\tstrcat(strcat(dbpath, db), \"\\\\\");\n#else   // !__WIN__\n\t\t\t\t\t\tstrcat(strcat(dbpath, db), \"/\");\n#endif  // !__WIN__\n\n\t\t\t\t\t(void)fn_format(path, options->filename, dbpath, \"\",\n\t\t\t\t\t\tMY_RELATIVE_PATH | MY_UNPACK_FILENAME);\n\n\t\t\t\t\tif (!is_secure_file_path(path)) {\n\t\t\t\t\t\tmy_error(ER_OPTION_PREVENTS_STATEMENT, MYF(0), \"--secure-file-priv\");\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t} // endif path\n\n\t\t\t\t}\t// endif !quick\n\n\t\t\t} else\n        return false;\n\n\t\t\t// Fall through\n\t\tcase TAB_MYSQL:\n\t\tcase TAB_DIR:\n\t\tcase TAB_ZIP:\n\t\tcase TAB_OEM:\n      if (table && table->pos_in_table_list) // if SELECT\n      {\n#if MYSQL_VERSION_ID > 100200\n\t\t\t\tSwitch_to_definer_security_ctx backup_ctx(thd, table->pos_in_table_list);\n#endif // VERSION_ID > 100200\n        return check_global_access(thd, FILE_ACL);\n      }\n      else\n        return check_global_access(thd, FILE_ACL);\n    case TAB_ODBC:\n\t\tcase TAB_JDBC:\n\t\tcase TAB_MONGO:\n    case TAB_MAC:\n    case TAB_WMI:\n\t\t\treturn false;\n    case TAB_TBL:\n    case TAB_XCL:\n    case TAB_PRX:\n    case TAB_OCCUR:\n    case TAB_PIVOT:\n    case TAB_VIR:\n\t\t\t// This is temporary until a solution is found\n\t\t\treturn false;\n    } // endswitch type\n\n  my_printf_error(ER_UNKNOWN_ERROR, \"check_privileges failed\", MYF(0));\n  return true;\n} // end of check_privileges\n\n// Check that two indexes are equivalent\nbool ha_connect::IsSameIndex(PIXDEF xp1, PIXDEF xp2)\n{\n  bool   b= true;\n  PKPDEF kp1, kp2;\n\n  if (stricmp(xp1->Name, xp2->Name))\n    b= false;\n  else if (xp1->Nparts  != xp2->Nparts  ||\n           xp1->MaxSame != xp2->MaxSame ||\n           xp1->Unique  != xp2->Unique)\n    b= false;\n  else for (kp1= xp1->ToKeyParts, kp2= xp2->ToKeyParts;\n            b && (kp1 || kp2);\n            kp1= kp1->Next, kp2= kp2->Next)\n    if (!kp1 || !kp2)\n      b= false;\n    else if (stricmp(kp1->Name, kp2->Name))\n      b= false;\n    else if (kp1->Klen != kp2->Klen)\n      b= false;\n\n  return b;\n} // end of IsSameIndex\n\nMODE ha_connect::CheckMode(PGLOBAL g, THD *thd, \n\t                         MODE newmode, bool *chk, bool *cras)\n{\n#if defined(DEVELOPMENT)\n\tif (true) {\n#else\n  if (trace(65)) {\n#endif\n    LEX_STRING *query_string= thd_query_string(thd);\n    htrc(\"%p check_mode: cmdtype=%d\\n\", this, thd_sql_command(thd));\n    htrc(\"Cmd=%.*s\\n\", (int) query_string->length, query_string->str);\n    } // endif trace\n\n  // Next code is temporarily replaced until sql_command is set\n  stop= false;\n\n  if (newmode == MODE_WRITE) {\n    switch (thd_sql_command(thd)) {\n      case SQLCOM_LOCK_TABLES:\n        locked= 2; // fall through\n      case SQLCOM_CREATE_TABLE:\n      case SQLCOM_INSERT:\n      case SQLCOM_LOAD:\n      case SQLCOM_INSERT_SELECT:\n        newmode= MODE_INSERT;\n        break;\n//    case SQLCOM_REPLACE:\n//    case SQLCOM_REPLACE_SELECT:\n//      newmode= MODE_UPDATE;               // To be checked\n//      break;\n\t\t\tcase SQLCOM_DELETE_MULTI:\n\t\t\t\t*cras= true;\n                                // fall through\n\t\t\tcase SQLCOM_DELETE:\n      case SQLCOM_TRUNCATE:\n        newmode= MODE_DELETE;\n        break;\n      case SQLCOM_UPDATE_MULTI:\n\t\t\t\t*cras= true;\n                                // fall through\n\t\t\tcase SQLCOM_UPDATE:\n\t\t\t\tnewmode= MODE_UPDATE;\n        break;\n      case SQLCOM_SELECT:\n      case SQLCOM_OPTIMIZE:\n        newmode= MODE_READ;\n        break;\n      case SQLCOM_FLUSH:\n        locked= 0;\n        // fall through\n      case SQLCOM_DROP_TABLE:\n      case SQLCOM_RENAME_TABLE:\n        newmode= MODE_ANY;\n        break;\n      case SQLCOM_CREATE_VIEW:\n      case SQLCOM_DROP_VIEW:\n        newmode= MODE_ANY;\n        break;\n      case SQLCOM_ALTER_TABLE:\n        newmode= MODE_ALTER;\n        break;\n      case SQLCOM_DROP_INDEX:\n      case SQLCOM_CREATE_INDEX:\n//      if (!IsPartitioned()) {\n          newmode= MODE_ANY;\n          break;\n//        } // endif partitioned\n\t\t\tcase SQLCOM_REPAIR: // TODO implement it\n\t\t\t\tnewmode= MODE_UPDATE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n        htrc(\"Unsupported sql_command=%d\\n\", thd_sql_command(thd));\n        strcpy(g->Message, \"CONNECT Unsupported command\");\n        my_message(ER_NOT_ALLOWED_COMMAND, g->Message, MYF(0));\n        newmode= MODE_ERROR;\n        break;\n      } // endswitch newmode\n\n  } else if (newmode == MODE_READ) {\n    switch (thd_sql_command(thd)) {\n      case SQLCOM_CREATE_TABLE:\n        *chk= true;\n\t\t\t\tbreak;\n\t\t\tcase SQLCOM_UPDATE_MULTI:\n\t\t\tcase SQLCOM_DELETE_MULTI:\n\t\t\t\t*cras= true;\n      case SQLCOM_INSERT:\n      case SQLCOM_LOAD:\n      case SQLCOM_INSERT_SELECT:\n//    case SQLCOM_REPLACE:\n//    case SQLCOM_REPLACE_SELECT:\n      case SQLCOM_DELETE:\n      case SQLCOM_TRUNCATE:\n      case SQLCOM_UPDATE:\n      case SQLCOM_SELECT:\n      case SQLCOM_OPTIMIZE:\n      case SQLCOM_SET_OPTION:\n        break;\n      case SQLCOM_LOCK_TABLES:\n        locked= 1;\n        break;\n      case SQLCOM_DROP_TABLE:\n      case SQLCOM_RENAME_TABLE:\n        newmode= MODE_ANY;\n        break;\n      case SQLCOM_CREATE_VIEW:\n      case SQLCOM_DROP_VIEW:\n\t\t\tcase SQLCOM_CREATE_TRIGGER:\n\t\t\tcase SQLCOM_DROP_TRIGGER:\n\t\t\t\tnewmode= MODE_ANY;\n        break;\n      case SQLCOM_ALTER_TABLE:\n        *chk= true;\n        newmode= MODE_ALTER;\n        break;\n      case SQLCOM_DROP_INDEX:\n      case SQLCOM_CREATE_INDEX:\n//      if (!IsPartitioned()) {\n          *chk= true;\n          newmode= MODE_ANY;\n          break;\n//        } // endif partitioned\n\n\t\t\tcase SQLCOM_CHECK:   // TODO implement it\n\t\t\tcase SQLCOM_ANALYZE: // TODO implement it\n\t\t\tcase SQLCOM_END:\t   // Met in procedures: IF(EXISTS(SELECT...\n\t\t\t\tnewmode= MODE_READ;\n        break;\n      default:\n        htrc(\"Unsupported sql_command=%d\\n\", thd_sql_command(thd));\n        strcpy(g->Message, \"CONNECT Unsupported command\");\n        my_message(ER_NOT_ALLOWED_COMMAND, g->Message, MYF(0));\n        newmode= MODE_ERROR;\n        break;\n      } // endswitch newmode\n\n  } // endif's newmode\n\n  if (trace(1))\n    htrc(\"New mode=%d\\n\", newmode);\n\n  return newmode;\n} // end of check_mode\n\nint ha_connect::start_stmt(THD *thd, thr_lock_type lock_type)\n{\n  int     rc= 0;\n  bool    chk=false, cras= false;\n  MODE    newmode;\n  PGLOBAL g= GetPlug(thd, xp);\n  DBUG_ENTER(\"ha_connect::start_stmt\");\n\n  if (check_privileges(thd, GetTableOptionStruct(), table->s->db.str, true))\n    DBUG_RETURN(HA_ERR_INTERNAL_ERROR);\n\n  // Action will depend on lock_type\n  switch (lock_type) {\n    case TL_WRITE_ALLOW_WRITE:\n    case TL_WRITE_CONCURRENT_INSERT:\n    case TL_WRITE_DELAYED:\n    case TL_WRITE_DEFAULT:\n    case TL_WRITE_LOW_PRIORITY:\n    case TL_WRITE:\n    case TL_WRITE_ONLY:\n      newmode= MODE_WRITE;\n      break;\n    case TL_READ:\n    case TL_READ_WITH_SHARED_LOCKS:\n    case TL_READ_HIGH_PRIORITY:\n    case TL_READ_NO_INSERT:\n    case TL_READ_DEFAULT:\n      newmode= MODE_READ;\n      break;\n    case TL_UNLOCK:\n    default:\n      newmode= MODE_ANY;\n      break;\n    } // endswitch mode\n\n\tif (newmode == MODE_ANY) {\n\t\tif (CloseTable(g)) {\n\t\t\t// Make error a warning to avoid crash\n\t\t\tpush_warning(thd, Sql_condition::WARN_LEVEL_WARN, 0, g->Message);\n\t\t\trc= 0;\n\t\t} // endif Close\n\n\t\tlocked= 0;\n\t\txmod= MODE_ANY;              // For info commands\n\t\tDBUG_RETURN(rc);\n\t} // endif MODE_ANY\n\n\tnewmode= CheckMode(g, thd, newmode, &chk, &cras);\n\n\tif (newmode == MODE_ERROR)\n\t\tDBUG_RETURN(HA_ERR_INTERNAL_ERROR);\n\n\tDBUG_RETURN(check_stmt(g, newmode, cras));\n} // end of start_stmt\n\n/**\n  @brief\n  This create a lock on the table. If you are implementing a storage engine\n  that can handle transacations look at ha_berkely.cc to see how you will\n  want to go about doing this. Otherwise you should consider calling flock()\n  here. Hint: Read the section \"locking functions for mysql\" in lock.cc to understand\n  this.\n\n    @details\n  Called from lock.cc by lock_external() and unlock_external(). Also called\n  from sql_table.cc by copy_data_between_tables().\n\n    @note\n  Following what we did in the MySQL XDB handler, we use this call to actually\n  physically open the table. This could be reconsider when finalizing this handler\n  design, which means we have a better understanding of what MariaDB does.\n\n    @see\n  lock.cc by lock_external() and unlock_external() in lock.cc;\n  the section \"locking functions for mysql\" in lock.cc;\n  copy_data_between_tables() in sql_table.cc.\n*/\nint ha_connect::external_lock(THD *thd, int lock_type)\n{\n  int     rc= 0;\n  bool    xcheck=false, cras= false;\n  MODE    newmode;\n  PTOS    options= GetTableOptionStruct();\n  PGLOBAL g= GetPlug(thd, xp);\n  DBUG_ENTER(\"ha_connect::external_lock\");\n\n  DBUG_ASSERT(thd == current_thd);\n\n  if (trace(1))\n    htrc(\"external_lock: this=%p thd=%p xp=%p g=%p lock_type=%d\\n\",\n            this, thd, xp, g, lock_type);\n\n  if (!g)\n    DBUG_RETURN(HA_ERR_INTERNAL_ERROR);\n\n  // Action will depend on lock_type\n  switch (lock_type) {\n    case F_WRLCK:\n      newmode= MODE_WRITE;\n      break;\n    case F_RDLCK:\n      newmode= MODE_READ;\n      break;\n    case F_UNLCK:\n    default:\n      newmode= MODE_ANY;\n      break;\n    } // endswitch mode\n\n  if (newmode == MODE_ANY) {\n    int sqlcom= thd_sql_command(thd);\n\n    // This is unlocking, do it by closing the table\n    if (xp->CheckQueryID() && sqlcom != SQLCOM_UNLOCK_TABLES\n                           && sqlcom != SQLCOM_LOCK_TABLES\n                           && sqlcom != SQLCOM_FLUSH\n                           && sqlcom != SQLCOM_BEGIN\n                           && sqlcom != SQLCOM_DROP_TABLE) {\n      sprintf(g->Message, \"external_lock: unexpected command %d\", sqlcom);\n      push_warning(thd, Sql_condition::WARN_LEVEL_WARN, 0, g->Message);\n      DBUG_RETURN(0);\n    } else if (g->Xchk) {\n      if (!tdbp) {\n\t\t\t\tif (!(tdbp= GetTDB(g))) {\n//        DBUG_RETURN(HA_ERR_INTERNAL_ERROR);  causes assert error\n\t\t\t\t\tpush_warning(thd, Sql_condition::WARN_LEVEL_WARN, 0, g->Message);\n\t\t\t\t\tDBUG_RETURN(0);\n\t\t\t\t} else if (!tdbp->GetDef()->Indexable()) {\n          sprintf(g->Message, \"external_lock: Table %s is not indexable\", tdbp->GetName());\n//        DBUG_RETURN(HA_ERR_INTERNAL_ERROR);  causes assert error\n          push_warning(thd, Sql_condition::WARN_LEVEL_WARN, 0, g->Message);\n          DBUG_RETURN(0);\n        } else if (tdbp->GetDef()->Indexable() == 1) {\n          bool    oldsep= ((PCHK)g->Xchk)->oldsep;\n          bool    newsep= ((PCHK)g->Xchk)->newsep;\n          PTDBDOS tdp= (PTDBDOS)tdbp;\n      \n          PDOSDEF ddp= (PDOSDEF)tdp->GetDef();\n          PIXDEF  xp, xp1, xp2, drp=NULL, adp= NULL;\n          PIXDEF  oldpix= ((PCHK)g->Xchk)->oldpix;\n          PIXDEF  newpix= ((PCHK)g->Xchk)->newpix;\n          PIXDEF *xlst, *xprc; \n      \n          ddp->SetIndx(oldpix);\n      \n          if (oldsep != newsep) {\n            // All indexes have to be remade\n            ddp->DeleteIndexFile(g, NULL);\n            oldpix= NULL;\n            ddp->SetIndx(NULL);\n            SetBooleanOption(\"Sepindex\", newsep);\n          } else if (newsep) {\n            // Make the list of dropped indexes\n            xlst= &drp; xprc= &oldpix;\n      \n            for (xp2= oldpix; xp2; xp2= xp) {\n              for (xp1= newpix; xp1; xp1= xp1->Next)\n                if (IsSameIndex(xp1, xp2))\n                  break;        // Index not to drop\n      \n              xp= xp2->GetNext();\n      \n              if (!xp1) {\n                *xlst= xp2;\n                *xprc= xp;\n                *(xlst= &xp2->Next)= NULL;\n              } else\n                xprc= &xp2->Next;\n      \n              } // endfor xp2\n      \n            if (drp) {\n              // Here we erase the index files\n              ddp->DeleteIndexFile(g, drp);\n              } // endif xp1\n      \n          } else if (oldpix) {\n            // TODO: optimize the case of just adding new indexes\n            if (!newpix)\n              ddp->DeleteIndexFile(g, NULL);\n      \n            oldpix= NULL;     // To remake all indexes\n            ddp->SetIndx(NULL);\n          } // endif sepindex\n      \n          // Make the list of new created indexes\n          xlst= &adp; xprc= &newpix;\n      \n          for (xp1= newpix; xp1; xp1= xp) {\n            for (xp2= oldpix; xp2; xp2= xp2->Next)\n              if (IsSameIndex(xp1, xp2))\n                break;        // Index already made\n      \n            xp= xp1->Next;\n      \n            if (!xp2) {\n              *xlst= xp1;\n              *xprc= xp;\n              *(xlst= &xp1->Next)= NULL;\n            } else\n              xprc= &xp1->Next;\n      \n            } // endfor xp1\n      \n          if (adp)\n            // Here we do make the new indexes\n            if (tdp->MakeIndex(g, adp, true) == RC_FX) {\n              // Make it a warning to avoid crash\n              push_warning(thd, Sql_condition::WARN_LEVEL_WARN, \n                                0, g->Message);\n              rc= 0;\n\t\t\t\t\t\t\t//my_message(ER_UNKNOWN_ERROR, g->Message, MYF(0));\n\t\t\t\t\t\t\t//rc= HA_ERR_INTERNAL_ERROR;\n\t\t\t\t\t\t} // endif MakeIndex\n      \n        } else if (tdbp->GetDef()->Indexable() == 3) {\n          if (CheckVirtualIndex(NULL)) {\n            // Make it a warning to avoid crash\n            push_warning(thd, Sql_condition::WARN_LEVEL_WARN, \n                              0, g->Message);\n            rc= 0;\n            } // endif Check\n\n        } // endif indexable\n\n        } // endif Tdbp\n\n      } // endelse Xchk\n\n    if (CloseTable(g)) {\n      // This is an error while builing index\n      // Make it a warning to avoid crash\n      push_warning(thd, Sql_condition::WARN_LEVEL_WARN, 0, g->Message);\n      rc= 0;\n\t\t} // endif Close\n\n    locked= 0;\n    xmod= MODE_ANY;              // For info commands\n    DBUG_RETURN(rc);\n\t} else if (check_privileges(thd, options, table->s->db.str)) {\n\t\tstrcpy(g->Message, \"This operation requires the FILE privilege\");\n\t\thtrc(\"%s\\n\", g->Message);\n\t\tDBUG_RETURN(HA_ERR_INTERNAL_ERROR);\n\t} // endif check_privileges\n\n\n  DBUG_ASSERT(table && table->s);\n\n  // Table mode depends on the query type\n  newmode= CheckMode(g, thd, newmode, &xcheck, &cras);\n\n  if (newmode == MODE_ERROR)\n    DBUG_RETURN(HA_ERR_INTERNAL_ERROR);\n\n\tDBUG_RETURN(check_stmt(g, newmode, cras));\n} // end of external_lock\n\n\nint ha_connect::check_stmt(PGLOBAL g, MODE newmode, bool cras)\n{\n\tint rc= 0;\n\tDBUG_ENTER(\"ha_connect::check_stmt\");\n\n\t// If this is the start of a new query, cleanup the previous one\n  if (xp->CheckCleanup()) {\n    tdbp= NULL;\n    valid_info= false;\n\t} // endif CheckCleanup\n\n  if (cras)\n    g->Createas= 1;  // To tell external tables of a multi-table command\n\n\tif (trace(1))\n\t\thtrc(\"Calling CntCheckDB db=%s cras=%d\\n\", GetDBName(NULL), cras);\n\n  // Set or reset the good database environment\n  if (CntCheckDB(g, this, GetDBName(NULL))) {\n\t\thtrc(\"%p check_stmt: %s\\n\", this, g->Message);\n\t\trc= HA_ERR_INTERNAL_ERROR;\n  // This can NOT be called without open called first, but\n  // the table can have been closed since then\n  } else if (!tdbp || xp->CheckQuery(valid_query_id) || xmod != newmode) {\n    if (tdbp) {\n      // If this is called by a later query, the table may have\n      // been already closed and the tdbp is not valid anymore.\n      if (xp->last_query_id == valid_query_id)\n        rc= CloseTable(g);\n      else\n        tdbp= NULL;\n\n      } // endif tdbp\n\n    xmod= newmode;\n\n    // Delay open until used fields are known\n  } // endif tdbp\n\n  if (trace(1))\n\t\thtrc(\"check_stmt: rc=%d\\n\", rc);\n\n  DBUG_RETURN(rc);\n} // end of check_stmt\n\n\n/**\n  @brief\n  The idea with handler::store_lock() is: The statement decides which locks\n  should be needed for the table. For updates/deletes/inserts we get WRITE\n  locks, for SELECT... we get read locks.\n\n    @details\n  Before adding the lock into the table lock handler (see thr_lock.c),\n  mysqld calls store lock with the requested locks. Store lock can now\n  modify a write lock to a read lock (or some other lock), ignore the\n  lock (if we don't want to use MySQL table locks at all), or add locks\n  for many tables (like we do when we are using a MERGE handler).\n\n  Berkeley DB, for example, changes all WRITE locks to TL_WRITE_ALLOW_WRITE\n  (which signals that we are doing WRITES, but are still allowing other\n  readers and writers).\n\n  When releasing locks, store_lock() is also called. In this case one\n  usually doesn't have to do anything.\n\n  In some exceptional cases MySQL may send a request for a TL_IGNORE;\n  This means that we are requesting the same lock as last time and this\n  should also be ignored. (This may happen when someone does a flush\n  table when we have opened a part of the tables, in which case mysqld\n  closes and reopens the tables and tries to get the same locks at last\n  time). In the future we will probably try to remove this.\n\n  Called from lock.cc by get_lock_data().\n\n    @note\n  In this method one should NEVER rely on table->in_use, it may, in fact,\n  refer to a different thread! (this happens if get_lock_data() is called\n  from mysql_lock_abort_for_thread() function)\n\n    @see\n  get_lock_data() in lock.cc\n*/\nTHR_LOCK_DATA **ha_connect::store_lock(THD *,\n                                       THR_LOCK_DATA **to,\n                                       enum thr_lock_type lock_type)\n{\n  if (lock_type != TL_IGNORE && lock.type == TL_UNLOCK)\n    lock.type=lock_type;\n  *to++= &lock;\n  return to;\n}\n\n\n/**\n  Searches for a pointer to the last occurrence of  the\n  character c in the string src.\n  Returns true on failure, false on success.\n*/\nstatic bool\nstrnrchr(LEX_CSTRING *ls, const char *src, size_t length, int c)\n{\n  const char *srcend, *s;\n  for (s= srcend= src + length; s > src; s--)\n  {\n    if (s[-1] == c)\n    {\n      ls->str= s;\n      ls->length= srcend - s;\n      return false;\n    }\n  }\n  return true;\n}\n\n\n/**\n  Split filename into database and table name.\n*/\nstatic bool\nfilename_to_dbname_and_tablename(const char *filename,\n                                 char *database, size_t database_size,\n                                 char *table, size_t table_size)\n{\n  LEX_CSTRING d, t;\n  size_t length= strlen(filename);\n\n  /* Find filename - the rightmost directory part */\n  if (strnrchr(&t, filename, length, slash) || t.length + 1 > table_size)\n    return true;\n  memcpy(table, t.str, t.length);\n  table[t.length]= '\\0';\n  if (!(length-= t.length))\n    return true;\n\n  length--; /* Skip slash */\n\n  /* Find database name - the second rightmost directory part */\n  if (strnrchr(&d, filename, length, slash) || d.length + 1 > database_size)\n    return true;\n  memcpy(database, d.str, d.length);\n  database[d.length]= '\\0';\n  return false;\n} // end of filename_to_dbname_and_tablename\n\n/**\n  @brief\n  Used to delete or rename a table. By the time delete_table() has been\n  called all opened references to this table will have been closed\n  (and your globally shared references released) ===> too bad!!!\n  The variable name will just be the name of the table.\n  You will need to remove or rename any files you have created at\n  this point.\n\n    @details\n  If you do not implement this, the default delete_table() is called from\n  handler.cc and it will delete all files with the file extensions returned\n  by bas_ext().\n\n  Called from handler.cc by delete_table and ha_create_table(). Only used\n  during create if the table_flag HA_DROP_BEFORE_CREATE was specified for\n  the storage engine.\n\n    @see\n  delete_table and ha_create_table() in handler.cc\n*/\nint ha_connect::delete_or_rename_table(const char *name, const char *to)\n{\n  DBUG_ENTER(\"ha_connect::delete_or_rename_table\");\n  char db[128], tabname[128];\n  int  rc= 0;\n  bool ok= false;\n  THD *thd= current_thd;\n  int  sqlcom= thd_sql_command(thd);\n\n  if (trace(1)) {\n    if (to)\n      htrc(\"rename_table: this=%p thd=%p sqlcom=%d from=%s to=%s\\n\",\n              this, thd, sqlcom, name, to);\n    else\n      htrc(\"delete_table: this=%p thd=%p sqlcom=%d name=%s\\n\",\n              this, thd, sqlcom, name);\n\n    } // endif trace\n\n  if (to && (filename_to_dbname_and_tablename(to, db, sizeof(db),\n                                             tabname, sizeof(tabname))\n      || (*tabname == '#' && sqlcom == SQLCOM_CREATE_INDEX)))\n    DBUG_RETURN(0);\n\n  if (filename_to_dbname_and_tablename(name, db, sizeof(db),\n                                       tabname, sizeof(tabname))\n      || (*tabname == '#' && sqlcom == SQLCOM_CREATE_INDEX))\n    DBUG_RETURN(0);\n\n  // If a temporary file exists, all the tests below were passed\n  // successfully when making it, so they are not needed anymore\n  // in particular because they sometimes cause DBUG_ASSERT crash.\n  // Also, for partitioned tables, no test can be done because when\n  // this function is called, the .par file is already deleted and\n  // this causes the open_table_def function to fail.\n  // Not having any other clues (table and table_share are NULL)\n  // the only mean we have to test for partitioning is this:\n  if (*tabname != '#' && !strstr(tabname, \"#P#\")) {\n    // We have to retrieve the information about this table options.\n    ha_table_option_struct *pos;\n    char         key[MAX_DBKEY_LENGTH];\n    uint         key_length;\n    TABLE_SHARE *share;\n\n//  if ((p= strstr(tabname, \"#P#\")))   won't work, see above\n//    *p= 0;             // Get the main the table name\n\n    key_length= tdc_create_key(key, db, tabname);\n\n    // share contains the option struct that we need\n    if (!(share= alloc_table_share(db, tabname, key, key_length)))\n      DBUG_RETURN(rc);\n\n    // Get the share info from the .frm file\n    Dummy_error_handler error_handler;\n    thd->push_internal_handler(&error_handler);\n    bool got_error= open_table_def(thd, share);\n    thd->pop_internal_handler();\n    if (!got_error) {\n      // Now we can work\n      if ((pos= share->option_struct)) {\n        if (check_privileges(thd, pos, db))\n          rc= HA_ERR_INTERNAL_ERROR;         // ???\n        else\n          if (IsFileType(GetRealType(pos)) && !pos->filename)\n            ok= true;\n\n        } // endif pos\n\n      } // endif open_table_def\n\n    free_table_share(share);\n  } else              // Temporary file\n    ok= true;\n\n  if (ok) {\n    // Let the base handler do the job\n    if (to)\n      rc= handler::rename_table(name, to);\n    else if ((rc= handler::delete_table(name)) == ENOENT)\n      rc= 0;        // No files is not an error for CONNECT\n\n    } // endif ok\n\n  DBUG_RETURN(rc);\n} // end of delete_or_rename_table\n\nint ha_connect::delete_table(const char *name)\n{\n  return delete_or_rename_table(name, NULL);\n} // end of delete_table\n\nint ha_connect::rename_table(const char *from, const char *to)\n{\n  return delete_or_rename_table(from, to);\n} // end of rename_table\n\n/**\n  @brief\n  Given a starting key and an ending key, estimate the number of rows that\n  will exist between the two keys.\n\n  @details\n  end_key may be empty, in which case determine if start_key matches any rows.\n\n  Called from opt_range.cc by check_quick_keys().\n\n  @see\n  check_quick_keys() in opt_range.cc\n*/\nha_rows ha_connect::records_in_range(uint inx, key_range *min_key,\n                                               key_range *max_key)\n{\n  ha_rows rows;\n  DBUG_ENTER(\"ha_connect::records_in_range\");\n\n  if (indexing < 0 || inx != active_index)\n    if (index_init(inx, false))\n      DBUG_RETURN(HA_POS_ERROR);\n\n  if (trace(1))\n    htrc(\"records_in_range: inx=%d indexing=%d\\n\", inx, indexing);\n\n  if (indexing > 0) {\n    int          nval;\n    uint         len[2];\n    const uchar *key[2];\n    bool         incl[2];\n    key_part_map kmap[2];\n\n    key[0]= (min_key) ? min_key->key : NULL;\n    key[1]= (max_key) ? max_key->key : NULL;\n    len[0]= (min_key) ? min_key->length : 0;\n    len[1]= (max_key) ? max_key->length : 0;\n    incl[0]= (min_key) ? (min_key->flag == HA_READ_KEY_EXACT) : false;\n    incl[1]= (max_key) ? (max_key->flag == HA_READ_AFTER_KEY) : false;\n    kmap[0]= (min_key) ? min_key->keypart_map : 0;\n    kmap[1]= (max_key) ? max_key->keypart_map : 0;\n\n    if ((nval= CntIndexRange(xp->g, tdbp, key, len, incl, kmap)) < 0)\n      rows= HA_POS_ERROR;\n    else\n      rows= (ha_rows)nval;\n\n  } else if (indexing == 0)\n    rows= 100000000;        // Don't use missing index\n  else\n    rows= HA_POS_ERROR;\n\n  if (trace(1))\n    htrc(\"records_in_range: rows=%llu\\n\", rows);\n\n  DBUG_RETURN(rows);\n} // end of records_in_range\n\n// Used to check whether a MYSQL table is created on itself\nbool CheckSelf(PGLOBAL g, TABLE_SHARE *s, PCSZ host,\n\t             PCSZ db, PCSZ tab, PCSZ src, int port)\n{\n  if (src)\n    return false;\n  else if (host && stricmp(host, \"localhost\") && strcmp(host, \"127.0.0.1\"))\n    return false;\n  else if (db && stricmp(db, s->db.str))\n    return false;\n  else if (tab && stricmp(tab, s->table_name.str))\n    return false;\n  else if (port && port != (signed)GetDefaultPort())\n    return false;\n\n  strcpy(g->Message, \"This MySQL table is defined on itself\");\n  return true;\n} // end of CheckSelf\n\n/**\n  Convert an ISO-8859-1 column name to UTF-8\n*/\nstatic char *encode(PGLOBAL g, const char *cnm)\n  {\n  char  *buf= (char*)PlugSubAlloc(g, NULL, strlen(cnm) * 3);\n  uint   dummy_errors;\n  uint32 len= copy_and_convert(buf, strlen(cnm) * 3,\n                               &my_charset_utf8_general_ci,\n                               cnm, strlen(cnm),\n                               &my_charset_latin1,\n                               &dummy_errors);\n  buf[len]= '\\0';\n  return buf;\n  } // end of encode\n\n/**\n  Store field definition for create.\n\n  @return\n    Return 0 if ok\n*/\nstatic bool add_field(String *sql, const char *field_name, int typ, int len,\n                      int dec, char *key, uint tm, const char *rem, char *dft,\n                      char *xtra, char *fmt, int flag, bool dbf, char v)\n{\n  char var= (len > 255) ? 'V' : v;\n  bool q, error= false;\n  const char *type= PLGtoMYSQLtype(typ, dbf, var);\n\n  error|= sql->append('`');\n  error|= sql->append(field_name);\n  error|= sql->append(\"` \");\n  error|= sql->append(type);\n\n\tif (typ == TYPE_STRING || \n\t\t (len && typ != TYPE_DATE && (typ != TYPE_DOUBLE || dec >= 0))) {\n    error|= sql->append('(');\n    error|= sql->append_ulonglong(len);\n\n\t\tif (typ == TYPE_DOUBLE) {\n      error|= sql->append(',');\n      // dec must be < len and < 31\n      error|= sql->append_ulonglong(MY_MIN(dec, (MY_MIN(len, 31) - 1)));\n    } else if (dec > 0 && !strcmp(type, \"DECIMAL\")) {\n      error|= sql->append(',');\n      // dec must be < len\n      error|= sql->append_ulonglong(MY_MIN(dec, len - 1));\n    } // endif dec\n\n    error|= sql->append(')');\n    } // endif len\n\n  if (v == 'U')\n    error|= sql->append(\" UNSIGNED\");\n  else if (v == 'Z')\n    error|= sql->append(\" ZEROFILL\");\n\n  if (key && *key) {\n    error|= sql->append(\" \");\n    error|= sql->append(key);\n    } // endif key\n\n  if (tm)\n    error|= sql->append(STRING_WITH_LEN(\" NOT NULL\"), system_charset_info);\n\n  if (dft && *dft) {\n    error|= sql->append(\" DEFAULT \");\n\n    if (typ == TYPE_DATE)\n      q= (strspn(dft, \"0123456789 -:/\") == strlen(dft));\n    else\n      q= !IsTypeNum(typ);\n\n    if (q) {\n      error|= sql->append(\"'\");\n      error|= sql->append_for_single_quote(dft, strlen(dft));\n      error|= sql->append(\"'\");\n    } else\n      error|= sql->append(dft);\n\n    } // endif dft\n\n  if (xtra && *xtra) {\n    error|= sql->append(\" \");\n    error|= sql->append(xtra);\n    } // endif rem\n\n  if (rem && *rem) {\n    error|= sql->append(\" COMMENT '\");\n    error|= sql->append_for_single_quote(rem, strlen(rem));\n    error|= sql->append(\"'\");\n    } // endif rem\n\n  if (fmt && *fmt) {\n    error|= sql->append(\" FIELD_FORMAT='\");\n    error|= sql->append_for_single_quote(fmt, strlen(fmt));\n    error|= sql->append(\"'\");\n    } // endif flag\n\n  if (flag) {\n    error|= sql->append(\" FLAG=\");\n    error|= sql->append_ulonglong(flag);\n    } // endif flag\n\n  error|= sql->append(',');\n  return error;\n} // end of add_field\n\n/**\n  Initialise the table share with the new columns.\n\n  @return\n    Return 0 if ok\n*/\nstatic int init_table_share(THD* thd,\n                            TABLE_SHARE *table_s,\n                            HA_CREATE_INFO *create_info,\n                            String *sql)\n{\n  bool oom= false;\n  PTOS topt= table_s->option_struct;\n\n  sql->length(sql->length()-1); // remove the trailing comma\n  sql->append(')');\n\n  for (ha_create_table_option *opt= connect_table_option_list;\n       opt->name; opt++) {\n    ulonglong   vull;\n    const char *vstr;\n\n    switch (opt->type) {\n      case HA_OPTION_TYPE_ULL:\n        vull= *(ulonglong*)(((char*)topt) + opt->offset);\n\n        if (vull != opt->def_value) {\n          oom|= sql->append(' ');\n          oom|= sql->append(opt->name);\n          oom|= sql->append('=');\n          oom|= sql->append_ulonglong(vull);\n          } // endif vull\n\n        break;\n      case HA_OPTION_TYPE_STRING:\n        vstr= *(char**)(((char*)topt) + opt->offset);\n\n        if (vstr) {\n          oom|= sql->append(' ');\n          oom|= sql->append(opt->name);\n          oom|= sql->append(\"='\");\n          oom|= sql->append_for_single_quote(vstr, strlen(vstr));\n          oom|= sql->append('\\'');\n          } // endif vstr\n\n        break;\n      case HA_OPTION_TYPE_BOOL:\n        vull= *(bool*)(((char*)topt) + opt->offset);\n\n        if (vull != opt->def_value) {\n          oom|= sql->append(' ');\n          oom|= sql->append(opt->name);\n          oom|= sql->append('=');\n          oom|= sql->append(vull ? \"YES\" : \"NO\");\n          } // endif vull\n\n        break;\n      default: // no enums here, good :)\n        break;\n      } // endswitch type\n\n    if (oom)\n      return HA_ERR_OUT_OF_MEM;\n\n    } // endfor opt\n\n  if (create_info->connect_string.length) {\n    oom|= sql->append(' ');\n    oom|= sql->append(\"CONNECTION='\");\n    oom|= sql->append_for_single_quote(create_info->connect_string.str,\n                                       create_info->connect_string.length);\n    oom|= sql->append('\\'');\n\n    if (oom)\n      return HA_ERR_OUT_OF_MEM;\n\n    } // endif string\n\n  if (create_info->default_table_charset) {\n    oom|= sql->append(' ');\n    oom|= sql->append(\"CHARSET=\");\n    oom|= sql->append(create_info->default_table_charset->csname);\n\n    if (oom)\n      return HA_ERR_OUT_OF_MEM;\n\n    } // endif charset\n\n  if (trace(1))\n    htrc(\"s_init: %.*s\\n\", sql->length(), sql->ptr());\n\n  return table_s->init_from_sql_statement_string(thd, true,\n                                                 sql->ptr(), sql->length());\n} // end of init_table_share\n\n/**\n  @brief\n  connect_assisted_discovery() is called when creating a table with no columns.\n\n  @details\n  When assisted discovery is used the .frm file have not already been\n  created. You can overwrite some definitions at this point but the\n  main purpose of it is to define the columns for some table types.\n\n  @note\n  this function is no more called in case of CREATE .. SELECT\n*/\nstatic int connect_assisted_discovery(handlerton *, THD* thd,\n                                      TABLE_SHARE *table_s,\n                                      HA_CREATE_INFO *create_info)\n{\n  char     v=0;\n\tPCSZ     fncn= \"?\";\n\tPCSZ     user, fn, db, host, pwd, sep, tbl, src;\n\tPCSZ     col, ocl, rnk, pic, fcl, skc, zfn;\n\tchar    *tab, *dsn, *shm, *dpath, *url;\n#if defined(__WIN__)\n\tPCSZ     nsp= NULL, cls= NULL;\n#endif   // __WIN__\n//int      hdr, mxe;\n\tint      port= 0, mxr __attribute__((unused)) = 0, rc= 0, mul= 0;\n//PCSZ     tabtyp= NULL;\n#if defined(ODBC_SUPPORT)\n  POPARM   sop= NULL;\n\tPCSZ     ucnc= NULL;\n\tbool     cnc= false;\n  int      cto= -1, qto= -1;\n#endif   // ODBC_SUPPORT\n#if defined(JAVA_SUPPORT)\n\tPJPARM   sjp= NULL;\n\tPCSZ     driver= NULL;\n#endif   // JAVA_SUPPORT\n  uint     tm, fnc= FNC_NO, supfnc= (FNC_NO | FNC_COL);\n  bool     bif, ok= false, dbf= false;\n  TABTYPE  ttp= TAB_UNDEF;\n  PQRYRES  qrp= NULL;\n  PCOLRES  crp;\n  PCONNECT xp= NULL;\n  PGLOBAL  g= GetPlug(thd, xp);\n\n  if (!g)\n    return HA_ERR_INTERNAL_ERROR;\n\n  PTOS     topt= table_s->option_struct;\n  char     buf[1024];\n  String   sql(buf, sizeof(buf), system_charset_info);\n\n  sql.copy(STRING_WITH_LEN(\"CREATE TABLE whatever (\"), system_charset_info);\n\tuser = host = pwd = tbl = src = col = ocl = pic = fcl = skc = rnk = zfn = NULL;\n\tdsn = url = NULL;\n\n  // Get the useful create options\n  ttp= GetTypeID(topt->type);\n  fn=  topt->filename;\n  tab= (char*)topt->tabname;\n  src= topt->srcdef;\n  db=  topt->dbname;\n  fncn= topt->catfunc;\n  fnc= GetFuncID(fncn);\n  sep= topt->separator;\n\tmul= (int)topt->multiple;\n\ttbl= topt->tablist;\n  col= topt->colist;\n\n  if (topt->oplist) {\n    host= GetListOption(g, \"host\", topt->oplist, \"localhost\");\n    user= GetListOption(g, \"user\", topt->oplist, \n          ((ttp == TAB_ODBC || ttp == TAB_JDBC) ? NULL : \"root\"));\n    // Default value db can come from the DBNAME=xxx option.\n    db= GetListOption(g, \"database\", topt->oplist, db);\n    col= GetListOption(g, \"colist\", topt->oplist, col);\n    ocl= GetListOption(g, \"occurcol\", topt->oplist, NULL);\n    pic= GetListOption(g, \"pivotcol\", topt->oplist, NULL);\n    fcl= GetListOption(g, \"fnccol\", topt->oplist, NULL);\n    skc= GetListOption(g, \"skipcol\", topt->oplist, NULL);\n    rnk= GetListOption(g, \"rankcol\", topt->oplist, NULL);\n    pwd= GetListOption(g, \"password\", topt->oplist);\n#if defined(__WIN__)\n    nsp= GetListOption(g, \"namespace\", topt->oplist);\n    cls= GetListOption(g, \"class\", topt->oplist);\n#endif   // __WIN__\n    port= atoi(GetListOption(g, \"port\", topt->oplist, \"0\"));\n#if defined(ODBC_SUPPORT)\n//\ttabtyp= GetListOption(g, \"Tabtype\", topt->oplist, NULL);\n\t\tmxr= atoi(GetListOption(g,\"maxres\", topt->oplist, \"0\"));\n    cto= atoi(GetListOption(g,\"ConnectTimeout\", topt->oplist, \"-1\"));\n    qto= atoi(GetListOption(g,\"QueryTimeout\", topt->oplist, \"-1\"));\n    \n    if ((ucnc= GetListOption(g, \"UseDSN\", topt->oplist)))\n      cnc= (!*ucnc || *ucnc == 'y' || *ucnc == 'Y' || atoi(ucnc) != 0);\n#endif\n#if defined(JAVA_SUPPORT)\n\t\tdriver= GetListOption(g, \"Driver\", topt->oplist, NULL);\n#endif   // JAVA_SUPPORT\n#if defined(PROMPT_OK)\n    cop= atoi(GetListOption(g, \"checkdsn\", topt->oplist, \"0\"));\n#endif   // PROMPT_OK\n#if defined(ZIP_SUPPORT)\n\t\tzfn= GetListOption(g, \"Zipfile\", topt->oplist, NULL);\n#endif   // ZIP_SUPPORT\n\t} else {\n    host= \"localhost\";\n    user= ((ttp == TAB_ODBC || ttp == TAB_JDBC) ? NULL : \"root\");\n  } // endif option_list\n\n  if (!(shm= (char*)db))\n    db= table_s->db.str;                   // Default value\n\n\ttry {\n\t\t// Check table type\n\t\tif (ttp == TAB_UNDEF) {\n\t\t\ttopt->type= (src) ? \"MYSQL\" : (tab) ? \"PROXY\" : \"DOS\";\n\t\t\tttp= GetTypeID(topt->type);\n\t\t\tsprintf(g->Message, \"No table_type. Was set to %s\", topt->type);\n\t\t\tpush_warning(thd, Sql_condition::WARN_LEVEL_WARN, 0, g->Message);\n\t\t} else if (ttp == TAB_NIY) {\n\t\t\tsprintf(g->Message, \"Unsupported table type %s\", topt->type);\n\t\t\trc= HA_ERR_INTERNAL_ERROR;\n\t\t\tgoto err;\n#if defined(REST_SUPPORT)\n\t\t} else if (topt->http) {\n\t\t\tswitch (ttp) {\n\t\t\t\tcase TAB_JSON:\n\t\t\t\tcase TAB_XML:\n\t\t\t\tcase TAB_CSV:\n\t\t\t\t\tttp = TAB_REST;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\t// endswitch type\n#endif   // REST_SUPPORT\n\t\t} // endif ttp\n\n\t\tif (!tab) {\n\t\t\tif (ttp == TAB_TBL) {\n\t\t\t\t// Make tab the first table of the list\n\t\t\t\tchar *p;\n\n\t\t\t\tif (!tbl) {\n\t\t\t\t\tstrcpy(g->Message, \"Missing table list\");\n\t\t\t\t\trc= HA_ERR_INTERNAL_ERROR;\n\t\t\t\t\tgoto err;\n\t\t\t\t} // endif tbl\n\n\t\t\t\ttab= PlugDup(g, tbl);\n\n\t\t\t\tif ((p= strchr(tab, ',')))\n\t\t\t\t\t*p= 0;\n\n\t\t\t\tif ((p= strchr(tab, '.'))) {\n\t\t\t\t\t*p= 0;\n\t\t\t\t\tdb= tab;\n\t\t\t\t\ttab= p + 1;\n\t\t\t\t} // endif p\n\n\t\t\t} else if (ttp != TAB_ODBC || !(fnc & (FNC_TABLE | FNC_COL)))\n\t\t\t  tab= (char*)table_s->table_name.str;   // Default value\n\n\t\t} // endif tab\n\n\t\tswitch (ttp) {\n#if defined(ODBC_SUPPORT)\n\t\t\tcase TAB_ODBC:\n\t\t\t\tdsn= strz(g, create_info->connect_string);\n\n\t\t\t\tif (fnc & (FNC_DSN | FNC_DRIVER)) {\n\t\t\t\t\tok= true;\n#if defined(PROMPT_OK)\n\t\t\t\t} else if (!stricmp(thd->main_security_ctx.host, \"localhost\")\n\t\t\t\t\t&& cop == 1) {\n\t\t\t\t\tif ((dsn= ODBCCheckConnection(g, dsn, cop)) != NULL) {\n\t\t\t\t\t\tthd->make_lex_string(&create_info->connect_string, dsn, strlen(dsn));\n\t\t\t\t\t\tok= true;\n\t\t\t\t\t} // endif dsn\n#endif   // PROMPT_OK\n\n\t\t\t\t} else if (!dsn) {\n\t\t\t\t\tsprintf(g->Message, \"Missing %s connection string\", topt->type);\n\t\t\t\t} else {\n\t\t\t\t\t// Store ODBC additional parameters\n\t\t\t\t\tsop= (POPARM)PlugSubAlloc(g, NULL, sizeof(ODBCPARM));\n\t\t\t\t\tsop->User= (char*)user;\n\t\t\t\t\tsop->Pwd= (char*)pwd;\n\t\t\t\t\tsop->Cto= cto;\n\t\t\t\t\tsop->Qto= qto;\n\t\t\t\t\tsop->UseCnc= cnc;\n\t\t\t\t\tok= true;\n\t\t\t\t} // endif's\n\n\t\t\t\tsupfnc |= (FNC_TABLE | FNC_DSN | FNC_DRIVER);\n\t\t\t\tbreak;\n#endif   // ODBC_SUPPORT\n#if defined(JAVA_SUPPORT)\n\t\t\tcase TAB_JDBC:\n\t\t\t\tif (fnc & FNC_DRIVER) {\n\t\t\t\t\tok= true;\n\t\t\t\t} else if (!(url= strz(g, create_info->connect_string))) {\n\t\t\t\t\tstrcpy(g->Message, \"Missing URL\");\n\t\t\t\t} else {\n\t\t\t\t\t// Store JDBC additional parameters\n\t\t\t\t\tint      rc;\n\t\t\t\t\tPJDBCDEF jdef= new(g) JDBCDEF();\n\n\t\t\t\t\tjdef->SetName(create_info->alias.str);\n\t\t\t\t\tsjp = (PJPARM)PlugSubAlloc(g, NULL, sizeof(JDBCPARM));\n\t\t\t\t\tsjp->Driver = driver;\n\t\t\t\t\t//\t\tsjp->Properties = prop;\n\t\t\t\t\tsjp->Fsize = 0;\n\t\t\t\t\tsjp->Scrollable = false;\n\n\t\t\t\t\tif ((rc = jdef->ParseURL(g, url, false)) == RC_OK) {\n\t\t\t\t\t\tsjp->Url = url;\n\t\t\t\t\t\tsjp->User = (char*)user;\n\t\t\t\t\t\tsjp->Pwd = (char*)pwd;\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t} else if (rc == RC_NF) {\n\t\t\t\t\t\tif (jdef->GetTabname())\n\t\t\t\t\t\t\ttab= (char*)jdef->GetTabname();\n\n\t\t\t\t\t\tok= jdef->SetParms(sjp);\n\t\t\t\t\t} // endif rc\n\n\t\t\t\t} // endif's\n\n\t\t\t\tsupfnc |= (FNC_DRIVER | FNC_TABLE);\n\t\t\t\tbreak;\n#endif   // JAVA_SUPPORT\n\t\t\tcase TAB_DBF:\n\t\t\t\tdbf= true;\n\t\t\t\t// fall through\n\t\t\tcase TAB_CSV:\n\t\t\t\tif (!fn && fnc != FNC_NO)\n\t\t\t\t\tsprintf(g->Message, \"Missing %s file name\", topt->type);\n\t\t\t\telse if (sep && strlen(sep) > 1)\n\t\t\t\t\tsprintf(g->Message, \"Invalid separator %s\", sep);\n\t\t\t\telse\n\t\t\t\t\tok= true;\n\n\t\t\t\tbreak;\n\t\t\tcase TAB_MYSQL:\n\t\t\t\tok= true;\n\n\t\t\t\tif (create_info->connect_string.str &&\n\t\t\t\t\tcreate_info->connect_string.length) {\n\t\t\t\t\tPMYDEF  mydef= new(g) MYSQLDEF();\n\n\t\t\t\t\tdsn= strz(g, create_info->connect_string);\n\t\t\t\t\tmydef->SetName(create_info->alias.str);\n\n\t\t\t\t\tif (!mydef->ParseURL(g, dsn, false)) {\n\t\t\t\t\t\tif (mydef->GetHostname())\n\t\t\t\t\t\t\thost= mydef->GetHostname();\n\n\t\t\t\t\t\tif (mydef->GetUsername())\n\t\t\t\t\t\t\tuser= mydef->GetUsername();\n\n\t\t\t\t\t\tif (mydef->GetPassword())\n\t\t\t\t\t\t\tpwd= mydef->GetPassword();\n\n\t\t\t\t\t\tif (mydef->GetTabschema())\n\t\t\t\t\t\t\tdb= mydef->GetTabschema();\n\n\t\t\t\t\t\tif (mydef->GetTabname())\n\t\t\t\t\t\t\ttab= (char*)mydef->GetTabname();\n\n\t\t\t\t\t\tif (mydef->GetPortnumber())\n\t\t\t\t\t\t\tport= mydef->GetPortnumber();\n\n\t\t\t\t\t} else\n\t\t\t\t\t\tok= false;\n\n\t\t\t\t} else if (!user)\n\t\t\t\t\tuser= \"root\";\n\n\t\t\t\tif (ok && CheckSelf(g, table_s, host, db, tab, src, port))\n\t\t\t\t\tok= false;\n\n\t\t\t\tbreak;\n#if defined(__WIN__)\n\t\t\tcase TAB_WMI:\n\t\t\t\tok= true;\n\t\t\t\tbreak;\n#endif   // __WIN__\n\t\t\tcase TAB_PIVOT:\n\t\t\t\tsupfnc= FNC_NO;\n                                // fall through\n\t\t\tcase TAB_PRX:\n\t\t\tcase TAB_TBL:\n\t\t\tcase TAB_XCL:\n\t\t\tcase TAB_OCCUR:\n\t\t\t\tif (!src && !stricmp(tab, create_info->alias.str) &&\n\t\t\t\t\t(!db || !stricmp(db, table_s->db.str)))\n\t\t\t\t\tsprintf(g->Message, \"A %s table cannot refer to itself\", topt->type);\n\t\t\t\telse\n\t\t\t\t\tok= true;\n\n\t\t\t\tbreak;\n\t\t\tcase TAB_OEM:\n\t\t\t\tif (topt->module && topt->subtype)\n\t\t\t\t\tok= true;\n\t\t\t\telse\n\t\t\t\t\tstrcpy(g->Message, \"Missing OEM module or subtype\");\n\n\t\t\t\tbreak;\n#if defined(LIBXML2_SUPPORT) || defined(DOMDOC_SUPPORT)\n\t\t\tcase TAB_XML:\n#endif   // LIBXML2_SUPPORT  ||         DOMDOC_SUPPORT\n\t\t\tcase TAB_JSON:\n\t\t\t\tdsn= strz(g, create_info->connect_string);\n\n\t\t\t\tif (!fn && !zfn && !mul && !dsn)\n\t\t\t\t\tsprintf(g->Message, \"Missing %s file name\", topt->type);\n\t\t\t\telse\n\t\t\t\t\tok= true;\n\n\t\t\t\tbreak;\n#if defined(JAVA_SUPPORT)\n\t\t\tcase TAB_MONGO:\n\t\t\t\tif (!topt->tabname)\n\t\t\t\t\ttopt->tabname= tab;\n\n\t\t\t\tok= true;\n\t\t\t\tbreak;\n#endif   // JAVA_SUPPORT\n#if defined(REST_SUPPORT)\n\t\t\tcase TAB_REST:\n\t\t\t\tif (!topt->http)\n\t\t\t\t\tsprintf(g->Message, \"Missing %s HTTP address\", topt->type);\n\t\t\t\telse\n\t\t\t\t\tok = true;\n\n\t\t\t\tbreak;\n#endif   // REST_SUPPORT\n\t\t\tcase TAB_VIR:\n\t\t\t\tok= true;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tsprintf(g->Message, \"Cannot get column info for table type %s\", topt->type);\n\t\t\t\tbreak;\n\t\t} // endif ttp\n\n\t// Check for supported catalog function\n\t\tif (ok && !(supfnc & fnc)) {\n\t\t\tsprintf(g->Message, \"Unsupported catalog function %s for table type %s\",\n\t\t\t\tfncn, topt->type);\n\t\t\tok= false;\n\t\t} // endif supfnc\n\n\t\tif (src && fnc != FNC_NO) {\n\t\t\tstrcpy(g->Message, \"Cannot make catalog table from srcdef\");\n\t\t\tok= false;\n\t\t} // endif src\n\n\t\tif (ok) {\n\t\t\tconst char *cnm, *rem;\n\t\t\tchar *dft, *xtra, *key, *fmt;\n\t\t\tint   i, len, prec, dec, typ, flg;\n\n\t\t\tif (!(dpath= SetPath(g, table_s->db.str))) {\n\t\t\t\trc= HA_ERR_INTERNAL_ERROR;\n\t\t\t\tgoto err;\n\t\t\t}\t// endif dpath\n\n\t\t\tif (src && ttp != TAB_PIVOT && ttp != TAB_ODBC && ttp != TAB_JDBC) {\n\t\t\t\tqrp= SrcColumns(g, host, db, user, pwd, src, port);\n\n\t\t\t\tif (qrp && ttp == TAB_OCCUR)\n\t\t\t\t\tif (OcrSrcCols(g, qrp, col, ocl, rnk)) {\n\t\t\t\t\t\trc= HA_ERR_INTERNAL_ERROR;\n\t\t\t\t\t\tgoto err;\n\t\t\t\t\t} // endif OcrSrcCols\n\n\t\t\t} else switch (ttp) {\n\t\t\t\tcase TAB_DBF:\n\t\t\t\t\tqrp= DBFColumns(g, dpath, fn, fnc == FNC_COL);\n\t\t\t\t\tbreak;\n#if defined(ODBC_SUPPORT)\n\t\t\t\tcase TAB_ODBC:\n\t\t\t\t\tswitch (fnc) {\n\t\t\t\t\t\tcase FNC_NO:\n\t\t\t\t\t\tcase FNC_COL:\n\t\t\t\t\t\t\tif (src) {\n\t\t\t\t\t\t\t\tqrp= ODBCSrcCols(g, dsn, (char*)src, sop);\n\t\t\t\t\t\t\t\tsrc= NULL;     // for next tests\n\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\tqrp= ODBCColumns(g, dsn, shm, tab, NULL,\n\t\t\t\t\t\t\t\t\tmxr, fnc == FNC_COL, sop);\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase FNC_TABLE:\n\t\t\t\t\t\t\tqrp= ODBCTables(g, dsn, shm, tab, NULL, mxr, true, sop);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase FNC_DSN:\n\t\t\t\t\t\t\tqrp= ODBCDataSources(g, mxr, true);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase FNC_DRIVER:\n\t\t\t\t\t\t\tqrp= ODBCDrivers(g, mxr, true);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tsprintf(g->Message, \"invalid catfunc %s\", fncn);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t} // endswitch info\n\n\t\t\t\t\tbreak;\n#endif   // ODBC_SUPPORT\n#if defined(JAVA_SUPPORT)\n\t\t\t\tcase TAB_JDBC:\n\t\t\t\t\tswitch (fnc) {\n\t\t\t\t\t\tcase FNC_NO:\n\t\t\t\t\t\tcase FNC_COL:\n\t\t\t\t\t\t\tif (src) {\n\t\t\t\t\t\t\t\tqrp= JDBCSrcCols(g, (char*)src, sjp);\n\t\t\t\t\t\t\t\tsrc= NULL;     // for next tests\n\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\tqrp= JDBCColumns(g, shm, tab, NULL, mxr, fnc == FNC_COL, sjp);\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase FNC_TABLE:\n//\t\t\t\t\t\tqrp= JDBCTables(g, shm, tab, tabtyp, mxr, true, sjp);\n\t\t\t\t\t\t\tqrp= JDBCTables(g, shm, tab, NULL, mxr, true, sjp);\n\t\t\t\t\t\t\tbreak;\n#if 0\n\t\t\t\t\t\tcase FNC_DSN:\n\t\t\t\t\t\t\tqrp= JDBCDataSources(g, mxr, true);\n\t\t\t\t\t\t\tbreak;\n#endif // 0\n\t\t\t\t\t\tcase FNC_DRIVER:\n\t\t\t\t\t\t\tqrp= JDBCDrivers(g, mxr, true);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tsprintf(g->Message, \"invalid catfunc %s\", fncn);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t} // endswitch info\n\n\t\t\t\t\tbreak;\n#endif   // JAVA_SUPPORT\n\t\t\t\tcase TAB_MYSQL:\n\t\t\t\t\tqrp= MyColumns(g, thd, host, db, user, pwd, tab,\n\t\t\t\t\t\tNULL, port, fnc == FNC_COL);\n\t\t\t\t\tbreak;\n\t\t\t\tcase TAB_CSV:\n\t\t\t\t\tqrp= CSVColumns(g, dpath, topt, fnc == FNC_COL);\n\t\t\t\t\tbreak;\n#if defined(__WIN__)\n\t\t\t\tcase TAB_WMI:\n\t\t\t\t\tqrp= WMIColumns(g, nsp, cls, fnc == FNC_COL);\n\t\t\t\t\tbreak;\n#endif   // __WIN__\n\t\t\t\tcase TAB_PRX:\n\t\t\t\tcase TAB_TBL:\n\t\t\t\tcase TAB_XCL:\n\t\t\t\tcase TAB_OCCUR:\n\t\t\t\t\tbif= fnc == FNC_COL;\n\t\t\t\t\tqrp= TabColumns(g, thd, db, tab, bif);\n\n\t\t\t\t\tif (!qrp && bif && fnc != FNC_COL)         // tab is a view\n\t\t\t\t\t\tqrp= MyColumns(g, thd, host, db, user, pwd, tab, NULL, port, false);\n\n\t\t\t\t\tif (qrp && ttp == TAB_OCCUR && fnc != FNC_COL)\n\t\t\t\t\t\tif (OcrColumns(g, qrp, col, ocl, rnk)) {\n\t\t\t\t\t\t\trc= HA_ERR_INTERNAL_ERROR;\n\t\t\t\t\t\t\tgoto err;\n\t\t\t\t\t\t} // endif OcrColumns\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase TAB_PIVOT:\n\t\t\t\t\tqrp= PivotColumns(g, tab, src, pic, fcl, skc, host, db, user, pwd, port);\n\t\t\t\t\tbreak;\n\t\t\t\tcase TAB_VIR:\n\t\t\t\t\tqrp= VirColumns(g, fnc == FNC_COL);\n\t\t\t\t\tbreak;\n\t\t\t\tcase TAB_JSON:\n\t\t\t\t\tqrp= JSONColumns(g, db, dsn, topt, fnc == FNC_COL);\n\t\t\t\t\tbreak;\n#if defined(JAVA_SUPPORT)\n\t\t\t\tcase TAB_MONGO:\n\t\t\t\t\turl= strz(g, create_info->connect_string);\n\t\t\t\t\tqrp= MGOColumns(g, db, url, topt, fnc == FNC_COL);\n\t\t\t\t\tbreak;\n#endif   // JAVA_SUPPORT\n#if defined(LIBXML2_SUPPORT) || defined(DOMDOC_SUPPORT)\n\t\t\t\tcase TAB_XML:\n\t\t\t\t\tqrp= XMLColumns(g, (char*)db, tab, topt, fnc == FNC_COL);\n\t\t\t\t\tbreak;\n#endif   // LIBXML2_SUPPORT  ||         DOMDOC_SUPPORT\n#if defined(REST_SUPPORT)\n\t\t\t\tcase TAB_REST:\n\t\t\t\t\tqrp = RESTColumns(g, topt, tab, (char *)db, fnc == FNC_COL);\n\t\t\t\t\tbreak;\n#endif   // REST_SUPPORT\n\t\t\t\tcase TAB_OEM:\n\t\t\t\t\tqrp= OEMColumns(g, topt, tab, (char*)db, fnc == FNC_COL);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tstrcpy(g->Message, \"System error during assisted discovery\");\n\t\t\t\t\tbreak;\n\t\t\t} // endswitch ttp\n\n\t\t\tif (!qrp) {\n\t\t\t\trc= HA_ERR_INTERNAL_ERROR;\n\t\t\t\tgoto err;\n\t\t\t} // endif !qrp\n\n\t\t\tif (fnc != FNC_NO || src || ttp == TAB_PIVOT) {\n\t\t\t\t// Catalog like table\n\t\t\t\tfor (crp= qrp->Colresp; !rc && crp; crp= crp->Next) {\n\t\t\t\t\tcnm= (ttp == TAB_PIVOT) ? crp->Name : encode(g, crp->Name);\n\t\t\t\t\ttyp= crp->Type;\n\t\t\t\t\tlen= crp->Length;\n\t\t\t\t\tdec= crp->Prec;\n\t\t\t\t\tflg= crp->Flag;\n\t\t\t\t\tv= (crp->Kdata->IsUnsigned()) ? 'U' : crp->Var;\n\t\t\t\t\ttm= (crp->Kdata->IsNullable()) ? 0 : NOT_NULL_FLAG;\n\n\t\t\t\t\tif (!len && typ == TYPE_STRING)\n\t\t\t\t\t\tlen= 256;      // STRBLK's have 0 length\n\n\t\t\t\t\t// Now add the field\n\t\t\t\t\tif (add_field(&sql, cnm, typ, len, dec, NULL, tm,\n\t\t\t\t\t\tNULL, NULL, NULL, NULL, flg, dbf, v))\n\t\t\t\t\t\trc= HA_ERR_OUT_OF_MEM;\n\t\t\t\t} // endfor crp\n\n\t\t\t} else {\n                                char *schem __attribute__((unused)) = NULL;\n\t\t\t\tchar *tn= NULL;\n\n\t\t\t\t// Not a catalog table\n\t\t\t\tif (!qrp->Nblin) {\n\t\t\t\t\tif (tab)\n\t\t\t\t\t\tsprintf(g->Message, \"Cannot get columns from %s\", tab);\n\t\t\t\t\telse\n\t\t\t\t\t\tstrcpy(g->Message, \"Fail to retrieve columns\");\n\n\t\t\t\t\trc= HA_ERR_INTERNAL_ERROR;\n\t\t\t\t\tgoto err;\n\t\t\t\t} // endif !nblin\n\n\t\t\t\tfor (i= 0; !rc && i < qrp->Nblin; i++) {\n\t\t\t\t\ttyp= len= prec= dec= flg= 0;\n\t\t\t\t\ttm= NOT_NULL_FLAG;\n\t\t\t\t\tcnm= (char*)\"noname\";\n\t\t\t\t\tdft= xtra= key= fmt= tn= NULL;\n\t\t\t\t\tv= ' ';\n\t\t\t\t\trem= NULL;\n\n\t\t\t\t\tfor (crp= qrp->Colresp; crp; crp= crp->Next)\n\t\t\t\t\t\tswitch (crp->Fld) {\n\t\t\t\t\t\t\tcase FLD_NAME:\n\t\t\t\t\t\t\t\tif (ttp == TAB_PRX ||\n\t\t\t\t\t\t\t\t\t(ttp == TAB_CSV && topt->data_charset &&\n\t\t\t\t\t\t\t\t\t(!stricmp(topt->data_charset, \"UTF8\") ||\n\t\t\t\t\t\t\t\t\t\t!stricmp(topt->data_charset, \"UTF-8\"))))\n\t\t\t\t\t\t\t\t\tcnm= crp->Kdata->GetCharValue(i);\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tcnm= encode(g, crp->Kdata->GetCharValue(i));\n\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase FLD_TYPE:\n\t\t\t\t\t\t\t\ttyp= crp->Kdata->GetIntValue(i);\n\t\t\t\t\t\t\t\tv= (crp->Nulls) ? crp->Nulls[i] : 0;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase FLD_TYPENAME:\n\t\t\t\t\t\t\t\ttn= crp->Kdata->GetCharValue(i);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase FLD_PREC:\n\t\t\t\t\t\t\t\t// PREC must be always before LENGTH\n\t\t\t\t\t\t\t\tlen= prec= crp->Kdata->GetIntValue(i);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase FLD_LENGTH:\n\t\t\t\t\t\t\t\tlen= crp->Kdata->GetIntValue(i);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase FLD_SCALE:\n\t\t\t\t\t\t\t\tdec= (!crp->Kdata->IsNull(i)) ? crp->Kdata->GetIntValue(i) : -1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase FLD_NULL:\n\t\t\t\t\t\t\t\tif (crp->Kdata->GetIntValue(i))\n\t\t\t\t\t\t\t\t\ttm= 0;               // Nullable\n\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase FLD_FLAG:\n\t\t\t\t\t\t\t\tflg = crp->Kdata->GetIntValue(i);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase FLD_FORMAT:\n\t\t\t\t\t\t\t\tfmt= (crp->Kdata) ? crp->Kdata->GetCharValue(i) : NULL;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase FLD_REM:\n\t\t\t\t\t\t\t\trem= crp->Kdata->GetCharValue(i);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t//          case FLD_CHARSET:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// No good because remote table is already translated\n\t\t\t\t\t\t\t\t//            if (*(csn= crp->Kdata->GetCharValue(i)))\n\t\t\t\t\t\t\t\t//              cs= get_charset_by_name(csn, 0);\n\n\t\t\t\t\t\t\t\t//            break;\n\t\t\t\t\t\t\tcase FLD_DEFAULT:\n\t\t\t\t\t\t\t\tdft= crp->Kdata->GetCharValue(i);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase FLD_EXTRA:\n\t\t\t\t\t\t\t\txtra= crp->Kdata->GetCharValue(i);\n\n\t\t\t\t\t\t\t\t// Auto_increment is not supported yet\n\t\t\t\t\t\t\t\tif (!stricmp(xtra, \"AUTO_INCREMENT\"))\n\t\t\t\t\t\t\t\t\txtra= NULL;\n\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase FLD_KEY:\n\t\t\t\t\t\t\t\tif (ttp == TAB_VIR)\n\t\t\t\t\t\t\t\t\tkey= crp->Kdata->GetCharValue(i);\n\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase FLD_SCHEM:\n#if defined(ODBC_SUPPORT) || defined(JAVA_SUPPORT)\n\t\t\t\t\t\t\t\tif ((ttp == TAB_ODBC || ttp == TAB_JDBC) && crp->Kdata) {\n\t\t\t\t\t\t\t\t\tif (schem && stricmp(schem, crp->Kdata->GetCharValue(i))) {\n\t\t\t\t\t\t\t\t\t\tsprintf(g->Message,\n\t\t\t\t\t\t\t\t\t\t\t\"Several %s tables found, specify DBNAME\", tab);\n\t\t\t\t\t\t\t\t\t\trc= HA_ERR_INTERNAL_ERROR;\n\t\t\t\t\t\t\t\t\t\tgoto err;\n\t\t\t\t\t\t\t\t\t} else if (!schem)\n\t\t\t\t\t\t\t\t\t\tschem= crp->Kdata->GetCharValue(i);\n\n\t\t\t\t\t\t\t\t} // endif ttp\n#endif   // ODBC_SUPPORT\t||\t\t\t\t JAVA_SUPPORT\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tbreak;                 // Ignore\n\t\t\t\t\t\t} // endswitch Fld\n\n#if defined(ODBC_SUPPORT)\n\t\t\t\t\tif (ttp == TAB_ODBC) {\n\t\t\t\t\t\tint  plgtyp;\n\t\t\t\t\t\tbool w= false;            // Wide character type\n\n\t\t\t\t\t\t// typ must be PLG type, not SQL type\n\t\t\t\t\t\tif (!(plgtyp= TranslateSQLType(typ, dec, prec, v, w))) {\n\t\t\t\t\t\t\tif (GetTypeConv() == TPC_SKIP) {\n\t\t\t\t\t\t\t\t// Skip this column\n\t\t\t\t\t\t\t\tsprintf(g->Message, \"Column %s skipped (unsupported type %d)\",\n\t\t\t\t\t\t\t\t\tcnm, typ);\n\t\t\t\t\t\t\t\tpush_warning(thd, Sql_condition::WARN_LEVEL_WARN, 0, g->Message);\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tsprintf(g->Message, \"Unsupported SQL type %d\", typ);\n\t\t\t\t\t\t\t\trc= HA_ERR_INTERNAL_ERROR;\n\t\t\t\t\t\t\t\tgoto err;\n\t\t\t\t\t\t\t} // endif type_conv\n\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\ttyp= plgtyp;\n\n\t\t\t\t\t\tswitch (typ) {\n\t\t\t\t\t\t\tcase TYPE_STRING:\n\t\t\t\t\t\t\t\tif (w) {\n\t\t\t\t\t\t\t\t\tsprintf(g->Message, \"Column %s is wide characters\", cnm);\n\t\t\t\t\t\t\t\t\tpush_warning(thd, Sql_condition::WARN_LEVEL_NOTE, 0, g->Message);\n\t\t\t\t\t\t\t\t} // endif w\n\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TYPE_DOUBLE:\n\t\t\t\t\t\t\t\t// Some data sources do not count dec in length (prec)\n\t\t\t\t\t\t\t\tprec += (dec + 2);        // To be safe\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase TYPE_DECIM:\n\t\t\t\t\t\t\t\tprec= len;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tdec= 0;\n\t\t\t\t\t\t} // endswitch typ\n\n\t\t\t\t\t} else\n#endif   // ODBC_SUPPORT\n#if defined(JAVA_SUPPORT)\n\t\t\t\t\t\tif (ttp == TAB_JDBC) {\n\t\t\t\t\t\t\tint  plgtyp;\n\n\t\t\t\t\t\t\t// typ must be PLG type, not SQL type\n\t\t\t\t\t\t\tif (!(plgtyp= TranslateJDBCType(typ, tn, dec, prec, v))) {\n\t\t\t\t\t\t\t\tif (GetTypeConv() == TPC_SKIP) {\n\t\t\t\t\t\t\t\t\t// Skip this column\n\t\t\t\t\t\t\t\t\tsprintf(g->Message, \"Column %s skipped (unsupported type %d)\",\n\t\t\t\t\t\t\t\t\t\tcnm, typ);\n\t\t\t\t\t\t\t\t\tpush_warning(thd, Sql_condition::WARN_LEVEL_WARN, 0, g->Message);\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tsprintf(g->Message, \"Unsupported SQL type %d\", typ);\n\t\t\t\t\t\t\t\t\trc= HA_ERR_INTERNAL_ERROR;\n\t\t\t\t\t\t\t\t\tgoto err;\n\t\t\t\t\t\t\t\t} // endif type_conv\n\n\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\ttyp= plgtyp;\n\n\t\t\t\t\t\t\tswitch (typ) {\n\t\t\t\t\t\t\t\tcase TYPE_DOUBLE:\n\t\t\t\t\t\t\t\tcase TYPE_DECIM:\n\t\t\t\t\t\t\t\t\t// Some data sources do not count dec in length (prec)\n\t\t\t\t\t\t\t\t\tprec += (dec + 2);        // To be safe\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\tdec= 0;\n\t\t\t\t\t\t\t} // endswitch typ\n\n\t\t\t\t\t\t} else\n#endif   // ODBC_SUPPORT\n\t\t\t\t\t\t\t// Make the arguments as required by add_fields\n\t\t\t\t\t\t\tif (typ == TYPE_DOUBLE)\n\t\t\t\t\t\t\t\tprec= len;\n\n\t\t\t\t\t\tif (typ == TYPE_DATE)\n\t\t\t\t\t\t\tprec= 0;\n\n\t\t\t\t\t\t// Now add the field\n\t\t\t\t\t\tif (add_field(&sql, cnm, typ, prec, dec, key, tm, rem, dft, xtra,\n\t\t\t\t\t\t\tfmt, flg, dbf, v))\n\t\t\t\t\t\t\trc= HA_ERR_OUT_OF_MEM;\n\t\t\t\t} // endfor i\n\n\t\t\t} // endif fnc\n\n\t\t\tif (!rc)\n\t\t\t\trc= init_table_share(thd, table_s, create_info, &sql);\n\n\t\t\t//g->jump_level--;\n\t\t\t//PopUser(xp);\n\t\t\t//return rc;\n\t\t} else {\n\t\t\trc= HA_ERR_UNSUPPORTED;\n\t\t} // endif ok\n\n\t} catch (int n) {\n\t\tif (trace(1))\n\t\t\thtrc(\"Exception %d: %s\\n\", n, g->Message);\n\t\trc= HA_ERR_INTERNAL_ERROR;\n\t} catch (const char *msg) {\n\t\tstrcpy(g->Message, msg);\n\t\trc= HA_ERR_INTERNAL_ERROR;\n\t} // end catch\n\n err:\n  if (rc)\n    my_message(ER_UNKNOWN_ERROR, g->Message, MYF(0));\n\n\tPopUser(xp);\n\treturn rc;\n} // end of connect_assisted_discovery\n\n/**\n  Get the database name from a qualified table name.\n*/\nchar *ha_connect::GetDBfromName(const char *name)\n{\n  char *db, dbname[128], tbname[128];\n\n  if (filename_to_dbname_and_tablename(name, dbname, sizeof(dbname),\n                                             tbname, sizeof(tbname)))\n    *dbname= 0;\n\n  if (*dbname) {\n    assert(xp && xp->g);\n    db= (char*)PlugSubAlloc(xp->g, NULL, strlen(dbname + 1));\n    strcpy(db, dbname);\n  } else\n    db= NULL;\n\n  return db;\n} // end of GetDBfromName\n\n\n/**\n  @brief\n  create() is called to create a database. The variable name will have the name\n  of the table.\n\n  @details\n  When create() is called you do not need to worry about\n  opening the table. Also, the .frm file will have already been\n  created so adjusting create_info is not necessary. You can overwrite\n  the .frm file at this point if you wish to change the table\n  definition, but there are no methods currently provided for doing\n  so.\n\n  Called from handle.cc by ha_create_table().\n\n  @note\n  Currently we do some checking on the create definitions and stop\n  creating if an error is found. We wish we could change the table\n  definition such as providing a default table type. However, as said\n  above, there are no method to do so.\n\n  @see\n  ha_create_table() in handle.cc\n*/\n\nint ha_connect::create(const char *name, TABLE *table_arg,\n                       HA_CREATE_INFO *create_info)\n{\n  int     rc= RC_OK;\n  bool    dbf, inward;\n  Field* *field;\n  Field  *fp;\n  TABTYPE type;\n  TABLE  *st= table;                       // Probably unuseful\n  THD    *thd= ha_thd();\n  LEX_CSTRING cnc = table_arg->s->connect_string;\n#if defined(WITH_PARTITION_STORAGE_ENGINE)\n  partition_info *part_info= table_arg->part_info;\n#else\t\t// !WITH_PARTITION_STORAGE_ENGINE\n#define part_info 0\n#endif  // !WITH_PARTITION_STORAGE_ENGINE\n  xp= GetUser(thd, xp);\n  PGLOBAL g= xp->g;\n\n  DBUG_ENTER(\"ha_connect::create\");\n  /*\n    This assignment fixes test failures if some\n    \"ALTER TABLE t1 ADD KEY(a)\" query exits on ER_ACCESS_DENIED_ERROR\n    (e.g. on missing FILE_ACL). All following \"CREATE TABLE\" failed with\n    \"ERROR 1105: CONNECT index modification should be in-place\"\n    TODO: check with Olivier.\n  */\n  g->Xchk= NULL;\n  int  sqlcom= thd_sql_command(table_arg->in_use);\n  PTOS options= GetTableOptionStruct(table_arg->s);\n\n  table= table_arg;         // Used by called functions\n\n  if (trace(1))\n    htrc(\"create: this=%p thd=%p xp=%p g=%p sqlcom=%d name=%s\\n\",\n           this, thd, xp, g, sqlcom, GetTableName());\n\n  // CONNECT engine specific table options:\n  DBUG_ASSERT(options);\n  type= GetTypeID(options->type);\n\n  // Check table type\n  if (type == TAB_UNDEF) {\n    options->type= (options->srcdef)  ? \"MYSQL\" :\n                   (options->tabname) ? \"PROXY\" : \"DOS\";\n    type= GetTypeID(options->type);\n    sprintf(g->Message, \"No table_type. Will be set to %s\", options->type);\n\n    if (sqlcom == SQLCOM_CREATE_TABLE)\n      push_warning(thd, Sql_condition::WARN_LEVEL_WARN, 0, g->Message);\n\n  } else if (type == TAB_NIY) {\n    sprintf(g->Message, \"Unsupported table type %s\", options->type);\n    my_message(ER_UNKNOWN_ERROR, g->Message, MYF(0));\n    DBUG_RETURN(HA_ERR_INTERNAL_ERROR);\n  } // endif ttp\n\n  if (check_privileges(thd, options, GetDBfromName(name)))\n    DBUG_RETURN(HA_ERR_INTERNAL_ERROR);\n\n  inward= IsFileType(type) && !options->filename &&\n\t\t     (type != TAB_JSON || !cnc.length);\n\n  if (options->data_charset) {\n    const CHARSET_INFO *data_charset;\n\n    if (!(data_charset= get_charset_by_csname(options->data_charset,\n                                              MY_CS_PRIMARY, MYF(0)))) {\n      my_error(ER_UNKNOWN_CHARACTER_SET, MYF(0), options->data_charset);\n      DBUG_RETURN(HA_ERR_INTERNAL_ERROR);\n      } // endif charset\n\n    if (type == TAB_XML && data_charset != &my_charset_utf8_general_ci) {\n      my_printf_error(ER_UNKNOWN_ERROR,\n                      \"DATA_CHARSET='%s' is not supported for TABLE_TYPE=XML\",\n                        MYF(0), options->data_charset);\n      DBUG_RETURN(HA_ERR_INTERNAL_ERROR);\n      } // endif utf8\n\n    } // endif charset\n\n  if (!g) {\n    rc= HA_ERR_INTERNAL_ERROR;\n    DBUG_RETURN(rc);\n  } else\n    dbf= (GetTypeID(options->type) == TAB_DBF && !options->catfunc);\n\n  // Can be null in ALTER TABLE\n  if (create_info->alias.str)\n    // Check whether a table is defined on itself\n    switch (type) {\n      case TAB_PRX:\n      case TAB_XCL:\n      case TAB_PIVOT:\n      case TAB_OCCUR:\n        if (options->srcdef) {\n          strcpy(g->Message, \"Cannot check looping reference\");\n          push_warning(thd, Sql_condition::WARN_LEVEL_WARN, 0, g->Message);\n        } else if (options->tabname) {\n          if (!stricmp(options->tabname, create_info->alias.str) &&\n             (!options->dbname || \n              !stricmp(options->dbname, table_arg->s->db.str))) {\n            sprintf(g->Message, \"A %s table cannot refer to itself\",\n                                options->type);\n            my_message(ER_UNKNOWN_ERROR, g->Message, MYF(0));\n            DBUG_RETURN(HA_ERR_INTERNAL_ERROR);\n            } // endif tab\n\n        } else {\n          strcpy(g->Message, \"Missing object table name or definition\");\n          my_message(ER_UNKNOWN_ERROR, g->Message, MYF(0));\n          DBUG_RETURN(HA_ERR_INTERNAL_ERROR);\n        } // endif tabname\n\n\t\t\t\t// fall through\n      case TAB_MYSQL:\n        if (!part_info)\n       {const char *src= options->srcdef;\n\t\t\t\tPCSZ host, db, tab= options->tabname;\n        int  port;\n\n        host= GetListOption(g, \"host\", options->oplist, NULL);\n        db= GetStringOption(\"database\", NULL);\n        port= atoi(GetListOption(g, \"port\", options->oplist, \"0\"));\n\n        if (create_info->connect_string.str &&\n            create_info->connect_string.length) {\n          char   *dsn= strz(g, create_info->connect_string);\n          PMYDEF  mydef= new(g) MYSQLDEF();\n\n          mydef->SetName(create_info->alias.str);\n\n          if (!mydef->ParseURL(g, dsn, false)) {\n            if (mydef->GetHostname())\n              host= mydef->GetHostname();\n\n\t\t\t\t\t\tif (mydef->GetTabschema())\n\t\t\t\t\t\t\tdb= mydef->GetTabschema();\n\n            if (mydef->GetTabname())\n              tab= mydef->GetTabname();\n\n            if (mydef->GetPortnumber())\n              port= mydef->GetPortnumber();\n\n          } else {\n            my_message(ER_UNKNOWN_ERROR, g->Message, MYF(0));\n            DBUG_RETURN(HA_ERR_INTERNAL_ERROR);\n          } // endif ParseURL\n\n          } // endif connect_string\n\n        if (CheckSelf(g, table_arg->s, host, db, tab, src, port)) {\n          my_message(ER_UNKNOWN_ERROR, g->Message, MYF(0));\n          DBUG_RETURN(HA_ERR_INTERNAL_ERROR);\n          } // endif CheckSelf\n\n       } break;\n      default: /* do nothing */;\n        break;\n     } // endswitch ttp\n\n  if (type == TAB_XML) {\n    bool dom;                  // True: MS-DOM, False libxml2\n\t\tPCSZ xsup= GetListOption(g, \"Xmlsup\", options->oplist, \"*\");\n\n    // Note that if no support is specified, the default is MS-DOM\n    // on Windows and libxml2 otherwise\n    switch (toupper(*xsup)) {\n      case '*':\n#if defined(__WIN__)\n        dom= true;\n#else   // !__WIN__\n        dom= false;\n#endif  // !__WIN__\n        break;\n      case 'M':\n      case 'D':\n        dom= true;\n        break;\n      default:\n        dom= false;\n        break;\n      } // endswitch xsup\n\n#if !defined(DOMDOC_SUPPORT)\n    if (dom) {\n      strcpy(g->Message, \"MS-DOM not supported by this version\");\n      xsup= NULL;\n      } // endif DomDoc\n#endif   // !DOMDOC_SUPPORT\n\n#if !defined(LIBXML2_SUPPORT)\n    if (!dom) {\n      strcpy(g->Message, \"libxml2 not supported by this version\");\n      xsup= NULL;\n      } // endif Libxml2\n#endif   // !LIBXML2_SUPPORT\n\n    if (!xsup) {\n      my_message(ER_UNKNOWN_ERROR, g->Message, MYF(0));\n      rc= HA_ERR_INTERNAL_ERROR;\n      DBUG_RETURN(rc);\n      } // endif xsup\n\n    } // endif type\n\n  if (type == TAB_JSON) {\n    int pretty= atoi(GetListOption(g, \"Pretty\", options->oplist, \"2\"));\n\n    if (!options->lrecl && pretty != 2) {\n      sprintf(g->Message, \"LRECL must be specified for pretty=%d\", pretty);\n      my_message(ER_UNKNOWN_ERROR, g->Message, MYF(0));\n      rc= HA_ERR_INTERNAL_ERROR;\n      DBUG_RETURN(rc);\n      } // endif lrecl\n\n    } // endif type\tJSON\n\n\tif (type == TAB_CSV) {\n\t\tconst char *sep= options->separator;\n\n\t\tif (sep && strlen(sep) > 1) {\n\t\t\tsprintf(g->Message, \"Invalid separator %s\", sep);\n\t\t\tmy_message(ER_UNKNOWN_ERROR, g->Message, MYF(0));\n\t\t\trc= HA_ERR_INTERNAL_ERROR;\n\t\t\tDBUG_RETURN(rc);\n\t\t} // endif sep\n\n\t} // endif type\tCSV\n\n  // Check column types\n  for (field= table_arg->field; *field; field++) {\n    fp= *field;\n\n    if (fp->vcol_info && !fp->stored_in_db)\n      continue;            // This is a virtual column\n\n    if (fp->flags & AUTO_INCREMENT_FLAG) {\n      strcpy(g->Message, \"Auto_increment is not supported yet\");\n      my_message(ER_UNKNOWN_ERROR, g->Message, MYF(0));\n      rc= HA_ERR_INTERNAL_ERROR;\n      DBUG_RETURN(rc);\n      } // endif flags\n\n    if (fp->flags & (BLOB_FLAG | ENUM_FLAG | SET_FLAG)) {\n      sprintf(g->Message, \"Unsupported type for column %s\",\n                          fp->field_name.str);\n      my_message(ER_UNKNOWN_ERROR, g->Message, MYF(0));\n      rc= HA_ERR_INTERNAL_ERROR;\n      DBUG_RETURN(rc);\n      } // endif flags\n\n    if (type == TAB_VIR)\n      if (!fp->option_struct || !fp->option_struct->special) {\n        strcpy(g->Message, \"Virtual tables accept only special or virtual columns\");\n        my_message(ER_UNKNOWN_ERROR, g->Message, MYF(0));\n        rc= HA_ERR_INTERNAL_ERROR;\n        DBUG_RETURN(rc);\n        } // endif special\n      \n    switch (fp->type()) {\n      case MYSQL_TYPE_SHORT:\n      case MYSQL_TYPE_LONG:\n      case MYSQL_TYPE_FLOAT:\n      case MYSQL_TYPE_DOUBLE:\n      case MYSQL_TYPE_TIMESTAMP:\n      case MYSQL_TYPE_DATE:\n      case MYSQL_TYPE_TIME:\n      case MYSQL_TYPE_DATETIME:\n      case MYSQL_TYPE_YEAR:\n      case MYSQL_TYPE_NEWDATE:\n      case MYSQL_TYPE_LONGLONG:\n      case MYSQL_TYPE_TINY:\n      case MYSQL_TYPE_DECIMAL:\n      case MYSQL_TYPE_NEWDECIMAL:\n      case MYSQL_TYPE_INT24:\n        break;                     // Ok\n      case MYSQL_TYPE_VARCHAR:\n      case MYSQL_TYPE_VAR_STRING:\n      case MYSQL_TYPE_STRING:\n#if 0\n        if (!fp->field_length) {\n          sprintf(g->Message, \"Unsupported 0 length for column %s\",\n                              fp->field_name.str);\n          rc= HA_ERR_INTERNAL_ERROR;\n          my_printf_error(ER_UNKNOWN_ERROR,\n                          \"Unsupported 0 length for column %s\",\n                          MYF(0), fp->field_name.str);\n          DBUG_RETURN(rc);\n          } // endif fp\n#endif // 0\n        break;                     // To be checked\n      case MYSQL_TYPE_BIT:\n      case MYSQL_TYPE_NULL:\n      case MYSQL_TYPE_ENUM:\n      case MYSQL_TYPE_SET:\n      case MYSQL_TYPE_TINY_BLOB:\n      case MYSQL_TYPE_MEDIUM_BLOB:\n      case MYSQL_TYPE_LONG_BLOB:\n      case MYSQL_TYPE_BLOB:\n      case MYSQL_TYPE_GEOMETRY:\n      default:\n//      fprintf(stderr, \"Unsupported type column %s\\n\", fp->field_name.str);\n        sprintf(g->Message, \"Unsupported type for column %s\",\n                            fp->field_name.str);\n        rc= HA_ERR_INTERNAL_ERROR;\n        my_printf_error(ER_UNKNOWN_ERROR, \"Unsupported type for column %s\",\n                        MYF(0), fp->field_name.str);\n        DBUG_RETURN(rc);\n        break;\n      } // endswitch type\n\n    if ((fp)->real_maybe_null() && !IsTypeNullable(type)) {\n      my_printf_error(ER_UNKNOWN_ERROR,\n                      \"Table type %s does not support nullable columns\",\n                      MYF(0), options->type);\n      DBUG_RETURN(HA_ERR_UNSUPPORTED);\n      } // endif !nullable\n\n    if (dbf) {\n      bool b= false;\n\n      if ((b= fp->field_name.length > 10))\n        sprintf(g->Message, \"DBF: Column name '%s' is too long (max=10)\",\n                            fp->field_name.str);\n      else if ((b= fp->field_length > 255))\n        sprintf(g->Message, \"DBF: Column length too big for '%s' (max=255)\",\n                            fp->field_name.str);\n\n      if (b) {\n        my_message(ER_UNKNOWN_ERROR, g->Message, MYF(0));\n        rc= HA_ERR_INTERNAL_ERROR;\n        DBUG_RETURN(rc);\n        } // endif b\n\n      } // endif dbf\n\n    } // endfor field\n\n  if ((sqlcom == SQLCOM_CREATE_TABLE || *GetTableName() == '#') && inward) {\n    // The file name is not specified, create a default file in\n    // the database directory named table_name.table_type.\n    // (temporarily not done for XML because a void file causes\n    // the XML parsers to report an error on the first Insert)\n    char buf[_MAX_PATH], fn[_MAX_PATH], dbpath[_MAX_PATH], lwt[12];\n    int  h;\n\n    // Check for incompatible options\n    if (options->sepindex) {\n      my_message(ER_UNKNOWN_ERROR,\n            \"SEPINDEX is incompatible with unspecified file name\", MYF(0));\n      DBUG_RETURN(HA_ERR_UNSUPPORTED);\n\t\t} else if (GetTypeID(options->type) == TAB_VEC) {\n\t\t\tif (!table->s->max_rows || options->split) {\n\t\t\t\tmy_printf_error(ER_UNKNOWN_ERROR,\n\t\t\t\t\t\"%s tables whose file name is unspecified cannot be split\",\n\t\t\t\t\tMYF(0), options->type);\n\t\t\t\tDBUG_RETURN(HA_ERR_UNSUPPORTED);\n\t\t\t} else if (options->header == 2) {\n\t\t\t\tmy_printf_error(ER_UNKNOWN_ERROR,\n\t\t\t\t\t\"header=2 is not allowed for %s tables whose file name is unspecified\",\n\t\t\t\t\tMYF(0), options->type);\n\t\t\t\tDBUG_RETURN(HA_ERR_UNSUPPORTED);\n\t\t\t} // endif's\n\n\t\t} else if (options->zipped) {\n\t\t\tmy_message(ER_UNKNOWN_ERROR,\n\t\t\t\t\"ZIPPED is incompatible with unspecified file name\", MYF(0));\n\t\t\tDBUG_RETURN(HA_ERR_UNSUPPORTED);\n\t\t}\t// endif's options\n\n    // Fold type to lower case\n    for (int i= 0; i < 12; i++)\n      if (!options->type[i]) {\n        lwt[i]= 0;\n        break;\n      } else\n        lwt[i]= tolower(options->type[i]);\n\n    if (part_info) {\n      char *p;\n\n      strcpy(dbpath, name);\n      p= strrchr(dbpath, slash);\n      strncpy(partname, ++p, sizeof(partname) - 1);\n      strcat(strcat(strcpy(buf, p), \".\"), lwt);\n      *p= 0;\n    } else {\n      strcat(strcat(strcpy(buf, GetTableName()), \".\"), lwt);\n      sprintf(g->Message, \"No file name. Table will use %s\", buf);\n  \n      if (sqlcom == SQLCOM_CREATE_TABLE)\n        push_warning(thd, Sql_condition::WARN_LEVEL_WARN, 0, g->Message);\n  \n      strcat(strcat(strcpy(dbpath, \"./\"), table->s->db.str), \"/\");\n    } // endif part_info\n\n    PlugSetPath(fn, buf, dbpath);\n\n    if ((h= ::open(fn, O_CREAT | O_EXCL, 0666)) == -1) {\n      if (errno == EEXIST)\n        sprintf(g->Message, \"Default file %s already exists\", fn);\n      else\n        sprintf(g->Message, \"Error %d creating file %s\", errno, fn);\n\n      push_warning(thd, Sql_condition::WARN_LEVEL_WARN, 0, g->Message);\n    } else\n      ::close(h);\n    \n    if ((type == TAB_FMT || options->readonly) && sqlcom == SQLCOM_CREATE_TABLE)\n      push_warning(thd, Sql_condition::WARN_LEVEL_WARN, 0,\n        \"Congratulation, you just created a read-only void table!\");\n\n    } // endif sqlcom\n\n  if (trace(1))\n    htrc(\"xchk=%p createas=%d\\n\", g->Xchk, g->Createas);\n\n#if defined(ZIP_SUPPORT)\n\tif (options->zipped) {\n\t\t// Check whether the zip entry must be made from a file\n\t\tPCSZ fn= GetListOption(g, \"Load\", options->oplist, NULL);\n\n\t\tif (fn) {\n\t\t\tchar zbuf[_MAX_PATH], buf[_MAX_PATH], dbpath[_MAX_PATH];\n\t\t\tPCSZ entry= GetListOption(g, \"Entry\", options->oplist, NULL);\n\t\t\tPCSZ a= GetListOption(g, \"Append\", options->oplist, \"NO\");\n\t\t\tbool append= *a == '1' || *a == 'Y' || *a == 'y' || !stricmp(a, \"ON\");\n\t\t\tPCSZ m= GetListOption(g, \"Mulentries\", options->oplist, \"NO\");\n\t\t\tbool mul= *m == '1' || *m == 'Y' || *m == 'y' || !stricmp(m, \"ON\");\n\n\t\t\tif (!entry && !mul) {\n\t\t\t\tmy_message(ER_UNKNOWN_ERROR, \"Missing entry name\", MYF(0));\n\t\t\t\tDBUG_RETURN(HA_ERR_INTERNAL_ERROR);\n\t\t\t}\t// endif entry\n\n\t\t\tstrcat(strcat(strcpy(dbpath, \"./\"), table->s->db.str), \"/\");\n\t\t\tPlugSetPath(zbuf, options->filename, dbpath);\n\t\t\tPlugSetPath(buf, fn, dbpath);\n\n\t\t\tif (ZipLoadFile(g, zbuf, buf, entry, append, mul)) {\n\t\t\t\tmy_message(ER_UNKNOWN_ERROR, g->Message, MYF(0));\n\t\t\t\tDBUG_RETURN(HA_ERR_INTERNAL_ERROR);\n\t\t\t}\t// endif LoadFile\n\n\t\t}\t// endif fn\n\n\t}\t// endif zipped\n#endif   // ZIP_SUPPORT\n\n  // To check whether indexes have to be made or remade\n  if (!g->Xchk) {\n    PIXDEF xdp;\n\n    // We should be in CREATE TABLE, ALTER_TABLE or CREATE INDEX\n    if (!(sqlcom == SQLCOM_CREATE_TABLE || sqlcom == SQLCOM_ALTER_TABLE ||\n          sqlcom == SQLCOM_CREATE_INDEX || sqlcom == SQLCOM_DROP_INDEX))  \n//         (sqlcom == SQLCOM_CREATE_INDEX && part_info) ||  \n//         (sqlcom == SQLCOM_DROP_INDEX && part_info)))  \n      push_warning(thd, Sql_condition::WARN_LEVEL_WARN, 0,\n        \"Unexpected command in create, please contact CONNECT team\");\n\n    if (part_info && !inward)\n      strncpy(partname, decode(g, strrchr(name, '#') + 1), sizeof(partname) - 1);\n//    strcpy(partname, part_info->curr_part_elem->partition_name);\n\n    if (g->Alchecked == 0 &&\n        (!IsFileType(type) || FileExists(options->filename, false))) {\n      if (part_info) {\n        sprintf(g->Message, \"Data repartition in %s is unchecked\", partname); \n        push_warning(thd, Sql_condition::WARN_LEVEL_WARN, 0, g->Message);\n      } else if (sqlcom == SQLCOM_ALTER_TABLE) {\n        // This is an ALTER to CONNECT from another engine.\n        // It cannot be accepted because the table data would be modified\n        // except when the target file does not exist.\n        strcpy(g->Message, \"Operation denied. Table data would be modified.\");\n        my_message(ER_UNKNOWN_ERROR, g->Message, MYF(0));\n        DBUG_RETURN(HA_ERR_INTERNAL_ERROR);\n      } // endif part_info\n\n      } // endif outward\n\n    // Get the index definitions\n    if ((xdp= GetIndexInfo()) || sqlcom == SQLCOM_DROP_INDEX) {\n      if (options->multiple) {\n        strcpy(g->Message, \"Multiple tables are not indexable\");\n        my_message(ER_UNKNOWN_ERROR, g->Message, MYF(0));\n        rc= HA_ERR_UNSUPPORTED;\n      } else if (options->compressed) {\n        strcpy(g->Message, \"Compressed tables are not indexable\");\n        my_message(ER_UNKNOWN_ERROR, g->Message, MYF(0));\n        rc= HA_ERR_UNSUPPORTED;\n      } else if (GetIndexType(type) == 1) {\n        PDBUSER dup= PlgGetUser(g);\n        PCATLG  cat= (dup) ? dup->Catalog : NULL;\n\n\t\t\t\tif (SetDataPath(g, table_arg->s->db.str)) {\n\t\t\t\t\tmy_message(ER_UNKNOWN_ERROR, g->Message, MYF(0));\n\t\t\t\t\trc= HA_ERR_INTERNAL_ERROR;\n\t\t\t\t} else if (cat) {\n          if (part_info)\n            strncpy(partname, \n                    decode(g, strrchr(name, (inward ? slash : '#')) + 1),\n\t\t\t\t\t\t\t\t\t\tsizeof(partname) - 1);\n\n          if ((rc= optimize(table->in_use, NULL))) {\n            htrc(\"Create rc=%d %s\\n\", rc, g->Message);\n            my_message(ER_UNKNOWN_ERROR, g->Message, MYF(0));\n            rc= HA_ERR_INTERNAL_ERROR;\n          } else\n            CloseTable(g);\n\n          } // endif cat\n    \n      } else if (GetIndexType(type) == 3) {\n        if (CheckVirtualIndex(table_arg->s)) {\n          my_message(ER_UNKNOWN_ERROR, g->Message, MYF(0));\n          rc= HA_ERR_UNSUPPORTED;\n          } // endif Check\n\n      } else if (!GetIndexType(type)) {\n        sprintf(g->Message, \"Table type %s is not indexable\", options->type);\n        my_message(ER_UNKNOWN_ERROR, g->Message, MYF(0));\n        rc= HA_ERR_UNSUPPORTED;\n      } // endif index type\n\n      } // endif xdp\n\n  } else {\n    // This should not happen anymore with indexing new way\n    my_message(ER_UNKNOWN_ERROR,\n               \"CONNECT index modification should be in-place\", MYF(0));\n    DBUG_RETURN(HA_ERR_UNSUPPORTED);\n  } // endif Xchk\n\n  table= st;\n  DBUG_RETURN(rc);\n} // end of create\n\n/**\n  Used to check whether a file based outward table can be populated by\n  an ALTER TABLE command. The conditions are:\n  - file does not exist or is void\n  - user has file privilege\n*/\nbool ha_connect::FileExists(const char *fn, bool bf)\n{\n  if (!fn || !*fn)\n    return false;\n  else if (IsPartitioned() && bf)\n    return true;\n\n  if (table) {\n    const char *s;\n\t\tchar  tfn[_MAX_PATH], filename[_MAX_PATH], path[_MAX_PATH];\n\t\tbool  b= false;\n    int   n;\n    struct stat info;\n\n#if defined(__WIN__)\n    s= \"\\\\\";\n#else   // !__WIN__\n    s= \"/\";\n#endif  // !__WIN__\n    if (IsPartitioned()) {\n      sprintf(tfn, fn, GetPartName());\n\n      // This is to avoid an initialization error raised by the\n      // test on check_table_flags made in ha_partition::open\n      // that can fail if some partition files are empty.\n      b= true;\n    } else\n      strcpy(tfn, fn);\n\n    strcat(strcat(strcat(strcpy(path, \".\"), s), table->s->db.str), s);\n    PlugSetPath(filename, tfn, path);\n    n= stat(filename, &info);\n\n    if (n < 0) {\n      if (errno != ENOENT) {\n        char buf[_MAX_PATH + 20];\n\n        sprintf(buf, \"Error %d for file %s\", errno, filename);\n        push_warning(table->in_use, Sql_condition::WARN_LEVEL_WARN, 0, buf);\n        return true;\n      } else\n        return false;\n\n    } else\n      return (info.st_size || b) ? true : false;\n\n    } // endif table\n\n  return true;\n} // end of FileExists\n\n// Called by SameString and NoFieldOptionChange\nbool ha_connect::CheckString(PCSZ str1, PCSZ str2)\n{\n  bool  b1= (!str1 || !*str1), b2= (!str2 || !*str2);\n\n  if (b1 && b2)\n    return true;\n  else if ((b1 && !b2) || (!b1 && b2) || stricmp(str1, str2))\n    return false;\n\n  return true;\n} // end of CheckString\n\n/**\n  check whether a string option have changed\n  */\nbool ha_connect::SameString(TABLE *tab, PCSZ opn)\n{\n  PCSZ str1, str2;\n\n  tshp= tab->s;                 // The altered table\n  str1= GetStringOption(opn);\n  tshp= NULL;\n  str2= GetStringOption(opn);\n  return CheckString(str1, str2);\n} // end of SameString\n\n/**\n  check whether a Boolean option have changed\n  */\nbool ha_connect::SameBool(TABLE *tab, PCSZ opn)\n{\n  bool b1, b2;\n\n  tshp= tab->s;                 // The altered table\n  b1= GetBooleanOption(opn, false);\n  tshp= NULL;\n  b2= GetBooleanOption(opn, false);\n  return (b1 == b2);\n} // end of SameBool\n\n/**\n  check whether an integer option have changed\n  */\nbool ha_connect::SameInt(TABLE *tab, PCSZ opn)\n{\n  int i1, i2;\n\n  tshp= tab->s;                 // The altered table\n  i1= GetIntegerOption(opn);\n  tshp= NULL;\n  i2= GetIntegerOption(opn);\n\n  if (!stricmp(opn, \"lrecl\"))\n    return (i1 == i2 || !i1 || !i2);\n  else if (!stricmp(opn, \"ending\"))\n    return (i1 == i2 || i1 <= 0 || i2 <= 0);\n  else\n    return (i1 == i2);\n\n} // end of SameInt\n\n/**\n  check whether a field option have changed\n  */\nbool ha_connect::NoFieldOptionChange(TABLE *tab)\n{\n  bool rc= true;\n  ha_field_option_struct *fop1, *fop2;\n  Field* *fld1= table->s->field;\n  Field* *fld2= tab->s->field;\n\n  for (; rc && *fld1 && *fld2; fld1++, fld2++) {\n    fop1= (*fld1)->option_struct;\n    fop2= (*fld2)->option_struct;\n\n    rc= (fop1->offset == fop2->offset &&\n         fop1->fldlen == fop2->fldlen &&\n         CheckString(fop1->dateformat, fop2->dateformat) &&\n         CheckString(fop1->fieldformat, fop2->fieldformat) &&\n         CheckString(fop1->special, fop2->special));\n    } // endfor fld\n\n  return rc;\n} // end of NoFieldOptionChange\n\n /**\n    Check if a storage engine supports a particular alter table in-place\n\n    @param    altered_table     TABLE object for new version of table.\n    @param    ha_alter_info     Structure describing changes to be done\n                                by ALTER TABLE and holding data used\n                                during in-place alter.\n\n    @retval   HA_ALTER_ERROR                  Unexpected error.\n    @retval   HA_ALTER_INPLACE_NOT_SUPPORTED  Not supported, must use copy.\n    @retval   HA_ALTER_INPLACE_EXCLUSIVE_LOCK Supported, but requires X lock.\n    @retval   HA_ALTER_INPLACE_COPY_LOCK\n                                              Supported, but requires SNW lock\n                                              during main phase. Prepare phase\n                                              requires X lock.\n    @retval   HA_ALTER_INPLACE_SHARED_LOCK    Supported, but requires SNW lock.\n    @retval   HA_ALTER_INPLACE_COPY_NO_LOCK\n                                              Supported, concurrent reads/writes\n                                              allowed. However, prepare phase\n                                              requires X lock.\n    @retval   HA_ALTER_INPLACE_NO_LOCK        Supported, concurrent\n                                              reads/writes allowed.\n\n    @note The default implementation uses the old in-place ALTER API\n    to determine if the storage engine supports in-place ALTER or not.\n\n    @note Called without holding thr_lock.c lock.\n */\nenum_alter_inplace_result\nha_connect::check_if_supported_inplace_alter(TABLE *altered_table,\n                                Alter_inplace_info *ha_alter_info)\n{\n  DBUG_ENTER(\"check_if_supported_alter\");\n\n  bool            idx= false, outward= false;\n  THD            *thd= ha_thd();\n  int             sqlcom= thd_sql_command(thd);\n  TABTYPE         newtyp, type= TAB_UNDEF;\n  HA_CREATE_INFO *create_info= ha_alter_info->create_info;\n  PTOS            newopt, oldopt;\n  xp= GetUser(thd, xp);\n  PGLOBAL         g= xp->g;\n\n  if (!g || !table) {\n    my_message(ER_UNKNOWN_ERROR, \"Cannot check ALTER operations\", MYF(0));\n    DBUG_RETURN(HA_ALTER_ERROR);\n    } // endif Xchk\n\n  newopt= altered_table->s->option_struct;\n  oldopt= table->s->option_struct;\n\n  // If this is the start of a new query, cleanup the previous one\n  if (xp->CheckCleanup()) {\n    tdbp= NULL;\n    valid_info= false;\n    } // endif CheckCleanup\n\n  g->Alchecked= 1;       // Tested in create\n  g->Xchk= NULL;\n  type= GetRealType(oldopt);\n  newtyp= GetRealType(newopt);\n\n  // No copy algorithm for outward tables\n  outward= (!IsFileType(type) || (oldopt->filename && *oldopt->filename));\n\n  // Index operations\n  alter_table_operations index_operations=\n    ALTER_ADD_INDEX |\n    ALTER_DROP_INDEX |\n    ALTER_ADD_NON_UNIQUE_NON_PRIM_INDEX |\n    ALTER_DROP_NON_UNIQUE_NON_PRIM_INDEX |\n    ALTER_ADD_UNIQUE_INDEX |\n    ALTER_DROP_UNIQUE_INDEX |\n    ALTER_ADD_PK_INDEX |\n    ALTER_DROP_PK_INDEX;\n\n  alter_table_operations inplace_offline_operations=\n    ALTER_COLUMN_TYPE_CHANGE_BY_ENGINE |\n    ALTER_COLUMN_NAME |\n    ALTER_COLUMN_DEFAULT |\n    ALTER_CHANGE_CREATE_OPTION |\n    ALTER_RENAME |\n    ALTER_PARTITIONED | index_operations;\n\n  if (ha_alter_info->handler_flags & index_operations ||\n      !SameString(altered_table, \"optname\") ||\n      !SameBool(altered_table, \"sepindex\")) {\n    if (newopt->multiple) {\n      strcpy(g->Message, \"Multiple tables are not indexable\");\n      my_message(ER_UNKNOWN_ERROR, g->Message, MYF(0));\n      DBUG_RETURN(HA_ALTER_ERROR);\n    } else if (newopt->compressed) {\n      strcpy(g->Message, \"Compressed tables are not indexable\");\n      my_message(ER_UNKNOWN_ERROR, g->Message, MYF(0));\n      DBUG_RETURN(HA_ALTER_ERROR);\n    } else if (GetIndexType(type) == 1) {\n      g->Xchk= new(g) XCHK;\n      PCHK xcp= (PCHK)g->Xchk;\n  \n      xcp->oldpix= GetIndexInfo(table->s);\n      xcp->newpix= GetIndexInfo(altered_table->s);\n      xcp->oldsep= GetBooleanOption(\"sepindex\", false);\n      xcp->oldsep= xcp->SetName(g, GetStringOption(\"optname\"));\n      tshp= altered_table->s;\n      xcp->newsep= GetBooleanOption(\"sepindex\", false);\n      xcp->newsep= xcp->SetName(g, GetStringOption(\"optname\"));\n      tshp= NULL;\n  \n      if (trace(1) && g->Xchk)\n        htrc(\n          \"oldsep=%d newsep=%d oldopn=%s newopn=%s oldpix=%p newpix=%p\\n\",\n                xcp->oldsep, xcp->newsep, \n                SVP(xcp->oldopn), SVP(xcp->newopn), \n                xcp->oldpix, xcp->newpix);\n  \n      if (sqlcom == SQLCOM_ALTER_TABLE)\n        idx= true;\n      else\n        DBUG_RETURN(HA_ALTER_INPLACE_EXCLUSIVE_LOCK);\n\n    } else if (GetIndexType(type) == 3) {\n      if (CheckVirtualIndex(altered_table->s)) {\n        my_message(ER_UNKNOWN_ERROR, g->Message, MYF(0));\n        DBUG_RETURN(HA_ALTER_ERROR);\n        } // endif Check\n\n    } else if (!GetIndexType(type)) {\n      sprintf(g->Message, \"Table type %s is not indexable\", oldopt->type);\n      my_message(ER_UNKNOWN_ERROR, g->Message, MYF(0));\n      DBUG_RETURN(HA_ALTER_ERROR);\n    } // endif index type\n\n    } // endif index operation\n\n  if (!SameString(altered_table, \"filename\")) {\n    if (!outward) {\n      // Conversion to outward table is only allowed for file based\n      // tables whose file does not exist.\n      tshp= altered_table->s;\n\t\t\tPCSZ fn= GetStringOption(\"filename\");\n      tshp= NULL;\n\n      if (FileExists(fn, false)) {\n        strcpy(g->Message, \"Operation denied. Table data would be lost.\");\n        my_message(ER_UNKNOWN_ERROR, g->Message, MYF(0));\n        DBUG_RETURN(HA_ALTER_ERROR);\n      } else\n        goto fin;\n\n    } else\n      goto fin;\n\n    } // endif filename\n\n  /* Is there at least one operation that requires copy algorithm? */\n  if (ha_alter_info->handler_flags & ~inplace_offline_operations)\n    goto fin;\n\n  /*\n    ALTER TABLE tbl_name CONVERT TO CHARACTER SET .. and\n    ALTER TABLE table_name DEFAULT CHARSET= .. most likely\n    change column charsets and so not supported in-place through\n    old API.\n\n    Changing of PACK_KEYS, MAX_ROWS and ROW_FORMAT options were\n    not supported as in-place operations in old API either.\n  */\n  if (create_info->used_fields & (HA_CREATE_USED_CHARSET |\n                                  HA_CREATE_USED_DEFAULT_CHARSET |\n                                  HA_CREATE_USED_PACK_KEYS |\n                                  HA_CREATE_USED_MAX_ROWS) ||\n      (table->s->row_type != create_info->row_type))\n    goto fin;\n\n#if 0\n  uint table_changes= (ha_alter_info->handler_flags &\n                       ALTER_COLUMN_TYPE_CHANGE_BY_ENGINE) ?\n    IS_EQUAL_PACK_LENGTH : IS_EQUAL_YES;\n\n  if (table->file->check_if_incompatible_data(create_info, table_changes)\n      == COMPATIBLE_DATA_YES)\n    DBUG_RETURN(HA_ALTER_INPLACE_EXCLUSIVE_LOCK);\n#endif // 0\n\n  // This was in check_if_incompatible_data\n  if (NoFieldOptionChange(altered_table) &&\n      type == newtyp &&\n      SameInt(altered_table, \"lrecl\") &&\n      SameInt(altered_table, \"elements\") &&\n      SameInt(altered_table, \"header\") &&\n      SameInt(altered_table, \"quoted\") &&\n      SameInt(altered_table, \"ending\") &&\n      SameInt(altered_table, \"compressed\"))\n    DBUG_RETURN(HA_ALTER_INPLACE_EXCLUSIVE_LOCK);\n\nfin:\n  if (idx) {\n    // Indexing is only supported inplace\n    my_message(ER_ALTER_OPERATION_NOT_SUPPORTED,\n      \"Alter operations not supported together by CONNECT\", MYF(0));\n    DBUG_RETURN(HA_ALTER_ERROR);\n  } else if (outward) {\n    if (IsFileType(type))\n      push_warning(thd, Sql_condition::WARN_LEVEL_WARN, 0,\n        \"This is an outward table, table data were not modified.\");\n\n    DBUG_RETURN(HA_ALTER_INPLACE_EXCLUSIVE_LOCK);\n  } else\n    DBUG_RETURN(HA_ALTER_INPLACE_NOT_SUPPORTED);\n\n} // end of check_if_supported_inplace_alter\n\n\n/**\n  check_if_incompatible_data() called if ALTER TABLE can't detect otherwise\n  if new and old definition are compatible\n\n  @details If there are no other explicit signs like changed number of\n  fields this function will be called by compare_tables()\n  (sql/sql_tables.cc) to decide should we rewrite whole table or only .frm\n  file.\n\n  @note: This function is no more called by check_if_supported_inplace_alter\n*/\n\nbool ha_connect::check_if_incompatible_data(HA_CREATE_INFO *, uint)\n{\n  DBUG_ENTER(\"ha_connect::check_if_incompatible_data\");\n  // TO DO: really implement and check it.\n  push_warning(ha_thd(), Sql_condition::WARN_LEVEL_WARN, 0,\n      \"Unexpected call to check_if_incompatible_data.\");\n  DBUG_RETURN(COMPATIBLE_DATA_NO);\n} // end of check_if_incompatible_data\n\n/****************************************************************************\n * CONNECT MRR implementation: use DS-MRR\n   This is just copied from myisam\n ***************************************************************************/\n\nint ha_connect::multi_range_read_init(RANGE_SEQ_IF *seq, void *seq_init_param,\n                                     uint n_ranges, uint mode,\n                                     HANDLER_BUFFER *buf)\n{\n  return ds_mrr.dsmrr_init(this, seq, seq_init_param, n_ranges, mode, buf);\n} // end of multi_range_read_init\n\nint ha_connect::multi_range_read_next(range_id_t *range_info)\n{\n  return ds_mrr.dsmrr_next(range_info);\n} // end of multi_range_read_next\n\nha_rows ha_connect::multi_range_read_info_const(uint keyno, RANGE_SEQ_IF *seq,\n                                               void *seq_init_param,\n                                               uint n_ranges, uint *bufsz,\n                                               uint *flags, Cost_estimate *cost)\n{\n  /*\n    This call is here because there is no location where this->table would\n    already be known.\n    TODO: consider moving it into some per-query initialization call.\n  */\n  ds_mrr.init(this, table);\n\n  // MMR is implemented for \"local\" file based tables only\n  if (!IsFileType(GetRealType(GetTableOptionStruct())))\n    *flags|= HA_MRR_USE_DEFAULT_IMPL;\n\n  ha_rows rows= ds_mrr.dsmrr_info_const(keyno, seq, seq_init_param, n_ranges,\n                                        bufsz, flags, cost);\n  xp->g->Mrr= !(*flags & HA_MRR_USE_DEFAULT_IMPL);\n  return rows;\n} // end of multi_range_read_info_const\n\nha_rows ha_connect::multi_range_read_info(uint keyno, uint n_ranges, uint keys,\n                                         uint key_parts, uint *bufsz,\n                                         uint *flags, Cost_estimate *cost)\n{\n  ds_mrr.init(this, table);\n\n  // MMR is implemented for \"local\" file based tables only\n  if (!IsFileType(GetRealType(GetTableOptionStruct())))\n    *flags|= HA_MRR_USE_DEFAULT_IMPL;\n\n  ha_rows rows= ds_mrr.dsmrr_info(keyno, n_ranges, keys, key_parts, bufsz,\n                                  flags, cost);\n  xp->g->Mrr= !(*flags & HA_MRR_USE_DEFAULT_IMPL);\n  return rows;\n} // end of multi_range_read_info\n\n\nint ha_connect::multi_range_read_explain_info(uint mrr_mode, char *str,\n                                             size_t size)\n{\n  return ds_mrr.dsmrr_explain_info(mrr_mode, str, size);\n} // end of multi_range_read_explain_info\n\n/* CONNECT MRR implementation ends */\n\n#if 0\n// Does this make sens for CONNECT?\nItem *ha_connect::idx_cond_push(uint keyno_arg, Item* idx_cond_arg)\n{\n  pushed_idx_cond_keyno= keyno_arg;\n  pushed_idx_cond= idx_cond_arg;\n  in_range_check_pushed_down= TRUE;\n  if (active_index == pushed_idx_cond_keyno)\n    mi_set_index_cond_func(file, handler_index_cond_check, this);\n  return NULL;\n}\n#endif // 0\n\n\nstruct st_mysql_storage_engine connect_storage_engine=\n{ MYSQL_HANDLERTON_INTERFACE_VERSION };\n\n/***********************************************************************/\n/*  CONNECT global variables definitions.                              */\n/***********************************************************************/\n#if defined(XMAP)\n// Using file mapping for indexes if true\nstatic MYSQL_SYSVAR_BOOL(indx_map, xmap, PLUGIN_VAR_RQCMDARG,\n       \"Using file mapping for indexes\", NULL, NULL, 0);\n#endif   // XMAP\n\n#if defined(XMSG)\nstatic MYSQL_SYSVAR_STR(errmsg_dir_path, msg_path,\n//     PLUGIN_VAR_RQCMDARG | PLUGIN_VAR_MEMALLOC,\n       PLUGIN_VAR_RQCMDARG | PLUGIN_VAR_READONLY,\n       \"Path to the directory where are the message files\",\n//     check_msg_path, update_msg_path,\n       NULL, NULL,\n       \"../../../../storage/connect/\");     // for testing\n#endif   // XMSG\n\n#if defined(JAVA_SUPPORT)\nstatic MYSQL_SYSVAR_STR(jvm_path, JvmPath,\n\tPLUGIN_VAR_RQCMDARG | PLUGIN_VAR_MEMALLOC,\n\t\"Path to the directory where is the JVM lib\",\n\t//     check_jvm_path, update_jvm_path,\n\tNULL, NULL,\tNULL);\n\nstatic MYSQL_SYSVAR_STR(class_path, ClassPath,\n\tPLUGIN_VAR_RQCMDARG | PLUGIN_VAR_MEMALLOC,\n\t\"Java class path\",\n\t//     check_class_path, update_class_path,\n\tNULL, NULL, NULL);\n#endif   // JAVA_SUPPORT\n\n\nstatic struct st_mysql_sys_var* connect_system_variables[]= {\n  MYSQL_SYSVAR(xtrace),\n  MYSQL_SYSVAR(conv_size),\n  MYSQL_SYSVAR(type_conv),\n#if defined(XMAP)\n  MYSQL_SYSVAR(indx_map),\n#endif   // XMAP\n  MYSQL_SYSVAR(work_size),\n  MYSQL_SYSVAR(use_tempfile),\n  MYSQL_SYSVAR(exact_info),\n#if defined(XMSG) || defined(NEWMSG)\n  MYSQL_SYSVAR(msg_lang),\n#endif   // XMSG || NEWMSG\n#if defined(XMSG)\n  MYSQL_SYSVAR(errmsg_dir_path),\n#endif   // XMSG\n\tMYSQL_SYSVAR(json_null),\n  MYSQL_SYSVAR(json_grp_size),\n#if defined(JAVA_SUPPORT)\n\tMYSQL_SYSVAR(jvm_path),\n\tMYSQL_SYSVAR(class_path),\n\tMYSQL_SYSVAR(java_wrapper),\n#endif   // JAVA_SUPPORT\n#if defined(JAVA_SUPPORT) || defined(CMGO_SUPPORT)\n\tMYSQL_SYSVAR(enable_mongo),\n#endif   // JAVA_SUPPORT || CMGO_SUPPORT   \n\tMYSQL_SYSVAR(cond_push),\n\tNULL\n};\n\nmaria_declare_plugin(connect)\n{\n  MYSQL_STORAGE_ENGINE_PLUGIN,\n  &connect_storage_engine,\n  \"CONNECT\",\n  \"Olivier Bertrand\",\n  \"Management of External Data (SQL/NOSQL/MED), including Rest query results\",\n  PLUGIN_LICENSE_GPL,\n  connect_init_func,                            /* Plugin Init */\n  connect_done_func,                            /* Plugin Deinit */\n  0x0107,                                       /* version number (1.07) */\n  NULL,                                         /* status variables */\n  connect_system_variables,                     /* system variables */\n  \"1.07.0001\",                                  /* string version */\n\tMariaDB_PLUGIN_MATURITY_STABLE                /* maturity */\n}\nmaria_declare_plugin_end;\n",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/connect/javaconn.cpp": "/************ Javaconn C++ Functions Source Code File (.CPP) ***********/\n/*  Name: JAVAConn.CPP  Version 1.0                                    */\n/*                                                                     */\n/*  (C) Copyright to the author Olivier BERTRAND          2017         */\n/*                                                                     */\n/*  This file contains the JAVA connection classes functions.          */\n/***********************************************************************/\n\n#if defined(__WIN__)\n// This is needed for RegGetValue\n#define _WINVER 0x0601\n#undef  _WIN32_WINNT\n#define _WIN32_WINNT 0x0601\n#endif   // __WIN__\n\n/***********************************************************************/\n/*  Include relevant MariaDB header file.                              */\n/***********************************************************************/\n#include <my_global.h>\n//#include <m_string.h>\n#if defined(__WIN__)\n#include <direct.h>                      // for getcwd\n#if defined(__BORLANDC__)\n#define __MFC_COMPAT__                   // To define min/max as macro\n#endif   // __BORLANDC__\n#else   // !__WIN__\n#if defined(UNIX)\n#include <errno.h>\n#else   // !UNIX\n#endif  // !UNIX\n#include <stdio.h>\n#include <stdlib.h>                      // for getenv\n#define NODW\n#endif  // !__WIN__\n\n/***********************************************************************/\n/*  Required objects includes.                                         */\n/***********************************************************************/\n#include \"global.h\"\n#include \"plgdbsem.h\"\n#include \"colblk.h\"\n#include \"xobject.h\"\n#include \"xtable.h\"\n#include \"tabext.h\"\n#include \"javaconn.h\"\n#include \"resource.h\"\n#include \"valblk.h\"\n#include \"osutil.h\"\n\n#if defined(__WIN__)\nextern \"C\" HINSTANCE s_hModule;           // Saved module handle\n#endif   // __WIN__\n#define nullptr 0\n\n//TYPCONV GetTypeConv();\n//int GetConvSize();\nextern char *JvmPath;   // The connect_jvm_path global variable value\nextern char *ClassPath; // The connect_class_path global variable value\n\nchar *GetPluginDir(void);\nchar *GetJavaWrapper(void);\t\t// The connect_java_wrapper variable value\n\n/***********************************************************************/\n/*  Static JAVAConn objects.                                           */\n/***********************************************************************/\nvoid  *JAVAConn::LibJvm = NULL;\nCRTJVM JAVAConn::CreateJavaVM = NULL;\nGETJVM JAVAConn::GetCreatedJavaVMs = NULL;\n#if defined(_DEBUG)\nGETDEF JAVAConn::GetDefaultJavaVMInitArgs = NULL;\n#endif   // _DEBUG\n\n/***********************************************************************/\n/*  Some macro's (should be defined elsewhere to be more accessible)   */\n/***********************************************************************/\n#if defined(_DEBUG)\n#define ASSERT(f)          assert(f)\n#define DEBUG_ONLY(f)      (f)\n#else   // !_DEBUG\n#define ASSERT(f)          ((void)0)\n#define DEBUG_ONLY(f)      ((void)0)\n#endif  // !_DEBUG\n\n/***********************************************************************/\n/*  JAVAConn construction/destruction.                                 */\n/***********************************************************************/\nJAVAConn::JAVAConn(PGLOBAL g, PCSZ wrapper)\n{\n\tm_G = g;\n\tjvm = nullptr;            // Pointer to the JVM (Java Virtual Machine)\n\tenv = nullptr;            // Pointer to native interface\n\tjdi = nullptr;\t\t\t\t\t\t// Pointer to the java wrapper class\n\tjob = nullptr;\t\t\t\t\t\t// The java wrapper class object\n\terrid = nullptr;\n\tDiscFunc = \"Disconnect\";\n\tMsg = NULL;\n\tm_Wrap = (wrapper) ? wrapper : GetJavaWrapper();\n\n\tif (!strchr(m_Wrap, '/')) {\n\t\t// Add the wrapper package name\n\t\tchar *wn = (char*)PlugSubAlloc(g, NULL, strlen(m_Wrap) + 10);\n\t\tm_Wrap = strcat(strcpy(wn, \"wrappers/\"), m_Wrap);\n\t} // endif m_Wrap\n\n\tfp = NULL;\n\tm_Opened = false;\n\tm_Connected = false;\n\tm_Rows = 0;\n//*m_ErrMsg = '\\0';\n} // end of JAVAConn\n\n//JAVAConn::~JAVAConn()\n//  {\n//if (Connected())\n//  EndCom();\n\n//  } // end of ~JAVAConn\nchar *JAVAConn::GetUTFString(jstring s)\n{\n\tchar *str;\n\tconst char *utf = env->GetStringUTFChars(s, nullptr);\n\n\tstr = PlugDup(m_G, utf);\n\tenv->ReleaseStringUTFChars(s, utf);\n\tenv->DeleteLocalRef(s);\n\treturn str;\n}\t// end of GetUTFString\n\n/***********************************************************************/\n/*  Screen for errors.                                                 */\n/***********************************************************************/\nbool JAVAConn::Check(jint rc)\n{\n\tjstring s;\n\n\tif (env->ExceptionCheck()) {\n\t\tjthrowable exc = env->ExceptionOccurred();\n\t\tjmethodID tid = env->GetMethodID(env->FindClass(\"java/lang/Object\"),\n\t\t\t\"toString\", \"()Ljava/lang/String;\");\n\n\t\tif (exc != nullptr && tid != nullptr) {\n\t\t\ts = (jstring)env->CallObjectMethod(exc, tid);\n\t\t\tMsg = GetUTFString(s);\n\t\t} else\n\t\t\tMsg = \"Exception occurred\";\n\n\t\tenv->ExceptionClear();\n\t} else if (rc < 0) {\n\t\ts = (jstring)env->CallObjectMethod(job, errid);\n\t\tMsg = GetUTFString(s);\n\t} else\n\t\tMsg = NULL;\n\n\treturn (Msg != NULL);\n} // end of Check\n\n/***********************************************************************/\n/*  Get MethodID if not exists yet.                                    */\n/***********************************************************************/\nbool JAVAConn::gmID(PGLOBAL g, jmethodID& mid, const char *name, const char *sig)\n{\n\tif (mid == nullptr) {\n\t\tmid = env->GetMethodID(jdi, name, sig);\n\n\t\tif (Check()) {\n\t\t\tstrcpy(g->Message, Msg);\n\t\t\treturn true;\n\t\t} else\n\t\t\treturn false;\n\n\t} else\n\t\treturn false;\n\n} // end of gmID\n\n#if 0\n/***********************************************************************/\n/*  Utility routine.                                                   */\n/***********************************************************************/\nint JAVAConn::GetMaxValue(int n)\n{\n\tjint      m;\n\tjmethodID maxid = nullptr;\n\n\tif (gmID(m_G, maxid, \"GetMaxValue\", \"(I)I\"))\n\t\treturn -1;\n\n\t// call method\n\tif (Check(m = env->CallIntMethod(job, maxid, n)))\n\t\thtrc(\"GetMaxValue: %s\", Msg);\n\n\treturn (int)m;\n} // end of GetMaxValue\n#endif // 0\n\n/***********************************************************************/\n/*  Reset the JVM library.                                             */\n/***********************************************************************/\nvoid JAVAConn::ResetJVM(void)\n{\n\tif (LibJvm) {\n#if defined(__WIN__)\n\t\tFreeLibrary((HMODULE)LibJvm);\n#else   // !__WIN__\n\t\tdlclose(LibJvm);\n#endif  // !__WIN__\n\t\tLibJvm = NULL;\n\t\tCreateJavaVM = NULL;\n\t\tGetCreatedJavaVMs = NULL;\n#if defined(_DEBUG)\n\t\tGetDefaultJavaVMInitArgs = NULL;\n#endif   // _DEBUG\n\t} // endif LibJvm\n\n} // end of ResetJVM\n\n/***********************************************************************/\n/*  Dynamically link the JVM library.                                  */\n/*  The purpose of this function is to allow using the CONNECT plugin  */\n/*  for other table types when the Java JDK is not installed.          */\n/***********************************************************************/\nbool JAVAConn::GetJVM(PGLOBAL g)\n{\n\tint ntry;\n\n\tif (!LibJvm) {\n\t\tchar soname[512];\n\n#if defined(__WIN__)\n\t\tfor (ntry = 0; !LibJvm && ntry < 3; ntry++) {\n\t\t\tif (!ntry && JvmPath) {\n\t\t\t\tstrcat(strcpy(soname, JvmPath), \"\\\\jvm.dll\");\n\t\t\t\tntry = 3;\t\t // No other try\n\t\t\t} else if (ntry < 2 && getenv(\"JAVA_HOME\")) {\n\t\t\t\tstrcpy(soname, getenv(\"JAVA_HOME\"));\n\n\t\t\t\tif (ntry == 1)\n\t\t\t\t\tstrcat(soname, \"\\\\jre\");\n\n\t\t\t\tstrcat(soname, \"\\\\bin\\\\client\\\\jvm.dll\");\n\t\t\t} else {\n\t\t\t\t// Try to find it through the registry\n\t\t\t\tchar version[16];\n\t\t\t\tchar javaKey[64] = \"SOFTWARE\\\\JavaSoft\\\\Java Runtime Environment\";\n\t\t\t\tLONG  rc;\n\t\t\t\tDWORD BufferSize = 16;\n\n\t\t\t\tstrcpy(soname, \"jvm.dll\");\t\t// In case it fails\n\n\t\t\t\tif ((rc = RegGetValue(HKEY_LOCAL_MACHINE, javaKey, \"CurrentVersion\",\n\t\t\t\t\tRRF_RT_ANY, NULL, (PVOID)&version, &BufferSize)) == ERROR_SUCCESS) {\n\t\t\t\t\tstrcat(strcat(javaKey, \"\\\\\"), version);\n\t\t\t\t\tBufferSize = sizeof(soname);\n\n\t\t\t\t\tif ((rc = RegGetValue(HKEY_LOCAL_MACHINE, javaKey, \"RuntimeLib\",\n\t\t\t\t\t\tRRF_RT_ANY, NULL, (PVOID)&soname, &BufferSize)) != ERROR_SUCCESS)\n\t\t\t\t\t\tprintf(\"RegGetValue: rc=%ld\\n\", rc);\n\n\t\t\t\t} // endif rc\n\n\t\t\t\tntry = 3;\t\t // Try this only once\n\t\t\t} // endelse\n\n\t\t\t// Load the desired shared library\n\t\t\tLibJvm = LoadLibrary(soname);\n\t\t}\t// endfor ntry\n\n\t\t// Get the needed entries\n\t\tif (!LibJvm) {\n\t\t\tchar  buf[256];\n\t\t\tDWORD rc = GetLastError();\n\n\t\t\tsprintf(g->Message, MSG(DLL_LOAD_ERROR), rc, soname);\n\t\t\tFormatMessage(FORMAT_MESSAGE_FROM_SYSTEM |\n\t\t\t\t\t\t\t\t\t\tFORMAT_MESSAGE_IGNORE_INSERTS, NULL, rc, 0,\n\t\t\t\t            (LPTSTR)buf, sizeof(buf), NULL);\n\t\t\tstrcat(strcat(g->Message, \": \"), buf);\n\t\t} else if (!(CreateJavaVM = (CRTJVM)GetProcAddress((HINSTANCE)LibJvm,\n\t\t\t                                       \"JNI_CreateJavaVM\"))) {\n\t\t\tsprintf(g->Message, MSG(PROCADD_ERROR), GetLastError(), \"JNI_CreateJavaVM\");\n\t\t\tFreeLibrary((HMODULE)LibJvm);\n\t\t\tLibJvm = NULL;\n\t\t} else if (!(GetCreatedJavaVMs = (GETJVM)GetProcAddress((HINSTANCE)LibJvm,\n\t\t\t                                       \"JNI_GetCreatedJavaVMs\"))) {\n\t\t\tsprintf(g->Message, MSG(PROCADD_ERROR), GetLastError(), \"JNI_GetCreatedJavaVMs\");\n\t\t\tFreeLibrary((HMODULE)LibJvm);\n\t\t\tLibJvm = NULL;\n#if defined(_DEBUG)\n\t\t} else if (!(GetDefaultJavaVMInitArgs = (GETDEF)GetProcAddress((HINSTANCE)LibJvm,\n\t\t\t                                       \"JNI_GetDefaultJavaVMInitArgs\"))) {\n\t\t\tsprintf(g->Message, MSG(PROCADD_ERROR), GetLastError(),\n\t\t\t\t\"JNI_GetDefaultJavaVMInitArgs\");\n\t\t\tFreeLibrary((HMODULE)LibJvm);\n\t\t\tLibJvm = NULL;\n#endif   // _DEBUG\n\t\t} // endif LibJvm\n#else   // !__WIN__\n\t\tconst char *error = NULL;\n\n\t\tfor (ntry = 0; !LibJvm && ntry < 2; ntry++) {\n\t\t\tif (!ntry && JvmPath) {\n\t\t\t\tstrcat(strcpy(soname, JvmPath), \"/libjvm.so\");\n\t\t\t\tntry = 2;\n\t\t\t} else if (!ntry && getenv(\"JAVA_HOME\")) {\n\t\t\t\t// TODO: Replace i386 by a better guess\n\t\t\t\tstrcat(strcpy(soname, getenv(\"JAVA_HOME\")), \"/jre/lib/i386/client/libjvm.so\");\n\t\t\t} else {\t // Will need LD_LIBRARY_PATH to be set\n\t\t\t\tstrcpy(soname, \"libjvm.so\");\n\t\t\t\tntry = 2;\n\t\t\t} // endelse\n\n\t\t\tLibJvm = dlopen(soname, RTLD_LAZY);\n\t\t} // endfor ntry\n\n\t\t\t// Load the desired shared library\n\t\tif (!LibJvm) {\n\t\t\terror = dlerror();\n\t\t\tsprintf(g->Message, MSG(SHARED_LIB_ERR), soname, SVP(error));\n\t\t} else if (!(CreateJavaVM = (CRTJVM)dlsym(LibJvm, \"JNI_CreateJavaVM\"))) {\n\t\t\terror = dlerror();\n\t\t\tsprintf(g->Message, MSG(GET_FUNC_ERR), \"JNI_CreateJavaVM\", SVP(error));\n\t\t\tdlclose(LibJvm);\n\t\t\tLibJvm = NULL;\n\t\t} else if (!(GetCreatedJavaVMs = (GETJVM)dlsym(LibJvm, \"JNI_GetCreatedJavaVMs\"))) {\n\t\t\terror = dlerror();\n\t\t\tsprintf(g->Message, MSG(GET_FUNC_ERR), \"JNI_GetCreatedJavaVMs\", SVP(error));\n\t\t\tdlclose(LibJvm);\n\t\t\tLibJvm = NULL;\n#if defined(_DEBUG)\n\t\t} else if (!(GetDefaultJavaVMInitArgs = (GETDEF)dlsym(LibJvm,\n\t\t\t\"JNI_GetDefaultJavaVMInitArgs\"))) {\n\t\t\terror = dlerror();\n\t\t\tsprintf(g->Message, MSG(GET_FUNC_ERR), \"JNI_GetDefaultJavaVMInitArgs\", SVP(error));\n\t\t\tdlclose(LibJvm);\n\t\t\tLibJvm = NULL;\n#endif   // _DEBUG\n\t\t} // endif LibJvm\n#endif  // !__WIN__\n\n\t} // endif LibJvm\n\n\treturn LibJvm == NULL;\n} // end of GetJVM\n\n/***********************************************************************/\n/*  Open: connect to a data source.                                    */\n/***********************************************************************/\nbool JAVAConn::Open(PGLOBAL g)\n{\n\tbool\t\t brc = true, err = false;\n\tjboolean jt = (trace(1));\n\n\t// Link or check whether jvm library was linked\n\tif (GetJVM(g))\n\t\treturn true;\n\n\t// Firstly check whether the jvm was already created\n\tJavaVM* jvms[1];\n\tjsize   jsz;\n\tjint    rc = GetCreatedJavaVMs(jvms, 1, &jsz);\n\n\tif (rc == JNI_OK && jsz == 1) {\n\t\t// jvm already existing\n\t\tjvm = jvms[0];\n\t\trc = jvm->AttachCurrentThread((void**)&env, nullptr);\n\n\t\tif (rc != JNI_OK) {\n\t\t\tstrcpy(g->Message, \"Cannot attach jvm to the current thread\");\n\t\t\treturn true;\n\t\t} // endif rc\n\n\t} else {\n\t\t/*******************************************************************/\n\t\t/*  Create a new jvm\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t */\n\t\t/*******************************************************************/\n\t\tPSTRG    jpop = new(g)STRING(g, 512, \"-Djava.class.path=.\");\n\t\tchar    *cp = NULL;\n\t\tchar     sep;\n\n#if defined(__WIN__)\n\t\tsep = ';';\n#define N 1\n\t\t//#define N 2\n\t\t//#define N 3\n#else\n\t\tsep = ':';\n#define N 1\n#endif\n\n\t\t// Add wrappers jar files \n\t\tAddJars(jpop, sep);\n\n\t\t//================== prepare loading of Java VM ============================\n\t\tJavaVMInitArgs vm_args;                        // Initialization arguments\n\t\tJavaVMOption* options = new JavaVMOption[N];   // JVM invocation options\n\n\t\t// where to find java .class\n\t\tif (ClassPath && *ClassPath) {\n\t\t\tjpop->Append(sep);\n\t\t\tjpop->Append(ClassPath);\n\t\t}\t// endif ClassPath\n\n\t\t\t// Java source will be compiled as a jar file installed in the plugin dir\n\t\tjpop->Append(sep);\n\t\tjpop->Append(GetPluginDir());\n\t\tjpop->Append(\"JdbcInterface.jar\");\n\n\t\t// All wrappers are pre-compiled in JavaWrappers.jar in the plugin dir\n\t\tjpop->Append(sep);\n\t\tjpop->Append(GetPluginDir());\n\t\tjpop->Append(\"JavaWrappers.jar\");\n\n\t\tif ((cp = getenv(\"CLASSPATH\"))) {\n\t\t\tjpop->Append(sep);\n\t\t\tjpop->Append(cp);\n\t\t} // endif cp\n\n\t\tif (trace(1)) {\n\t\t\thtrc(\"ClassPath=%s\\n\", ClassPath);\n\t\t\thtrc(\"CLASSPATH=%s\\n\", cp);\n\t\t\thtrc(\"%s\\n\", jpop->GetStr());\n\t\t} // endif trace\n\n\t\toptions[0].optionString = jpop->GetStr();\n#if N == 2\n\t\toptions[1].optionString = \"-Xcheck:jni\";\n#endif\n#if N == 3\n\t\toptions[1].optionString = \"-Xms256M\";\n\t\toptions[2].optionString = \"-Xmx512M\";\n#endif\n#if defined(_DEBUG)\n\t\tvm_args.version = JNI_VERSION_1_2;             // minimum Java version\n\t\trc = GetDefaultJavaVMInitArgs(&vm_args);\n#else\n\t\tvm_args.version = JNI_VERSION_1_6;             // minimum Java version\n#endif   // _DEBUG\n\t\tvm_args.nOptions = N;                          // number of options\n\t\tvm_args.options = options;\n\t\tvm_args.ignoreUnrecognized = false; // invalid options make the JVM init fail\n\n\t\t//=============== load and initialize Java VM and JNI interface =============\n\t\trc = CreateJavaVM(&jvm, (void**)&env, &vm_args);  // YES !!\n\t\tdelete[] options;    // we then no longer need the initialisation options.\n\n\t\tswitch (rc) {\n\t\t\tcase JNI_OK:\n\t\t\t\tstrcpy(g->Message, \"VM successfully created\");\n\t\t\t\tbrc = false;\n\t\t\t\tbreak;\n\t\t\tcase JNI_ERR:\n\t\t\t\tstrcpy(g->Message, \"Initialising JVM failed: unknown error\");\n\t\t\t\tbreak;\n\t\t\tcase JNI_EDETACHED:\n\t\t\t\tstrcpy(g->Message, \"Thread detached from the VM\");\n\t\t\t\tbreak;\n\t\t\tcase JNI_EVERSION:\n\t\t\t\tstrcpy(g->Message, \"JNI version error\");\n\t\t\t\tbreak;\n\t\t\tcase JNI_ENOMEM:\n\t\t\t\tstrcpy(g->Message, \"Not enough memory\");\n\t\t\t\tbreak;\n\t\t\tcase JNI_EEXIST:\n\t\t\t\tstrcpy(g->Message, \"VM already created\");\n\t\t\t\tbreak;\n\t\t\tcase JNI_EINVAL:\n\t\t\t\tstrcpy(g->Message, \"Invalid arguments\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tsprintf(g->Message, \"Unknown return code %d\", (int)rc);\n\t\t\t\tbreak;\n\t\t} // endswitch rc\n\n\t\tif (trace(1))\n\t\t\thtrc(\"%s\\n\", g->Message);\n\n\t\tif (brc)\n\t\t\treturn true;\n\n\t\t//=============== Display JVM version ===============\n\t\tjint ver = env->GetVersion();\n\t\tprintf(\"JVM Version %d.%d\\n\", ((ver >> 16) & 0x0f), (ver & 0x0f));\n\t} // endif rc\n\n\t// try to find the java wrapper class\n\tjdi = env->FindClass(m_Wrap);\n\n\tif (jdi == nullptr) {\n\t\tsprintf(g->Message, \"ERROR: class %s not found!\", m_Wrap);\n\t\treturn true;\n\t} // endif jdi\n\n#if 0\t\t// Suppressed because it does not make any usable change\n\tif (b && jpath && *jpath) {\n\t\t// Try to add that path the the jvm class path\n\t\tjmethodID alp = env->GetStaticMethodID(jdi, \"addLibraryPath\",\n\t\t\t\"(Ljava/lang/String;)I\");\n\n\t\tif (alp == nullptr) {\n\t\t\tenv->ExceptionDescribe();\n\t\t\tenv->ExceptionClear();\n\t\t} else {\n\t\t\tchar *msg;\n\t\t\tjstring path = env->NewStringUTF(jpath);\n\t\t\trc = env->CallStaticIntMethod(jdi, alp, path);\n\n\t\t\tif ((msg = Check(rc))) {\n\t\t\t\tstrcpy(g->Message, msg);\n\t\t\t\tenv->DeleteLocalRef(path);\n\t\t\t\treturn RC_FX;\n\t\t\t} else switch (rc) {\n\t\t\t\tcase JNI_OK:\n\t\t\t\t\tprintf(\"jpath added\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase JNI_EEXIST:\n\t\t\t\t\tprintf(\"jpath already exist\\n\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase JNI_ERR:\n\t\t\t\tdefault:\n\t\t\t\t\tstrcpy(g->Message, \"Error adding jpath\");\n\t\t\t\t\tenv->DeleteLocalRef(path);\n\t\t\t\t\treturn RC_FX;\n\t\t\t}\t// endswitch rc\n\n\t\t\tenv->DeleteLocalRef(path);\n\t\t}\t// endif alp\n\n\t}\t// endif jpath\n#endif // 0\n\n\t// if class found, continue\n\tjmethodID ctor = env->GetMethodID(jdi, \"<init>\", \"(Z)V\");\n\n\tif (ctor == nullptr) {\n\t\tsprintf(g->Message, \"ERROR: %s constructor not found!\", m_Wrap);\n\t\treturn true;\n\t} else\n\t\tjob = env->NewObject(jdi, ctor, jt);\n\n\tif (job == nullptr) {\n\t\tsprintf(g->Message, \"%s class object not constructed!\", m_Wrap);\n\t\treturn true;\n\t} // endif job\n\n\t// If the object is successfully constructed, \n\t// we can then search for the method we want to call, \n\t// and invoke it for the object:\n\terrid = env->GetMethodID(jdi, \"GetErrmsg\", \"()Ljava/lang/String;\");\n\n\tif (env->ExceptionCheck()) {\n\t\tstrcpy(g->Message, \"ERROR: method GetErrmsg() not found!\");\n\t\tenv->ExceptionDescribe();\n\t\tenv->ExceptionClear();\n\t\treturn true;\n\t} // endif Check\n\n\t/*********************************************************************/\n\t/*  Link a Fblock. This make possible to automatically close it      */\n\t/*  in case of error (throw).                                        */\n\t/*********************************************************************/\n\tPDBUSER dbuserp = (PDBUSER)g->Activityp->Aptr;\n\n\tfp = (PFBLOCK)PlugSubAlloc(g, NULL, sizeof(FBLOCK));\n\tfp->Type = TYPE_FB_JAVA;\n\tfp->Fname = NULL;\n\tfp->Next = dbuserp->Openlist;\n\tdbuserp->Openlist = fp;\n\tfp->Count = 1;\n\tfp->Length = 0;\n\tfp->Memory = NULL;\n\tfp->Mode = MODE_ANY;\n\tfp->File = this;\n\tfp->Handle = 0;\n\n\tm_Opened = true;\n\treturn false;\n} // end of Open\n\n/***********************************************************************/\n/*  Disconnect connection                                              */\n/***********************************************************************/\nvoid JAVAConn::Close()\n{\n\tjint rc;\n\n\tif (m_Connected) {\n\t\tjmethodID did = nullptr;\n\n\t\t// Could have been detached in case of join\n\t\trc = jvm->AttachCurrentThread((void**)&env, nullptr);\n\n\t\tif (gmID(m_G, did, DiscFunc, \"()I\"))\n\t\t\tprintf(\"%s\\n\", Msg);\n\t\telse if (Check(env->CallIntMethod(job, did)))\n\t\t\tprintf(\"%s: %s\\n\", DiscFunc, Msg);\n\n\t\tm_Connected = false;\n\t}\t// endif m_Connected\n\n\tif ((rc = jvm->DetachCurrentThread()) != JNI_OK)\n\t\tprintf(\"DetachCurrentThread: rc=%d\\n\", (int)rc);\n\n\tif (fp)\n\t\tfp->Count = 0;\n\n\tm_Opened = false;\n} // end of Close\n",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/connect/tabrest.cpp": "/************** tabrest C++ Program Source Code File (.CPP) ************/\n/* PROGRAM NAME: tabrest   Version 1.7                                 */\n/*  (C) Copyright to the author Olivier BERTRAND          2018 - 2019  */\n/*  This program is the REST Web API support for MariaDB.              */\n/*  When compiled without MARIADB defined, it is the EOM module code.  */\n/***********************************************************************/\n\n/***********************************************************************/\n/*  Definitions needed by the included files.                          */\n/***********************************************************************/\n#if defined(MARIADB)\n#include <my_global.h>    // All MariaDB stuff\n#else   // !MARIADB       OEM module\n#include \"mini-global.h\"\n#define _MAX_PATH 260\n#if !defined(REST_SOURCE)\n#if defined(__WIN__) || defined(_WINDOWS)\n#include <windows.h>\n#else\t\t // !__WIN__\n#define __stdcall\n#include <dlfcn.h>         // dlopen(), dlclose(), dlsym() ...\n#endif   // !__WIN__\n#endif\t // !REST_SOURCE\n#define _OS_H_INCLUDED     // Prevent os.h to be called\n#endif  // !MARIADB\n\n/***********************************************************************/\n/*  Include application header files:                                  */\n/*  global.h    is header containing all global declarations.          */\n/*  plgdbsem.h  is header containing the DB application declarations.  */\n/***********************************************************************/\n#include \"global.h\"\n#include \"plgdbsem.h\"\n#include \"xtable.h\"\n#include \"filamtxt.h\"\n#include \"tabdos.h\"\n#include \"plgxml.h\"\n#if defined(XML_SUPPORT)\n#include \"tabxml.h\"\n#endif   // XML_SUPPORT\n#include \"tabjson.h\"\n#include \"tabfmt.h\"\n#include \"tabrest.h\"\n\nstatic XGETREST getRestFnc = NULL;\n\n#if !defined(MARIADB)\n/***********************************************************************/\n/*  DB static variables.                                               */\n/***********************************************************************/\nint    TDB::Tnum;\nint    DTVAL::Shift;\nint    CSORT::Limit = 0;\ndouble CSORT::Lg2 = log(2.0);\nsize_t CSORT::Cpn[1000] = { 0 };\n\n/***********************************************************************/\n/*  These functions are exported from the REST library.                */\n/***********************************************************************/\nextern \"C\" {\n  PTABDEF __stdcall GetREST(PGLOBAL, void*);\n  PQRYRES __stdcall ColREST(PGLOBAL, PTOS, char*, char*, bool);\n} // extern \"C\"\n\n/***********************************************************************/\n/*  This function returns a table definition class.                    */\n/***********************************************************************/\nPTABDEF __stdcall GetREST(PGLOBAL g, void *memp)\n{\n  return new(g, memp) RESTDEF;\n} // end of GetREST\n#endif   // !MARIADB\n\n/***********************************************************************/\n/*  GetREST: get the external TABDEF from OEM module.                  */\n/***********************************************************************/\nXGETREST GetRestFunction(PGLOBAL g)\n{\n\tif (getRestFnc)\n\t\treturn getRestFnc;\n\t\n#if !defined(MARIADB) || !defined(REST_SOURCE)\n\tif (trace(515))\n\t\thtrc(\"Looking for GetRest library\\n\");\n\n#if defined(__WIN__) || defined(_WINDOWS)\n\tHANDLE Hdll;\n\tconst char* soname = \"GetRest.dll\";   // Module name\n\n\tif (!(Hdll = LoadLibrary(soname))) {\n\t\tchar  buf[256];\n\t\tDWORD rc = GetLastError();\n\n\t\tsprintf(g->Message, MSG(DLL_LOAD_ERROR), rc, soname);\n\t\tFormatMessage(FORMAT_MESSAGE_FROM_SYSTEM |\n\t\t\tFORMAT_MESSAGE_IGNORE_INSERTS, NULL, rc, 0,\n\t\t\t(LPTSTR)buf, sizeof(buf), NULL);\n\t\tstrcat(strcat(g->Message, \": \"), buf);\n\t\treturn NULL;\n\t} // endif Hdll\n\n// Get the function returning an instance of the external DEF class\n\tif (!(getRestFnc = (XGETREST)GetProcAddress((HINSTANCE)Hdll, \"restGetFile\"))) {\n\t\tchar  buf[256];\n\t\tDWORD rc = GetLastError();\n\n\t\tsprintf(g->Message, MSG(PROCADD_ERROR), rc, \"restGetFile\");\n\t\tFormatMessage(FORMAT_MESSAGE_FROM_SYSTEM |\n\t\t\tFORMAT_MESSAGE_IGNORE_INSERTS, NULL, rc, 0,\n\t\t\t(LPTSTR)buf, sizeof(buf), NULL);\n\t\tstrcat(strcat(g->Message, \": \"), buf);\n\t\tFreeLibrary((HMODULE)Hdll);\n\t\treturn NULL;\n\t} // endif getRestFnc\n#else   // !__WIN__\n\tvoid* Hso;\n\tconst char* error = NULL;\n\tconst char* soname = \"GetRest.so\";   // Module name\n\n\t// Load the desired shared library\n\tif (!(Hso = dlopen(soname, RTLD_LAZY))) {\n\t\terror = dlerror();\n\t\tsprintf(g->Message, MSG(SHARED_LIB_ERR), soname, SVP(error));\n\t\treturn NULL;\n\t} // endif Hdll\n\n// Get the function returning an instance of the external DEF class\n\tif (!(getRestFnc = (XGETREST)dlsym(Hso, \"restGetFile\"))) {\n\t\terror = dlerror();\n\t\tsprintf(g->Message, MSG(GET_FUNC_ERR), \"restGetFile\", SVP(error));\n\t\tdlclose(Hso);\n\t\treturn NULL;\n\t} // endif getdef\n#endif  // !__WIN__\n#else\n\tgetRestFnc = restGetFile;\n#endif\n\n\treturn getRestFnc;\n} // end of GetRestFunction\n\n/***********************************************************************/\n/*  Return the columns definition to MariaDB.                          */\n/***********************************************************************/\n#if defined(MARIADB)\nPQRYRES RESTColumns(PGLOBAL g, PTOS tp, char *tab, char *db, bool info)\n#else   // !MARIADB\nPQRYRES __stdcall ColREST(PGLOBAL g, PTOS tp, char *tab, char *db, bool info)\n#endif  // !MARIADB\n{\n  PQRYRES qrp= NULL;\n  char filename[_MAX_PATH + 1];  // MAX PATH ???\n  PCSZ http, uri, fn, ftype;\n\tXGETREST grf = GetRestFunction(g);\n\n\tif (!grf)\n\t\treturn NULL;\n\n  http = GetStringTableOption(g, tp, \"Http\", NULL);\n  uri = GetStringTableOption(g, tp, \"Uri\", NULL);\n  fn = GetStringTableOption(g, tp, \"Filename\", \"rest.json\");\n#if defined(MARIADB)\n  ftype = GetStringTableOption(g, tp, \"Type\", \"JSON\");\n#else   // !MARIADB\n  // OEM tables must specify the file type\n  ftype = GetStringTableOption(g, tp, \"Ftype\", \"JSON\");\n#endif  // !MARIADB\n\n  //  We used the file name relative to recorded datapath\n  strcat(strcat(strcat(strcpy(filename, \".\"), slash), db), slash);\n  strncat(filename, fn, _MAX_PATH - strlen(filename));\n\n  // Retrieve the file from the web and copy it locally\n\tif (http && grf(g->Message, trace(515), http, uri, filename)) {\n\t\t\t// sprintf(g->Message, \"Failed to get file at %s\", http);\n  } else if (!stricmp(ftype, \"JSON\"))\n    qrp = JSONColumns(g, db, NULL, tp, info);\n  else if (!stricmp(ftype, \"CSV\"))\n    qrp = CSVColumns(g, NULL, tp, info);\n#if defined(XML_SUPPORT)\n\telse if (!stricmp(ftype, \"XML\"))\n\t\tqrp = XMLColumns(g, db, tab, tp, info);\n#endif   // XML_SUPPORT\n\telse\n    sprintf(g->Message, \"Usupported file type %s\", ftype);\n\n  return qrp;\n} // end of RESTColumns\n\n/* -------------------------- Class RESTDEF -------------------------- */\n\n/***********************************************************************/\n/*  DefineAM: define specific AM block values.                         */\n/***********************************************************************/\nbool RESTDEF::DefineAM(PGLOBAL g, LPCSTR am, int poff)\n{\n\tchar    filename[_MAX_PATH + 1];\n  int     rc = 0, n;\n\tbool    xt = trace(515);\n\tLPCSTR  ftype;\n\tXGETREST grf = GetRestFunction(g);\n\n\tif (!grf)\n\t\treturn true;\n\n#if defined(MARIADB)\n  ftype = GetStringCatInfo(g, \"Type\", \"JSON\");\n#else   // !MARIADB\n  // OEM tables must specify the file type\n  ftype = GetStringCatInfo(g, \"Ftype\", \"JSON\");\n#endif  // !MARIADB\n\n  if (xt)\n    htrc(\"ftype = %s am = %s\\n\", ftype, SVP(am));\n\n  n = (!stricmp(ftype, \"JSON\")) ? 1\n#if defined(XML_SUPPORT)\n    : (!stricmp(ftype, \"XML\"))  ? 2\n#endif   // XML_SUPPORT\n    : (!stricmp(ftype, \"CSV\"))  ? 3 : 0;\n\n  if (n == 0) {\n    htrc(\"DefineAM: Unsupported REST table type %s\", am);\n    sprintf(g->Message, \"Unsupported REST table type %s\", am);\n    return true;\n  } // endif n\n\n  Http = GetStringCatInfo(g, \"Http\", NULL);\n  Uri = GetStringCatInfo(g, \"Uri\", NULL);\n  Fn = GetStringCatInfo(g, \"Filename\", \"rest.json\");\n\n  //  We used the file name relative to recorded datapath\n  //PlugSetPath(filename, Fn, GetPath());\n  strcpy(filename, GetPath());\n\tstrncat(filename, Fn, _MAX_PATH - strlen(filename));\n\n  // Retrieve the file from the web and copy it locally\n\trc = grf(g->Message, xt, Http, Uri, filename);\n\n  if (xt)\n    htrc(\"Return from restGetFile: rc=%d\\n\", rc);\n\n  if (rc)\n    return true;\n  else switch (n) {\n    case 1: Tdp = new (g) JSONDEF; break;\n#if defined(XML_SUPPORT)\n\t\tcase 2: Tdp = new (g) XMLDEF;  break;\n#endif   // XML_SUPPORT\n    case 3: Tdp = new (g) CSVDEF;  break;\n    default: Tdp = NULL;\n  } // endswitch n\n\n  // Do make the table/view definition\n  if (Tdp && Tdp->Define(g, Cat, Name, Schema, \"REST\"))\n    Tdp = NULL; // Error occured\n\n  if (xt)\n    htrc(\"Tdp defined\\n\", rc);\n\n  // Return true in case of error\n  return (Tdp == NULL);\n} // end of DefineAM\n\n/***********************************************************************/\n/*  GetTable: makes a new Table Description Block.                     */\n/***********************************************************************/\nPTDB RESTDEF::GetTable(PGLOBAL g, MODE m)\n{\n  if (trace(515))\n    htrc(\"REST GetTable mode=%d\\n\", m);\n\n  if (m != MODE_READ && m != MODE_READX) {\n    strcpy(g->Message, \"REST tables are currently read only\");\n    return NULL;\n  } // endif m\n\n  return Tdp->GetTable(g, m); // Leave file type do the job\n} // end of GetTable\n\n/* ---------------------- End of Class RESTDEF ----------------------- */\n",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/connect/reldef.cpp": "/************* RelDef CPP Program Source Code File (.CPP) **************/\n/* PROGRAM NAME: RELDEF                                                */\n/* -------------                                                       */\n/*  Version 1.7                                                        */\n/*                                                                     */\n/* COPYRIGHT:                                                          */\n/* ----------                                                          */\n/*  (C) Copyright to the author Olivier BERTRAND          2004-2019    */\n/*                                                                     */\n/* WHAT THIS PROGRAM DOES:                                             */\n/* -----------------------                                             */\n/*  This program are the DB definition related routines.               */\n/*                                                                     */\n/***********************************************************************/\n\n/***********************************************************************/\n/*  Include relevant MariaDB header file.                              */\n/***********************************************************************/\n#include \"my_global.h\"\n#if defined(__WIN__)\n#include <sqlext.h>\n#else\n//#include <dlfcn.h>          // dlopen(), dlclose(), dlsym() ...\n#include \"osutil.h\"\n//#include \"sqlext.h\"\n#endif\n#include \"handler.h\"\n\n/***********************************************************************/\n/*  Include application header files                                   */\n/*                                                                     */\n/*  global.h     is header containing all global declarations.         */\n/*  plgdbsem.h   is header containing DB application declarations.     */\n/*  catalog.h    is header containing DB description declarations.     */\n/***********************************************************************/\n#include \"global.h\"\n#include \"plgdbsem.h\"\n#include \"reldef.h\"\n#include \"colblk.h\"\n#include \"tabcol.h\"\n#include \"filamap.h\"\n#include \"filamfix.h\"\n#if defined(VCT_SUPPORT)\n#include \"filamvct.h\"\n#endif   // VCT_SUPPORT\n#if defined(GZ_SUPPORT)\n#include \"filamgz.h\"\n#endif   // GZ_SUPPORT\n#include \"tabdos.h\"\n#include \"valblk.h\"\n#include \"tabmul.h\"\n#include \"ha_connect.h\"\n#include \"mycat.h\"\n\n#if !defined(__WIN__)\nextern handlerton *connect_hton;\n#endif   // !__WIN__\n\n/***********************************************************************/\n/*  External function.                                                 */\n/***********************************************************************/\nUSETEMP UseTemp(void);\nchar   *GetPluginDir(void);\nPQRYRES OEMColumns(PGLOBAL g, PTOS topt, char* tab, char* db, bool info);\n\n/***********************************************************************/\n/*  OEMColumns: Get table column info for an OEM table.                */\n/***********************************************************************/\nPQRYRES OEMColumns(PGLOBAL g, PTOS topt, char* tab, char* db, bool info)\n{\n\ttypedef PQRYRES(__stdcall* XCOLDEF) (PGLOBAL, void*, char*, char*, bool);\n\tconst char* module, * subtype;\n\tchar    c, soname[_MAX_PATH], getname[40] = \"Col\";\n#if defined(__WIN__)\n\tHANDLE  hdll;               /* Handle to the external DLL            */\n#else   // !__WIN__\n\tvoid* hdll;               /* Handle for the loaded shared library  */\n#endif  // !__WIN__\n\tXCOLDEF coldef = NULL;\n\tPQRYRES qrp = NULL;\n\n\tmodule = topt->module;\n\tsubtype = topt->subtype;\n\n\tif (!module || !subtype)\n\t\treturn NULL;\n\n\t/*********************************************************************/\n\t/*  Ensure that the .dll doesn't have a path.                        */\n\t/*  This is done to ensure that only approved dll from the system    */\n\t/*  directories are used (to make this even remotely secure).        */\n\t/*********************************************************************/\n\tif (check_valid_path(module, strlen(module))) {\n\t\tstrcpy(g->Message, \"Module cannot contain a path\");\n\t\treturn NULL;\n\t}\n\telse\n\t\tPlugSetPath(soname, module, GetPluginDir());\n\n\t// The exported name is always in uppercase\n\tfor (int i = 0; ; i++) {\n\t\tc = subtype[i];\n\t\tgetname[i + 3] = toupper(c);\n\t\tif (!c) break;\n\t} // endfor i\n\n#if defined(__WIN__)\n\t// Load the Dll implementing the table\n\tif (!(hdll = LoadLibrary(soname))) {\n\t\tchar  buf[256];\n\t\tDWORD rc = GetLastError();\n\n\t\tsprintf(g->Message, MSG(DLL_LOAD_ERROR), rc, soname);\n\t\tFormatMessage(FORMAT_MESSAGE_FROM_SYSTEM |\n\t\t\tFORMAT_MESSAGE_IGNORE_INSERTS, NULL, rc, 0,\n\t\t\t(LPTSTR)buf, sizeof(buf), NULL);\n\t\tstrcat(strcat(g->Message, \": \"), buf);\n\t\treturn NULL;\n\t} // endif hDll\n\n// Get the function returning an instance of the external DEF class\n\tif (!(coldef = (XCOLDEF)GetProcAddress((HINSTANCE)hdll, getname))) {\n\t\tsprintf(g->Message, MSG(PROCADD_ERROR), GetLastError(), getname);\n\t\tFreeLibrary((HMODULE)hdll);\n\t\treturn NULL;\n\t} // endif coldef\n#else   // !__WIN__\n\tconst char* error = NULL;\n\n\t// Load the desired shared library\n\tif (!(hdll = dlopen(soname, RTLD_LAZY))) {\n\t\terror = dlerror();\n\t\tsprintf(g->Message, MSG(SHARED_LIB_ERR), soname, SVP(error));\n\t\treturn NULL;\n\t} // endif Hdll\n\n// Get the function returning an instance of the external DEF class\n\tif (!(coldef = (XCOLDEF)dlsym(hdll, getname))) {\n\t\terror = dlerror();\n\t\tsprintf(g->Message, MSG(GET_FUNC_ERR), getname, SVP(error));\n\t\tdlclose(hdll);\n\t\treturn NULL;\n\t} // endif coldef\n#endif  // !__WIN__\n\n\t// Just in case the external Get function does not set error messages\n\tsprintf(g->Message, \"Error getting column info from %s\", subtype);\n\n\t// Get the table column definition\n\tqrp = coldef(g, topt, tab, db, info);\n\n#if defined(__WIN__)\n\tFreeLibrary((HMODULE)hdll);\n#else   // !__WIN__\n\tdlclose(hdll);\n#endif  // !__WIN__\n\n\treturn qrp;\n} // end of OEMColumns\n\n/* --------------------------- Class RELDEF -------------------------- */\n\n/***********************************************************************/\n/*  RELDEF Constructor.                                                */\n/***********************************************************************/\nRELDEF::RELDEF(void)\n  {\n  Next = NULL;\n  To_Cols = NULL;\n  Name = NULL;\n  Database = NULL;\n  Cat = NULL;\n  Hc = NULL;\n  } // end of RELDEF constructor\n\n/***********************************************************************/\n/*  This function return a pointer to the Table Option Struct.         */\n/***********************************************************************/\nPTOS RELDEF::GetTopt(void)\n  {\n  return Hc->GetTableOptionStruct();\n  } // end of GetTopt\n\n/***********************************************************************/\n/*  This function sets an integer table information.                   */\n/***********************************************************************/\nbool RELDEF::SetIntCatInfo(PCSZ what, int n)\n  {\n  return Hc->SetIntegerOption(what, n);\n  } // end of SetIntCatInfo\n\n/***********************************************************************/\n/*  This function returns integer table information.                   */\n/***********************************************************************/\nint RELDEF::GetIntCatInfo(PCSZ what, int idef)\n  {\n  int n= Hc->GetIntegerOption(what);\n\n  return (n == NO_IVAL) ? idef : n;\n  } // end of GetIntCatInfo\n\n/***********************************************************************/\n/*  This function returns Boolean table information.                   */\n/***********************************************************************/\nbool RELDEF::GetBoolCatInfo(PCSZ what, bool bdef)\n  {\n  bool b= Hc->GetBooleanOption(what, bdef);\n\n  return b;\n  } // end of GetBoolCatInfo\n\n/***********************************************************************/\n/*  This function returns size catalog information.                    */\n/***********************************************************************/\nint RELDEF::GetSizeCatInfo(PCSZ what, PCSZ sdef)\n  {\n  char c;\n  PCSZ s;\n  int  i, n= 0;\n\n  if (!(s= Hc->GetStringOption(what)))\n    s= sdef;\n\n  if ((i= sscanf(s, \" %d %c \", &n, &c)) == 2)\n    switch (toupper(c)) {\n      case 'M':\n        n *= 1024;\n        // fall through\n      case 'K':\n        n *= 1024;\n      } // endswitch c\n\n  return n;\n} // end of GetSizeCatInfo\n\n/***********************************************************************/\n/*  This function sets char table information in buf.                  */\n/***********************************************************************/\nint RELDEF::GetCharCatInfo(PCSZ what, PCSZ sdef, char *buf, int size)\n  {\n  PCSZ s= Hc->GetStringOption(what);\n\n  strncpy(buf, ((s) ? s : sdef), size);\n  return size;\n  } // end of GetCharCatInfo\n\n/***********************************************************************/\n/*  To be used by any TDB's.                                           */\n/***********************************************************************/\nbool RELDEF::Partitioned(void)\n  {\n  return Hc->IsPartitioned();\n  } // end of Partitioned\n\n/***********************************************************************/\n/*  This function returns string table information.                    */\n/*  Default parameter is \"*\" to get the handler default.               */\n/***********************************************************************/\nchar *RELDEF::GetStringCatInfo(PGLOBAL g, PCSZ what, PCSZ sdef)\n  {\n  char *sval = NULL;\n  PCSZ  name, s= Hc->GetStringOption(what, sdef);\n\n  if (s) {\n    if (!Hc->IsPartitioned() ||\n        (stricmp(what, \"filename\") && stricmp(what, \"tabname\")\n                                   && stricmp(what, \"connect\")))\n      sval= PlugDup(g, s);\n    else\n      sval= (char*)s;\n\n  } else if (!stricmp(what, \"filename\")) {\n    // Return default file name\n    PCSZ ftype= Hc->GetStringOption(\"Type\", \"*\");\n    int  i, n;\n\n    if (IsFileType(GetTypeID(ftype))) {\n      name= Hc->GetPartName();\n      sval= (char*)PlugSubAlloc(g, NULL, strlen(name) + 12);\n      strcat(strcpy(sval, name), \".\");\n      n= strlen(sval);\n\n      // Fold ftype to lower case\n      for (i= 0; i < 12; i++)\n        if (!ftype[i]) {\n          sval[n+i]= 0;\n          break;\n        } else\n          sval[n+i]= tolower(ftype[i]);\n\n      } // endif FileType\n\n  } // endif s\n\n  return sval;\n  } // end of GetStringCatInfo\n\n/* --------------------------- Class TABDEF -------------------------- */\n\n/***********************************************************************/\n/*  TABDEF Constructor.                                                */\n/***********************************************************************/\nTABDEF::TABDEF(void)\n  {\n  Schema = NULL;\n  Desc = NULL;\n\tRecfm = RECFM_DFLT;\n  Catfunc = FNC_NO;\n  Card = 0;\n  Elemt = 0;\n  Sort = 0;\n  Multiple = 0;\n  Degree = 0;\n  Pseudo = 0;\n  Read_Only = false;\n  m_data_charset = NULL;\n  csname = NULL;\n  } // end of TABDEF constructor\n\n/***********************************************************************/\n/*  Return the table format.                                           */\n/***********************************************************************/\nRECFM TABDEF::GetTableFormat(const char* type)\n{\n\tRECFM recfm = Recfm;\n\n\tif (Catfunc != FNC_NO)\n\t\trecfm = RECFM_NAF;\n\telse if (recfm == RECFM_DFLT)\n\t\t// Default format depends on the table type\n\t\tswitch (GetTypeID(type)) {\n\t\tcase TAB_DOS: recfm = RECFM_VAR; break;\n\t\tcase TAB_CSV: recfm = RECFM_CSV; break;\n\t\tcase TAB_FMT: recfm = RECFM_FMT; break;\n\t\tcase TAB_FIX: recfm = RECFM_FIX; break;\n\t\tcase TAB_BIN: recfm = RECFM_BIN; break;\n\t\tcase TAB_VEC: recfm = RECFM_VCT; break;\n\t\tcase TAB_DBF: recfm = RECFM_DBF; break;\n\t\tcase TAB_XML: recfm = RECFM_XML; break;\n\t\tcase TAB_DIR: recfm = RECFM_DIR; break;\n\t\tdefault:\t\t\trecfm = RECFM_NAF; break;\n\t\t} // endswitch type\n\n\treturn recfm;\n} // end of GetTableFormat\n\n/***********************************************************************/\n/*  Define: initialize the table definition block from XDB file.       */\n/***********************************************************************/\nbool TABDEF::Define(PGLOBAL g, PCATLG cat,\n                    LPCSTR name, LPCSTR schema, LPCSTR am)\n{\n  int   poff = 0;\n\n  Hc = ((MYCAT*)cat)->GetHandler();\n  Name = (PSZ)name;\n  Schema = (PSZ)Hc->GetDBName(schema);\n  Cat = cat;\n  Catfunc = GetFuncID(GetStringCatInfo(g, \"Catfunc\", NULL));\n  Elemt = GetIntCatInfo(\"Elements\", 0);\n  Multiple = GetIntCatInfo(\"Multiple\", 0);\n  Degree = GetIntCatInfo(\"Degree\", 0);\n  Read_Only = GetBoolCatInfo(\"ReadOnly\", false);\n  const char *data_charset_name= GetStringCatInfo(g, \"Data_charset\", NULL);\n  m_data_charset= data_charset_name ?\n                  get_charset_by_csname(data_charset_name, MY_CS_PRIMARY, 0):\n                  NULL;\n  csname = GetStringCatInfo(g, \"Table_charset\", NULL);\n\n\t// Do the definition of AM specific fields\n\tif (DefineAM(g, am, 0))\n\t\treturn true;\n\n\t// Get The column definitions\n\tif (stricmp(am, \"OEM\") && GetColCatInfo(g) < 0)\n\t\treturn true;\n\n\tHc->tshp = NULL;    // TO BE CHECKED\n\treturn false;\n} // end of Define\n\n/***********************************************************************/\n/*  This function returns the database data path.                      */\n/***********************************************************************/\nPCSZ TABDEF::GetPath(void)\n  {\n  return (Database) ? Database : (Hc) ? Hc->GetDataPath() : NULL;\n  } // end of GetPath\n\n/***********************************************************************/\n/*  This function returns column table information.                    */\n/***********************************************************************/\nint TABDEF::GetColCatInfo(PGLOBAL g)\n  {\n  char    *type = GetStringCatInfo(g, \"Type\", \"*\");\n  char     c, fty, eds;\n  int      i, n, loff, poff, nof, nlg;\n  void    *field = NULL;\n  RECFM    trf;\n  PCOLDEF  cdp, lcdp = NULL, tocols= NULL;\n  PCOLINFO pcf= (PCOLINFO)PlugSubAlloc(g, NULL, sizeof(COLINFO));\n\n  memset(pcf, 0, sizeof(COLINFO));\n\n  // Get the table format\n\ttrf = GetTableFormat(type);\n\n  // Take care of the column definitions\n  i= poff= nof= nlg= 0;\n\n#if defined(__WIN__)\n  // Offsets of HTML and DIR tables start from 0, DBF at 1\n  loff= (trf == RECFM_DBF) ? 1 : (trf  == RECFM_XML || trf  == RECFM_DIR) ? -1 : 0;\n#else   // !__WIN__\n  // Offsets of HTML tables start from 0, DIR and DBF at 1\n  loff = (trf  == RECFM_DBF || trf  == RECFM_DIR) ? 1 : (trf  == RECFM_XML) ? -1 : 0;\n#endif  // !__WIN__\n\n  while (true) {\n    // Default Offset depends on table format\n    switch (trf ) {\n      case RECFM_VAR:\n      case RECFM_FIX:\n      case RECFM_BIN:\n      case RECFM_VCT:\n      case RECFM_DBF:\n        poff= loff + nof;        // Default next offset\n        nlg= MY_MAX(nlg, poff);    // Default lrecl\n        break;\n      case RECFM_CSV:\n      case RECFM_FMT:\n        nlg+= nof;\n      case RECFM_DIR:\n      case RECFM_XML:\n        poff= loff + (pcf->Flags & U_VIRTUAL ? 0 : 1);\n        break;\n      //case RECFM_INI:\n      //case RECFM_MAC:\n      //case RECFM_TBL:\n      //case RECFM_XCL:\n      //case RECFM_OCCUR:\n      //case RECFM_PRX:\n      case RECFM_OEM:\n        poff = 0;      // Offset represents an independant flag\n        break;\n      default:         // PLG ODBC JDBC MYSQL WMI...\n        poff = 0;      // NA\n        break;\n      } // endswitch trf \n\n//    do {\n      field= Hc->GetColumnOption(g, field, pcf);\n//    } while (field && (*pcf->Name =='*' /*|| pcf->Flags & U_VIRTUAL*/));\n\n    if (trf  == RECFM_DBF && pcf->Type == TYPE_DATE && !pcf->Datefmt) {\n      // DBF date format defaults to 'YYYMMDD'\n      pcf->Datefmt= \"YYYYMMDD\";\n      pcf->Length= 8;\n      } // endif trf \n\n    if (!field)\n      break;\n\n    // Allocate the column description block\n    cdp= new(g) COLDEF;\n\n    if ((nof= cdp->Define(g, NULL, pcf, poff)) < 0)\n      return -1;             // Error, probably unhandled type\n    else\n      loff= cdp->GetOffset();\n\n    switch (trf ) {\n      case RECFM_VCT:\n        cdp->SetOffset(0);     // Not to have shift\n      case RECFM_BIN:\n        // BIN/VEC are packed by default\n        if (nof) {\n          // Field width is the internal representation width\n          // that can also depend on the column format\n          fty = cdp->Decode ? 'C' : 'X';\n          eds = 0;\n          n = 0;\n\n          if (cdp->Fmt && !cdp->Decode) {\n            for (i = 0; cdp->Fmt[i]; i++) {\n              c = toupper(cdp->Fmt[i]);\n\n              if (isdigit(c))\n                n = (n * 10 + (c - '0'));\n              else if (c == 'L' || c == 'B' || c == 'H')\n                eds = c;\n              else\n                fty = c;\n\n              } // endfor i\n\n          } // endif Fmt\n\n          if (n)\n            nof = n;\n          else switch (fty) {\n            case 'X':\n              if (eds && IsTypeChar(cdp->Buf_Type))\n                nof = sizeof(longlong);\n              else\n                nof= cdp->Clen;\n\n              break;\n            case 'C':                         break;\n            case 'R':\n            case 'F': nof = sizeof(float);    break;\n            case 'I': nof = sizeof(int);      break;\n            case 'D': nof = sizeof(double);   break;\n            case 'S': nof = sizeof(short);    break;\n            case 'T': nof = sizeof(char);     break;\n            case 'G': nof = sizeof(longlong); break;\n            default:  /* Wrong format */\n              sprintf(g->Message, \"Invalid format %c\", fty);\n              return -1;\n            } // endswitch fty\n\n          } // endif nof\n\n      default:\n        break;\n      } // endswitch trf \n\n    if (lcdp)\n      lcdp->SetNext(cdp);\n    else\n      tocols= cdp;\n\n    lcdp= cdp;\n    i++;\n    } // endwhile\n\n  // Degree is the the number of defined columns (informational)\n  if (i != GetDegree())\n    SetDegree(i);\n\n  if (GetDefType() == TYPE_AM_DOS) {\n    int     ending, recln= 0;\n\n\t\tending = Hc->GetIntegerOption(\"Ending\");\n\n    // Calculate the default record size\n    switch (trf ) {\n      case RECFM_FIX:\n      case RECFM_BIN:\n        recln= nlg + ending;     // + length of line ending\n        break;\n      case RECFM_VCT:\n        recln= nlg;\n\n//      if ((k= (pak < 0) ? 8 : pak) > 1)\n          // See above for detailed comment\n          // Round up lrecl to multiple of 8 or pak\n//        recln= ((recln + k - 1) / k) * k;\n\n        break;\n      case RECFM_VAR:\n      case RECFM_DBF:\n        recln= nlg;\n        break;\n      case RECFM_CSV:\n      case RECFM_FMT:\n        // The number of separators (assuming an extra one can exist)\n//      recln= poff * ((qotd) ? 3 : 1);  to be investigated\n        recln= nlg + poff * 3;     // To be safe\n      default:\n        break;\n      } // endswitch trf \n\n    // lrecl must be at least recln to avoid buffer overflow\n    if (trace(1))\n      htrc(\"Lrecl: Calculated=%d defined=%d\\n\",\n        recln, Hc->GetIntegerOption(\"Lrecl\"));\n\n    recln = MY_MAX(recln, Hc->GetIntegerOption(\"Lrecl\"));\n    Hc->SetIntegerOption(\"Lrecl\", recln);\n    ((PDOSDEF)this)->SetLrecl(recln);\n\n    if (trace(1))\n      htrc(\"Lrecl set to %d\\n\", recln);\n\n    } // endif TYPE\n\n  // Attach the column definition to the tabdef\n  SetCols(tocols);\n  return poff;\n  } // end of GetColCatInfo\n\n/***********************************************************************/\n/*  SetIndexInfo: retrieve index description from the table structure. */\n/***********************************************************************/\nvoid TABDEF::SetIndexInfo(void)\n  {\n  // Attach new index(es)\n  SetIndx(Hc->GetIndexInfo());\n  } // end of SetIndexInfo\n\n/* --------------------------- Class OEMDEF -------------------------- */\n\n/***********************************************************************/\n/*  GetXdef: get the external TABDEF from OEM module.                  */\n/***********************************************************************/\nPTABDEF OEMDEF::GetXdef(PGLOBAL g)\n  {\n  typedef PTABDEF (__stdcall *XGETDEF) (PGLOBAL, void *);\n  char    c, soname[_MAX_PATH], getname[40] = \"Get\";\n  PTABDEF xdefp;\n  XGETDEF getdef = NULL;\n  PCATLG  cat = Cat;\n\n  /*********************************************************************/\n  /*  Ensure that the module name doesn't have a path.                 */\n  /*  This is done to ensure that only approved libs from the system   */\n  /*  directories are used (to make this even remotely secure).        */\n  /*********************************************************************/\n  if (check_valid_path(Module, strlen(Module))) {\n    strcpy(g->Message, \"Module cannot contain a path\");\n    return NULL;\n  } else\n//  PlugSetPath(soname, Module, GetPluginDir());  // Crashes on Fedora\n    strncat(strcpy(soname, GetPluginDir()), Module,\n\t\t\tsizeof(soname) - strlen(soname) - 1);\n\n#if defined(__WIN__)\n  // Is the DLL already loaded?\n  if (!Hdll && !(Hdll = GetModuleHandle(soname)))\n    // No, load the Dll implementing the function\n    if (!(Hdll = LoadLibrary(soname))) {\n      char  buf[256];\n      DWORD rc = GetLastError();\n\n      sprintf(g->Message, MSG(DLL_LOAD_ERROR), rc, soname);\n      FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM |\n                    FORMAT_MESSAGE_IGNORE_INSERTS, NULL, rc, 0,\n                    (LPTSTR)buf, sizeof(buf), NULL);\n      strcat(strcat(g->Message, \": \"), buf);\n      return NULL;\n      } // endif hDll\n\n  // The exported name is always in uppercase\n  for (int i = 0; ; i++) {\n    c = Subtype[i];\n    getname[i + 3] = toupper(c);\n    if (!c) break;\n    } // endfor i\n\n  // Get the function returning an instance of the external DEF class\n  if (!(getdef = (XGETDEF)GetProcAddress((HINSTANCE)Hdll, getname))) {\n    char  buf[256];\n    DWORD rc = GetLastError();\n\n    sprintf(g->Message, MSG(PROCADD_ERROR), rc, getname);\n    FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM |\n      FORMAT_MESSAGE_IGNORE_INSERTS, NULL, rc, 0,\n      (LPTSTR)buf, sizeof(buf), NULL);\n    strcat(strcat(g->Message, \": \"), buf);\n    FreeLibrary((HMODULE)Hdll);\n    return NULL;\n    } // endif getdef\n#else   // !__WIN__\n  const char *error = NULL;\n\n#if 0  // Don't know what all this stuff does\n  Dl_info dl_info;\n\n  // The OEM lib must retrieve exported CONNECT variables\n  if (dladdr(&connect_hton, &dl_info)) {\n    if (dlopen(dl_info.dli_fname, RTLD_NOLOAD | RTLD_NOW | RTLD_GLOBAL) == 0) {\n      error = dlerror();\n      sprintf(g->Message, \"dlopen failed: %s, OEM not supported\", SVP(error));\n      return NULL;\n      } // endif dlopen\n\n  } else {\n    error = dlerror();\n    sprintf(g->Message, \"dladdr failed: %s, OEM not supported\", SVP(error));\n    return NULL;\n  } // endif dladdr\n#endif // 0\n\n  // Load the desired shared library\n  if (!Hdll && !(Hdll = dlopen(soname, RTLD_LAZY))) {\n    error = dlerror();\n    sprintf(g->Message, MSG(SHARED_LIB_ERR), soname, SVP(error));\n    return NULL;\n    } // endif Hdll\n\n  // The exported name is always in uppercase\n  for (int i = 0; ; i++) {\n    c = Subtype[i];\n    getname[i + 3] = toupper(c);\n    if (!c) break;\n    } // endfor i\n\n  // Get the function returning an instance of the external DEF class\n  if (!(getdef = (XGETDEF)dlsym(Hdll, getname))) {\n    error = dlerror();\n    sprintf(g->Message, MSG(GET_FUNC_ERR), getname, SVP(error));\n    dlclose(Hdll);\n    return NULL;\n    } // endif getdef\n#endif  // !__WIN__\n\n  // Just in case the external Get function does not set error messages\n  sprintf(g->Message, MSG(DEF_ALLOC_ERROR), Subtype);\n\n  // Get the table definition block\n  if (!(xdefp = getdef(g, NULL)))\n    return NULL;\n\n  // Have the external class do its complete definition\n  if (!cat->Cbuf) {\n    // Suballocate a temporary buffer for the entire column section\n    cat->Cblen = GetSizeCatInfo(\"Colsize\", \"8K\");\n    cat->Cbuf = (char*)PlugSubAlloc(g, NULL, cat->Cblen);\n    } // endif Cbuf\n\n  // Ok, return external block\n  return xdefp;\n  } // end of GetXdef\n\n#if 0\n/***********************************************************************/\n/*  DeleteTableFile: Delete an OEM table file if applicable.           */\n/***********************************************************************/\nbool OEMDEF::DeleteTableFile(PGLOBAL g)\n  {\n  if (!Pxdef)\n    Pxdef = GetXdef(g);\n\n  return (Pxdef) ? Pxdef->DeleteTableFile(g) : true;\n  } // end of DeleteTableFile\n#endif // 0\n\n/***********************************************************************/\n/*  Define: initialize the table definition block from XDB file.       */\n/***********************************************************************/\nbool OEMDEF::DefineAM(PGLOBAL g, LPCSTR, int)\n  {\n\tModule = GetStringCatInfo(g, \"Module\", \"\");\n  Subtype = GetStringCatInfo(g, \"Subtype\", Module);\n\n  if (!*Module)\n    Module = Subtype;\n\n  char *desc = (char*)PlugSubAlloc(g, NULL, strlen(Module)\n                                          + strlen(Subtype) + 3);\n  sprintf(desc, \"%s(%s)\", Module, Subtype);\n  Desc = desc;\n\n\t// If define block not here yet, get it now\n\tif (!Pxdef && !(Pxdef = GetXdef(g)))\n\t\treturn true;            // Error\n\n\t// Here \"OEM\" should be replace by a more useful value\n  return Pxdef->Define(g, Cat, Name, Schema, Subtype);\n  } // end of DefineAM\n\n/***********************************************************************/\n/*  GetTable: makes a new Table Description Block.                     */\n/***********************************************************************/\nPTDB OEMDEF::GetTable(PGLOBAL g, MODE mode)\n  {\n  PTDB  tdbp = NULL;\n\n  // If define block not here yet, get it now\n  if (!Pxdef && !(Pxdef = GetXdef(g)))\n    return NULL;            // Error\n\n  /*********************************************************************/\n  /*  Allocate a TDB of the proper type.                               */\n  /*  Column blocks will be allocated only when needed.                */\n  /*********************************************************************/\n  if (!(tdbp = Pxdef->GetTable(g, mode)))\n    return NULL;\n  else if (Multiple && tdbp->GetFtype() == RECFM_OEM)\n    tdbp = new(g) TDBMUL(tdbp);       // No block optimization yet\n\n#if 0\n  /*********************************************************************/\n  /*  The OEM table is based on a file type (currently DOS+ only)      */\n  /*********************************************************************/\n  assert (rfm == RECFM_VAR || rfm == RECFM_FIX ||\n          rfm == RECFM_BIN || rfm == RECFM_VCT);\n\n  PTXF    txfp = NULL;\n  PDOSDEF defp = (PDOSDEF)Pxdef;\n  bool    map = defp->Mapped && mode != MODE_INSERT &&\n                !(UseTemp() == TMP_FORCE &&\n                (mode == MODE_UPDATE || mode == MODE_DELETE));\n  int     cmpr = defp->Compressed;\n\n  /*********************************************************************/\n  /*  Allocate table and file processing class of the proper type.     */\n  /*  Column blocks will be allocated only when needed.                */\n  /*********************************************************************/\n  if (!((PTDBDOS)tdbp)->GetTxfp()) {\n    if (cmpr) {\n#if defined(GZ_SUPPORT)\n      if (cmpr == 1)\n        txfp = new(g) GZFAM(defp);\n      else\n        txfp = new(g) ZLBFAM(defp);\n#else   // !GZ_SUPPORT\n      strcpy(g->Message, \"Compress not supported\");\n      return NULL;\n#endif  // !GZ_SUPPORT\n    } else if (rfm == RECFM_VAR) {\n      if (map)\n        txfp = new(g) MAPFAM(defp);\n      else\n        txfp = new(g) DOSFAM(defp);\n\n    } else if (rfm == RECFM_FIX || rfm == RECFM_BIN) {\n      if (map)\n        txfp = new(g) MPXFAM(defp);\n      else\n        txfp = new(g) FIXFAM(defp);\n    } else if (rfm == RECFM_VCT) {\n#if defined(VCT_SUPPORT)\n      assert(Pxdef->GetDefType() == TYPE_AM_VCT);\n\n      if (map)\n        txfp = new(g) VCMFAM((PVCTDEF)defp);\n      else\n        txfp = new(g) VCTFAM((PVCTDEF)defp);\n#else   // !VCT_SUPPORT\n      strcpy(g->Message, \"VCT no more supported\");\n      return NULL;\n#endif  // !VCT_SUPPORT\n    } // endif's\n\n    ((PTDBDOS)tdbp)->SetTxfp(txfp);\n    } // endif Txfp\n\n  if (Multiple)\n    tdbp = new(g) TDBMUL(tdbp);\n#endif // 0\n  return tdbp;\n  } // end of GetTable\n\n/* --------------------------- Class COLCRT -------------------------- */\n\n/***********************************************************************/\n/*  COLCRT Constructors.                                               */\n/***********************************************************************/\nCOLCRT::COLCRT(PSZ name)\n  {\n  Next = NULL;\n  Name = name;\n  Desc = NULL;\n  Decode = NULL;\n  Fmt = NULL;\n  Offset = -1;\n  Long = -1;\n  Precision = -1;\n  Freq = -1;\n  Key = -1;\n  Scale = -1;\n  Opt = -1;\n  DataType = '*';\n  } // end of COLCRT constructor for table creation\n\nCOLCRT::COLCRT(void)\n  {\n  Next = NULL;\n  Name = NULL;\n  Desc = NULL;\n  Decode = NULL;\n  Fmt = NULL;\n  Offset = 0;\n  Long = 0;\n  Precision = 0;\n  Freq = 0;\n  Key = 0;\n  Scale = 0;\n  Opt = 0;\n  DataType = '*';\n  } // end of COLCRT constructor for table & view definition\n\n/* --------------------------- Class COLDEF -------------------------- */\n\n/***********************************************************************/\n/*  COLDEF Constructor.                                                */\n/***********************************************************************/\nCOLDEF::COLDEF(void) : COLCRT()\n  {\n  To_Min = NULL;\n  To_Max = NULL;\n  To_Pos = NULL;\n  Xdb2 = FALSE;\n  To_Bmap = NULL;\n  To_Dval = NULL;\n  Ndv = 0;\n  Nbm = 0;\n  Buf_Type = TYPE_ERROR;\n  Clen = 0;\n  Poff = 0;\n  memset(&F, 0, sizeof(FORMAT));\n  Flags = 0;\n  } // end of COLDEF constructor\n\n/***********************************************************************/\n/*  Define: initialize a column definition from a COLINFO structure.   */\n/***********************************************************************/\nint COLDEF::Define(PGLOBAL g, void *, PCOLINFO cfp, int poff)\n  {\n  Name = (PSZ)PlugDup(g, cfp->Name);\n\n  if (!(cfp->Flags & U_SPECIAL)) {\n    Poff = poff;\n    Buf_Type = cfp->Type;\n\n    if ((Clen = GetTypeSize(Buf_Type, cfp->Length)) < 0) {\n      sprintf(g->Message, MSG(BAD_COL_TYPE), GetTypeName(Buf_Type), Name);\n      return -1;\n      } // endswitch\n\n    strcpy(F.Type, GetFormatType(Buf_Type));\n    F.Length = cfp->Length;\n    F.Prec = cfp->Scale;\n    Offset = (cfp->Offset < 0) ? poff : cfp->Offset;\n    Precision = cfp->Precision;\n    Scale = cfp->Scale;\n    Long = cfp->Length;\n    Opt = cfp->Opt;\n    Key = cfp->Key;\n    Freq = cfp->Freq;\n\n    if (cfp->Remark && *cfp->Remark)\n      Desc = (PSZ)PlugDup(g, cfp->Remark);\n\n    if (cfp->Datefmt)\n      Decode = (PSZ)PlugDup(g, cfp->Datefmt);\n\n  } else\n    Offset = poff;\n\n  if (cfp->Fieldfmt)\n    Fmt = (PSZ)PlugDup(g, cfp->Fieldfmt);\n\n  Flags = cfp->Flags;\n  return (Flags & (U_VIRTUAL|U_SPECIAL)) ? 0 : Long;\n  } // end of Define\n\n/* ------------------------- End of RelDef --------------------------- */\n",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/tokudb/CMakeLists.txt": "SET(TOKUDB_VERSION 5.6.41-84.1)\n# PerconaFT only supports x86-64 and cmake-2.8.9+\nIF(WIN32)\n  # tokudb never worked there\n  RETURN()\nELSEIF(CMAKE_VERSION VERSION_LESS \"2.8.9\")\n  MESSAGE(STATUS \"CMake 2.8.9 or higher is required by TokuDB\")\nELSEIF(NOT HAVE_DLOPEN)\n  MESSAGE(STATUS \"dlopen is required by TokuDB\")\nELSEIF(PLUGIN_PERFSCHEMA MATCHES \"^NO$\")\n  MESSAGE(STATUS \"Performance Schema is required by TokuDB\")\n  RETURN()\nELSEIF(CMAKE_SYSTEM_PROCESSOR STREQUAL \"x86_64\" OR\n       CMAKE_SYSTEM_PROCESSOR STREQUAL \"amd64\")\n# tokudb requires F_NOCACHE or O_DIRECT, and designated initializers\nCHECK_CXX_SOURCE_COMPILES(\n\"\n#include <fcntl.h>\nstruct a {int b; int c; };\nstruct a d = { .b=1, .c=2 };\n#if defined(O_DIRECT) || defined(F_NOCACHE)\nint main() { return 0; }\n#else\n#error\n#endif\n\" TOKUDB_OK)\nENDIF()\n\nIF(NOT TOKUDB_OK)\n  RETURN()\nENDIF()\n\nSET(TOKUDB_SOURCES\n    ha_tokudb.cc\n    tokudb_background.cc\n    tokudb_information_schema.cc\n    tokudb_sysvars.cc\n    tokudb_thread.cc\n    tokudb_dir_cmd.cc)\nMYSQL_ADD_PLUGIN(tokudb ${TOKUDB_SOURCES} STORAGE_ENGINE MODULE_ONLY\n                 COMPONENT tokudb-engine CONFIG ${CMAKE_CURRENT_BINARY_DIR}/tokudb.cnf)\n\nIF(NOT TARGET tokudb)\n  RETURN()\nENDIF()\n\nINCLUDE(jemalloc)\nCHECK_JEMALLOC()\n\nIF(NOT LIBJEMALLOC)\n  MESSAGE(WARNING \"TokuDB is enabled, but jemalloc is not. This configuration is not supported\")\nELSEIF(LIBJEMALLOC STREQUAL jemalloc_pic)\n  CHECK_CXX_SOURCE_COMPILES(\n\"\n#include <jemalloc/jemalloc.h>\n#if JEMALLOC_VERSION_MAJOR < 5\nint main() { return 0; }\n#else\n#error\n#endif\n\" JEMALLOC_OK)\n  IF (NOT JEMALLOC_OK)\n    MESSAGE(FATAL_ERROR \"static jemalloc_pic.a can only be used up to jemalloc 4\")\n  ENDIF()\nELSEIF(LIBJEMALLOC STREQUAL jemalloc)\n  FIND_LIBRARY(LIBJEMALLOC_SO jemalloc)\n  IF(NOT LIBJEMALLOC_SO)\n    MESSAGE(FATAL_ERROR \"jemalloc is present, but cannot be found?\")\n  ENDIF()\n  GET_FILENAME_COMPONENT(LIBJEMALLOC_PATH ${LIBJEMALLOC_SO} REALPATH CACHE)\n\n  IF(RPM OR DEB)\n    UNSET(LIBJEMALLOC)\n    GET_DIRECTORY_PROPERTY(V DIRECTORY ${CMAKE_SOURCE_DIR} DEFINITION CPACK_RPM_tokudb-engine_PACKAGE_REQUIRES)\n    SET(CPACK_RPM_tokudb-engine_PACKAGE_REQUIRES \"${V} jemalloc\" PARENT_SCOPE)\n  ENDIF()\n\n  IF(INSTALL_SYSCONFDIR)\n    SET(systemd_env \"Environment=\\\"LD_PRELOAD=${LIBJEMALLOC_PATH}\\\"\")\n    SET(cnf_malloc_lib \"malloc-lib=${LIBJEMALLOC_PATH}\")\n    CONFIGURE_FILE(tokudb.conf.in tokudb.conf @ONLY)\n    INSTALL(FILES ${CMAKE_CURRENT_BINARY_DIR}/tokudb.conf\n            DESTINATION ${INSTALL_SYSCONFDIR}/systemd/system/mariadb.service.d/\n            COMPONENT tokudb-engine)\n  ENDIF()\nENDIF()\n\nCONFIGURE_FILE(tokudb.cnf.in tokudb.cnf @ONLY)\n\nMY_CHECK_AND_SET_COMPILER_FLAG(\"-Wno-shadow\")\nMY_CHECK_AND_SET_COMPILER_FLAG(\"-Wno-vla\" DEBUG)\nMY_CHECK_AND_SET_COMPILER_FLAG(\"-Wno-implicit-fallthrough\")\nMY_CHECK_AND_SET_COMPILER_FLAG(\"-Wno-cpp\" DEBUG)\n\n############################################\nMARK_AS_ADVANCED(BUILDNAME)\nMARK_AS_ADVANCED(BUILD_TESTING)\nMARK_AS_ADVANCED(CMAKE_TOKUDB_REVISION)\nMARK_AS_ADVANCED(LIBTOKUDB)\nMARK_AS_ADVANCED(LIBTOKUPORTABILITY)\nMARK_AS_ADVANCED(PROFILING)\nMARK_AS_ADVANCED(SNAPPY_SOURCE_DIR)\nMARK_AS_ADVANCED(TOKUDB_DATA)\nMARK_AS_ADVANCED(TOKU_DEBUG_PARANOID)\nMARK_AS_ADVANCED(USE_VALGRIND)\nMARK_AS_ADVANCED(XZ_SOURCE_DIR)\nMARK_AS_ADVANCED(gcc_ar)\nMARK_AS_ADVANCED(gcc_ranlib)\n############################################\n\n# pick language dialect\nMY_CHECK_AND_SET_COMPILER_FLAG(-std=c++11)\n\nSET(BUILD_TESTING OFF CACHE BOOL \"\")\nSET(USE_VALGRIND OFF CACHE BOOL \"\")\nSET(TOKU_DEBUG_PARANOID OFF CACHE BOOL \"\")\n\n# Enable TokuDB's TOKUDB_DEBUG in debug builds\nSET(CMAKE_CXX_FLAGS_DEBUG \"${CMAKE_CXX_FLAGS_DEBUG} -DTOKUDB_DEBUG\")\n\nIF(NOT DEFINED TOKUDB_VERSION)\n    IF(DEFINED ENV{TOKUDB_VERSION})\n        SET(TOKUDB_VERSION $ENV{TOKUDB_VERSION})\n    ENDIF()\nENDIF()\nIF(DEFINED TOKUDB_VERSION)\n    ADD_DEFINITIONS(\"-DTOKUDB_VERSION=${TOKUDB_VERSION}\")\n    IF (${TOKUDB_VERSION} MATCHES \"^tokudb-([0-9]+)\\\\.([0-9]+)\\\\.([0-9]+.*)\")\n        ADD_DEFINITIONS(\"-DTOKUDB_VERSION_MAJOR=${CMAKE_MATCH_1}\")\n        ADD_DEFINITIONS(\"-DTOKUDB_VERSION_MINOR=${CMAKE_MATCH_2}\")\n        ADD_DEFINITIONS(\"-DTOKUDB_VERSION_PATCH=${CMAKE_MATCH_3}\")\n    ENDIF()\nENDIF()\n\nIF(DEFINED TOKUDB_NOPATCH_CONFIG)\n    ADD_DEFINITIONS(\"-DTOKUDB_NOPATCH_CONFIG=${TOKUDB_NOPATCH_CONFIG}\")\nENDIF()\n\nMY_CHECK_AND_SET_COMPILER_FLAG(-Wno-missing-field-initializers)\n\nIF (EXISTS \"${CMAKE_CURRENT_SOURCE_DIR}/PerconaFT/\")\n    IF (EXISTS \"${CMAKE_CURRENT_SOURCE_DIR}/ft-index/\")\n        MESSAGE(FATAL_ERROR \"Found both PerconaFT and ft-index sources.  Don't know which to use.\")\n    ENDIF ()\n    SET(TOKU_FT_DIR_NAME \"PerconaFT\")\n    \nELSEIF (EXISTS \"${CMAKE_CURRENT_SOURCE_DIR}/ft-index/\")\n    MESSAGE(WARNING \"Found ft-index sources, ft-index is deprecated and replaced with PerconaFT.\")\n    SET(TOKU_FT_DIR_NAME \"ft-index\")\nELSE ()\n    MESSAGE(FATAL_ERROR \"Could not find PerconaFT sources.\")\nENDIF ()\n\nIF (WITH_VALGRIND)\n    SET(USE_VALGRIND \"ON\")\nENDIF ()\n\nADD_SUBDIRECTORY(${TOKU_FT_DIR_NAME})\nINCLUDE_DIRECTORIES(${TOKU_FT_DIR_NAME})\nINCLUDE_DIRECTORIES(${TOKU_FT_DIR_NAME}/portability)\nINCLUDE_DIRECTORIES(${TOKU_FT_DIR_NAME}/util)\nINCLUDE_DIRECTORIES(${CMAKE_CURRENT_BINARY_DIR}/${TOKU_FT_DIR_NAME})\nINCLUDE_DIRECTORIES(${CMAKE_CURRENT_BINARY_DIR}/${TOKU_FT_DIR_NAME}/buildheader)\nINCLUDE_DIRECTORIES(${CMAKE_CURRENT_BINARY_DIR}/${TOKU_FT_DIR_NAME}/portability)\n\nTARGET_LINK_LIBRARIES(tokudb tokufractaltree_static tokuportability_static\n                      ${ZLIB_LIBRARY} ${LIBJEMALLOC} stdc++)\n\nSET(CMAKE_MODULE_LINKER_FLAGS_RELEASE \"${CMAKE_MODULE_LINKER_FLAGS_RELEASE} -flto -fuse-linker-plugin\")\nSET(CMAKE_MODULE_LINKER_FLAGS_RELWITHDEBINFO \"${CMAKE_MODULE_LINKER_FLAGS_RELWITHDEBINFO} -flto -fuse-linker-plugin\")\n",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/tokudb/PerconaFT/third_party/snappy-1.1.2/ltmain.sh": "\n# libtool (GNU libtool) 2.4.2\n# Written by Gordon Matzigkeit <gord@gnu.ai.mit.edu>, 1996\n\n# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005, 2006,\n# 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.\n# This is free software; see the source for copying conditions.  There is NO\n# warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\n# GNU Libtool is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation; either version 2 of the License, or\n# (at your option) any later version.\n#\n# As a special exception to the GNU General Public License,\n# if you distribute this file as part of a program or library that\n# is built using GNU Libtool, you may include this file under the\n# same distribution terms that you use for the rest of that program.\n#\n# GNU Libtool is distributed in the hope that it will be useful, but\n# WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with GNU Libtool; see the file COPYING.  If not, a copy\n# can be downloaded from http://www.gnu.org/licenses/gpl.html,\n# or obtained by writing to the Free Software Foundation, Inc.,\n# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1335  USA.\n\n# Usage: $progname [OPTION]... [MODE-ARG]...\n#\n# Provide generalized library-building support services.\n#\n#       --config             show all configuration variables\n#       --debug              enable verbose shell tracing\n#   -n, --dry-run            display commands without modifying any files\n#       --features           display basic configuration information and exit\n#       --mode=MODE          use operation mode MODE\n#       --preserve-dup-deps  don't remove duplicate dependency libraries\n#       --quiet, --silent    don't print informational messages\n#       --no-quiet, --no-silent\n#                            print informational messages (default)\n#       --no-warn            don't display warning messages\n#       --tag=TAG            use configuration variables from tag TAG\n#   -v, --verbose            print more informational messages than default\n#       --no-verbose         don't print the extra informational messages\n#       --version            print version information\n#   -h, --help, --help-all   print short, long, or detailed help message\n#\n# MODE must be one of the following:\n#\n#         clean              remove files from the build directory\n#         compile            compile a source file into a libtool object\n#         execute            automatically set library path, then run a program\n#         finish             complete the installation of libtool libraries\n#         install            install libraries or executables\n#         link               create a library or an executable\n#         uninstall          remove libraries from an installed directory\n#\n# MODE-ARGS vary depending on the MODE.  When passed as first option,\n# `--mode=MODE' may be abbreviated as `MODE' or a unique abbreviation of that.\n# Try `$progname --help --mode=MODE' for a more detailed description of MODE.\n#\n# When reporting a bug, please describe a test case to reproduce it and\n# include the following information:\n#\n#         host-triplet:\t$host\n#         shell:\t\t$SHELL\n#         compiler:\t\t$LTCC\n#         compiler flags:\t\t$LTCFLAGS\n#         linker:\t\t$LD (gnu? $with_gnu_ld)\n#         $progname:\t(GNU libtool) 2.4.2 Debian-2.4.2-1ubuntu1\n#         automake:\t$automake_version\n#         autoconf:\t$autoconf_version\n#\n# Report bugs to <bug-libtool@gnu.org>.\n# GNU libtool home page: <http://www.gnu.org/software/libtool/>.\n# General help using GNU software: <http://www.gnu.org/gethelp/>.\n\nPROGRAM=libtool\nPACKAGE=libtool\nVERSION=\"2.4.2 Debian-2.4.2-1ubuntu1\"\nTIMESTAMP=\"\"\npackage_revision=1.3337\n\n# Be Bourne compatible\nif test -n \"${ZSH_VERSION+set}\" && (emulate sh) >/dev/null 2>&1; then\n  emulate sh\n  NULLCMD=:\n  # Zsh 3.x and 4.x performs word splitting on ${1+\"$@\"}, which\n  # is contrary to our usage.  Disable this feature.\n  alias -g '${1+\"$@\"}'='\"$@\"'\n  setopt NO_GLOB_SUBST\nelse\n  case `(set -o) 2>/dev/null` in *posix*) set -o posix;; esac\nfi\nBIN_SH=xpg4; export BIN_SH # for Tru64\nDUALCASE=1; export DUALCASE # for MKS sh\n\n# A function that is used when there is no print builtin or printf.\nfunc_fallback_echo ()\n{\n  eval 'cat <<_LTECHO_EOF\n$1\n_LTECHO_EOF'\n}\n\n# NLS nuisances: We save the old values to restore during execute mode.\nlt_user_locale=\nlt_safe_locale=\nfor lt_var in LANG LANGUAGE LC_ALL LC_CTYPE LC_COLLATE LC_MESSAGES\ndo\n  eval \"if test \\\"\\${$lt_var+set}\\\" = set; then\n          save_$lt_var=\\$$lt_var\n          $lt_var=C\n\t  export $lt_var\n\t  lt_user_locale=\\\"$lt_var=\\\\\\$save_\\$lt_var; \\$lt_user_locale\\\"\n\t  lt_safe_locale=\\\"$lt_var=C; \\$lt_safe_locale\\\"\n\tfi\"\ndone\nLC_ALL=C\nLANGUAGE=C\nexport LANGUAGE LC_ALL\n\n$lt_unset CDPATH\n\n\n# Work around backward compatibility issue on IRIX 6.5. On IRIX 6.4+, sh\n# is ksh but when the shell is invoked as \"sh\" and the current value of\n# the _XPG environment variable is not equal to 1 (one), the special\n# positional parameter $0, within a function call, is the name of the\n# function.\nprogpath=\"$0\"\n\n\n\n: ${CP=\"cp -f\"}\ntest \"${ECHO+set}\" = set || ECHO=${as_echo-'printf %s\\n'}\n: ${MAKE=\"make\"}\n: ${MKDIR=\"mkdir\"}\n: ${MV=\"mv -f\"}\n: ${RM=\"rm -f\"}\n: ${SHELL=\"${CONFIG_SHELL-/bin/sh}\"}\n: ${Xsed=\"$SED -e 1s/^X//\"}\n\n# Global variables:\nEXIT_SUCCESS=0\nEXIT_FAILURE=1\nEXIT_MISMATCH=63  # $? = 63 is used to indicate version mismatch to missing.\nEXIT_SKIP=77\t  # $? = 77 is used to indicate a skipped test to automake.\n\nexit_status=$EXIT_SUCCESS\n\n# Make sure IFS has a sensible default\nlt_nl='\n'\nIFS=\" \t$lt_nl\"\n\ndirname=\"s,/[^/]*$,,\"\nbasename=\"s,^.*/,,\"\n\n# func_dirname file append nondir_replacement\n# Compute the dirname of FILE.  If nonempty, add APPEND to the result,\n# otherwise set result to NONDIR_REPLACEMENT.\nfunc_dirname ()\n{\n    func_dirname_result=`$ECHO \"${1}\" | $SED \"$dirname\"`\n    if test \"X$func_dirname_result\" = \"X${1}\"; then\n      func_dirname_result=\"${3}\"\n    else\n      func_dirname_result=\"$func_dirname_result${2}\"\n    fi\n} # func_dirname may be replaced by extended shell implementation\n\n\n# func_basename file\nfunc_basename ()\n{\n    func_basename_result=`$ECHO \"${1}\" | $SED \"$basename\"`\n} # func_basename may be replaced by extended shell implementation\n\n\n# func_dirname_and_basename file append nondir_replacement\n# perform func_basename and func_dirname in a single function\n# call:\n#   dirname:  Compute the dirname of FILE.  If nonempty,\n#             add APPEND to the result, otherwise set result\n#             to NONDIR_REPLACEMENT.\n#             value returned in \"$func_dirname_result\"\n#   basename: Compute filename of FILE.\n#             value retuned in \"$func_basename_result\"\n# Implementation must be kept synchronized with func_dirname\n# and func_basename. For efficiency, we do not delegate to\n# those functions but instead duplicate the functionality here.\nfunc_dirname_and_basename ()\n{\n    # Extract subdirectory from the argument.\n    func_dirname_result=`$ECHO \"${1}\" | $SED -e \"$dirname\"`\n    if test \"X$func_dirname_result\" = \"X${1}\"; then\n      func_dirname_result=\"${3}\"\n    else\n      func_dirname_result=\"$func_dirname_result${2}\"\n    fi\n    func_basename_result=`$ECHO \"${1}\" | $SED -e \"$basename\"`\n} # func_dirname_and_basename may be replaced by extended shell implementation\n\n\n# func_stripname prefix suffix name\n# strip PREFIX and SUFFIX off of NAME.\n# PREFIX and SUFFIX must not contain globbing or regex special\n# characters, hashes, percent signs, but SUFFIX may contain a leading\n# dot (in which case that matches only a dot).\n# func_strip_suffix prefix name\nfunc_stripname ()\n{\n    case ${2} in\n      .*) func_stripname_result=`$ECHO \"${3}\" | $SED \"s%^${1}%%; s%\\\\\\\\${2}\\$%%\"`;;\n      *)  func_stripname_result=`$ECHO \"${3}\" | $SED \"s%^${1}%%; s%${2}\\$%%\"`;;\n    esac\n} # func_stripname may be replaced by extended shell implementation\n\n\n# These SED scripts presuppose an absolute path with a trailing slash.\npathcar='s,^/\\([^/]*\\).*$,\\1,'\npathcdr='s,^/[^/]*,,'\nremovedotparts=':dotsl\n\t\ts@/\\./@/@g\n\t\tt dotsl\n\t\ts,/\\.$,/,'\ncollapseslashes='s@/\\{1,\\}@/@g'\nfinalslash='s,/*$,/,'\n\n# func_normal_abspath PATH\n# Remove doubled-up and trailing slashes, \".\" path components,\n# and cancel out any \"..\" path components in PATH after making\n# it an absolute path.\n#             value returned in \"$func_normal_abspath_result\"\nfunc_normal_abspath ()\n{\n  # Start from root dir and reassemble the path.\n  func_normal_abspath_result=\n  func_normal_abspath_tpath=$1\n  func_normal_abspath_altnamespace=\n  case $func_normal_abspath_tpath in\n    \"\")\n      # Empty path, that just means $cwd.\n      func_stripname '' '/' \"`pwd`\"\n      func_normal_abspath_result=$func_stripname_result\n      return\n    ;;\n    # The next three entries are used to spot a run of precisely\n    # two leading slashes without using negated character classes;\n    # we take advantage of case's first-match behaviour.\n    ///*)\n      # Unusual form of absolute path, do nothing.\n    ;;\n    //*)\n      # Not necessarily an ordinary path; POSIX reserves leading '//'\n      # and for example Cygwin uses it to access remote file shares\n      # over CIFS/SMB, so we conserve a leading double slash if found.\n      func_normal_abspath_altnamespace=/\n    ;;\n    /*)\n      # Absolute path, do nothing.\n    ;;\n    *)\n      # Relative path, prepend $cwd.\n      func_normal_abspath_tpath=`pwd`/$func_normal_abspath_tpath\n    ;;\n  esac\n  # Cancel out all the simple stuff to save iterations.  We also want\n  # the path to end with a slash for ease of parsing, so make sure\n  # there is one (and only one) here.\n  func_normal_abspath_tpath=`$ECHO \"$func_normal_abspath_tpath\" | $SED \\\n        -e \"$removedotparts\" -e \"$collapseslashes\" -e \"$finalslash\"`\n  while :; do\n    # Processed it all yet?\n    if test \"$func_normal_abspath_tpath\" = / ; then\n      # If we ascended to the root using \"..\" the result may be empty now.\n      if test -z \"$func_normal_abspath_result\" ; then\n        func_normal_abspath_result=/\n      fi\n      break\n    fi\n    func_normal_abspath_tcomponent=`$ECHO \"$func_normal_abspath_tpath\" | $SED \\\n        -e \"$pathcar\"`\n    func_normal_abspath_tpath=`$ECHO \"$func_normal_abspath_tpath\" | $SED \\\n        -e \"$pathcdr\"`\n    # Figure out what to do with it\n    case $func_normal_abspath_tcomponent in\n      \"\")\n        # Trailing empty path component, ignore it.\n      ;;\n      ..)\n        # Parent dir; strip last assembled component from result.\n        func_dirname \"$func_normal_abspath_result\"\n        func_normal_abspath_result=$func_dirname_result\n      ;;\n      *)\n        # Actual path component, append it.\n        func_normal_abspath_result=$func_normal_abspath_result/$func_normal_abspath_tcomponent\n      ;;\n    esac\n  done\n  # Restore leading double-slash if one was found on entry.\n  func_normal_abspath_result=$func_normal_abspath_altnamespace$func_normal_abspath_result\n}\n\n# func_relative_path SRCDIR DSTDIR\n# generates a relative path from SRCDIR to DSTDIR, with a trailing\n# slash if non-empty, suitable for immediately appending a filename\n# without needing to append a separator.\n#             value returned in \"$func_relative_path_result\"\nfunc_relative_path ()\n{\n  func_relative_path_result=\n  func_normal_abspath \"$1\"\n  func_relative_path_tlibdir=$func_normal_abspath_result\n  func_normal_abspath \"$2\"\n  func_relative_path_tbindir=$func_normal_abspath_result\n\n  # Ascend the tree starting from libdir\n  while :; do\n    # check if we have found a prefix of bindir\n    case $func_relative_path_tbindir in\n      $func_relative_path_tlibdir)\n        # found an exact match\n        func_relative_path_tcancelled=\n        break\n        ;;\n      $func_relative_path_tlibdir*)\n        # found a matching prefix\n        func_stripname \"$func_relative_path_tlibdir\" '' \"$func_relative_path_tbindir\"\n        func_relative_path_tcancelled=$func_stripname_result\n        if test -z \"$func_relative_path_result\"; then\n          func_relative_path_result=.\n        fi\n        break\n        ;;\n      *)\n        func_dirname $func_relative_path_tlibdir\n        func_relative_path_tlibdir=${func_dirname_result}\n        if test \"x$func_relative_path_tlibdir\" = x ; then\n          # Have to descend all the way to the root!\n          func_relative_path_result=../$func_relative_path_result\n          func_relative_path_tcancelled=$func_relative_path_tbindir\n          break\n        fi\n        func_relative_path_result=../$func_relative_path_result\n        ;;\n    esac\n  done\n\n  # Now calculate path; take care to avoid doubling-up slashes.\n  func_stripname '' '/' \"$func_relative_path_result\"\n  func_relative_path_result=$func_stripname_result\n  func_stripname '/' '/' \"$func_relative_path_tcancelled\"\n  if test \"x$func_stripname_result\" != x ; then\n    func_relative_path_result=${func_relative_path_result}/${func_stripname_result}\n  fi\n\n  # Normalisation. If bindir is libdir, return empty string,\n  # else relative path ending with a slash; either way, target\n  # file name can be directly appended.\n  if test ! -z \"$func_relative_path_result\"; then\n    func_stripname './' '' \"$func_relative_path_result/\"\n    func_relative_path_result=$func_stripname_result\n  fi\n}\n\n# The name of this program:\nfunc_dirname_and_basename \"$progpath\"\nprogname=$func_basename_result\n\n# Make sure we have an absolute path for reexecution:\ncase $progpath in\n  [\\\\/]*|[A-Za-z]:\\\\*) ;;\n  *[\\\\/]*)\n     progdir=$func_dirname_result\n     progdir=`cd \"$progdir\" && pwd`\n     progpath=\"$progdir/$progname\"\n     ;;\n  *)\n     save_IFS=\"$IFS\"\n     IFS=${PATH_SEPARATOR-:}\n     for progdir in $PATH; do\n       IFS=\"$save_IFS\"\n       test -x \"$progdir/$progname\" && break\n     done\n     IFS=\"$save_IFS\"\n     test -n \"$progdir\" || progdir=`pwd`\n     progpath=\"$progdir/$progname\"\n     ;;\nesac\n\n# Sed substitution that helps us do robust quoting.  It backslashifies\n# metacharacters that are still active within double-quoted strings.\nXsed=\"${SED}\"' -e 1s/^X//'\nsed_quote_subst='s/\\([`\"$\\\\]\\)/\\\\\\1/g'\n\n# Same as above, but do not quote variable references.\ndouble_quote_subst='s/\\([\"`\\\\]\\)/\\\\\\1/g'\n\n# Sed substitution that turns a string into a regex matching for the\n# string literally.\nsed_make_literal_regex='s,[].[^$\\\\*\\/],\\\\&,g'\n\n# Sed substitution that converts a w32 file name or path\n# which contains forward slashes, into one that contains\n# (escaped) backslashes.  A very naive implementation.\nlt_sed_naive_backslashify='s|\\\\\\\\*|\\\\|g;s|/|\\\\|g;s|\\\\|\\\\\\\\|g'\n\n# Re-`\\' parameter expansions in output of double_quote_subst that were\n# `\\'-ed in input to the same.  If an odd number of `\\' preceded a '$'\n# in input to double_quote_subst, that '$' was protected from expansion.\n# Since each input `\\' is now two `\\'s, look for any number of runs of\n# four `\\'s followed by two `\\'s and then a '$'.  `\\' that '$'.\nbs='\\\\'\nbs2='\\\\\\\\'\nbs4='\\\\\\\\\\\\\\\\'\ndollar='\\$'\nsed_double_backslash=\"\\\n  s/$bs4/&\\\\\n/g\n  s/^$bs2$dollar/$bs&/\n  s/\\\\([^$bs]\\\\)$bs2$dollar/\\\\1$bs2$bs$dollar/g\n  s/\\n//g\"\n\n# Standard options:\nopt_dry_run=false\nopt_help=false\nopt_quiet=false\nopt_verbose=false\nopt_warning=:\n\n# func_echo arg...\n# Echo program name prefixed message, along with the current mode\n# name if it has been set yet.\nfunc_echo ()\n{\n    $ECHO \"$progname: ${opt_mode+$opt_mode: }$*\"\n}\n\n# func_verbose arg...\n# Echo program name prefixed message in verbose mode only.\nfunc_verbose ()\n{\n    $opt_verbose && func_echo ${1+\"$@\"}\n\n    # A bug in bash halts the script if the last line of a function\n    # fails when set -e is in force, so we need another command to\n    # work around that:\n    :\n}\n\n# func_echo_all arg...\n# Invoke $ECHO with all args, space-separated.\nfunc_echo_all ()\n{\n    $ECHO \"$*\"\n}\n\n# func_error arg...\n# Echo program name prefixed message to standard error.\nfunc_error ()\n{\n    $ECHO \"$progname: ${opt_mode+$opt_mode: }\"${1+\"$@\"} 1>&2\n}\n\n# func_warning arg...\n# Echo program name prefixed warning message to standard error.\nfunc_warning ()\n{\n    $opt_warning && $ECHO \"$progname: ${opt_mode+$opt_mode: }warning: \"${1+\"$@\"} 1>&2\n\n    # bash bug again:\n    :\n}\n\n# func_fatal_error arg...\n# Echo program name prefixed message to standard error, and exit.\nfunc_fatal_error ()\n{\n    func_error ${1+\"$@\"}\n    exit $EXIT_FAILURE\n}\n\n# func_fatal_help arg...\n# Echo program name prefixed message to standard error, followed by\n# a help hint, and exit.\nfunc_fatal_help ()\n{\n    func_error ${1+\"$@\"}\n    func_fatal_error \"$help\"\n}\nhelp=\"Try \\`$progname --help' for more information.\"  ## default\n\n\n# func_grep expression filename\n# Check whether EXPRESSION matches any line of FILENAME, without output.\nfunc_grep ()\n{\n    $GREP \"$1\" \"$2\" >/dev/null 2>&1\n}\n\n\n# func_mkdir_p directory-path\n# Make sure the entire path to DIRECTORY-PATH is available.\nfunc_mkdir_p ()\n{\n    my_directory_path=\"$1\"\n    my_dir_list=\n\n    if test -n \"$my_directory_path\" && test \"$opt_dry_run\" != \":\"; then\n\n      # Protect directory names starting with `-'\n      case $my_directory_path in\n        -*) my_directory_path=\"./$my_directory_path\" ;;\n      esac\n\n      # While some portion of DIR does not yet exist...\n      while test ! -d \"$my_directory_path\"; do\n        # ...make a list in topmost first order.  Use a colon delimited\n\t# list incase some portion of path contains whitespace.\n        my_dir_list=\"$my_directory_path:$my_dir_list\"\n\n        # If the last portion added has no slash in it, the list is done\n        case $my_directory_path in */*) ;; *) break ;; esac\n\n        # ...otherwise throw away the child directory and loop\n        my_directory_path=`$ECHO \"$my_directory_path\" | $SED -e \"$dirname\"`\n      done\n      my_dir_list=`$ECHO \"$my_dir_list\" | $SED 's,:*$,,'`\n\n      save_mkdir_p_IFS=\"$IFS\"; IFS=':'\n      for my_dir in $my_dir_list; do\n\tIFS=\"$save_mkdir_p_IFS\"\n        # mkdir can fail with a `File exist' error if two processes\n        # try to create one of the directories concurrently.  Don't\n        # stop in that case!\n        $MKDIR \"$my_dir\" 2>/dev/null || :\n      done\n      IFS=\"$save_mkdir_p_IFS\"\n\n      # Bail out if we (or some other process) failed to create a directory.\n      test -d \"$my_directory_path\" || \\\n        func_fatal_error \"Failed to create \\`$1'\"\n    fi\n}\n\n\n# func_mktempdir [string]\n# Make a temporary directory that won't clash with other running\n# libtool processes, and avoids race conditions if possible.  If\n# given, STRING is the basename for that directory.\nfunc_mktempdir ()\n{\n    my_template=\"${TMPDIR-/tmp}/${1-$progname}\"\n\n    if test \"$opt_dry_run\" = \":\"; then\n      # Return a directory name, but don't create it in dry-run mode\n      my_tmpdir=\"${my_template}-$$\"\n    else\n\n      # If mktemp works, use that first and foremost\n      my_tmpdir=`mktemp -d \"${my_template}-XXXXXXXX\" 2>/dev/null`\n\n      if test ! -d \"$my_tmpdir\"; then\n        # Failing that, at least try and use $RANDOM to avoid a race\n        my_tmpdir=\"${my_template}-${RANDOM-0}$$\"\n\n        save_mktempdir_umask=`umask`\n        umask 0077\n        $MKDIR \"$my_tmpdir\"\n        umask $save_mktempdir_umask\n      fi\n\n      # If we're not in dry-run mode, bomb out on failure\n      test -d \"$my_tmpdir\" || \\\n        func_fatal_error \"cannot create temporary directory \\`$my_tmpdir'\"\n    fi\n\n    $ECHO \"$my_tmpdir\"\n}\n\n\n# func_quote_for_eval arg\n# Aesthetically quote ARG to be evaled later.\n# This function returns two values: FUNC_QUOTE_FOR_EVAL_RESULT\n# is double-quoted, suitable for a subsequent eval, whereas\n# FUNC_QUOTE_FOR_EVAL_UNQUOTED_RESULT has merely all characters\n# which are still active within double quotes backslashified.\nfunc_quote_for_eval ()\n{\n    case $1 in\n      *[\\\\\\`\\\"\\$]*)\n\tfunc_quote_for_eval_unquoted_result=`$ECHO \"$1\" | $SED \"$sed_quote_subst\"` ;;\n      *)\n        func_quote_for_eval_unquoted_result=\"$1\" ;;\n    esac\n\n    case $func_quote_for_eval_unquoted_result in\n      # Double-quote args containing shell metacharacters to delay\n      # word splitting, command substitution and and variable\n      # expansion for a subsequent eval.\n      # Many Bourne shells cannot handle close brackets correctly\n      # in scan sets, so we specify it separately.\n      *[\\[\\~\\#\\^\\&\\*\\(\\)\\{\\}\\|\\;\\<\\>\\?\\'\\ \\\t]*|*]*|\"\")\n        func_quote_for_eval_result=\"\\\"$func_quote_for_eval_unquoted_result\\\"\"\n        ;;\n      *)\n        func_quote_for_eval_result=\"$func_quote_for_eval_unquoted_result\"\n    esac\n}\n\n\n# func_quote_for_expand arg\n# Aesthetically quote ARG to be evaled later; same as above,\n# but do not quote variable references.\nfunc_quote_for_expand ()\n{\n    case $1 in\n      *[\\\\\\`\\\"]*)\n\tmy_arg=`$ECHO \"$1\" | $SED \\\n\t    -e \"$double_quote_subst\" -e \"$sed_double_backslash\"` ;;\n      *)\n        my_arg=\"$1\" ;;\n    esac\n\n    case $my_arg in\n      # Double-quote args containing shell metacharacters to delay\n      # word splitting and command substitution for a subsequent eval.\n      # Many Bourne shells cannot handle close brackets correctly\n      # in scan sets, so we specify it separately.\n      *[\\[\\~\\#\\^\\&\\*\\(\\)\\{\\}\\|\\;\\<\\>\\?\\'\\ \\\t]*|*]*|\"\")\n        my_arg=\"\\\"$my_arg\\\"\"\n        ;;\n    esac\n\n    func_quote_for_expand_result=\"$my_arg\"\n}\n\n\n# func_show_eval cmd [fail_exp]\n# Unless opt_silent is true, then output CMD.  Then, if opt_dryrun is\n# not true, evaluate CMD.  If the evaluation of CMD fails, and FAIL_EXP\n# is given, then evaluate it.\nfunc_show_eval ()\n{\n    my_cmd=\"$1\"\n    my_fail_exp=\"${2-:}\"\n\n    ${opt_silent-false} || {\n      func_quote_for_expand \"$my_cmd\"\n      eval \"func_echo $func_quote_for_expand_result\"\n    }\n\n    if ${opt_dry_run-false}; then :; else\n      eval \"$my_cmd\"\n      my_status=$?\n      if test \"$my_status\" -eq 0; then :; else\n\teval \"(exit $my_status); $my_fail_exp\"\n      fi\n    fi\n}\n\n\n# func_show_eval_locale cmd [fail_exp]\n# Unless opt_silent is true, then output CMD.  Then, if opt_dryrun is\n# not true, evaluate CMD.  If the evaluation of CMD fails, and FAIL_EXP\n# is given, then evaluate it.  Use the saved locale for evaluation.\nfunc_show_eval_locale ()\n{\n    my_cmd=\"$1\"\n    my_fail_exp=\"${2-:}\"\n\n    ${opt_silent-false} || {\n      func_quote_for_expand \"$my_cmd\"\n      eval \"func_echo $func_quote_for_expand_result\"\n    }\n\n    if ${opt_dry_run-false}; then :; else\n      eval \"$lt_user_locale\n\t    $my_cmd\"\n      my_status=$?\n      eval \"$lt_safe_locale\"\n      if test \"$my_status\" -eq 0; then :; else\n\teval \"(exit $my_status); $my_fail_exp\"\n      fi\n    fi\n}\n\n# func_tr_sh\n# Turn $1 into a string suitable for a shell variable name.\n# Result is stored in $func_tr_sh_result.  All characters\n# not in the set a-zA-Z0-9_ are replaced with '_'. Further,\n# if $1 begins with a digit, a '_' is prepended as well.\nfunc_tr_sh ()\n{\n  case $1 in\n  [0-9]* | *[!a-zA-Z0-9_]*)\n    func_tr_sh_result=`$ECHO \"$1\" | $SED 's/^\\([0-9]\\)/_\\1/; s/[^a-zA-Z0-9_]/_/g'`\n    ;;\n  * )\n    func_tr_sh_result=$1\n    ;;\n  esac\n}\n\n\n# func_version\n# Echo version message to standard output and exit.\nfunc_version ()\n{\n    $opt_debug\n\n    $SED -n '/(C)/!b go\n\t:more\n\t/\\./!{\n\t  N\n\t  s/\\n# / /\n\t  b more\n\t}\n\t:go\n\t/^# '$PROGRAM' (GNU /,/# warranty; / {\n        s/^# //\n\ts/^# *$//\n        s/\\((C)\\)[ 0-9,-]*\\( [1-9][0-9]*\\)/\\1\\2/\n        p\n     }' < \"$progpath\"\n     exit $?\n}\n\n# func_usage\n# Echo short help message to standard output and exit.\nfunc_usage ()\n{\n    $opt_debug\n\n    $SED -n '/^# Usage:/,/^#  *.*--help/ {\n        s/^# //\n\ts/^# *$//\n\ts/\\$progname/'$progname'/\n\tp\n    }' < \"$progpath\"\n    echo\n    $ECHO \"run \\`$progname --help | more' for full usage\"\n    exit $?\n}\n\n# func_help [NOEXIT]\n# Echo long help message to standard output and exit,\n# unless 'noexit' is passed as argument.\nfunc_help ()\n{\n    $opt_debug\n\n    $SED -n '/^# Usage:/,/# Report bugs to/ {\n\t:print\n        s/^# //\n\ts/^# *$//\n\ts*\\$progname*'$progname'*\n\ts*\\$host*'\"$host\"'*\n\ts*\\$SHELL*'\"$SHELL\"'*\n\ts*\\$LTCC*'\"$LTCC\"'*\n\ts*\\$LTCFLAGS*'\"$LTCFLAGS\"'*\n\ts*\\$LD*'\"$LD\"'*\n\ts/\\$with_gnu_ld/'\"$with_gnu_ld\"'/\n\ts/\\$automake_version/'\"`(${AUTOMAKE-automake} --version) 2>/dev/null |$SED 1q`\"'/\n\ts/\\$autoconf_version/'\"`(${AUTOCONF-autoconf} --version) 2>/dev/null |$SED 1q`\"'/\n\tp\n\td\n     }\n     /^# .* home page:/b print\n     /^# General help using/b print\n     ' < \"$progpath\"\n    ret=$?\n    if test -z \"$1\"; then\n      exit $ret\n    fi\n}\n\n# func_missing_arg argname\n# Echo program name prefixed message to standard error and set global\n# exit_cmd.\nfunc_missing_arg ()\n{\n    $opt_debug\n\n    func_error \"missing argument for $1.\"\n    exit_cmd=exit\n}\n\n\n# func_split_short_opt shortopt\n# Set func_split_short_opt_name and func_split_short_opt_arg shell\n# variables after splitting SHORTOPT after the 2nd character.\nfunc_split_short_opt ()\n{\n    my_sed_short_opt='1s/^\\(..\\).*$/\\1/;q'\n    my_sed_short_rest='1s/^..\\(.*\\)$/\\1/;q'\n\n    func_split_short_opt_name=`$ECHO \"$1\" | $SED \"$my_sed_short_opt\"`\n    func_split_short_opt_arg=`$ECHO \"$1\" | $SED \"$my_sed_short_rest\"`\n} # func_split_short_opt may be replaced by extended shell implementation\n\n\n# func_split_long_opt longopt\n# Set func_split_long_opt_name and func_split_long_opt_arg shell\n# variables after splitting LONGOPT at the `=' sign.\nfunc_split_long_opt ()\n{\n    my_sed_long_opt='1s/^\\(--[^=]*\\)=.*/\\1/;q'\n    my_sed_long_arg='1s/^--[^=]*=//'\n\n    func_split_long_opt_name=`$ECHO \"$1\" | $SED \"$my_sed_long_opt\"`\n    func_split_long_opt_arg=`$ECHO \"$1\" | $SED \"$my_sed_long_arg\"`\n} # func_split_long_opt may be replaced by extended shell implementation\n\nexit_cmd=:\n\n\n\n\n\nmagic=\"%%%MAGIC variable%%%\"\nmagic_exe=\"%%%MAGIC EXE variable%%%\"\n\n# Global variables.\nnonopt=\npreserve_args=\nlo2o=\"s/\\\\.lo\\$/.${objext}/\"\no2lo=\"s/\\\\.${objext}\\$/.lo/\"\nextracted_archives=\nextracted_serial=0\n\n# If this variable is set in any of the actions, the command in it\n# will be execed at the end.  This prevents here-documents from being\n# left over by shells.\nexec_cmd=\n\n# func_append var value\n# Append VALUE to the end of shell variable VAR.\nfunc_append ()\n{\n    eval \"${1}=\\$${1}\\${2}\"\n} # func_append may be replaced by extended shell implementation\n\n# func_append_quoted var value\n# Quote VALUE and append to the end of shell variable VAR, separated\n# by a space.\nfunc_append_quoted ()\n{\n    func_quote_for_eval \"${2}\"\n    eval \"${1}=\\$${1}\\\\ \\$func_quote_for_eval_result\"\n} # func_append_quoted may be replaced by extended shell implementation\n\n\n# func_arith arithmetic-term...\nfunc_arith ()\n{\n    func_arith_result=`expr \"${@}\"`\n} # func_arith may be replaced by extended shell implementation\n\n\n# func_len string\n# STRING may not start with a hyphen.\nfunc_len ()\n{\n    func_len_result=`expr \"${1}\" : \".*\" 2>/dev/null || echo $max_cmd_len`\n} # func_len may be replaced by extended shell implementation\n\n\n# func_lo2o object\nfunc_lo2o ()\n{\n    func_lo2o_result=`$ECHO \"${1}\" | $SED \"$lo2o\"`\n} # func_lo2o may be replaced by extended shell implementation\n\n\n# func_xform libobj-or-source\nfunc_xform ()\n{\n    func_xform_result=`$ECHO \"${1}\" | $SED 's/\\.[^.]*$/.lo/'`\n} # func_xform may be replaced by extended shell implementation\n\n\n# func_fatal_configuration arg...\n# Echo program name prefixed message to standard error, followed by\n# a configuration failure hint, and exit.\nfunc_fatal_configuration ()\n{\n    func_error ${1+\"$@\"}\n    func_error \"See the $PACKAGE documentation for more information.\"\n    func_fatal_error \"Fatal configuration error.\"\n}\n\n\n# func_config\n# Display the configuration for all the tags in this script.\nfunc_config ()\n{\n    re_begincf='^# ### BEGIN LIBTOOL'\n    re_endcf='^# ### END LIBTOOL'\n\n    # Default configuration.\n    $SED \"1,/$re_begincf CONFIG/d;/$re_endcf CONFIG/,\\$d\" < \"$progpath\"\n\n    # Now print the configurations for the tags.\n    for tagname in $taglist; do\n      $SED -n \"/$re_begincf TAG CONFIG: $tagname\\$/,/$re_endcf TAG CONFIG: $tagname\\$/p\" < \"$progpath\"\n    done\n\n    exit $?\n}\n\n# func_features\n# Display the features supported by this script.\nfunc_features ()\n{\n    echo \"host: $host\"\n    if test \"$build_libtool_libs\" = yes; then\n      echo \"enable shared libraries\"\n    else\n      echo \"disable shared libraries\"\n    fi\n    if test \"$build_old_libs\" = yes; then\n      echo \"enable static libraries\"\n    else\n      echo \"disable static libraries\"\n    fi\n\n    exit $?\n}\n\n# func_enable_tag tagname\n# Verify that TAGNAME is valid, and either flag an error and exit, or\n# enable the TAGNAME tag.  We also add TAGNAME to the global $taglist\n# variable here.\nfunc_enable_tag ()\n{\n  # Global variable:\n  tagname=\"$1\"\n\n  re_begincf=\"^# ### BEGIN LIBTOOL TAG CONFIG: $tagname\\$\"\n  re_endcf=\"^# ### END LIBTOOL TAG CONFIG: $tagname\\$\"\n  sed_extractcf=\"/$re_begincf/,/$re_endcf/p\"\n\n  # Validate tagname.\n  case $tagname in\n    *[!-_A-Za-z0-9,/]*)\n      func_fatal_error \"invalid tag name: $tagname\"\n      ;;\n  esac\n\n  # Don't test for the \"default\" C tag, as we know it's\n  # there but not specially marked.\n  case $tagname in\n    CC) ;;\n    *)\n      if $GREP \"$re_begincf\" \"$progpath\" >/dev/null 2>&1; then\n\ttaglist=\"$taglist $tagname\"\n\n\t# Evaluate the configuration.  Be careful to quote the path\n\t# and the sed script, to avoid splitting on whitespace, but\n\t# also don't use non-portable quotes within backquotes within\n\t# quotes we have to do it in 2 steps:\n\textractedcf=`$SED -n -e \"$sed_extractcf\" < \"$progpath\"`\n\teval \"$extractedcf\"\n      else\n\tfunc_error \"ignoring unknown tag $tagname\"\n      fi\n      ;;\n  esac\n}\n\n# func_check_version_match\n# Ensure that we are using m4 macros, and libtool script from the same\n# release of libtool.\nfunc_check_version_match ()\n{\n  if test \"$package_revision\" != \"$macro_revision\"; then\n    if test \"$VERSION\" != \"$macro_version\"; then\n      if test -z \"$macro_version\"; then\n        cat >&2 <<_LT_EOF\n$progname: Version mismatch error.  This is $PACKAGE $VERSION, but the\n$progname: definition of this LT_INIT comes from an older release.\n$progname: You should recreate aclocal.m4 with macros from $PACKAGE $VERSION\n$progname: and run autoconf again.\n_LT_EOF\n      else\n        cat >&2 <<_LT_EOF\n$progname: Version mismatch error.  This is $PACKAGE $VERSION, but the\n$progname: definition of this LT_INIT comes from $PACKAGE $macro_version.\n$progname: You should recreate aclocal.m4 with macros from $PACKAGE $VERSION\n$progname: and run autoconf again.\n_LT_EOF\n      fi\n    else\n      cat >&2 <<_LT_EOF\n$progname: Version mismatch error.  This is $PACKAGE $VERSION, revision $package_revision,\n$progname: but the definition of this LT_INIT comes from revision $macro_revision.\n$progname: You should recreate aclocal.m4 with macros from revision $package_revision\n$progname: of $PACKAGE $VERSION and run autoconf again.\n_LT_EOF\n    fi\n\n    exit $EXIT_MISMATCH\n  fi\n}\n\n\n# Shorthand for --mode=foo, only valid as the first argument\ncase $1 in\nclean|clea|cle|cl)\n  shift; set dummy --mode clean ${1+\"$@\"}; shift\n  ;;\ncompile|compil|compi|comp|com|co|c)\n  shift; set dummy --mode compile ${1+\"$@\"}; shift\n  ;;\nexecute|execut|execu|exec|exe|ex|e)\n  shift; set dummy --mode execute ${1+\"$@\"}; shift\n  ;;\nfinish|finis|fini|fin|fi|f)\n  shift; set dummy --mode finish ${1+\"$@\"}; shift\n  ;;\ninstall|instal|insta|inst|ins|in|i)\n  shift; set dummy --mode install ${1+\"$@\"}; shift\n  ;;\nlink|lin|li|l)\n  shift; set dummy --mode link ${1+\"$@\"}; shift\n  ;;\nuninstall|uninstal|uninsta|uninst|unins|unin|uni|un|u)\n  shift; set dummy --mode uninstall ${1+\"$@\"}; shift\n  ;;\nesac\n\n\n\n# Option defaults:\nopt_debug=:\nopt_dry_run=false\nopt_config=false\nopt_preserve_dup_deps=false\nopt_features=false\nopt_finish=false\nopt_help=false\nopt_help_all=false\nopt_silent=:\nopt_warning=:\nopt_verbose=:\nopt_silent=false\nopt_verbose=false\n\n\n# Parse options once, thoroughly.  This comes as soon as possible in the\n# script to make things like `--version' happen as quickly as we can.\n{\n  # this just eases exit handling\n  while test $# -gt 0; do\n    opt=\"$1\"\n    shift\n    case $opt in\n      --debug|-x)\topt_debug='set -x'\n\t\t\tfunc_echo \"enabling shell trace mode\"\n\t\t\t$opt_debug\n\t\t\t;;\n      --dry-run|--dryrun|-n)\n\t\t\topt_dry_run=:\n\t\t\t;;\n      --config)\n\t\t\topt_config=:\nfunc_config\n\t\t\t;;\n      --dlopen|-dlopen)\n\t\t\toptarg=\"$1\"\n\t\t\topt_dlopen=\"${opt_dlopen+$opt_dlopen\n}$optarg\"\n\t\t\tshift\n\t\t\t;;\n      --preserve-dup-deps)\n\t\t\topt_preserve_dup_deps=:\n\t\t\t;;\n      --features)\n\t\t\topt_features=:\nfunc_features\n\t\t\t;;\n      --finish)\n\t\t\topt_finish=:\nset dummy --mode finish ${1+\"$@\"}; shift\n\t\t\t;;\n      --help)\n\t\t\topt_help=:\n\t\t\t;;\n      --help-all)\n\t\t\topt_help_all=:\nopt_help=': help-all'\n\t\t\t;;\n      --mode)\n\t\t\ttest $# = 0 && func_missing_arg $opt && break\n\t\t\toptarg=\"$1\"\n\t\t\topt_mode=\"$optarg\"\ncase $optarg in\n  # Valid mode arguments:\n  clean|compile|execute|finish|install|link|relink|uninstall) ;;\n\n  # Catch anything else as an error\n  *) func_error \"invalid argument for $opt\"\n     exit_cmd=exit\n     break\n     ;;\nesac\n\t\t\tshift\n\t\t\t;;\n      --no-silent|--no-quiet)\n\t\t\topt_silent=false\nfunc_append preserve_args \" $opt\"\n\t\t\t;;\n      --no-warning|--no-warn)\n\t\t\topt_warning=false\nfunc_append preserve_args \" $opt\"\n\t\t\t;;\n      --no-verbose)\n\t\t\topt_verbose=false\nfunc_append preserve_args \" $opt\"\n\t\t\t;;\n      --silent|--quiet)\n\t\t\topt_silent=:\nfunc_append preserve_args \" $opt\"\n        opt_verbose=false\n\t\t\t;;\n      --verbose|-v)\n\t\t\topt_verbose=:\nfunc_append preserve_args \" $opt\"\nopt_silent=false\n\t\t\t;;\n      --tag)\n\t\t\ttest $# = 0 && func_missing_arg $opt && break\n\t\t\toptarg=\"$1\"\n\t\t\topt_tag=\"$optarg\"\nfunc_append preserve_args \" $opt $optarg\"\nfunc_enable_tag \"$optarg\"\n\t\t\tshift\n\t\t\t;;\n\n      -\\?|-h)\t\tfunc_usage\t\t\t\t;;\n      --help)\t\tfunc_help\t\t\t\t;;\n      --version)\tfunc_version\t\t\t\t;;\n\n      # Separate optargs to long options:\n      --*=*)\n\t\t\tfunc_split_long_opt \"$opt\"\n\t\t\tset dummy \"$func_split_long_opt_name\" \"$func_split_long_opt_arg\" ${1+\"$@\"}\n\t\t\tshift\n\t\t\t;;\n\n      # Separate non-argument short options:\n      -\\?*|-h*|-n*|-v*)\n\t\t\tfunc_split_short_opt \"$opt\"\n\t\t\tset dummy \"$func_split_short_opt_name\" \"-$func_split_short_opt_arg\" ${1+\"$@\"}\n\t\t\tshift\n\t\t\t;;\n\n      --)\t\tbreak\t\t\t\t\t;;\n      -*)\t\tfunc_fatal_help \"unrecognized option \\`$opt'\" ;;\n      *)\t\tset dummy \"$opt\" ${1+\"$@\"};\tshift; break  ;;\n    esac\n  done\n\n  # Validate options:\n\n  # save first non-option argument\n  if test \"$#\" -gt 0; then\n    nonopt=\"$opt\"\n    shift\n  fi\n\n  # preserve --debug\n  test \"$opt_debug\" = : || func_append preserve_args \" --debug\"\n\n  case $host in\n    *cygwin* | *mingw* | *pw32* | *cegcc*)\n      # don't eliminate duplications in $postdeps and $predeps\n      opt_duplicate_compiler_generated_deps=:\n      ;;\n    *)\n      opt_duplicate_compiler_generated_deps=$opt_preserve_dup_deps\n      ;;\n  esac\n\n  $opt_help || {\n    # Sanity checks first:\n    func_check_version_match\n\n    if test \"$build_libtool_libs\" != yes && test \"$build_old_libs\" != yes; then\n      func_fatal_configuration \"not configured to build any kind of library\"\n    fi\n\n    # Darwin sucks\n    eval std_shrext=\\\"$shrext_cmds\\\"\n\n    # Only execute mode is allowed to have -dlopen flags.\n    if test -n \"$opt_dlopen\" && test \"$opt_mode\" != execute; then\n      func_error \"unrecognized option \\`-dlopen'\"\n      $ECHO \"$help\" 1>&2\n      exit $EXIT_FAILURE\n    fi\n\n    # Change the help message to a mode-specific one.\n    generic_help=\"$help\"\n    help=\"Try \\`$progname --help --mode=$opt_mode' for more information.\"\n  }\n\n\n  # Bail if the options were screwed\n  $exit_cmd $EXIT_FAILURE\n}\n\n\n\n\n## ----------- ##\n##    Main.    ##\n## ----------- ##\n\n# func_lalib_p file\n# True iff FILE is a libtool `.la' library or `.lo' object file.\n# This function is only a basic sanity check; it will hardly flush out\n# determined imposters.\nfunc_lalib_p ()\n{\n    test -f \"$1\" &&\n      $SED -e 4q \"$1\" 2>/dev/null \\\n        | $GREP \"^# Generated by .*$PACKAGE\" > /dev/null 2>&1\n}\n\n# func_lalib_unsafe_p file\n# True iff FILE is a libtool `.la' library or `.lo' object file.\n# This function implements the same check as func_lalib_p without\n# resorting to external programs.  To this end, it redirects stdin and\n# closes it afterwards, without saving the original file descriptor.\n# As a safety measure, use it only where a negative result would be\n# fatal anyway.  Works if `file' does not exist.\nfunc_lalib_unsafe_p ()\n{\n    lalib_p=no\n    if test -f \"$1\" && test -r \"$1\" && exec 5<&0 <\"$1\"; then\n\tfor lalib_p_l in 1 2 3 4\n\tdo\n\t    read lalib_p_line\n\t    case \"$lalib_p_line\" in\n\t\t\\#\\ Generated\\ by\\ *$PACKAGE* ) lalib_p=yes; break;;\n\t    esac\n\tdone\n\texec 0<&5 5<&-\n    fi\n    test \"$lalib_p\" = yes\n}\n\n# func_ltwrapper_script_p file\n# True iff FILE is a libtool wrapper script\n# This function is only a basic sanity check; it will hardly flush out\n# determined imposters.\nfunc_ltwrapper_script_p ()\n{\n    func_lalib_p \"$1\"\n}\n\n# func_ltwrapper_executable_p file\n# True iff FILE is a libtool wrapper executable\n# This function is only a basic sanity check; it will hardly flush out\n# determined imposters.\nfunc_ltwrapper_executable_p ()\n{\n    func_ltwrapper_exec_suffix=\n    case $1 in\n    *.exe) ;;\n    *) func_ltwrapper_exec_suffix=.exe ;;\n    esac\n    $GREP \"$magic_exe\" \"$1$func_ltwrapper_exec_suffix\" >/dev/null 2>&1\n}\n\n# func_ltwrapper_scriptname file\n# Assumes file is an ltwrapper_executable\n# uses $file to determine the appropriate filename for a\n# temporary ltwrapper_script.\nfunc_ltwrapper_scriptname ()\n{\n    func_dirname_and_basename \"$1\" \"\" \".\"\n    func_stripname '' '.exe' \"$func_basename_result\"\n    func_ltwrapper_scriptname_result=\"$func_dirname_result/$objdir/${func_stripname_result}_ltshwrapper\"\n}\n\n# func_ltwrapper_p file\n# True iff FILE is a libtool wrapper script or wrapper executable\n# This function is only a basic sanity check; it will hardly flush out\n# determined imposters.\nfunc_ltwrapper_p ()\n{\n    func_ltwrapper_script_p \"$1\" || func_ltwrapper_executable_p \"$1\"\n}\n\n\n# func_execute_cmds commands fail_cmd\n# Execute tilde-delimited COMMANDS.\n# If FAIL_CMD is given, eval that upon failure.\n# FAIL_CMD may read-access the current command in variable CMD!\nfunc_execute_cmds ()\n{\n    $opt_debug\n    save_ifs=$IFS; IFS='~'\n    for cmd in $1; do\n      IFS=$save_ifs\n      eval cmd=\\\"$cmd\\\"\n      func_show_eval \"$cmd\" \"${2-:}\"\n    done\n    IFS=$save_ifs\n}\n\n\n# func_source file\n# Source FILE, adding directory component if necessary.\n# Note that it is not necessary on cygwin/mingw to append a dot to\n# FILE even if both FILE and FILE.exe exist: automatic-append-.exe\n# behavior happens only for exec(3), not for open(2)!  Also, sourcing\n# `FILE.' does not work on cygwin managed mounts.\nfunc_source ()\n{\n    $opt_debug\n    case $1 in\n    */* | *\\\\*)\t. \"$1\" ;;\n    *)\t\t. \"./$1\" ;;\n    esac\n}\n\n\n# func_resolve_sysroot PATH\n# Replace a leading = in PATH with a sysroot.  Store the result into\n# func_resolve_sysroot_result\nfunc_resolve_sysroot ()\n{\n  func_resolve_sysroot_result=$1\n  case $func_resolve_sysroot_result in\n  =*)\n    func_stripname '=' '' \"$func_resolve_sysroot_result\"\n    func_resolve_sysroot_result=$lt_sysroot$func_stripname_result\n    ;;\n  esac\n}\n\n# func_replace_sysroot PATH\n# If PATH begins with the sysroot, replace it with = and\n# store the result into func_replace_sysroot_result.\nfunc_replace_sysroot ()\n{\n  case \"$lt_sysroot:$1\" in\n  ?*:\"$lt_sysroot\"*)\n    func_stripname \"$lt_sysroot\" '' \"$1\"\n    func_replace_sysroot_result=\"=$func_stripname_result\"\n    ;;\n  *)\n    # Including no sysroot.\n    func_replace_sysroot_result=$1\n    ;;\n  esac\n}\n\n# func_infer_tag arg\n# Infer tagged configuration to use if any are available and\n# if one wasn't chosen via the \"--tag\" command line option.\n# Only attempt this if the compiler in the base compile\n# command doesn't match the default compiler.\n# arg is usually of the form 'gcc ...'\nfunc_infer_tag ()\n{\n    $opt_debug\n    if test -n \"$available_tags\" && test -z \"$tagname\"; then\n      CC_quoted=\n      for arg in $CC; do\n\tfunc_append_quoted CC_quoted \"$arg\"\n      done\n      CC_expanded=`func_echo_all $CC`\n      CC_quoted_expanded=`func_echo_all $CC_quoted`\n      case $@ in\n      # Blanks in the command may have been stripped by the calling shell,\n      # but not from the CC environment variable when configure was run.\n      \" $CC \"* | \"$CC \"* | \" $CC_expanded \"* | \"$CC_expanded \"* | \\\n      \" $CC_quoted\"* | \"$CC_quoted \"* | \" $CC_quoted_expanded \"* | \"$CC_quoted_expanded \"*) ;;\n      # Blanks at the start of $base_compile will cause this to fail\n      # if we don't check for them as well.\n      *)\n\tfor z in $available_tags; do\n\t  if $GREP \"^# ### BEGIN LIBTOOL TAG CONFIG: $z$\" < \"$progpath\" > /dev/null; then\n\t    # Evaluate the configuration.\n\t    eval \"`${SED} -n -e '/^# ### BEGIN LIBTOOL TAG CONFIG: '$z'$/,/^# ### END LIBTOOL TAG CONFIG: '$z'$/p' < $progpath`\"\n\t    CC_quoted=\n\t    for arg in $CC; do\n\t      # Double-quote args containing other shell metacharacters.\n\t      func_append_quoted CC_quoted \"$arg\"\n\t    done\n\t    CC_expanded=`func_echo_all $CC`\n\t    CC_quoted_expanded=`func_echo_all $CC_quoted`\n\t    case \"$@ \" in\n\t    \" $CC \"* | \"$CC \"* | \" $CC_expanded \"* | \"$CC_expanded \"* | \\\n\t    \" $CC_quoted\"* | \"$CC_quoted \"* | \" $CC_quoted_expanded \"* | \"$CC_quoted_expanded \"*)\n\t      # The compiler in the base compile command matches\n\t      # the one in the tagged configuration.\n\t      # Assume this is the tagged configuration we want.\n\t      tagname=$z\n\t      break\n\t      ;;\n\t    esac\n\t  fi\n\tdone\n\t# If $tagname still isn't set, then no tagged configuration\n\t# was found and let the user know that the \"--tag\" command\n\t# line option must be used.\n\tif test -z \"$tagname\"; then\n\t  func_echo \"unable to infer tagged configuration\"\n\t  func_fatal_error \"specify a tag with \\`--tag'\"\n#\telse\n#\t  func_verbose \"using $tagname tagged configuration\"\n\tfi\n\t;;\n      esac\n    fi\n}\n\n\n\n# func_write_libtool_object output_name pic_name nonpic_name\n# Create a libtool object file (analogous to a \".la\" file),\n# but don't create it if we're doing a dry run.\nfunc_write_libtool_object ()\n{\n    write_libobj=${1}\n    if test \"$build_libtool_libs\" = yes; then\n      write_lobj=\\'${2}\\'\n    else\n      write_lobj=none\n    fi\n\n    if test \"$build_old_libs\" = yes; then\n      write_oldobj=\\'${3}\\'\n    else\n      write_oldobj=none\n    fi\n\n    $opt_dry_run || {\n      cat >${write_libobj}T <<EOF\n# $write_libobj - a libtool object file\n# Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION\n#\n# Please DO NOT delete this file!\n# It is necessary for linking the library.\n\n# Name of the PIC object.\npic_object=$write_lobj\n\n# Name of the non-PIC object\nnon_pic_object=$write_oldobj\n\nEOF\n      $MV \"${write_libobj}T\" \"${write_libobj}\"\n    }\n}\n\n\n##################################################\n# FILE NAME AND PATH CONVERSION HELPER FUNCTIONS #\n##################################################\n\n# func_convert_core_file_wine_to_w32 ARG\n# Helper function used by file name conversion functions when $build is *nix,\n# and $host is mingw, cygwin, or some other w32 environment. Relies on a\n# correctly configured wine environment available, with the winepath program\n# in $build's $PATH.\n#\n# ARG is the $build file name to be converted to w32 format.\n# Result is available in $func_convert_core_file_wine_to_w32_result, and will\n# be empty on error (or when ARG is empty)\nfunc_convert_core_file_wine_to_w32 ()\n{\n  $opt_debug\n  func_convert_core_file_wine_to_w32_result=\"$1\"\n  if test -n \"$1\"; then\n    # Unfortunately, winepath does not exit with a non-zero error code, so we\n    # are forced to check the contents of stdout. On the other hand, if the\n    # command is not found, the shell will set an exit code of 127 and print\n    # *an error message* to stdout. So we must check for both error code of\n    # zero AND non-empty stdout, which explains the odd construction:\n    func_convert_core_file_wine_to_w32_tmp=`winepath -w \"$1\" 2>/dev/null`\n    if test \"$?\" -eq 0 && test -n \"${func_convert_core_file_wine_to_w32_tmp}\"; then\n      func_convert_core_file_wine_to_w32_result=`$ECHO \"$func_convert_core_file_wine_to_w32_tmp\" |\n        $SED -e \"$lt_sed_naive_backslashify\"`\n    else\n      func_convert_core_file_wine_to_w32_result=\n    fi\n  fi\n}\n# end: func_convert_core_file_wine_to_w32\n\n\n# func_convert_core_path_wine_to_w32 ARG\n# Helper function used by path conversion functions when $build is *nix, and\n# $host is mingw, cygwin, or some other w32 environment. Relies on a correctly\n# configured wine environment available, with the winepath program in $build's\n# $PATH. Assumes ARG has no leading or trailing path separator characters.\n#\n# ARG is path to be converted from $build format to win32.\n# Result is available in $func_convert_core_path_wine_to_w32_result.\n# Unconvertible file (directory) names in ARG are skipped; if no directory names\n# are convertible, then the result may be empty.\nfunc_convert_core_path_wine_to_w32 ()\n{\n  $opt_debug\n  # unfortunately, winepath doesn't convert paths, only file names\n  func_convert_core_path_wine_to_w32_result=\"\"\n  if test -n \"$1\"; then\n    oldIFS=$IFS\n    IFS=:\n    for func_convert_core_path_wine_to_w32_f in $1; do\n      IFS=$oldIFS\n      func_convert_core_file_wine_to_w32 \"$func_convert_core_path_wine_to_w32_f\"\n      if test -n \"$func_convert_core_file_wine_to_w32_result\" ; then\n        if test -z \"$func_convert_core_path_wine_to_w32_result\"; then\n          func_convert_core_path_wine_to_w32_result=\"$func_convert_core_file_wine_to_w32_result\"\n        else\n          func_append func_convert_core_path_wine_to_w32_result \";$func_convert_core_file_wine_to_w32_result\"\n        fi\n      fi\n    done\n    IFS=$oldIFS\n  fi\n}\n# end: func_convert_core_path_wine_to_w32\n\n\n# func_cygpath ARGS...\n# Wrapper around calling the cygpath program via LT_CYGPATH. This is used when\n# when (1) $build is *nix and Cygwin is hosted via a wine environment; or (2)\n# $build is MSYS and $host is Cygwin, or (3) $build is Cygwin. In case (1) or\n# (2), returns the Cygwin file name or path in func_cygpath_result (input\n# file name or path is assumed to be in w32 format, as previously converted\n# from $build's *nix or MSYS format). In case (3), returns the w32 file name\n# or path in func_cygpath_result (input file name or path is assumed to be in\n# Cygwin format). Returns an empty string on error.\n#\n# ARGS are passed to cygpath, with the last one being the file name or path to\n# be converted.\n#\n# Specify the absolute *nix (or w32) name to cygpath in the LT_CYGPATH\n# environment variable; do not put it in $PATH.\nfunc_cygpath ()\n{\n  $opt_debug\n  if test -n \"$LT_CYGPATH\" && test -f \"$LT_CYGPATH\"; then\n    func_cygpath_result=`$LT_CYGPATH \"$@\" 2>/dev/null`\n    if test \"$?\" -ne 0; then\n      # on failure, ensure result is empty\n      func_cygpath_result=\n    fi\n  else\n    func_cygpath_result=\n    func_error \"LT_CYGPATH is empty or specifies non-existent file: \\`$LT_CYGPATH'\"\n  fi\n}\n#end: func_cygpath\n\n\n# func_convert_core_msys_to_w32 ARG\n# Convert file name or path ARG from MSYS format to w32 format.  Return\n# result in func_convert_core_msys_to_w32_result.\nfunc_convert_core_msys_to_w32 ()\n{\n  $opt_debug\n  # awkward: cmd appends spaces to result\n  func_convert_core_msys_to_w32_result=`( cmd //c echo \"$1\" ) 2>/dev/null |\n    $SED -e 's/[ ]*$//' -e \"$lt_sed_naive_backslashify\"`\n}\n#end: func_convert_core_msys_to_w32\n\n\n# func_convert_file_check ARG1 ARG2\n# Verify that ARG1 (a file name in $build format) was converted to $host\n# format in ARG2. Otherwise, emit an error message, but continue (resetting\n# func_to_host_file_result to ARG1).\nfunc_convert_file_check ()\n{\n  $opt_debug\n  if test -z \"$2\" && test -n \"$1\" ; then\n    func_error \"Could not determine host file name corresponding to\"\n    func_error \"  \\`$1'\"\n    func_error \"Continuing, but uninstalled executables may not work.\"\n    # Fallback:\n    func_to_host_file_result=\"$1\"\n  fi\n}\n# end func_convert_file_check\n\n\n# func_convert_path_check FROM_PATHSEP TO_PATHSEP FROM_PATH TO_PATH\n# Verify that FROM_PATH (a path in $build format) was converted to $host\n# format in TO_PATH. Otherwise, emit an error message, but continue, resetting\n# func_to_host_file_result to a simplistic fallback value (see below).\nfunc_convert_path_check ()\n{\n  $opt_debug\n  if test -z \"$4\" && test -n \"$3\"; then\n    func_error \"Could not determine the host path corresponding to\"\n    func_error \"  \\`$3'\"\n    func_error \"Continuing, but uninstalled executables may not work.\"\n    # Fallback.  This is a deliberately simplistic \"conversion\" and\n    # should not be \"improved\".  See libtool.info.\n    if test \"x$1\" != \"x$2\"; then\n      lt_replace_pathsep_chars=\"s|$1|$2|g\"\n      func_to_host_path_result=`echo \"$3\" |\n        $SED -e \"$lt_replace_pathsep_chars\"`\n    else\n      func_to_host_path_result=\"$3\"\n    fi\n  fi\n}\n# end func_convert_path_check\n\n\n# func_convert_path_front_back_pathsep FRONTPAT BACKPAT REPL ORIG\n# Modifies func_to_host_path_result by prepending REPL if ORIG matches FRONTPAT\n# and appending REPL if ORIG matches BACKPAT.\nfunc_convert_path_front_back_pathsep ()\n{\n  $opt_debug\n  case $4 in\n  $1 ) func_to_host_path_result=\"$3$func_to_host_path_result\"\n    ;;\n  esac\n  case $4 in\n  $2 ) func_append func_to_host_path_result \"$3\"\n    ;;\n  esac\n}\n# end func_convert_path_front_back_pathsep\n\n\n##################################################\n# $build to $host FILE NAME CONVERSION FUNCTIONS #\n##################################################\n# invoked via `$to_host_file_cmd ARG'\n#\n# In each case, ARG is the path to be converted from $build to $host format.\n# Result will be available in $func_to_host_file_result.\n\n\n# func_to_host_file ARG\n# Converts the file name ARG from $build format to $host format. Return result\n# in func_to_host_file_result.\nfunc_to_host_file ()\n{\n  $opt_debug\n  $to_host_file_cmd \"$1\"\n}\n# end func_to_host_file\n\n\n# func_to_tool_file ARG LAZY\n# converts the file name ARG from $build format to toolchain format. Return\n# result in func_to_tool_file_result.  If the conversion in use is listed\n# in (the comma separated) LAZY, no conversion takes place.\nfunc_to_tool_file ()\n{\n  $opt_debug\n  case ,$2, in\n    *,\"$to_tool_file_cmd\",*)\n      func_to_tool_file_result=$1\n      ;;\n    *)\n      $to_tool_file_cmd \"$1\"\n      func_to_tool_file_result=$func_to_host_file_result\n      ;;\n  esac\n}\n# end func_to_tool_file\n\n\n# func_convert_file_noop ARG\n# Copy ARG to func_to_host_file_result.\nfunc_convert_file_noop ()\n{\n  func_to_host_file_result=\"$1\"\n}\n# end func_convert_file_noop\n\n\n# func_convert_file_msys_to_w32 ARG\n# Convert file name ARG from (mingw) MSYS to (mingw) w32 format; automatic\n# conversion to w32 is not available inside the cwrapper.  Returns result in\n# func_to_host_file_result.\nfunc_convert_file_msys_to_w32 ()\n{\n  $opt_debug\n  func_to_host_file_result=\"$1\"\n  if test -n \"$1\"; then\n    func_convert_core_msys_to_w32 \"$1\"\n    func_to_host_file_result=\"$func_convert_core_msys_to_w32_result\"\n  fi\n  func_convert_file_check \"$1\" \"$func_to_host_file_result\"\n}\n# end func_convert_file_msys_to_w32\n\n\n# func_convert_file_cygwin_to_w32 ARG\n# Convert file name ARG from Cygwin to w32 format.  Returns result in\n# func_to_host_file_result.\nfunc_convert_file_cygwin_to_w32 ()\n{\n  $opt_debug\n  func_to_host_file_result=\"$1\"\n  if test -n \"$1\"; then\n    # because $build is cygwin, we call \"the\" cygpath in $PATH; no need to use\n    # LT_CYGPATH in this case.\n    func_to_host_file_result=`cygpath -m \"$1\"`\n  fi\n  func_convert_file_check \"$1\" \"$func_to_host_file_result\"\n}\n# end func_convert_file_cygwin_to_w32\n\n\n# func_convert_file_nix_to_w32 ARG\n# Convert file name ARG from *nix to w32 format.  Requires a wine environment\n# and a working winepath. Returns result in func_to_host_file_result.\nfunc_convert_file_nix_to_w32 ()\n{\n  $opt_debug\n  func_to_host_file_result=\"$1\"\n  if test -n \"$1\"; then\n    func_convert_core_file_wine_to_w32 \"$1\"\n    func_to_host_file_result=\"$func_convert_core_file_wine_to_w32_result\"\n  fi\n  func_convert_file_check \"$1\" \"$func_to_host_file_result\"\n}\n# end func_convert_file_nix_to_w32\n\n\n# func_convert_file_msys_to_cygwin ARG\n# Convert file name ARG from MSYS to Cygwin format.  Requires LT_CYGPATH set.\n# Returns result in func_to_host_file_result.\nfunc_convert_file_msys_to_cygwin ()\n{\n  $opt_debug\n  func_to_host_file_result=\"$1\"\n  if test -n \"$1\"; then\n    func_convert_core_msys_to_w32 \"$1\"\n    func_cygpath -u \"$func_convert_core_msys_to_w32_result\"\n    func_to_host_file_result=\"$func_cygpath_result\"\n  fi\n  func_convert_file_check \"$1\" \"$func_to_host_file_result\"\n}\n# end func_convert_file_msys_to_cygwin\n\n\n# func_convert_file_nix_to_cygwin ARG\n# Convert file name ARG from *nix to Cygwin format.  Requires Cygwin installed\n# in a wine environment, working winepath, and LT_CYGPATH set.  Returns result\n# in func_to_host_file_result.\nfunc_convert_file_nix_to_cygwin ()\n{\n  $opt_debug\n  func_to_host_file_result=\"$1\"\n  if test -n \"$1\"; then\n    # convert from *nix to w32, then use cygpath to convert from w32 to cygwin.\n    func_convert_core_file_wine_to_w32 \"$1\"\n    func_cygpath -u \"$func_convert_core_file_wine_to_w32_result\"\n    func_to_host_file_result=\"$func_cygpath_result\"\n  fi\n  func_convert_file_check \"$1\" \"$func_to_host_file_result\"\n}\n# end func_convert_file_nix_to_cygwin\n\n\n#############################################\n# $build to $host PATH CONVERSION FUNCTIONS #\n#############################################\n# invoked via `$to_host_path_cmd ARG'\n#\n# In each case, ARG is the path to be converted from $build to $host format.\n# The result will be available in $func_to_host_path_result.\n#\n# Path separators are also converted from $build format to $host format.  If\n# ARG begins or ends with a path separator character, it is preserved (but\n# converted to $host format) on output.\n#\n# All path conversion functions are named using the following convention:\n#   file name conversion function    : func_convert_file_X_to_Y ()\n#   path conversion function         : func_convert_path_X_to_Y ()\n# where, for any given $build/$host combination the 'X_to_Y' value is the\n# same.  If conversion functions are added for new $build/$host combinations,\n# the two new functions must follow this pattern, or func_init_to_host_path_cmd\n# will break.\n\n\n# func_init_to_host_path_cmd\n# Ensures that function \"pointer\" variable $to_host_path_cmd is set to the\n# appropriate value, based on the value of $to_host_file_cmd.\nto_host_path_cmd=\nfunc_init_to_host_path_cmd ()\n{\n  $opt_debug\n  if test -z \"$to_host_path_cmd\"; then\n    func_stripname 'func_convert_file_' '' \"$to_host_file_cmd\"\n    to_host_path_cmd=\"func_convert_path_${func_stripname_result}\"\n  fi\n}\n\n\n# func_to_host_path ARG\n# Converts the path ARG from $build format to $host format. Return result\n# in func_to_host_path_result.\nfunc_to_host_path ()\n{\n  $opt_debug\n  func_init_to_host_path_cmd\n  $to_host_path_cmd \"$1\"\n}\n# end func_to_host_path\n\n\n# func_convert_path_noop ARG\n# Copy ARG to func_to_host_path_result.\nfunc_convert_path_noop ()\n{\n  func_to_host_path_result=\"$1\"\n}\n# end func_convert_path_noop\n\n\n# func_convert_path_msys_to_w32 ARG\n# Convert path ARG from (mingw) MSYS to (mingw) w32 format; automatic\n# conversion to w32 is not available inside the cwrapper.  Returns result in\n# func_to_host_path_result.\nfunc_convert_path_msys_to_w32 ()\n{\n  $opt_debug\n  func_to_host_path_result=\"$1\"\n  if test -n \"$1\"; then\n    # Remove leading and trailing path separator characters from ARG.  MSYS\n    # behavior is inconsistent here; cygpath turns them into '.;' and ';.';\n    # and winepath ignores them completely.\n    func_stripname : : \"$1\"\n    func_to_host_path_tmp1=$func_stripname_result\n    func_convert_core_msys_to_w32 \"$func_to_host_path_tmp1\"\n    func_to_host_path_result=\"$func_convert_core_msys_to_w32_result\"\n    func_convert_path_check : \";\" \\\n      \"$func_to_host_path_tmp1\" \"$func_to_host_path_result\"\n    func_convert_path_front_back_pathsep \":*\" \"*:\" \";\" \"$1\"\n  fi\n}\n# end func_convert_path_msys_to_w32\n\n\n# func_convert_path_cygwin_to_w32 ARG\n# Convert path ARG from Cygwin to w32 format.  Returns result in\n# func_to_host_file_result.\nfunc_convert_path_cygwin_to_w32 ()\n{\n  $opt_debug\n  func_to_host_path_result=\"$1\"\n  if test -n \"$1\"; then\n    # See func_convert_path_msys_to_w32:\n    func_stripname : : \"$1\"\n    func_to_host_path_tmp1=$func_stripname_result\n    func_to_host_path_result=`cygpath -m -p \"$func_to_host_path_tmp1\"`\n    func_convert_path_check : \";\" \\\n      \"$func_to_host_path_tmp1\" \"$func_to_host_path_result\"\n    func_convert_path_front_back_pathsep \":*\" \"*:\" \";\" \"$1\"\n  fi\n}\n# end func_convert_path_cygwin_to_w32\n\n\n# func_convert_path_nix_to_w32 ARG\n# Convert path ARG from *nix to w32 format.  Requires a wine environment and\n# a working winepath.  Returns result in func_to_host_file_result.\nfunc_convert_path_nix_to_w32 ()\n{\n  $opt_debug\n  func_to_host_path_result=\"$1\"\n  if test -n \"$1\"; then\n    # See func_convert_path_msys_to_w32:\n    func_stripname : : \"$1\"\n    func_to_host_path_tmp1=$func_stripname_result\n    func_convert_core_path_wine_to_w32 \"$func_to_host_path_tmp1\"\n    func_to_host_path_result=\"$func_convert_core_path_wine_to_w32_result\"\n    func_convert_path_check : \";\" \\\n      \"$func_to_host_path_tmp1\" \"$func_to_host_path_result\"\n    func_convert_path_front_back_pathsep \":*\" \"*:\" \";\" \"$1\"\n  fi\n}\n# end func_convert_path_nix_to_w32\n\n\n# func_convert_path_msys_to_cygwin ARG\n# Convert path ARG from MSYS to Cygwin format.  Requires LT_CYGPATH set.\n# Returns result in func_to_host_file_result.\nfunc_convert_path_msys_to_cygwin ()\n{\n  $opt_debug\n  func_to_host_path_result=\"$1\"\n  if test -n \"$1\"; then\n    # See func_convert_path_msys_to_w32:\n    func_stripname : : \"$1\"\n    func_to_host_path_tmp1=$func_stripname_result\n    func_convert_core_msys_to_w32 \"$func_to_host_path_tmp1\"\n    func_cygpath -u -p \"$func_convert_core_msys_to_w32_result\"\n    func_to_host_path_result=\"$func_cygpath_result\"\n    func_convert_path_check : : \\\n      \"$func_to_host_path_tmp1\" \"$func_to_host_path_result\"\n    func_convert_path_front_back_pathsep \":*\" \"*:\" : \"$1\"\n  fi\n}\n# end func_convert_path_msys_to_cygwin\n\n\n# func_convert_path_nix_to_cygwin ARG\n# Convert path ARG from *nix to Cygwin format.  Requires Cygwin installed in a\n# a wine environment, working winepath, and LT_CYGPATH set.  Returns result in\n# func_to_host_file_result.\nfunc_convert_path_nix_to_cygwin ()\n{\n  $opt_debug\n  func_to_host_path_result=\"$1\"\n  if test -n \"$1\"; then\n    # Remove leading and trailing path separator characters from\n    # ARG. msys behavior is inconsistent here, cygpath turns them\n    # into '.;' and ';.', and winepath ignores them completely.\n    func_stripname : : \"$1\"\n    func_to_host_path_tmp1=$func_stripname_result\n    func_convert_core_path_wine_to_w32 \"$func_to_host_path_tmp1\"\n    func_cygpath -u -p \"$func_convert_core_path_wine_to_w32_result\"\n    func_to_host_path_result=\"$func_cygpath_result\"\n    func_convert_path_check : : \\\n      \"$func_to_host_path_tmp1\" \"$func_to_host_path_result\"\n    func_convert_path_front_back_pathsep \":*\" \"*:\" : \"$1\"\n  fi\n}\n# end func_convert_path_nix_to_cygwin\n\n\n# func_mode_compile arg...\nfunc_mode_compile ()\n{\n    $opt_debug\n    # Get the compilation command and the source file.\n    base_compile=\n    srcfile=\"$nonopt\"  #  always keep a non-empty value in \"srcfile\"\n    suppress_opt=yes\n    suppress_output=\n    arg_mode=normal\n    libobj=\n    later=\n    pie_flag=\n\n    for arg\n    do\n      case $arg_mode in\n      arg  )\n\t# do not \"continue\".  Instead, add this to base_compile\n\tlastarg=\"$arg\"\n\targ_mode=normal\n\t;;\n\n      target )\n\tlibobj=\"$arg\"\n\targ_mode=normal\n\tcontinue\n\t;;\n\n      normal )\n\t# Accept any command-line options.\n\tcase $arg in\n\t-o)\n\t  test -n \"$libobj\" && \\\n\t    func_fatal_error \"you cannot specify \\`-o' more than once\"\n\t  arg_mode=target\n\t  continue\n\t  ;;\n\n\t-pie | -fpie | -fPIE)\n          func_append pie_flag \" $arg\"\n\t  continue\n\t  ;;\n\n\t-shared | -static | -prefer-pic | -prefer-non-pic)\n\t  func_append later \" $arg\"\n\t  continue\n\t  ;;\n\n\t-no-suppress)\n\t  suppress_opt=no\n\t  continue\n\t  ;;\n\n\t-Xcompiler)\n\t  arg_mode=arg  #  the next one goes into the \"base_compile\" arg list\n\t  continue      #  The current \"srcfile\" will either be retained or\n\t  ;;            #  replaced later.  I would guess that would be a bug.\n\n\t-Wc,*)\n\t  func_stripname '-Wc,' '' \"$arg\"\n\t  args=$func_stripname_result\n\t  lastarg=\n\t  save_ifs=\"$IFS\"; IFS=','\n\t  for arg in $args; do\n\t    IFS=\"$save_ifs\"\n\t    func_append_quoted lastarg \"$arg\"\n\t  done\n\t  IFS=\"$save_ifs\"\n\t  func_stripname ' ' '' \"$lastarg\"\n\t  lastarg=$func_stripname_result\n\n\t  # Add the arguments to base_compile.\n\t  func_append base_compile \" $lastarg\"\n\t  continue\n\t  ;;\n\n\t*)\n\t  # Accept the current argument as the source file.\n\t  # The previous \"srcfile\" becomes the current argument.\n\t  #\n\t  lastarg=\"$srcfile\"\n\t  srcfile=\"$arg\"\n\t  ;;\n\tesac  #  case $arg\n\t;;\n      esac    #  case $arg_mode\n\n      # Aesthetically quote the previous argument.\n      func_append_quoted base_compile \"$lastarg\"\n    done # for arg\n\n    case $arg_mode in\n    arg)\n      func_fatal_error \"you must specify an argument for -Xcompile\"\n      ;;\n    target)\n      func_fatal_error \"you must specify a target with \\`-o'\"\n      ;;\n    *)\n      # Get the name of the library object.\n      test -z \"$libobj\" && {\n\tfunc_basename \"$srcfile\"\n\tlibobj=\"$func_basename_result\"\n      }\n      ;;\n    esac\n\n    # Recognize several different file suffixes.\n    # If the user specifies -o file.o, it is replaced with file.lo\n    case $libobj in\n    *.[cCFSifmso] | \\\n    *.ada | *.adb | *.ads | *.asm | \\\n    *.c++ | *.cc | *.ii | *.class | *.cpp | *.cxx | \\\n    *.[fF][09]? | *.for | *.java | *.go | *.obj | *.sx | *.cu | *.cup)\n      func_xform \"$libobj\"\n      libobj=$func_xform_result\n      ;;\n    esac\n\n    case $libobj in\n    *.lo) func_lo2o \"$libobj\"; obj=$func_lo2o_result ;;\n    *)\n      func_fatal_error \"cannot determine name of library object from \\`$libobj'\"\n      ;;\n    esac\n\n    func_infer_tag $base_compile\n\n    for arg in $later; do\n      case $arg in\n      -shared)\n\ttest \"$build_libtool_libs\" != yes && \\\n\t  func_fatal_configuration \"can not build a shared library\"\n\tbuild_old_libs=no\n\tcontinue\n\t;;\n\n      -static)\n\tbuild_libtool_libs=no\n\tbuild_old_libs=yes\n\tcontinue\n\t;;\n\n      -prefer-pic)\n\tpic_mode=yes\n\tcontinue\n\t;;\n\n      -prefer-non-pic)\n\tpic_mode=no\n\tcontinue\n\t;;\n      esac\n    done\n\n    func_quote_for_eval \"$libobj\"\n    test \"X$libobj\" != \"X$func_quote_for_eval_result\" \\\n      && $ECHO \"X$libobj\" | $GREP '[]~#^*{};<>?\"'\"'\"'\t &()|`$[]' \\\n      && func_warning \"libobj name \\`$libobj' may not contain shell special characters.\"\n    func_dirname_and_basename \"$obj\" \"/\" \"\"\n    objname=\"$func_basename_result\"\n    xdir=\"$func_dirname_result\"\n    lobj=${xdir}$objdir/$objname\n\n    test -z \"$base_compile\" && \\\n      func_fatal_help \"you must specify a compilation command\"\n\n    # Delete any leftover library objects.\n    if test \"$build_old_libs\" = yes; then\n      removelist=\"$obj $lobj $libobj ${libobj}T\"\n    else\n      removelist=\"$lobj $libobj ${libobj}T\"\n    fi\n\n    # On Cygwin there's no \"real\" PIC flag so we must build both object types\n    case $host_os in\n    cygwin* | mingw* | pw32* | os2* | cegcc*)\n      pic_mode=default\n      ;;\n    esac\n    if test \"$pic_mode\" = no && test \"$deplibs_check_method\" != pass_all; then\n      # non-PIC code in shared libraries is not supported\n      pic_mode=default\n    fi\n\n    # Calculate the filename of the output object if compiler does\n    # not support -o with -c\n    if test \"$compiler_c_o\" = no; then\n      output_obj=`$ECHO \"$srcfile\" | $SED 's%^.*/%%; s%\\.[^.]*$%%'`.${objext}\n      lockfile=\"$output_obj.lock\"\n    else\n      output_obj=\n      need_locks=no\n      lockfile=\n    fi\n\n    # Lock this critical section if it is needed\n    # We use this script file to make the link, it avoids creating a new file\n    if test \"$need_locks\" = yes; then\n      until $opt_dry_run || ln \"$progpath\" \"$lockfile\" 2>/dev/null; do\n\tfunc_echo \"Waiting for $lockfile to be removed\"\n\tsleep 2\n      done\n    elif test \"$need_locks\" = warn; then\n      if test -f \"$lockfile\"; then\n\t$ECHO \"\\\n*** ERROR, $lockfile exists and contains:\n`cat $lockfile 2>/dev/null`\n\nThis indicates that another process is trying to use the same\ntemporary object file, and libtool could not work around it because\nyour compiler does not support \\`-c' and \\`-o' together.  If you\nrepeat this compilation, it may succeed, by chance, but you had better\navoid parallel builds (make -j) in this platform, or get a better\ncompiler.\"\n\n\t$opt_dry_run || $RM $removelist\n\texit $EXIT_FAILURE\n      fi\n      func_append removelist \" $output_obj\"\n      $ECHO \"$srcfile\" > \"$lockfile\"\n    fi\n\n    $opt_dry_run || $RM $removelist\n    func_append removelist \" $lockfile\"\n    trap '$opt_dry_run || $RM $removelist; exit $EXIT_FAILURE' 1 2 15\n\n    func_to_tool_file \"$srcfile\" func_convert_file_msys_to_w32\n    srcfile=$func_to_tool_file_result\n    func_quote_for_eval \"$srcfile\"\n    qsrcfile=$func_quote_for_eval_result\n\n    # Only build a PIC object if we are building libtool libraries.\n    if test \"$build_libtool_libs\" = yes; then\n      # Without this assignment, base_compile gets emptied.\n      fbsd_hideous_sh_bug=$base_compile\n\n      if test \"$pic_mode\" != no; then\n\tcommand=\"$base_compile $qsrcfile $pic_flag\"\n      else\n\t# Don't build PIC code\n\tcommand=\"$base_compile $qsrcfile\"\n      fi\n\n      func_mkdir_p \"$xdir$objdir\"\n\n      if test -z \"$output_obj\"; then\n\t# Place PIC objects in $objdir\n\tfunc_append command \" -o $lobj\"\n      fi\n\n      func_show_eval_locale \"$command\"\t\\\n          'test -n \"$output_obj\" && $RM $removelist; exit $EXIT_FAILURE'\n\n      if test \"$need_locks\" = warn &&\n\t test \"X`cat $lockfile 2>/dev/null`\" != \"X$srcfile\"; then\n\t$ECHO \"\\\n*** ERROR, $lockfile contains:\n`cat $lockfile 2>/dev/null`\n\nbut it should contain:\n$srcfile\n\nThis indicates that another process is trying to use the same\ntemporary object file, and libtool could not work around it because\nyour compiler does not support \\`-c' and \\`-o' together.  If you\nrepeat this compilation, it may succeed, by chance, but you had better\navoid parallel builds (make -j) in this platform, or get a better\ncompiler.\"\n\n\t$opt_dry_run || $RM $removelist\n\texit $EXIT_FAILURE\n      fi\n\n      # Just move the object if needed, then go on to compile the next one\n      if test -n \"$output_obj\" && test \"X$output_obj\" != \"X$lobj\"; then\n\tfunc_show_eval '$MV \"$output_obj\" \"$lobj\"' \\\n\t  'error=$?; $opt_dry_run || $RM $removelist; exit $error'\n      fi\n\n      # Allow error messages only from the first compilation.\n      if test \"$suppress_opt\" = yes; then\n\tsuppress_output=' >/dev/null 2>&1'\n      fi\n    fi\n\n    # Only build a position-dependent object if we build old libraries.\n    if test \"$build_old_libs\" = yes; then\n      if test \"$pic_mode\" != yes; then\n\t# Don't build PIC code\n\tcommand=\"$base_compile $qsrcfile$pie_flag\"\n      else\n\tcommand=\"$base_compile $qsrcfile $pic_flag\"\n      fi\n      if test \"$compiler_c_o\" = yes; then\n\tfunc_append command \" -o $obj\"\n      fi\n\n      # Suppress compiler output if we already did a PIC compilation.\n      func_append command \"$suppress_output\"\n      func_show_eval_locale \"$command\" \\\n        '$opt_dry_run || $RM $removelist; exit $EXIT_FAILURE'\n\n      if test \"$need_locks\" = warn &&\n\t test \"X`cat $lockfile 2>/dev/null`\" != \"X$srcfile\"; then\n\t$ECHO \"\\\n*** ERROR, $lockfile contains:\n`cat $lockfile 2>/dev/null`\n\nbut it should contain:\n$srcfile\n\nThis indicates that another process is trying to use the same\ntemporary object file, and libtool could not work around it because\nyour compiler does not support \\`-c' and \\`-o' together.  If you\nrepeat this compilation, it may succeed, by chance, but you had better\navoid parallel builds (make -j) in this platform, or get a better\ncompiler.\"\n\n\t$opt_dry_run || $RM $removelist\n\texit $EXIT_FAILURE\n      fi\n\n      # Just move the object if needed\n      if test -n \"$output_obj\" && test \"X$output_obj\" != \"X$obj\"; then\n\tfunc_show_eval '$MV \"$output_obj\" \"$obj\"' \\\n\t  'error=$?; $opt_dry_run || $RM $removelist; exit $error'\n      fi\n    fi\n\n    $opt_dry_run || {\n      func_write_libtool_object \"$libobj\" \"$objdir/$objname\" \"$objname\"\n\n      # Unlock the critical section if it was locked\n      if test \"$need_locks\" != no; then\n\tremovelist=$lockfile\n        $RM \"$lockfile\"\n      fi\n    }\n\n    exit $EXIT_SUCCESS\n}\n\n$opt_help || {\n  test \"$opt_mode\" = compile && func_mode_compile ${1+\"$@\"}\n}\n\nfunc_mode_help ()\n{\n    # We need to display help for each of the modes.\n    case $opt_mode in\n      \"\")\n        # Generic help is extracted from the usage comments\n        # at the start of this file.\n        func_help\n        ;;\n\n      clean)\n        $ECHO \\\n\"Usage: $progname [OPTION]... --mode=clean RM [RM-OPTION]... FILE...\n\nRemove files from the build directory.\n\nRM is the name of the program to use to delete files associated with each FILE\n(typically \\`/bin/rm').  RM-OPTIONS are options (such as \\`-f') to be passed\nto RM.\n\nIf FILE is a libtool library, object or program, all the files associated\nwith it are deleted. Otherwise, only FILE itself is deleted using RM.\"\n        ;;\n\n      compile)\n      $ECHO \\\n\"Usage: $progname [OPTION]... --mode=compile COMPILE-COMMAND... SOURCEFILE\n\nCompile a source file into a libtool library object.\n\nThis mode accepts the following additional options:\n\n  -o OUTPUT-FILE    set the output file name to OUTPUT-FILE\n  -no-suppress      do not suppress compiler output for multiple passes\n  -prefer-pic       try to build PIC objects only\n  -prefer-non-pic   try to build non-PIC objects only\n  -shared           do not build a \\`.o' file suitable for static linking\n  -static           only build a \\`.o' file suitable for static linking\n  -Wc,FLAG          pass FLAG directly to the compiler\n\nCOMPILE-COMMAND is a command to be used in creating a \\`standard' object file\nfrom the given SOURCEFILE.\n\nThe output file name is determined by removing the directory component from\nSOURCEFILE, then substituting the C source code suffix \\`.c' with the\nlibrary object suffix, \\`.lo'.\"\n        ;;\n\n      execute)\n        $ECHO \\\n\"Usage: $progname [OPTION]... --mode=execute COMMAND [ARGS]...\n\nAutomatically set library path, then run a program.\n\nThis mode accepts the following additional options:\n\n  -dlopen FILE      add the directory containing FILE to the library path\n\nThis mode sets the library path environment variable according to \\`-dlopen'\nflags.\n\nIf any of the ARGS are libtool executable wrappers, then they are translated\ninto their corresponding uninstalled binary, and any of their required library\ndirectories are added to the library path.\n\nThen, COMMAND is executed, with ARGS as arguments.\"\n        ;;\n\n      finish)\n        $ECHO \\\n\"Usage: $progname [OPTION]... --mode=finish [LIBDIR]...\n\nComplete the installation of libtool libraries.\n\nEach LIBDIR is a directory that contains libtool libraries.\n\nThe commands that this mode executes may require superuser privileges.  Use\nthe \\`--dry-run' option if you just want to see what would be executed.\"\n        ;;\n\n      install)\n        $ECHO \\\n\"Usage: $progname [OPTION]... --mode=install INSTALL-COMMAND...\n\nInstall executables or libraries.\n\nINSTALL-COMMAND is the installation command.  The first component should be\neither the \\`install' or \\`cp' program.\n\nThe following components of INSTALL-COMMAND are treated specially:\n\n  -inst-prefix-dir PREFIX-DIR  Use PREFIX-DIR as a staging area for installation\n\nThe rest of the components are interpreted as arguments to that command (only\nBSD-compatible install options are recognized).\"\n        ;;\n\n      link)\n        $ECHO \\\n\"Usage: $progname [OPTION]... --mode=link LINK-COMMAND...\n\nLink object files or libraries together to form another library, or to\ncreate an executable program.\n\nLINK-COMMAND is a command using the C compiler that you would use to create\na program from several object files.\n\nThe following components of LINK-COMMAND are treated specially:\n\n  -all-static       do not do any dynamic linking at all\n  -avoid-version    do not add a version suffix if possible\n  -bindir BINDIR    specify path to binaries directory (for systems where\n                    libraries must be found in the PATH setting at runtime)\n  -dlopen FILE      \\`-dlpreopen' FILE if it cannot be dlopened at runtime\n  -dlpreopen FILE   link in FILE and add its symbols to lt_preloaded_symbols\n  -export-dynamic   allow symbols from OUTPUT-FILE to be resolved with dlsym(3)\n  -export-symbols SYMFILE\n                    try to export only the symbols listed in SYMFILE\n  -export-symbols-regex REGEX\n                    try to export only the symbols matching REGEX\n  -LLIBDIR          search LIBDIR for required installed libraries\n  -lNAME            OUTPUT-FILE requires the installed library libNAME\n  -module           build a library that can dlopened\n  -no-fast-install  disable the fast-install mode\n  -no-install       link a not-installable executable\n  -no-undefined     declare that a library does not refer to external symbols\n  -o OUTPUT-FILE    create OUTPUT-FILE from the specified objects\n  -objectlist FILE  Use a list of object files found in FILE to specify objects\n  -precious-files-regex REGEX\n                    don't remove output files matching REGEX\n  -release RELEASE  specify package release information\n  -rpath LIBDIR     the created library will eventually be installed in LIBDIR\n  -R[ ]LIBDIR       add LIBDIR to the runtime path of programs and libraries\n  -shared           only do dynamic linking of libtool libraries\n  -shrext SUFFIX    override the standard shared library file extension\n  -static           do not do any dynamic linking of uninstalled libtool libraries\n  -static-libtool-libs\n                    do not do any dynamic linking of libtool libraries\n  -version-info CURRENT[:REVISION[:AGE]]\n                    specify library version info [each variable defaults to 0]\n  -weak LIBNAME     declare that the target provides the LIBNAME interface\n  -Wc,FLAG\n  -Xcompiler FLAG   pass linker-specific FLAG directly to the compiler\n  -Wl,FLAG\n  -Xlinker FLAG     pass linker-specific FLAG directly to the linker\n  -XCClinker FLAG   pass link-specific FLAG to the compiler driver (CC)\n\nAll other options (arguments beginning with \\`-') are ignored.\n\nEvery other argument is treated as a filename.  Files ending in \\`.la' are\ntreated as uninstalled libtool libraries, other files are standard or library\nobject files.\n\nIf the OUTPUT-FILE ends in \\`.la', then a libtool library is created,\nonly library objects (\\`.lo' files) may be specified, and \\`-rpath' is\nrequired, except when creating a convenience library.\n\nIf OUTPUT-FILE ends in \\`.a' or \\`.lib', then a standard library is created\nusing \\`ar' and \\`ranlib', or on Windows using \\`lib'.\n\nIf OUTPUT-FILE ends in \\`.lo' or \\`.${objext}', then a reloadable object file\nis created, otherwise an executable program is created.\"\n        ;;\n\n      uninstall)\n        $ECHO \\\n\"Usage: $progname [OPTION]... --mode=uninstall RM [RM-OPTION]... FILE...\n\nRemove libraries from an installation directory.\n\nRM is the name of the program to use to delete files associated with each FILE\n(typically \\`/bin/rm').  RM-OPTIONS are options (such as \\`-f') to be passed\nto RM.\n\nIf FILE is a libtool library, all the files associated with it are deleted.\nOtherwise, only FILE itself is deleted using RM.\"\n        ;;\n\n      *)\n        func_fatal_help \"invalid operation mode \\`$opt_mode'\"\n        ;;\n    esac\n\n    echo\n    $ECHO \"Try \\`$progname --help' for more information about other modes.\"\n}\n\n# Now that we've collected a possible --mode arg, show help if necessary\nif $opt_help; then\n  if test \"$opt_help\" = :; then\n    func_mode_help\n  else\n    {\n      func_help noexit\n      for opt_mode in compile link execute install finish uninstall clean; do\n\tfunc_mode_help\n      done\n    } | sed -n '1p; 2,$s/^Usage:/  or: /p'\n    {\n      func_help noexit\n      for opt_mode in compile link execute install finish uninstall clean; do\n\techo\n\tfunc_mode_help\n      done\n    } |\n    sed '1d\n      /^When reporting/,/^Report/{\n\tH\n\td\n      }\n      $x\n      /information about other modes/d\n      /more detailed .*MODE/d\n      s/^Usage:.*--mode=\\([^ ]*\\) .*/Description of \\1 mode:/'\n  fi\n  exit $?\nfi\n\n\n# func_mode_execute arg...\nfunc_mode_execute ()\n{\n    $opt_debug\n    # The first argument is the command name.\n    cmd=\"$nonopt\"\n    test -z \"$cmd\" && \\\n      func_fatal_help \"you must specify a COMMAND\"\n\n    # Handle -dlopen flags immediately.\n    for file in $opt_dlopen; do\n      test -f \"$file\" \\\n\t|| func_fatal_help \"\\`$file' is not a file\"\n\n      dir=\n      case $file in\n      *.la)\n\tfunc_resolve_sysroot \"$file\"\n\tfile=$func_resolve_sysroot_result\n\n\t# Check to see that this really is a libtool archive.\n\tfunc_lalib_unsafe_p \"$file\" \\\n\t  || func_fatal_help \"\\`$lib' is not a valid libtool archive\"\n\n\t# Read the libtool library.\n\tdlname=\n\tlibrary_names=\n\tfunc_source \"$file\"\n\n\t# Skip this library if it cannot be dlopened.\n\tif test -z \"$dlname\"; then\n\t  # Warn if it was a shared library.\n\t  test -n \"$library_names\" && \\\n\t    func_warning \"\\`$file' was not linked with \\`-export-dynamic'\"\n\t  continue\n\tfi\n\n\tfunc_dirname \"$file\" \"\" \".\"\n\tdir=\"$func_dirname_result\"\n\n\tif test -f \"$dir/$objdir/$dlname\"; then\n\t  func_append dir \"/$objdir\"\n\telse\n\t  if test ! -f \"$dir/$dlname\"; then\n\t    func_fatal_error \"cannot find \\`$dlname' in \\`$dir' or \\`$dir/$objdir'\"\n\t  fi\n\tfi\n\t;;\n\n      *.lo)\n\t# Just add the directory containing the .lo file.\n\tfunc_dirname \"$file\" \"\" \".\"\n\tdir=\"$func_dirname_result\"\n\t;;\n\n      *)\n\tfunc_warning \"\\`-dlopen' is ignored for non-libtool libraries and objects\"\n\tcontinue\n\t;;\n      esac\n\n      # Get the absolute pathname.\n      absdir=`cd \"$dir\" && pwd`\n      test -n \"$absdir\" && dir=\"$absdir\"\n\n      # Now add the directory to shlibpath_var.\n      if eval \"test -z \\\"\\$$shlibpath_var\\\"\"; then\n\teval \"$shlibpath_var=\\\"\\$dir\\\"\"\n      else\n\teval \"$shlibpath_var=\\\"\\$dir:\\$$shlibpath_var\\\"\"\n      fi\n    done\n\n    # This variable tells wrapper scripts just to set shlibpath_var\n    # rather than running their programs.\n    libtool_execute_magic=\"$magic\"\n\n    # Check if any of the arguments is a wrapper script.\n    args=\n    for file\n    do\n      case $file in\n      -* | *.la | *.lo ) ;;\n      *)\n\t# Do a test to see if this is really a libtool program.\n\tif func_ltwrapper_script_p \"$file\"; then\n\t  func_source \"$file\"\n\t  # Transform arg to wrapped name.\n\t  file=\"$progdir/$program\"\n\telif func_ltwrapper_executable_p \"$file\"; then\n\t  func_ltwrapper_scriptname \"$file\"\n\t  func_source \"$func_ltwrapper_scriptname_result\"\n\t  # Transform arg to wrapped name.\n\t  file=\"$progdir/$program\"\n\tfi\n\t;;\n      esac\n      # Quote arguments (to preserve shell metacharacters).\n      func_append_quoted args \"$file\"\n    done\n\n    if test \"X$opt_dry_run\" = Xfalse; then\n      if test -n \"$shlibpath_var\"; then\n\t# Export the shlibpath_var.\n\teval \"export $shlibpath_var\"\n      fi\n\n      # Restore saved environment variables\n      for lt_var in LANG LANGUAGE LC_ALL LC_CTYPE LC_COLLATE LC_MESSAGES\n      do\n\teval \"if test \\\"\\${save_$lt_var+set}\\\" = set; then\n                $lt_var=\\$save_$lt_var; export $lt_var\n\t      else\n\t\t$lt_unset $lt_var\n\t      fi\"\n      done\n\n      # Now prepare to actually exec the command.\n      exec_cmd=\"\\$cmd$args\"\n    else\n      # Display what would be done.\n      if test -n \"$shlibpath_var\"; then\n\teval \"\\$ECHO \\\"\\$shlibpath_var=\\$$shlibpath_var\\\"\"\n\techo \"export $shlibpath_var\"\n      fi\n      $ECHO \"$cmd$args\"\n      exit $EXIT_SUCCESS\n    fi\n}\n\ntest \"$opt_mode\" = execute && func_mode_execute ${1+\"$@\"}\n\n\n# func_mode_finish arg...\nfunc_mode_finish ()\n{\n    $opt_debug\n    libs=\n    libdirs=\n    admincmds=\n\n    for opt in \"$nonopt\" ${1+\"$@\"}\n    do\n      if test -d \"$opt\"; then\n\tfunc_append libdirs \" $opt\"\n\n      elif test -f \"$opt\"; then\n\tif func_lalib_unsafe_p \"$opt\"; then\n\t  func_append libs \" $opt\"\n\telse\n\t  func_warning \"\\`$opt' is not a valid libtool archive\"\n\tfi\n\n      else\n\tfunc_fatal_error \"invalid argument \\`$opt'\"\n      fi\n    done\n\n    if test -n \"$libs\"; then\n      if test -n \"$lt_sysroot\"; then\n        sysroot_regex=`$ECHO \"$lt_sysroot\" | $SED \"$sed_make_literal_regex\"`\n        sysroot_cmd=\"s/\\([ ']\\)$sysroot_regex/\\1/g;\"\n      else\n        sysroot_cmd=\n      fi\n\n      # Remove sysroot references\n      if $opt_dry_run; then\n        for lib in $libs; do\n          echo \"removing references to $lt_sysroot and \\`=' prefixes from $lib\"\n        done\n      else\n        tmpdir=`func_mktempdir`\n        for lib in $libs; do\n\t  sed -e \"${sysroot_cmd} s/\\([ ']-[LR]\\)=/\\1/g; s/\\([ ']\\)=/\\1/g\" $lib \\\n\t    > $tmpdir/tmp-la\n\t  mv -f $tmpdir/tmp-la $lib\n\tdone\n        ${RM}r \"$tmpdir\"\n      fi\n    fi\n\n    if test -n \"$finish_cmds$finish_eval\" && test -n \"$libdirs\"; then\n      for libdir in $libdirs; do\n\tif test -n \"$finish_cmds\"; then\n\t  # Do each command in the finish commands.\n\t  func_execute_cmds \"$finish_cmds\" 'admincmds=\"$admincmds\n'\"$cmd\"'\"'\n\tfi\n\tif test -n \"$finish_eval\"; then\n\t  # Do the single finish_eval.\n\t  eval cmds=\\\"$finish_eval\\\"\n\t  $opt_dry_run || eval \"$cmds\" || func_append admincmds \"\n       $cmds\"\n\tfi\n      done\n    fi\n\n    # Exit here if they wanted silent mode.\n    $opt_silent && exit $EXIT_SUCCESS\n\n    if test -n \"$finish_cmds$finish_eval\" && test -n \"$libdirs\"; then\n      echo \"----------------------------------------------------------------------\"\n      echo \"Libraries have been installed in:\"\n      for libdir in $libdirs; do\n\t$ECHO \"   $libdir\"\n      done\n      echo\n      echo \"If you ever happen to want to link against installed libraries\"\n      echo \"in a given directory, LIBDIR, you must either use libtool, and\"\n      echo \"specify the full pathname of the library, or use the \\`-LLIBDIR'\"\n      echo \"flag during linking and do at least one of the following:\"\n      if test -n \"$shlibpath_var\"; then\n\techo \"   - add LIBDIR to the \\`$shlibpath_var' environment variable\"\n\techo \"     during execution\"\n      fi\n      if test -n \"$runpath_var\"; then\n\techo \"   - add LIBDIR to the \\`$runpath_var' environment variable\"\n\techo \"     during linking\"\n      fi\n      if test -n \"$hardcode_libdir_flag_spec\"; then\n\tlibdir=LIBDIR\n\teval flag=\\\"$hardcode_libdir_flag_spec\\\"\n\n\t$ECHO \"   - use the \\`$flag' linker flag\"\n      fi\n      if test -n \"$admincmds\"; then\n\t$ECHO \"   - have your system administrator run these commands:$admincmds\"\n      fi\n      if test -f /etc/ld.so.conf; then\n\techo \"   - have your system administrator add LIBDIR to \\`/etc/ld.so.conf'\"\n      fi\n      echo\n\n      echo \"See any operating system documentation about shared libraries for\"\n      case $host in\n\tsolaris2.[6789]|solaris2.1[0-9])\n\t  echo \"more information, such as the ld(1), crle(1) and ld.so(8) manual\"\n\t  echo \"pages.\"\n\t  ;;\n\t*)\n\t  echo \"more information, such as the ld(1) and ld.so(8) manual pages.\"\n\t  ;;\n      esac\n      echo \"----------------------------------------------------------------------\"\n    fi\n    exit $EXIT_SUCCESS\n}\n\ntest \"$opt_mode\" = finish && func_mode_finish ${1+\"$@\"}\n\n\n# func_mode_install arg...\nfunc_mode_install ()\n{\n    $opt_debug\n    # There may be an optional sh(1) argument at the beginning of\n    # install_prog (especially on Windows NT).\n    if test \"$nonopt\" = \"$SHELL\" || test \"$nonopt\" = /bin/sh ||\n       # Allow the use of GNU shtool's install command.\n       case $nonopt in *shtool*) :;; *) false;; esac; then\n      # Aesthetically quote it.\n      func_quote_for_eval \"$nonopt\"\n      install_prog=\"$func_quote_for_eval_result \"\n      arg=$1\n      shift\n    else\n      install_prog=\n      arg=$nonopt\n    fi\n\n    # The real first argument should be the name of the installation program.\n    # Aesthetically quote it.\n    func_quote_for_eval \"$arg\"\n    func_append install_prog \"$func_quote_for_eval_result\"\n    install_shared_prog=$install_prog\n    case \" $install_prog \" in\n      *[\\\\\\ /]cp\\ *) install_cp=: ;;\n      *) install_cp=false ;;\n    esac\n\n    # We need to accept at least all the BSD install flags.\n    dest=\n    files=\n    opts=\n    prev=\n    install_type=\n    isdir=no\n    stripme=\n    no_mode=:\n    for arg\n    do\n      arg2=\n      if test -n \"$dest\"; then\n\tfunc_append files \" $dest\"\n\tdest=$arg\n\tcontinue\n      fi\n\n      case $arg in\n      -d) isdir=yes ;;\n      -f)\n\tif $install_cp; then :; else\n\t  prev=$arg\n\tfi\n\t;;\n      -g | -m | -o)\n\tprev=$arg\n\t;;\n      -s)\n\tstripme=\" -s\"\n\tcontinue\n\t;;\n      -*)\n\t;;\n      *)\n\t# If the previous option needed an argument, then skip it.\n\tif test -n \"$prev\"; then\n\t  if test \"x$prev\" = x-m && test -n \"$install_override_mode\"; then\n\t    arg2=$install_override_mode\n\t    no_mode=false\n\t  fi\n\t  prev=\n\telse\n\t  dest=$arg\n\t  continue\n\tfi\n\t;;\n      esac\n\n      # Aesthetically quote the argument.\n      func_quote_for_eval \"$arg\"\n      func_append install_prog \" $func_quote_for_eval_result\"\n      if test -n \"$arg2\"; then\n\tfunc_quote_for_eval \"$arg2\"\n      fi\n      func_append install_shared_prog \" $func_quote_for_eval_result\"\n    done\n\n    test -z \"$install_prog\" && \\\n      func_fatal_help \"you must specify an install program\"\n\n    test -n \"$prev\" && \\\n      func_fatal_help \"the \\`$prev' option requires an argument\"\n\n    if test -n \"$install_override_mode\" && $no_mode; then\n      if $install_cp; then :; else\n\tfunc_quote_for_eval \"$install_override_mode\"\n\tfunc_append install_shared_prog \" -m $func_quote_for_eval_result\"\n      fi\n    fi\n\n    if test -z \"$files\"; then\n      if test -z \"$dest\"; then\n\tfunc_fatal_help \"no file or destination specified\"\n      else\n\tfunc_fatal_help \"you must specify a destination\"\n      fi\n    fi\n\n    # Strip any trailing slash from the destination.\n    func_stripname '' '/' \"$dest\"\n    dest=$func_stripname_result\n\n    # Check to see that the destination is a directory.\n    test -d \"$dest\" && isdir=yes\n    if test \"$isdir\" = yes; then\n      destdir=\"$dest\"\n      destname=\n    else\n      func_dirname_and_basename \"$dest\" \"\" \".\"\n      destdir=\"$func_dirname_result\"\n      destname=\"$func_basename_result\"\n\n      # Not a directory, so check to see that there is only one file specified.\n      set dummy $files; shift\n      test \"$#\" -gt 1 && \\\n\tfunc_fatal_help \"\\`$dest' is not a directory\"\n    fi\n    case $destdir in\n    [\\\\/]* | [A-Za-z]:[\\\\/]*) ;;\n    *)\n      for file in $files; do\n\tcase $file in\n\t*.lo) ;;\n\t*)\n\t  func_fatal_help \"\\`$destdir' must be an absolute directory name\"\n\t  ;;\n\tesac\n      done\n      ;;\n    esac\n\n    # This variable tells wrapper scripts just to set variables rather\n    # than running their programs.\n    libtool_install_magic=\"$magic\"\n\n    staticlibs=\n    future_libdirs=\n    current_libdirs=\n    for file in $files; do\n\n      # Do each installation.\n      case $file in\n      *.$libext)\n\t# Do the static libraries later.\n\tfunc_append staticlibs \" $file\"\n\t;;\n\n      *.la)\n\tfunc_resolve_sysroot \"$file\"\n\tfile=$func_resolve_sysroot_result\n\n\t# Check to see that this really is a libtool archive.\n\tfunc_lalib_unsafe_p \"$file\" \\\n\t  || func_fatal_help \"\\`$file' is not a valid libtool archive\"\n\n\tlibrary_names=\n\told_library=\n\trelink_command=\n\tfunc_source \"$file\"\n\n\t# Add the libdir to current_libdirs if it is the destination.\n\tif test \"X$destdir\" = \"X$libdir\"; then\n\t  case \"$current_libdirs \" in\n\t  *\" $libdir \"*) ;;\n\t  *) func_append current_libdirs \" $libdir\" ;;\n\t  esac\n\telse\n\t  # Note the libdir as a future libdir.\n\t  case \"$future_libdirs \" in\n\t  *\" $libdir \"*) ;;\n\t  *) func_append future_libdirs \" $libdir\" ;;\n\t  esac\n\tfi\n\n\tfunc_dirname \"$file\" \"/\" \"\"\n\tdir=\"$func_dirname_result\"\n\tfunc_append dir \"$objdir\"\n\n\tif test -n \"$relink_command\"; then\n\t  # Determine the prefix the user has applied to our future dir.\n\t  inst_prefix_dir=`$ECHO \"$destdir\" | $SED -e \"s%$libdir\\$%%\"`\n\n\t  # Don't allow the user to place us outside of our expected\n\t  # location b/c this prevents finding dependent libraries that\n\t  # are installed to the same prefix.\n\t  # At present, this check doesn't affect windows .dll's that\n\t  # are installed into $libdir/../bin (currently, that works fine)\n\t  # but it's something to keep an eye on.\n\t  test \"$inst_prefix_dir\" = \"$destdir\" && \\\n\t    func_fatal_error \"error: cannot install \\`$file' to a directory not ending in $libdir\"\n\n\t  if test -n \"$inst_prefix_dir\"; then\n\t    # Stick the inst_prefix_dir data into the link command.\n\t    relink_command=`$ECHO \"$relink_command\" | $SED \"s%@inst_prefix_dir@%-inst-prefix-dir $inst_prefix_dir%\"`\n\t  else\n\t    relink_command=`$ECHO \"$relink_command\" | $SED \"s%@inst_prefix_dir@%%\"`\n\t  fi\n\n\t  func_warning \"relinking \\`$file'\"\n\t  func_show_eval \"$relink_command\" \\\n\t    'func_fatal_error \"error: relink \\`$file'\\'' with the above command before installing it\"'\n\tfi\n\n\t# See the names of the shared library.\n\tset dummy $library_names; shift\n\tif test -n \"$1\"; then\n\t  realname=\"$1\"\n\t  shift\n\n\t  srcname=\"$realname\"\n\t  test -n \"$relink_command\" && srcname=\"$realname\"T\n\n\t  # Install the shared library and build the symlinks.\n\t  func_show_eval \"$install_shared_prog $dir/$srcname $destdir/$realname\" \\\n\t      'exit $?'\n\t  tstripme=\"$stripme\"\n\t  case $host_os in\n\t  cygwin* | mingw* | pw32* | cegcc*)\n\t    case $realname in\n\t    *.dll.a)\n\t      tstripme=\"\"\n\t      ;;\n\t    esac\n\t    ;;\n\t  esac\n\t  if test -n \"$tstripme\" && test -n \"$striplib\"; then\n\t    func_show_eval \"$striplib $destdir/$realname\" 'exit $?'\n\t  fi\n\n\t  if test \"$#\" -gt 0; then\n\t    # Delete the old symlinks, and create new ones.\n\t    # Try `ln -sf' first, because the `ln' binary might depend on\n\t    # the symlink we replace!  Solaris /bin/ln does not understand -f,\n\t    # so we also need to try rm && ln -s.\n\t    for linkname\n\t    do\n\t      test \"$linkname\" != \"$realname\" \\\n\t\t&& func_show_eval \"(cd $destdir && { $LN_S -f $realname $linkname || { $RM $linkname && $LN_S $realname $linkname; }; })\"\n\t    done\n\t  fi\n\n\t  # Do each command in the postinstall commands.\n\t  lib=\"$destdir/$realname\"\n\t  func_execute_cmds \"$postinstall_cmds\" 'exit $?'\n\tfi\n\n\t# Install the pseudo-library for information purposes.\n\tfunc_basename \"$file\"\n\tname=\"$func_basename_result\"\n\tinstname=\"$dir/$name\"i\n\tfunc_show_eval \"$install_prog $instname $destdir/$name\" 'exit $?'\n\n\t# Maybe install the static library, too.\n\ttest -n \"$old_library\" && func_append staticlibs \" $dir/$old_library\"\n\t;;\n\n      *.lo)\n\t# Install (i.e. copy) a libtool object.\n\n\t# Figure out destination file name, if it wasn't already specified.\n\tif test -n \"$destname\"; then\n\t  destfile=\"$destdir/$destname\"\n\telse\n\t  func_basename \"$file\"\n\t  destfile=\"$func_basename_result\"\n\t  destfile=\"$destdir/$destfile\"\n\tfi\n\n\t# Deduce the name of the destination old-style object file.\n\tcase $destfile in\n\t*.lo)\n\t  func_lo2o \"$destfile\"\n\t  staticdest=$func_lo2o_result\n\t  ;;\n\t*.$objext)\n\t  staticdest=\"$destfile\"\n\t  destfile=\n\t  ;;\n\t*)\n\t  func_fatal_help \"cannot copy a libtool object to \\`$destfile'\"\n\t  ;;\n\tesac\n\n\t# Install the libtool object if requested.\n\ttest -n \"$destfile\" && \\\n\t  func_show_eval \"$install_prog $file $destfile\" 'exit $?'\n\n\t# Install the old object if enabled.\n\tif test \"$build_old_libs\" = yes; then\n\t  # Deduce the name of the old-style object file.\n\t  func_lo2o \"$file\"\n\t  staticobj=$func_lo2o_result\n\t  func_show_eval \"$install_prog \\$staticobj \\$staticdest\" 'exit $?'\n\tfi\n\texit $EXIT_SUCCESS\n\t;;\n\n      *)\n\t# Figure out destination file name, if it wasn't already specified.\n\tif test -n \"$destname\"; then\n\t  destfile=\"$destdir/$destname\"\n\telse\n\t  func_basename \"$file\"\n\t  destfile=\"$func_basename_result\"\n\t  destfile=\"$destdir/$destfile\"\n\tfi\n\n\t# If the file is missing, and there is a .exe on the end, strip it\n\t# because it is most likely a libtool script we actually want to\n\t# install\n\tstripped_ext=\"\"\n\tcase $file in\n\t  *.exe)\n\t    if test ! -f \"$file\"; then\n\t      func_stripname '' '.exe' \"$file\"\n\t      file=$func_stripname_result\n\t      stripped_ext=\".exe\"\n\t    fi\n\t    ;;\n\tesac\n\n\t# Do a test to see if this is really a libtool program.\n\tcase $host in\n\t*cygwin* | *mingw*)\n\t    if func_ltwrapper_executable_p \"$file\"; then\n\t      func_ltwrapper_scriptname \"$file\"\n\t      wrapper=$func_ltwrapper_scriptname_result\n\t    else\n\t      func_stripname '' '.exe' \"$file\"\n\t      wrapper=$func_stripname_result\n\t    fi\n\t    ;;\n\t*)\n\t    wrapper=$file\n\t    ;;\n\tesac\n\tif func_ltwrapper_script_p \"$wrapper\"; then\n\t  notinst_deplibs=\n\t  relink_command=\n\n\t  func_source \"$wrapper\"\n\n\t  # Check the variables that should have been set.\n\t  test -z \"$generated_by_libtool_version\" && \\\n\t    func_fatal_error \"invalid libtool wrapper script \\`$wrapper'\"\n\n\t  finalize=yes\n\t  for lib in $notinst_deplibs; do\n\t    # Check to see that each library is installed.\n\t    libdir=\n\t    if test -f \"$lib\"; then\n\t      func_source \"$lib\"\n\t    fi\n\t    libfile=\"$libdir/\"`$ECHO \"$lib\" | $SED 's%^.*/%%g'` ### testsuite: skip nested quoting test\n\t    if test -n \"$libdir\" && test ! -f \"$libfile\"; then\n\t      func_warning \"\\`$lib' has not been installed in \\`$libdir'\"\n\t      finalize=no\n\t    fi\n\t  done\n\n\t  relink_command=\n\t  func_source \"$wrapper\"\n\n\t  outputname=\n\t  if test \"$fast_install\" = no && test -n \"$relink_command\"; then\n\t    $opt_dry_run || {\n\t      if test \"$finalize\" = yes; then\n\t        tmpdir=`func_mktempdir`\n\t\tfunc_basename \"$file$stripped_ext\"\n\t\tfile=\"$func_basename_result\"\n\t        outputname=\"$tmpdir/$file\"\n\t        # Replace the output file specification.\n\t        relink_command=`$ECHO \"$relink_command\" | $SED 's%@OUTPUT@%'\"$outputname\"'%g'`\n\n\t        $opt_silent || {\n\t          func_quote_for_expand \"$relink_command\"\n\t\t  eval \"func_echo $func_quote_for_expand_result\"\n\t        }\n\t        if eval \"$relink_command\"; then :\n\t          else\n\t\t  func_error \"error: relink \\`$file' with the above command before installing it\"\n\t\t  $opt_dry_run || ${RM}r \"$tmpdir\"\n\t\t  continue\n\t        fi\n\t        file=\"$outputname\"\n\t      else\n\t        func_warning \"cannot relink \\`$file'\"\n\t      fi\n\t    }\n\t  else\n\t    # Install the binary that we compiled earlier.\n\t    file=`$ECHO \"$file$stripped_ext\" | $SED \"s%\\([^/]*\\)$%$objdir/\\1%\"`\n\t  fi\n\tfi\n\n\t# remove .exe since cygwin /usr/bin/install will append another\n\t# one anyway\n\tcase $install_prog,$host in\n\t*/usr/bin/install*,*cygwin*)\n\t  case $file:$destfile in\n\t  *.exe:*.exe)\n\t    # this is ok\n\t    ;;\n\t  *.exe:*)\n\t    destfile=$destfile.exe\n\t    ;;\n\t  *:*.exe)\n\t    func_stripname '' '.exe' \"$destfile\"\n\t    destfile=$func_stripname_result\n\t    ;;\n\t  esac\n\t  ;;\n\tesac\n\tfunc_show_eval \"$install_prog\\$stripme \\$file \\$destfile\" 'exit $?'\n\t$opt_dry_run || if test -n \"$outputname\"; then\n\t  ${RM}r \"$tmpdir\"\n\tfi\n\t;;\n      esac\n    done\n\n    for file in $staticlibs; do\n      func_basename \"$file\"\n      name=\"$func_basename_result\"\n\n      # Set up the ranlib parameters.\n      oldlib=\"$destdir/$name\"\n      func_to_tool_file \"$oldlib\" func_convert_file_msys_to_w32\n      tool_oldlib=$func_to_tool_file_result\n\n      func_show_eval \"$install_prog \\$file \\$oldlib\" 'exit $?'\n\n      if test -n \"$stripme\" && test -n \"$old_striplib\"; then\n\tfunc_show_eval \"$old_striplib $tool_oldlib\" 'exit $?'\n      fi\n\n      # Do each command in the postinstall commands.\n      func_execute_cmds \"$old_postinstall_cmds\" 'exit $?'\n    done\n\n    test -n \"$future_libdirs\" && \\\n      func_warning \"remember to run \\`$progname --finish$future_libdirs'\"\n\n    if test -n \"$current_libdirs\"; then\n      # Maybe just do a dry run.\n      $opt_dry_run && current_libdirs=\" -n$current_libdirs\"\n      exec_cmd='$SHELL $progpath $preserve_args --finish$current_libdirs'\n    else\n      exit $EXIT_SUCCESS\n    fi\n}\n\ntest \"$opt_mode\" = install && func_mode_install ${1+\"$@\"}\n\n\n# func_generate_dlsyms outputname originator pic_p\n# Extract symbols from dlprefiles and create ${outputname}S.o with\n# a dlpreopen symbol table.\nfunc_generate_dlsyms ()\n{\n    $opt_debug\n    my_outputname=\"$1\"\n    my_originator=\"$2\"\n    my_pic_p=\"${3-no}\"\n    my_prefix=`$ECHO \"$my_originator\" | sed 's%[^a-zA-Z0-9]%_%g'`\n    my_dlsyms=\n\n    if test -n \"$dlfiles$dlprefiles\" || test \"$dlself\" != no; then\n      if test -n \"$NM\" && test -n \"$global_symbol_pipe\"; then\n\tmy_dlsyms=\"${my_outputname}S.c\"\n      else\n\tfunc_error \"not configured to extract global symbols from dlpreopened files\"\n      fi\n    fi\n\n    if test -n \"$my_dlsyms\"; then\n      case $my_dlsyms in\n      \"\") ;;\n      *.c)\n\t# Discover the nlist of each of the dlfiles.\n\tnlist=\"$output_objdir/${my_outputname}.nm\"\n\n\tfunc_show_eval \"$RM $nlist ${nlist}S ${nlist}T\"\n\n\t# Parse the name list into a source file.\n\tfunc_verbose \"creating $output_objdir/$my_dlsyms\"\n\n\t$opt_dry_run || $ECHO > \"$output_objdir/$my_dlsyms\" \"\\\n/* $my_dlsyms - symbol resolution table for \\`$my_outputname' dlsym emulation. */\n/* Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION */\n\n#ifdef __cplusplus\nextern \\\"C\\\" {\n#endif\n\n#if defined(__GNUC__) && (((__GNUC__ == 4) && (__GNUC_MINOR__ >= 4)) || (__GNUC__ > 4))\n#pragma GCC diagnostic ignored \\\"-Wstrict-prototypes\\\"\n#endif\n\n/* Keep this code in sync between libtool.m4, ltmain, lt_system.h, and tests.  */\n#if defined(_WIN32) || defined(__CYGWIN__) || defined(_WIN32_WCE)\n/* DATA imports from DLLs on WIN32 con't be const, because runtime\n   relocations are performed -- see ld's documentation on pseudo-relocs.  */\n# define LT_DLSYM_CONST\n#elif defined(__osf__)\n/* This system does not cope well with relocations in const data.  */\n# define LT_DLSYM_CONST\n#else\n# define LT_DLSYM_CONST const\n#endif\n\n/* External symbol declarations for the compiler. */\\\n\"\n\n\tif test \"$dlself\" = yes; then\n\t  func_verbose \"generating symbol list for \\`$output'\"\n\n\t  $opt_dry_run || echo ': @PROGRAM@ ' > \"$nlist\"\n\n\t  # Add our own program objects to the symbol list.\n\t  progfiles=`$ECHO \"$objs$old_deplibs\" | $SP2NL | $SED \"$lo2o\" | $NL2SP`\n\t  for progfile in $progfiles; do\n\t    func_to_tool_file \"$progfile\" func_convert_file_msys_to_w32\n\t    func_verbose \"extracting global C symbols from \\`$func_to_tool_file_result'\"\n\t    $opt_dry_run || eval \"$NM $func_to_tool_file_result | $global_symbol_pipe >> '$nlist'\"\n\t  done\n\n\t  if test -n \"$exclude_expsyms\"; then\n\t    $opt_dry_run || {\n\t      eval '$EGREP -v \" ($exclude_expsyms)$\" \"$nlist\" > \"$nlist\"T'\n\t      eval '$MV \"$nlist\"T \"$nlist\"'\n\t    }\n\t  fi\n\n\t  if test -n \"$export_symbols_regex\"; then\n\t    $opt_dry_run || {\n\t      eval '$EGREP -e \"$export_symbols_regex\" \"$nlist\" > \"$nlist\"T'\n\t      eval '$MV \"$nlist\"T \"$nlist\"'\n\t    }\n\t  fi\n\n\t  # Prepare the list of exported symbols\n\t  if test -z \"$export_symbols\"; then\n\t    export_symbols=\"$output_objdir/$outputname.exp\"\n\t    $opt_dry_run || {\n\t      $RM $export_symbols\n\t      eval \"${SED} -n -e '/^: @PROGRAM@ $/d' -e 's/^.* \\(.*\\)$/\\1/p' \"'< \"$nlist\" > \"$export_symbols\"'\n\t      case $host in\n\t      *cygwin* | *mingw* | *cegcc* )\n                eval \"echo EXPORTS \"'> \"$output_objdir/$outputname.def\"'\n                eval 'cat \"$export_symbols\" >> \"$output_objdir/$outputname.def\"'\n\t        ;;\n\t      esac\n\t    }\n\t  else\n\t    $opt_dry_run || {\n\t      eval \"${SED} -e 's/\\([].[*^$]\\)/\\\\\\\\\\1/g' -e 's/^/ /' -e 's/$/$/'\"' < \"$export_symbols\" > \"$output_objdir/$outputname.exp\"'\n\t      eval '$GREP -f \"$output_objdir/$outputname.exp\" < \"$nlist\" > \"$nlist\"T'\n\t      eval '$MV \"$nlist\"T \"$nlist\"'\n\t      case $host in\n\t        *cygwin* | *mingw* | *cegcc* )\n\t          eval \"echo EXPORTS \"'> \"$output_objdir/$outputname.def\"'\n\t          eval 'cat \"$nlist\" >> \"$output_objdir/$outputname.def\"'\n\t          ;;\n\t      esac\n\t    }\n\t  fi\n\tfi\n\n\tfor dlprefile in $dlprefiles; do\n\t  func_verbose \"extracting global C symbols from \\`$dlprefile'\"\n\t  func_basename \"$dlprefile\"\n\t  name=\"$func_basename_result\"\n          case $host in\n\t    *cygwin* | *mingw* | *cegcc* )\n\t      # if an import library, we need to obtain dlname\n\t      if func_win32_import_lib_p \"$dlprefile\"; then\n\t        func_tr_sh \"$dlprefile\"\n\t        eval \"curr_lafile=\\$libfile_$func_tr_sh_result\"\n\t        dlprefile_dlbasename=\"\"\n\t        if test -n \"$curr_lafile\" && func_lalib_p \"$curr_lafile\"; then\n\t          # Use subshell, to avoid clobbering current variable values\n\t          dlprefile_dlname=`source \"$curr_lafile\" && echo \"$dlname\"`\n\t          if test -n \"$dlprefile_dlname\" ; then\n\t            func_basename \"$dlprefile_dlname\"\n\t            dlprefile_dlbasename=\"$func_basename_result\"\n\t          else\n\t            # no lafile. user explicitly requested -dlpreopen <import library>.\n\t            $sharedlib_from_linklib_cmd \"$dlprefile\"\n\t            dlprefile_dlbasename=$sharedlib_from_linklib_result\n\t          fi\n\t        fi\n\t        $opt_dry_run || {\n\t          if test -n \"$dlprefile_dlbasename\" ; then\n\t            eval '$ECHO \": $dlprefile_dlbasename\" >> \"$nlist\"'\n\t          else\n\t            func_warning \"Could not compute DLL name from $name\"\n\t            eval '$ECHO \": $name \" >> \"$nlist\"'\n\t          fi\n\t          func_to_tool_file \"$dlprefile\" func_convert_file_msys_to_w32\n\t          eval \"$NM \\\"$func_to_tool_file_result\\\" 2>/dev/null | $global_symbol_pipe |\n\t            $SED -e '/I __imp/d' -e 's/I __nm_/D /;s/_nm__//' >> '$nlist'\"\n\t        }\n\t      else # not an import lib\n\t        $opt_dry_run || {\n\t          eval '$ECHO \": $name \" >> \"$nlist\"'\n\t          func_to_tool_file \"$dlprefile\" func_convert_file_msys_to_w32\n\t          eval \"$NM \\\"$func_to_tool_file_result\\\" 2>/dev/null | $global_symbol_pipe >> '$nlist'\"\n\t        }\n\t      fi\n\t    ;;\n\t    *)\n\t      $opt_dry_run || {\n\t        eval '$ECHO \": $name \" >> \"$nlist\"'\n\t        func_to_tool_file \"$dlprefile\" func_convert_file_msys_to_w32\n\t        eval \"$NM \\\"$func_to_tool_file_result\\\" 2>/dev/null | $global_symbol_pipe >> '$nlist'\"\n\t      }\n\t    ;;\n          esac\n\tdone\n\n\t$opt_dry_run || {\n\t  # Make sure we have at least an empty file.\n\t  test -f \"$nlist\" || : > \"$nlist\"\n\n\t  if test -n \"$exclude_expsyms\"; then\n\t    $EGREP -v \" ($exclude_expsyms)$\" \"$nlist\" > \"$nlist\"T\n\t    $MV \"$nlist\"T \"$nlist\"\n\t  fi\n\n\t  # Try sorting and uniquifying the output.\n\t  if $GREP -v \"^: \" < \"$nlist\" |\n\t      if sort -k 3 </dev/null >/dev/null 2>&1; then\n\t\tsort -k 3\n\t      else\n\t\tsort +2\n\t      fi |\n\t      uniq > \"$nlist\"S; then\n\t    :\n\t  else\n\t    $GREP -v \"^: \" < \"$nlist\" > \"$nlist\"S\n\t  fi\n\n\t  if test -f \"$nlist\"S; then\n\t    eval \"$global_symbol_to_cdecl\"' < \"$nlist\"S >> \"$output_objdir/$my_dlsyms\"'\n\t  else\n\t    echo '/* NONE */' >> \"$output_objdir/$my_dlsyms\"\n\t  fi\n\n\t  echo >> \"$output_objdir/$my_dlsyms\" \"\\\n\n/* The mapping between symbol names and symbols.  */\ntypedef struct {\n  const char *name;\n  void *address;\n} lt_dlsymlist;\nextern LT_DLSYM_CONST lt_dlsymlist\nlt_${my_prefix}_LTX_preloaded_symbols[];\nLT_DLSYM_CONST lt_dlsymlist\nlt_${my_prefix}_LTX_preloaded_symbols[] =\n{\\\n  { \\\"$my_originator\\\", (void *) 0 },\"\n\n\t  case $need_lib_prefix in\n\t  no)\n\t    eval \"$global_symbol_to_c_name_address\" < \"$nlist\" >> \"$output_objdir/$my_dlsyms\"\n\t    ;;\n\t  *)\n\t    eval \"$global_symbol_to_c_name_address_lib_prefix\" < \"$nlist\" >> \"$output_objdir/$my_dlsyms\"\n\t    ;;\n\t  esac\n\t  echo >> \"$output_objdir/$my_dlsyms\" \"\\\n  {0, (void *) 0}\n};\n\n/* This works around a problem in FreeBSD linker */\n#ifdef FREEBSD_WORKAROUND\nstatic const void *lt_preloaded_setup() {\n  return lt_${my_prefix}_LTX_preloaded_symbols;\n}\n#endif\n\n#ifdef __cplusplus\n}\n#endif\\\n\"\n\t} # !$opt_dry_run\n\n\tpic_flag_for_symtable=\n\tcase \"$compile_command \" in\n\t*\" -static \"*) ;;\n\t*)\n\t  case $host in\n\t  # compiling the symbol table file with pic_flag works around\n\t  # a FreeBSD bug that causes programs to crash when -lm is\n\t  # linked before any other PIC object.  But we must not use\n\t  # pic_flag when linking with -static.  The problem exists in\n\t  # FreeBSD 2.2.6 and is fixed in FreeBSD 3.1.\n\t  *-*-freebsd2.*|*-*-freebsd3.0*|*-*-freebsdelf3.0*)\n\t    pic_flag_for_symtable=\" $pic_flag -DFREEBSD_WORKAROUND\" ;;\n\t  *-*-hpux*)\n\t    pic_flag_for_symtable=\" $pic_flag\"  ;;\n\t  *)\n\t    if test \"X$my_pic_p\" != Xno; then\n\t      pic_flag_for_symtable=\" $pic_flag\"\n\t    fi\n\t    ;;\n\t  esac\n\t  ;;\n\tesac\n\tsymtab_cflags=\n\tfor arg in $LTCFLAGS; do\n\t  case $arg in\n\t  -pie | -fpie | -fPIE) ;;\n\t  *) func_append symtab_cflags \" $arg\" ;;\n\t  esac\n\tdone\n\n\t# Now compile the dynamic symbol file.\n\tfunc_show_eval '(cd $output_objdir && $LTCC$symtab_cflags -c$no_builtin_flag$pic_flag_for_symtable \"$my_dlsyms\")' 'exit $?'\n\n\t# Clean up the generated files.\n\tfunc_show_eval '$RM \"$output_objdir/$my_dlsyms\" \"$nlist\" \"${nlist}S\" \"${nlist}T\"'\n\n\t# Transform the symbol file into the correct name.\n\tsymfileobj=\"$output_objdir/${my_outputname}S.$objext\"\n\tcase $host in\n\t*cygwin* | *mingw* | *cegcc* )\n\t  if test -f \"$output_objdir/$my_outputname.def\"; then\n\t    compile_command=`$ECHO \"$compile_command\" | $SED \"s%@SYMFILE@%$output_objdir/$my_outputname.def $symfileobj%\"`\n\t    finalize_command=`$ECHO \"$finalize_command\" | $SED \"s%@SYMFILE@%$output_objdir/$my_outputname.def $symfileobj%\"`\n\t  else\n\t    compile_command=`$ECHO \"$compile_command\" | $SED \"s%@SYMFILE@%$symfileobj%\"`\n\t    finalize_command=`$ECHO \"$finalize_command\" | $SED \"s%@SYMFILE@%$symfileobj%\"`\n\t  fi\n\t  ;;\n\t*)\n\t  compile_command=`$ECHO \"$compile_command\" | $SED \"s%@SYMFILE@%$symfileobj%\"`\n\t  finalize_command=`$ECHO \"$finalize_command\" | $SED \"s%@SYMFILE@%$symfileobj%\"`\n\t  ;;\n\tesac\n\t;;\n      *)\n\tfunc_fatal_error \"unknown suffix for \\`$my_dlsyms'\"\n\t;;\n      esac\n    else\n      # We keep going just in case the user didn't refer to\n      # lt_preloaded_symbols.  The linker will fail if global_symbol_pipe\n      # really was required.\n\n      # Nullify the symbol file.\n      compile_command=`$ECHO \"$compile_command\" | $SED \"s% @SYMFILE@%%\"`\n      finalize_command=`$ECHO \"$finalize_command\" | $SED \"s% @SYMFILE@%%\"`\n    fi\n}\n\n# func_win32_libid arg\n# return the library type of file 'arg'\n#\n# Need a lot of goo to handle *both* DLLs and import libs\n# Has to be a shell function in order to 'eat' the argument\n# that is supplied when $file_magic_command is called.\n# Despite the name, also deal with 64 bit binaries.\nfunc_win32_libid ()\n{\n  $opt_debug\n  win32_libid_type=\"unknown\"\n  win32_fileres=`file -L $1 2>/dev/null`\n  case $win32_fileres in\n  *ar\\ archive\\ import\\ library*) # definitely import\n    win32_libid_type=\"x86 archive import\"\n    ;;\n  *ar\\ archive*) # could be an import, or static\n    # Keep the egrep pattern in sync with the one in _LT_CHECK_MAGIC_METHOD.\n    if eval $OBJDUMP -f $1 | $SED -e '10q' 2>/dev/null |\n       $EGREP 'file format (pei*-i386(.*architecture: i386)?|pe-arm-wince|pe-x86-64)' >/dev/null; then\n      func_to_tool_file \"$1\" func_convert_file_msys_to_w32\n      win32_nmres=`eval $NM -f posix -A \\\"$func_to_tool_file_result\\\" |\n\t$SED -n -e '\n\t    1,100{\n\t\t/ I /{\n\t\t    s,.*,import,\n\t\t    p\n\t\t    q\n\t\t}\n\t    }'`\n      case $win32_nmres in\n      import*)  win32_libid_type=\"x86 archive import\";;\n      *)        win32_libid_type=\"x86 archive static\";;\n      esac\n    fi\n    ;;\n  *DLL*)\n    win32_libid_type=\"x86 DLL\"\n    ;;\n  *executable*) # but shell scripts are \"executable\" too...\n    case $win32_fileres in\n    *MS\\ Windows\\ PE\\ Intel*)\n      win32_libid_type=\"x86 DLL\"\n      ;;\n    esac\n    ;;\n  esac\n  $ECHO \"$win32_libid_type\"\n}\n\n# func_cygming_dll_for_implib ARG\n#\n# Platform-specific function to extract the\n# name of the DLL associated with the specified\n# import library ARG.\n# Invoked by eval'ing the libtool variable\n#    $sharedlib_from_linklib_cmd\n# Result is available in the variable\n#    $sharedlib_from_linklib_result\nfunc_cygming_dll_for_implib ()\n{\n  $opt_debug\n  sharedlib_from_linklib_result=`$DLLTOOL --identify-strict --identify \"$1\"`\n}\n\n# func_cygming_dll_for_implib_fallback_core SECTION_NAME LIBNAMEs\n#\n# The is the core of a fallback implementation of a\n# platform-specific function to extract the name of the\n# DLL associated with the specified import library LIBNAME.\n#\n# SECTION_NAME is either .idata$6 or .idata$7, depending\n# on the platform and compiler that created the implib.\n#\n# Echos the name of the DLL associated with the\n# specified import library.\nfunc_cygming_dll_for_implib_fallback_core ()\n{\n  $opt_debug\n  match_literal=`$ECHO \"$1\" | $SED \"$sed_make_literal_regex\"`\n  $OBJDUMP -s --section \"$1\" \"$2\" 2>/dev/null |\n    $SED '/^Contents of section '\"$match_literal\"':/{\n      # Place marker at beginning of archive member dllname section\n      s/.*/====MARK====/\n      p\n      d\n    }\n    # These lines can sometimes be longer than 43 characters, but\n    # are always uninteresting\n    /:[\t ]*file format pe[i]\\{,1\\}-/d\n    /^In archive [^:]*:/d\n    # Ensure marker is printed\n    /^====MARK====/p\n    # Remove all lines with less than 43 characters\n    /^.\\{43\\}/!d\n    # From remaining lines, remove first 43 characters\n    s/^.\\{43\\}//' |\n    $SED -n '\n      # Join marker and all lines until next marker into a single line\n      /^====MARK====/ b para\n      H\n      $ b para\n      b\n      :para\n      x\n      s/\\n//g\n      # Remove the marker\n      s/^====MARK====//\n      # Remove trailing dots and whitespace\n      s/[\\. \\t]*$//\n      # Print\n      /./p' |\n    # we now have a list, one entry per line, of the stringified\n    # contents of the appropriate section of all members of the\n    # archive which possess that section. Heuristic: eliminate\n    # all those which have a first or second character that is\n    # a '.' (that is, objdump's representation of an unprintable\n    # character.) This should work for all archives with less than\n    # 0x302f exports -- but will fail for DLLs whose name actually\n    # begins with a literal '.' or a single character followed by\n    # a '.'.\n    #\n    # Of those that remain, print the first one.\n    $SED -e '/^\\./d;/^.\\./d;q'\n}\n\n# func_cygming_gnu_implib_p ARG\n# This predicate returns with zero status (TRUE) if\n# ARG is a GNU/binutils-style import library. Returns\n# with nonzero status (FALSE) otherwise.\nfunc_cygming_gnu_implib_p ()\n{\n  $opt_debug\n  func_to_tool_file \"$1\" func_convert_file_msys_to_w32\n  func_cygming_gnu_implib_tmp=`$NM \"$func_to_tool_file_result\" | eval \"$global_symbol_pipe\" | $EGREP ' (_head_[A-Za-z0-9_]+_[ad]l*|[A-Za-z0-9_]+_[ad]l*_iname)$'`\n  test -n \"$func_cygming_gnu_implib_tmp\"\n}\n\n# func_cygming_ms_implib_p ARG\n# This predicate returns with zero status (TRUE) if\n# ARG is an MS-style import library. Returns\n# with nonzero status (FALSE) otherwise.\nfunc_cygming_ms_implib_p ()\n{\n  $opt_debug\n  func_to_tool_file \"$1\" func_convert_file_msys_to_w32\n  func_cygming_ms_implib_tmp=`$NM \"$func_to_tool_file_result\" | eval \"$global_symbol_pipe\" | $GREP '_NULL_IMPORT_DESCRIPTOR'`\n  test -n \"$func_cygming_ms_implib_tmp\"\n}\n\n# func_cygming_dll_for_implib_fallback ARG\n# Platform-specific function to extract the\n# name of the DLL associated with the specified\n# import library ARG.\n#\n# This fallback implementation is for use when $DLLTOOL\n# does not support the --identify-strict option.\n# Invoked by eval'ing the libtool variable\n#    $sharedlib_from_linklib_cmd\n# Result is available in the variable\n#    $sharedlib_from_linklib_result\nfunc_cygming_dll_for_implib_fallback ()\n{\n  $opt_debug\n  if func_cygming_gnu_implib_p \"$1\" ; then\n    # binutils import library\n    sharedlib_from_linklib_result=`func_cygming_dll_for_implib_fallback_core '.idata$7' \"$1\"`\n  elif func_cygming_ms_implib_p \"$1\" ; then\n    # ms-generated import library\n    sharedlib_from_linklib_result=`func_cygming_dll_for_implib_fallback_core '.idata$6' \"$1\"`\n  else\n    # unknown\n    sharedlib_from_linklib_result=\"\"\n  fi\n}\n\n\n# func_extract_an_archive dir oldlib\nfunc_extract_an_archive ()\n{\n    $opt_debug\n    f_ex_an_ar_dir=\"$1\"; shift\n    f_ex_an_ar_oldlib=\"$1\"\n    if test \"$lock_old_archive_extraction\" = yes; then\n      lockfile=$f_ex_an_ar_oldlib.lock\n      until $opt_dry_run || ln \"$progpath\" \"$lockfile\" 2>/dev/null; do\n\tfunc_echo \"Waiting for $lockfile to be removed\"\n\tsleep 2\n      done\n    fi\n    func_show_eval \"(cd \\$f_ex_an_ar_dir && $AR x \\\"\\$f_ex_an_ar_oldlib\\\")\" \\\n\t\t   'stat=$?; rm -f \"$lockfile\"; exit $stat'\n    if test \"$lock_old_archive_extraction\" = yes; then\n      $opt_dry_run || rm -f \"$lockfile\"\n    fi\n    if ($AR t \"$f_ex_an_ar_oldlib\" | sort | sort -uc >/dev/null 2>&1); then\n     :\n    else\n      func_fatal_error \"object name conflicts in archive: $f_ex_an_ar_dir/$f_ex_an_ar_oldlib\"\n    fi\n}\n\n\n# func_extract_archives gentop oldlib ...\nfunc_extract_archives ()\n{\n    $opt_debug\n    my_gentop=\"$1\"; shift\n    my_oldlibs=${1+\"$@\"}\n    my_oldobjs=\"\"\n    my_xlib=\"\"\n    my_xabs=\"\"\n    my_xdir=\"\"\n\n    for my_xlib in $my_oldlibs; do\n      # Extract the objects.\n      case $my_xlib in\n\t[\\\\/]* | [A-Za-z]:[\\\\/]*) my_xabs=\"$my_xlib\" ;;\n\t*) my_xabs=`pwd`\"/$my_xlib\" ;;\n      esac\n      func_basename \"$my_xlib\"\n      my_xlib=\"$func_basename_result\"\n      my_xlib_u=$my_xlib\n      while :; do\n        case \" $extracted_archives \" in\n\t*\" $my_xlib_u \"*)\n\t  func_arith $extracted_serial + 1\n\t  extracted_serial=$func_arith_result\n\t  my_xlib_u=lt$extracted_serial-$my_xlib ;;\n\t*) break ;;\n\tesac\n      done\n      extracted_archives=\"$extracted_archives $my_xlib_u\"\n      my_xdir=\"$my_gentop/$my_xlib_u\"\n\n      func_mkdir_p \"$my_xdir\"\n\n      case $host in\n      *-darwin*)\n\tfunc_verbose \"Extracting $my_xabs\"\n\t# Do not bother doing anything if just a dry run\n\t$opt_dry_run || {\n\t  darwin_orig_dir=`pwd`\n\t  cd $my_xdir || exit $?\n\t  darwin_archive=$my_xabs\n\t  darwin_curdir=`pwd`\n\t  darwin_base_archive=`basename \"$darwin_archive\"`\n\t  darwin_arches=`$LIPO -info \"$darwin_archive\" 2>/dev/null | $GREP Architectures 2>/dev/null || true`\n\t  if test -n \"$darwin_arches\"; then\n\t    darwin_arches=`$ECHO \"$darwin_arches\" | $SED -e 's/.*are://'`\n\t    darwin_arch=\n\t    func_verbose \"$darwin_base_archive has multiple architectures $darwin_arches\"\n\t    for darwin_arch in  $darwin_arches ; do\n\t      func_mkdir_p \"unfat-$$/${darwin_base_archive}-${darwin_arch}\"\n\t      $LIPO -thin $darwin_arch -output \"unfat-$$/${darwin_base_archive}-${darwin_arch}/${darwin_base_archive}\" \"${darwin_archive}\"\n\t      cd \"unfat-$$/${darwin_base_archive}-${darwin_arch}\"\n\t      func_extract_an_archive \"`pwd`\" \"${darwin_base_archive}\"\n\t      cd \"$darwin_curdir\"\n\t      $RM \"unfat-$$/${darwin_base_archive}-${darwin_arch}/${darwin_base_archive}\"\n\t    done # $darwin_arches\n            ## Okay now we've a bunch of thin objects, gotta fatten them up :)\n\t    darwin_filelist=`find unfat-$$ -type f -name \\*.o -print -o -name \\*.lo -print | $SED -e \"$basename\" | sort -u`\n\t    darwin_file=\n\t    darwin_files=\n\t    for darwin_file in $darwin_filelist; do\n\t      darwin_files=`find unfat-$$ -name $darwin_file -print | sort | $NL2SP`\n\t      $LIPO -create -output \"$darwin_file\" $darwin_files\n\t    done # $darwin_filelist\n\t    $RM -rf unfat-$$\n\t    cd \"$darwin_orig_dir\"\n\t  else\n\t    cd $darwin_orig_dir\n\t    func_extract_an_archive \"$my_xdir\" \"$my_xabs\"\n\t  fi # $darwin_arches\n\t} # !$opt_dry_run\n\t;;\n      *)\n        func_extract_an_archive \"$my_xdir\" \"$my_xabs\"\n\t;;\n      esac\n      my_oldobjs=\"$my_oldobjs \"`find $my_xdir -name \\*.$objext -print -o -name \\*.lo -print | sort | $NL2SP`\n    done\n\n    func_extract_archives_result=\"$my_oldobjs\"\n}\n\n\n# func_emit_wrapper [arg=no]\n#\n# Emit a libtool wrapper script on stdout.\n# Don't directly open a file because we may want to\n# incorporate the script contents within a cygwin/mingw\n# wrapper executable.  Must ONLY be called from within\n# func_mode_link because it depends on a number of variables\n# set therein.\n#\n# ARG is the value that the WRAPPER_SCRIPT_BELONGS_IN_OBJDIR\n# variable will take.  If 'yes', then the emitted script\n# will assume that the directory in which it is stored is\n# the $objdir directory.  This is a cygwin/mingw-specific\n# behavior.\nfunc_emit_wrapper ()\n{\n\tfunc_emit_wrapper_arg1=${1-no}\n\n\t$ECHO \"\\\n#! $SHELL\n\n# $output - temporary wrapper script for $objdir/$outputname\n# Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION\n#\n# The $output program cannot be directly executed until all the libtool\n# libraries that it depends on are installed.\n#\n# This wrapper script should never be moved out of the build directory.\n# If it is, it will not operate correctly.\n\n# Sed substitution that helps us do robust quoting.  It backslashifies\n# metacharacters that are still active within double-quoted strings.\nsed_quote_subst='$sed_quote_subst'\n\n# Be Bourne compatible\nif test -n \\\"\\${ZSH_VERSION+set}\\\" && (emulate sh) >/dev/null 2>&1; then\n  emulate sh\n  NULLCMD=:\n  # Zsh 3.x and 4.x performs word splitting on \\${1+\\\"\\$@\\\"}, which\n  # is contrary to our usage.  Disable this feature.\n  alias -g '\\${1+\\\"\\$@\\\"}'='\\\"\\$@\\\"'\n  setopt NO_GLOB_SUBST\nelse\n  case \\`(set -o) 2>/dev/null\\` in *posix*) set -o posix;; esac\nfi\nBIN_SH=xpg4; export BIN_SH # for Tru64\nDUALCASE=1; export DUALCASE # for MKS sh\n\n# The HP-UX ksh and POSIX shell print the target directory to stdout\n# if CDPATH is set.\n(unset CDPATH) >/dev/null 2>&1 && unset CDPATH\n\nrelink_command=\\\"$relink_command\\\"\n\n# This environment variable determines our operation mode.\nif test \\\"\\$libtool_install_magic\\\" = \\\"$magic\\\"; then\n  # install mode needs the following variables:\n  generated_by_libtool_version='$macro_version'\n  notinst_deplibs='$notinst_deplibs'\nelse\n  # When we are sourced in execute mode, \\$file and \\$ECHO are already set.\n  if test \\\"\\$libtool_execute_magic\\\" != \\\"$magic\\\"; then\n    file=\\\"\\$0\\\"\"\n\n    qECHO=`$ECHO \"$ECHO\" | $SED \"$sed_quote_subst\"`\n    $ECHO \"\\\n\n# A function that is used when there is no print builtin or printf.\nfunc_fallback_echo ()\n{\n  eval 'cat <<_LTECHO_EOF\n\\$1\n_LTECHO_EOF'\n}\n    ECHO=\\\"$qECHO\\\"\n  fi\n\n# Very basic option parsing. These options are (a) specific to\n# the libtool wrapper, (b) are identical between the wrapper\n# /script/ and the wrapper /executable/ which is used only on\n# windows platforms, and (c) all begin with the string \"--lt-\"\n# (application programs are unlikely to have options which match\n# this pattern).\n#\n# There are only two supported options: --lt-debug and\n# --lt-dump-script. There is, deliberately, no --lt-help.\n#\n# The first argument to this parsing function should be the\n# script's $0 value, followed by \"$@\".\nlt_option_debug=\nfunc_parse_lt_options ()\n{\n  lt_script_arg0=\\$0\n  shift\n  for lt_opt\n  do\n    case \\\"\\$lt_opt\\\" in\n    --lt-debug) lt_option_debug=1 ;;\n    --lt-dump-script)\n        lt_dump_D=\\`\\$ECHO \\\"X\\$lt_script_arg0\\\" | $SED -e 's/^X//' -e 's%/[^/]*$%%'\\`\n        test \\\"X\\$lt_dump_D\\\" = \\\"X\\$lt_script_arg0\\\" && lt_dump_D=.\n        lt_dump_F=\\`\\$ECHO \\\"X\\$lt_script_arg0\\\" | $SED -e 's/^X//' -e 's%^.*/%%'\\`\n        cat \\\"\\$lt_dump_D/\\$lt_dump_F\\\"\n        exit 0\n      ;;\n    --lt-*)\n        \\$ECHO \\\"Unrecognized --lt- option: '\\$lt_opt'\\\" 1>&2\n        exit 1\n      ;;\n    esac\n  done\n\n  # Print the debug banner immediately:\n  if test -n \\\"\\$lt_option_debug\\\"; then\n    echo \\\"${outputname}:${output}:\\${LINENO}: libtool wrapper (GNU $PACKAGE$TIMESTAMP) $VERSION\\\" 1>&2\n  fi\n}\n\n# Used when --lt-debug. Prints its arguments to stdout\n# (redirection is the responsibility of the caller)\nfunc_lt_dump_args ()\n{\n  lt_dump_args_N=1;\n  for lt_arg\n  do\n    \\$ECHO \\\"${outputname}:${output}:\\${LINENO}: newargv[\\$lt_dump_args_N]: \\$lt_arg\\\"\n    lt_dump_args_N=\\`expr \\$lt_dump_args_N + 1\\`\n  done\n}\n\n# Core function for launching the target application\nfunc_exec_program_core ()\n{\n\"\n  case $host in\n  # Backslashes separate directories on plain windows\n  *-*-mingw | *-*-os2* | *-cegcc*)\n    $ECHO \"\\\n      if test -n \\\"\\$lt_option_debug\\\"; then\n        \\$ECHO \\\"${outputname}:${output}:\\${LINENO}: newargv[0]: \\$progdir\\\\\\\\\\$program\\\" 1>&2\n        func_lt_dump_args \\${1+\\\"\\$@\\\"} 1>&2\n      fi\n      exec \\\"\\$progdir\\\\\\\\\\$program\\\" \\${1+\\\"\\$@\\\"}\n\"\n    ;;\n\n  *)\n    $ECHO \"\\\n      if test -n \\\"\\$lt_option_debug\\\"; then\n        \\$ECHO \\\"${outputname}:${output}:\\${LINENO}: newargv[0]: \\$progdir/\\$program\\\" 1>&2\n        func_lt_dump_args \\${1+\\\"\\$@\\\"} 1>&2\n      fi\n      exec \\\"\\$progdir/\\$program\\\" \\${1+\\\"\\$@\\\"}\n\"\n    ;;\n  esac\n  $ECHO \"\\\n      \\$ECHO \\\"\\$0: cannot exec \\$program \\$*\\\" 1>&2\n      exit 1\n}\n\n# A function to encapsulate launching the target application\n# Strips options in the --lt-* namespace from \\$@ and\n# launches target application with the remaining arguments.\nfunc_exec_program ()\n{\n  case \\\" \\$* \\\" in\n  *\\\\ --lt-*)\n    for lt_wr_arg\n    do\n      case \\$lt_wr_arg in\n      --lt-*) ;;\n      *) set x \\\"\\$@\\\" \\\"\\$lt_wr_arg\\\"; shift;;\n      esac\n      shift\n    done ;;\n  esac\n  func_exec_program_core \\${1+\\\"\\$@\\\"}\n}\n\n  # Parse options\n  func_parse_lt_options \\\"\\$0\\\" \\${1+\\\"\\$@\\\"}\n\n  # Find the directory that this script lives in.\n  thisdir=\\`\\$ECHO \\\"\\$file\\\" | $SED 's%/[^/]*$%%'\\`\n  test \\\"x\\$thisdir\\\" = \\\"x\\$file\\\" && thisdir=.\n\n  # Follow symbolic links until we get to the real thisdir.\n  file=\\`ls -ld \\\"\\$file\\\" | $SED -n 's/.*-> //p'\\`\n  while test -n \\\"\\$file\\\"; do\n    destdir=\\`\\$ECHO \\\"\\$file\\\" | $SED 's%/[^/]*\\$%%'\\`\n\n    # If there was a directory component, then change thisdir.\n    if test \\\"x\\$destdir\\\" != \\\"x\\$file\\\"; then\n      case \\\"\\$destdir\\\" in\n      [\\\\\\\\/]* | [A-Za-z]:[\\\\\\\\/]*) thisdir=\\\"\\$destdir\\\" ;;\n      *) thisdir=\\\"\\$thisdir/\\$destdir\\\" ;;\n      esac\n    fi\n\n    file=\\`\\$ECHO \\\"\\$file\\\" | $SED 's%^.*/%%'\\`\n    file=\\`ls -ld \\\"\\$thisdir/\\$file\\\" | $SED -n 's/.*-> //p'\\`\n  done\n\n  # Usually 'no', except on cygwin/mingw when embedded into\n  # the cwrapper.\n  WRAPPER_SCRIPT_BELONGS_IN_OBJDIR=$func_emit_wrapper_arg1\n  if test \\\"\\$WRAPPER_SCRIPT_BELONGS_IN_OBJDIR\\\" = \\\"yes\\\"; then\n    # special case for '.'\n    if test \\\"\\$thisdir\\\" = \\\".\\\"; then\n      thisdir=\\`pwd\\`\n    fi\n    # remove .libs from thisdir\n    case \\\"\\$thisdir\\\" in\n    *[\\\\\\\\/]$objdir ) thisdir=\\`\\$ECHO \\\"\\$thisdir\\\" | $SED 's%[\\\\\\\\/][^\\\\\\\\/]*$%%'\\` ;;\n    $objdir )   thisdir=. ;;\n    esac\n  fi\n\n  # Try to get the absolute directory name.\n  absdir=\\`cd \\\"\\$thisdir\\\" && pwd\\`\n  test -n \\\"\\$absdir\\\" && thisdir=\\\"\\$absdir\\\"\n\"\n\n\tif test \"$fast_install\" = yes; then\n\t  $ECHO \"\\\n  program=lt-'$outputname'$exeext\n  progdir=\\\"\\$thisdir/$objdir\\\"\n\n  if test ! -f \\\"\\$progdir/\\$program\\\" ||\n     { file=\\`ls -1dt \\\"\\$progdir/\\$program\\\" \\\"\\$progdir/../\\$program\\\" 2>/dev/null | ${SED} 1q\\`; \\\\\n       test \\\"X\\$file\\\" != \\\"X\\$progdir/\\$program\\\"; }; then\n\n    file=\\\"\\$\\$-\\$program\\\"\n\n    if test ! -d \\\"\\$progdir\\\"; then\n      $MKDIR \\\"\\$progdir\\\"\n    else\n      $RM \\\"\\$progdir/\\$file\\\"\n    fi\"\n\n\t  $ECHO \"\\\n\n    # relink executable if necessary\n    if test -n \\\"\\$relink_command\\\"; then\n      if relink_command_output=\\`eval \\$relink_command 2>&1\\`; then :\n      else\n\t$ECHO \\\"\\$relink_command_output\\\" >&2\n\t$RM \\\"\\$progdir/\\$file\\\"\n\texit 1\n      fi\n    fi\n\n    $MV \\\"\\$progdir/\\$file\\\" \\\"\\$progdir/\\$program\\\" 2>/dev/null ||\n    { $RM \\\"\\$progdir/\\$program\\\";\n      $MV \\\"\\$progdir/\\$file\\\" \\\"\\$progdir/\\$program\\\"; }\n    $RM \\\"\\$progdir/\\$file\\\"\n  fi\"\n\telse\n\t  $ECHO \"\\\n  program='$outputname'\n  progdir=\\\"\\$thisdir/$objdir\\\"\n\"\n\tfi\n\n\t$ECHO \"\\\n\n  if test -f \\\"\\$progdir/\\$program\\\"; then\"\n\n\t# fixup the dll searchpath if we need to.\n\t#\n\t# Fix the DLL searchpath if we need to.  Do this before prepending\n\t# to shlibpath, because on Windows, both are PATH and uninstalled\n\t# libraries must come first.\n\tif test -n \"$dllsearchpath\"; then\n\t  $ECHO \"\\\n    # Add the dll search path components to the executable PATH\n    PATH=$dllsearchpath:\\$PATH\n\"\n\tfi\n\n\t# Export our shlibpath_var if we have one.\n\tif test \"$shlibpath_overrides_runpath\" = yes && test -n \"$shlibpath_var\" && test -n \"$temp_rpath\"; then\n\t  $ECHO \"\\\n    # Add our own library path to $shlibpath_var\n    $shlibpath_var=\\\"$temp_rpath\\$$shlibpath_var\\\"\n\n    # Some systems cannot cope with colon-terminated $shlibpath_var\n    # The second colon is a workaround for a bug in BeOS R4 sed\n    $shlibpath_var=\\`\\$ECHO \\\"\\$$shlibpath_var\\\" | $SED 's/::*\\$//'\\`\n\n    export $shlibpath_var\n\"\n\tfi\n\n\t$ECHO \"\\\n    if test \\\"\\$libtool_execute_magic\\\" != \\\"$magic\\\"; then\n      # Run the actual program with our arguments.\n      func_exec_program \\${1+\\\"\\$@\\\"}\n    fi\n  else\n    # The program doesn't exist.\n    \\$ECHO \\\"\\$0: error: \\\\\\`\\$progdir/\\$program' does not exist\\\" 1>&2\n    \\$ECHO \\\"This script is just a wrapper for \\$program.\\\" 1>&2\n    \\$ECHO \\\"See the $PACKAGE documentation for more information.\\\" 1>&2\n    exit 1\n  fi\nfi\\\n\"\n}\n\n\n# func_emit_cwrapperexe_src\n# emit the source code for a wrapper executable on stdout\n# Must ONLY be called from within func_mode_link because\n# it depends on a number of variable set therein.\nfunc_emit_cwrapperexe_src ()\n{\n\tcat <<EOF\n\n/* $cwrappersource - temporary wrapper executable for $objdir/$outputname\n   Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION\n\n   The $output program cannot be directly executed until all the libtool\n   libraries that it depends on are installed.\n\n   This wrapper executable should never be moved out of the build directory.\n   If it is, it will not operate correctly.\n*/\nEOF\n\t    cat <<\"EOF\"\n#ifdef _MSC_VER\n# define _CRT_SECURE_NO_DEPRECATE 1\n#endif\n#include <stdio.h>\n#include <stdlib.h>\n#ifdef _MSC_VER\n# include <direct.h>\n# include <process.h>\n# include <io.h>\n#else\n# include <unistd.h>\n# include <stdint.h>\n# ifdef __CYGWIN__\n#  include <io.h>\n# endif\n#endif\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include <string.h>\n#include <ctype.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n\n/* declarations of non-ANSI functions */\n#if defined(__MINGW32__)\n# ifdef __STRICT_ANSI__\nint _putenv (const char *);\n# endif\n#elif defined(__CYGWIN__)\n# ifdef __STRICT_ANSI__\nchar *realpath (const char *, char *);\nint putenv (char *);\nint setenv (const char *, const char *, int);\n# endif\n/* #elif defined (other platforms) ... */\n#endif\n\n/* portability defines, excluding path handling macros */\n#if defined(_MSC_VER)\n# define setmode _setmode\n# define stat    _stat\n# define chmod   _chmod\n# define getcwd  _getcwd\n# define putenv  _putenv\n# define S_IXUSR _S_IEXEC\n# ifndef _INTPTR_T_DEFINED\n#  define _INTPTR_T_DEFINED\n#  define intptr_t int\n# endif\n#elif defined(__MINGW32__)\n# define setmode _setmode\n# define stat    _stat\n# define chmod   _chmod\n# define getcwd  _getcwd\n# define putenv  _putenv\n#elif defined(__CYGWIN__)\n# define HAVE_SETENV\n# define FOPEN_WB \"wb\"\n/* #elif defined (other platforms) ... */\n#endif\n\n#if defined(PATH_MAX)\n# define LT_PATHMAX PATH_MAX\n#elif defined(MAXPATHLEN)\n# define LT_PATHMAX MAXPATHLEN\n#else\n# define LT_PATHMAX 1024\n#endif\n\n#ifndef S_IXOTH\n# define S_IXOTH 0\n#endif\n#ifndef S_IXGRP\n# define S_IXGRP 0\n#endif\n\n/* path handling portability macros */\n#ifndef DIR_SEPARATOR\n# define DIR_SEPARATOR '/'\n# define PATH_SEPARATOR ':'\n#endif\n\n#if defined (_WIN32) || defined (__MSDOS__) || defined (__DJGPP__) || \\\n  defined (__OS2__)\n# define HAVE_DOS_BASED_FILE_SYSTEM\n# define FOPEN_WB \"wb\"\n# ifndef DIR_SEPARATOR_2\n#  define DIR_SEPARATOR_2 '\\\\'\n# endif\n# ifndef PATH_SEPARATOR_2\n#  define PATH_SEPARATOR_2 ';'\n# endif\n#endif\n\n#ifndef DIR_SEPARATOR_2\n# define IS_DIR_SEPARATOR(ch) ((ch) == DIR_SEPARATOR)\n#else /* DIR_SEPARATOR_2 */\n# define IS_DIR_SEPARATOR(ch) \\\n\t(((ch) == DIR_SEPARATOR) || ((ch) == DIR_SEPARATOR_2))\n#endif /* DIR_SEPARATOR_2 */\n\n#ifndef PATH_SEPARATOR_2\n# define IS_PATH_SEPARATOR(ch) ((ch) == PATH_SEPARATOR)\n#else /* PATH_SEPARATOR_2 */\n# define IS_PATH_SEPARATOR(ch) ((ch) == PATH_SEPARATOR_2)\n#endif /* PATH_SEPARATOR_2 */\n\n#ifndef FOPEN_WB\n# define FOPEN_WB \"w\"\n#endif\n#ifndef _O_BINARY\n# define _O_BINARY 0\n#endif\n\n#define XMALLOC(type, num)      ((type *) xmalloc ((num) * sizeof(type)))\n#define XFREE(stale) do { \\\n  if (stale) { free ((void *) stale); stale = 0; } \\\n} while (0)\n\n#if defined(LT_DEBUGWRAPPER)\nstatic int lt_debug = 1;\n#else\nstatic int lt_debug = 0;\n#endif\n\nconst char *program_name = \"libtool-wrapper\"; /* in case xstrdup fails */\n\nvoid *xmalloc (size_t num);\nchar *xstrdup (const char *string);\nconst char *base_name (const char *name);\nchar *find_executable (const char *wrapper);\nchar *chase_symlinks (const char *pathspec);\nint make_executable (const char *path);\nint check_executable (const char *path);\nchar *strendzap (char *str, const char *pat);\nvoid lt_debugprintf (const char *file, int line, const char *fmt, ...);\nvoid lt_fatal (const char *file, int line, const char *message, ...);\nstatic const char *nonnull (const char *s);\nstatic const char *nonempty (const char *s);\nvoid lt_setenv (const char *name, const char *value);\nchar *lt_extend_str (const char *orig_value, const char *add, int to_end);\nvoid lt_update_exe_path (const char *name, const char *value);\nvoid lt_update_lib_path (const char *name, const char *value);\nchar **prepare_spawn (char **argv);\nvoid lt_dump_script (FILE *f);\nEOF\n\n\t    cat <<EOF\nvolatile const char * MAGIC_EXE = \"$magic_exe\";\nconst char * LIB_PATH_VARNAME = \"$shlibpath_var\";\nEOF\n\n\t    if test \"$shlibpath_overrides_runpath\" = yes && test -n \"$shlibpath_var\" && test -n \"$temp_rpath\"; then\n              func_to_host_path \"$temp_rpath\"\n\t      cat <<EOF\nconst char * LIB_PATH_VALUE   = \"$func_to_host_path_result\";\nEOF\n\t    else\n\t      cat <<\"EOF\"\nconst char * LIB_PATH_VALUE   = \"\";\nEOF\n\t    fi\n\n\t    if test -n \"$dllsearchpath\"; then\n              func_to_host_path \"$dllsearchpath:\"\n\t      cat <<EOF\nconst char * EXE_PATH_VARNAME = \"PATH\";\nconst char * EXE_PATH_VALUE   = \"$func_to_host_path_result\";\nEOF\n\t    else\n\t      cat <<\"EOF\"\nconst char * EXE_PATH_VARNAME = \"\";\nconst char * EXE_PATH_VALUE   = \"\";\nEOF\n\t    fi\n\n\t    if test \"$fast_install\" = yes; then\n\t      cat <<EOF\nconst char * TARGET_PROGRAM_NAME = \"lt-$outputname\"; /* hopefully, no .exe */\nEOF\n\t    else\n\t      cat <<EOF\nconst char * TARGET_PROGRAM_NAME = \"$outputname\"; /* hopefully, no .exe */\nEOF\n\t    fi\n\n\n\t    cat <<\"EOF\"\n\n#define LTWRAPPER_OPTION_PREFIX         \"--lt-\"\n\nstatic const char *ltwrapper_option_prefix = LTWRAPPER_OPTION_PREFIX;\nstatic const char *dumpscript_opt       = LTWRAPPER_OPTION_PREFIX \"dump-script\";\nstatic const char *debug_opt            = LTWRAPPER_OPTION_PREFIX \"debug\";\n\nint\nmain (int argc, char *argv[])\n{\n  char **newargz;\n  int  newargc;\n  char *tmp_pathspec;\n  char *actual_cwrapper_path;\n  char *actual_cwrapper_name;\n  char *target_name;\n  char *lt_argv_zero;\n  intptr_t rval = 127;\n\n  int i;\n\n  program_name = (char *) xstrdup (base_name (argv[0]));\n  newargz = XMALLOC (char *, argc + 1);\n\n  /* very simple arg parsing; don't want to rely on getopt\n   * also, copy all non cwrapper options to newargz, except\n   * argz[0], which is handled differently\n   */\n  newargc=0;\n  for (i = 1; i < argc; i++)\n    {\n      if (strcmp (argv[i], dumpscript_opt) == 0)\n\t{\nEOF\n\t    case \"$host\" in\n\t      *mingw* | *cygwin* )\n\t\t# make stdout use \"unix\" line endings\n\t\techo \"          setmode(1,_O_BINARY);\"\n\t\t;;\n\t      esac\n\n\t    cat <<\"EOF\"\n\t  lt_dump_script (stdout);\n\t  return 0;\n\t}\n      if (strcmp (argv[i], debug_opt) == 0)\n\t{\n          lt_debug = 1;\n          continue;\n\t}\n      if (strcmp (argv[i], ltwrapper_option_prefix) == 0)\n        {\n          /* however, if there is an option in the LTWRAPPER_OPTION_PREFIX\n             namespace, but it is not one of the ones we know about and\n             have already dealt with, above (inluding dump-script), then\n             report an error. Otherwise, targets might begin to believe\n             they are allowed to use options in the LTWRAPPER_OPTION_PREFIX\n             namespace. The first time any user complains about this, we'll\n             need to make LTWRAPPER_OPTION_PREFIX a configure-time option\n             or a configure.ac-settable value.\n           */\n          lt_fatal (__FILE__, __LINE__,\n\t\t    \"unrecognized %s option: '%s'\",\n                    ltwrapper_option_prefix, argv[i]);\n        }\n      /* otherwise ... */\n      newargz[++newargc] = xstrdup (argv[i]);\n    }\n  newargz[++newargc] = NULL;\n\nEOF\n\t    cat <<EOF\n  /* The GNU banner must be the first non-error debug message */\n  lt_debugprintf (__FILE__, __LINE__, \"libtool wrapper (GNU $PACKAGE$TIMESTAMP) $VERSION\\n\");\nEOF\n\t    cat <<\"EOF\"\n  lt_debugprintf (__FILE__, __LINE__, \"(main) argv[0]: %s\\n\", argv[0]);\n  lt_debugprintf (__FILE__, __LINE__, \"(main) program_name: %s\\n\", program_name);\n\n  tmp_pathspec = find_executable (argv[0]);\n  if (tmp_pathspec == NULL)\n    lt_fatal (__FILE__, __LINE__, \"couldn't find %s\", argv[0]);\n  lt_debugprintf (__FILE__, __LINE__,\n                  \"(main) found exe (before symlink chase) at: %s\\n\",\n\t\t  tmp_pathspec);\n\n  actual_cwrapper_path = chase_symlinks (tmp_pathspec);\n  lt_debugprintf (__FILE__, __LINE__,\n                  \"(main) found exe (after symlink chase) at: %s\\n\",\n\t\t  actual_cwrapper_path);\n  XFREE (tmp_pathspec);\n\n  actual_cwrapper_name = xstrdup (base_name (actual_cwrapper_path));\n  strendzap (actual_cwrapper_path, actual_cwrapper_name);\n\n  /* wrapper name transforms */\n  strendzap (actual_cwrapper_name, \".exe\");\n  tmp_pathspec = lt_extend_str (actual_cwrapper_name, \".exe\", 1);\n  XFREE (actual_cwrapper_name);\n  actual_cwrapper_name = tmp_pathspec;\n  tmp_pathspec = 0;\n\n  /* target_name transforms -- use actual target program name; might have lt- prefix */\n  target_name = xstrdup (base_name (TARGET_PROGRAM_NAME));\n  strendzap (target_name, \".exe\");\n  tmp_pathspec = lt_extend_str (target_name, \".exe\", 1);\n  XFREE (target_name);\n  target_name = tmp_pathspec;\n  tmp_pathspec = 0;\n\n  lt_debugprintf (__FILE__, __LINE__,\n\t\t  \"(main) libtool target name: %s\\n\",\n\t\t  target_name);\nEOF\n\n\t    cat <<EOF\n  newargz[0] =\n    XMALLOC (char, (strlen (actual_cwrapper_path) +\n\t\t    strlen (\"$objdir\") + 1 + strlen (actual_cwrapper_name) + 1));\n  strcpy (newargz[0], actual_cwrapper_path);\n  strcat (newargz[0], \"$objdir\");\n  strcat (newargz[0], \"/\");\nEOF\n\n\t    cat <<\"EOF\"\n  /* stop here, and copy so we don't have to do this twice */\n  tmp_pathspec = xstrdup (newargz[0]);\n\n  /* do NOT want the lt- prefix here, so use actual_cwrapper_name */\n  strcat (newargz[0], actual_cwrapper_name);\n\n  /* DO want the lt- prefix here if it exists, so use target_name */\n  lt_argv_zero = lt_extend_str (tmp_pathspec, target_name, 1);\n  XFREE (tmp_pathspec);\n  tmp_pathspec = NULL;\nEOF\n\n\t    case $host_os in\n\t      mingw*)\n\t    cat <<\"EOF\"\n  {\n    char* p;\n    while ((p = strchr (newargz[0], '\\\\')) != NULL)\n      {\n\t*p = '/';\n      }\n    while ((p = strchr (lt_argv_zero, '\\\\')) != NULL)\n      {\n\t*p = '/';\n      }\n  }\nEOF\n\t    ;;\n\t    esac\n\n\t    cat <<\"EOF\"\n  XFREE (target_name);\n  XFREE (actual_cwrapper_path);\n  XFREE (actual_cwrapper_name);\n\n  lt_setenv (\"BIN_SH\", \"xpg4\"); /* for Tru64 */\n  lt_setenv (\"DUALCASE\", \"1\");  /* for MSK sh */\n  /* Update the DLL searchpath.  EXE_PATH_VALUE ($dllsearchpath) must\n     be prepended before (that is, appear after) LIB_PATH_VALUE ($temp_rpath)\n     because on Windows, both *_VARNAMEs are PATH but uninstalled\n     libraries must come first. */\n  lt_update_exe_path (EXE_PATH_VARNAME, EXE_PATH_VALUE);\n  lt_update_lib_path (LIB_PATH_VARNAME, LIB_PATH_VALUE);\n\n  lt_debugprintf (__FILE__, __LINE__, \"(main) lt_argv_zero: %s\\n\",\n\t\t  nonnull (lt_argv_zero));\n  for (i = 0; i < newargc; i++)\n    {\n      lt_debugprintf (__FILE__, __LINE__, \"(main) newargz[%d]: %s\\n\",\n\t\t      i, nonnull (newargz[i]));\n    }\n\nEOF\n\n\t    case $host_os in\n\t      mingw*)\n\t\tcat <<\"EOF\"\n  /* execv doesn't actually work on mingw as expected on unix */\n  newargz = prepare_spawn (newargz);\n  rval = _spawnv (_P_WAIT, lt_argv_zero, (const char * const *) newargz);\n  if (rval == -1)\n    {\n      /* failed to start process */\n      lt_debugprintf (__FILE__, __LINE__,\n\t\t      \"(main) failed to launch target \\\"%s\\\": %s\\n\",\n\t\t      lt_argv_zero, nonnull (strerror (errno)));\n      return 127;\n    }\n  return rval;\nEOF\n\t\t;;\n\t      *)\n\t\tcat <<\"EOF\"\n  execv (lt_argv_zero, newargz);\n  return rval; /* =127, but avoids unused variable warning */\nEOF\n\t\t;;\n\t    esac\n\n\t    cat <<\"EOF\"\n}\n\nvoid *\nxmalloc (size_t num)\n{\n  void *p = (void *) malloc (num);\n  if (!p)\n    lt_fatal (__FILE__, __LINE__, \"memory exhausted\");\n\n  return p;\n}\n\nchar *\nxstrdup (const char *string)\n{\n  return string ? strcpy ((char *) xmalloc (strlen (string) + 1),\n\t\t\t  string) : NULL;\n}\n\nconst char *\nbase_name (const char *name)\n{\n  const char *base;\n\n#if defined (HAVE_DOS_BASED_FILE_SYSTEM)\n  /* Skip over the disk name in MSDOS pathnames. */\n  if (isalpha ((unsigned char) name[0]) && name[1] == ':')\n    name += 2;\n#endif\n\n  for (base = name; *name; name++)\n    if (IS_DIR_SEPARATOR (*name))\n      base = name + 1;\n  return base;\n}\n\nint\ncheck_executable (const char *path)\n{\n  struct stat st;\n\n  lt_debugprintf (__FILE__, __LINE__, \"(check_executable): %s\\n\",\n                  nonempty (path));\n  if ((!path) || (!*path))\n    return 0;\n\n  if ((stat (path, &st) >= 0)\n      && (st.st_mode & (S_IXUSR | S_IXGRP | S_IXOTH)))\n    return 1;\n  else\n    return 0;\n}\n\nint\nmake_executable (const char *path)\n{\n  int rval = 0;\n  struct stat st;\n\n  lt_debugprintf (__FILE__, __LINE__, \"(make_executable): %s\\n\",\n                  nonempty (path));\n  if ((!path) || (!*path))\n    return 0;\n\n  if (stat (path, &st) >= 0)\n    {\n      rval = chmod (path, st.st_mode | S_IXOTH | S_IXGRP | S_IXUSR);\n    }\n  return rval;\n}\n\n/* Searches for the full path of the wrapper.  Returns\n   newly allocated full path name if found, NULL otherwise\n   Does not chase symlinks, even on platforms that support them.\n*/\nchar *\nfind_executable (const char *wrapper)\n{\n  int has_slash = 0;\n  const char *p;\n  const char *p_next;\n  /* static buffer for getcwd */\n  char tmp[LT_PATHMAX + 1];\n  int tmp_len;\n  char *concat_name;\n\n  lt_debugprintf (__FILE__, __LINE__, \"(find_executable): %s\\n\",\n                  nonempty (wrapper));\n\n  if ((wrapper == NULL) || (*wrapper == '\\0'))\n    return NULL;\n\n  /* Absolute path? */\n#if defined (HAVE_DOS_BASED_FILE_SYSTEM)\n  if (isalpha ((unsigned char) wrapper[0]) && wrapper[1] == ':')\n    {\n      concat_name = xstrdup (wrapper);\n      if (check_executable (concat_name))\n\treturn concat_name;\n      XFREE (concat_name);\n    }\n  else\n    {\n#endif\n      if (IS_DIR_SEPARATOR (wrapper[0]))\n\t{\n\t  concat_name = xstrdup (wrapper);\n\t  if (check_executable (concat_name))\n\t    return concat_name;\n\t  XFREE (concat_name);\n\t}\n#if defined (HAVE_DOS_BASED_FILE_SYSTEM)\n    }\n#endif\n\n  for (p = wrapper; *p; p++)\n    if (*p == '/')\n      {\n\thas_slash = 1;\n\tbreak;\n      }\n  if (!has_slash)\n    {\n      /* no slashes; search PATH */\n      const char *path = getenv (\"PATH\");\n      if (path != NULL)\n\t{\n\t  for (p = path; *p; p = p_next)\n\t    {\n\t      const char *q;\n\t      size_t p_len;\n\t      for (q = p; *q; q++)\n\t\tif (IS_PATH_SEPARATOR (*q))\n\t\t  break;\n\t      p_len = q - p;\n\t      p_next = (*q == '\\0' ? q : q + 1);\n\t      if (p_len == 0)\n\t\t{\n\t\t  /* empty path: current directory */\n\t\t  if (getcwd (tmp, LT_PATHMAX) == NULL)\n\t\t    lt_fatal (__FILE__, __LINE__, \"getcwd failed: %s\",\n                              nonnull (strerror (errno)));\n\t\t  tmp_len = strlen (tmp);\n\t\t  concat_name =\n\t\t    XMALLOC (char, tmp_len + 1 + strlen (wrapper) + 1);\n\t\t  memcpy (concat_name, tmp, tmp_len);\n\t\t  concat_name[tmp_len] = '/';\n\t\t  strcpy (concat_name + tmp_len + 1, wrapper);\n\t\t}\n\t      else\n\t\t{\n\t\t  concat_name =\n\t\t    XMALLOC (char, p_len + 1 + strlen (wrapper) + 1);\n\t\t  memcpy (concat_name, p, p_len);\n\t\t  concat_name[p_len] = '/';\n\t\t  strcpy (concat_name + p_len + 1, wrapper);\n\t\t}\n\t      if (check_executable (concat_name))\n\t\treturn concat_name;\n\t      XFREE (concat_name);\n\t    }\n\t}\n      /* not found in PATH; assume curdir */\n    }\n  /* Relative path | not found in path: prepend cwd */\n  if (getcwd (tmp, LT_PATHMAX) == NULL)\n    lt_fatal (__FILE__, __LINE__, \"getcwd failed: %s\",\n              nonnull (strerror (errno)));\n  tmp_len = strlen (tmp);\n  concat_name = XMALLOC (char, tmp_len + 1 + strlen (wrapper) + 1);\n  memcpy (concat_name, tmp, tmp_len);\n  concat_name[tmp_len] = '/';\n  strcpy (concat_name + tmp_len + 1, wrapper);\n\n  if (check_executable (concat_name))\n    return concat_name;\n  XFREE (concat_name);\n  return NULL;\n}\n\nchar *\nchase_symlinks (const char *pathspec)\n{\n#ifndef S_ISLNK\n  return xstrdup (pathspec);\n#else\n  char buf[LT_PATHMAX];\n  struct stat s;\n  char *tmp_pathspec = xstrdup (pathspec);\n  char *p;\n  int has_symlinks = 0;\n  while (strlen (tmp_pathspec) && !has_symlinks)\n    {\n      lt_debugprintf (__FILE__, __LINE__,\n\t\t      \"checking path component for symlinks: %s\\n\",\n\t\t      tmp_pathspec);\n      if (lstat (tmp_pathspec, &s) == 0)\n\t{\n\t  if (S_ISLNK (s.st_mode) != 0)\n\t    {\n\t      has_symlinks = 1;\n\t      break;\n\t    }\n\n\t  /* search backwards for last DIR_SEPARATOR */\n\t  p = tmp_pathspec + strlen (tmp_pathspec) - 1;\n\t  while ((p > tmp_pathspec) && (!IS_DIR_SEPARATOR (*p)))\n\t    p--;\n\t  if ((p == tmp_pathspec) && (!IS_DIR_SEPARATOR (*p)))\n\t    {\n\t      /* no more DIR_SEPARATORS left */\n\t      break;\n\t    }\n\t  *p = '\\0';\n\t}\n      else\n\t{\n\t  lt_fatal (__FILE__, __LINE__,\n\t\t    \"error accessing file \\\"%s\\\": %s\",\n\t\t    tmp_pathspec, nonnull (strerror (errno)));\n\t}\n    }\n  XFREE (tmp_pathspec);\n\n  if (!has_symlinks)\n    {\n      return xstrdup (pathspec);\n    }\n\n  tmp_pathspec = realpath (pathspec, buf);\n  if (tmp_pathspec == 0)\n    {\n      lt_fatal (__FILE__, __LINE__,\n\t\t\"could not follow symlinks for %s\", pathspec);\n    }\n  return xstrdup (tmp_pathspec);\n#endif\n}\n\nchar *\nstrendzap (char *str, const char *pat)\n{\n  size_t len, patlen;\n\n  assert (str != NULL);\n  assert (pat != NULL);\n\n  len = strlen (str);\n  patlen = strlen (pat);\n\n  if (patlen <= len)\n    {\n      str += len - patlen;\n      if (strcmp (str, pat) == 0)\n\t*str = '\\0';\n    }\n  return str;\n}\n\nvoid\nlt_debugprintf (const char *file, int line, const char *fmt, ...)\n{\n  va_list args;\n  if (lt_debug)\n    {\n      (void) fprintf (stderr, \"%s:%s:%d: \", program_name, file, line);\n      va_start (args, fmt);\n      (void) vfprintf (stderr, fmt, args);\n      va_end (args);\n    }\n}\n\nstatic void\nlt_error_core (int exit_status, const char *file,\n\t       int line, const char *mode,\n\t       const char *message, va_list ap)\n{\n  fprintf (stderr, \"%s:%s:%d: %s: \", program_name, file, line, mode);\n  vfprintf (stderr, message, ap);\n  fprintf (stderr, \".\\n\");\n\n  if (exit_status >= 0)\n    exit (exit_status);\n}\n\nvoid\nlt_fatal (const char *file, int line, const char *message, ...)\n{\n  va_list ap;\n  va_start (ap, message);\n  lt_error_core (EXIT_FAILURE, file, line, \"FATAL\", message, ap);\n  va_end (ap);\n}\n\nstatic const char *\nnonnull (const char *s)\n{\n  return s ? s : \"(null)\";\n}\n\nstatic const char *\nnonempty (const char *s)\n{\n  return (s && !*s) ? \"(empty)\" : nonnull (s);\n}\n\nvoid\nlt_setenv (const char *name, const char *value)\n{\n  lt_debugprintf (__FILE__, __LINE__,\n\t\t  \"(lt_setenv) setting '%s' to '%s'\\n\",\n                  nonnull (name), nonnull (value));\n  {\n#ifdef HAVE_SETENV\n    /* always make a copy, for consistency with !HAVE_SETENV */\n    char *str = xstrdup (value);\n    setenv (name, str, 1);\n#else\n    int len = strlen (name) + 1 + strlen (value) + 1;\n    char *str = XMALLOC (char, len);\n    sprintf (str, \"%s=%s\", name, value);\n    if (putenv (str) != EXIT_SUCCESS)\n      {\n        XFREE (str);\n      }\n#endif\n  }\n}\n\nchar *\nlt_extend_str (const char *orig_value, const char *add, int to_end)\n{\n  char *new_value;\n  if (orig_value && *orig_value)\n    {\n      int orig_value_len = strlen (orig_value);\n      int add_len = strlen (add);\n      new_value = XMALLOC (char, add_len + orig_value_len + 1);\n      if (to_end)\n        {\n          strcpy (new_value, orig_value);\n          strcpy (new_value + orig_value_len, add);\n        }\n      else\n        {\n          strcpy (new_value, add);\n          strcpy (new_value + add_len, orig_value);\n        }\n    }\n  else\n    {\n      new_value = xstrdup (add);\n    }\n  return new_value;\n}\n\nvoid\nlt_update_exe_path (const char *name, const char *value)\n{\n  lt_debugprintf (__FILE__, __LINE__,\n\t\t  \"(lt_update_exe_path) modifying '%s' by prepending '%s'\\n\",\n                  nonnull (name), nonnull (value));\n\n  if (name && *name && value && *value)\n    {\n      char *new_value = lt_extend_str (getenv (name), value, 0);\n      /* some systems can't cope with a ':'-terminated path #' */\n      int len = strlen (new_value);\n      while (((len = strlen (new_value)) > 0) && IS_PATH_SEPARATOR (new_value[len-1]))\n        {\n          new_value[len-1] = '\\0';\n        }\n      lt_setenv (name, new_value);\n      XFREE (new_value);\n    }\n}\n\nvoid\nlt_update_lib_path (const char *name, const char *value)\n{\n  lt_debugprintf (__FILE__, __LINE__,\n\t\t  \"(lt_update_lib_path) modifying '%s' by prepending '%s'\\n\",\n                  nonnull (name), nonnull (value));\n\n  if (name && *name && value && *value)\n    {\n      char *new_value = lt_extend_str (getenv (name), value, 0);\n      lt_setenv (name, new_value);\n      XFREE (new_value);\n    }\n}\n\nEOF\n\t    case $host_os in\n\t      mingw*)\n\t\tcat <<\"EOF\"\n\n/* Prepares an argument vector before calling spawn().\n   Note that spawn() does not by itself call the command interpreter\n     (getenv (\"COMSPEC\") != NULL ? getenv (\"COMSPEC\") :\n      ({ OSVERSIONINFO v; v.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);\n         GetVersionEx(&v);\n         v.dwPlatformId == VER_PLATFORM_WIN32_NT;\n      }) ? \"cmd.exe\" : \"command.com\").\n   Instead it simply concatenates the arguments, separated by ' ', and calls\n   CreateProcess().  We must quote the arguments since Win32 CreateProcess()\n   interprets characters like ' ', '\\t', '\\\\', '\"' (but not '<' and '>') in a\n   special way:\n   - Space and tab are interpreted as delimiters. They are not treated as\n     delimiters if they are surrounded by double quotes: \"...\".\n   - Unescaped double quotes are removed from the input. Their only effect is\n     that within double quotes, space and tab are treated like normal\n     characters.\n   - Backslashes not followed by double quotes are not special.\n   - But 2*n+1 backslashes followed by a double quote become\n     n backslashes followed by a double quote (n >= 0):\n       \\\" -> \"\n       \\\\\\\" -> \\\"\n       \\\\\\\\\\\" -> \\\\\"\n */\n#define SHELL_SPECIAL_CHARS \"\\\"\\\\ \\001\\002\\003\\004\\005\\006\\007\\010\\011\\012\\013\\014\\015\\016\\017\\020\\021\\022\\023\\024\\025\\026\\027\\030\\031\\032\\033\\034\\035\\036\\037\"\n#define SHELL_SPACE_CHARS \" \\001\\002\\003\\004\\005\\006\\007\\010\\011\\012\\013\\014\\015\\016\\017\\020\\021\\022\\023\\024\\025\\026\\027\\030\\031\\032\\033\\034\\035\\036\\037\"\nchar **\nprepare_spawn (char **argv)\n{\n  size_t argc;\n  char **new_argv;\n  size_t i;\n\n  /* Count number of arguments.  */\n  for (argc = 0; argv[argc] != NULL; argc++)\n    ;\n\n  /* Allocate new argument vector.  */\n  new_argv = XMALLOC (char *, argc + 1);\n\n  /* Put quoted arguments into the new argument vector.  */\n  for (i = 0; i < argc; i++)\n    {\n      const char *string = argv[i];\n\n      if (string[0] == '\\0')\n\tnew_argv[i] = xstrdup (\"\\\"\\\"\");\n      else if (strpbrk (string, SHELL_SPECIAL_CHARS) != NULL)\n\t{\n\t  int quote_around = (strpbrk (string, SHELL_SPACE_CHARS) != NULL);\n\t  size_t length;\n\t  unsigned int backslashes;\n\t  const char *s;\n\t  char *quoted_string;\n\t  char *p;\n\n\t  length = 0;\n\t  backslashes = 0;\n\t  if (quote_around)\n\t    length++;\n\t  for (s = string; *s != '\\0'; s++)\n\t    {\n\t      char c = *s;\n\t      if (c == '\"')\n\t\tlength += backslashes + 1;\n\t      length++;\n\t      if (c == '\\\\')\n\t\tbackslashes++;\n\t      else\n\t\tbackslashes = 0;\n\t    }\n\t  if (quote_around)\n\t    length += backslashes + 1;\n\n\t  quoted_string = XMALLOC (char, length + 1);\n\n\t  p = quoted_string;\n\t  backslashes = 0;\n\t  if (quote_around)\n\t    *p++ = '\"';\n\t  for (s = string; *s != '\\0'; s++)\n\t    {\n\t      char c = *s;\n\t      if (c == '\"')\n\t\t{\n\t\t  unsigned int j;\n\t\t  for (j = backslashes + 1; j > 0; j--)\n\t\t    *p++ = '\\\\';\n\t\t}\n\t      *p++ = c;\n\t      if (c == '\\\\')\n\t\tbackslashes++;\n\t      else\n\t\tbackslashes = 0;\n\t    }\n\t  if (quote_around)\n\t    {\n\t      unsigned int j;\n\t      for (j = backslashes; j > 0; j--)\n\t\t*p++ = '\\\\';\n\t      *p++ = '\"';\n\t    }\n\t  *p = '\\0';\n\n\t  new_argv[i] = quoted_string;\n\t}\n      else\n\tnew_argv[i] = (char *) string;\n    }\n  new_argv[argc] = NULL;\n\n  return new_argv;\n}\nEOF\n\t\t;;\n\t    esac\n\n            cat <<\"EOF\"\nvoid lt_dump_script (FILE* f)\n{\nEOF\n\t    func_emit_wrapper yes |\n\t      $SED -n -e '\ns/^\\(.\\{79\\}\\)\\(..*\\)/\\1\\\n\\2/\nh\ns/\\([\\\\\"]\\)/\\\\\\1/g\ns/$/\\\\n/\ns/\\([^\\n]*\\).*/  fputs (\"\\1\", f);/p\ng\nD'\n            cat <<\"EOF\"\n}\nEOF\n}\n# end: func_emit_cwrapperexe_src\n\n# func_win32_import_lib_p ARG\n# True if ARG is an import lib, as indicated by $file_magic_cmd\nfunc_win32_import_lib_p ()\n{\n    $opt_debug\n    case `eval $file_magic_cmd \\\"\\$1\\\" 2>/dev/null | $SED -e 10q` in\n    *import*) : ;;\n    *) false ;;\n    esac\n}\n\n# func_mode_link arg...\nfunc_mode_link ()\n{\n    $opt_debug\n    case $host in\n    *-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-cegcc*)\n      # It is impossible to link a dll without this setting, and\n      # we shouldn't force the makefile maintainer to figure out\n      # which system we are compiling for in order to pass an extra\n      # flag for every libtool invocation.\n      # allow_undefined=no\n\n      # FIXME: Unfortunately, there are problems with the above when trying\n      # to make a dll which has undefined symbols, in which case not\n      # even a static library is built.  For now, we need to specify\n      # -no-undefined on the libtool link line when we can be certain\n      # that all symbols are satisfied, otherwise we get a static library.\n      allow_undefined=yes\n      ;;\n    *)\n      allow_undefined=yes\n      ;;\n    esac\n    libtool_args=$nonopt\n    base_compile=\"$nonopt $@\"\n    compile_command=$nonopt\n    finalize_command=$nonopt\n\n    compile_rpath=\n    finalize_rpath=\n    compile_shlibpath=\n    finalize_shlibpath=\n    convenience=\n    old_convenience=\n    deplibs=\n    old_deplibs=\n    compiler_flags=\n    linker_flags=\n    dllsearchpath=\n    lib_search_path=`pwd`\n    inst_prefix_dir=\n    new_inherited_linker_flags=\n\n    avoid_version=no\n    bindir=\n    dlfiles=\n    dlprefiles=\n    dlself=no\n    export_dynamic=no\n    export_symbols=\n    export_symbols_regex=\n    generated=\n    libobjs=\n    ltlibs=\n    module=no\n    no_install=no\n    objs=\n    non_pic_objects=\n    precious_files_regex=\n    prefer_static_libs=no\n    preload=no\n    prev=\n    prevarg=\n    release=\n    rpath=\n    xrpath=\n    perm_rpath=\n    temp_rpath=\n    thread_safe=no\n    vinfo=\n    vinfo_number=no\n    weak_libs=\n    single_module=\"${wl}-single_module\"\n    func_infer_tag $base_compile\n\n    # We need to know -static, to get the right output filenames.\n    for arg\n    do\n      case $arg in\n      -shared)\n\ttest \"$build_libtool_libs\" != yes && \\\n\t  func_fatal_configuration \"can not build a shared library\"\n\tbuild_old_libs=no\n\tbreak\n\t;;\n      -all-static | -static | -static-libtool-libs)\n\tcase $arg in\n\t-all-static)\n\t  if test \"$build_libtool_libs\" = yes && test -z \"$link_static_flag\"; then\n\t    func_warning \"complete static linking is impossible in this configuration\"\n\t  fi\n\t  if test -n \"$link_static_flag\"; then\n\t    dlopen_self=$dlopen_self_static\n\t  fi\n\t  prefer_static_libs=yes\n\t  ;;\n\t-static)\n\t  if test -z \"$pic_flag\" && test -n \"$link_static_flag\"; then\n\t    dlopen_self=$dlopen_self_static\n\t  fi\n\t  prefer_static_libs=built\n\t  ;;\n\t-static-libtool-libs)\n\t  if test -z \"$pic_flag\" && test -n \"$link_static_flag\"; then\n\t    dlopen_self=$dlopen_self_static\n\t  fi\n\t  prefer_static_libs=yes\n\t  ;;\n\tesac\n\tbuild_libtool_libs=no\n\tbuild_old_libs=yes\n\tbreak\n\t;;\n      esac\n    done\n\n    # See if our shared archives depend on static archives.\n    test -n \"$old_archive_from_new_cmds\" && build_old_libs=yes\n\n    # Go through the arguments, transforming them on the way.\n    while test \"$#\" -gt 0; do\n      arg=\"$1\"\n      shift\n      func_quote_for_eval \"$arg\"\n      qarg=$func_quote_for_eval_unquoted_result\n      func_append libtool_args \" $func_quote_for_eval_result\"\n\n      # If the previous option needs an argument, assign it.\n      if test -n \"$prev\"; then\n\tcase $prev in\n\toutput)\n\t  func_append compile_command \" @OUTPUT@\"\n\t  func_append finalize_command \" @OUTPUT@\"\n\t  ;;\n\tesac\n\n\tcase $prev in\n\tbindir)\n\t  bindir=\"$arg\"\n\t  prev=\n\t  continue\n\t  ;;\n\tdlfiles|dlprefiles)\n\t  if test \"$preload\" = no; then\n\t    # Add the symbol object into the linking commands.\n\t    func_append compile_command \" @SYMFILE@\"\n\t    func_append finalize_command \" @SYMFILE@\"\n\t    preload=yes\n\t  fi\n\t  case $arg in\n\t  *.la | *.lo) ;;  # We handle these cases below.\n\t  force)\n\t    if test \"$dlself\" = no; then\n\t      dlself=needless\n\t      export_dynamic=yes\n\t    fi\n\t    prev=\n\t    continue\n\t    ;;\n\t  self)\n\t    if test \"$prev\" = dlprefiles; then\n\t      dlself=yes\n\t    elif test \"$prev\" = dlfiles && test \"$dlopen_self\" != yes; then\n\t      dlself=yes\n\t    else\n\t      dlself=needless\n\t      export_dynamic=yes\n\t    fi\n\t    prev=\n\t    continue\n\t    ;;\n\t  *)\n\t    if test \"$prev\" = dlfiles; then\n\t      func_append dlfiles \" $arg\"\n\t    else\n\t      func_append dlprefiles \" $arg\"\n\t    fi\n\t    prev=\n\t    continue\n\t    ;;\n\t  esac\n\t  ;;\n\texpsyms)\n\t  export_symbols=\"$arg\"\n\t  test -f \"$arg\" \\\n\t    || func_fatal_error \"symbol file \\`$arg' does not exist\"\n\t  prev=\n\t  continue\n\t  ;;\n\texpsyms_regex)\n\t  export_symbols_regex=\"$arg\"\n\t  prev=\n\t  continue\n\t  ;;\n\tframework)\n\t  case $host in\n\t    *-*-darwin*)\n\t      case \"$deplibs \" in\n\t\t*\" $qarg.ltframework \"*) ;;\n\t\t*) func_append deplibs \" $qarg.ltframework\" # this is fixed later\n\t\t   ;;\n\t      esac\n\t      ;;\n\t  esac\n\t  prev=\n\t  continue\n\t  ;;\n\tinst_prefix)\n\t  inst_prefix_dir=\"$arg\"\n\t  prev=\n\t  continue\n\t  ;;\n\tobjectlist)\n\t  if test -f \"$arg\"; then\n\t    save_arg=$arg\n\t    moreargs=\n\t    for fil in `cat \"$save_arg\"`\n\t    do\n#\t      func_append moreargs \" $fil\"\n\t      arg=$fil\n\t      # A libtool-controlled object.\n\n\t      # Check to see that this really is a libtool object.\n\t      if func_lalib_unsafe_p \"$arg\"; then\n\t\tpic_object=\n\t\tnon_pic_object=\n\n\t\t# Read the .lo file\n\t\tfunc_source \"$arg\"\n\n\t\tif test -z \"$pic_object\" ||\n\t\t   test -z \"$non_pic_object\" ||\n\t\t   test \"$pic_object\" = none &&\n\t\t   test \"$non_pic_object\" = none; then\n\t\t  func_fatal_error \"cannot find name of object for \\`$arg'\"\n\t\tfi\n\n\t\t# Extract subdirectory from the argument.\n\t\tfunc_dirname \"$arg\" \"/\" \"\"\n\t\txdir=\"$func_dirname_result\"\n\n\t\tif test \"$pic_object\" != none; then\n\t\t  # Prepend the subdirectory the object is found in.\n\t\t  pic_object=\"$xdir$pic_object\"\n\n\t\t  if test \"$prev\" = dlfiles; then\n\t\t    if test \"$build_libtool_libs\" = yes && test \"$dlopen_support\" = yes; then\n\t\t      func_append dlfiles \" $pic_object\"\n\t\t      prev=\n\t\t      continue\n\t\t    else\n\t\t      # If libtool objects are unsupported, then we need to preload.\n\t\t      prev=dlprefiles\n\t\t    fi\n\t\t  fi\n\n\t\t  # CHECK ME:  I think I busted this.  -Ossama\n\t\t  if test \"$prev\" = dlprefiles; then\n\t\t    # Preload the old-style object.\n\t\t    func_append dlprefiles \" $pic_object\"\n\t\t    prev=\n\t\t  fi\n\n\t\t  # A PIC object.\n\t\t  func_append libobjs \" $pic_object\"\n\t\t  arg=\"$pic_object\"\n\t\tfi\n\n\t\t# Non-PIC object.\n\t\tif test \"$non_pic_object\" != none; then\n\t\t  # Prepend the subdirectory the object is found in.\n\t\t  non_pic_object=\"$xdir$non_pic_object\"\n\n\t\t  # A standard non-PIC object\n\t\t  func_append non_pic_objects \" $non_pic_object\"\n\t\t  if test -z \"$pic_object\" || test \"$pic_object\" = none ; then\n\t\t    arg=\"$non_pic_object\"\n\t\t  fi\n\t\telse\n\t\t  # If the PIC object exists, use it instead.\n\t\t  # $xdir was prepended to $pic_object above.\n\t\t  non_pic_object=\"$pic_object\"\n\t\t  func_append non_pic_objects \" $non_pic_object\"\n\t\tfi\n\t      else\n\t\t# Only an error if not doing a dry-run.\n\t\tif $opt_dry_run; then\n\t\t  # Extract subdirectory from the argument.\n\t\t  func_dirname \"$arg\" \"/\" \"\"\n\t\t  xdir=\"$func_dirname_result\"\n\n\t\t  func_lo2o \"$arg\"\n\t\t  pic_object=$xdir$objdir/$func_lo2o_result\n\t\t  non_pic_object=$xdir$func_lo2o_result\n\t\t  func_append libobjs \" $pic_object\"\n\t\t  func_append non_pic_objects \" $non_pic_object\"\n\t        else\n\t\t  func_fatal_error \"\\`$arg' is not a valid libtool object\"\n\t\tfi\n\t      fi\n\t    done\n\t  else\n\t    func_fatal_error \"link input file \\`$arg' does not exist\"\n\t  fi\n\t  arg=$save_arg\n\t  prev=\n\t  continue\n\t  ;;\n\tprecious_regex)\n\t  precious_files_regex=\"$arg\"\n\t  prev=\n\t  continue\n\t  ;;\n\trelease)\n\t  release=\"-$arg\"\n\t  prev=\n\t  continue\n\t  ;;\n\trpath | xrpath)\n\t  # We need an absolute path.\n\t  case $arg in\n\t  [\\\\/]* | [A-Za-z]:[\\\\/]*) ;;\n\t  *)\n\t    func_fatal_error \"only absolute run-paths are allowed\"\n\t    ;;\n\t  esac\n\t  if test \"$prev\" = rpath; then\n\t    case \"$rpath \" in\n\t    *\" $arg \"*) ;;\n\t    *) func_append rpath \" $arg\" ;;\n\t    esac\n\t  else\n\t    case \"$xrpath \" in\n\t    *\" $arg \"*) ;;\n\t    *) func_append xrpath \" $arg\" ;;\n\t    esac\n\t  fi\n\t  prev=\n\t  continue\n\t  ;;\n\tshrext)\n\t  shrext_cmds=\"$arg\"\n\t  prev=\n\t  continue\n\t  ;;\n\tweak)\n\t  func_append weak_libs \" $arg\"\n\t  prev=\n\t  continue\n\t  ;;\n\txcclinker)\n\t  func_append linker_flags \" $qarg\"\n\t  func_append compiler_flags \" $qarg\"\n\t  prev=\n\t  func_append compile_command \" $qarg\"\n\t  func_append finalize_command \" $qarg\"\n\t  continue\n\t  ;;\n\txcompiler)\n\t  func_append compiler_flags \" $qarg\"\n\t  prev=\n\t  func_append compile_command \" $qarg\"\n\t  func_append finalize_command \" $qarg\"\n\t  continue\n\t  ;;\n\txlinker)\n\t  func_append linker_flags \" $qarg\"\n\t  func_append compiler_flags \" $wl$qarg\"\n\t  prev=\n\t  func_append compile_command \" $wl$qarg\"\n\t  func_append finalize_command \" $wl$qarg\"\n\t  continue\n\t  ;;\n\t*)\n\t  eval \"$prev=\\\"\\$arg\\\"\"\n\t  prev=\n\t  continue\n\t  ;;\n\tesac\n      fi # test -n \"$prev\"\n\n      prevarg=\"$arg\"\n\n      case $arg in\n      -all-static)\n\tif test -n \"$link_static_flag\"; then\n\t  # See comment for -static flag below, for more details.\n\t  func_append compile_command \" $link_static_flag\"\n\t  func_append finalize_command \" $link_static_flag\"\n\tfi\n\tcontinue\n\t;;\n\n      -allow-undefined)\n\t# FIXME: remove this flag sometime in the future.\n\tfunc_fatal_error \"\\`-allow-undefined' must not be used because it is the default\"\n\t;;\n\n      -avoid-version)\n\tavoid_version=yes\n\tcontinue\n\t;;\n\n      -bindir)\n\tprev=bindir\n\tcontinue\n\t;;\n\n      -dlopen)\n\tprev=dlfiles\n\tcontinue\n\t;;\n\n      -dlpreopen)\n\tprev=dlprefiles\n\tcontinue\n\t;;\n\n      -export-dynamic)\n\texport_dynamic=yes\n\tcontinue\n\t;;\n\n      -export-symbols | -export-symbols-regex)\n\tif test -n \"$export_symbols\" || test -n \"$export_symbols_regex\"; then\n\t  func_fatal_error \"more than one -exported-symbols argument is not allowed\"\n\tfi\n\tif test \"X$arg\" = \"X-export-symbols\"; then\n\t  prev=expsyms\n\telse\n\t  prev=expsyms_regex\n\tfi\n\tcontinue\n\t;;\n\n      -framework)\n\tprev=framework\n\tcontinue\n\t;;\n\n      -inst-prefix-dir)\n\tprev=inst_prefix\n\tcontinue\n\t;;\n\n      # The native IRIX linker understands -LANG:*, -LIST:* and -LNO:*\n      # so, if we see these flags be careful not to treat them like -L\n      -L[A-Z][A-Z]*:*)\n\tcase $with_gcc/$host in\n\tno/*-*-irix* | /*-*-irix*)\n\t  func_append compile_command \" $arg\"\n\t  func_append finalize_command \" $arg\"\n\t  ;;\n\tesac\n\tcontinue\n\t;;\n\n      -L*)\n\tfunc_stripname \"-L\" '' \"$arg\"\n\tif test -z \"$func_stripname_result\"; then\n\t  if test \"$#\" -gt 0; then\n\t    func_fatal_error \"require no space between \\`-L' and \\`$1'\"\n\t  else\n\t    func_fatal_error \"need path for \\`-L' option\"\n\t  fi\n\tfi\n\tfunc_resolve_sysroot \"$func_stripname_result\"\n\tdir=$func_resolve_sysroot_result\n\t# We need an absolute path.\n\tcase $dir in\n\t[\\\\/]* | [A-Za-z]:[\\\\/]*) ;;\n\t*)\n\t  absdir=`cd \"$dir\" && pwd`\n\t  test -z \"$absdir\" && \\\n\t    func_fatal_error \"cannot determine absolute directory name of \\`$dir'\"\n\t  dir=\"$absdir\"\n\t  ;;\n\tesac\n\tcase \"$deplibs \" in\n\t*\" -L$dir \"* | *\" $arg \"*)\n\t  # Will only happen for absolute or sysroot arguments\n\t  ;;\n\t*)\n\t  # Preserve sysroot, but never include relative directories\n\t  case $dir in\n\t    [\\\\/]* | [A-Za-z]:[\\\\/]* | =*) func_append deplibs \" $arg\" ;;\n\t    *) func_append deplibs \" -L$dir\" ;;\n\t  esac\n\t  func_append lib_search_path \" $dir\"\n\t  ;;\n\tesac\n\tcase $host in\n\t*-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-cegcc*)\n\t  testbindir=`$ECHO \"$dir\" | $SED 's*/lib$*/bin*'`\n\t  case :$dllsearchpath: in\n\t  *\":$dir:\"*) ;;\n\t  ::) dllsearchpath=$dir;;\n\t  *) func_append dllsearchpath \":$dir\";;\n\t  esac\n\t  case :$dllsearchpath: in\n\t  *\":$testbindir:\"*) ;;\n\t  ::) dllsearchpath=$testbindir;;\n\t  *) func_append dllsearchpath \":$testbindir\";;\n\t  esac\n\t  ;;\n\tesac\n\tcontinue\n\t;;\n\n      -l*)\n\tif test \"X$arg\" = \"X-lc\" || test \"X$arg\" = \"X-lm\"; then\n\t  case $host in\n\t  *-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-beos* | *-cegcc* | *-*-haiku*)\n\t    # These systems don't actually have a C or math library (as such)\n\t    continue\n\t    ;;\n\t  *-*-os2*)\n\t    # These systems don't actually have a C library (as such)\n\t    test \"X$arg\" = \"X-lc\" && continue\n\t    ;;\n\t  *-*-openbsd* | *-*-freebsd* | *-*-dragonfly*)\n\t    # Do not include libc due to us having libc/libc_r.\n\t    test \"X$arg\" = \"X-lc\" && continue\n\t    ;;\n\t  *-*-rhapsody* | *-*-darwin1.[012])\n\t    # Rhapsody C and math libraries are in the System framework\n\t    func_append deplibs \" System.ltframework\"\n\t    continue\n\t    ;;\n\t  *-*-sco3.2v5* | *-*-sco5v6*)\n\t    # Causes problems with __ctype\n\t    test \"X$arg\" = \"X-lc\" && continue\n\t    ;;\n\t  *-*-sysv4.2uw2* | *-*-sysv5* | *-*-unixware* | *-*-OpenUNIX*)\n\t    # Compiler inserts libc in the correct place for threads to work\n\t    test \"X$arg\" = \"X-lc\" && continue\n\t    ;;\n\t  esac\n\telif test \"X$arg\" = \"X-lc_r\"; then\n\t case $host in\n\t *-*-openbsd* | *-*-freebsd* | *-*-dragonfly*)\n\t   # Do not include libc_r directly, use -pthread flag.\n\t   continue\n\t   ;;\n\t esac\n\tfi\n\tfunc_append deplibs \" $arg\"\n\tcontinue\n\t;;\n\n      -module)\n\tmodule=yes\n\tcontinue\n\t;;\n\n      # Tru64 UNIX uses -model [arg] to determine the layout of C++\n      # classes, name mangling, and exception handling.\n      # Darwin uses the -arch flag to determine output architecture.\n      -model|-arch|-isysroot|--sysroot)\n\tfunc_append compiler_flags \" $arg\"\n\tfunc_append compile_command \" $arg\"\n\tfunc_append finalize_command \" $arg\"\n\tprev=xcompiler\n\tcontinue\n\t;;\n\n      -mt|-mthreads|-kthread|-Kthread|-pthread|-pthreads|--thread-safe \\\n      |-threads|-fopenmp|-openmp|-mp|-xopenmp|-omp|-qsmp=*)\n\tfunc_append compiler_flags \" $arg\"\n\tfunc_append compile_command \" $arg\"\n\tfunc_append finalize_command \" $arg\"\n\tcase \"$new_inherited_linker_flags \" in\n\t    *\" $arg \"*) ;;\n\t    * ) func_append new_inherited_linker_flags \" $arg\" ;;\n\tesac\n\tcontinue\n\t;;\n\n      -multi_module)\n\tsingle_module=\"${wl}-multi_module\"\n\tcontinue\n\t;;\n\n      -no-fast-install)\n\tfast_install=no\n\tcontinue\n\t;;\n\n      -no-install)\n\tcase $host in\n\t*-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-*-darwin* | *-cegcc*)\n\t  # The PATH hackery in wrapper scripts is required on Windows\n\t  # and Darwin in order for the loader to find any dlls it needs.\n\t  func_warning \"\\`-no-install' is ignored for $host\"\n\t  func_warning \"assuming \\`-no-fast-install' instead\"\n\t  fast_install=no\n\t  ;;\n\t*) no_install=yes ;;\n\tesac\n\tcontinue\n\t;;\n\n      -no-undefined)\n\tallow_undefined=no\n\tcontinue\n\t;;\n\n      -objectlist)\n\tprev=objectlist\n\tcontinue\n\t;;\n\n      -o) prev=output ;;\n\n      -precious-files-regex)\n\tprev=precious_regex\n\tcontinue\n\t;;\n\n      -release)\n\tprev=release\n\tcontinue\n\t;;\n\n      -rpath)\n\tprev=rpath\n\tcontinue\n\t;;\n\n      -R)\n\tprev=xrpath\n\tcontinue\n\t;;\n\n      -R*)\n\tfunc_stripname '-R' '' \"$arg\"\n\tdir=$func_stripname_result\n\t# We need an absolute path.\n\tcase $dir in\n\t[\\\\/]* | [A-Za-z]:[\\\\/]*) ;;\n\t=*)\n\t  func_stripname '=' '' \"$dir\"\n\t  dir=$lt_sysroot$func_stripname_result\n\t  ;;\n\t*)\n\t  func_fatal_error \"only absolute run-paths are allowed\"\n\t  ;;\n\tesac\n\tcase \"$xrpath \" in\n\t*\" $dir \"*) ;;\n\t*) func_append xrpath \" $dir\" ;;\n\tesac\n\tcontinue\n\t;;\n\n      -shared)\n\t# The effects of -shared are defined in a previous loop.\n\tcontinue\n\t;;\n\n      -shrext)\n\tprev=shrext\n\tcontinue\n\t;;\n\n      -static | -static-libtool-libs)\n\t# The effects of -static are defined in a previous loop.\n\t# We used to do the same as -all-static on platforms that\n\t# didn't have a PIC flag, but the assumption that the effects\n\t# would be equivalent was wrong.  It would break on at least\n\t# Digital Unix and AIX.\n\tcontinue\n\t;;\n\n      -thread-safe)\n\tthread_safe=yes\n\tcontinue\n\t;;\n\n      -version-info)\n\tprev=vinfo\n\tcontinue\n\t;;\n\n      -version-number)\n\tprev=vinfo\n\tvinfo_number=yes\n\tcontinue\n\t;;\n\n      -weak)\n        prev=weak\n\tcontinue\n\t;;\n\n      -Wc,*)\n\tfunc_stripname '-Wc,' '' \"$arg\"\n\targs=$func_stripname_result\n\targ=\n\tsave_ifs=\"$IFS\"; IFS=','\n\tfor flag in $args; do\n\t  IFS=\"$save_ifs\"\n          func_quote_for_eval \"$flag\"\n\t  func_append arg \" $func_quote_for_eval_result\"\n\t  func_append compiler_flags \" $func_quote_for_eval_result\"\n\tdone\n\tIFS=\"$save_ifs\"\n\tfunc_stripname ' ' '' \"$arg\"\n\targ=$func_stripname_result\n\t;;\n\n      -Wl,*)\n\tfunc_stripname '-Wl,' '' \"$arg\"\n\targs=$func_stripname_result\n\targ=\n\tsave_ifs=\"$IFS\"; IFS=','\n\tfor flag in $args; do\n\t  IFS=\"$save_ifs\"\n          func_quote_for_eval \"$flag\"\n\t  func_append arg \" $wl$func_quote_for_eval_result\"\n\t  func_append compiler_flags \" $wl$func_quote_for_eval_result\"\n\t  func_append linker_flags \" $func_quote_for_eval_result\"\n\tdone\n\tIFS=\"$save_ifs\"\n\tfunc_stripname ' ' '' \"$arg\"\n\targ=$func_stripname_result\n\t;;\n\n      -Xcompiler)\n\tprev=xcompiler\n\tcontinue\n\t;;\n\n      -Xlinker)\n\tprev=xlinker\n\tcontinue\n\t;;\n\n      -XCClinker)\n\tprev=xcclinker\n\tcontinue\n\t;;\n\n      # -msg_* for osf cc\n      -msg_*)\n\tfunc_quote_for_eval \"$arg\"\n\targ=\"$func_quote_for_eval_result\"\n\t;;\n\n      # Flags to be passed through unchanged, with rationale:\n      # -64, -mips[0-9]      enable 64-bit mode for the SGI compiler\n      # -r[0-9][0-9]*        specify processor for the SGI compiler\n      # -xarch=*, -xtarget=* enable 64-bit mode for the Sun compiler\n      # +DA*, +DD*           enable 64-bit mode for the HP compiler\n      # -q*                  compiler args for the IBM compiler\n      # -m*, -t[45]*, -txscale* architecture-specific flags for GCC\n      # -F/path              path to uninstalled frameworks, gcc on darwin\n      # -p, -pg, --coverage, -fprofile-*  profiling flags for GCC\n      # @file                GCC response files\n      # -tp=*                Portland pgcc target processor selection\n      # --sysroot=*          for sysroot support\n      # -O*, -flto*, -fwhopr*, -fuse-linker-plugin GCC link-time optimization\n      -64|-mips[0-9]|-r[0-9][0-9]*|-xarch=*|-xtarget=*|+DA*|+DD*|-q*|-m*| \\\n      -t[45]*|-txscale*|-p|-pg|--coverage|-fprofile-*|-F*|@*|-tp=*|--sysroot=*| \\\n      -O*|-flto*|-fwhopr*|-fuse-linker-plugin)\n        func_quote_for_eval \"$arg\"\n\targ=\"$func_quote_for_eval_result\"\n        func_append compile_command \" $arg\"\n        func_append finalize_command \" $arg\"\n        func_append compiler_flags \" $arg\"\n        continue\n        ;;\n\n      # Some other compiler flag.\n      -* | +*)\n        func_quote_for_eval \"$arg\"\n\targ=\"$func_quote_for_eval_result\"\n\t;;\n\n      *.$objext)\n\t# A standard object.\n\tfunc_append objs \" $arg\"\n\t;;\n\n      *.lo)\n\t# A libtool-controlled object.\n\n\t# Check to see that this really is a libtool object.\n\tif func_lalib_unsafe_p \"$arg\"; then\n\t  pic_object=\n\t  non_pic_object=\n\n\t  # Read the .lo file\n\t  func_source \"$arg\"\n\n\t  if test -z \"$pic_object\" ||\n\t     test -z \"$non_pic_object\" ||\n\t     test \"$pic_object\" = none &&\n\t     test \"$non_pic_object\" = none; then\n\t    func_fatal_error \"cannot find name of object for \\`$arg'\"\n\t  fi\n\n\t  # Extract subdirectory from the argument.\n\t  func_dirname \"$arg\" \"/\" \"\"\n\t  xdir=\"$func_dirname_result\"\n\n\t  if test \"$pic_object\" != none; then\n\t    # Prepend the subdirectory the object is found in.\n\t    pic_object=\"$xdir$pic_object\"\n\n\t    if test \"$prev\" = dlfiles; then\n\t      if test \"$build_libtool_libs\" = yes && test \"$dlopen_support\" = yes; then\n\t\tfunc_append dlfiles \" $pic_object\"\n\t\tprev=\n\t\tcontinue\n\t      else\n\t\t# If libtool objects are unsupported, then we need to preload.\n\t\tprev=dlprefiles\n\t      fi\n\t    fi\n\n\t    # CHECK ME:  I think I busted this.  -Ossama\n\t    if test \"$prev\" = dlprefiles; then\n\t      # Preload the old-style object.\n\t      func_append dlprefiles \" $pic_object\"\n\t      prev=\n\t    fi\n\n\t    # A PIC object.\n\t    func_append libobjs \" $pic_object\"\n\t    arg=\"$pic_object\"\n\t  fi\n\n\t  # Non-PIC object.\n\t  if test \"$non_pic_object\" != none; then\n\t    # Prepend the subdirectory the object is found in.\n\t    non_pic_object=\"$xdir$non_pic_object\"\n\n\t    # A standard non-PIC object\n\t    func_append non_pic_objects \" $non_pic_object\"\n\t    if test -z \"$pic_object\" || test \"$pic_object\" = none ; then\n\t      arg=\"$non_pic_object\"\n\t    fi\n\t  else\n\t    # If the PIC object exists, use it instead.\n\t    # $xdir was prepended to $pic_object above.\n\t    non_pic_object=\"$pic_object\"\n\t    func_append non_pic_objects \" $non_pic_object\"\n\t  fi\n\telse\n\t  # Only an error if not doing a dry-run.\n\t  if $opt_dry_run; then\n\t    # Extract subdirectory from the argument.\n\t    func_dirname \"$arg\" \"/\" \"\"\n\t    xdir=\"$func_dirname_result\"\n\n\t    func_lo2o \"$arg\"\n\t    pic_object=$xdir$objdir/$func_lo2o_result\n\t    non_pic_object=$xdir$func_lo2o_result\n\t    func_append libobjs \" $pic_object\"\n\t    func_append non_pic_objects \" $non_pic_object\"\n\t  else\n\t    func_fatal_error \"\\`$arg' is not a valid libtool object\"\n\t  fi\n\tfi\n\t;;\n\n      *.$libext)\n\t# An archive.\n\tfunc_append deplibs \" $arg\"\n\tfunc_append old_deplibs \" $arg\"\n\tcontinue\n\t;;\n\n      *.la)\n\t# A libtool-controlled library.\n\n\tfunc_resolve_sysroot \"$arg\"\n\tif test \"$prev\" = dlfiles; then\n\t  # This library was specified with -dlopen.\n\t  func_append dlfiles \" $func_resolve_sysroot_result\"\n\t  prev=\n\telif test \"$prev\" = dlprefiles; then\n\t  # The library was specified with -dlpreopen.\n\t  func_append dlprefiles \" $func_resolve_sysroot_result\"\n\t  prev=\n\telse\n\t  func_append deplibs \" $func_resolve_sysroot_result\"\n\tfi\n\tcontinue\n\t;;\n\n      # Some other compiler argument.\n      *)\n\t# Unknown arguments in both finalize_command and compile_command need\n\t# to be aesthetically quoted because they are evaled later.\n\tfunc_quote_for_eval \"$arg\"\n\targ=\"$func_quote_for_eval_result\"\n\t;;\n      esac # arg\n\n      # Now actually substitute the argument into the commands.\n      if test -n \"$arg\"; then\n\tfunc_append compile_command \" $arg\"\n\tfunc_append finalize_command \" $arg\"\n      fi\n    done # argument parsing loop\n\n    test -n \"$prev\" && \\\n      func_fatal_help \"the \\`$prevarg' option requires an argument\"\n\n    if test \"$export_dynamic\" = yes && test -n \"$export_dynamic_flag_spec\"; then\n      eval arg=\\\"$export_dynamic_flag_spec\\\"\n      func_append compile_command \" $arg\"\n      func_append finalize_command \" $arg\"\n    fi\n\n    oldlibs=\n    # calculate the name of the file, without its directory\n    func_basename \"$output\"\n    outputname=\"$func_basename_result\"\n    libobjs_save=\"$libobjs\"\n\n    if test -n \"$shlibpath_var\"; then\n      # get the directories listed in $shlibpath_var\n      eval shlib_search_path=\\`\\$ECHO \\\"\\${$shlibpath_var}\\\" \\| \\$SED \\'s/:/ /g\\'\\`\n    else\n      shlib_search_path=\n    fi\n    eval sys_lib_search_path=\\\"$sys_lib_search_path_spec\\\"\n    eval sys_lib_dlsearch_path=\\\"$sys_lib_dlsearch_path_spec\\\"\n\n    func_dirname \"$output\" \"/\" \"\"\n    output_objdir=\"$func_dirname_result$objdir\"\n    func_to_tool_file \"$output_objdir/\"\n    tool_output_objdir=$func_to_tool_file_result\n    # Create the object directory.\n    func_mkdir_p \"$output_objdir\"\n\n    # Determine the type of output\n    case $output in\n    \"\")\n      func_fatal_help \"you must specify an output file\"\n      ;;\n    *.$libext) linkmode=oldlib ;;\n    *.lo | *.$objext) linkmode=obj ;;\n    *.la) linkmode=lib ;;\n    *) linkmode=prog ;; # Anything else should be a program.\n    esac\n\n    specialdeplibs=\n\n    libs=\n    # Find all interdependent deplibs by searching for libraries\n    # that are linked more than once (e.g. -la -lb -la)\n    for deplib in $deplibs; do\n      if $opt_preserve_dup_deps ; then\n\tcase \"$libs \" in\n\t*\" $deplib \"*) func_append specialdeplibs \" $deplib\" ;;\n\tesac\n      fi\n      func_append libs \" $deplib\"\n    done\n\n    if test \"$linkmode\" = lib; then\n      libs=\"$predeps $libs $compiler_lib_search_path $postdeps\"\n\n      # Compute libraries that are listed more than once in $predeps\n      # $postdeps and mark them as special (i.e., whose duplicates are\n      # not to be eliminated).\n      pre_post_deps=\n      if $opt_duplicate_compiler_generated_deps; then\n\tfor pre_post_dep in $predeps $postdeps; do\n\t  case \"$pre_post_deps \" in\n\t  *\" $pre_post_dep \"*) func_append specialdeplibs \" $pre_post_deps\" ;;\n\t  esac\n\t  func_append pre_post_deps \" $pre_post_dep\"\n\tdone\n      fi\n      pre_post_deps=\n    fi\n\n    deplibs=\n    newdependency_libs=\n    newlib_search_path=\n    need_relink=no # whether we're linking any uninstalled libtool libraries\n    notinst_deplibs= # not-installed libtool libraries\n    notinst_path= # paths that contain not-installed libtool libraries\n\n    case $linkmode in\n    lib)\n\tpasses=\"conv dlpreopen link\"\n\tfor file in $dlfiles $dlprefiles; do\n\t  case $file in\n\t  *.la) ;;\n\t  *)\n\t    func_fatal_help \"libraries can \\`-dlopen' only libtool libraries: $file\"\n\t    ;;\n\t  esac\n\tdone\n\t;;\n    prog)\n\tcompile_deplibs=\n\tfinalize_deplibs=\n\talldeplibs=no\n\tnewdlfiles=\n\tnewdlprefiles=\n\tpasses=\"conv scan dlopen dlpreopen link\"\n\t;;\n    *)  passes=\"conv\"\n\t;;\n    esac\n\n    for pass in $passes; do\n      # The preopen pass in lib mode reverses $deplibs; put it back here\n      # so that -L comes before libs that need it for instance...\n      if test \"$linkmode,$pass\" = \"lib,link\"; then\n\t## FIXME: Find the place where the list is rebuilt in the wrong\n\t##        order, and fix it there properly\n        tmp_deplibs=\n\tfor deplib in $deplibs; do\n\t  tmp_deplibs=\"$deplib $tmp_deplibs\"\n\tdone\n\tdeplibs=\"$tmp_deplibs\"\n      fi\n\n      if test \"$linkmode,$pass\" = \"lib,link\" ||\n\t test \"$linkmode,$pass\" = \"prog,scan\"; then\n\tlibs=\"$deplibs\"\n\tdeplibs=\n      fi\n      if test \"$linkmode\" = prog; then\n\tcase $pass in\n\tdlopen) libs=\"$dlfiles\" ;;\n\tdlpreopen) libs=\"$dlprefiles\" ;;\n\tlink)\n\t  libs=\"$deplibs %DEPLIBS%\"\n\t  test \"X$link_all_deplibs\" != Xno && libs=\"$libs $dependency_libs\"\n\t  ;;\n\tesac\n      fi\n      if test \"$linkmode,$pass\" = \"lib,dlpreopen\"; then\n\t# Collect and forward deplibs of preopened libtool libs\n\tfor lib in $dlprefiles; do\n\t  # Ignore non-libtool-libs\n\t  dependency_libs=\n\t  func_resolve_sysroot \"$lib\"\n\t  case $lib in\n\t  *.la)\tfunc_source \"$func_resolve_sysroot_result\" ;;\n\t  esac\n\n\t  # Collect preopened libtool deplibs, except any this library\n\t  # has declared as weak libs\n\t  for deplib in $dependency_libs; do\n\t    func_basename \"$deplib\"\n            deplib_base=$func_basename_result\n\t    case \" $weak_libs \" in\n\t    *\" $deplib_base \"*) ;;\n\t    *) func_append deplibs \" $deplib\" ;;\n\t    esac\n\t  done\n\tdone\n\tlibs=\"$dlprefiles\"\n      fi\n      if test \"$pass\" = dlopen; then\n\t# Collect dlpreopened libraries\n\tsave_deplibs=\"$deplibs\"\n\tdeplibs=\n      fi\n\n      for deplib in $libs; do\n\tlib=\n\tfound=no\n\tcase $deplib in\n\t-mt|-mthreads|-kthread|-Kthread|-pthread|-pthreads|--thread-safe \\\n        |-threads|-fopenmp|-openmp|-mp|-xopenmp|-omp|-qsmp=*)\n\t  if test \"$linkmode,$pass\" = \"prog,link\"; then\n\t    compile_deplibs=\"$deplib $compile_deplibs\"\n\t    finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t  else\n\t    func_append compiler_flags \" $deplib\"\n\t    if test \"$linkmode\" = lib ; then\n\t\tcase \"$new_inherited_linker_flags \" in\n\t\t    *\" $deplib \"*) ;;\n\t\t    * ) func_append new_inherited_linker_flags \" $deplib\" ;;\n\t\tesac\n\t    fi\n\t  fi\n\t  continue\n\t  ;;\n\t-l*)\n\t  if test \"$linkmode\" != lib && test \"$linkmode\" != prog; then\n\t    func_warning \"\\`-l' is ignored for archives/objects\"\n\t    continue\n\t  fi\n\t  func_stripname '-l' '' \"$deplib\"\n\t  name=$func_stripname_result\n\t  if test \"$linkmode\" = lib; then\n\t    searchdirs=\"$newlib_search_path $lib_search_path $compiler_lib_search_dirs $sys_lib_search_path $shlib_search_path\"\n\t  else\n\t    searchdirs=\"$newlib_search_path $lib_search_path $sys_lib_search_path $shlib_search_path\"\n\t  fi\n\t  for searchdir in $searchdirs; do\n\t    for search_ext in .la $std_shrext .so .a; do\n\t      # Search the libtool library\n\t      lib=\"$searchdir/lib${name}${search_ext}\"\n\t      if test -f \"$lib\"; then\n\t\tif test \"$search_ext\" = \".la\"; then\n\t\t  found=yes\n\t\telse\n\t\t  found=no\n\t\tfi\n\t\tbreak 2\n\t      fi\n\t    done\n\t  done\n\t  if test \"$found\" != yes; then\n\t    # deplib doesn't seem to be a libtool library\n\t    if test \"$linkmode,$pass\" = \"prog,link\"; then\n\t      compile_deplibs=\"$deplib $compile_deplibs\"\n\t      finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t    else\n\t      deplibs=\"$deplib $deplibs\"\n\t      test \"$linkmode\" = lib && newdependency_libs=\"$deplib $newdependency_libs\"\n\t    fi\n\t    continue\n\t  else # deplib is a libtool library\n\t    # If $allow_libtool_libs_with_static_runtimes && $deplib is a stdlib,\n\t    # We need to do some special things here, and not later.\n\t    if test \"X$allow_libtool_libs_with_static_runtimes\" = \"Xyes\" ; then\n\t      case \" $predeps $postdeps \" in\n\t      *\" $deplib \"*)\n\t\tif func_lalib_p \"$lib\"; then\n\t\t  library_names=\n\t\t  old_library=\n\t\t  func_source \"$lib\"\n\t\t  for l in $old_library $library_names; do\n\t\t    ll=\"$l\"\n\t\t  done\n\t\t  if test \"X$ll\" = \"X$old_library\" ; then # only static version available\n\t\t    found=no\n\t\t    func_dirname \"$lib\" \"\" \".\"\n\t\t    ladir=\"$func_dirname_result\"\n\t\t    lib=$ladir/$old_library\n\t\t    if test \"$linkmode,$pass\" = \"prog,link\"; then\n\t\t      compile_deplibs=\"$deplib $compile_deplibs\"\n\t\t      finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t\t    else\n\t\t      deplibs=\"$deplib $deplibs\"\n\t\t      test \"$linkmode\" = lib && newdependency_libs=\"$deplib $newdependency_libs\"\n\t\t    fi\n\t\t    continue\n\t\t  fi\n\t\tfi\n\t\t;;\n\t      *) ;;\n\t      esac\n\t    fi\n\t  fi\n\t  ;; # -l\n\t*.ltframework)\n\t  if test \"$linkmode,$pass\" = \"prog,link\"; then\n\t    compile_deplibs=\"$deplib $compile_deplibs\"\n\t    finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t  else\n\t    deplibs=\"$deplib $deplibs\"\n\t    if test \"$linkmode\" = lib ; then\n\t\tcase \"$new_inherited_linker_flags \" in\n\t\t    *\" $deplib \"*) ;;\n\t\t    * ) func_append new_inherited_linker_flags \" $deplib\" ;;\n\t\tesac\n\t    fi\n\t  fi\n\t  continue\n\t  ;;\n\t-L*)\n\t  case $linkmode in\n\t  lib)\n\t    deplibs=\"$deplib $deplibs\"\n\t    test \"$pass\" = conv && continue\n\t    newdependency_libs=\"$deplib $newdependency_libs\"\n\t    func_stripname '-L' '' \"$deplib\"\n\t    func_resolve_sysroot \"$func_stripname_result\"\n\t    func_append newlib_search_path \" $func_resolve_sysroot_result\"\n\t    ;;\n\t  prog)\n\t    if test \"$pass\" = conv; then\n\t      deplibs=\"$deplib $deplibs\"\n\t      continue\n\t    fi\n\t    if test \"$pass\" = scan; then\n\t      deplibs=\"$deplib $deplibs\"\n\t    else\n\t      compile_deplibs=\"$deplib $compile_deplibs\"\n\t      finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t    fi\n\t    func_stripname '-L' '' \"$deplib\"\n\t    func_resolve_sysroot \"$func_stripname_result\"\n\t    func_append newlib_search_path \" $func_resolve_sysroot_result\"\n\t    ;;\n\t  *)\n\t    func_warning \"\\`-L' is ignored for archives/objects\"\n\t    ;;\n\t  esac # linkmode\n\t  continue\n\t  ;; # -L\n\t-R*)\n\t  if test \"$pass\" = link; then\n\t    func_stripname '-R' '' \"$deplib\"\n\t    func_resolve_sysroot \"$func_stripname_result\"\n\t    dir=$func_resolve_sysroot_result\n\t    # Make sure the xrpath contains only unique directories.\n\t    case \"$xrpath \" in\n\t    *\" $dir \"*) ;;\n\t    *) func_append xrpath \" $dir\" ;;\n\t    esac\n\t  fi\n\t  deplibs=\"$deplib $deplibs\"\n\t  continue\n\t  ;;\n\t*.la)\n\t  func_resolve_sysroot \"$deplib\"\n\t  lib=$func_resolve_sysroot_result\n\t  ;;\n\t*.$libext)\n\t  if test \"$pass\" = conv; then\n\t    deplibs=\"$deplib $deplibs\"\n\t    continue\n\t  fi\n\t  case $linkmode in\n\t  lib)\n\t    # Linking convenience modules into shared libraries is allowed,\n\t    # but linking other static libraries is non-portable.\n\t    case \" $dlpreconveniencelibs \" in\n\t    *\" $deplib \"*) ;;\n\t    *)\n\t      valid_a_lib=no\n\t      case $deplibs_check_method in\n\t\tmatch_pattern*)\n\t\t  set dummy $deplibs_check_method; shift\n\t\t  match_pattern_regex=`expr \"$deplibs_check_method\" : \"$1 \\(.*\\)\"`\n\t\t  if eval \"\\$ECHO \\\"$deplib\\\"\" 2>/dev/null | $SED 10q \\\n\t\t    | $EGREP \"$match_pattern_regex\" > /dev/null; then\n\t\t    valid_a_lib=yes\n\t\t  fi\n\t\t;;\n\t\tpass_all)\n\t\t  valid_a_lib=yes\n\t\t;;\n\t      esac\n\t      if test \"$valid_a_lib\" != yes; then\n\t\techo\n\t\t$ECHO \"*** Warning: Trying to link with static lib archive $deplib.\"\n\t\techo \"*** I have the capability to make that library automatically link in when\"\n\t\techo \"*** you link to this library.  But I can only do this if you have a\"\n\t\techo \"*** shared version of the library, which you do not appear to have\"\n\t\techo \"*** because the file extensions .$libext of this argument makes me believe\"\n\t\techo \"*** that it is just a static archive that I should not use here.\"\n\t      else\n\t\techo\n\t\t$ECHO \"*** Warning: Linking the shared library $output against the\"\n\t\t$ECHO \"*** static library $deplib is not portable!\"\n\t\tdeplibs=\"$deplib $deplibs\"\n\t      fi\n\t      ;;\n\t    esac\n\t    continue\n\t    ;;\n\t  prog)\n\t    if test \"$pass\" != link; then\n\t      deplibs=\"$deplib $deplibs\"\n\t    else\n\t      compile_deplibs=\"$deplib $compile_deplibs\"\n\t      finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t    fi\n\t    continue\n\t    ;;\n\t  esac # linkmode\n\t  ;; # *.$libext\n\t*.lo | *.$objext)\n\t  if test \"$pass\" = conv; then\n\t    deplibs=\"$deplib $deplibs\"\n\t  elif test \"$linkmode\" = prog; then\n\t    if test \"$pass\" = dlpreopen || test \"$dlopen_support\" != yes || test \"$build_libtool_libs\" = no; then\n\t      # If there is no dlopen support or we're linking statically,\n\t      # we need to preload.\n\t      func_append newdlprefiles \" $deplib\"\n\t      compile_deplibs=\"$deplib $compile_deplibs\"\n\t      finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t    else\n\t      func_append newdlfiles \" $deplib\"\n\t    fi\n\t  fi\n\t  continue\n\t  ;;\n\t%DEPLIBS%)\n\t  alldeplibs=yes\n\t  continue\n\t  ;;\n\tesac # case $deplib\n\n\tif test \"$found\" = yes || test -f \"$lib\"; then :\n\telse\n\t  func_fatal_error \"cannot find the library \\`$lib' or unhandled argument \\`$deplib'\"\n\tfi\n\n\t# Check to see that this really is a libtool archive.\n\tfunc_lalib_unsafe_p \"$lib\" \\\n\t  || func_fatal_error \"\\`$lib' is not a valid libtool archive\"\n\n\tfunc_dirname \"$lib\" \"\" \".\"\n\tladir=\"$func_dirname_result\"\n\n\tdlname=\n\tdlopen=\n\tdlpreopen=\n\tlibdir=\n\tlibrary_names=\n\told_library=\n\tinherited_linker_flags=\n\t# If the library was installed with an old release of libtool,\n\t# it will not redefine variables installed, or shouldnotlink\n\tinstalled=yes\n\tshouldnotlink=no\n\tavoidtemprpath=\n\n\n\t# Read the .la file\n\tfunc_source \"$lib\"\n\n\t# Convert \"-framework foo\" to \"foo.ltframework\"\n\tif test -n \"$inherited_linker_flags\"; then\n\t  tmp_inherited_linker_flags=`$ECHO \"$inherited_linker_flags\" | $SED 's/-framework \\([^ $]*\\)/\\1.ltframework/g'`\n\t  for tmp_inherited_linker_flag in $tmp_inherited_linker_flags; do\n\t    case \" $new_inherited_linker_flags \" in\n\t      *\" $tmp_inherited_linker_flag \"*) ;;\n\t      *) func_append new_inherited_linker_flags \" $tmp_inherited_linker_flag\";;\n\t    esac\n\t  done\n\tfi\n\tdependency_libs=`$ECHO \" $dependency_libs\" | $SED 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\tif test \"$linkmode,$pass\" = \"lib,link\" ||\n\t   test \"$linkmode,$pass\" = \"prog,scan\" ||\n\t   { test \"$linkmode\" != prog && test \"$linkmode\" != lib; }; then\n\t  test -n \"$dlopen\" && func_append dlfiles \" $dlopen\"\n\t  test -n \"$dlpreopen\" && func_append dlprefiles \" $dlpreopen\"\n\tfi\n\n\tif test \"$pass\" = conv; then\n\t  # Only check for convenience libraries\n\t  deplibs=\"$lib $deplibs\"\n\t  if test -z \"$libdir\"; then\n\t    if test -z \"$old_library\"; then\n\t      func_fatal_error \"cannot find name of link library for \\`$lib'\"\n\t    fi\n\t    # It is a libtool convenience library, so add in its objects.\n\t    func_append convenience \" $ladir/$objdir/$old_library\"\n\t    func_append old_convenience \" $ladir/$objdir/$old_library\"\n\t    tmp_libs=\n\t    for deplib in $dependency_libs; do\n\t      deplibs=\"$deplib $deplibs\"\n\t      if $opt_preserve_dup_deps ; then\n\t\tcase \"$tmp_libs \" in\n\t\t*\" $deplib \"*) func_append specialdeplibs \" $deplib\" ;;\n\t\tesac\n\t      fi\n\t      func_append tmp_libs \" $deplib\"\n\t    done\n\t  elif test \"$linkmode\" != prog && test \"$linkmode\" != lib; then\n\t    func_fatal_error \"\\`$lib' is not a convenience library\"\n\t  fi\n\t  continue\n\tfi # $pass = conv\n\n\n\t# Get the name of the library we link against.\n\tlinklib=\n\tif test -n \"$old_library\" &&\n\t   { test \"$prefer_static_libs\" = yes ||\n\t     test \"$prefer_static_libs,$installed\" = \"built,no\"; }; then\n\t  linklib=$old_library\n\telse\n\t  for l in $old_library $library_names; do\n\t    linklib=\"$l\"\n\t  done\n\tfi\n\tif test -z \"$linklib\"; then\n\t  func_fatal_error \"cannot find name of link library for \\`$lib'\"\n\tfi\n\n\t# This library was specified with -dlopen.\n\tif test \"$pass\" = dlopen; then\n\t  if test -z \"$libdir\"; then\n\t    func_fatal_error \"cannot -dlopen a convenience library: \\`$lib'\"\n\t  fi\n\t  if test -z \"$dlname\" ||\n\t     test \"$dlopen_support\" != yes ||\n\t     test \"$build_libtool_libs\" = no; then\n\t    # If there is no dlname, no dlopen support or we're linking\n\t    # statically, we need to preload.  We also need to preload any\n\t    # dependent libraries so libltdl's deplib preloader doesn't\n\t    # bomb out in the load deplibs phase.\n\t    func_append dlprefiles \" $lib $dependency_libs\"\n\t  else\n\t    func_append newdlfiles \" $lib\"\n\t  fi\n\t  continue\n\tfi # $pass = dlopen\n\n\t# We need an absolute path.\n\tcase $ladir in\n\t[\\\\/]* | [A-Za-z]:[\\\\/]*) abs_ladir=\"$ladir\" ;;\n\t*)\n\t  abs_ladir=`cd \"$ladir\" && pwd`\n\t  if test -z \"$abs_ladir\"; then\n\t    func_warning \"cannot determine absolute directory name of \\`$ladir'\"\n\t    func_warning \"passing it literally to the linker, although it might fail\"\n\t    abs_ladir=\"$ladir\"\n\t  fi\n\t  ;;\n\tesac\n\tfunc_basename \"$lib\"\n\tlaname=\"$func_basename_result\"\n\n\t# Find the relevant object directory and library name.\n\tif test \"X$installed\" = Xyes; then\n\t  if test ! -f \"$lt_sysroot$libdir/$linklib\" && test -f \"$abs_ladir/$linklib\"; then\n\t    func_warning \"library \\`$lib' was moved.\"\n\t    dir=\"$ladir\"\n\t    absdir=\"$abs_ladir\"\n\t    libdir=\"$abs_ladir\"\n\t  else\n\t    dir=\"$lt_sysroot$libdir\"\n\t    absdir=\"$lt_sysroot$libdir\"\n\t  fi\n\t  test \"X$hardcode_automatic\" = Xyes && avoidtemprpath=yes\n\telse\n\t  if test ! -f \"$ladir/$objdir/$linklib\" && test -f \"$abs_ladir/$linklib\"; then\n\t    dir=\"$ladir\"\n\t    absdir=\"$abs_ladir\"\n\t    # Remove this search path later\n\t    func_append notinst_path \" $abs_ladir\"\n\t  else\n\t    dir=\"$ladir/$objdir\"\n\t    absdir=\"$abs_ladir/$objdir\"\n\t    # Remove this search path later\n\t    func_append notinst_path \" $abs_ladir\"\n\t  fi\n\tfi # $installed = yes\n\tfunc_stripname 'lib' '.la' \"$laname\"\n\tname=$func_stripname_result\n\n\t# This library was specified with -dlpreopen.\n\tif test \"$pass\" = dlpreopen; then\n\t  if test -z \"$libdir\" && test \"$linkmode\" = prog; then\n\t    func_fatal_error \"only libraries may -dlpreopen a convenience library: \\`$lib'\"\n\t  fi\n\t  case \"$host\" in\n\t    # special handling for platforms with PE-DLLs.\n\t    *cygwin* | *mingw* | *cegcc* )\n\t      # Linker will automatically link against shared library if both\n\t      # static and shared are present.  Therefore, ensure we extract\n\t      # symbols from the import library if a shared library is present\n\t      # (otherwise, the dlopen module name will be incorrect).  We do\n\t      # this by putting the import library name into $newdlprefiles.\n\t      # We recover the dlopen module name by 'saving' the la file\n\t      # name in a special purpose variable, and (later) extracting the\n\t      # dlname from the la file.\n\t      if test -n \"$dlname\"; then\n\t        func_tr_sh \"$dir/$linklib\"\n\t        eval \"libfile_$func_tr_sh_result=\\$abs_ladir/\\$laname\"\n\t        func_append newdlprefiles \" $dir/$linklib\"\n\t      else\n\t        func_append newdlprefiles \" $dir/$old_library\"\n\t        # Keep a list of preopened convenience libraries to check\n\t        # that they are being used correctly in the link pass.\n\t        test -z \"$libdir\" && \\\n\t          func_append dlpreconveniencelibs \" $dir/$old_library\"\n\t      fi\n\t    ;;\n\t    * )\n\t      # Prefer using a static library (so that no silly _DYNAMIC symbols\n\t      # are required to link).\n\t      if test -n \"$old_library\"; then\n\t        func_append newdlprefiles \" $dir/$old_library\"\n\t        # Keep a list of preopened convenience libraries to check\n\t        # that they are being used correctly in the link pass.\n\t        test -z \"$libdir\" && \\\n\t          func_append dlpreconveniencelibs \" $dir/$old_library\"\n\t      # Otherwise, use the dlname, so that lt_dlopen finds it.\n\t      elif test -n \"$dlname\"; then\n\t        func_append newdlprefiles \" $dir/$dlname\"\n\t      else\n\t        func_append newdlprefiles \" $dir/$linklib\"\n\t      fi\n\t    ;;\n\t  esac\n\tfi # $pass = dlpreopen\n\n\tif test -z \"$libdir\"; then\n\t  # Link the convenience library\n\t  if test \"$linkmode\" = lib; then\n\t    deplibs=\"$dir/$old_library $deplibs\"\n\t  elif test \"$linkmode,$pass\" = \"prog,link\"; then\n\t    compile_deplibs=\"$dir/$old_library $compile_deplibs\"\n\t    finalize_deplibs=\"$dir/$old_library $finalize_deplibs\"\n\t  else\n\t    deplibs=\"$lib $deplibs\" # used for prog,scan pass\n\t  fi\n\t  continue\n\tfi\n\n\n\tif test \"$linkmode\" = prog && test \"$pass\" != link; then\n\t  func_append newlib_search_path \" $ladir\"\n\t  deplibs=\"$lib $deplibs\"\n\n\t  linkalldeplibs=no\n\t  if test \"$link_all_deplibs\" != no || test -z \"$library_names\" ||\n\t     test \"$build_libtool_libs\" = no; then\n\t    linkalldeplibs=yes\n\t  fi\n\n\t  tmp_libs=\n\t  for deplib in $dependency_libs; do\n\t    case $deplib in\n\t    -L*) func_stripname '-L' '' \"$deplib\"\n\t         func_resolve_sysroot \"$func_stripname_result\"\n\t         func_append newlib_search_path \" $func_resolve_sysroot_result\"\n\t\t ;;\n\t    esac\n\t    # Need to link against all dependency_libs?\n\t    if test \"$linkalldeplibs\" = yes; then\n\t      deplibs=\"$deplib $deplibs\"\n\t    else\n\t      # Need to hardcode shared library paths\n\t      # or/and link against static libraries\n\t      newdependency_libs=\"$deplib $newdependency_libs\"\n\t    fi\n\t    if $opt_preserve_dup_deps ; then\n\t      case \"$tmp_libs \" in\n\t      *\" $deplib \"*) func_append specialdeplibs \" $deplib\" ;;\n\t      esac\n\t    fi\n\t    func_append tmp_libs \" $deplib\"\n\t  done # for deplib\n\t  continue\n\tfi # $linkmode = prog...\n\n\tif test \"$linkmode,$pass\" = \"prog,link\"; then\n\t  if test -n \"$library_names\" &&\n\t     { { test \"$prefer_static_libs\" = no ||\n\t         test \"$prefer_static_libs,$installed\" = \"built,yes\"; } ||\n\t       test -z \"$old_library\"; }; then\n\t    # We need to hardcode the library path\n\t    if test -n \"$shlibpath_var\" && test -z \"$avoidtemprpath\" ; then\n\t      # Make sure the rpath contains only unique directories.\n\t      case \"$temp_rpath:\" in\n\t      *\"$absdir:\"*) ;;\n\t      *) func_append temp_rpath \"$absdir:\" ;;\n\t      esac\n\t    fi\n\n\t    # Hardcode the library path.\n\t    # Skip directories that are in the system default run-time\n\t    # search path.\n\t    case \" $sys_lib_dlsearch_path \" in\n\t    *\" $absdir \"*) ;;\n\t    *)\n\t      case \"$compile_rpath \" in\n\t      *\" $absdir \"*) ;;\n\t      *) func_append compile_rpath \" $absdir\" ;;\n\t      esac\n\t      ;;\n\t    esac\n\t    case \" $sys_lib_dlsearch_path \" in\n\t    *\" $libdir \"*) ;;\n\t    *)\n\t      case \"$finalize_rpath \" in\n\t      *\" $libdir \"*) ;;\n\t      *) func_append finalize_rpath \" $libdir\" ;;\n\t      esac\n\t      ;;\n\t    esac\n\t  fi # $linkmode,$pass = prog,link...\n\n\t  if test \"$alldeplibs\" = yes &&\n\t     { test \"$deplibs_check_method\" = pass_all ||\n\t       { test \"$build_libtool_libs\" = yes &&\n\t\t test -n \"$library_names\"; }; }; then\n\t    # We only need to search for static libraries\n\t    continue\n\t  fi\n\tfi\n\n\tlink_static=no # Whether the deplib will be linked statically\n\tuse_static_libs=$prefer_static_libs\n\tif test \"$use_static_libs\" = built && test \"$installed\" = yes; then\n\t  use_static_libs=no\n\tfi\n\tif test -n \"$library_names\" &&\n\t   { test \"$use_static_libs\" = no || test -z \"$old_library\"; }; then\n\t  case $host in\n\t  *cygwin* | *mingw* | *cegcc*)\n\t      # No point in relinking DLLs because paths are not encoded\n\t      func_append notinst_deplibs \" $lib\"\n\t      need_relink=no\n\t    ;;\n\t  *)\n\t    if test \"$installed\" = no; then\n\t      func_append notinst_deplibs \" $lib\"\n\t      need_relink=yes\n\t    fi\n\t    ;;\n\t  esac\n\t  # This is a shared library\n\n\t  # Warn about portability, can't link against -module's on some\n\t  # systems (darwin).  Don't bleat about dlopened modules though!\n\t  dlopenmodule=\"\"\n\t  for dlpremoduletest in $dlprefiles; do\n\t    if test \"X$dlpremoduletest\" = \"X$lib\"; then\n\t      dlopenmodule=\"$dlpremoduletest\"\n\t      break\n\t    fi\n\t  done\n\t  if test -z \"$dlopenmodule\" && test \"$shouldnotlink\" = yes && test \"$pass\" = link; then\n\t    echo\n\t    if test \"$linkmode\" = prog; then\n\t      $ECHO \"*** Warning: Linking the executable $output against the loadable module\"\n\t    else\n\t      $ECHO \"*** Warning: Linking the shared library $output against the loadable module\"\n\t    fi\n\t    $ECHO \"*** $linklib is not portable!\"\n\t  fi\n\t  if test \"$linkmode\" = lib &&\n\t     test \"$hardcode_into_libs\" = yes; then\n\t    # Hardcode the library path.\n\t    # Skip directories that are in the system default run-time\n\t    # search path.\n\t    case \" $sys_lib_dlsearch_path \" in\n\t    *\" $absdir \"*) ;;\n\t    *)\n\t      case \"$compile_rpath \" in\n\t      *\" $absdir \"*) ;;\n\t      *) func_append compile_rpath \" $absdir\" ;;\n\t      esac\n\t      ;;\n\t    esac\n\t    case \" $sys_lib_dlsearch_path \" in\n\t    *\" $libdir \"*) ;;\n\t    *)\n\t      case \"$finalize_rpath \" in\n\t      *\" $libdir \"*) ;;\n\t      *) func_append finalize_rpath \" $libdir\" ;;\n\t      esac\n\t      ;;\n\t    esac\n\t  fi\n\n\t  if test -n \"$old_archive_from_expsyms_cmds\"; then\n\t    # figure out the soname\n\t    set dummy $library_names\n\t    shift\n\t    realname=\"$1\"\n\t    shift\n\t    libname=`eval \"\\\\$ECHO \\\"$libname_spec\\\"\"`\n\t    # use dlname if we got it. it's perfectly good, no?\n\t    if test -n \"$dlname\"; then\n\t      soname=\"$dlname\"\n\t    elif test -n \"$soname_spec\"; then\n\t      # bleh windows\n\t      case $host in\n\t      *cygwin* | mingw* | *cegcc*)\n\t        func_arith $current - $age\n\t\tmajor=$func_arith_result\n\t\tversuffix=\"-$major\"\n\t\t;;\n\t      esac\n\t      eval soname=\\\"$soname_spec\\\"\n\t    else\n\t      soname=\"$realname\"\n\t    fi\n\n\t    # Make a new name for the extract_expsyms_cmds to use\n\t    soroot=\"$soname\"\n\t    func_basename \"$soroot\"\n\t    soname=\"$func_basename_result\"\n\t    func_stripname 'lib' '.dll' \"$soname\"\n\t    newlib=libimp-$func_stripname_result.a\n\n\t    # If the library has no export list, then create one now\n\t    if test -f \"$output_objdir/$soname-def\"; then :\n\t    else\n\t      func_verbose \"extracting exported symbol list from \\`$soname'\"\n\t      func_execute_cmds \"$extract_expsyms_cmds\" 'exit $?'\n\t    fi\n\n\t    # Create $newlib\n\t    if test -f \"$output_objdir/$newlib\"; then :; else\n\t      func_verbose \"generating import library for \\`$soname'\"\n\t      func_execute_cmds \"$old_archive_from_expsyms_cmds\" 'exit $?'\n\t    fi\n\t    # make sure the library variables are pointing to the new library\n\t    dir=$output_objdir\n\t    linklib=$newlib\n\t  fi # test -n \"$old_archive_from_expsyms_cmds\"\n\n\t  if test \"$linkmode\" = prog || test \"$opt_mode\" != relink; then\n\t    add_shlibpath=\n\t    add_dir=\n\t    add=\n\t    lib_linked=yes\n\t    case $hardcode_action in\n\t    immediate | unsupported)\n\t      if test \"$hardcode_direct\" = no; then\n\t\tadd=\"$dir/$linklib\"\n\t\tcase $host in\n\t\t  *-*-sco3.2v5.0.[024]*) add_dir=\"-L$dir\" ;;\n\t\t  *-*-sysv4*uw2*) add_dir=\"-L$dir\" ;;\n\t\t  *-*-sysv5OpenUNIX* | *-*-sysv5UnixWare7.[01].[10]* | \\\n\t\t    *-*-unixware7*) add_dir=\"-L$dir\" ;;\n\t\t  *-*-darwin* )\n\t\t    # if the lib is a (non-dlopened) module then we can not\n\t\t    # link against it, someone is ignoring the earlier warnings\n\t\t    if /usr/bin/file -L $add 2> /dev/null |\n\t\t\t $GREP \": [^:]* bundle\" >/dev/null ; then\n\t\t      if test \"X$dlopenmodule\" != \"X$lib\"; then\n\t\t\t$ECHO \"*** Warning: lib $linklib is a module, not a shared library\"\n\t\t\tif test -z \"$old_library\" ; then\n\t\t\t  echo\n\t\t\t  echo \"*** And there doesn't seem to be a static archive available\"\n\t\t\t  echo \"*** The link will probably fail, sorry\"\n\t\t\telse\n\t\t\t  add=\"$dir/$old_library\"\n\t\t\tfi\n\t\t      elif test -n \"$old_library\"; then\n\t\t\tadd=\"$dir/$old_library\"\n\t\t      fi\n\t\t    fi\n\t\tesac\n\t      elif test \"$hardcode_minus_L\" = no; then\n\t\tcase $host in\n\t\t*-*-sunos*) add_shlibpath=\"$dir\" ;;\n\t\tesac\n\t\tadd_dir=\"-L$dir\"\n\t\tadd=\"-l$name\"\n\t      elif test \"$hardcode_shlibpath_var\" = no; then\n\t\tadd_shlibpath=\"$dir\"\n\t\tadd=\"-l$name\"\n\t      else\n\t\tlib_linked=no\n\t      fi\n\t      ;;\n\t    relink)\n\t      if test \"$hardcode_direct\" = yes &&\n\t         test \"$hardcode_direct_absolute\" = no; then\n\t\tadd=\"$dir/$linklib\"\n\t      elif test \"$hardcode_minus_L\" = yes; then\n\t\tadd_dir=\"-L$absdir\"\n\t\t# Try looking first in the location we're being installed to.\n\t\tif test -n \"$inst_prefix_dir\"; then\n\t\t  case $libdir in\n\t\t    [\\\\/]*)\n\t\t      func_append add_dir \" -L$inst_prefix_dir$libdir\"\n\t\t      ;;\n\t\t  esac\n\t\tfi\n\t\tadd=\"-l$name\"\n\t      elif test \"$hardcode_shlibpath_var\" = yes; then\n\t\tadd_shlibpath=\"$dir\"\n\t\tadd=\"-l$name\"\n\t      else\n\t\tlib_linked=no\n\t      fi\n\t      ;;\n\t    *) lib_linked=no ;;\n\t    esac\n\n\t    if test \"$lib_linked\" != yes; then\n\t      func_fatal_configuration \"unsupported hardcode properties\"\n\t    fi\n\n\t    if test -n \"$add_shlibpath\"; then\n\t      case :$compile_shlibpath: in\n\t      *\":$add_shlibpath:\"*) ;;\n\t      *) func_append compile_shlibpath \"$add_shlibpath:\" ;;\n\t      esac\n\t    fi\n\t    if test \"$linkmode\" = prog; then\n\t      test -n \"$add_dir\" && compile_deplibs=\"$add_dir $compile_deplibs\"\n\t      test -n \"$add\" && compile_deplibs=\"$add $compile_deplibs\"\n\t    else\n\t      test -n \"$add_dir\" && deplibs=\"$add_dir $deplibs\"\n\t      test -n \"$add\" && deplibs=\"$add $deplibs\"\n\t      if test \"$hardcode_direct\" != yes &&\n\t\t test \"$hardcode_minus_L\" != yes &&\n\t\t test \"$hardcode_shlibpath_var\" = yes; then\n\t\tcase :$finalize_shlibpath: in\n\t\t*\":$libdir:\"*) ;;\n\t\t*) func_append finalize_shlibpath \"$libdir:\" ;;\n\t\tesac\n\t      fi\n\t    fi\n\t  fi\n\n\t  if test \"$linkmode\" = prog || test \"$opt_mode\" = relink; then\n\t    add_shlibpath=\n\t    add_dir=\n\t    add=\n\t    # Finalize command for both is simple: just hardcode it.\n\t    if test \"$hardcode_direct\" = yes &&\n\t       test \"$hardcode_direct_absolute\" = no; then\n\t      add=\"$libdir/$linklib\"\n\t    elif test \"$hardcode_minus_L\" = yes; then\n\t      add_dir=\"-L$libdir\"\n\t      add=\"-l$name\"\n\t    elif test \"$hardcode_shlibpath_var\" = yes; then\n\t      case :$finalize_shlibpath: in\n\t      *\":$libdir:\"*) ;;\n\t      *) func_append finalize_shlibpath \"$libdir:\" ;;\n\t      esac\n\t      add=\"-l$name\"\n\t    elif test \"$hardcode_automatic\" = yes; then\n\t      if test -n \"$inst_prefix_dir\" &&\n\t\t test -f \"$inst_prefix_dir$libdir/$linklib\" ; then\n\t\tadd=\"$inst_prefix_dir$libdir/$linklib\"\n\t      else\n\t\tadd=\"$libdir/$linklib\"\n\t      fi\n\t    else\n\t      # We cannot seem to hardcode it, guess we'll fake it.\n\t      add_dir=\"-L$libdir\"\n\t      # Try looking first in the location we're being installed to.\n\t      if test -n \"$inst_prefix_dir\"; then\n\t\tcase $libdir in\n\t\t  [\\\\/]*)\n\t\t    func_append add_dir \" -L$inst_prefix_dir$libdir\"\n\t\t    ;;\n\t\tesac\n\t      fi\n\t      add=\"-l$name\"\n\t    fi\n\n\t    if test \"$linkmode\" = prog; then\n\t      test -n \"$add_dir\" && finalize_deplibs=\"$add_dir $finalize_deplibs\"\n\t      test -n \"$add\" && finalize_deplibs=\"$add $finalize_deplibs\"\n\t    else\n\t      test -n \"$add_dir\" && deplibs=\"$add_dir $deplibs\"\n\t      test -n \"$add\" && deplibs=\"$add $deplibs\"\n\t    fi\n\t  fi\n\telif test \"$linkmode\" = prog; then\n\t  # Here we assume that one of hardcode_direct or hardcode_minus_L\n\t  # is not unsupported.  This is valid on all known static and\n\t  # shared platforms.\n\t  if test \"$hardcode_direct\" != unsupported; then\n\t    test -n \"$old_library\" && linklib=\"$old_library\"\n\t    compile_deplibs=\"$dir/$linklib $compile_deplibs\"\n\t    finalize_deplibs=\"$dir/$linklib $finalize_deplibs\"\n\t  else\n\t    compile_deplibs=\"-l$name -L$dir $compile_deplibs\"\n\t    finalize_deplibs=\"-l$name -L$dir $finalize_deplibs\"\n\t  fi\n\telif test \"$build_libtool_libs\" = yes; then\n\t  # Not a shared library\n\t  if test \"$deplibs_check_method\" != pass_all; then\n\t    # We're trying link a shared library against a static one\n\t    # but the system doesn't support it.\n\n\t    # Just print a warning and add the library to dependency_libs so\n\t    # that the program can be linked against the static library.\n\t    echo\n\t    $ECHO \"*** Warning: This system can not link to static lib archive $lib.\"\n\t    echo \"*** I have the capability to make that library automatically link in when\"\n\t    echo \"*** you link to this library.  But I can only do this if you have a\"\n\t    echo \"*** shared version of the library, which you do not appear to have.\"\n\t    if test \"$module\" = yes; then\n\t      echo \"*** But as you try to build a module library, libtool will still create \"\n\t      echo \"*** a static module, that should work as long as the dlopening application\"\n\t      echo \"*** is linked with the -dlopen flag to resolve symbols at runtime.\"\n\t      if test -z \"$global_symbol_pipe\"; then\n\t\techo\n\t\techo \"*** However, this would only work if libtool was able to extract symbol\"\n\t\techo \"*** lists from a program, using \\`nm' or equivalent, but libtool could\"\n\t\techo \"*** not find such a program.  So, this module is probably useless.\"\n\t\techo \"*** \\`nm' from GNU binutils and a full rebuild may help.\"\n\t      fi\n\t      if test \"$build_old_libs\" = no; then\n\t\tbuild_libtool_libs=module\n\t\tbuild_old_libs=yes\n\t      else\n\t\tbuild_libtool_libs=no\n\t      fi\n\t    fi\n\t  else\n\t    deplibs=\"$dir/$old_library $deplibs\"\n\t    link_static=yes\n\t  fi\n\tfi # link shared/static library?\n\n\tif test \"$linkmode\" = lib; then\n\t  if test -n \"$dependency_libs\" &&\n\t     { test \"$hardcode_into_libs\" != yes ||\n\t       test \"$build_old_libs\" = yes ||\n\t       test \"$link_static\" = yes; }; then\n\t    # Extract -R from dependency_libs\n\t    temp_deplibs=\n\t    for libdir in $dependency_libs; do\n\t      case $libdir in\n\t      -R*) func_stripname '-R' '' \"$libdir\"\n\t           temp_xrpath=$func_stripname_result\n\t\t   case \" $xrpath \" in\n\t\t   *\" $temp_xrpath \"*) ;;\n\t\t   *) func_append xrpath \" $temp_xrpath\";;\n\t\t   esac;;\n\t      *) func_append temp_deplibs \" $libdir\";;\n\t      esac\n\t    done\n\t    dependency_libs=\"$temp_deplibs\"\n\t  fi\n\n\t  func_append newlib_search_path \" $absdir\"\n\t  # Link against this library\n\t  test \"$link_static\" = no && newdependency_libs=\"$abs_ladir/$laname $newdependency_libs\"\n\t  # ... and its dependency_libs\n\t  tmp_libs=\n\t  for deplib in $dependency_libs; do\n\t    newdependency_libs=\"$deplib $newdependency_libs\"\n\t    case $deplib in\n              -L*) func_stripname '-L' '' \"$deplib\"\n                   func_resolve_sysroot \"$func_stripname_result\";;\n              *) func_resolve_sysroot \"$deplib\" ;;\n            esac\n\t    if $opt_preserve_dup_deps ; then\n\t      case \"$tmp_libs \" in\n\t      *\" $func_resolve_sysroot_result \"*)\n                func_append specialdeplibs \" $func_resolve_sysroot_result\" ;;\n\t      esac\n\t    fi\n\t    func_append tmp_libs \" $func_resolve_sysroot_result\"\n\t  done\n\n\t  if test \"$link_all_deplibs\" != no; then\n\t    # Add the search paths of all dependency libraries\n\t    for deplib in $dependency_libs; do\n\t      path=\n\t      case $deplib in\n\t      -L*) path=\"$deplib\" ;;\n\t      *.la)\n\t        func_resolve_sysroot \"$deplib\"\n\t        deplib=$func_resolve_sysroot_result\n\t        func_dirname \"$deplib\" \"\" \".\"\n\t\tdir=$func_dirname_result\n\t\t# We need an absolute path.\n\t\tcase $dir in\n\t\t[\\\\/]* | [A-Za-z]:[\\\\/]*) absdir=\"$dir\" ;;\n\t\t*)\n\t\t  absdir=`cd \"$dir\" && pwd`\n\t\t  if test -z \"$absdir\"; then\n\t\t    func_warning \"cannot determine absolute directory name of \\`$dir'\"\n\t\t    absdir=\"$dir\"\n\t\t  fi\n\t\t  ;;\n\t\tesac\n\t\tif $GREP \"^installed=no\" $deplib > /dev/null; then\n\t\tcase $host in\n\t\t*-*-darwin*)\n\t\t  depdepl=\n\t\t  eval deplibrary_names=`${SED} -n -e 's/^library_names=\\(.*\\)$/\\1/p' $deplib`\n\t\t  if test -n \"$deplibrary_names\" ; then\n\t\t    for tmp in $deplibrary_names ; do\n\t\t      depdepl=$tmp\n\t\t    done\n\t\t    if test -f \"$absdir/$objdir/$depdepl\" ; then\n\t\t      depdepl=\"$absdir/$objdir/$depdepl\"\n\t\t      darwin_install_name=`${OTOOL} -L $depdepl | awk '{if (NR == 2) {print $1;exit}}'`\n                      if test -z \"$darwin_install_name\"; then\n                          darwin_install_name=`${OTOOL64} -L $depdepl  | awk '{if (NR == 2) {print $1;exit}}'`\n                      fi\n\t\t      func_append compiler_flags \" ${wl}-dylib_file ${wl}${darwin_install_name}:${depdepl}\"\n\t\t      func_append linker_flags \" -dylib_file ${darwin_install_name}:${depdepl}\"\n\t\t      path=\n\t\t    fi\n\t\t  fi\n\t\t  ;;\n\t\t*)\n\t\t  path=\"-L$absdir/$objdir\"\n\t\t  ;;\n\t\tesac\n\t\telse\n\t\t  eval libdir=`${SED} -n -e 's/^libdir=\\(.*\\)$/\\1/p' $deplib`\n\t\t  test -z \"$libdir\" && \\\n\t\t    func_fatal_error \"\\`$deplib' is not a valid libtool archive\"\n\t\t  test \"$absdir\" != \"$libdir\" && \\\n\t\t    func_warning \"\\`$deplib' seems to be moved\"\n\n\t\t  path=\"-L$absdir\"\n\t\tfi\n\t\t;;\n\t      esac\n\t      case \" $deplibs \" in\n\t      *\" $path \"*) ;;\n\t      *) deplibs=\"$path $deplibs\" ;;\n\t      esac\n\t    done\n\t  fi # link_all_deplibs != no\n\tfi # linkmode = lib\n      done # for deplib in $libs\n      if test \"$pass\" = link; then\n\tif test \"$linkmode\" = \"prog\"; then\n\t  compile_deplibs=\"$new_inherited_linker_flags $compile_deplibs\"\n\t  finalize_deplibs=\"$new_inherited_linker_flags $finalize_deplibs\"\n\telse\n\t  compiler_flags=\"$compiler_flags \"`$ECHO \" $new_inherited_linker_flags\" | $SED 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\tfi\n      fi\n      dependency_libs=\"$newdependency_libs\"\n      if test \"$pass\" = dlpreopen; then\n\t# Link the dlpreopened libraries before other libraries\n\tfor deplib in $save_deplibs; do\n\t  deplibs=\"$deplib $deplibs\"\n\tdone\n      fi\n      if test \"$pass\" != dlopen; then\n\tif test \"$pass\" != conv; then\n\t  # Make sure lib_search_path contains only unique directories.\n\t  lib_search_path=\n\t  for dir in $newlib_search_path; do\n\t    case \"$lib_search_path \" in\n\t    *\" $dir \"*) ;;\n\t    *) func_append lib_search_path \" $dir\" ;;\n\t    esac\n\t  done\n\t  newlib_search_path=\n\tfi\n\n\tif test \"$linkmode,$pass\" != \"prog,link\"; then\n\t  vars=\"deplibs\"\n\telse\n\t  vars=\"compile_deplibs finalize_deplibs\"\n\tfi\n\tfor var in $vars dependency_libs; do\n\t  # Add libraries to $var in reverse order\n\t  eval tmp_libs=\\\"\\$$var\\\"\n\t  new_libs=\n\t  for deplib in $tmp_libs; do\n\t    # FIXME: Pedantically, this is the right thing to do, so\n\t    #        that some nasty dependency loop isn't accidentally\n\t    #        broken:\n\t    #new_libs=\"$deplib $new_libs\"\n\t    # Pragmatically, this seems to cause very few problems in\n\t    # practice:\n\t    case $deplib in\n\t    -L*) new_libs=\"$deplib $new_libs\" ;;\n\t    -R*) ;;\n\t    *)\n\t      # And here is the reason: when a library appears more\n\t      # than once as an explicit dependence of a library, or\n\t      # is implicitly linked in more than once by the\n\t      # compiler, it is considered special, and multiple\n\t      # occurrences thereof are not removed.  Compare this\n\t      # with having the same library being listed as a\n\t      # dependency of multiple other libraries: in this case,\n\t      # we know (pedantically, we assume) the library does not\n\t      # need to be listed more than once, so we keep only the\n\t      # last copy.  This is not always right, but it is rare\n\t      # enough that we require users that really mean to play\n\t      # such unportable linking tricks to link the library\n\t      # using -Wl,-lname, so that libtool does not consider it\n\t      # for duplicate removal.\n\t      case \" $specialdeplibs \" in\n\t      *\" $deplib \"*) new_libs=\"$deplib $new_libs\" ;;\n\t      *)\n\t\tcase \" $new_libs \" in\n\t\t*\" $deplib \"*) ;;\n\t\t*) new_libs=\"$deplib $new_libs\" ;;\n\t\tesac\n\t\t;;\n\t      esac\n\t      ;;\n\t    esac\n\t  done\n\t  tmp_libs=\n\t  for deplib in $new_libs; do\n\t    case $deplib in\n\t    -L*)\n\t      case \" $tmp_libs \" in\n\t      *\" $deplib \"*) ;;\n\t      *) func_append tmp_libs \" $deplib\" ;;\n\t      esac\n\t      ;;\n\t    *) func_append tmp_libs \" $deplib\" ;;\n\t    esac\n\t  done\n\t  eval $var=\\\"$tmp_libs\\\"\n\tdone # for var\n      fi\n      # Last step: remove runtime libs from dependency_libs\n      # (they stay in deplibs)\n      tmp_libs=\n      for i in $dependency_libs ; do\n\tcase \" $predeps $postdeps $compiler_lib_search_path \" in\n\t*\" $i \"*)\n\t  i=\"\"\n\t  ;;\n\tesac\n\tif test -n \"$i\" ; then\n\t  func_append tmp_libs \" $i\"\n\tfi\n      done\n      dependency_libs=$tmp_libs\n    done # for pass\n    if test \"$linkmode\" = prog; then\n      dlfiles=\"$newdlfiles\"\n    fi\n    if test \"$linkmode\" = prog || test \"$linkmode\" = lib; then\n      dlprefiles=\"$newdlprefiles\"\n    fi\n\n    case $linkmode in\n    oldlib)\n      if test -n \"$dlfiles$dlprefiles\" || test \"$dlself\" != no; then\n\tfunc_warning \"\\`-dlopen' is ignored for archives\"\n      fi\n\n      case \" $deplibs\" in\n      *\\ -l* | *\\ -L*)\n\tfunc_warning \"\\`-l' and \\`-L' are ignored for archives\" ;;\n      esac\n\n      test -n \"$rpath\" && \\\n\tfunc_warning \"\\`-rpath' is ignored for archives\"\n\n      test -n \"$xrpath\" && \\\n\tfunc_warning \"\\`-R' is ignored for archives\"\n\n      test -n \"$vinfo\" && \\\n\tfunc_warning \"\\`-version-info/-version-number' is ignored for archives\"\n\n      test -n \"$release\" && \\\n\tfunc_warning \"\\`-release' is ignored for archives\"\n\n      test -n \"$export_symbols$export_symbols_regex\" && \\\n\tfunc_warning \"\\`-export-symbols' is ignored for archives\"\n\n      # Now set the variables for building old libraries.\n      build_libtool_libs=no\n      oldlibs=\"$output\"\n      func_append objs \"$old_deplibs\"\n      ;;\n\n    lib)\n      # Make sure we only generate libraries of the form `libNAME.la'.\n      case $outputname in\n      lib*)\n\tfunc_stripname 'lib' '.la' \"$outputname\"\n\tname=$func_stripname_result\n\teval shared_ext=\\\"$shrext_cmds\\\"\n\teval libname=\\\"$libname_spec\\\"\n\t;;\n      *)\n\ttest \"$module\" = no && \\\n\t  func_fatal_help \"libtool library \\`$output' must begin with \\`lib'\"\n\n\tif test \"$need_lib_prefix\" != no; then\n\t  # Add the \"lib\" prefix for modules if required\n\t  func_stripname '' '.la' \"$outputname\"\n\t  name=$func_stripname_result\n\t  eval shared_ext=\\\"$shrext_cmds\\\"\n\t  eval libname=\\\"$libname_spec\\\"\n\telse\n\t  func_stripname '' '.la' \"$outputname\"\n\t  libname=$func_stripname_result\n\tfi\n\t;;\n      esac\n\n      if test -n \"$objs\"; then\n\tif test \"$deplibs_check_method\" != pass_all; then\n\t  func_fatal_error \"cannot build libtool library \\`$output' from non-libtool objects on this host:$objs\"\n\telse\n\t  echo\n\t  $ECHO \"*** Warning: Linking the shared library $output against the non-libtool\"\n\t  $ECHO \"*** objects $objs is not portable!\"\n\t  func_append libobjs \" $objs\"\n\tfi\n      fi\n\n      test \"$dlself\" != no && \\\n\tfunc_warning \"\\`-dlopen self' is ignored for libtool libraries\"\n\n      set dummy $rpath\n      shift\n      test \"$#\" -gt 1 && \\\n\tfunc_warning \"ignoring multiple \\`-rpath's for a libtool library\"\n\n      install_libdir=\"$1\"\n\n      oldlibs=\n      if test -z \"$rpath\"; then\n\tif test \"$build_libtool_libs\" = yes; then\n\t  # Building a libtool convenience library.\n\t  # Some compilers have problems with a `.al' extension so\n\t  # convenience libraries should have the same extension an\n\t  # archive normally would.\n\t  oldlibs=\"$output_objdir/$libname.$libext $oldlibs\"\n\t  build_libtool_libs=convenience\n\t  build_old_libs=yes\n\tfi\n\n\ttest -n \"$vinfo\" && \\\n\t  func_warning \"\\`-version-info/-version-number' is ignored for convenience libraries\"\n\n\ttest -n \"$release\" && \\\n\t  func_warning \"\\`-release' is ignored for convenience libraries\"\n      else\n\n\t# Parse the version information argument.\n\tsave_ifs=\"$IFS\"; IFS=':'\n\tset dummy $vinfo 0 0 0\n\tshift\n\tIFS=\"$save_ifs\"\n\n\ttest -n \"$7\" && \\\n\t  func_fatal_help \"too many parameters to \\`-version-info'\"\n\n\t# convert absolute version numbers to libtool ages\n\t# this retains compatibility with .la files and attempts\n\t# to make the code below a bit more comprehensible\n\n\tcase $vinfo_number in\n\tyes)\n\t  number_major=\"$1\"\n\t  number_minor=\"$2\"\n\t  number_revision=\"$3\"\n\t  #\n\t  # There are really only two kinds -- those that\n\t  # use the current revision as the major version\n\t  # and those that subtract age and use age as\n\t  # a minor version.  But, then there is irix\n\t  # which has an extra 1 added just for fun\n\t  #\n\t  case $version_type in\n\t  # correct linux to gnu/linux during the next big refactor\n\t  darwin|linux|osf|windows|none)\n\t    func_arith $number_major + $number_minor\n\t    current=$func_arith_result\n\t    age=\"$number_minor\"\n\t    revision=\"$number_revision\"\n\t    ;;\n\t  freebsd-aout|freebsd-elf|qnx|sunos)\n\t    current=\"$number_major\"\n\t    revision=\"$number_minor\"\n\t    age=\"0\"\n\t    ;;\n\t  irix|nonstopux)\n\t    func_arith $number_major + $number_minor\n\t    current=$func_arith_result\n\t    age=\"$number_minor\"\n\t    revision=\"$number_minor\"\n\t    lt_irix_increment=no\n\t    ;;\n\t  *)\n\t    func_fatal_configuration \"$modename: unknown library version type \\`$version_type'\"\n\t    ;;\n\t  esac\n\t  ;;\n\tno)\n\t  current=\"$1\"\n\t  revision=\"$2\"\n\t  age=\"$3\"\n\t  ;;\n\tesac\n\n\t# Check that each of the things are valid numbers.\n\tcase $current in\n\t0|[1-9]|[1-9][0-9]|[1-9][0-9][0-9]|[1-9][0-9][0-9][0-9]|[1-9][0-9][0-9][0-9][0-9]) ;;\n\t*)\n\t  func_error \"CURRENT \\`$current' must be a nonnegative integer\"\n\t  func_fatal_error \"\\`$vinfo' is not valid version information\"\n\t  ;;\n\tesac\n\n\tcase $revision in\n\t0|[1-9]|[1-9][0-9]|[1-9][0-9][0-9]|[1-9][0-9][0-9][0-9]|[1-9][0-9][0-9][0-9][0-9]) ;;\n\t*)\n\t  func_error \"REVISION \\`$revision' must be a nonnegative integer\"\n\t  func_fatal_error \"\\`$vinfo' is not valid version information\"\n\t  ;;\n\tesac\n\n\tcase $age in\n\t0|[1-9]|[1-9][0-9]|[1-9][0-9][0-9]|[1-9][0-9][0-9][0-9]|[1-9][0-9][0-9][0-9][0-9]) ;;\n\t*)\n\t  func_error \"AGE \\`$age' must be a nonnegative integer\"\n\t  func_fatal_error \"\\`$vinfo' is not valid version information\"\n\t  ;;\n\tesac\n\n\tif test \"$age\" -gt \"$current\"; then\n\t  func_error \"AGE \\`$age' is greater than the current interface number \\`$current'\"\n\t  func_fatal_error \"\\`$vinfo' is not valid version information\"\n\tfi\n\n\t# Calculate the version variables.\n\tmajor=\n\tversuffix=\n\tverstring=\n\tcase $version_type in\n\tnone) ;;\n\n\tdarwin)\n\t  # Like Linux, but with the current version available in\n\t  # verstring for coding it into the library header\n\t  func_arith $current - $age\n\t  major=.$func_arith_result\n\t  versuffix=\"$major.$age.$revision\"\n\t  # Darwin ld doesn't like 0 for these options...\n\t  func_arith $current + 1\n\t  minor_current=$func_arith_result\n\t  xlcverstring=\"${wl}-compatibility_version ${wl}$minor_current ${wl}-current_version ${wl}$minor_current.$revision\"\n\t  verstring=\"-compatibility_version $minor_current -current_version $minor_current.$revision\"\n\t  ;;\n\n\tfreebsd-aout)\n\t  major=\".$current\"\n\t  versuffix=\".$current.$revision\";\n\t  ;;\n\n\tfreebsd-elf)\n\t  major=\".$current\"\n\t  versuffix=\".$current\"\n\t  ;;\n\n\tirix | nonstopux)\n\t  if test \"X$lt_irix_increment\" = \"Xno\"; then\n\t    func_arith $current - $age\n\t  else\n\t    func_arith $current - $age + 1\n\t  fi\n\t  major=$func_arith_result\n\n\t  case $version_type in\n\t    nonstopux) verstring_prefix=nonstopux ;;\n\t    *)         verstring_prefix=sgi ;;\n\t  esac\n\t  verstring=\"$verstring_prefix$major.$revision\"\n\n\t  # Add in all the interfaces that we are compatible with.\n\t  loop=$revision\n\t  while test \"$loop\" -ne 0; do\n\t    func_arith $revision - $loop\n\t    iface=$func_arith_result\n\t    func_arith $loop - 1\n\t    loop=$func_arith_result\n\t    verstring=\"$verstring_prefix$major.$iface:$verstring\"\n\t  done\n\n\t  # Before this point, $major must not contain `.'.\n\t  major=.$major\n\t  versuffix=\"$major.$revision\"\n\t  ;;\n\n\tlinux) # correct to gnu/linux during the next big refactor\n\t  func_arith $current - $age\n\t  major=.$func_arith_result\n\t  versuffix=\"$major.$age.$revision\"\n\t  ;;\n\n\tosf)\n\t  func_arith $current - $age\n\t  major=.$func_arith_result\n\t  versuffix=\".$current.$age.$revision\"\n\t  verstring=\"$current.$age.$revision\"\n\n\t  # Add in all the interfaces that we are compatible with.\n\t  loop=$age\n\t  while test \"$loop\" -ne 0; do\n\t    func_arith $current - $loop\n\t    iface=$func_arith_result\n\t    func_arith $loop - 1\n\t    loop=$func_arith_result\n\t    verstring=\"$verstring:${iface}.0\"\n\t  done\n\n\t  # Make executables depend on our current version.\n\t  func_append verstring \":${current}.0\"\n\t  ;;\n\n\tqnx)\n\t  major=\".$current\"\n\t  versuffix=\".$current\"\n\t  ;;\n\n\tsunos)\n\t  major=\".$current\"\n\t  versuffix=\".$current.$revision\"\n\t  ;;\n\n\twindows)\n\t  # Use '-' rather than '.', since we only want one\n\t  # extension on DOS 8.3 filesystems.\n\t  func_arith $current - $age\n\t  major=$func_arith_result\n\t  versuffix=\"-$major\"\n\t  ;;\n\n\t*)\n\t  func_fatal_configuration \"unknown library version type \\`$version_type'\"\n\t  ;;\n\tesac\n\n\t# Clear the version info if we defaulted, and they specified a release.\n\tif test -z \"$vinfo\" && test -n \"$release\"; then\n\t  major=\n\t  case $version_type in\n\t  darwin)\n\t    # we can't check for \"0.0\" in archive_cmds due to quoting\n\t    # problems, so we reset it completely\n\t    verstring=\n\t    ;;\n\t  *)\n\t    verstring=\"0.0\"\n\t    ;;\n\t  esac\n\t  if test \"$need_version\" = no; then\n\t    versuffix=\n\t  else\n\t    versuffix=\".0.0\"\n\t  fi\n\tfi\n\n\t# Remove version info from name if versioning should be avoided\n\tif test \"$avoid_version\" = yes && test \"$need_version\" = no; then\n\t  major=\n\t  versuffix=\n\t  verstring=\"\"\n\tfi\n\n\t# Check to see if the archive will have undefined symbols.\n\tif test \"$allow_undefined\" = yes; then\n\t  if test \"$allow_undefined_flag\" = unsupported; then\n\t    func_warning \"undefined symbols not allowed in $host shared libraries\"\n\t    build_libtool_libs=no\n\t    build_old_libs=yes\n\t  fi\n\telse\n\t  # Don't allow undefined symbols.\n\t  allow_undefined_flag=\"$no_undefined_flag\"\n\tfi\n\n      fi\n\n      func_generate_dlsyms \"$libname\" \"$libname\" \"yes\"\n      func_append libobjs \" $symfileobj\"\n      test \"X$libobjs\" = \"X \" && libobjs=\n\n      if test \"$opt_mode\" != relink; then\n\t# Remove our outputs, but don't remove object files since they\n\t# may have been created when compiling PIC objects.\n\tremovelist=\n\ttempremovelist=`$ECHO \"$output_objdir/*\"`\n\tfor p in $tempremovelist; do\n\t  case $p in\n\t    *.$objext | *.gcno)\n\t       ;;\n\t    $output_objdir/$outputname | $output_objdir/$libname.* | $output_objdir/${libname}${release}.*)\n\t       if test \"X$precious_files_regex\" != \"X\"; then\n\t\t if $ECHO \"$p\" | $EGREP -e \"$precious_files_regex\" >/dev/null 2>&1\n\t\t then\n\t\t   continue\n\t\t fi\n\t       fi\n\t       func_append removelist \" $p\"\n\t       ;;\n\t    *) ;;\n\t  esac\n\tdone\n\ttest -n \"$removelist\" && \\\n\t  func_show_eval \"${RM}r \\$removelist\"\n      fi\n\n      # Now set the variables for building old libraries.\n      if test \"$build_old_libs\" = yes && test \"$build_libtool_libs\" != convenience ; then\n\tfunc_append oldlibs \" $output_objdir/$libname.$libext\"\n\n\t# Transform .lo files to .o files.\n\toldobjs=\"$objs \"`$ECHO \"$libobjs\" | $SP2NL | $SED \"/\\.${libext}$/d; $lo2o\" | $NL2SP`\n      fi\n\n      # Eliminate all temporary directories.\n      #for path in $notinst_path; do\n      #\tlib_search_path=`$ECHO \"$lib_search_path \" | $SED \"s% $path % %g\"`\n      #\tdeplibs=`$ECHO \"$deplibs \" | $SED \"s% -L$path % %g\"`\n      #\tdependency_libs=`$ECHO \"$dependency_libs \" | $SED \"s% -L$path % %g\"`\n      #done\n\n      if test -n \"$xrpath\"; then\n\t# If the user specified any rpath flags, then add them.\n\ttemp_xrpath=\n\tfor libdir in $xrpath; do\n\t  func_replace_sysroot \"$libdir\"\n\t  func_append temp_xrpath \" -R$func_replace_sysroot_result\"\n\t  case \"$finalize_rpath \" in\n\t  *\" $libdir \"*) ;;\n\t  *) func_append finalize_rpath \" $libdir\" ;;\n\t  esac\n\tdone\n\tif test \"$hardcode_into_libs\" != yes || test \"$build_old_libs\" = yes; then\n\t  dependency_libs=\"$temp_xrpath $dependency_libs\"\n\tfi\n      fi\n\n      # Make sure dlfiles contains only unique files that won't be dlpreopened\n      old_dlfiles=\"$dlfiles\"\n      dlfiles=\n      for lib in $old_dlfiles; do\n\tcase \" $dlprefiles $dlfiles \" in\n\t*\" $lib \"*) ;;\n\t*) func_append dlfiles \" $lib\" ;;\n\tesac\n      done\n\n      # Make sure dlprefiles contains only unique files\n      old_dlprefiles=\"$dlprefiles\"\n      dlprefiles=\n      for lib in $old_dlprefiles; do\n\tcase \"$dlprefiles \" in\n\t*\" $lib \"*) ;;\n\t*) func_append dlprefiles \" $lib\" ;;\n\tesac\n      done\n\n      if test \"$build_libtool_libs\" = yes; then\n\tif test -n \"$rpath\"; then\n\t  case $host in\n\t  *-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-*-beos* | *-cegcc* | *-*-haiku*)\n\t    # these systems don't actually have a c library (as such)!\n\t    ;;\n\t  *-*-rhapsody* | *-*-darwin1.[012])\n\t    # Rhapsody C library is in the System framework\n\t    func_append deplibs \" System.ltframework\"\n\t    ;;\n\t  *-*-netbsd*)\n\t    # Don't link with libc until the a.out ld.so is fixed.\n\t    ;;\n\t  *-*-openbsd* | *-*-freebsd* | *-*-dragonfly*)\n\t    # Do not include libc due to us having libc/libc_r.\n\t    ;;\n\t  *-*-sco3.2v5* | *-*-sco5v6*)\n\t    # Causes problems with __ctype\n\t    ;;\n\t  *-*-sysv4.2uw2* | *-*-sysv5* | *-*-unixware* | *-*-OpenUNIX*)\n\t    # Compiler inserts libc in the correct place for threads to work\n\t    ;;\n\t  *)\n\t    # Add libc to deplibs on all other systems if necessary.\n\t    if test \"$build_libtool_need_lc\" = \"yes\"; then\n\t      func_append deplibs \" -lc\"\n\t    fi\n\t    ;;\n\t  esac\n\tfi\n\n\t# Transform deplibs into only deplibs that can be linked in shared.\n\tname_save=$name\n\tlibname_save=$libname\n\trelease_save=$release\n\tversuffix_save=$versuffix\n\tmajor_save=$major\n\t# I'm not sure if I'm treating the release correctly.  I think\n\t# release should show up in the -l (ie -lgmp5) so we don't want to\n\t# add it in twice.  Is that correct?\n\trelease=\"\"\n\tversuffix=\"\"\n\tmajor=\"\"\n\tnewdeplibs=\n\tdroppeddeps=no\n\tcase $deplibs_check_method in\n\tpass_all)\n\t  # Don't check for shared/static.  Everything works.\n\t  # This might be a little naive.  We might want to check\n\t  # whether the library exists or not.  But this is on\n\t  # osf3 & osf4 and I'm not really sure... Just\n\t  # implementing what was already the behavior.\n\t  newdeplibs=$deplibs\n\t  ;;\n\ttest_compile)\n\t  # This code stresses the \"libraries are programs\" paradigm to its\n\t  # limits. Maybe even breaks it.  We compile a program, linking it\n\t  # against the deplibs as a proxy for the library.  Then we can check\n\t  # whether they linked in statically or dynamically with ldd.\n\t  $opt_dry_run || $RM conftest.c\n\t  cat > conftest.c <<EOF\n\t  int main() { return 0; }\nEOF\n\t  $opt_dry_run || $RM conftest\n\t  if $LTCC $LTCFLAGS -o conftest conftest.c $deplibs; then\n\t    ldd_output=`ldd conftest`\n\t    for i in $deplibs; do\n\t      case $i in\n\t      -l*)\n\t\tfunc_stripname -l '' \"$i\"\n\t\tname=$func_stripname_result\n\t\tif test \"X$allow_libtool_libs_with_static_runtimes\" = \"Xyes\" ; then\n\t\t  case \" $predeps $postdeps \" in\n\t\t  *\" $i \"*)\n\t\t    func_append newdeplibs \" $i\"\n\t\t    i=\"\"\n\t\t    ;;\n\t\t  esac\n\t\tfi\n\t\tif test -n \"$i\" ; then\n\t\t  libname=`eval \"\\\\$ECHO \\\"$libname_spec\\\"\"`\n\t\t  deplib_matches=`eval \"\\\\$ECHO \\\"$library_names_spec\\\"\"`\n\t\t  set dummy $deplib_matches; shift\n\t\t  deplib_match=$1\n\t\t  if test `expr \"$ldd_output\" : \".*$deplib_match\"` -ne 0 ; then\n\t\t    func_append newdeplibs \" $i\"\n\t\t  else\n\t\t    droppeddeps=yes\n\t\t    echo\n\t\t    $ECHO \"*** Warning: dynamic linker does not accept needed library $i.\"\n\t\t    echo \"*** I have the capability to make that library automatically link in when\"\n\t\t    echo \"*** you link to this library.  But I can only do this if you have a\"\n\t\t    echo \"*** shared version of the library, which I believe you do not have\"\n\t\t    echo \"*** because a test_compile did reveal that the linker did not use it for\"\n\t\t    echo \"*** its dynamic dependency list that programs get resolved with at runtime.\"\n\t\t  fi\n\t\tfi\n\t\t;;\n\t      *)\n\t\tfunc_append newdeplibs \" $i\"\n\t\t;;\n\t      esac\n\t    done\n\t  else\n\t    # Error occurred in the first compile.  Let's try to salvage\n\t    # the situation: Compile a separate program for each library.\n\t    for i in $deplibs; do\n\t      case $i in\n\t      -l*)\n\t\tfunc_stripname -l '' \"$i\"\n\t\tname=$func_stripname_result\n\t\t$opt_dry_run || $RM conftest\n\t\tif $LTCC $LTCFLAGS -o conftest conftest.c $i; then\n\t\t  ldd_output=`ldd conftest`\n\t\t  if test \"X$allow_libtool_libs_with_static_runtimes\" = \"Xyes\" ; then\n\t\t    case \" $predeps $postdeps \" in\n\t\t    *\" $i \"*)\n\t\t      func_append newdeplibs \" $i\"\n\t\t      i=\"\"\n\t\t      ;;\n\t\t    esac\n\t\t  fi\n\t\t  if test -n \"$i\" ; then\n\t\t    libname=`eval \"\\\\$ECHO \\\"$libname_spec\\\"\"`\n\t\t    deplib_matches=`eval \"\\\\$ECHO \\\"$library_names_spec\\\"\"`\n\t\t    set dummy $deplib_matches; shift\n\t\t    deplib_match=$1\n\t\t    if test `expr \"$ldd_output\" : \".*$deplib_match\"` -ne 0 ; then\n\t\t      func_append newdeplibs \" $i\"\n\t\t    else\n\t\t      droppeddeps=yes\n\t\t      echo\n\t\t      $ECHO \"*** Warning: dynamic linker does not accept needed library $i.\"\n\t\t      echo \"*** I have the capability to make that library automatically link in when\"\n\t\t      echo \"*** you link to this library.  But I can only do this if you have a\"\n\t\t      echo \"*** shared version of the library, which you do not appear to have\"\n\t\t      echo \"*** because a test_compile did reveal that the linker did not use this one\"\n\t\t      echo \"*** as a dynamic dependency that programs can get resolved with at runtime.\"\n\t\t    fi\n\t\t  fi\n\t\telse\n\t\t  droppeddeps=yes\n\t\t  echo\n\t\t  $ECHO \"*** Warning!  Library $i is needed by this library but I was not able to\"\n\t\t  echo \"*** make it link in!  You will probably need to install it or some\"\n\t\t  echo \"*** library that it depends on before this library will be fully\"\n\t\t  echo \"*** functional.  Installing it before continuing would be even better.\"\n\t\tfi\n\t\t;;\n\t      *)\n\t\tfunc_append newdeplibs \" $i\"\n\t\t;;\n\t      esac\n\t    done\n\t  fi\n\t  ;;\n\tfile_magic*)\n\t  set dummy $deplibs_check_method; shift\n\t  file_magic_regex=`expr \"$deplibs_check_method\" : \"$1 \\(.*\\)\"`\n\t  for a_deplib in $deplibs; do\n\t    case $a_deplib in\n\t    -l*)\n\t      func_stripname -l '' \"$a_deplib\"\n\t      name=$func_stripname_result\n\t      if test \"X$allow_libtool_libs_with_static_runtimes\" = \"Xyes\" ; then\n\t\tcase \" $predeps $postdeps \" in\n\t\t*\" $a_deplib \"*)\n\t\t  func_append newdeplibs \" $a_deplib\"\n\t\t  a_deplib=\"\"\n\t\t  ;;\n\t\tesac\n\t      fi\n\t      if test -n \"$a_deplib\" ; then\n\t\tlibname=`eval \"\\\\$ECHO \\\"$libname_spec\\\"\"`\n\t\tif test -n \"$file_magic_glob\"; then\n\t\t  libnameglob=`func_echo_all \"$libname\" | $SED -e $file_magic_glob`\n\t\telse\n\t\t  libnameglob=$libname\n\t\tfi\n\t\ttest \"$want_nocaseglob\" = yes && nocaseglob=`shopt -p nocaseglob`\n\t\tfor i in $lib_search_path $sys_lib_search_path $shlib_search_path; do\n\t\t  if test \"$want_nocaseglob\" = yes; then\n\t\t    shopt -s nocaseglob\n\t\t    potential_libs=`ls $i/$libnameglob[.-]* 2>/dev/null`\n\t\t    $nocaseglob\n\t\t  else\n\t\t    potential_libs=`ls $i/$libnameglob[.-]* 2>/dev/null`\n\t\t  fi\n\t\t  for potent_lib in $potential_libs; do\n\t\t      # Follow soft links.\n\t\t      if ls -lLd \"$potent_lib\" 2>/dev/null |\n\t\t\t $GREP \" -> \" >/dev/null; then\n\t\t\tcontinue\n\t\t      fi\n\t\t      # The statement above tries to avoid entering an\n\t\t      # endless loop below, in case of cyclic links.\n\t\t      # We might still enter an endless loop, since a link\n\t\t      # loop can be closed while we follow links,\n\t\t      # but so what?\n\t\t      potlib=\"$potent_lib\"\n\t\t      while test -h \"$potlib\" 2>/dev/null; do\n\t\t\tpotliblink=`ls -ld $potlib | ${SED} 's/.* -> //'`\n\t\t\tcase $potliblink in\n\t\t\t[\\\\/]* | [A-Za-z]:[\\\\/]*) potlib=\"$potliblink\";;\n\t\t\t*) potlib=`$ECHO \"$potlib\" | $SED 's,[^/]*$,,'`\"$potliblink\";;\n\t\t\tesac\n\t\t      done\n\t\t      if eval $file_magic_cmd \\\"\\$potlib\\\" 2>/dev/null |\n\t\t\t $SED -e 10q |\n\t\t\t $EGREP \"$file_magic_regex\" > /dev/null; then\n\t\t\tfunc_append newdeplibs \" $a_deplib\"\n\t\t\ta_deplib=\"\"\n\t\t\tbreak 2\n\t\t      fi\n\t\t  done\n\t\tdone\n\t      fi\n\t      if test -n \"$a_deplib\" ; then\n\t\tdroppeddeps=yes\n\t\techo\n\t\t$ECHO \"*** Warning: linker path does not have real file for library $a_deplib.\"\n\t\techo \"*** I have the capability to make that library automatically link in when\"\n\t\techo \"*** you link to this library.  But I can only do this if you have a\"\n\t\techo \"*** shared version of the library, which you do not appear to have\"\n\t\techo \"*** because I did check the linker path looking for a file starting\"\n\t\tif test -z \"$potlib\" ; then\n\t\t  $ECHO \"*** with $libname but no candidates were found. (...for file magic test)\"\n\t\telse\n\t\t  $ECHO \"*** with $libname and none of the candidates passed a file format test\"\n\t\t  $ECHO \"*** using a file magic. Last file checked: $potlib\"\n\t\tfi\n\t      fi\n\t      ;;\n\t    *)\n\t      # Add a -L argument.\n\t      func_append newdeplibs \" $a_deplib\"\n\t      ;;\n\t    esac\n\t  done # Gone through all deplibs.\n\t  ;;\n\tmatch_pattern*)\n\t  set dummy $deplibs_check_method; shift\n\t  match_pattern_regex=`expr \"$deplibs_check_method\" : \"$1 \\(.*\\)\"`\n\t  for a_deplib in $deplibs; do\n\t    case $a_deplib in\n\t    -l*)\n\t      func_stripname -l '' \"$a_deplib\"\n\t      name=$func_stripname_result\n\t      if test \"X$allow_libtool_libs_with_static_runtimes\" = \"Xyes\" ; then\n\t\tcase \" $predeps $postdeps \" in\n\t\t*\" $a_deplib \"*)\n\t\t  func_append newdeplibs \" $a_deplib\"\n\t\t  a_deplib=\"\"\n\t\t  ;;\n\t\tesac\n\t      fi\n\t      if test -n \"$a_deplib\" ; then\n\t\tlibname=`eval \"\\\\$ECHO \\\"$libname_spec\\\"\"`\n\t\tfor i in $lib_search_path $sys_lib_search_path $shlib_search_path; do\n\t\t  potential_libs=`ls $i/$libname[.-]* 2>/dev/null`\n\t\t  for potent_lib in $potential_libs; do\n\t\t    potlib=\"$potent_lib\" # see symlink-check above in file_magic test\n\t\t    if eval \"\\$ECHO \\\"$potent_lib\\\"\" 2>/dev/null | $SED 10q | \\\n\t\t       $EGREP \"$match_pattern_regex\" > /dev/null; then\n\t\t      func_append newdeplibs \" $a_deplib\"\n\t\t      a_deplib=\"\"\n\t\t      break 2\n\t\t    fi\n\t\t  done\n\t\tdone\n\t      fi\n\t      if test -n \"$a_deplib\" ; then\n\t\tdroppeddeps=yes\n\t\techo\n\t\t$ECHO \"*** Warning: linker path does not have real file for library $a_deplib.\"\n\t\techo \"*** I have the capability to make that library automatically link in when\"\n\t\techo \"*** you link to this library.  But I can only do this if you have a\"\n\t\techo \"*** shared version of the library, which you do not appear to have\"\n\t\techo \"*** because I did check the linker path looking for a file starting\"\n\t\tif test -z \"$potlib\" ; then\n\t\t  $ECHO \"*** with $libname but no candidates were found. (...for regex pattern test)\"\n\t\telse\n\t\t  $ECHO \"*** with $libname and none of the candidates passed a file format test\"\n\t\t  $ECHO \"*** using a regex pattern. Last file checked: $potlib\"\n\t\tfi\n\t      fi\n\t      ;;\n\t    *)\n\t      # Add a -L argument.\n\t      func_append newdeplibs \" $a_deplib\"\n\t      ;;\n\t    esac\n\t  done # Gone through all deplibs.\n\t  ;;\n\tnone | unknown | *)\n\t  newdeplibs=\"\"\n\t  tmp_deplibs=`$ECHO \" $deplibs\" | $SED 's/ -lc$//; s/ -[LR][^ ]*//g'`\n\t  if test \"X$allow_libtool_libs_with_static_runtimes\" = \"Xyes\" ; then\n\t    for i in $predeps $postdeps ; do\n\t      # can't use Xsed below, because $i might contain '/'\n\t      tmp_deplibs=`$ECHO \" $tmp_deplibs\" | $SED \"s,$i,,\"`\n\t    done\n\t  fi\n\t  case $tmp_deplibs in\n\t  *[!\\\t\\ ]*)\n\t    echo\n\t    if test \"X$deplibs_check_method\" = \"Xnone\"; then\n\t      echo \"*** Warning: inter-library dependencies are not supported in this platform.\"\n\t    else\n\t      echo \"*** Warning: inter-library dependencies are not known to be supported.\"\n\t    fi\n\t    echo \"*** All declared inter-library dependencies are being dropped.\"\n\t    droppeddeps=yes\n\t    ;;\n\t  esac\n\t  ;;\n\tesac\n\tversuffix=$versuffix_save\n\tmajor=$major_save\n\trelease=$release_save\n\tlibname=$libname_save\n\tname=$name_save\n\n\tcase $host in\n\t*-*-rhapsody* | *-*-darwin1.[012])\n\t  # On Rhapsody replace the C library with the System framework\n\t  newdeplibs=`$ECHO \" $newdeplibs\" | $SED 's/ -lc / System.ltframework /'`\n\t  ;;\n\tesac\n\n\tif test \"$droppeddeps\" = yes; then\n\t  if test \"$module\" = yes; then\n\t    echo\n\t    echo \"*** Warning: libtool could not satisfy all declared inter-library\"\n\t    $ECHO \"*** dependencies of module $libname.  Therefore, libtool will create\"\n\t    echo \"*** a static module, that should work as long as the dlopening\"\n\t    echo \"*** application is linked with the -dlopen flag.\"\n\t    if test -z \"$global_symbol_pipe\"; then\n\t      echo\n\t      echo \"*** However, this would only work if libtool was able to extract symbol\"\n\t      echo \"*** lists from a program, using \\`nm' or equivalent, but libtool could\"\n\t      echo \"*** not find such a program.  So, this module is probably useless.\"\n\t      echo \"*** \\`nm' from GNU binutils and a full rebuild may help.\"\n\t    fi\n\t    if test \"$build_old_libs\" = no; then\n\t      oldlibs=\"$output_objdir/$libname.$libext\"\n\t      build_libtool_libs=module\n\t      build_old_libs=yes\n\t    else\n\t      build_libtool_libs=no\n\t    fi\n\t  else\n\t    echo \"*** The inter-library dependencies that have been dropped here will be\"\n\t    echo \"*** automatically added whenever a program is linked with this library\"\n\t    echo \"*** or is declared to -dlopen it.\"\n\n\t    if test \"$allow_undefined\" = no; then\n\t      echo\n\t      echo \"*** Since this library must not contain undefined symbols,\"\n\t      echo \"*** because either the platform does not support them or\"\n\t      echo \"*** it was explicitly requested with -no-undefined,\"\n\t      echo \"*** libtool will only create a static version of it.\"\n\t      if test \"$build_old_libs\" = no; then\n\t\toldlibs=\"$output_objdir/$libname.$libext\"\n\t\tbuild_libtool_libs=module\n\t\tbuild_old_libs=yes\n\t      else\n\t\tbuild_libtool_libs=no\n\t      fi\n\t    fi\n\t  fi\n\tfi\n\t# Done checking deplibs!\n\tdeplibs=$newdeplibs\n      fi\n      # Time to change all our \"foo.ltframework\" stuff back to \"-framework foo\"\n      case $host in\n\t*-*-darwin*)\n\t  newdeplibs=`$ECHO \" $newdeplibs\" | $SED 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\t  new_inherited_linker_flags=`$ECHO \" $new_inherited_linker_flags\" | $SED 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\t  deplibs=`$ECHO \" $deplibs\" | $SED 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\t  ;;\n      esac\n\n      # move library search paths that coincide with paths to not yet\n      # installed libraries to the beginning of the library search list\n      new_libs=\n      for path in $notinst_path; do\n\tcase \" $new_libs \" in\n\t*\" -L$path/$objdir \"*) ;;\n\t*)\n\t  case \" $deplibs \" in\n\t  *\" -L$path/$objdir \"*)\n\t    func_append new_libs \" -L$path/$objdir\" ;;\n\t  esac\n\t  ;;\n\tesac\n      done\n      for deplib in $deplibs; do\n\tcase $deplib in\n\t-L*)\n\t  case \" $new_libs \" in\n\t  *\" $deplib \"*) ;;\n\t  *) func_append new_libs \" $deplib\" ;;\n\t  esac\n\t  ;;\n\t*) func_append new_libs \" $deplib\" ;;\n\tesac\n      done\n      deplibs=\"$new_libs\"\n\n      # All the library-specific variables (install_libdir is set above).\n      library_names=\n      old_library=\n      dlname=\n\n      # Test again, we may have decided not to build it any more\n      if test \"$build_libtool_libs\" = yes; then\n\t# Remove ${wl} instances when linking with ld.\n\t# FIXME: should test the right _cmds variable.\n\tcase $archive_cmds in\n\t  *\\$LD\\ *) wl= ;;\n        esac\n\tif test \"$hardcode_into_libs\" = yes; then\n\t  # Hardcode the library paths\n\t  hardcode_libdirs=\n\t  dep_rpath=\n\t  rpath=\"$finalize_rpath\"\n\t  test \"$opt_mode\" != relink && rpath=\"$compile_rpath$rpath\"\n\t  for libdir in $rpath; do\n\t    if test -n \"$hardcode_libdir_flag_spec\"; then\n\t      if test -n \"$hardcode_libdir_separator\"; then\n\t\tfunc_replace_sysroot \"$libdir\"\n\t\tlibdir=$func_replace_sysroot_result\n\t\tif test -z \"$hardcode_libdirs\"; then\n\t\t  hardcode_libdirs=\"$libdir\"\n\t\telse\n\t\t  # Just accumulate the unique libdirs.\n\t\t  case $hardcode_libdir_separator$hardcode_libdirs$hardcode_libdir_separator in\n\t\t  *\"$hardcode_libdir_separator$libdir$hardcode_libdir_separator\"*)\n\t\t    ;;\n\t\t  *)\n\t\t    func_append hardcode_libdirs \"$hardcode_libdir_separator$libdir\"\n\t\t    ;;\n\t\t  esac\n\t\tfi\n\t      else\n\t\teval flag=\\\"$hardcode_libdir_flag_spec\\\"\n\t\tfunc_append dep_rpath \" $flag\"\n\t      fi\n\t    elif test -n \"$runpath_var\"; then\n\t      case \"$perm_rpath \" in\n\t      *\" $libdir \"*) ;;\n\t      *) func_append perm_rpath \" $libdir\" ;;\n\t      esac\n\t    fi\n\t  done\n\t  # Substitute the hardcoded libdirs into the rpath.\n\t  if test -n \"$hardcode_libdir_separator\" &&\n\t     test -n \"$hardcode_libdirs\"; then\n\t    libdir=\"$hardcode_libdirs\"\n\t    eval \"dep_rpath=\\\"$hardcode_libdir_flag_spec\\\"\"\n\t  fi\n\t  if test -n \"$runpath_var\" && test -n \"$perm_rpath\"; then\n\t    # We should set the runpath_var.\n\t    rpath=\n\t    for dir in $perm_rpath; do\n\t      func_append rpath \"$dir:\"\n\t    done\n\t    eval \"$runpath_var='$rpath\\$$runpath_var'; export $runpath_var\"\n\t  fi\n\t  test -n \"$dep_rpath\" && deplibs=\"$dep_rpath $deplibs\"\n\tfi\n\n\tshlibpath=\"$finalize_shlibpath\"\n\ttest \"$opt_mode\" != relink && shlibpath=\"$compile_shlibpath$shlibpath\"\n\tif test -n \"$shlibpath\"; then\n\t  eval \"$shlibpath_var='$shlibpath\\$$shlibpath_var'; export $shlibpath_var\"\n\tfi\n\n\t# Get the real and link names of the library.\n\teval shared_ext=\\\"$shrext_cmds\\\"\n\teval library_names=\\\"$library_names_spec\\\"\n\tset dummy $library_names\n\tshift\n\trealname=\"$1\"\n\tshift\n\n\tif test -n \"$soname_spec\"; then\n\t  eval soname=\\\"$soname_spec\\\"\n\telse\n\t  soname=\"$realname\"\n\tfi\n\tif test -z \"$dlname\"; then\n\t  dlname=$soname\n\tfi\n\n\tlib=\"$output_objdir/$realname\"\n\tlinknames=\n\tfor link\n\tdo\n\t  func_append linknames \" $link\"\n\tdone\n\n\t# Use standard objects if they are pic\n\ttest -z \"$pic_flag\" && libobjs=`$ECHO \"$libobjs\" | $SP2NL | $SED \"$lo2o\" | $NL2SP`\n\ttest \"X$libobjs\" = \"X \" && libobjs=\n\n\tdelfiles=\n\tif test -n \"$export_symbols\" && test -n \"$include_expsyms\"; then\n\t  $opt_dry_run || cp \"$export_symbols\" \"$output_objdir/$libname.uexp\"\n\t  export_symbols=\"$output_objdir/$libname.uexp\"\n\t  func_append delfiles \" $export_symbols\"\n\tfi\n\n\torig_export_symbols=\n\tcase $host_os in\n\tcygwin* | mingw* | cegcc*)\n\t  if test -n \"$export_symbols\" && test -z \"$export_symbols_regex\"; then\n\t    # exporting using user supplied symfile\n\t    if test \"x`$SED 1q $export_symbols`\" != xEXPORTS; then\n\t      # and it's NOT already a .def file. Must figure out\n\t      # which of the given symbols are data symbols and tag\n\t      # them as such. So, trigger use of export_symbols_cmds.\n\t      # export_symbols gets reassigned inside the \"prepare\n\t      # the list of exported symbols\" if statement, so the\n\t      # include_expsyms logic still works.\n\t      orig_export_symbols=\"$export_symbols\"\n\t      export_symbols=\n\t      always_export_symbols=yes\n\t    fi\n\t  fi\n\t  ;;\n\tesac\n\n\t# Prepare the list of exported symbols\n\tif test -z \"$export_symbols\"; then\n\t  if test \"$always_export_symbols\" = yes || test -n \"$export_symbols_regex\"; then\n\t    func_verbose \"generating symbol list for \\`$libname.la'\"\n\t    export_symbols=\"$output_objdir/$libname.exp\"\n\t    $opt_dry_run || $RM $export_symbols\n\t    cmds=$export_symbols_cmds\n\t    save_ifs=\"$IFS\"; IFS='~'\n\t    for cmd1 in $cmds; do\n\t      IFS=\"$save_ifs\"\n\t      # Take the normal branch if the nm_file_list_spec branch\n\t      # doesn't work or if tool conversion is not needed.\n\t      case $nm_file_list_spec~$to_tool_file_cmd in\n\t\t*~func_convert_file_noop | *~func_convert_file_msys_to_w32 | ~*)\n\t\t  try_normal_branch=yes\n\t\t  eval cmd=\\\"$cmd1\\\"\n\t\t  func_len \" $cmd\"\n\t\t  len=$func_len_result\n\t\t  ;;\n\t\t*)\n\t\t  try_normal_branch=no\n\t\t  ;;\n\t      esac\n\t      if test \"$try_normal_branch\" = yes \\\n\t\t && { test \"$len\" -lt \"$max_cmd_len\" \\\n\t\t      || test \"$max_cmd_len\" -le -1; }\n\t      then\n\t\tfunc_show_eval \"$cmd\" 'exit $?'\n\t\tskipped_export=false\n\t      elif test -n \"$nm_file_list_spec\"; then\n\t\tfunc_basename \"$output\"\n\t\toutput_la=$func_basename_result\n\t\tsave_libobjs=$libobjs\n\t\tsave_output=$output\n\t\toutput=${output_objdir}/${output_la}.nm\n\t\tfunc_to_tool_file \"$output\"\n\t\tlibobjs=$nm_file_list_spec$func_to_tool_file_result\n\t\tfunc_append delfiles \" $output\"\n\t\tfunc_verbose \"creating $NM input file list: $output\"\n\t\tfor obj in $save_libobjs; do\n\t\t  func_to_tool_file \"$obj\"\n\t\t  $ECHO \"$func_to_tool_file_result\"\n\t\tdone > \"$output\"\n\t\teval cmd=\\\"$cmd1\\\"\n\t\tfunc_show_eval \"$cmd\" 'exit $?'\n\t\toutput=$save_output\n\t\tlibobjs=$save_libobjs\n\t\tskipped_export=false\n\t      else\n\t\t# The command line is too long to execute in one step.\n\t\tfunc_verbose \"using reloadable object file for export list...\"\n\t\tskipped_export=:\n\t\t# Break out early, otherwise skipped_export may be\n\t\t# set to false by a later but shorter cmd.\n\t\tbreak\n\t      fi\n\t    done\n\t    IFS=\"$save_ifs\"\n\t    if test -n \"$export_symbols_regex\" && test \"X$skipped_export\" != \"X:\"; then\n\t      func_show_eval '$EGREP -e \"$export_symbols_regex\" \"$export_symbols\" > \"${export_symbols}T\"'\n\t      func_show_eval '$MV \"${export_symbols}T\" \"$export_symbols\"'\n\t    fi\n\t  fi\n\tfi\n\n\tif test -n \"$export_symbols\" && test -n \"$include_expsyms\"; then\n\t  tmp_export_symbols=\"$export_symbols\"\n\t  test -n \"$orig_export_symbols\" && tmp_export_symbols=\"$orig_export_symbols\"\n\t  $opt_dry_run || eval '$ECHO \"$include_expsyms\" | $SP2NL >> \"$tmp_export_symbols\"'\n\tfi\n\n\tif test \"X$skipped_export\" != \"X:\" && test -n \"$orig_export_symbols\"; then\n\t  # The given exports_symbols file has to be filtered, so filter it.\n\t  func_verbose \"filter symbol list for \\`$libname.la' to tag DATA exports\"\n\t  # FIXME: $output_objdir/$libname.filter potentially contains lots of\n\t  # 's' commands which not all seds can handle. GNU sed should be fine\n\t  # though. Also, the filter scales superlinearly with the number of\n\t  # global variables. join(1) would be nice here, but unfortunately\n\t  # isn't a blessed tool.\n\t  $opt_dry_run || $SED -e '/[ ,]DATA/!d;s,\\(.*\\)\\([ \\,].*\\),s|^\\1$|\\1\\2|,' < $export_symbols > $output_objdir/$libname.filter\n\t  func_append delfiles \" $export_symbols $output_objdir/$libname.filter\"\n\t  export_symbols=$output_objdir/$libname.def\n\t  $opt_dry_run || $SED -f $output_objdir/$libname.filter < $orig_export_symbols > $export_symbols\n\tfi\n\n\ttmp_deplibs=\n\tfor test_deplib in $deplibs; do\n\t  case \" $convenience \" in\n\t  *\" $test_deplib \"*) ;;\n\t  *)\n\t    func_append tmp_deplibs \" $test_deplib\"\n\t    ;;\n\t  esac\n\tdone\n\tdeplibs=\"$tmp_deplibs\"\n\n\tif test -n \"$convenience\"; then\n\t  if test -n \"$whole_archive_flag_spec\" &&\n\t    test \"$compiler_needs_object\" = yes &&\n\t    test -z \"$libobjs\"; then\n\t    # extract the archives, so we have objects to list.\n\t    # TODO: could optimize this to just extract one archive.\n\t    whole_archive_flag_spec=\n\t  fi\n\t  if test -n \"$whole_archive_flag_spec\"; then\n\t    save_libobjs=$libobjs\n\t    eval libobjs=\\\"\\$libobjs $whole_archive_flag_spec\\\"\n\t    test \"X$libobjs\" = \"X \" && libobjs=\n\t  else\n\t    gentop=\"$output_objdir/${outputname}x\"\n\t    func_append generated \" $gentop\"\n\n\t    func_extract_archives $gentop $convenience\n\t    func_append libobjs \" $func_extract_archives_result\"\n\t    test \"X$libobjs\" = \"X \" && libobjs=\n\t  fi\n\tfi\n\n\tif test \"$thread_safe\" = yes && test -n \"$thread_safe_flag_spec\"; then\n\t  eval flag=\\\"$thread_safe_flag_spec\\\"\n\t  func_append linker_flags \" $flag\"\n\tfi\n\n\t# Make a backup of the uninstalled library when relinking\n\tif test \"$opt_mode\" = relink; then\n\t  $opt_dry_run || eval '(cd $output_objdir && $RM ${realname}U && $MV $realname ${realname}U)' || exit $?\n\tfi\n\n\t# Do each of the archive commands.\n\tif test \"$module\" = yes && test -n \"$module_cmds\" ; then\n\t  if test -n \"$export_symbols\" && test -n \"$module_expsym_cmds\"; then\n\t    eval test_cmds=\\\"$module_expsym_cmds\\\"\n\t    cmds=$module_expsym_cmds\n\t  else\n\t    eval test_cmds=\\\"$module_cmds\\\"\n\t    cmds=$module_cmds\n\t  fi\n\telse\n\t  if test -n \"$export_symbols\" && test -n \"$archive_expsym_cmds\"; then\n\t    eval test_cmds=\\\"$archive_expsym_cmds\\\"\n\t    cmds=$archive_expsym_cmds\n\t  else\n\t    eval test_cmds=\\\"$archive_cmds\\\"\n\t    cmds=$archive_cmds\n\t  fi\n\tfi\n\n\tif test \"X$skipped_export\" != \"X:\" &&\n\t   func_len \" $test_cmds\" &&\n\t   len=$func_len_result &&\n\t   test \"$len\" -lt \"$max_cmd_len\" || test \"$max_cmd_len\" -le -1; then\n\t  :\n\telse\n\t  # The command line is too long to link in one step, link piecewise\n\t  # or, if using GNU ld and skipped_export is not :, use a linker\n\t  # script.\n\n\t  # Save the value of $output and $libobjs because we want to\n\t  # use them later.  If we have whole_archive_flag_spec, we\n\t  # want to use save_libobjs as it was before\n\t  # whole_archive_flag_spec was expanded, because we can't\n\t  # assume the linker understands whole_archive_flag_spec.\n\t  # This may have to be revisited, in case too many\n\t  # convenience libraries get linked in and end up exceeding\n\t  # the spec.\n\t  if test -z \"$convenience\" || test -z \"$whole_archive_flag_spec\"; then\n\t    save_libobjs=$libobjs\n\t  fi\n\t  save_output=$output\n\t  func_basename \"$output\"\n\t  output_la=$func_basename_result\n\n\t  # Clear the reloadable object creation command queue and\n\t  # initialize k to one.\n\t  test_cmds=\n\t  concat_cmds=\n\t  objlist=\n\t  last_robj=\n\t  k=1\n\n\t  if test -n \"$save_libobjs\" && test \"X$skipped_export\" != \"X:\" && test \"$with_gnu_ld\" = yes; then\n\t    output=${output_objdir}/${output_la}.lnkscript\n\t    func_verbose \"creating GNU ld script: $output\"\n\t    echo 'INPUT (' > $output\n\t    for obj in $save_libobjs\n\t    do\n\t      func_to_tool_file \"$obj\"\n\t      $ECHO \"$func_to_tool_file_result\" >> $output\n\t    done\n\t    echo ')' >> $output\n\t    func_append delfiles \" $output\"\n\t    func_to_tool_file \"$output\"\n\t    output=$func_to_tool_file_result\n\t  elif test -n \"$save_libobjs\" && test \"X$skipped_export\" != \"X:\" && test \"X$file_list_spec\" != X; then\n\t    output=${output_objdir}/${output_la}.lnk\n\t    func_verbose \"creating linker input file list: $output\"\n\t    : > $output\n\t    set x $save_libobjs\n\t    shift\n\t    firstobj=\n\t    if test \"$compiler_needs_object\" = yes; then\n\t      firstobj=\"$1 \"\n\t      shift\n\t    fi\n\t    for obj\n\t    do\n\t      func_to_tool_file \"$obj\"\n\t      $ECHO \"$func_to_tool_file_result\" >> $output\n\t    done\n\t    func_append delfiles \" $output\"\n\t    func_to_tool_file \"$output\"\n\t    output=$firstobj\\\"$file_list_spec$func_to_tool_file_result\\\"\n\t  else\n\t    if test -n \"$save_libobjs\"; then\n\t      func_verbose \"creating reloadable object files...\"\n\t      output=$output_objdir/$output_la-${k}.$objext\n\t      eval test_cmds=\\\"$reload_cmds\\\"\n\t      func_len \" $test_cmds\"\n\t      len0=$func_len_result\n\t      len=$len0\n\n\t      # Loop over the list of objects to be linked.\n\t      for obj in $save_libobjs\n\t      do\n\t\tfunc_len \" $obj\"\n\t\tfunc_arith $len + $func_len_result\n\t\tlen=$func_arith_result\n\t\tif test \"X$objlist\" = X ||\n\t\t   test \"$len\" -lt \"$max_cmd_len\"; then\n\t\t  func_append objlist \" $obj\"\n\t\telse\n\t\t  # The command $test_cmds is almost too long, add a\n\t\t  # command to the queue.\n\t\t  if test \"$k\" -eq 1 ; then\n\t\t    # The first file doesn't have a previous command to add.\n\t\t    reload_objs=$objlist\n\t\t    eval concat_cmds=\\\"$reload_cmds\\\"\n\t\t  else\n\t\t    # All subsequent reloadable object files will link in\n\t\t    # the last one created.\n\t\t    reload_objs=\"$objlist $last_robj\"\n\t\t    eval concat_cmds=\\\"\\$concat_cmds~$reload_cmds~\\$RM $last_robj\\\"\n\t\t  fi\n\t\t  last_robj=$output_objdir/$output_la-${k}.$objext\n\t\t  func_arith $k + 1\n\t\t  k=$func_arith_result\n\t\t  output=$output_objdir/$output_la-${k}.$objext\n\t\t  objlist=\" $obj\"\n\t\t  func_len \" $last_robj\"\n\t\t  func_arith $len0 + $func_len_result\n\t\t  len=$func_arith_result\n\t\tfi\n\t      done\n\t      # Handle the remaining objects by creating one last\n\t      # reloadable object file.  All subsequent reloadable object\n\t      # files will link in the last one created.\n\t      test -z \"$concat_cmds\" || concat_cmds=$concat_cmds~\n\t      reload_objs=\"$objlist $last_robj\"\n\t      eval concat_cmds=\\\"\\${concat_cmds}$reload_cmds\\\"\n\t      if test -n \"$last_robj\"; then\n\t        eval concat_cmds=\\\"\\${concat_cmds}~\\$RM $last_robj\\\"\n\t      fi\n\t      func_append delfiles \" $output\"\n\n\t    else\n\t      output=\n\t    fi\n\n\t    if ${skipped_export-false}; then\n\t      func_verbose \"generating symbol list for \\`$libname.la'\"\n\t      export_symbols=\"$output_objdir/$libname.exp\"\n\t      $opt_dry_run || $RM $export_symbols\n\t      libobjs=$output\n\t      # Append the command to create the export file.\n\t      test -z \"$concat_cmds\" || concat_cmds=$concat_cmds~\n\t      eval concat_cmds=\\\"\\$concat_cmds$export_symbols_cmds\\\"\n\t      if test -n \"$last_robj\"; then\n\t\teval concat_cmds=\\\"\\$concat_cmds~\\$RM $last_robj\\\"\n\t      fi\n\t    fi\n\n\t    test -n \"$save_libobjs\" &&\n\t      func_verbose \"creating a temporary reloadable object file: $output\"\n\n\t    # Loop through the commands generated above and execute them.\n\t    save_ifs=\"$IFS\"; IFS='~'\n\t    for cmd in $concat_cmds; do\n\t      IFS=\"$save_ifs\"\n\t      $opt_silent || {\n\t\t  func_quote_for_expand \"$cmd\"\n\t\t  eval \"func_echo $func_quote_for_expand_result\"\n\t      }\n\t      $opt_dry_run || eval \"$cmd\" || {\n\t\tlt_exit=$?\n\n\t\t# Restore the uninstalled library and exit\n\t\tif test \"$opt_mode\" = relink; then\n\t\t  ( cd \"$output_objdir\" && \\\n\t\t    $RM \"${realname}T\" && \\\n\t\t    $MV \"${realname}U\" \"$realname\" )\n\t\tfi\n\n\t\texit $lt_exit\n\t      }\n\t    done\n\t    IFS=\"$save_ifs\"\n\n\t    if test -n \"$export_symbols_regex\" && ${skipped_export-false}; then\n\t      func_show_eval '$EGREP -e \"$export_symbols_regex\" \"$export_symbols\" > \"${export_symbols}T\"'\n\t      func_show_eval '$MV \"${export_symbols}T\" \"$export_symbols\"'\n\t    fi\n\t  fi\n\n          if ${skipped_export-false}; then\n\t    if test -n \"$export_symbols\" && test -n \"$include_expsyms\"; then\n\t      tmp_export_symbols=\"$export_symbols\"\n\t      test -n \"$orig_export_symbols\" && tmp_export_symbols=\"$orig_export_symbols\"\n\t      $opt_dry_run || eval '$ECHO \"$include_expsyms\" | $SP2NL >> \"$tmp_export_symbols\"'\n\t    fi\n\n\t    if test -n \"$orig_export_symbols\"; then\n\t      # The given exports_symbols file has to be filtered, so filter it.\n\t      func_verbose \"filter symbol list for \\`$libname.la' to tag DATA exports\"\n\t      # FIXME: $output_objdir/$libname.filter potentially contains lots of\n\t      # 's' commands which not all seds can handle. GNU sed should be fine\n\t      # though. Also, the filter scales superlinearly with the number of\n\t      # global variables. join(1) would be nice here, but unfortunately\n\t      # isn't a blessed tool.\n\t      $opt_dry_run || $SED -e '/[ ,]DATA/!d;s,\\(.*\\)\\([ \\,].*\\),s|^\\1$|\\1\\2|,' < $export_symbols > $output_objdir/$libname.filter\n\t      func_append delfiles \" $export_symbols $output_objdir/$libname.filter\"\n\t      export_symbols=$output_objdir/$libname.def\n\t      $opt_dry_run || $SED -f $output_objdir/$libname.filter < $orig_export_symbols > $export_symbols\n\t    fi\n\t  fi\n\n\t  libobjs=$output\n\t  # Restore the value of output.\n\t  output=$save_output\n\n\t  if test -n \"$convenience\" && test -n \"$whole_archive_flag_spec\"; then\n\t    eval libobjs=\\\"\\$libobjs $whole_archive_flag_spec\\\"\n\t    test \"X$libobjs\" = \"X \" && libobjs=\n\t  fi\n\t  # Expand the library linking commands again to reset the\n\t  # value of $libobjs for piecewise linking.\n\n\t  # Do each of the archive commands.\n\t  if test \"$module\" = yes && test -n \"$module_cmds\" ; then\n\t    if test -n \"$export_symbols\" && test -n \"$module_expsym_cmds\"; then\n\t      cmds=$module_expsym_cmds\n\t    else\n\t      cmds=$module_cmds\n\t    fi\n\t  else\n\t    if test -n \"$export_symbols\" && test -n \"$archive_expsym_cmds\"; then\n\t      cmds=$archive_expsym_cmds\n\t    else\n\t      cmds=$archive_cmds\n\t    fi\n\t  fi\n\tfi\n\n\tif test -n \"$delfiles\"; then\n\t  # Append the command to remove temporary files to $cmds.\n\t  eval cmds=\\\"\\$cmds~\\$RM $delfiles\\\"\n\tfi\n\n\t# Add any objects from preloaded convenience libraries\n\tif test -n \"$dlprefiles\"; then\n\t  gentop=\"$output_objdir/${outputname}x\"\n\t  func_append generated \" $gentop\"\n\n\t  func_extract_archives $gentop $dlprefiles\n\t  func_append libobjs \" $func_extract_archives_result\"\n\t  test \"X$libobjs\" = \"X \" && libobjs=\n\tfi\n\n\tsave_ifs=\"$IFS\"; IFS='~'\n\tfor cmd in $cmds; do\n\t  IFS=\"$save_ifs\"\n\t  eval cmd=\\\"$cmd\\\"\n\t  $opt_silent || {\n\t    func_quote_for_expand \"$cmd\"\n\t    eval \"func_echo $func_quote_for_expand_result\"\n\t  }\n\t  $opt_dry_run || eval \"$cmd\" || {\n\t    lt_exit=$?\n\n\t    # Restore the uninstalled library and exit\n\t    if test \"$opt_mode\" = relink; then\n\t      ( cd \"$output_objdir\" && \\\n\t        $RM \"${realname}T\" && \\\n\t\t$MV \"${realname}U\" \"$realname\" )\n\t    fi\n\n\t    exit $lt_exit\n\t  }\n\tdone\n\tIFS=\"$save_ifs\"\n\n\t# Restore the uninstalled library and exit\n\tif test \"$opt_mode\" = relink; then\n\t  $opt_dry_run || eval '(cd $output_objdir && $RM ${realname}T && $MV $realname ${realname}T && $MV ${realname}U $realname)' || exit $?\n\n\t  if test -n \"$convenience\"; then\n\t    if test -z \"$whole_archive_flag_spec\"; then\n\t      func_show_eval '${RM}r \"$gentop\"'\n\t    fi\n\t  fi\n\n\t  exit $EXIT_SUCCESS\n\tfi\n\n\t# Create links to the real library.\n\tfor linkname in $linknames; do\n\t  if test \"$realname\" != \"$linkname\"; then\n\t    func_show_eval '(cd \"$output_objdir\" && $RM \"$linkname\" && $LN_S \"$realname\" \"$linkname\")' 'exit $?'\n\t  fi\n\tdone\n\n\t# If -module or -export-dynamic was specified, set the dlname.\n\tif test \"$module\" = yes || test \"$export_dynamic\" = yes; then\n\t  # On all known operating systems, these are identical.\n\t  dlname=\"$soname\"\n\tfi\n      fi\n      ;;\n\n    obj)\n      if test -n \"$dlfiles$dlprefiles\" || test \"$dlself\" != no; then\n\tfunc_warning \"\\`-dlopen' is ignored for objects\"\n      fi\n\n      case \" $deplibs\" in\n      *\\ -l* | *\\ -L*)\n\tfunc_warning \"\\`-l' and \\`-L' are ignored for objects\" ;;\n      esac\n\n      test -n \"$rpath\" && \\\n\tfunc_warning \"\\`-rpath' is ignored for objects\"\n\n      test -n \"$xrpath\" && \\\n\tfunc_warning \"\\`-R' is ignored for objects\"\n\n      test -n \"$vinfo\" && \\\n\tfunc_warning \"\\`-version-info' is ignored for objects\"\n\n      test -n \"$release\" && \\\n\tfunc_warning \"\\`-release' is ignored for objects\"\n\n      case $output in\n      *.lo)\n\ttest -n \"$objs$old_deplibs\" && \\\n\t  func_fatal_error \"cannot build library object \\`$output' from non-libtool objects\"\n\n\tlibobj=$output\n\tfunc_lo2o \"$libobj\"\n\tobj=$func_lo2o_result\n\t;;\n      *)\n\tlibobj=\n\tobj=\"$output\"\n\t;;\n      esac\n\n      # Delete the old objects.\n      $opt_dry_run || $RM $obj $libobj\n\n      # Objects from convenience libraries.  This assumes\n      # single-version convenience libraries.  Whenever we create\n      # different ones for PIC/non-PIC, this we'll have to duplicate\n      # the extraction.\n      reload_conv_objs=\n      gentop=\n      # reload_cmds runs $LD directly, so let us get rid of\n      # -Wl from whole_archive_flag_spec and hope we can get by with\n      # turning comma into space..\n      wl=\n\n      if test -n \"$convenience\"; then\n\tif test -n \"$whole_archive_flag_spec\"; then\n\t  eval tmp_whole_archive_flags=\\\"$whole_archive_flag_spec\\\"\n\t  reload_conv_objs=$reload_objs\\ `$ECHO \"$tmp_whole_archive_flags\" | $SED 's|,| |g'`\n\telse\n\t  gentop=\"$output_objdir/${obj}x\"\n\t  func_append generated \" $gentop\"\n\n\t  func_extract_archives $gentop $convenience\n\t  reload_conv_objs=\"$reload_objs $func_extract_archives_result\"\n\tfi\n      fi\n\n      # If we're not building shared, we need to use non_pic_objs\n      test \"$build_libtool_libs\" != yes && libobjs=\"$non_pic_objects\"\n\n      # Create the old-style object.\n      reload_objs=\"$objs$old_deplibs \"`$ECHO \"$libobjs\" | $SP2NL | $SED \"/\\.${libext}$/d; /\\.lib$/d; $lo2o\" | $NL2SP`\" $reload_conv_objs\" ### testsuite: skip nested quoting test\n\n      output=\"$obj\"\n      func_execute_cmds \"$reload_cmds\" 'exit $?'\n\n      # Exit if we aren't doing a library object file.\n      if test -z \"$libobj\"; then\n\tif test -n \"$gentop\"; then\n\t  func_show_eval '${RM}r \"$gentop\"'\n\tfi\n\n\texit $EXIT_SUCCESS\n      fi\n\n      if test \"$build_libtool_libs\" != yes; then\n\tif test -n \"$gentop\"; then\n\t  func_show_eval '${RM}r \"$gentop\"'\n\tfi\n\n\t# Create an invalid libtool object if no PIC, so that we don't\n\t# accidentally link it into a program.\n\t# $show \"echo timestamp > $libobj\"\n\t# $opt_dry_run || eval \"echo timestamp > $libobj\" || exit $?\n\texit $EXIT_SUCCESS\n      fi\n\n      if test -n \"$pic_flag\" || test \"$pic_mode\" != default; then\n\t# Only do commands if we really have different PIC objects.\n\treload_objs=\"$libobjs $reload_conv_objs\"\n\toutput=\"$libobj\"\n\tfunc_execute_cmds \"$reload_cmds\" 'exit $?'\n      fi\n\n      if test -n \"$gentop\"; then\n\tfunc_show_eval '${RM}r \"$gentop\"'\n      fi\n\n      exit $EXIT_SUCCESS\n      ;;\n\n    prog)\n      case $host in\n\t*cygwin*) func_stripname '' '.exe' \"$output\"\n\t          output=$func_stripname_result.exe;;\n      esac\n      test -n \"$vinfo\" && \\\n\tfunc_warning \"\\`-version-info' is ignored for programs\"\n\n      test -n \"$release\" && \\\n\tfunc_warning \"\\`-release' is ignored for programs\"\n\n      test \"$preload\" = yes \\\n        && test \"$dlopen_support\" = unknown \\\n\t&& test \"$dlopen_self\" = unknown \\\n\t&& test \"$dlopen_self_static\" = unknown && \\\n\t  func_warning \"\\`LT_INIT([dlopen])' not used. Assuming no dlopen support.\"\n\n      case $host in\n      *-*-rhapsody* | *-*-darwin1.[012])\n\t# On Rhapsody replace the C library is the System framework\n\tcompile_deplibs=`$ECHO \" $compile_deplibs\" | $SED 's/ -lc / System.ltframework /'`\n\tfinalize_deplibs=`$ECHO \" $finalize_deplibs\" | $SED 's/ -lc / System.ltframework /'`\n\t;;\n      esac\n\n      case $host in\n      *-*-darwin*)\n\t# Don't allow lazy linking, it breaks C++ global constructors\n\t# But is supposedly fixed on 10.4 or later (yay!).\n\tif test \"$tagname\" = CXX ; then\n\t  case ${MACOSX_DEPLOYMENT_TARGET-10.0} in\n\t    10.[0123])\n\t      func_append compile_command \" ${wl}-bind_at_load\"\n\t      func_append finalize_command \" ${wl}-bind_at_load\"\n\t    ;;\n\t  esac\n\tfi\n\t# Time to change all our \"foo.ltframework\" stuff back to \"-framework foo\"\n\tcompile_deplibs=`$ECHO \" $compile_deplibs\" | $SED 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\tfinalize_deplibs=`$ECHO \" $finalize_deplibs\" | $SED 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\t;;\n      esac\n\n\n      # move library search paths that coincide with paths to not yet\n      # installed libraries to the beginning of the library search list\n      new_libs=\n      for path in $notinst_path; do\n\tcase \" $new_libs \" in\n\t*\" -L$path/$objdir \"*) ;;\n\t*)\n\t  case \" $compile_deplibs \" in\n\t  *\" -L$path/$objdir \"*)\n\t    func_append new_libs \" -L$path/$objdir\" ;;\n\t  esac\n\t  ;;\n\tesac\n      done\n      for deplib in $compile_deplibs; do\n\tcase $deplib in\n\t-L*)\n\t  case \" $new_libs \" in\n\t  *\" $deplib \"*) ;;\n\t  *) func_append new_libs \" $deplib\" ;;\n\t  esac\n\t  ;;\n\t*) func_append new_libs \" $deplib\" ;;\n\tesac\n      done\n      compile_deplibs=\"$new_libs\"\n\n\n      func_append compile_command \" $compile_deplibs\"\n      func_append finalize_command \" $finalize_deplibs\"\n\n      if test -n \"$rpath$xrpath\"; then\n\t# If the user specified any rpath flags, then add them.\n\tfor libdir in $rpath $xrpath; do\n\t  # This is the magic to use -rpath.\n\t  case \"$finalize_rpath \" in\n\t  *\" $libdir \"*) ;;\n\t  *) func_append finalize_rpath \" $libdir\" ;;\n\t  esac\n\tdone\n      fi\n\n      # Now hardcode the library paths\n      rpath=\n      hardcode_libdirs=\n      for libdir in $compile_rpath $finalize_rpath; do\n\tif test -n \"$hardcode_libdir_flag_spec\"; then\n\t  if test -n \"$hardcode_libdir_separator\"; then\n\t    if test -z \"$hardcode_libdirs\"; then\n\t      hardcode_libdirs=\"$libdir\"\n\t    else\n\t      # Just accumulate the unique libdirs.\n\t      case $hardcode_libdir_separator$hardcode_libdirs$hardcode_libdir_separator in\n\t      *\"$hardcode_libdir_separator$libdir$hardcode_libdir_separator\"*)\n\t\t;;\n\t      *)\n\t\tfunc_append hardcode_libdirs \"$hardcode_libdir_separator$libdir\"\n\t\t;;\n\t      esac\n\t    fi\n\t  else\n\t    eval flag=\\\"$hardcode_libdir_flag_spec\\\"\n\t    func_append rpath \" $flag\"\n\t  fi\n\telif test -n \"$runpath_var\"; then\n\t  case \"$perm_rpath \" in\n\t  *\" $libdir \"*) ;;\n\t  *) func_append perm_rpath \" $libdir\" ;;\n\t  esac\n\tfi\n\tcase $host in\n\t*-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-cegcc*)\n\t  testbindir=`${ECHO} \"$libdir\" | ${SED} -e 's*/lib$*/bin*'`\n\t  case :$dllsearchpath: in\n\t  *\":$libdir:\"*) ;;\n\t  ::) dllsearchpath=$libdir;;\n\t  *) func_append dllsearchpath \":$libdir\";;\n\t  esac\n\t  case :$dllsearchpath: in\n\t  *\":$testbindir:\"*) ;;\n\t  ::) dllsearchpath=$testbindir;;\n\t  *) func_append dllsearchpath \":$testbindir\";;\n\t  esac\n\t  ;;\n\tesac\n      done\n      # Substitute the hardcoded libdirs into the rpath.\n      if test -n \"$hardcode_libdir_separator\" &&\n\t test -n \"$hardcode_libdirs\"; then\n\tlibdir=\"$hardcode_libdirs\"\n\teval rpath=\\\" $hardcode_libdir_flag_spec\\\"\n      fi\n      compile_rpath=\"$rpath\"\n\n      rpath=\n      hardcode_libdirs=\n      for libdir in $finalize_rpath; do\n\tif test -n \"$hardcode_libdir_flag_spec\"; then\n\t  if test -n \"$hardcode_libdir_separator\"; then\n\t    if test -z \"$hardcode_libdirs\"; then\n\t      hardcode_libdirs=\"$libdir\"\n\t    else\n\t      # Just accumulate the unique libdirs.\n\t      case $hardcode_libdir_separator$hardcode_libdirs$hardcode_libdir_separator in\n\t      *\"$hardcode_libdir_separator$libdir$hardcode_libdir_separator\"*)\n\t\t;;\n\t      *)\n\t\tfunc_append hardcode_libdirs \"$hardcode_libdir_separator$libdir\"\n\t\t;;\n\t      esac\n\t    fi\n\t  else\n\t    eval flag=\\\"$hardcode_libdir_flag_spec\\\"\n\t    func_append rpath \" $flag\"\n\t  fi\n\telif test -n \"$runpath_var\"; then\n\t  case \"$finalize_perm_rpath \" in\n\t  *\" $libdir \"*) ;;\n\t  *) func_append finalize_perm_rpath \" $libdir\" ;;\n\t  esac\n\tfi\n      done\n      # Substitute the hardcoded libdirs into the rpath.\n      if test -n \"$hardcode_libdir_separator\" &&\n\t test -n \"$hardcode_libdirs\"; then\n\tlibdir=\"$hardcode_libdirs\"\n\teval rpath=\\\" $hardcode_libdir_flag_spec\\\"\n      fi\n      finalize_rpath=\"$rpath\"\n\n      if test -n \"$libobjs\" && test \"$build_old_libs\" = yes; then\n\t# Transform all the library objects into standard objects.\n\tcompile_command=`$ECHO \"$compile_command\" | $SP2NL | $SED \"$lo2o\" | $NL2SP`\n\tfinalize_command=`$ECHO \"$finalize_command\" | $SP2NL | $SED \"$lo2o\" | $NL2SP`\n      fi\n\n      func_generate_dlsyms \"$outputname\" \"@PROGRAM@\" \"no\"\n\n      # template prelinking step\n      if test -n \"$prelink_cmds\"; then\n\tfunc_execute_cmds \"$prelink_cmds\" 'exit $?'\n      fi\n\n      wrappers_required=yes\n      case $host in\n      *cegcc* | *mingw32ce*)\n        # Disable wrappers for cegcc and mingw32ce hosts, we are cross compiling anyway.\n        wrappers_required=no\n        ;;\n      *cygwin* | *mingw* )\n        if test \"$build_libtool_libs\" != yes; then\n          wrappers_required=no\n        fi\n        ;;\n      *)\n        if test \"$need_relink\" = no || test \"$build_libtool_libs\" != yes; then\n          wrappers_required=no\n        fi\n        ;;\n      esac\n      if test \"$wrappers_required\" = no; then\n\t# Replace the output file specification.\n\tcompile_command=`$ECHO \"$compile_command\" | $SED 's%@OUTPUT@%'\"$output\"'%g'`\n\tlink_command=\"$compile_command$compile_rpath\"\n\n\t# We have no uninstalled library dependencies, so finalize right now.\n\texit_status=0\n\tfunc_show_eval \"$link_command\" 'exit_status=$?'\n\n\tif test -n \"$postlink_cmds\"; then\n\t  func_to_tool_file \"$output\"\n\t  postlink_cmds=`func_echo_all \"$postlink_cmds\" | $SED -e 's%@OUTPUT@%'\"$output\"'%g' -e 's%@TOOL_OUTPUT@%'\"$func_to_tool_file_result\"'%g'`\n\t  func_execute_cmds \"$postlink_cmds\" 'exit $?'\n\tfi\n\n\t# Delete the generated files.\n\tif test -f \"$output_objdir/${outputname}S.${objext}\"; then\n\t  func_show_eval '$RM \"$output_objdir/${outputname}S.${objext}\"'\n\tfi\n\n\texit $exit_status\n      fi\n\n      if test -n \"$compile_shlibpath$finalize_shlibpath\"; then\n\tcompile_command=\"$shlibpath_var=\\\"$compile_shlibpath$finalize_shlibpath\\$$shlibpath_var\\\" $compile_command\"\n      fi\n      if test -n \"$finalize_shlibpath\"; then\n\tfinalize_command=\"$shlibpath_var=\\\"$finalize_shlibpath\\$$shlibpath_var\\\" $finalize_command\"\n      fi\n\n      compile_var=\n      finalize_var=\n      if test -n \"$runpath_var\"; then\n\tif test -n \"$perm_rpath\"; then\n\t  # We should set the runpath_var.\n\t  rpath=\n\t  for dir in $perm_rpath; do\n\t    func_append rpath \"$dir:\"\n\t  done\n\t  compile_var=\"$runpath_var=\\\"$rpath\\$$runpath_var\\\" \"\n\tfi\n\tif test -n \"$finalize_perm_rpath\"; then\n\t  # We should set the runpath_var.\n\t  rpath=\n\t  for dir in $finalize_perm_rpath; do\n\t    func_append rpath \"$dir:\"\n\t  done\n\t  finalize_var=\"$runpath_var=\\\"$rpath\\$$runpath_var\\\" \"\n\tfi\n      fi\n\n      if test \"$no_install\" = yes; then\n\t# We don't need to create a wrapper script.\n\tlink_command=\"$compile_var$compile_command$compile_rpath\"\n\t# Replace the output file specification.\n\tlink_command=`$ECHO \"$link_command\" | $SED 's%@OUTPUT@%'\"$output\"'%g'`\n\t# Delete the old output file.\n\t$opt_dry_run || $RM $output\n\t# Link the executable and exit\n\tfunc_show_eval \"$link_command\" 'exit $?'\n\n\tif test -n \"$postlink_cmds\"; then\n\t  func_to_tool_file \"$output\"\n\t  postlink_cmds=`func_echo_all \"$postlink_cmds\" | $SED -e 's%@OUTPUT@%'\"$output\"'%g' -e 's%@TOOL_OUTPUT@%'\"$func_to_tool_file_result\"'%g'`\n\t  func_execute_cmds \"$postlink_cmds\" 'exit $?'\n\tfi\n\n\texit $EXIT_SUCCESS\n      fi\n\n      if test \"$hardcode_action\" = relink; then\n\t# Fast installation is not supported\n\tlink_command=\"$compile_var$compile_command$compile_rpath\"\n\trelink_command=\"$finalize_var$finalize_command$finalize_rpath\"\n\n\tfunc_warning \"this platform does not like uninstalled shared libraries\"\n\tfunc_warning \"\\`$output' will be relinked during installation\"\n      else\n\tif test \"$fast_install\" != no; then\n\t  link_command=\"$finalize_var$compile_command$finalize_rpath\"\n\t  if test \"$fast_install\" = yes; then\n\t    relink_command=`$ECHO \"$compile_var$compile_command$compile_rpath\" | $SED 's%@OUTPUT@%\\$progdir/\\$file%g'`\n\t  else\n\t    # fast_install is set to needless\n\t    relink_command=\n\t  fi\n\telse\n\t  link_command=\"$compile_var$compile_command$compile_rpath\"\n\t  relink_command=\"$finalize_var$finalize_command$finalize_rpath\"\n\tfi\n      fi\n\n      # Replace the output file specification.\n      link_command=`$ECHO \"$link_command\" | $SED 's%@OUTPUT@%'\"$output_objdir/$outputname\"'%g'`\n\n      # Delete the old output files.\n      $opt_dry_run || $RM $output $output_objdir/$outputname $output_objdir/lt-$outputname\n\n      func_show_eval \"$link_command\" 'exit $?'\n\n      if test -n \"$postlink_cmds\"; then\n\tfunc_to_tool_file \"$output_objdir/$outputname\"\n\tpostlink_cmds=`func_echo_all \"$postlink_cmds\" | $SED -e 's%@OUTPUT@%'\"$output_objdir/$outputname\"'%g' -e 's%@TOOL_OUTPUT@%'\"$func_to_tool_file_result\"'%g'`\n\tfunc_execute_cmds \"$postlink_cmds\" 'exit $?'\n      fi\n\n      # Now create the wrapper script.\n      func_verbose \"creating $output\"\n\n      # Quote the relink command for shipping.\n      if test -n \"$relink_command\"; then\n\t# Preserve any variables that may affect compiler behavior\n\tfor var in $variables_saved_for_relink; do\n\t  if eval test -z \\\"\\${$var+set}\\\"; then\n\t    relink_command=\"{ test -z \\\"\\${$var+set}\\\" || $lt_unset $var || { $var=; export $var; }; }; $relink_command\"\n\t  elif eval var_value=\\$$var; test -z \"$var_value\"; then\n\t    relink_command=\"$var=; export $var; $relink_command\"\n\t  else\n\t    func_quote_for_eval \"$var_value\"\n\t    relink_command=\"$var=$func_quote_for_eval_result; export $var; $relink_command\"\n\t  fi\n\tdone\n\trelink_command=\"(cd `pwd`; $relink_command)\"\n\trelink_command=`$ECHO \"$relink_command\" | $SED \"$sed_quote_subst\"`\n      fi\n\n      # Only actually do things if not in dry run mode.\n      $opt_dry_run || {\n\t# win32 will think the script is a binary if it has\n\t# a .exe suffix, so we strip it off here.\n\tcase $output in\n\t  *.exe) func_stripname '' '.exe' \"$output\"\n\t         output=$func_stripname_result ;;\n\tesac\n\t# test for cygwin because mv fails w/o .exe extensions\n\tcase $host in\n\t  *cygwin*)\n\t    exeext=.exe\n\t    func_stripname '' '.exe' \"$outputname\"\n\t    outputname=$func_stripname_result ;;\n\t  *) exeext= ;;\n\tesac\n\tcase $host in\n\t  *cygwin* | *mingw* )\n\t    func_dirname_and_basename \"$output\" \"\" \".\"\n\t    output_name=$func_basename_result\n\t    output_path=$func_dirname_result\n\t    cwrappersource=\"$output_path/$objdir/lt-$output_name.c\"\n\t    cwrapper=\"$output_path/$output_name.exe\"\n\t    $RM $cwrappersource $cwrapper\n\t    trap \"$RM $cwrappersource $cwrapper; exit $EXIT_FAILURE\" 1 2 15\n\n\t    func_emit_cwrapperexe_src > $cwrappersource\n\n\t    # The wrapper executable is built using the $host compiler,\n\t    # because it contains $host paths and files. If cross-\n\t    # compiling, it, like the target executable, must be\n\t    # executed on the $host or under an emulation environment.\n\t    $opt_dry_run || {\n\t      $LTCC $LTCFLAGS -o $cwrapper $cwrappersource\n\t      $STRIP $cwrapper\n\t    }\n\n\t    # Now, create the wrapper script for func_source use:\n\t    func_ltwrapper_scriptname $cwrapper\n\t    $RM $func_ltwrapper_scriptname_result\n\t    trap \"$RM $func_ltwrapper_scriptname_result; exit $EXIT_FAILURE\" 1 2 15\n\t    $opt_dry_run || {\n\t      # note: this script will not be executed, so do not chmod.\n\t      if test \"x$build\" = \"x$host\" ; then\n\t\t$cwrapper --lt-dump-script > $func_ltwrapper_scriptname_result\n\t      else\n\t\tfunc_emit_wrapper no > $func_ltwrapper_scriptname_result\n\t      fi\n\t    }\n\t  ;;\n\t  * )\n\t    $RM $output\n\t    trap \"$RM $output; exit $EXIT_FAILURE\" 1 2 15\n\n\t    func_emit_wrapper no > $output\n\t    chmod +x $output\n\t  ;;\n\tesac\n      }\n      exit $EXIT_SUCCESS\n      ;;\n    esac\n\n    # See if we need to build an old-fashioned archive.\n    for oldlib in $oldlibs; do\n\n      if test \"$build_libtool_libs\" = convenience; then\n\toldobjs=\"$libobjs_save $symfileobj\"\n\taddlibs=\"$convenience\"\n\tbuild_libtool_libs=no\n      else\n\tif test \"$build_libtool_libs\" = module; then\n\t  oldobjs=\"$libobjs_save\"\n\t  build_libtool_libs=no\n\telse\n\t  oldobjs=\"$old_deplibs $non_pic_objects\"\n\t  if test \"$preload\" = yes && test -f \"$symfileobj\"; then\n\t    func_append oldobjs \" $symfileobj\"\n\t  fi\n\tfi\n\taddlibs=\"$old_convenience\"\n      fi\n\n      if test -n \"$addlibs\"; then\n\tgentop=\"$output_objdir/${outputname}x\"\n\tfunc_append generated \" $gentop\"\n\n\tfunc_extract_archives $gentop $addlibs\n\tfunc_append oldobjs \" $func_extract_archives_result\"\n      fi\n\n      # Do each command in the archive commands.\n      if test -n \"$old_archive_from_new_cmds\" && test \"$build_libtool_libs\" = yes; then\n\tcmds=$old_archive_from_new_cmds\n      else\n\n\t# Add any objects from preloaded convenience libraries\n\tif test -n \"$dlprefiles\"; then\n\t  gentop=\"$output_objdir/${outputname}x\"\n\t  func_append generated \" $gentop\"\n\n\t  func_extract_archives $gentop $dlprefiles\n\t  func_append oldobjs \" $func_extract_archives_result\"\n\tfi\n\n\t# POSIX demands no paths to be encoded in archives.  We have\n\t# to avoid creating archives with duplicate basenames if we\n\t# might have to extract them afterwards, e.g., when creating a\n\t# static archive out of a convenience library, or when linking\n\t# the entirety of a libtool archive into another (currently\n\t# not supported by libtool).\n\tif (for obj in $oldobjs\n\t    do\n\t      func_basename \"$obj\"\n\t      $ECHO \"$func_basename_result\"\n\t    done | sort | sort -uc >/dev/null 2>&1); then\n\t  :\n\telse\n\t  echo \"copying selected object files to avoid basename conflicts...\"\n\t  gentop=\"$output_objdir/${outputname}x\"\n\t  func_append generated \" $gentop\"\n\t  func_mkdir_p \"$gentop\"\n\t  save_oldobjs=$oldobjs\n\t  oldobjs=\n\t  counter=1\n\t  for obj in $save_oldobjs\n\t  do\n\t    func_basename \"$obj\"\n\t    objbase=\"$func_basename_result\"\n\t    case \" $oldobjs \" in\n\t    \" \") oldobjs=$obj ;;\n\t    *[\\ /]\"$objbase \"*)\n\t      while :; do\n\t\t# Make sure we don't pick an alternate name that also\n\t\t# overlaps.\n\t\tnewobj=lt$counter-$objbase\n\t\tfunc_arith $counter + 1\n\t\tcounter=$func_arith_result\n\t\tcase \" $oldobjs \" in\n\t\t*[\\ /]\"$newobj \"*) ;;\n\t\t*) if test ! -f \"$gentop/$newobj\"; then break; fi ;;\n\t\tesac\n\t      done\n\t      func_show_eval \"ln $obj $gentop/$newobj || cp $obj $gentop/$newobj\"\n\t      func_append oldobjs \" $gentop/$newobj\"\n\t      ;;\n\t    *) func_append oldobjs \" $obj\" ;;\n\t    esac\n\t  done\n\tfi\n\tfunc_to_tool_file \"$oldlib\" func_convert_file_msys_to_w32\n\ttool_oldlib=$func_to_tool_file_result\n\teval cmds=\\\"$old_archive_cmds\\\"\n\n\tfunc_len \" $cmds\"\n\tlen=$func_len_result\n\tif test \"$len\" -lt \"$max_cmd_len\" || test \"$max_cmd_len\" -le -1; then\n\t  cmds=$old_archive_cmds\n\telif test -n \"$archiver_list_spec\"; then\n\t  func_verbose \"using command file archive linking...\"\n\t  for obj in $oldobjs\n\t  do\n\t    func_to_tool_file \"$obj\"\n\t    $ECHO \"$func_to_tool_file_result\"\n\t  done > $output_objdir/$libname.libcmd\n\t  func_to_tool_file \"$output_objdir/$libname.libcmd\"\n\t  oldobjs=\" $archiver_list_spec$func_to_tool_file_result\"\n\t  cmds=$old_archive_cmds\n\telse\n\t  # the command line is too long to link in one step, link in parts\n\t  func_verbose \"using piecewise archive linking...\"\n\t  save_RANLIB=$RANLIB\n\t  RANLIB=:\n\t  objlist=\n\t  concat_cmds=\n\t  save_oldobjs=$oldobjs\n\t  oldobjs=\n\t  # Is there a better way of finding the last object in the list?\n\t  for obj in $save_oldobjs\n\t  do\n\t    last_oldobj=$obj\n\t  done\n\t  eval test_cmds=\\\"$old_archive_cmds\\\"\n\t  func_len \" $test_cmds\"\n\t  len0=$func_len_result\n\t  len=$len0\n\t  for obj in $save_oldobjs\n\t  do\n\t    func_len \" $obj\"\n\t    func_arith $len + $func_len_result\n\t    len=$func_arith_result\n\t    func_append objlist \" $obj\"\n\t    if test \"$len\" -lt \"$max_cmd_len\"; then\n\t      :\n\t    else\n\t      # the above command should be used before it gets too long\n\t      oldobjs=$objlist\n\t      if test \"$obj\" = \"$last_oldobj\" ; then\n\t\tRANLIB=$save_RANLIB\n\t      fi\n\t      test -z \"$concat_cmds\" || concat_cmds=$concat_cmds~\n\t      eval concat_cmds=\\\"\\${concat_cmds}$old_archive_cmds\\\"\n\t      objlist=\n\t      len=$len0\n\t    fi\n\t  done\n\t  RANLIB=$save_RANLIB\n\t  oldobjs=$objlist\n\t  if test \"X$oldobjs\" = \"X\" ; then\n\t    eval cmds=\\\"\\$concat_cmds\\\"\n\t  else\n\t    eval cmds=\\\"\\$concat_cmds~\\$old_archive_cmds\\\"\n\t  fi\n\tfi\n      fi\n      func_execute_cmds \"$cmds\" 'exit $?'\n    done\n\n    test -n \"$generated\" && \\\n      func_show_eval \"${RM}r$generated\"\n\n    # Now create the libtool archive.\n    case $output in\n    *.la)\n      old_library=\n      test \"$build_old_libs\" = yes && old_library=\"$libname.$libext\"\n      func_verbose \"creating $output\"\n\n      # Preserve any variables that may affect compiler behavior\n      for var in $variables_saved_for_relink; do\n\tif eval test -z \\\"\\${$var+set}\\\"; then\n\t  relink_command=\"{ test -z \\\"\\${$var+set}\\\" || $lt_unset $var || { $var=; export $var; }; }; $relink_command\"\n\telif eval var_value=\\$$var; test -z \"$var_value\"; then\n\t  relink_command=\"$var=; export $var; $relink_command\"\n\telse\n\t  func_quote_for_eval \"$var_value\"\n\t  relink_command=\"$var=$func_quote_for_eval_result; export $var; $relink_command\"\n\tfi\n      done\n      # Quote the link command for shipping.\n      relink_command=\"(cd `pwd`; $SHELL $progpath $preserve_args --mode=relink $libtool_args @inst_prefix_dir@)\"\n      relink_command=`$ECHO \"$relink_command\" | $SED \"$sed_quote_subst\"`\n      if test \"$hardcode_automatic\" = yes ; then\n\trelink_command=\n      fi\n\n      # Only create the output if not a dry run.\n      $opt_dry_run || {\n\tfor installed in no yes; do\n\t  if test \"$installed\" = yes; then\n\t    if test -z \"$install_libdir\"; then\n\t      break\n\t    fi\n\t    output=\"$output_objdir/$outputname\"i\n\t    # Replace all uninstalled libtool libraries with the installed ones\n\t    newdependency_libs=\n\t    for deplib in $dependency_libs; do\n\t      case $deplib in\n\t      *.la)\n\t\tfunc_basename \"$deplib\"\n\t\tname=\"$func_basename_result\"\n\t\tfunc_resolve_sysroot \"$deplib\"\n\t\teval libdir=`${SED} -n -e 's/^libdir=\\(.*\\)$/\\1/p' $func_resolve_sysroot_result`\n\t\ttest -z \"$libdir\" && \\\n\t\t  func_fatal_error \"\\`$deplib' is not a valid libtool archive\"\n\t\tfunc_append newdependency_libs \" ${lt_sysroot:+=}$libdir/$name\"\n\t\t;;\n\t      -L*)\n\t\tfunc_stripname -L '' \"$deplib\"\n\t\tfunc_replace_sysroot \"$func_stripname_result\"\n\t\tfunc_append newdependency_libs \" -L$func_replace_sysroot_result\"\n\t\t;;\n\t      -R*)\n\t\tfunc_stripname -R '' \"$deplib\"\n\t\tfunc_replace_sysroot \"$func_stripname_result\"\n\t\tfunc_append newdependency_libs \" -R$func_replace_sysroot_result\"\n\t\t;;\n\t      *) func_append newdependency_libs \" $deplib\" ;;\n\t      esac\n\t    done\n\t    dependency_libs=\"$newdependency_libs\"\n\t    newdlfiles=\n\n\t    for lib in $dlfiles; do\n\t      case $lib in\n\t      *.la)\n\t        func_basename \"$lib\"\n\t\tname=\"$func_basename_result\"\n\t\teval libdir=`${SED} -n -e 's/^libdir=\\(.*\\)$/\\1/p' $lib`\n\t\ttest -z \"$libdir\" && \\\n\t\t  func_fatal_error \"\\`$lib' is not a valid libtool archive\"\n\t\tfunc_append newdlfiles \" ${lt_sysroot:+=}$libdir/$name\"\n\t\t;;\n\t      *) func_append newdlfiles \" $lib\" ;;\n\t      esac\n\t    done\n\t    dlfiles=\"$newdlfiles\"\n\t    newdlprefiles=\n\t    for lib in $dlprefiles; do\n\t      case $lib in\n\t      *.la)\n\t\t# Only pass preopened files to the pseudo-archive (for\n\t\t# eventual linking with the app. that links it) if we\n\t\t# didn't already link the preopened objects directly into\n\t\t# the library:\n\t\tfunc_basename \"$lib\"\n\t\tname=\"$func_basename_result\"\n\t\teval libdir=`${SED} -n -e 's/^libdir=\\(.*\\)$/\\1/p' $lib`\n\t\ttest -z \"$libdir\" && \\\n\t\t  func_fatal_error \"\\`$lib' is not a valid libtool archive\"\n\t\tfunc_append newdlprefiles \" ${lt_sysroot:+=}$libdir/$name\"\n\t\t;;\n\t      esac\n\t    done\n\t    dlprefiles=\"$newdlprefiles\"\n\t  else\n\t    newdlfiles=\n\t    for lib in $dlfiles; do\n\t      case $lib in\n\t\t[\\\\/]* | [A-Za-z]:[\\\\/]*) abs=\"$lib\" ;;\n\t\t*) abs=`pwd`\"/$lib\" ;;\n\t      esac\n\t      func_append newdlfiles \" $abs\"\n\t    done\n\t    dlfiles=\"$newdlfiles\"\n\t    newdlprefiles=\n\t    for lib in $dlprefiles; do\n\t      case $lib in\n\t\t[\\\\/]* | [A-Za-z]:[\\\\/]*) abs=\"$lib\" ;;\n\t\t*) abs=`pwd`\"/$lib\" ;;\n\t      esac\n\t      func_append newdlprefiles \" $abs\"\n\t    done\n\t    dlprefiles=\"$newdlprefiles\"\n\t  fi\n\t  $RM $output\n\t  # place dlname in correct position for cygwin\n\t  # In fact, it would be nice if we could use this code for all target\n\t  # systems that can't hard-code library paths into their executables\n\t  # and that have no shared library path variable independent of PATH,\n\t  # but it turns out we can't easily determine that from inspecting\n\t  # libtool variables, so we have to hard-code the OSs to which it\n\t  # applies here; at the moment, that means platforms that use the PE\n\t  # object format with DLL files.  See the long comment at the top of\n\t  # tests/bindir.at for full details.\n\t  tdlname=$dlname\n\t  case $host,$output,$installed,$module,$dlname in\n\t    *cygwin*,*lai,yes,no,*.dll | *mingw*,*lai,yes,no,*.dll | *cegcc*,*lai,yes,no,*.dll)\n\t      # If a -bindir argument was supplied, place the dll there.\n\t      if test \"x$bindir\" != x ;\n\t      then\n\t\tfunc_relative_path \"$install_libdir\" \"$bindir\"\n\t\ttdlname=$func_relative_path_result$dlname\n\t      else\n\t\t# Otherwise fall back on heuristic.\n\t\ttdlname=../bin/$dlname\n\t      fi\n\t      ;;\n\t  esac\n\t  $ECHO > $output \"\\\n# $outputname - a libtool library file\n# Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION\n#\n# Please DO NOT delete this file!\n# It is necessary for linking the library.\n\n# The name that we can dlopen(3).\ndlname='$tdlname'\n\n# Names of this library.\nlibrary_names='$library_names'\n\n# The name of the static archive.\nold_library='$old_library'\n\n# Linker flags that can not go in dependency_libs.\ninherited_linker_flags='$new_inherited_linker_flags'\n\n# Libraries that this one depends upon.\ndependency_libs='$dependency_libs'\n\n# Names of additional weak libraries provided by this library\nweak_library_names='$weak_libs'\n\n# Version information for $libname.\ncurrent=$current\nage=$age\nrevision=$revision\n\n# Is this an already installed library?\ninstalled=$installed\n\n# Should we warn about portability when linking against -modules?\nshouldnotlink=$module\n\n# Files to dlopen/dlpreopen\ndlopen='$dlfiles'\ndlpreopen='$dlprefiles'\n\n# Directory that this library needs to be installed in:\nlibdir='$install_libdir'\"\n\t  if test \"$installed\" = no && test \"$need_relink\" = yes; then\n\t    $ECHO >> $output \"\\\nrelink_command=\\\"$relink_command\\\"\"\n\t  fi\n\tdone\n      }\n\n      # Do a symbolic link so that the libtool archive can be found in\n      # LD_LIBRARY_PATH before the program is installed.\n      func_show_eval '( cd \"$output_objdir\" && $RM \"$outputname\" && $LN_S \"../$outputname\" \"$outputname\" )' 'exit $?'\n      ;;\n    esac\n    exit $EXIT_SUCCESS\n}\n\n{ test \"$opt_mode\" = link || test \"$opt_mode\" = relink; } &&\n    func_mode_link ${1+\"$@\"}\n\n\n# func_mode_uninstall arg...\nfunc_mode_uninstall ()\n{\n    $opt_debug\n    RM=\"$nonopt\"\n    files=\n    rmforce=\n    exit_status=0\n\n    # This variable tells wrapper scripts just to set variables rather\n    # than running their programs.\n    libtool_install_magic=\"$magic\"\n\n    for arg\n    do\n      case $arg in\n      -f) func_append RM \" $arg\"; rmforce=yes ;;\n      -*) func_append RM \" $arg\" ;;\n      *) func_append files \" $arg\" ;;\n      esac\n    done\n\n    test -z \"$RM\" && \\\n      func_fatal_help \"you must specify an RM program\"\n\n    rmdirs=\n\n    for file in $files; do\n      func_dirname \"$file\" \"\" \".\"\n      dir=\"$func_dirname_result\"\n      if test \"X$dir\" = X.; then\n\todir=\"$objdir\"\n      else\n\todir=\"$dir/$objdir\"\n      fi\n      func_basename \"$file\"\n      name=\"$func_basename_result\"\n      test \"$opt_mode\" = uninstall && odir=\"$dir\"\n\n      # Remember odir for removal later, being careful to avoid duplicates\n      if test \"$opt_mode\" = clean; then\n\tcase \" $rmdirs \" in\n\t  *\" $odir \"*) ;;\n\t  *) func_append rmdirs \" $odir\" ;;\n\tesac\n      fi\n\n      # Don't error if the file doesn't exist and rm -f was used.\n      if { test -L \"$file\"; } >/dev/null 2>&1 ||\n\t { test -h \"$file\"; } >/dev/null 2>&1 ||\n\t test -f \"$file\"; then\n\t:\n      elif test -d \"$file\"; then\n\texit_status=1\n\tcontinue\n      elif test \"$rmforce\" = yes; then\n\tcontinue\n      fi\n\n      rmfiles=\"$file\"\n\n      case $name in\n      *.la)\n\t# Possibly a libtool archive, so verify it.\n\tif func_lalib_p \"$file\"; then\n\t  func_source $dir/$name\n\n\t  # Delete the libtool libraries and symlinks.\n\t  for n in $library_names; do\n\t    func_append rmfiles \" $odir/$n\"\n\t  done\n\t  test -n \"$old_library\" && func_append rmfiles \" $odir/$old_library\"\n\n\t  case \"$opt_mode\" in\n\t  clean)\n\t    case \" $library_names \" in\n\t    *\" $dlname \"*) ;;\n\t    *) test -n \"$dlname\" && func_append rmfiles \" $odir/$dlname\" ;;\n\t    esac\n\t    test -n \"$libdir\" && func_append rmfiles \" $odir/$name $odir/${name}i\"\n\t    ;;\n\t  uninstall)\n\t    if test -n \"$library_names\"; then\n\t      # Do each command in the postuninstall commands.\n\t      func_execute_cmds \"$postuninstall_cmds\" 'test \"$rmforce\" = yes || exit_status=1'\n\t    fi\n\n\t    if test -n \"$old_library\"; then\n\t      # Do each command in the old_postuninstall commands.\n\t      func_execute_cmds \"$old_postuninstall_cmds\" 'test \"$rmforce\" = yes || exit_status=1'\n\t    fi\n\t    # FIXME: should reinstall the best remaining shared library.\n\t    ;;\n\t  esac\n\tfi\n\t;;\n\n      *.lo)\n\t# Possibly a libtool object, so verify it.\n\tif func_lalib_p \"$file\"; then\n\n\t  # Read the .lo file\n\t  func_source $dir/$name\n\n\t  # Add PIC object to the list of files to remove.\n\t  if test -n \"$pic_object\" &&\n\t     test \"$pic_object\" != none; then\n\t    func_append rmfiles \" $dir/$pic_object\"\n\t  fi\n\n\t  # Add non-PIC object to the list of files to remove.\n\t  if test -n \"$non_pic_object\" &&\n\t     test \"$non_pic_object\" != none; then\n\t    func_append rmfiles \" $dir/$non_pic_object\"\n\t  fi\n\tfi\n\t;;\n\n      *)\n\tif test \"$opt_mode\" = clean ; then\n\t  noexename=$name\n\t  case $file in\n\t  *.exe)\n\t    func_stripname '' '.exe' \"$file\"\n\t    file=$func_stripname_result\n\t    func_stripname '' '.exe' \"$name\"\n\t    noexename=$func_stripname_result\n\t    # $file with .exe has already been added to rmfiles,\n\t    # add $file without .exe\n\t    func_append rmfiles \" $file\"\n\t    ;;\n\t  esac\n\t  # Do a test to see if this is a libtool program.\n\t  if func_ltwrapper_p \"$file\"; then\n\t    if func_ltwrapper_executable_p \"$file\"; then\n\t      func_ltwrapper_scriptname \"$file\"\n\t      relink_command=\n\t      func_source $func_ltwrapper_scriptname_result\n\t      func_append rmfiles \" $func_ltwrapper_scriptname_result\"\n\t    else\n\t      relink_command=\n\t      func_source $dir/$noexename\n\t    fi\n\n\t    # note $name still contains .exe if it was in $file originally\n\t    # as does the version of $file that was added into $rmfiles\n\t    func_append rmfiles \" $odir/$name $odir/${name}S.${objext}\"\n\t    if test \"$fast_install\" = yes && test -n \"$relink_command\"; then\n\t      func_append rmfiles \" $odir/lt-$name\"\n\t    fi\n\t    if test \"X$noexename\" != \"X$name\" ; then\n\t      func_append rmfiles \" $odir/lt-${noexename}.c\"\n\t    fi\n\t  fi\n\tfi\n\t;;\n      esac\n      func_show_eval \"$RM $rmfiles\" 'exit_status=1'\n    done\n\n    # Try to remove the ${objdir}s in the directories where we deleted files\n    for dir in $rmdirs; do\n      if test -d \"$dir\"; then\n\tfunc_show_eval \"rmdir $dir >/dev/null 2>&1\"\n      fi\n    done\n\n    exit $exit_status\n}\n\n{ test \"$opt_mode\" = uninstall || test \"$opt_mode\" = clean; } &&\n    func_mode_uninstall ${1+\"$@\"}\n\ntest -z \"$opt_mode\" && {\n  help=\"$generic_help\"\n  func_fatal_help \"you must specify a MODE\"\n}\n\ntest -z \"$exec_cmd\" && \\\n  func_fatal_help \"invalid operation mode \\`$opt_mode'\"\n\nif test -n \"$exec_cmd\"; then\n  eval exec \"$exec_cmd\"\n  exit $EXIT_FAILURE\nfi\n\nexit $exit_status\n\n\n# The TAGs below are defined such that we never get into a situation\n# in which we disable both kinds of libraries.  Given conflicting\n# choices, we go for a static library, that is the most portable,\n# since we can't tell whether shared libraries were disabled because\n# the user asked for that or because the platform doesn't support\n# them.  This is particularly important on AIX, because we don't\n# support having both static and shared libraries enabled at the same\n# time on that platform, so we default to a shared-only configuration.\n# If a disable-shared tag is given, we'll fallback to a static-only\n# configuration.  But we'll never go from static-only to shared-only.\n\n# ### BEGIN LIBTOOL TAG CONFIG: disable-shared\nbuild_libtool_libs=no\nbuild_old_libs=yes\n# ### END LIBTOOL TAG CONFIG: disable-shared\n\n# ### BEGIN LIBTOOL TAG CONFIG: disable-static\nbuild_old_libs=`case $build_libtool_libs in yes) echo no;; *) echo yes;; esac`\n# ### END LIBTOOL TAG CONFIG: disable-static\n\n# Local Variables:\n# mode:shell-script\n# sh-indentation:2\n# End:\n# vi:sw=2\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/tokudb/PerconaFT/third_party/snappy-1.1.2/aclocal.m4": "# generated automatically by aclocal 1.11.3 -*- Autoconf -*-\n\n# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,\n# 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software Foundation,\n# Inc.\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY, to the extent permitted by law; without\n# even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n# PARTICULAR PURPOSE.\n\nm4_ifndef([AC_AUTOCONF_VERSION],\n  [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl\nm4_if(m4_defn([AC_AUTOCONF_VERSION]), [2.68],,\n[m4_warning([this file was generated for autoconf 2.68.\nYou have another version of autoconf.  It may work, but is not guaranteed to.\nIf you have problems, you may need to regenerate the build system entirely.\nTo do so, use the procedure documented by the package, typically `autoreconf'.])])\n\n# libtool.m4 - Configure libtool for the host system. -*-Autoconf-*-\n#\n#   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005,\n#                 2006, 2007, 2008, 2009, 2010, 2011 Free Software\n#                 Foundation, Inc.\n#   Written by Gordon Matzigkeit, 1996\n#\n# This file is free software; the Free Software Foundation gives\n# unlimited permission to copy and/or distribute it, with or without\n# modifications, as long as this notice is preserved.\n\nm4_define([_LT_COPYING], [dnl\n#   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005,\n#                 2006, 2007, 2008, 2009, 2010, 2011 Free Software\n#                 Foundation, Inc.\n#   Written by Gordon Matzigkeit, 1996\n#\n#   This file is part of GNU Libtool.\n#\n# GNU Libtool is free software; you can redistribute it and/or\n# modify it under the terms of the GNU General Public License as\n# published by the Free Software Foundation; either version 2 of\n# the License, or (at your option) any later version.\n#\n# As a special exception to the GNU General Public License,\n# if you distribute this file as part of a program or library that\n# is built using GNU Libtool, you may include this file under the\n# same distribution terms that you use for the rest of that program.\n#\n# GNU Libtool is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with GNU Libtool; see the file COPYING.  If not, a copy\n# can be downloaded from http://www.gnu.org/licenses/gpl.html, or\n# obtained by writing to the Free Software Foundation, Inc.,\n# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1335  USA.\n])\n\n# serial 57 LT_INIT\n\n\n# LT_PREREQ(VERSION)\n# ------------------\n# Complain and exit if this libtool version is less that VERSION.\nm4_defun([LT_PREREQ],\n[m4_if(m4_version_compare(m4_defn([LT_PACKAGE_VERSION]), [$1]), -1,\n       [m4_default([$3],\n\t\t   [m4_fatal([Libtool version $1 or higher is required],\n\t\t             63)])],\n       [$2])])\n\n\n# _LT_CHECK_BUILDDIR\n# ------------------\n# Complain if the absolute build directory name contains unusual characters\nm4_defun([_LT_CHECK_BUILDDIR],\n[case `pwd` in\n  *\\ * | *\\\t*)\n    AC_MSG_WARN([Libtool does not cope well with whitespace in `pwd`]) ;;\nesac\n])\n\n\n# LT_INIT([OPTIONS])\n# ------------------\nAC_DEFUN([LT_INIT],\n[AC_PREREQ([2.58])dnl We use AC_INCLUDES_DEFAULT\nAC_REQUIRE([AC_CONFIG_AUX_DIR_DEFAULT])dnl\nAC_BEFORE([$0], [LT_LANG])dnl\nAC_BEFORE([$0], [LT_OUTPUT])dnl\nAC_BEFORE([$0], [LTDL_INIT])dnl\nm4_require([_LT_CHECK_BUILDDIR])dnl\n\ndnl Autoconf doesn't catch unexpanded LT_ macros by default:\nm4_pattern_forbid([^_?LT_[A-Z_]+$])dnl\nm4_pattern_allow([^(_LT_EOF|LT_DLGLOBAL|LT_DLLAZY_OR_NOW|LT_MULTI_MODULE)$])dnl\ndnl aclocal doesn't pull ltoptions.m4, ltsugar.m4, or ltversion.m4\ndnl unless we require an AC_DEFUNed macro:\nAC_REQUIRE([LTOPTIONS_VERSION])dnl\nAC_REQUIRE([LTSUGAR_VERSION])dnl\nAC_REQUIRE([LTVERSION_VERSION])dnl\nAC_REQUIRE([LTOBSOLETE_VERSION])dnl\nm4_require([_LT_PROG_LTMAIN])dnl\n\n_LT_SHELL_INIT([SHELL=${CONFIG_SHELL-/bin/sh}])\n\ndnl Parse OPTIONS\n_LT_SET_OPTIONS([$0], [$1])\n\n# This can be used to rebuild libtool when needed\nLIBTOOL_DEPS=\"$ltmain\"\n\n# Always use our own libtool.\nLIBTOOL='$(SHELL) $(top_builddir)/libtool'\nAC_SUBST(LIBTOOL)dnl\n\n_LT_SETUP\n\n# Only expand once:\nm4_define([LT_INIT])\n])# LT_INIT\n\n# Old names:\nAU_ALIAS([AC_PROG_LIBTOOL], [LT_INIT])\nAU_ALIAS([AM_PROG_LIBTOOL], [LT_INIT])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_PROG_LIBTOOL], [])\ndnl AC_DEFUN([AM_PROG_LIBTOOL], [])\n\n\n# _LT_CC_BASENAME(CC)\n# -------------------\n# Calculate cc_basename.  Skip known compiler wrappers and cross-prefix.\nm4_defun([_LT_CC_BASENAME],\n[for cc_temp in $1\"\"; do\n  case $cc_temp in\n    compile | *[[\\\\/]]compile | ccache | *[[\\\\/]]ccache ) ;;\n    distcc | *[[\\\\/]]distcc | purify | *[[\\\\/]]purify ) ;;\n    \\-*) ;;\n    *) break;;\n  esac\ndone\ncc_basename=`$ECHO \"$cc_temp\" | $SED \"s%.*/%%; s%^$host_alias-%%\"`\n])\n\n\n# _LT_FILEUTILS_DEFAULTS\n# ----------------------\n# It is okay to use these file commands and assume they have been set\n# sensibly after `m4_require([_LT_FILEUTILS_DEFAULTS])'.\nm4_defun([_LT_FILEUTILS_DEFAULTS],\n[: ${CP=\"cp -f\"}\n: ${MV=\"mv -f\"}\n: ${RM=\"rm -f\"}\n])# _LT_FILEUTILS_DEFAULTS\n\n\n# _LT_SETUP\n# ---------\nm4_defun([_LT_SETUP],\n[AC_REQUIRE([AC_CANONICAL_HOST])dnl\nAC_REQUIRE([AC_CANONICAL_BUILD])dnl\nAC_REQUIRE([_LT_PREPARE_SED_QUOTE_VARS])dnl\nAC_REQUIRE([_LT_PROG_ECHO_BACKSLASH])dnl\n\n_LT_DECL([], [PATH_SEPARATOR], [1], [The PATH separator for the build system])dnl\ndnl\n_LT_DECL([], [host_alias], [0], [The host system])dnl\n_LT_DECL([], [host], [0])dnl\n_LT_DECL([], [host_os], [0])dnl\ndnl\n_LT_DECL([], [build_alias], [0], [The build system])dnl\n_LT_DECL([], [build], [0])dnl\n_LT_DECL([], [build_os], [0])dnl\ndnl\nAC_REQUIRE([AC_PROG_CC])dnl\nAC_REQUIRE([LT_PATH_LD])dnl\nAC_REQUIRE([LT_PATH_NM])dnl\ndnl\nAC_REQUIRE([AC_PROG_LN_S])dnl\ntest -z \"$LN_S\" && LN_S=\"ln -s\"\n_LT_DECL([], [LN_S], [1], [Whether we need soft or hard links])dnl\ndnl\nAC_REQUIRE([LT_CMD_MAX_LEN])dnl\n_LT_DECL([objext], [ac_objext], [0], [Object file suffix (normally \"o\")])dnl\n_LT_DECL([], [exeext], [0], [Executable file suffix (normally \"\")])dnl\ndnl\nm4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_CHECK_SHELL_FEATURES])dnl\nm4_require([_LT_PATH_CONVERSION_FUNCTIONS])dnl\nm4_require([_LT_CMD_RELOAD])dnl\nm4_require([_LT_CHECK_MAGIC_METHOD])dnl\nm4_require([_LT_CHECK_SHAREDLIB_FROM_LINKLIB])dnl\nm4_require([_LT_CMD_OLD_ARCHIVE])dnl\nm4_require([_LT_CMD_GLOBAL_SYMBOLS])dnl\nm4_require([_LT_WITH_SYSROOT])dnl\n\n_LT_CONFIG_LIBTOOL_INIT([\n# See if we are running on zsh, and set the options which allow our\n# commands through without removal of \\ escapes INIT.\nif test -n \"\\${ZSH_VERSION+set}\" ; then\n   setopt NO_GLOB_SUBST\nfi\n])\nif test -n \"${ZSH_VERSION+set}\" ; then\n   setopt NO_GLOB_SUBST\nfi\n\n_LT_CHECK_OBJDIR\n\nm4_require([_LT_TAG_COMPILER])dnl\n\ncase $host_os in\naix3*)\n  # AIX sometimes has problems with the GCC collect2 program.  For some\n  # reason, if we set the COLLECT_NAMES environment variable, the problems\n  # vanish in a puff of smoke.\n  if test \"X${COLLECT_NAMES+set}\" != Xset; then\n    COLLECT_NAMES=\n    export COLLECT_NAMES\n  fi\n  ;;\nesac\n\n# Global variables:\nofile=libtool\ncan_build_shared=yes\n\n# All known linkers require a `.a' archive for static linking (except MSVC,\n# which needs '.lib').\nlibext=a\n\nwith_gnu_ld=\"$lt_cv_prog_gnu_ld\"\n\nold_CC=\"$CC\"\nold_CFLAGS=\"$CFLAGS\"\n\n# Set sane defaults for various variables\ntest -z \"$CC\" && CC=cc\ntest -z \"$LTCC\" && LTCC=$CC\ntest -z \"$LTCFLAGS\" && LTCFLAGS=$CFLAGS\ntest -z \"$LD\" && LD=ld\ntest -z \"$ac_objext\" && ac_objext=o\n\n_LT_CC_BASENAME([$compiler])\n\n# Only perform the check for file, if the check method requires it\ntest -z \"$MAGIC_CMD\" && MAGIC_CMD=file\ncase $deplibs_check_method in\nfile_magic*)\n  if test \"$file_magic_cmd\" = '$MAGIC_CMD'; then\n    _LT_PATH_MAGIC\n  fi\n  ;;\nesac\n\n# Use C for the default configuration in the libtool script\nLT_SUPPORTED_TAG([CC])\n_LT_LANG_C_CONFIG\n_LT_LANG_DEFAULT_CONFIG\n_LT_CONFIG_COMMANDS\n])# _LT_SETUP\n\n\n# _LT_PREPARE_SED_QUOTE_VARS\n# --------------------------\n# Define a few sed substitution that help us do robust quoting.\nm4_defun([_LT_PREPARE_SED_QUOTE_VARS],\n[# Backslashify metacharacters that are still active within\n# double-quoted strings.\nsed_quote_subst='s/\\([[\"`$\\\\]]\\)/\\\\\\1/g'\n\n# Same as above, but do not quote variable references.\ndouble_quote_subst='s/\\([[\"`\\\\]]\\)/\\\\\\1/g'\n\n# Sed substitution to delay expansion of an escaped shell variable in a\n# double_quote_subst'ed string.\ndelay_variable_subst='s/\\\\\\\\\\\\\\\\\\\\\\$/\\\\\\\\\\\\$/g'\n\n# Sed substitution to delay expansion of an escaped single quote.\ndelay_single_quote_subst='s/'\\''/'\\'\\\\\\\\\\\\\\'\\''/g'\n\n# Sed substitution to avoid accidental globbing in evaled expressions\nno_glob_subst='s/\\*/\\\\\\*/g'\n])\n\n# _LT_PROG_LTMAIN\n# ---------------\n# Note that this code is called both from `configure', and `config.status'\n# now that we use AC_CONFIG_COMMANDS to generate libtool.  Notably,\n# `config.status' has no value for ac_aux_dir unless we are using Automake,\n# so we pass a copy along to make sure it has a sensible value anyway.\nm4_defun([_LT_PROG_LTMAIN],\n[m4_ifdef([AC_REQUIRE_AUX_FILE], [AC_REQUIRE_AUX_FILE([ltmain.sh])])dnl\n_LT_CONFIG_LIBTOOL_INIT([ac_aux_dir='$ac_aux_dir'])\nltmain=\"$ac_aux_dir/ltmain.sh\"\n])# _LT_PROG_LTMAIN\n\n\n\n# So that we can recreate a full libtool script including additional\n# tags, we accumulate the chunks of code to send to AC_CONFIG_COMMANDS\n# in macros and then make a single call at the end using the `libtool'\n# label.\n\n\n# _LT_CONFIG_LIBTOOL_INIT([INIT-COMMANDS])\n# ----------------------------------------\n# Register INIT-COMMANDS to be passed to AC_CONFIG_COMMANDS later.\nm4_define([_LT_CONFIG_LIBTOOL_INIT],\n[m4_ifval([$1],\n          [m4_append([_LT_OUTPUT_LIBTOOL_INIT],\n                     [$1\n])])])\n\n# Initialize.\nm4_define([_LT_OUTPUT_LIBTOOL_INIT])\n\n\n# _LT_CONFIG_LIBTOOL([COMMANDS])\n# ------------------------------\n# Register COMMANDS to be passed to AC_CONFIG_COMMANDS later.\nm4_define([_LT_CONFIG_LIBTOOL],\n[m4_ifval([$1],\n          [m4_append([_LT_OUTPUT_LIBTOOL_COMMANDS],\n                     [$1\n])])])\n\n# Initialize.\nm4_define([_LT_OUTPUT_LIBTOOL_COMMANDS])\n\n\n# _LT_CONFIG_SAVE_COMMANDS([COMMANDS], [INIT_COMMANDS])\n# -----------------------------------------------------\nm4_defun([_LT_CONFIG_SAVE_COMMANDS],\n[_LT_CONFIG_LIBTOOL([$1])\n_LT_CONFIG_LIBTOOL_INIT([$2])\n])\n\n\n# _LT_FORMAT_COMMENT([COMMENT])\n# -----------------------------\n# Add leading comment marks to the start of each line, and a trailing\n# full-stop to the whole comment if one is not present already.\nm4_define([_LT_FORMAT_COMMENT],\n[m4_ifval([$1], [\nm4_bpatsubst([m4_bpatsubst([$1], [^ *], [# ])],\n              [['`$\\]], [\\\\\\&])]m4_bmatch([$1], [[!?.]$], [], [.])\n)])\n\n\n\n\n\n# _LT_DECL([CONFIGNAME], VARNAME, VALUE, [DESCRIPTION], [IS-TAGGED?])\n# -------------------------------------------------------------------\n# CONFIGNAME is the name given to the value in the libtool script.\n# VARNAME is the (base) name used in the configure script.\n# VALUE may be 0, 1 or 2 for a computed quote escaped value based on\n# VARNAME.  Any other value will be used directly.\nm4_define([_LT_DECL],\n[lt_if_append_uniq([lt_decl_varnames], [$2], [, ],\n    [lt_dict_add_subkey([lt_decl_dict], [$2], [libtool_name],\n\t[m4_ifval([$1], [$1], [$2])])\n    lt_dict_add_subkey([lt_decl_dict], [$2], [value], [$3])\n    m4_ifval([$4],\n\t[lt_dict_add_subkey([lt_decl_dict], [$2], [description], [$4])])\n    lt_dict_add_subkey([lt_decl_dict], [$2],\n\t[tagged?], [m4_ifval([$5], [yes], [no])])])\n])\n\n\n# _LT_TAGDECL([CONFIGNAME], VARNAME, VALUE, [DESCRIPTION])\n# --------------------------------------------------------\nm4_define([_LT_TAGDECL], [_LT_DECL([$1], [$2], [$3], [$4], [yes])])\n\n\n# lt_decl_tag_varnames([SEPARATOR], [VARNAME1...])\n# ------------------------------------------------\nm4_define([lt_decl_tag_varnames],\n[_lt_decl_filter([tagged?], [yes], $@)])\n\n\n# _lt_decl_filter(SUBKEY, VALUE, [SEPARATOR], [VARNAME1..])\n# ---------------------------------------------------------\nm4_define([_lt_decl_filter],\n[m4_case([$#],\n  [0], [m4_fatal([$0: too few arguments: $#])],\n  [1], [m4_fatal([$0: too few arguments: $#: $1])],\n  [2], [lt_dict_filter([lt_decl_dict], [$1], [$2], [], lt_decl_varnames)],\n  [3], [lt_dict_filter([lt_decl_dict], [$1], [$2], [$3], lt_decl_varnames)],\n  [lt_dict_filter([lt_decl_dict], $@)])[]dnl\n])\n\n\n# lt_decl_quote_varnames([SEPARATOR], [VARNAME1...])\n# --------------------------------------------------\nm4_define([lt_decl_quote_varnames],\n[_lt_decl_filter([value], [1], $@)])\n\n\n# lt_decl_dquote_varnames([SEPARATOR], [VARNAME1...])\n# ---------------------------------------------------\nm4_define([lt_decl_dquote_varnames],\n[_lt_decl_filter([value], [2], $@)])\n\n\n# lt_decl_varnames_tagged([SEPARATOR], [VARNAME1...])\n# ---------------------------------------------------\nm4_define([lt_decl_varnames_tagged],\n[m4_assert([$# <= 2])dnl\n_$0(m4_quote(m4_default([$1], [[, ]])),\n    m4_ifval([$2], [[$2]], [m4_dquote(lt_decl_tag_varnames)]),\n    m4_split(m4_normalize(m4_quote(_LT_TAGS)), [ ]))])\nm4_define([_lt_decl_varnames_tagged],\n[m4_ifval([$3], [lt_combine([$1], [$2], [_], $3)])])\n\n\n# lt_decl_all_varnames([SEPARATOR], [VARNAME1...])\n# ------------------------------------------------\nm4_define([lt_decl_all_varnames],\n[_$0(m4_quote(m4_default([$1], [[, ]])),\n     m4_if([$2], [],\n\t   m4_quote(lt_decl_varnames),\n\tm4_quote(m4_shift($@))))[]dnl\n])\nm4_define([_lt_decl_all_varnames],\n[lt_join($@, lt_decl_varnames_tagged([$1],\n\t\t\tlt_decl_tag_varnames([[, ]], m4_shift($@))))dnl\n])\n\n\n# _LT_CONFIG_STATUS_DECLARE([VARNAME])\n# ------------------------------------\n# Quote a variable value, and forward it to `config.status' so that its\n# declaration there will have the same value as in `configure'.  VARNAME\n# must have a single quote delimited value for this to work.\nm4_define([_LT_CONFIG_STATUS_DECLARE],\n[$1='`$ECHO \"$][$1\" | $SED \"$delay_single_quote_subst\"`'])\n\n\n# _LT_CONFIG_STATUS_DECLARATIONS\n# ------------------------------\n# We delimit libtool config variables with single quotes, so when\n# we write them to config.status, we have to be sure to quote all\n# embedded single quotes properly.  In configure, this macro expands\n# each variable declared with _LT_DECL (and _LT_TAGDECL) into:\n#\n#    <var>='`$ECHO \"$<var>\" | $SED \"$delay_single_quote_subst\"`'\nm4_defun([_LT_CONFIG_STATUS_DECLARATIONS],\n[m4_foreach([_lt_var], m4_quote(lt_decl_all_varnames),\n    [m4_n([_LT_CONFIG_STATUS_DECLARE(_lt_var)])])])\n\n\n# _LT_LIBTOOL_TAGS\n# ----------------\n# Output comment and list of tags supported by the script\nm4_defun([_LT_LIBTOOL_TAGS],\n[_LT_FORMAT_COMMENT([The names of the tagged configurations supported by this script])dnl\navailable_tags=\"_LT_TAGS\"dnl\n])\n\n\n# _LT_LIBTOOL_DECLARE(VARNAME, [TAG])\n# -----------------------------------\n# Extract the dictionary values for VARNAME (optionally with TAG) and\n# expand to a commented shell variable setting:\n#\n#    # Some comment about what VAR is for.\n#    visible_name=$lt_internal_name\nm4_define([_LT_LIBTOOL_DECLARE],\n[_LT_FORMAT_COMMENT(m4_quote(lt_dict_fetch([lt_decl_dict], [$1],\n\t\t\t\t\t   [description])))[]dnl\nm4_pushdef([_libtool_name],\n    m4_quote(lt_dict_fetch([lt_decl_dict], [$1], [libtool_name])))[]dnl\nm4_case(m4_quote(lt_dict_fetch([lt_decl_dict], [$1], [value])),\n    [0], [_libtool_name=[$]$1],\n    [1], [_libtool_name=$lt_[]$1],\n    [2], [_libtool_name=$lt_[]$1],\n    [_libtool_name=lt_dict_fetch([lt_decl_dict], [$1], [value])])[]dnl\nm4_ifval([$2], [_$2])[]m4_popdef([_libtool_name])[]dnl\n])\n\n\n# _LT_LIBTOOL_CONFIG_VARS\n# -----------------------\n# Produce commented declarations of non-tagged libtool config variables\n# suitable for insertion in the LIBTOOL CONFIG section of the `libtool'\n# script.  Tagged libtool config variables (even for the LIBTOOL CONFIG\n# section) are produced by _LT_LIBTOOL_TAG_VARS.\nm4_defun([_LT_LIBTOOL_CONFIG_VARS],\n[m4_foreach([_lt_var],\n    m4_quote(_lt_decl_filter([tagged?], [no], [], lt_decl_varnames)),\n    [m4_n([_LT_LIBTOOL_DECLARE(_lt_var)])])])\n\n\n# _LT_LIBTOOL_TAG_VARS(TAG)\n# -------------------------\nm4_define([_LT_LIBTOOL_TAG_VARS],\n[m4_foreach([_lt_var], m4_quote(lt_decl_tag_varnames),\n    [m4_n([_LT_LIBTOOL_DECLARE(_lt_var, [$1])])])])\n\n\n# _LT_TAGVAR(VARNAME, [TAGNAME])\n# ------------------------------\nm4_define([_LT_TAGVAR], [m4_ifval([$2], [$1_$2], [$1])])\n\n\n# _LT_CONFIG_COMMANDS\n# -------------------\n# Send accumulated output to $CONFIG_STATUS.  Thanks to the lists of\n# variables for single and double quote escaping we saved from calls\n# to _LT_DECL, we can put quote escaped variables declarations\n# into `config.status', and then the shell code to quote escape them in\n# for loops in `config.status'.  Finally, any additional code accumulated\n# from calls to _LT_CONFIG_LIBTOOL_INIT is expanded.\nm4_defun([_LT_CONFIG_COMMANDS],\n[AC_PROVIDE_IFELSE([LT_OUTPUT],\n\tdnl If the libtool generation code has been placed in $CONFIG_LT,\n\tdnl instead of duplicating it all over again into config.status,\n\tdnl then we will have config.status run $CONFIG_LT later, so it\n\tdnl needs to know what name is stored there:\n        [AC_CONFIG_COMMANDS([libtool],\n            [$SHELL $CONFIG_LT || AS_EXIT(1)], [CONFIG_LT='$CONFIG_LT'])],\n    dnl If the libtool generation code is destined for config.status,\n    dnl expand the accumulated commands and init code now:\n    [AC_CONFIG_COMMANDS([libtool],\n        [_LT_OUTPUT_LIBTOOL_COMMANDS], [_LT_OUTPUT_LIBTOOL_COMMANDS_INIT])])\n])#_LT_CONFIG_COMMANDS\n\n\n# Initialize.\nm4_define([_LT_OUTPUT_LIBTOOL_COMMANDS_INIT],\n[\n\n# The HP-UX ksh and POSIX shell print the target directory to stdout\n# if CDPATH is set.\n(unset CDPATH) >/dev/null 2>&1 && unset CDPATH\n\nsed_quote_subst='$sed_quote_subst'\ndouble_quote_subst='$double_quote_subst'\ndelay_variable_subst='$delay_variable_subst'\n_LT_CONFIG_STATUS_DECLARATIONS\nLTCC='$LTCC'\nLTCFLAGS='$LTCFLAGS'\ncompiler='$compiler_DEFAULT'\n\n# A function that is used when there is no print builtin or printf.\nfunc_fallback_echo ()\n{\n  eval 'cat <<_LTECHO_EOF\n\\$[]1\n_LTECHO_EOF'\n}\n\n# Quote evaled strings.\nfor var in lt_decl_all_varnames([[ \\\n]], lt_decl_quote_varnames); do\n    case \\`eval \\\\\\\\\\$ECHO \\\\\\\\\"\"\\\\\\\\\\$\\$var\"\\\\\\\\\"\\` in\n    *[[\\\\\\\\\\\\\\`\\\\\"\\\\\\$]]*)\n      eval \"lt_\\$var=\\\\\\\\\\\\\"\\\\\\`\\\\\\$ECHO \\\\\"\\\\\\$\\$var\\\\\" | \\\\\\$SED \\\\\"\\\\\\$sed_quote_subst\\\\\"\\\\\\`\\\\\\\\\\\\\"\"\n      ;;\n    *)\n      eval \"lt_\\$var=\\\\\\\\\\\\\"\\\\\\$\\$var\\\\\\\\\\\\\"\"\n      ;;\n    esac\ndone\n\n# Double-quote double-evaled strings.\nfor var in lt_decl_all_varnames([[ \\\n]], lt_decl_dquote_varnames); do\n    case \\`eval \\\\\\\\\\$ECHO \\\\\\\\\"\"\\\\\\\\\\$\\$var\"\\\\\\\\\"\\` in\n    *[[\\\\\\\\\\\\\\`\\\\\"\\\\\\$]]*)\n      eval \"lt_\\$var=\\\\\\\\\\\\\"\\\\\\`\\\\\\$ECHO \\\\\"\\\\\\$\\$var\\\\\" | \\\\\\$SED -e \\\\\"\\\\\\$double_quote_subst\\\\\" -e \\\\\"\\\\\\$sed_quote_subst\\\\\" -e \\\\\"\\\\\\$delay_variable_subst\\\\\"\\\\\\`\\\\\\\\\\\\\"\"\n      ;;\n    *)\n      eval \"lt_\\$var=\\\\\\\\\\\\\"\\\\\\$\\$var\\\\\\\\\\\\\"\"\n      ;;\n    esac\ndone\n\n_LT_OUTPUT_LIBTOOL_INIT\n])\n\n# _LT_GENERATED_FILE_INIT(FILE, [COMMENT])\n# ------------------------------------\n# Generate a child script FILE with all initialization necessary to\n# reuse the environment learned by the parent script, and make the\n# file executable.  If COMMENT is supplied, it is inserted after the\n# `#!' sequence but before initialization text begins.  After this\n# macro, additional text can be appended to FILE to form the body of\n# the child script.  The macro ends with non-zero status if the\n# file could not be fully written (such as if the disk is full).\nm4_ifdef([AS_INIT_GENERATED],\n[m4_defun([_LT_GENERATED_FILE_INIT],[AS_INIT_GENERATED($@)])],\n[m4_defun([_LT_GENERATED_FILE_INIT],\n[m4_require([AS_PREPARE])]dnl\n[m4_pushdef([AS_MESSAGE_LOG_FD])]dnl\n[lt_write_fail=0\ncat >$1 <<_ASEOF || lt_write_fail=1\n#! $SHELL\n# Generated by $as_me.\n$2\nSHELL=\\${CONFIG_SHELL-$SHELL}\nexport SHELL\n_ASEOF\ncat >>$1 <<\\_ASEOF || lt_write_fail=1\nAS_SHELL_SANITIZE\n_AS_PREPARE\nexec AS_MESSAGE_FD>&1\n_ASEOF\ntest $lt_write_fail = 0 && chmod +x $1[]dnl\nm4_popdef([AS_MESSAGE_LOG_FD])])])# _LT_GENERATED_FILE_INIT\n\n# LT_OUTPUT\n# ---------\n# This macro allows early generation of the libtool script (before\n# AC_OUTPUT is called), incase it is used in configure for compilation\n# tests.\nAC_DEFUN([LT_OUTPUT],\n[: ${CONFIG_LT=./config.lt}\nAC_MSG_NOTICE([creating $CONFIG_LT])\n_LT_GENERATED_FILE_INIT([\"$CONFIG_LT\"],\n[# Run this file to recreate a libtool stub with the current configuration.])\n\ncat >>\"$CONFIG_LT\" <<\\_LTEOF\nlt_cl_silent=false\nexec AS_MESSAGE_LOG_FD>>config.log\n{\n  echo\n  AS_BOX([Running $as_me.])\n} >&AS_MESSAGE_LOG_FD\n\nlt_cl_help=\"\\\n\\`$as_me' creates a local libtool stub from the current configuration,\nfor use in further configure time tests before the real libtool is\ngenerated.\n\nUsage: $[0] [[OPTIONS]]\n\n  -h, --help      print this help, then exit\n  -V, --version   print version number, then exit\n  -q, --quiet     do not print progress messages\n  -d, --debug     don't remove temporary files\n\nReport bugs to <bug-libtool@gnu.org>.\"\n\nlt_cl_version=\"\\\nm4_ifset([AC_PACKAGE_NAME], [AC_PACKAGE_NAME ])config.lt[]dnl\nm4_ifset([AC_PACKAGE_VERSION], [ AC_PACKAGE_VERSION])\nconfigured by $[0], generated by m4_PACKAGE_STRING.\n\nCopyright (C) 2011 Free Software Foundation, Inc.\nThis config.lt script is free software; the Free Software Foundation\ngives unlimited permision to copy, distribute and modify it.\"\n\nwhile test $[#] != 0\ndo\n  case $[1] in\n    --version | --v* | -V )\n      echo \"$lt_cl_version\"; exit 0 ;;\n    --help | --h* | -h )\n      echo \"$lt_cl_help\"; exit 0 ;;\n    --debug | --d* | -d )\n      debug=: ;;\n    --quiet | --q* | --silent | --s* | -q )\n      lt_cl_silent=: ;;\n\n    -*) AC_MSG_ERROR([unrecognized option: $[1]\nTry \\`$[0] --help' for more information.]) ;;\n\n    *) AC_MSG_ERROR([unrecognized argument: $[1]\nTry \\`$[0] --help' for more information.]) ;;\n  esac\n  shift\ndone\n\nif $lt_cl_silent; then\n  exec AS_MESSAGE_FD>/dev/null\nfi\n_LTEOF\n\ncat >>\"$CONFIG_LT\" <<_LTEOF\n_LT_OUTPUT_LIBTOOL_COMMANDS_INIT\n_LTEOF\n\ncat >>\"$CONFIG_LT\" <<\\_LTEOF\nAC_MSG_NOTICE([creating $ofile])\n_LT_OUTPUT_LIBTOOL_COMMANDS\nAS_EXIT(0)\n_LTEOF\nchmod +x \"$CONFIG_LT\"\n\n# configure is writing to config.log, but config.lt does its own redirection,\n# appending to config.log, which fails on DOS, as config.log is still kept\n# open by configure.  Here we exec the FD to /dev/null, effectively closing\n# config.log, so it can be properly (re)opened and appended to by config.lt.\nlt_cl_success=:\ntest \"$silent\" = yes &&\n  lt_config_lt_args=\"$lt_config_lt_args --quiet\"\nexec AS_MESSAGE_LOG_FD>/dev/null\n$SHELL \"$CONFIG_LT\" $lt_config_lt_args || lt_cl_success=false\nexec AS_MESSAGE_LOG_FD>>config.log\n$lt_cl_success || AS_EXIT(1)\n])# LT_OUTPUT\n\n\n# _LT_CONFIG(TAG)\n# ---------------\n# If TAG is the built-in tag, create an initial libtool script with a\n# default configuration from the untagged config vars.  Otherwise add code\n# to config.status for appending the configuration named by TAG from the\n# matching tagged config vars.\nm4_defun([_LT_CONFIG],\n[m4_require([_LT_FILEUTILS_DEFAULTS])dnl\n_LT_CONFIG_SAVE_COMMANDS([\n  m4_define([_LT_TAG], m4_if([$1], [], [C], [$1]))dnl\n  m4_if(_LT_TAG, [C], [\n    # See if we are running on zsh, and set the options which allow our\n    # commands through without removal of \\ escapes.\n    if test -n \"${ZSH_VERSION+set}\" ; then\n      setopt NO_GLOB_SUBST\n    fi\n\n    cfgfile=\"${ofile}T\"\n    trap \"$RM \\\"$cfgfile\\\"; exit 1\" 1 2 15\n    $RM \"$cfgfile\"\n\n    cat <<_LT_EOF >> \"$cfgfile\"\n#! $SHELL\n\n# `$ECHO \"$ofile\" | sed 's%^.*/%%'` - Provide generalized library-building support services.\n# Generated automatically by $as_me ($PACKAGE$TIMESTAMP) $VERSION\n# Libtool was configured on host `(hostname || uname -n) 2>/dev/null | sed 1q`:\n# NOTE: Changes made to this file will be lost: look at ltmain.sh.\n#\n_LT_COPYING\n_LT_LIBTOOL_TAGS\n\n# ### BEGIN LIBTOOL CONFIG\n_LT_LIBTOOL_CONFIG_VARS\n_LT_LIBTOOL_TAG_VARS\n# ### END LIBTOOL CONFIG\n\n_LT_EOF\n\n  case $host_os in\n  aix3*)\n    cat <<\\_LT_EOF >> \"$cfgfile\"\n# AIX sometimes has problems with the GCC collect2 program.  For some\n# reason, if we set the COLLECT_NAMES environment variable, the problems\n# vanish in a puff of smoke.\nif test \"X${COLLECT_NAMES+set}\" != Xset; then\n  COLLECT_NAMES=\n  export COLLECT_NAMES\nfi\n_LT_EOF\n    ;;\n  esac\n\n  _LT_PROG_LTMAIN\n\n  # We use sed instead of cat because bash on DJGPP gets confused if\n  # if finds mixed CR/LF and LF-only lines.  Since sed operates in\n  # text mode, it properly converts lines to CR/LF.  This bash problem\n  # is reportedly fixed, but why not run on old versions too?\n  sed '$q' \"$ltmain\" >> \"$cfgfile\" \\\n     || (rm -f \"$cfgfile\"; exit 1)\n\n  _LT_PROG_REPLACE_SHELLFNS\n\n   mv -f \"$cfgfile\" \"$ofile\" ||\n    (rm -f \"$ofile\" && cp \"$cfgfile\" \"$ofile\" && rm -f \"$cfgfile\")\n  chmod +x \"$ofile\"\n],\n[cat <<_LT_EOF >> \"$ofile\"\n\ndnl Unfortunately we have to use $1 here, since _LT_TAG is not expanded\ndnl in a comment (ie after a #).\n# ### BEGIN LIBTOOL TAG CONFIG: $1\n_LT_LIBTOOL_TAG_VARS(_LT_TAG)\n# ### END LIBTOOL TAG CONFIG: $1\n_LT_EOF\n])dnl /m4_if\n],\n[m4_if([$1], [], [\n    PACKAGE='$PACKAGE'\n    VERSION='$VERSION'\n    TIMESTAMP='$TIMESTAMP'\n    RM='$RM'\n    ofile='$ofile'], [])\n])dnl /_LT_CONFIG_SAVE_COMMANDS\n])# _LT_CONFIG\n\n\n# LT_SUPPORTED_TAG(TAG)\n# ---------------------\n# Trace this macro to discover what tags are supported by the libtool\n# --tag option, using:\n#    autoconf --trace 'LT_SUPPORTED_TAG:$1'\nAC_DEFUN([LT_SUPPORTED_TAG], [])\n\n\n# C support is built-in for now\nm4_define([_LT_LANG_C_enabled], [])\nm4_define([_LT_TAGS], [])\n\n\n# LT_LANG(LANG)\n# -------------\n# Enable libtool support for the given language if not already enabled.\nAC_DEFUN([LT_LANG],\n[AC_BEFORE([$0], [LT_OUTPUT])dnl\nm4_case([$1],\n  [C],\t\t\t[_LT_LANG(C)],\n  [C++],\t\t[_LT_LANG(CXX)],\n  [Go],\t\t\t[_LT_LANG(GO)],\n  [Java],\t\t[_LT_LANG(GCJ)],\n  [Fortran 77],\t\t[_LT_LANG(F77)],\n  [Fortran],\t\t[_LT_LANG(FC)],\n  [Windows Resource],\t[_LT_LANG(RC)],\n  [m4_ifdef([_LT_LANG_]$1[_CONFIG],\n    [_LT_LANG($1)],\n    [m4_fatal([$0: unsupported language: \"$1\"])])])dnl\n])# LT_LANG\n\n\n# _LT_LANG(LANGNAME)\n# ------------------\nm4_defun([_LT_LANG],\n[m4_ifdef([_LT_LANG_]$1[_enabled], [],\n  [LT_SUPPORTED_TAG([$1])dnl\n  m4_append([_LT_TAGS], [$1 ])dnl\n  m4_define([_LT_LANG_]$1[_enabled], [])dnl\n  _LT_LANG_$1_CONFIG($1)])dnl\n])# _LT_LANG\n\n\nm4_ifndef([AC_PROG_GO], [\n# NOTE: This macro has been submitted for inclusion into   #\n#  GNU Autoconf as AC_PROG_GO.  When it is available in    #\n#  a released version of Autoconf we should remove this    #\n#  macro and use it instead.                               #\nm4_defun([AC_PROG_GO],\n[AC_LANG_PUSH(Go)dnl\nAC_ARG_VAR([GOC],     [Go compiler command])dnl\nAC_ARG_VAR([GOFLAGS], [Go compiler flags])dnl\n_AC_ARG_VAR_LDFLAGS()dnl\nAC_CHECK_TOOL(GOC, gccgo)\nif test -z \"$GOC\"; then\n  if test -n \"$ac_tool_prefix\"; then\n    AC_CHECK_PROG(GOC, [${ac_tool_prefix}gccgo], [${ac_tool_prefix}gccgo])\n  fi\nfi\nif test -z \"$GOC\"; then\n  AC_CHECK_PROG(GOC, gccgo, gccgo, false)\nfi\n])#m4_defun\n])#m4_ifndef\n\n\n# _LT_LANG_DEFAULT_CONFIG\n# -----------------------\nm4_defun([_LT_LANG_DEFAULT_CONFIG],\n[AC_PROVIDE_IFELSE([AC_PROG_CXX],\n  [LT_LANG(CXX)],\n  [m4_define([AC_PROG_CXX], defn([AC_PROG_CXX])[LT_LANG(CXX)])])\n\nAC_PROVIDE_IFELSE([AC_PROG_F77],\n  [LT_LANG(F77)],\n  [m4_define([AC_PROG_F77], defn([AC_PROG_F77])[LT_LANG(F77)])])\n\nAC_PROVIDE_IFELSE([AC_PROG_FC],\n  [LT_LANG(FC)],\n  [m4_define([AC_PROG_FC], defn([AC_PROG_FC])[LT_LANG(FC)])])\n\ndnl The call to [A][M_PROG_GCJ] is quoted like that to stop aclocal\ndnl pulling things in needlessly.\nAC_PROVIDE_IFELSE([AC_PROG_GCJ],\n  [LT_LANG(GCJ)],\n  [AC_PROVIDE_IFELSE([A][M_PROG_GCJ],\n    [LT_LANG(GCJ)],\n    [AC_PROVIDE_IFELSE([LT_PROG_GCJ],\n      [LT_LANG(GCJ)],\n      [m4_ifdef([AC_PROG_GCJ],\n\t[m4_define([AC_PROG_GCJ], defn([AC_PROG_GCJ])[LT_LANG(GCJ)])])\n       m4_ifdef([A][M_PROG_GCJ],\n\t[m4_define([A][M_PROG_GCJ], defn([A][M_PROG_GCJ])[LT_LANG(GCJ)])])\n       m4_ifdef([LT_PROG_GCJ],\n\t[m4_define([LT_PROG_GCJ], defn([LT_PROG_GCJ])[LT_LANG(GCJ)])])])])])\n\nAC_PROVIDE_IFELSE([AC_PROG_GO],\n  [LT_LANG(GO)],\n  [m4_define([AC_PROG_GO], defn([AC_PROG_GO])[LT_LANG(GO)])])\n\nAC_PROVIDE_IFELSE([LT_PROG_RC],\n  [LT_LANG(RC)],\n  [m4_define([LT_PROG_RC], defn([LT_PROG_RC])[LT_LANG(RC)])])\n])# _LT_LANG_DEFAULT_CONFIG\n\n# Obsolete macros:\nAU_DEFUN([AC_LIBTOOL_CXX], [LT_LANG(C++)])\nAU_DEFUN([AC_LIBTOOL_F77], [LT_LANG(Fortran 77)])\nAU_DEFUN([AC_LIBTOOL_FC], [LT_LANG(Fortran)])\nAU_DEFUN([AC_LIBTOOL_GCJ], [LT_LANG(Java)])\nAU_DEFUN([AC_LIBTOOL_RC], [LT_LANG(Windows Resource)])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_CXX], [])\ndnl AC_DEFUN([AC_LIBTOOL_F77], [])\ndnl AC_DEFUN([AC_LIBTOOL_FC], [])\ndnl AC_DEFUN([AC_LIBTOOL_GCJ], [])\ndnl AC_DEFUN([AC_LIBTOOL_RC], [])\n\n\n# _LT_TAG_COMPILER\n# ----------------\nm4_defun([_LT_TAG_COMPILER],\n[AC_REQUIRE([AC_PROG_CC])dnl\n\n_LT_DECL([LTCC], [CC], [1], [A C compiler])dnl\n_LT_DECL([LTCFLAGS], [CFLAGS], [1], [LTCC compiler flags])dnl\n_LT_TAGDECL([CC], [compiler], [1], [A language specific compiler])dnl\n_LT_TAGDECL([with_gcc], [GCC], [0], [Is the compiler the GNU compiler?])dnl\n\n# If no C compiler was specified, use CC.\nLTCC=${LTCC-\"$CC\"}\n\n# If no C compiler flags were specified, use CFLAGS.\nLTCFLAGS=${LTCFLAGS-\"$CFLAGS\"}\n\n# Allow CC to be a program name with arguments.\ncompiler=$CC\n])# _LT_TAG_COMPILER\n\n\n# _LT_COMPILER_BOILERPLATE\n# ------------------------\n# Check for compiler boilerplate output or warnings with\n# the simple compiler test code.\nm4_defun([_LT_COMPILER_BOILERPLATE],\n[m4_require([_LT_DECL_SED])dnl\nac_outfile=conftest.$ac_objext\necho \"$lt_simple_compile_test_code\" >conftest.$ac_ext\neval \"$ac_compile\" 2>&1 >/dev/null | $SED '/^$/d; /^ *+/d' >conftest.err\n_lt_compiler_boilerplate=`cat conftest.err`\n$RM conftest*\n])# _LT_COMPILER_BOILERPLATE\n\n\n# _LT_LINKER_BOILERPLATE\n# ----------------------\n# Check for linker boilerplate output or warnings with\n# the simple link test code.\nm4_defun([_LT_LINKER_BOILERPLATE],\n[m4_require([_LT_DECL_SED])dnl\nac_outfile=conftest.$ac_objext\necho \"$lt_simple_link_test_code\" >conftest.$ac_ext\neval \"$ac_link\" 2>&1 >/dev/null | $SED '/^$/d; /^ *+/d' >conftest.err\n_lt_linker_boilerplate=`cat conftest.err`\n$RM -r conftest*\n])# _LT_LINKER_BOILERPLATE\n\n# _LT_REQUIRED_DARWIN_CHECKS\n# -------------------------\nm4_defun_once([_LT_REQUIRED_DARWIN_CHECKS],[\n  case $host_os in\n    rhapsody* | darwin*)\n    AC_CHECK_TOOL([DSYMUTIL], [dsymutil], [:])\n    AC_CHECK_TOOL([NMEDIT], [nmedit], [:])\n    AC_CHECK_TOOL([LIPO], [lipo], [:])\n    AC_CHECK_TOOL([OTOOL], [otool], [:])\n    AC_CHECK_TOOL([OTOOL64], [otool64], [:])\n    _LT_DECL([], [DSYMUTIL], [1],\n      [Tool to manipulate archived DWARF debug symbol files on Mac OS X])\n    _LT_DECL([], [NMEDIT], [1],\n      [Tool to change global to local symbols on Mac OS X])\n    _LT_DECL([], [LIPO], [1],\n      [Tool to manipulate fat objects and archives on Mac OS X])\n    _LT_DECL([], [OTOOL], [1],\n      [ldd/readelf like tool for Mach-O binaries on Mac OS X])\n    _LT_DECL([], [OTOOL64], [1],\n      [ldd/readelf like tool for 64 bit Mach-O binaries on Mac OS X 10.4])\n\n    AC_CACHE_CHECK([for -single_module linker flag],[lt_cv_apple_cc_single_mod],\n      [lt_cv_apple_cc_single_mod=no\n      if test -z \"${LT_MULTI_MODULE}\"; then\n\t# By default we will add the -single_module flag. You can override\n\t# by either setting the environment variable LT_MULTI_MODULE\n\t# non-empty at configure time, or by adding -multi_module to the\n\t# link flags.\n\trm -rf libconftest.dylib*\n\techo \"int foo(void){return 1;}\" > conftest.c\n\techo \"$LTCC $LTCFLAGS $LDFLAGS -o libconftest.dylib \\\n-dynamiclib -Wl,-single_module conftest.c\" >&AS_MESSAGE_LOG_FD\n\t$LTCC $LTCFLAGS $LDFLAGS -o libconftest.dylib \\\n\t  -dynamiclib -Wl,-single_module conftest.c 2>conftest.err\n        _lt_result=$?\n\t# If there is a non-empty error log, and \"single_module\"\n\t# appears in it, assume the flag caused a linker warning\n        if test -s conftest.err && $GREP single_module conftest.err; then\n\t  cat conftest.err >&AS_MESSAGE_LOG_FD\n\t# Otherwise, if the output was created with a 0 exit code from\n\t# the compiler, it worked.\n\telif test -f libconftest.dylib && test $_lt_result -eq 0; then\n\t  lt_cv_apple_cc_single_mod=yes\n\telse\n\t  cat conftest.err >&AS_MESSAGE_LOG_FD\n\tfi\n\trm -rf libconftest.dylib*\n\trm -f conftest.*\n      fi])\n\n    AC_CACHE_CHECK([for -exported_symbols_list linker flag],\n      [lt_cv_ld_exported_symbols_list],\n      [lt_cv_ld_exported_symbols_list=no\n      save_LDFLAGS=$LDFLAGS\n      echo \"_main\" > conftest.sym\n      LDFLAGS=\"$LDFLAGS -Wl,-exported_symbols_list,conftest.sym\"\n      AC_LINK_IFELSE([AC_LANG_PROGRAM([],[])],\n\t[lt_cv_ld_exported_symbols_list=yes],\n\t[lt_cv_ld_exported_symbols_list=no])\n\tLDFLAGS=\"$save_LDFLAGS\"\n    ])\n\n    AC_CACHE_CHECK([for -force_load linker flag],[lt_cv_ld_force_load],\n      [lt_cv_ld_force_load=no\n      cat > conftest.c << _LT_EOF\nint forced_loaded() { return 2;}\n_LT_EOF\n      echo \"$LTCC $LTCFLAGS -c -o conftest.o conftest.c\" >&AS_MESSAGE_LOG_FD\n      $LTCC $LTCFLAGS -c -o conftest.o conftest.c 2>&AS_MESSAGE_LOG_FD\n      echo \"$AR cru libconftest.a conftest.o\" >&AS_MESSAGE_LOG_FD\n      $AR cru libconftest.a conftest.o 2>&AS_MESSAGE_LOG_FD\n      echo \"$RANLIB libconftest.a\" >&AS_MESSAGE_LOG_FD\n      $RANLIB libconftest.a 2>&AS_MESSAGE_LOG_FD\n      cat > conftest.c << _LT_EOF\nint main() { return 0;}\n_LT_EOF\n      echo \"$LTCC $LTCFLAGS $LDFLAGS -o conftest conftest.c -Wl,-force_load,./libconftest.a\" >&AS_MESSAGE_LOG_FD\n      $LTCC $LTCFLAGS $LDFLAGS -o conftest conftest.c -Wl,-force_load,./libconftest.a 2>conftest.err\n      _lt_result=$?\n      if test -s conftest.err && $GREP force_load conftest.err; then\n\tcat conftest.err >&AS_MESSAGE_LOG_FD\n      elif test -f conftest && test $_lt_result -eq 0 && $GREP forced_load conftest >/dev/null 2>&1 ; then\n\tlt_cv_ld_force_load=yes\n      else\n\tcat conftest.err >&AS_MESSAGE_LOG_FD\n      fi\n        rm -f conftest.err libconftest.a conftest conftest.c\n        rm -rf conftest.dSYM\n    ])\n    case $host_os in\n    rhapsody* | darwin1.[[012]])\n      _lt_dar_allow_undefined='${wl}-undefined ${wl}suppress' ;;\n    darwin1.*)\n      _lt_dar_allow_undefined='${wl}-flat_namespace ${wl}-undefined ${wl}suppress' ;;\n    darwin*) # darwin 5.x on\n      # if running on 10.5 or later, the deployment target defaults\n      # to the OS version, if on x86, and 10.4, the deployment\n      # target defaults to 10.4. Don't you love it?\n      case ${MACOSX_DEPLOYMENT_TARGET-10.0},$host in\n\t10.0,*86*-darwin8*|10.0,*-darwin[[91]]*)\n\t  _lt_dar_allow_undefined='${wl}-undefined ${wl}dynamic_lookup' ;;\n\t10.[[012]]*)\n\t  _lt_dar_allow_undefined='${wl}-flat_namespace ${wl}-undefined ${wl}suppress' ;;\n\t10.*)\n\t  _lt_dar_allow_undefined='${wl}-undefined ${wl}dynamic_lookup' ;;\n      esac\n    ;;\n  esac\n    if test \"$lt_cv_apple_cc_single_mod\" = \"yes\"; then\n      _lt_dar_single_mod='$single_module'\n    fi\n    if test \"$lt_cv_ld_exported_symbols_list\" = \"yes\"; then\n      _lt_dar_export_syms=' ${wl}-exported_symbols_list,$output_objdir/${libname}-symbols.expsym'\n    else\n      _lt_dar_export_syms='~$NMEDIT -s $output_objdir/${libname}-symbols.expsym ${lib}'\n    fi\n    if test \"$DSYMUTIL\" != \":\" && test \"$lt_cv_ld_force_load\" = \"no\"; then\n      _lt_dsymutil='~$DSYMUTIL $lib || :'\n    else\n      _lt_dsymutil=\n    fi\n    ;;\n  esac\n])\n\n\n# _LT_DARWIN_LINKER_FEATURES([TAG])\n# ---------------------------------\n# Checks for linker and compiler features on darwin\nm4_defun([_LT_DARWIN_LINKER_FEATURES],\n[\n  m4_require([_LT_REQUIRED_DARWIN_CHECKS])\n  _LT_TAGVAR(archive_cmds_need_lc, $1)=no\n  _LT_TAGVAR(hardcode_direct, $1)=no\n  _LT_TAGVAR(hardcode_automatic, $1)=yes\n  _LT_TAGVAR(hardcode_shlibpath_var, $1)=unsupported\n  if test \"$lt_cv_ld_force_load\" = \"yes\"; then\n    _LT_TAGVAR(whole_archive_flag_spec, $1)='`for conv in $convenience\\\"\\\"; do test  -n \\\"$conv\\\" && new_convenience=\\\"$new_convenience ${wl}-force_load,$conv\\\"; done; func_echo_all \\\"$new_convenience\\\"`'\n    m4_case([$1], [F77], [_LT_TAGVAR(compiler_needs_object, $1)=yes],\n                  [FC],  [_LT_TAGVAR(compiler_needs_object, $1)=yes])\n  else\n    _LT_TAGVAR(whole_archive_flag_spec, $1)=''\n  fi\n  _LT_TAGVAR(link_all_deplibs, $1)=yes\n  _LT_TAGVAR(allow_undefined_flag, $1)=\"$_lt_dar_allow_undefined\"\n  case $cc_basename in\n     ifort*) _lt_dar_can_shared=yes ;;\n     *) _lt_dar_can_shared=$GCC ;;\n  esac\n  if test \"$_lt_dar_can_shared\" = \"yes\"; then\n    output_verbose_link_cmd=func_echo_all\n    _LT_TAGVAR(archive_cmds, $1)=\"\\$CC -dynamiclib \\$allow_undefined_flag -o \\$lib \\$libobjs \\$deplibs \\$compiler_flags -install_name \\$rpath/\\$soname \\$verstring $_lt_dar_single_mod${_lt_dsymutil}\"\n    _LT_TAGVAR(module_cmds, $1)=\"\\$CC \\$allow_undefined_flag -o \\$lib -bundle \\$libobjs \\$deplibs \\$compiler_flags${_lt_dsymutil}\"\n    _LT_TAGVAR(archive_expsym_cmds, $1)=\"sed 's,^,_,' < \\$export_symbols > \\$output_objdir/\\${libname}-symbols.expsym~\\$CC -dynamiclib \\$allow_undefined_flag -o \\$lib \\$libobjs \\$deplibs \\$compiler_flags -install_name \\$rpath/\\$soname \\$verstring ${_lt_dar_single_mod}${_lt_dar_export_syms}${_lt_dsymutil}\"\n    _LT_TAGVAR(module_expsym_cmds, $1)=\"sed -e 's,^,_,' < \\$export_symbols > \\$output_objdir/\\${libname}-symbols.expsym~\\$CC \\$allow_undefined_flag -o \\$lib -bundle \\$libobjs \\$deplibs \\$compiler_flags${_lt_dar_export_syms}${_lt_dsymutil}\"\n    m4_if([$1], [CXX],\n[   if test \"$lt_cv_apple_cc_single_mod\" != \"yes\"; then\n      _LT_TAGVAR(archive_cmds, $1)=\"\\$CC -r -keep_private_externs -nostdlib -o \\${lib}-master.o \\$libobjs~\\$CC -dynamiclib \\$allow_undefined_flag -o \\$lib \\${lib}-master.o \\$deplibs \\$compiler_flags -install_name \\$rpath/\\$soname \\$verstring${_lt_dsymutil}\"\n      _LT_TAGVAR(archive_expsym_cmds, $1)=\"sed 's,^,_,' < \\$export_symbols > \\$output_objdir/\\${libname}-symbols.expsym~\\$CC -r -keep_private_externs -nostdlib -o \\${lib}-master.o \\$libobjs~\\$CC -dynamiclib \\$allow_undefined_flag -o \\$lib \\${lib}-master.o \\$deplibs \\$compiler_flags -install_name \\$rpath/\\$soname \\$verstring${_lt_dar_export_syms}${_lt_dsymutil}\"\n    fi\n],[])\n  else\n  _LT_TAGVAR(ld_shlibs, $1)=no\n  fi\n])\n\n# _LT_SYS_MODULE_PATH_AIX([TAGNAME])\n# ----------------------------------\n# Links a minimal program and checks the executable\n# for the system default hardcoded library path. In most cases,\n# this is /usr/lib:/lib, but when the MPI compilers are used\n# the location of the communication and MPI libs are included too.\n# If we don't find anything, use the default library path according\n# to the aix ld manual.\n# Store the results from the different compilers for each TAGNAME.\n# Allow to override them for all tags through lt_cv_aix_libpath.\nm4_defun([_LT_SYS_MODULE_PATH_AIX],\n[m4_require([_LT_DECL_SED])dnl\nif test \"${lt_cv_aix_libpath+set}\" = set; then\n  aix_libpath=$lt_cv_aix_libpath\nelse\n  AC_CACHE_VAL([_LT_TAGVAR([lt_cv_aix_libpath_], [$1])],\n  [AC_LINK_IFELSE([AC_LANG_PROGRAM],[\n  lt_aix_libpath_sed='[\n      /Import File Strings/,/^$/ {\n\t  /^0/ {\n\t      s/^0  *\\([^ ]*\\) *$/\\1/\n\t      p\n\t  }\n      }]'\n  _LT_TAGVAR([lt_cv_aix_libpath_], [$1])=`dump -H conftest$ac_exeext 2>/dev/null | $SED -n -e \"$lt_aix_libpath_sed\"`\n  # Check for a 64-bit object if we didn't find anything.\n  if test -z \"$_LT_TAGVAR([lt_cv_aix_libpath_], [$1])\"; then\n    _LT_TAGVAR([lt_cv_aix_libpath_], [$1])=`dump -HX64 conftest$ac_exeext 2>/dev/null | $SED -n -e \"$lt_aix_libpath_sed\"`\n  fi],[])\n  if test -z \"$_LT_TAGVAR([lt_cv_aix_libpath_], [$1])\"; then\n    _LT_TAGVAR([lt_cv_aix_libpath_], [$1])=\"/usr/lib:/lib\"\n  fi\n  ])\n  aix_libpath=$_LT_TAGVAR([lt_cv_aix_libpath_], [$1])\nfi\n])# _LT_SYS_MODULE_PATH_AIX\n\n\n# _LT_SHELL_INIT(ARG)\n# -------------------\nm4_define([_LT_SHELL_INIT],\n[m4_divert_text([M4SH-INIT], [$1\n])])# _LT_SHELL_INIT\n\n\n\n# _LT_PROG_ECHO_BACKSLASH\n# -----------------------\n# Find how we can fake an echo command that does not interpret backslash.\n# In particular, with Autoconf 2.60 or later we add some code to the start\n# of the generated configure script which will find a shell with a builtin\n# printf (which we can use as an echo command).\nm4_defun([_LT_PROG_ECHO_BACKSLASH],\n[ECHO='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\nECHO=$ECHO$ECHO$ECHO$ECHO$ECHO\nECHO=$ECHO$ECHO$ECHO$ECHO$ECHO$ECHO\n\nAC_MSG_CHECKING([how to print strings])\n# Test print first, because it will be a builtin if present.\nif test \"X`( print -r -- -n ) 2>/dev/null`\" = X-n && \\\n   test \"X`print -r -- $ECHO 2>/dev/null`\" = \"X$ECHO\"; then\n  ECHO='print -r --'\nelif test \"X`printf %s $ECHO 2>/dev/null`\" = \"X$ECHO\"; then\n  ECHO='printf %s\\n'\nelse\n  # Use this function as a fallback that always works.\n  func_fallback_echo ()\n  {\n    eval 'cat <<_LTECHO_EOF\n$[]1\n_LTECHO_EOF'\n  }\n  ECHO='func_fallback_echo'\nfi\n\n# func_echo_all arg...\n# Invoke $ECHO with all args, space-separated.\nfunc_echo_all ()\n{\n    $ECHO \"$*\" \n}\n\ncase \"$ECHO\" in\n  printf*) AC_MSG_RESULT([printf]) ;;\n  print*) AC_MSG_RESULT([print -r]) ;;\n  *) AC_MSG_RESULT([cat]) ;;\nesac\n\nm4_ifdef([_AS_DETECT_SUGGESTED],\n[_AS_DETECT_SUGGESTED([\n  test -n \"${ZSH_VERSION+set}${BASH_VERSION+set}\" || (\n    ECHO='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\n    ECHO=$ECHO$ECHO$ECHO$ECHO$ECHO\n    ECHO=$ECHO$ECHO$ECHO$ECHO$ECHO$ECHO\n    PATH=/empty FPATH=/empty; export PATH FPATH\n    test \"X`printf %s $ECHO`\" = \"X$ECHO\" \\\n      || test \"X`print -r -- $ECHO`\" = \"X$ECHO\" )])])\n\n_LT_DECL([], [SHELL], [1], [Shell to use when invoking shell scripts])\n_LT_DECL([], [ECHO], [1], [An echo program that protects backslashes])\n])# _LT_PROG_ECHO_BACKSLASH\n\n\n# _LT_WITH_SYSROOT\n# ----------------\nAC_DEFUN([_LT_WITH_SYSROOT],\n[AC_MSG_CHECKING([for sysroot])\nAC_ARG_WITH([sysroot],\n[  --with-sysroot[=DIR] Search for dependent libraries within DIR\n                        (or the compiler's sysroot if not specified).],\n[], [with_sysroot=no])\n\ndnl lt_sysroot will always be passed unquoted.  We quote it here\ndnl in case the user passed a directory name.\nlt_sysroot=\ncase ${with_sysroot} in #(\n yes)\n   if test \"$GCC\" = yes; then\n     lt_sysroot=`$CC --print-sysroot 2>/dev/null`\n   fi\n   ;; #(\n /*)\n   lt_sysroot=`echo \"$with_sysroot\" | sed -e \"$sed_quote_subst\"`\n   ;; #(\n no|'')\n   ;; #(\n *)\n   AC_MSG_RESULT([${with_sysroot}])\n   AC_MSG_ERROR([The sysroot must be an absolute path.])\n   ;;\nesac\n\n AC_MSG_RESULT([${lt_sysroot:-no}])\n_LT_DECL([], [lt_sysroot], [0], [The root where to search for ]dnl\n[dependent libraries, and in which our libraries should be installed.])])\n\n# _LT_ENABLE_LOCK\n# ---------------\nm4_defun([_LT_ENABLE_LOCK],\n[AC_ARG_ENABLE([libtool-lock],\n  [AS_HELP_STRING([--disable-libtool-lock],\n    [avoid locking (might break parallel builds)])])\ntest \"x$enable_libtool_lock\" != xno && enable_libtool_lock=yes\n\n# Some flags need to be propagated to the compiler or linker for good\n# libtool support.\ncase $host in\nia64-*-hpux*)\n  # Find out which ABI we are using.\n  echo 'int i;' > conftest.$ac_ext\n  if AC_TRY_EVAL(ac_compile); then\n    case `/usr/bin/file conftest.$ac_objext` in\n      *ELF-32*)\n\tHPUX_IA64_MODE=\"32\"\n\t;;\n      *ELF-64*)\n\tHPUX_IA64_MODE=\"64\"\n\t;;\n    esac\n  fi\n  rm -rf conftest*\n  ;;\n*-*-irix6*)\n  # Find out which ABI we are using.\n  echo '[#]line '$LINENO' \"configure\"' > conftest.$ac_ext\n  if AC_TRY_EVAL(ac_compile); then\n    if test \"$lt_cv_prog_gnu_ld\" = yes; then\n      case `/usr/bin/file conftest.$ac_objext` in\n\t*32-bit*)\n\t  LD=\"${LD-ld} -melf32bsmip\"\n\t  ;;\n\t*N32*)\n\t  LD=\"${LD-ld} -melf32bmipn32\"\n\t  ;;\n\t*64-bit*)\n\t  LD=\"${LD-ld} -melf64bmip\"\n\t;;\n      esac\n    else\n      case `/usr/bin/file conftest.$ac_objext` in\n\t*32-bit*)\n\t  LD=\"${LD-ld} -32\"\n\t  ;;\n\t*N32*)\n\t  LD=\"${LD-ld} -n32\"\n\t  ;;\n\t*64-bit*)\n\t  LD=\"${LD-ld} -64\"\n\t  ;;\n      esac\n    fi\n  fi\n  rm -rf conftest*\n  ;;\n\nx86_64-*kfreebsd*-gnu|x86_64-*linux*|ppc*-*linux*|powerpc*-*linux*| \\\ns390*-*linux*|s390*-*tpf*|sparc*-*linux*)\n  # Find out which ABI we are using.\n  echo 'int i;' > conftest.$ac_ext\n  if AC_TRY_EVAL(ac_compile); then\n    case `/usr/bin/file conftest.o` in\n      *32-bit*)\n\tcase $host in\n\t  x86_64-*kfreebsd*-gnu)\n\t    LD=\"${LD-ld} -m elf_i386_fbsd\"\n\t    ;;\n\t  x86_64-*linux*)\n\t    LD=\"${LD-ld} -m elf_i386\"\n\t    ;;\n\t  ppc64-*linux*|powerpc64-*linux*)\n\t    LD=\"${LD-ld} -m elf32ppclinux\"\n\t    ;;\n\t  s390x-*linux*)\n\t    LD=\"${LD-ld} -m elf_s390\"\n\t    ;;\n\t  sparc64-*linux*)\n\t    LD=\"${LD-ld} -m elf32_sparc\"\n\t    ;;\n\tesac\n\t;;\n      *64-bit*)\n\tcase $host in\n\t  x86_64-*kfreebsd*-gnu)\n\t    LD=\"${LD-ld} -m elf_x86_64_fbsd\"\n\t    ;;\n\t  x86_64-*linux*)\n\t    LD=\"${LD-ld} -m elf_x86_64\"\n\t    ;;\n\t  ppc*-*linux*|powerpc*-*linux*)\n\t    LD=\"${LD-ld} -m elf64ppc\"\n\t    ;;\n\t  s390*-*linux*|s390*-*tpf*)\n\t    LD=\"${LD-ld} -m elf64_s390\"\n\t    ;;\n\t  sparc*-*linux*)\n\t    LD=\"${LD-ld} -m elf64_sparc\"\n\t    ;;\n\tesac\n\t;;\n    esac\n  fi\n  rm -rf conftest*\n  ;;\n\n*-*-sco3.2v5*)\n  # On SCO OpenServer 5, we need -belf to get full-featured binaries.\n  SAVE_CFLAGS=\"$CFLAGS\"\n  CFLAGS=\"$CFLAGS -belf\"\n  AC_CACHE_CHECK([whether the C compiler needs -belf], lt_cv_cc_needs_belf,\n    [AC_LANG_PUSH(C)\n     AC_LINK_IFELSE([AC_LANG_PROGRAM([[]],[[]])],[lt_cv_cc_needs_belf=yes],[lt_cv_cc_needs_belf=no])\n     AC_LANG_POP])\n  if test x\"$lt_cv_cc_needs_belf\" != x\"yes\"; then\n    # this is probably gcc 2.8.0, egcs 1.0 or newer; no need for -belf\n    CFLAGS=\"$SAVE_CFLAGS\"\n  fi\n  ;;\n*-*solaris*)\n  # Find out which ABI we are using.\n  echo 'int i;' > conftest.$ac_ext\n  if AC_TRY_EVAL(ac_compile); then\n    case `/usr/bin/file conftest.o` in\n    *64-bit*)\n      case $lt_cv_prog_gnu_ld in\n      yes*)\n        case $host in\n        i?86-*-solaris*)\n          LD=\"${LD-ld} -m elf_x86_64\"\n          ;;\n        sparc*-*-solaris*)\n          LD=\"${LD-ld} -m elf64_sparc\"\n          ;;\n        esac\n        # GNU ld 2.21 introduced _sol2 emulations.  Use them if available.\n        if ${LD-ld} -V | grep _sol2 >/dev/null 2>&1; then\n          LD=\"${LD-ld}_sol2\"\n        fi\n        ;;\n      *)\n\tif ${LD-ld} -64 -r -o conftest2.o conftest.o >/dev/null 2>&1; then\n\t  LD=\"${LD-ld} -64\"\n\tfi\n\t;;\n      esac\n      ;;\n    esac\n  fi\n  rm -rf conftest*\n  ;;\nesac\n\nneed_locks=\"$enable_libtool_lock\"\n])# _LT_ENABLE_LOCK\n\n\n# _LT_PROG_AR\n# -----------\nm4_defun([_LT_PROG_AR],\n[AC_CHECK_TOOLS(AR, [ar], false)\n: ${AR=ar}\n: ${AR_FLAGS=cru}\n_LT_DECL([], [AR], [1], [The archiver])\n_LT_DECL([], [AR_FLAGS], [1], [Flags to create an archive])\n\nAC_CACHE_CHECK([for archiver @FILE support], [lt_cv_ar_at_file],\n  [lt_cv_ar_at_file=no\n   AC_COMPILE_IFELSE([AC_LANG_PROGRAM],\n     [echo conftest.$ac_objext > conftest.lst\n      lt_ar_try='$AR $AR_FLAGS libconftest.a @conftest.lst >&AS_MESSAGE_LOG_FD'\n      AC_TRY_EVAL([lt_ar_try])\n      if test \"$ac_status\" -eq 0; then\n\t# Ensure the archiver fails upon bogus file names.\n\trm -f conftest.$ac_objext libconftest.a\n\tAC_TRY_EVAL([lt_ar_try])\n\tif test \"$ac_status\" -ne 0; then\n          lt_cv_ar_at_file=@\n        fi\n      fi\n      rm -f conftest.* libconftest.a\n     ])\n  ])\n\nif test \"x$lt_cv_ar_at_file\" = xno; then\n  archiver_list_spec=\nelse\n  archiver_list_spec=$lt_cv_ar_at_file\nfi\n_LT_DECL([], [archiver_list_spec], [1],\n  [How to feed a file listing to the archiver])\n])# _LT_PROG_AR\n\n\n# _LT_CMD_OLD_ARCHIVE\n# -------------------\nm4_defun([_LT_CMD_OLD_ARCHIVE],\n[_LT_PROG_AR\n\nAC_CHECK_TOOL(STRIP, strip, :)\ntest -z \"$STRIP\" && STRIP=:\n_LT_DECL([], [STRIP], [1], [A symbol stripping program])\n\nAC_CHECK_TOOL(RANLIB, ranlib, :)\ntest -z \"$RANLIB\" && RANLIB=:\n_LT_DECL([], [RANLIB], [1],\n    [Commands used to install an old-style archive])\n\n# Determine commands to create old-style static archives.\nold_archive_cmds='$AR $AR_FLAGS $oldlib$oldobjs'\nold_postinstall_cmds='chmod 644 $oldlib'\nold_postuninstall_cmds=\n\nif test -n \"$RANLIB\"; then\n  case $host_os in\n  openbsd*)\n    old_postinstall_cmds=\"$old_postinstall_cmds~\\$RANLIB -t \\$tool_oldlib\"\n    ;;\n  *)\n    old_postinstall_cmds=\"$old_postinstall_cmds~\\$RANLIB \\$tool_oldlib\"\n    ;;\n  esac\n  old_archive_cmds=\"$old_archive_cmds~\\$RANLIB \\$tool_oldlib\"\nfi\n\ncase $host_os in\n  darwin*)\n    lock_old_archive_extraction=yes ;;\n  *)\n    lock_old_archive_extraction=no ;;\nesac\n_LT_DECL([], [old_postinstall_cmds], [2])\n_LT_DECL([], [old_postuninstall_cmds], [2])\n_LT_TAGDECL([], [old_archive_cmds], [2],\n    [Commands used to build an old-style archive])\n_LT_DECL([], [lock_old_archive_extraction], [0],\n    [Whether to use a lock for old archive extraction])\n])# _LT_CMD_OLD_ARCHIVE\n\n\n# _LT_COMPILER_OPTION(MESSAGE, VARIABLE-NAME, FLAGS,\n#\t\t[OUTPUT-FILE], [ACTION-SUCCESS], [ACTION-FAILURE])\n# ----------------------------------------------------------------\n# Check whether the given compiler option works\nAC_DEFUN([_LT_COMPILER_OPTION],\n[m4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_DECL_SED])dnl\nAC_CACHE_CHECK([$1], [$2],\n  [$2=no\n   m4_if([$4], , [ac_outfile=conftest.$ac_objext], [ac_outfile=$4])\n   echo \"$lt_simple_compile_test_code\" > conftest.$ac_ext\n   lt_compiler_flag=\"$3\"\n   # Insert the option either (1) after the last *FLAGS variable, or\n   # (2) before a word containing \"conftest.\", or (3) at the end.\n   # Note that $ac_compile itself does not contain backslashes and begins\n   # with a dollar sign (not a hyphen), so the echo should work correctly.\n   # The option is referenced via a variable to avoid confusing sed.\n   lt_compile=`echo \"$ac_compile\" | $SED \\\n   -e 's:.*FLAGS}\\{0,1\\} :&$lt_compiler_flag :; t' \\\n   -e 's: [[^ ]]*conftest\\.: $lt_compiler_flag&:; t' \\\n   -e 's:$: $lt_compiler_flag:'`\n   (eval echo \"\\\"\\$as_me:$LINENO: $lt_compile\\\"\" >&AS_MESSAGE_LOG_FD)\n   (eval \"$lt_compile\" 2>conftest.err)\n   ac_status=$?\n   cat conftest.err >&AS_MESSAGE_LOG_FD\n   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&AS_MESSAGE_LOG_FD\n   if (exit $ac_status) && test -s \"$ac_outfile\"; then\n     # The compiler can only warn and ignore the option if not recognized\n     # So say no if there are warnings other than the usual output.\n     $ECHO \"$_lt_compiler_boilerplate\" | $SED '/^$/d' >conftest.exp\n     $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2\n     if test ! -s conftest.er2 || diff conftest.exp conftest.er2 >/dev/null; then\n       $2=yes\n     fi\n   fi\n   $RM conftest*\n])\n\nif test x\"[$]$2\" = xyes; then\n    m4_if([$5], , :, [$5])\nelse\n    m4_if([$6], , :, [$6])\nfi\n])# _LT_COMPILER_OPTION\n\n# Old name:\nAU_ALIAS([AC_LIBTOOL_COMPILER_OPTION], [_LT_COMPILER_OPTION])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_COMPILER_OPTION], [])\n\n\n# _LT_LINKER_OPTION(MESSAGE, VARIABLE-NAME, FLAGS,\n#                  [ACTION-SUCCESS], [ACTION-FAILURE])\n# ----------------------------------------------------\n# Check whether the given linker option works\nAC_DEFUN([_LT_LINKER_OPTION],\n[m4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_DECL_SED])dnl\nAC_CACHE_CHECK([$1], [$2],\n  [$2=no\n   save_LDFLAGS=\"$LDFLAGS\"\n   LDFLAGS=\"$LDFLAGS $3\"\n   echo \"$lt_simple_link_test_code\" > conftest.$ac_ext\n   if (eval $ac_link 2>conftest.err) && test -s conftest$ac_exeext; then\n     # The linker can only warn and ignore the option if not recognized\n     # So say no if there are warnings\n     if test -s conftest.err; then\n       # Append any errors to the config.log.\n       cat conftest.err 1>&AS_MESSAGE_LOG_FD\n       $ECHO \"$_lt_linker_boilerplate\" | $SED '/^$/d' > conftest.exp\n       $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2\n       if diff conftest.exp conftest.er2 >/dev/null; then\n         $2=yes\n       fi\n     else\n       $2=yes\n     fi\n   fi\n   $RM -r conftest*\n   LDFLAGS=\"$save_LDFLAGS\"\n])\n\nif test x\"[$]$2\" = xyes; then\n    m4_if([$4], , :, [$4])\nelse\n    m4_if([$5], , :, [$5])\nfi\n])# _LT_LINKER_OPTION\n\n# Old name:\nAU_ALIAS([AC_LIBTOOL_LINKER_OPTION], [_LT_LINKER_OPTION])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_LINKER_OPTION], [])\n\n\n# LT_CMD_MAX_LEN\n#---------------\nAC_DEFUN([LT_CMD_MAX_LEN],\n[AC_REQUIRE([AC_CANONICAL_HOST])dnl\n# find the maximum length of command line arguments\nAC_MSG_CHECKING([the maximum length of command line arguments])\nAC_CACHE_VAL([lt_cv_sys_max_cmd_len], [dnl\n  i=0\n  teststring=\"ABCD\"\n\n  case $build_os in\n  msdosdjgpp*)\n    # On DJGPP, this test can blow up pretty badly due to problems in libc\n    # (any single argument exceeding 2000 bytes causes a buffer overrun\n    # during glob expansion).  Even if it were fixed, the result of this\n    # check would be larger than it should be.\n    lt_cv_sys_max_cmd_len=12288;    # 12K is about right\n    ;;\n\n  gnu*)\n    # Under GNU Hurd, this test is not required because there is\n    # no limit to the length of command line arguments.\n    # Libtool will interpret -1 as no limit whatsoever\n    lt_cv_sys_max_cmd_len=-1;\n    ;;\n\n  cygwin* | mingw* | cegcc*)\n    # On Win9x/ME, this test blows up -- it succeeds, but takes\n    # about 5 minutes as the teststring grows exponentially.\n    # Worse, since 9x/ME are not pre-emptively multitasking,\n    # you end up with a \"frozen\" computer, even though with patience\n    # the test eventually succeeds (with a max line length of 256k).\n    # Instead, let's just punt: use the minimum linelength reported by\n    # all of the supported platforms: 8192 (on NT/2K/XP).\n    lt_cv_sys_max_cmd_len=8192;\n    ;;\n\n  mint*)\n    # On MiNT this can take a long time and run out of memory.\n    lt_cv_sys_max_cmd_len=8192;\n    ;;\n\n  amigaos*)\n    # On AmigaOS with pdksh, this test takes hours, literally.\n    # So we just punt and use a minimum line length of 8192.\n    lt_cv_sys_max_cmd_len=8192;\n    ;;\n\n  netbsd* | freebsd* | openbsd* | darwin* | dragonfly*)\n    # This has been around since 386BSD, at least.  Likely further.\n    if test -x /sbin/sysctl; then\n      lt_cv_sys_max_cmd_len=`/sbin/sysctl -n kern.argmax`\n    elif test -x /usr/sbin/sysctl; then\n      lt_cv_sys_max_cmd_len=`/usr/sbin/sysctl -n kern.argmax`\n    else\n      lt_cv_sys_max_cmd_len=65536\t# usable default for all BSDs\n    fi\n    # And add a safety zone\n    lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \\/ 4`\n    lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \\* 3`\n    ;;\n\n  interix*)\n    # We know the value 262144 and hardcode it with a safety zone (like BSD)\n    lt_cv_sys_max_cmd_len=196608\n    ;;\n\n  os2*)\n    # The test takes a long time on OS/2.\n    lt_cv_sys_max_cmd_len=8192\n    ;;\n\n  osf*)\n    # Dr. Hans Ekkehard Plesser reports seeing a kernel panic running configure\n    # due to this test when exec_disable_arg_limit is 1 on Tru64. It is not\n    # nice to cause kernel panics so lets avoid the loop below.\n    # First set a reasonable default.\n    lt_cv_sys_max_cmd_len=16384\n    #\n    if test -x /sbin/sysconfig; then\n      case `/sbin/sysconfig -q proc exec_disable_arg_limit` in\n        *1*) lt_cv_sys_max_cmd_len=-1 ;;\n      esac\n    fi\n    ;;\n  sco3.2v5*)\n    lt_cv_sys_max_cmd_len=102400\n    ;;\n  sysv5* | sco5v6* | sysv4.2uw2*)\n    kargmax=`grep ARG_MAX /etc/conf/cf.d/stune 2>/dev/null`\n    if test -n \"$kargmax\"; then\n      lt_cv_sys_max_cmd_len=`echo $kargmax | sed 's/.*[[\t ]]//'`\n    else\n      lt_cv_sys_max_cmd_len=32768\n    fi\n    ;;\n  *)\n    lt_cv_sys_max_cmd_len=`(getconf ARG_MAX) 2> /dev/null`\n    if test -n \"$lt_cv_sys_max_cmd_len\"; then\n      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \\/ 4`\n      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \\* 3`\n    else\n      # Make teststring a little bigger before we do anything with it.\n      # a 1K string should be a reasonable start.\n      for i in 1 2 3 4 5 6 7 8 ; do\n        teststring=$teststring$teststring\n      done\n      SHELL=${SHELL-${CONFIG_SHELL-/bin/sh}}\n      # If test is not a shell built-in, we'll probably end up computing a\n      # maximum length that is only half of the actual maximum length, but\n      # we can't tell.\n      while { test \"X\"`env echo \"$teststring$teststring\" 2>/dev/null` \\\n\t         = \"X$teststring$teststring\"; } >/dev/null 2>&1 &&\n\t      test $i != 17 # 1/2 MB should be enough\n      do\n        i=`expr $i + 1`\n        teststring=$teststring$teststring\n      done\n      # Only check the string length outside the loop.\n      lt_cv_sys_max_cmd_len=`expr \"X$teststring\" : \".*\" 2>&1`\n      teststring=\n      # Add a significant safety factor because C++ compilers can tack on\n      # massive amounts of additional arguments before passing them to the\n      # linker.  It appears as though 1/2 is a usable value.\n      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \\/ 2`\n    fi\n    ;;\n  esac\n])\nif test -n $lt_cv_sys_max_cmd_len ; then\n  AC_MSG_RESULT($lt_cv_sys_max_cmd_len)\nelse\n  AC_MSG_RESULT(none)\nfi\nmax_cmd_len=$lt_cv_sys_max_cmd_len\n_LT_DECL([], [max_cmd_len], [0],\n    [What is the maximum length of a command?])\n])# LT_CMD_MAX_LEN\n\n# Old name:\nAU_ALIAS([AC_LIBTOOL_SYS_MAX_CMD_LEN], [LT_CMD_MAX_LEN])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_SYS_MAX_CMD_LEN], [])\n\n\n# _LT_HEADER_DLFCN\n# ----------------\nm4_defun([_LT_HEADER_DLFCN],\n[AC_CHECK_HEADERS([dlfcn.h], [], [], [AC_INCLUDES_DEFAULT])dnl\n])# _LT_HEADER_DLFCN\n\n\n# _LT_TRY_DLOPEN_SELF (ACTION-IF-TRUE, ACTION-IF-TRUE-W-USCORE,\n#                      ACTION-IF-FALSE, ACTION-IF-CROSS-COMPILING)\n# ----------------------------------------------------------------\nm4_defun([_LT_TRY_DLOPEN_SELF],\n[m4_require([_LT_HEADER_DLFCN])dnl\nif test \"$cross_compiling\" = yes; then :\n  [$4]\nelse\n  lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n  lt_status=$lt_dlunknown\n  cat > conftest.$ac_ext <<_LT_EOF\n[#line $LINENO \"configure\"\n#include \"confdefs.h\"\n\n#if HAVE_DLFCN_H\n#include <dlfcn.h>\n#endif\n\n#include <stdio.h>\n\n#ifdef RTLD_GLOBAL\n#  define LT_DLGLOBAL\t\tRTLD_GLOBAL\n#else\n#  ifdef DL_GLOBAL\n#    define LT_DLGLOBAL\t\tDL_GLOBAL\n#  else\n#    define LT_DLGLOBAL\t\t0\n#  endif\n#endif\n\n/* We may have to define LT_DLLAZY_OR_NOW in the command line if we\n   find out it does not work in some platform. */\n#ifndef LT_DLLAZY_OR_NOW\n#  ifdef RTLD_LAZY\n#    define LT_DLLAZY_OR_NOW\t\tRTLD_LAZY\n#  else\n#    ifdef DL_LAZY\n#      define LT_DLLAZY_OR_NOW\t\tDL_LAZY\n#    else\n#      ifdef RTLD_NOW\n#        define LT_DLLAZY_OR_NOW\tRTLD_NOW\n#      else\n#        ifdef DL_NOW\n#          define LT_DLLAZY_OR_NOW\tDL_NOW\n#        else\n#          define LT_DLLAZY_OR_NOW\t0\n#        endif\n#      endif\n#    endif\n#  endif\n#endif\n\n/* When -fvisbility=hidden is used, assume the code has been annotated\n   correspondingly for the symbols needed.  */\n#if defined(__GNUC__) && (((__GNUC__ == 3) && (__GNUC_MINOR__ >= 3)) || (__GNUC__ > 3))\nint fnord () __attribute__((visibility(\"default\")));\n#endif\n\nint fnord () { return 42; }\nint main ()\n{\n  void *self = dlopen (0, LT_DLGLOBAL|LT_DLLAZY_OR_NOW);\n  int status = $lt_dlunknown;\n\n  if (self)\n    {\n      if (dlsym (self,\"fnord\"))       status = $lt_dlno_uscore;\n      else\n        {\n\t  if (dlsym( self,\"_fnord\"))  status = $lt_dlneed_uscore;\n          else puts (dlerror ());\n\t}\n      /* dlclose (self); */\n    }\n  else\n    puts (dlerror ());\n\n  return status;\n}]\n_LT_EOF\n  if AC_TRY_EVAL(ac_link) && test -s conftest${ac_exeext} 2>/dev/null; then\n    (./conftest; exit; ) >&AS_MESSAGE_LOG_FD 2>/dev/null\n    lt_status=$?\n    case x$lt_status in\n      x$lt_dlno_uscore) $1 ;;\n      x$lt_dlneed_uscore) $2 ;;\n      x$lt_dlunknown|x*) $3 ;;\n    esac\n  else :\n    # compilation failed\n    $3\n  fi\nfi\nrm -fr conftest*\n])# _LT_TRY_DLOPEN_SELF\n\n\n# LT_SYS_DLOPEN_SELF\n# ------------------\nAC_DEFUN([LT_SYS_DLOPEN_SELF],\n[m4_require([_LT_HEADER_DLFCN])dnl\nif test \"x$enable_dlopen\" != xyes; then\n  enable_dlopen=unknown\n  enable_dlopen_self=unknown\n  enable_dlopen_self_static=unknown\nelse\n  lt_cv_dlopen=no\n  lt_cv_dlopen_libs=\n\n  case $host_os in\n  beos*)\n    lt_cv_dlopen=\"load_add_on\"\n    lt_cv_dlopen_libs=\n    lt_cv_dlopen_self=yes\n    ;;\n\n  mingw* | pw32* | cegcc*)\n    lt_cv_dlopen=\"LoadLibrary\"\n    lt_cv_dlopen_libs=\n    ;;\n\n  cygwin*)\n    lt_cv_dlopen=\"dlopen\"\n    lt_cv_dlopen_libs=\n    ;;\n\n  darwin*)\n  # if libdl is installed we need to link against it\n    AC_CHECK_LIB([dl], [dlopen],\n\t\t[lt_cv_dlopen=\"dlopen\" lt_cv_dlopen_libs=\"-ldl\"],[\n    lt_cv_dlopen=\"dyld\"\n    lt_cv_dlopen_libs=\n    lt_cv_dlopen_self=yes\n    ])\n    ;;\n\n  *)\n    AC_CHECK_FUNC([shl_load],\n\t  [lt_cv_dlopen=\"shl_load\"],\n      [AC_CHECK_LIB([dld], [shl_load],\n\t    [lt_cv_dlopen=\"shl_load\" lt_cv_dlopen_libs=\"-ldld\"],\n\t[AC_CHECK_FUNC([dlopen],\n\t      [lt_cv_dlopen=\"dlopen\"],\n\t  [AC_CHECK_LIB([dl], [dlopen],\n\t\t[lt_cv_dlopen=\"dlopen\" lt_cv_dlopen_libs=\"-ldl\"],\n\t    [AC_CHECK_LIB([svld], [dlopen],\n\t\t  [lt_cv_dlopen=\"dlopen\" lt_cv_dlopen_libs=\"-lsvld\"],\n\t      [AC_CHECK_LIB([dld], [dld_link],\n\t\t    [lt_cv_dlopen=\"dld_link\" lt_cv_dlopen_libs=\"-ldld\"])\n\t      ])\n\t    ])\n\t  ])\n\t])\n      ])\n    ;;\n  esac\n\n  if test \"x$lt_cv_dlopen\" != xno; then\n    enable_dlopen=yes\n  else\n    enable_dlopen=no\n  fi\n\n  case $lt_cv_dlopen in\n  dlopen)\n    save_CPPFLAGS=\"$CPPFLAGS\"\n    test \"x$ac_cv_header_dlfcn_h\" = xyes && CPPFLAGS=\"$CPPFLAGS -DHAVE_DLFCN_H\"\n\n    save_LDFLAGS=\"$LDFLAGS\"\n    wl=$lt_prog_compiler_wl eval LDFLAGS=\\\"\\$LDFLAGS $export_dynamic_flag_spec\\\"\n\n    save_LIBS=\"$LIBS\"\n    LIBS=\"$lt_cv_dlopen_libs $LIBS\"\n\n    AC_CACHE_CHECK([whether a program can dlopen itself],\n\t  lt_cv_dlopen_self, [dnl\n\t  _LT_TRY_DLOPEN_SELF(\n\t    lt_cv_dlopen_self=yes, lt_cv_dlopen_self=yes,\n\t    lt_cv_dlopen_self=no, lt_cv_dlopen_self=cross)\n    ])\n\n    if test \"x$lt_cv_dlopen_self\" = xyes; then\n      wl=$lt_prog_compiler_wl eval LDFLAGS=\\\"\\$LDFLAGS $lt_prog_compiler_static\\\"\n      AC_CACHE_CHECK([whether a statically linked program can dlopen itself],\n\t  lt_cv_dlopen_self_static, [dnl\n\t  _LT_TRY_DLOPEN_SELF(\n\t    lt_cv_dlopen_self_static=yes, lt_cv_dlopen_self_static=yes,\n\t    lt_cv_dlopen_self_static=no,  lt_cv_dlopen_self_static=cross)\n      ])\n    fi\n\n    CPPFLAGS=\"$save_CPPFLAGS\"\n    LDFLAGS=\"$save_LDFLAGS\"\n    LIBS=\"$save_LIBS\"\n    ;;\n  esac\n\n  case $lt_cv_dlopen_self in\n  yes|no) enable_dlopen_self=$lt_cv_dlopen_self ;;\n  *) enable_dlopen_self=unknown ;;\n  esac\n\n  case $lt_cv_dlopen_self_static in\n  yes|no) enable_dlopen_self_static=$lt_cv_dlopen_self_static ;;\n  *) enable_dlopen_self_static=unknown ;;\n  esac\nfi\n_LT_DECL([dlopen_support], [enable_dlopen], [0],\n\t [Whether dlopen is supported])\n_LT_DECL([dlopen_self], [enable_dlopen_self], [0],\n\t [Whether dlopen of programs is supported])\n_LT_DECL([dlopen_self_static], [enable_dlopen_self_static], [0],\n\t [Whether dlopen of statically linked programs is supported])\n])# LT_SYS_DLOPEN_SELF\n\n# Old name:\nAU_ALIAS([AC_LIBTOOL_DLOPEN_SELF], [LT_SYS_DLOPEN_SELF])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_DLOPEN_SELF], [])\n\n\n# _LT_COMPILER_C_O([TAGNAME])\n# ---------------------------\n# Check to see if options -c and -o are simultaneously supported by compiler.\n# This macro does not hard code the compiler like AC_PROG_CC_C_O.\nm4_defun([_LT_COMPILER_C_O],\n[m4_require([_LT_DECL_SED])dnl\nm4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_TAG_COMPILER])dnl\nAC_CACHE_CHECK([if $compiler supports -c -o file.$ac_objext],\n  [_LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)],\n  [_LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)=no\n   $RM -r conftest 2>/dev/null\n   mkdir conftest\n   cd conftest\n   mkdir out\n   echo \"$lt_simple_compile_test_code\" > conftest.$ac_ext\n\n   lt_compiler_flag=\"-o out/conftest2.$ac_objext\"\n   # Insert the option either (1) after the last *FLAGS variable, or\n   # (2) before a word containing \"conftest.\", or (3) at the end.\n   # Note that $ac_compile itself does not contain backslashes and begins\n   # with a dollar sign (not a hyphen), so the echo should work correctly.\n   lt_compile=`echo \"$ac_compile\" | $SED \\\n   -e 's:.*FLAGS}\\{0,1\\} :&$lt_compiler_flag :; t' \\\n   -e 's: [[^ ]]*conftest\\.: $lt_compiler_flag&:; t' \\\n   -e 's:$: $lt_compiler_flag:'`\n   (eval echo \"\\\"\\$as_me:$LINENO: $lt_compile\\\"\" >&AS_MESSAGE_LOG_FD)\n   (eval \"$lt_compile\" 2>out/conftest.err)\n   ac_status=$?\n   cat out/conftest.err >&AS_MESSAGE_LOG_FD\n   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&AS_MESSAGE_LOG_FD\n   if (exit $ac_status) && test -s out/conftest2.$ac_objext\n   then\n     # The compiler can only warn and ignore the option if not recognized\n     # So say no if there are warnings\n     $ECHO \"$_lt_compiler_boilerplate\" | $SED '/^$/d' > out/conftest.exp\n     $SED '/^$/d; /^ *+/d' out/conftest.err >out/conftest.er2\n     if test ! -s out/conftest.er2 || diff out/conftest.exp out/conftest.er2 >/dev/null; then\n       _LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)=yes\n     fi\n   fi\n   chmod u+w . 2>&AS_MESSAGE_LOG_FD\n   $RM conftest*\n   # SGI C++ compiler will create directory out/ii_files/ for\n   # template instantiation\n   test -d out/ii_files && $RM out/ii_files/* && rmdir out/ii_files\n   $RM out/* && rmdir out\n   cd ..\n   $RM -r conftest\n   $RM conftest*\n])\n_LT_TAGDECL([compiler_c_o], [lt_cv_prog_compiler_c_o], [1],\n\t[Does compiler simultaneously support -c and -o options?])\n])# _LT_COMPILER_C_O\n\n\n# _LT_COMPILER_FILE_LOCKS([TAGNAME])\n# ----------------------------------\n# Check to see if we can do hard links to lock some files if needed\nm4_defun([_LT_COMPILER_FILE_LOCKS],\n[m4_require([_LT_ENABLE_LOCK])dnl\nm4_require([_LT_FILEUTILS_DEFAULTS])dnl\n_LT_COMPILER_C_O([$1])\n\nhard_links=\"nottested\"\nif test \"$_LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)\" = no && test \"$need_locks\" != no; then\n  # do not overwrite the value of need_locks provided by the user\n  AC_MSG_CHECKING([if we can lock with hard links])\n  hard_links=yes\n  $RM conftest*\n  ln conftest.a conftest.b 2>/dev/null && hard_links=no\n  touch conftest.a\n  ln conftest.a conftest.b 2>&5 || hard_links=no\n  ln conftest.a conftest.b 2>/dev/null && hard_links=no\n  AC_MSG_RESULT([$hard_links])\n  if test \"$hard_links\" = no; then\n    AC_MSG_WARN([`$CC' does not support `-c -o', so `make -j' may be unsafe])\n    need_locks=warn\n  fi\nelse\n  need_locks=no\nfi\n_LT_DECL([], [need_locks], [1], [Must we lock files when doing compilation?])\n])# _LT_COMPILER_FILE_LOCKS\n\n\n# _LT_CHECK_OBJDIR\n# ----------------\nm4_defun([_LT_CHECK_OBJDIR],\n[AC_CACHE_CHECK([for objdir], [lt_cv_objdir],\n[rm -f .libs 2>/dev/null\nmkdir .libs 2>/dev/null\nif test -d .libs; then\n  lt_cv_objdir=.libs\nelse\n  # MS-DOS does not allow filenames that begin with a dot.\n  lt_cv_objdir=_libs\nfi\nrmdir .libs 2>/dev/null])\nobjdir=$lt_cv_objdir\n_LT_DECL([], [objdir], [0],\n         [The name of the directory that contains temporary libtool files])dnl\nm4_pattern_allow([LT_OBJDIR])dnl\nAC_DEFINE_UNQUOTED(LT_OBJDIR, \"$lt_cv_objdir/\",\n  [Define to the sub-directory in which libtool stores uninstalled libraries.])\n])# _LT_CHECK_OBJDIR\n\n\n# _LT_LINKER_HARDCODE_LIBPATH([TAGNAME])\n# --------------------------------------\n# Check hardcoding attributes.\nm4_defun([_LT_LINKER_HARDCODE_LIBPATH],\n[AC_MSG_CHECKING([how to hardcode library paths into programs])\n_LT_TAGVAR(hardcode_action, $1)=\nif test -n \"$_LT_TAGVAR(hardcode_libdir_flag_spec, $1)\" ||\n   test -n \"$_LT_TAGVAR(runpath_var, $1)\" ||\n   test \"X$_LT_TAGVAR(hardcode_automatic, $1)\" = \"Xyes\" ; then\n\n  # We can hardcode non-existent directories.\n  if test \"$_LT_TAGVAR(hardcode_direct, $1)\" != no &&\n     # If the only mechanism to avoid hardcoding is shlibpath_var, we\n     # have to relink, otherwise we might link with an installed library\n     # when we should be linking with a yet-to-be-installed one\n     ## test \"$_LT_TAGVAR(hardcode_shlibpath_var, $1)\" != no &&\n     test \"$_LT_TAGVAR(hardcode_minus_L, $1)\" != no; then\n    # Linking always hardcodes the temporary library directory.\n    _LT_TAGVAR(hardcode_action, $1)=relink\n  else\n    # We can link without hardcoding, and we can hardcode nonexisting dirs.\n    _LT_TAGVAR(hardcode_action, $1)=immediate\n  fi\nelse\n  # We cannot hardcode anything, or else we can only hardcode existing\n  # directories.\n  _LT_TAGVAR(hardcode_action, $1)=unsupported\nfi\nAC_MSG_RESULT([$_LT_TAGVAR(hardcode_action, $1)])\n\nif test \"$_LT_TAGVAR(hardcode_action, $1)\" = relink ||\n   test \"$_LT_TAGVAR(inherit_rpath, $1)\" = yes; then\n  # Fast installation is not supported\n  enable_fast_install=no\nelif test \"$shlibpath_overrides_runpath\" = yes ||\n     test \"$enable_shared\" = no; then\n  # Fast installation is not necessary\n  enable_fast_install=needless\nfi\n_LT_TAGDECL([], [hardcode_action], [0],\n    [How to hardcode a shared library path into an executable])\n])# _LT_LINKER_HARDCODE_LIBPATH\n\n\n# _LT_CMD_STRIPLIB\n# ----------------\nm4_defun([_LT_CMD_STRIPLIB],\n[m4_require([_LT_DECL_EGREP])\nstriplib=\nold_striplib=\nAC_MSG_CHECKING([whether stripping libraries is possible])\nif test -n \"$STRIP\" && $STRIP -V 2>&1 | $GREP \"GNU strip\" >/dev/null; then\n  test -z \"$old_striplib\" && old_striplib=\"$STRIP --strip-debug\"\n  test -z \"$striplib\" && striplib=\"$STRIP --strip-unneeded\"\n  AC_MSG_RESULT([yes])\nelse\n# FIXME - insert some real tests, host_os isn't really good enough\n  case $host_os in\n  darwin*)\n    if test -n \"$STRIP\" ; then\n      striplib=\"$STRIP -x\"\n      old_striplib=\"$STRIP -S\"\n      AC_MSG_RESULT([yes])\n    else\n      AC_MSG_RESULT([no])\n    fi\n    ;;\n  *)\n    AC_MSG_RESULT([no])\n    ;;\n  esac\nfi\n_LT_DECL([], [old_striplib], [1], [Commands to strip libraries])\n_LT_DECL([], [striplib], [1])\n])# _LT_CMD_STRIPLIB\n\n\n# _LT_SYS_DYNAMIC_LINKER([TAG])\n# -----------------------------\n# PORTME Fill in your ld.so characteristics\nm4_defun([_LT_SYS_DYNAMIC_LINKER],\n[AC_REQUIRE([AC_CANONICAL_HOST])dnl\nm4_require([_LT_DECL_EGREP])dnl\nm4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_DECL_OBJDUMP])dnl\nm4_require([_LT_DECL_SED])dnl\nm4_require([_LT_CHECK_SHELL_FEATURES])dnl\nAC_MSG_CHECKING([dynamic linker characteristics])\nm4_if([$1],\n\t[], [\nif test \"$GCC\" = yes; then\n  case $host_os in\n    darwin*) lt_awk_arg=\"/^libraries:/,/LR/\" ;;\n    *) lt_awk_arg=\"/^libraries:/\" ;;\n  esac\n  case $host_os in\n    mingw* | cegcc*) lt_sed_strip_eq=\"s,=\\([[A-Za-z]]:\\),\\1,g\" ;;\n    *) lt_sed_strip_eq=\"s,=/,/,g\" ;;\n  esac\n  lt_search_path_spec=`$CC -print-search-dirs | awk $lt_awk_arg | $SED -e \"s/^libraries://\" -e $lt_sed_strip_eq`\n  case $lt_search_path_spec in\n  *\\;*)\n    # if the path contains \";\" then we assume it to be the separator\n    # otherwise default to the standard path separator (i.e. \":\") - it is\n    # assumed that no part of a normal pathname contains \";\" but that should\n    # okay in the real world where \";\" in dirpaths is itself problematic.\n    lt_search_path_spec=`$ECHO \"$lt_search_path_spec\" | $SED 's/;/ /g'`\n    ;;\n  *)\n    lt_search_path_spec=`$ECHO \"$lt_search_path_spec\" | $SED \"s/$PATH_SEPARATOR/ /g\"`\n    ;;\n  esac\n  # Ok, now we have the path, separated by spaces, we can step through it\n  # and add multilib dir if necessary.\n  lt_tmp_lt_search_path_spec=\n  lt_multi_os_dir=`$CC $CPPFLAGS $CFLAGS $LDFLAGS -print-multi-os-directory 2>/dev/null`\n  for lt_sys_path in $lt_search_path_spec; do\n    if test -d \"$lt_sys_path/$lt_multi_os_dir\"; then\n      lt_tmp_lt_search_path_spec=\"$lt_tmp_lt_search_path_spec $lt_sys_path/$lt_multi_os_dir\"\n    else\n      test -d \"$lt_sys_path\" && \\\n\tlt_tmp_lt_search_path_spec=\"$lt_tmp_lt_search_path_spec $lt_sys_path\"\n    fi\n  done\n  lt_search_path_spec=`$ECHO \"$lt_tmp_lt_search_path_spec\" | awk '\nBEGIN {RS=\" \"; FS=\"/|\\n\";} {\n  lt_foo=\"\";\n  lt_count=0;\n  for (lt_i = NF; lt_i > 0; lt_i--) {\n    if ($lt_i != \"\" && $lt_i != \".\") {\n      if ($lt_i == \"..\") {\n        lt_count++;\n      } else {\n        if (lt_count == 0) {\n          lt_foo=\"/\" $lt_i lt_foo;\n        } else {\n          lt_count--;\n        }\n      }\n    }\n  }\n  if (lt_foo != \"\") { lt_freq[[lt_foo]]++; }\n  if (lt_freq[[lt_foo]] == 1) { print lt_foo; }\n}'`\n  # AWK program above erroneously prepends '/' to C:/dos/paths\n  # for these hosts.\n  case $host_os in\n    mingw* | cegcc*) lt_search_path_spec=`$ECHO \"$lt_search_path_spec\" |\\\n      $SED 's,/\\([[A-Za-z]]:\\),\\1,g'` ;;\n  esac\n  sys_lib_search_path_spec=`$ECHO \"$lt_search_path_spec\" | $lt_NL2SP`\nelse\n  sys_lib_search_path_spec=\"/lib /usr/lib /usr/local/lib\"\nfi])\nlibrary_names_spec=\nlibname_spec='lib$name'\nsoname_spec=\nshrext_cmds=\".so\"\npostinstall_cmds=\npostuninstall_cmds=\nfinish_cmds=\nfinish_eval=\nshlibpath_var=\nshlibpath_overrides_runpath=unknown\nversion_type=none\ndynamic_linker=\"$host_os ld.so\"\nsys_lib_dlsearch_path_spec=\"/lib /usr/lib\"\nneed_lib_prefix=unknown\nhardcode_into_libs=no\n\n# when you set need_version to no, make sure it does not cause -set_version\n# flags to be left without arguments\nneed_version=unknown\n\ncase $host_os in\naix3*)\n  version_type=linux # correct to gnu/linux during the next big refactor\n  library_names_spec='${libname}${release}${shared_ext}$versuffix $libname.a'\n  shlibpath_var=LIBPATH\n\n  # AIX 3 has no versioning support, so we append a major version to the name.\n  soname_spec='${libname}${release}${shared_ext}$major'\n  ;;\n\naix[[4-9]]*)\n  version_type=linux # correct to gnu/linux during the next big refactor\n  need_lib_prefix=no\n  need_version=no\n  hardcode_into_libs=yes\n  if test \"$host_cpu\" = ia64; then\n    # AIX 5 supports IA64\n    library_names_spec='${libname}${release}${shared_ext}$major ${libname}${release}${shared_ext}$versuffix $libname${shared_ext}'\n    shlibpath_var=LD_LIBRARY_PATH\n  else\n    # With GCC up to 2.95.x, collect2 would create an import file\n    # for dependence libraries.  The import file would start with\n    # the line `#! .'.  This would cause the generated library to\n    # depend on `.', always an invalid library.  This was fixed in\n    # development snapshots of GCC prior to 3.0.\n    case $host_os in\n      aix4 | aix4.[[01]] | aix4.[[01]].*)\n      if { echo '#if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 97)'\n\t   echo ' yes '\n\t   echo '#endif'; } | ${CC} -E - | $GREP yes > /dev/null; then\n\t:\n      else\n\tcan_build_shared=no\n      fi\n      ;;\n    esac\n    # AIX (on Power*) has no versioning support, so currently we can not hardcode correct\n    # soname into executable. Probably we can add versioning support to\n    # collect2, so additional links can be useful in future.\n    if test \"$aix_use_runtimelinking\" = yes; then\n      # If using run time linking (on AIX 4.2 or later) use lib<name>.so\n      # instead of lib<name>.a to let people know that these are not\n      # typical AIX shared libraries.\n      library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n    else\n      # We preserve .a as extension for shared libraries through AIX4.2\n      # and later when we are not doing run time linking.\n      library_names_spec='${libname}${release}.a $libname.a'\n      soname_spec='${libname}${release}${shared_ext}$major'\n    fi\n    shlibpath_var=LIBPATH\n  fi\n  ;;\n\namigaos*)\n  case $host_cpu in\n  powerpc)\n    # Since July 2007 AmigaOS4 officially supports .so libraries.\n    # When compiling the executable, add -use-dynld -Lsobjs: to the compileline.\n    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n    ;;\n  m68k)\n    library_names_spec='$libname.ixlibrary $libname.a'\n    # Create ${libname}_ixlibrary.a entries in /sys/libs.\n    finish_eval='for lib in `ls $libdir/*.ixlibrary 2>/dev/null`; do libname=`func_echo_all \"$lib\" | $SED '\\''s%^.*/\\([[^/]]*\\)\\.ixlibrary$%\\1%'\\''`; test $RM /sys/libs/${libname}_ixlibrary.a; $show \"cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a\"; cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a || exit 1; done'\n    ;;\n  esac\n  ;;\n\nbeos*)\n  library_names_spec='${libname}${shared_ext}'\n  dynamic_linker=\"$host_os ld.so\"\n  shlibpath_var=LIBRARY_PATH\n  ;;\n\nbsdi[[45]]*)\n  version_type=linux # correct to gnu/linux during the next big refactor\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  finish_cmds='PATH=\"\\$PATH:/sbin\" ldconfig $libdir'\n  shlibpath_var=LD_LIBRARY_PATH\n  sys_lib_search_path_spec=\"/shlib /usr/lib /usr/X11/lib /usr/contrib/lib /lib /usr/local/lib\"\n  sys_lib_dlsearch_path_spec=\"/shlib /usr/lib /usr/local/lib\"\n  # the default ld.so.conf also contains /usr/contrib/lib and\n  # /usr/X11R6/lib (/usr/X11 is a link to /usr/X11R6), but let us allow\n  # libtool to hard-code these into programs\n  ;;\n\ncygwin* | mingw* | pw32* | cegcc*)\n  version_type=windows\n  shrext_cmds=\".dll\"\n  need_version=no\n  need_lib_prefix=no\n\n  case $GCC,$cc_basename in\n  yes,*)\n    # gcc\n    library_names_spec='$libname.dll.a'\n    # DLL is installed to $(libdir)/../bin by postinstall_cmds\n    postinstall_cmds='base_file=`basename \\${file}`~\n      dlpath=`$SHELL 2>&1 -c '\\''. $dir/'\\''\\${base_file}'\\''i; echo \\$dlname'\\''`~\n      dldir=$destdir/`dirname \\$dlpath`~\n      test -d \\$dldir || mkdir -p \\$dldir~\n      $install_prog $dir/$dlname \\$dldir/$dlname~\n      chmod a+x \\$dldir/$dlname~\n      if test -n '\\''$stripme'\\'' && test -n '\\''$striplib'\\''; then\n        eval '\\''$striplib \\$dldir/$dlname'\\'' || exit \\$?;\n      fi'\n    postuninstall_cmds='dldll=`$SHELL 2>&1 -c '\\''. $file; echo \\$dlname'\\''`~\n      dlpath=$dir/\\$dldll~\n       $RM \\$dlpath'\n    shlibpath_overrides_runpath=yes\n\n    case $host_os in\n    cygwin*)\n      # Cygwin DLLs use 'cyg' prefix rather than 'lib'\n      soname_spec='`echo ${libname} | sed -e 's/^lib/cyg/'``echo ${release} | $SED -e 's/[[.]]/-/g'`${versuffix}${shared_ext}'\nm4_if([$1], [],[\n      sys_lib_search_path_spec=\"$sys_lib_search_path_spec /usr/lib/w32api\"])\n      ;;\n    mingw* | cegcc*)\n      # MinGW DLLs use traditional 'lib' prefix\n      soname_spec='${libname}`echo ${release} | $SED -e 's/[[.]]/-/g'`${versuffix}${shared_ext}'\n      ;;\n    pw32*)\n      # pw32 DLLs use 'pw' prefix rather than 'lib'\n      library_names_spec='`echo ${libname} | sed -e 's/^lib/pw/'``echo ${release} | $SED -e 's/[[.]]/-/g'`${versuffix}${shared_ext}'\n      ;;\n    esac\n    dynamic_linker='Win32 ld.exe'\n    ;;\n\n  *,cl*)\n    # Native MSVC\n    libname_spec='$name'\n    soname_spec='${libname}`echo ${release} | $SED -e 's/[[.]]/-/g'`${versuffix}${shared_ext}'\n    library_names_spec='${libname}.dll.lib'\n\n    case $build_os in\n    mingw*)\n      sys_lib_search_path_spec=\n      lt_save_ifs=$IFS\n      IFS=';'\n      for lt_path in $LIB\n      do\n        IFS=$lt_save_ifs\n        # Let DOS variable expansion print the short 8.3 style file name.\n        lt_path=`cd \"$lt_path\" 2>/dev/null && cmd //C \"for %i in (\".\") do @echo %~si\"`\n        sys_lib_search_path_spec=\"$sys_lib_search_path_spec $lt_path\"\n      done\n      IFS=$lt_save_ifs\n      # Convert to MSYS style.\n      sys_lib_search_path_spec=`$ECHO \"$sys_lib_search_path_spec\" | sed -e 's|\\\\\\\\|/|g' -e 's| \\\\([[a-zA-Z]]\\\\):| /\\\\1|g' -e 's|^ ||'`\n      ;;\n    cygwin*)\n      # Convert to unix form, then to dos form, then back to unix form\n      # but this time dos style (no spaces!) so that the unix form looks\n      # like /cygdrive/c/PROGRA~1:/cygdr...\n      sys_lib_search_path_spec=`cygpath --path --unix \"$LIB\"`\n      sys_lib_search_path_spec=`cygpath --path --dos \"$sys_lib_search_path_spec\" 2>/dev/null`\n      sys_lib_search_path_spec=`cygpath --path --unix \"$sys_lib_search_path_spec\" | $SED -e \"s/$PATH_SEPARATOR/ /g\"`\n      ;;\n    *)\n      sys_lib_search_path_spec=\"$LIB\"\n      if $ECHO \"$sys_lib_search_path_spec\" | [$GREP ';[c-zC-Z]:/' >/dev/null]; then\n        # It is most probably a Windows format PATH.\n        sys_lib_search_path_spec=`$ECHO \"$sys_lib_search_path_spec\" | $SED -e 's/;/ /g'`\n      else\n        sys_lib_search_path_spec=`$ECHO \"$sys_lib_search_path_spec\" | $SED -e \"s/$PATH_SEPARATOR/ /g\"`\n      fi\n      # FIXME: find the short name or the path components, as spaces are\n      # common. (e.g. \"Program Files\" -> \"PROGRA~1\")\n      ;;\n    esac\n\n    # DLL is installed to $(libdir)/../bin by postinstall_cmds\n    postinstall_cmds='base_file=`basename \\${file}`~\n      dlpath=`$SHELL 2>&1 -c '\\''. $dir/'\\''\\${base_file}'\\''i; echo \\$dlname'\\''`~\n      dldir=$destdir/`dirname \\$dlpath`~\n      test -d \\$dldir || mkdir -p \\$dldir~\n      $install_prog $dir/$dlname \\$dldir/$dlname'\n    postuninstall_cmds='dldll=`$SHELL 2>&1 -c '\\''. $file; echo \\$dlname'\\''`~\n      dlpath=$dir/\\$dldll~\n       $RM \\$dlpath'\n    shlibpath_overrides_runpath=yes\n    dynamic_linker='Win32 link.exe'\n    ;;\n\n  *)\n    # Assume MSVC wrapper\n    library_names_spec='${libname}`echo ${release} | $SED -e 's/[[.]]/-/g'`${versuffix}${shared_ext} $libname.lib'\n    dynamic_linker='Win32 ld.exe'\n    ;;\n  esac\n  # FIXME: first we should search . and the directory the executable is in\n  shlibpath_var=PATH\n  ;;\n\ndarwin* | rhapsody*)\n  dynamic_linker=\"$host_os dyld\"\n  version_type=darwin\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${major}$shared_ext ${libname}$shared_ext'\n  soname_spec='${libname}${release}${major}$shared_ext'\n  shlibpath_overrides_runpath=yes\n  shlibpath_var=DYLD_LIBRARY_PATH\n  shrext_cmds='`test .$module = .yes && echo .so || echo .dylib`'\nm4_if([$1], [],[\n  sys_lib_search_path_spec=\"$sys_lib_search_path_spec /usr/local/lib\"])\n  sys_lib_dlsearch_path_spec='/usr/local/lib /lib /usr/lib'\n  ;;\n\ndgux*)\n  version_type=linux # correct to gnu/linux during the next big refactor\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname$shared_ext'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  ;;\n\nfreebsd* | dragonfly*)\n  # DragonFly does not have aout.  When/if they implement a new\n  # versioning mechanism, adjust this.\n  if test -x /usr/bin/objformat; then\n    objformat=`/usr/bin/objformat`\n  else\n    case $host_os in\n    freebsd[[23]].*) objformat=aout ;;\n    *) objformat=elf ;;\n    esac\n  fi\n  version_type=freebsd-$objformat\n  case $version_type in\n    freebsd-elf*)\n      library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext} $libname${shared_ext}'\n      need_version=no\n      need_lib_prefix=no\n      ;;\n    freebsd-*)\n      library_names_spec='${libname}${release}${shared_ext}$versuffix $libname${shared_ext}$versuffix'\n      need_version=yes\n      ;;\n  esac\n  shlibpath_var=LD_LIBRARY_PATH\n  case $host_os in\n  freebsd2.*)\n    shlibpath_overrides_runpath=yes\n    ;;\n  freebsd3.[[01]]* | freebsdelf3.[[01]]*)\n    shlibpath_overrides_runpath=yes\n    hardcode_into_libs=yes\n    ;;\n  freebsd3.[[2-9]]* | freebsdelf3.[[2-9]]* | \\\n  freebsd4.[[0-5]] | freebsdelf4.[[0-5]] | freebsd4.1.1 | freebsdelf4.1.1)\n    shlibpath_overrides_runpath=no\n    hardcode_into_libs=yes\n    ;;\n  *) # from 4.6 on, and DragonFly\n    shlibpath_overrides_runpath=yes\n    hardcode_into_libs=yes\n    ;;\n  esac\n  ;;\n\ngnu*)\n  version_type=linux # correct to gnu/linux during the next big refactor\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}${major} ${libname}${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=no\n  hardcode_into_libs=yes\n  ;;\n\nhaiku*)\n  version_type=linux # correct to gnu/linux during the next big refactor\n  need_lib_prefix=no\n  need_version=no\n  dynamic_linker=\"$host_os runtime_loader\"\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}${major} ${libname}${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LIBRARY_PATH\n  shlibpath_overrides_runpath=yes\n  sys_lib_dlsearch_path_spec='/boot/home/config/lib /boot/common/lib /boot/system/lib'\n  hardcode_into_libs=yes\n  ;;\n\nhpux9* | hpux10* | hpux11*)\n  # Give a soname corresponding to the major version so that dld.sl refuses to\n  # link against other versions.\n  version_type=sunos\n  need_lib_prefix=no\n  need_version=no\n  case $host_cpu in\n  ia64*)\n    shrext_cmds='.so'\n    hardcode_into_libs=yes\n    dynamic_linker=\"$host_os dld.so\"\n    shlibpath_var=LD_LIBRARY_PATH\n    shlibpath_overrides_runpath=yes # Unless +noenvvar is specified.\n    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n    soname_spec='${libname}${release}${shared_ext}$major'\n    if test \"X$HPUX_IA64_MODE\" = X32; then\n      sys_lib_search_path_spec=\"/usr/lib/hpux32 /usr/local/lib/hpux32 /usr/local/lib\"\n    else\n      sys_lib_search_path_spec=\"/usr/lib/hpux64 /usr/local/lib/hpux64\"\n    fi\n    sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec\n    ;;\n  hppa*64*)\n    shrext_cmds='.sl'\n    hardcode_into_libs=yes\n    dynamic_linker=\"$host_os dld.sl\"\n    shlibpath_var=LD_LIBRARY_PATH # How should we handle SHLIB_PATH\n    shlibpath_overrides_runpath=yes # Unless +noenvvar is specified.\n    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n    soname_spec='${libname}${release}${shared_ext}$major'\n    sys_lib_search_path_spec=\"/usr/lib/pa20_64 /usr/ccs/lib/pa20_64\"\n    sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec\n    ;;\n  *)\n    shrext_cmds='.sl'\n    dynamic_linker=\"$host_os dld.sl\"\n    shlibpath_var=SHLIB_PATH\n    shlibpath_overrides_runpath=no # +s is required to enable SHLIB_PATH\n    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n    soname_spec='${libname}${release}${shared_ext}$major'\n    ;;\n  esac\n  # HP-UX runs *really* slowly unless shared libraries are mode 555, ...\n  postinstall_cmds='chmod 555 $lib'\n  # or fails outright, so override atomically:\n  install_override_mode=555\n  ;;\n\ninterix[[3-9]]*)\n  version_type=linux # correct to gnu/linux during the next big refactor\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  dynamic_linker='Interix 3.x ld.so.1 (PE, like ELF)'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=no\n  hardcode_into_libs=yes\n  ;;\n\nirix5* | irix6* | nonstopux*)\n  case $host_os in\n    nonstopux*) version_type=nonstopux ;;\n    *)\n\tif test \"$lt_cv_prog_gnu_ld\" = yes; then\n\t\tversion_type=linux # correct to gnu/linux during the next big refactor\n\telse\n\t\tversion_type=irix\n\tfi ;;\n  esac\n  need_lib_prefix=no\n  need_version=no\n  soname_spec='${libname}${release}${shared_ext}$major'\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${release}${shared_ext} $libname${shared_ext}'\n  case $host_os in\n  irix5* | nonstopux*)\n    libsuff= shlibsuff=\n    ;;\n  *)\n    case $LD in # libtool.m4 will add one of these switches to LD\n    *-32|*\"-32 \"|*-melf32bsmip|*\"-melf32bsmip \")\n      libsuff= shlibsuff= libmagic=32-bit;;\n    *-n32|*\"-n32 \"|*-melf32bmipn32|*\"-melf32bmipn32 \")\n      libsuff=32 shlibsuff=N32 libmagic=N32;;\n    *-64|*\"-64 \"|*-melf64bmip|*\"-melf64bmip \")\n      libsuff=64 shlibsuff=64 libmagic=64-bit;;\n    *) libsuff= shlibsuff= libmagic=never-match;;\n    esac\n    ;;\n  esac\n  shlibpath_var=LD_LIBRARY${shlibsuff}_PATH\n  shlibpath_overrides_runpath=no\n  sys_lib_search_path_spec=\"/usr/lib${libsuff} /lib${libsuff} /usr/local/lib${libsuff}\"\n  sys_lib_dlsearch_path_spec=\"/usr/lib${libsuff} /lib${libsuff}\"\n  hardcode_into_libs=yes\n  ;;\n\n# No shared lib support for Linux oldld, aout, or coff.\nlinux*oldld* | linux*aout* | linux*coff*)\n  dynamic_linker=no\n  ;;\n\n# This must be glibc/ELF.\nlinux* | k*bsd*-gnu | kopensolaris*-gnu)\n  version_type=linux # correct to gnu/linux during the next big refactor\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  finish_cmds='PATH=\"\\$PATH:/sbin\" ldconfig -n $libdir'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=no\n\n  # Some binutils ld are patched to set DT_RUNPATH\n  AC_CACHE_VAL([lt_cv_shlibpath_overrides_runpath],\n    [lt_cv_shlibpath_overrides_runpath=no\n    save_LDFLAGS=$LDFLAGS\n    save_libdir=$libdir\n    eval \"libdir=/foo; wl=\\\"$_LT_TAGVAR(lt_prog_compiler_wl, $1)\\\"; \\\n\t LDFLAGS=\\\"\\$LDFLAGS $_LT_TAGVAR(hardcode_libdir_flag_spec, $1)\\\"\"\n    AC_LINK_IFELSE([AC_LANG_PROGRAM([],[])],\n      [AS_IF([ ($OBJDUMP -p conftest$ac_exeext) 2>/dev/null | grep \"RUNPATH.*$libdir\" >/dev/null],\n\t [lt_cv_shlibpath_overrides_runpath=yes])])\n    LDFLAGS=$save_LDFLAGS\n    libdir=$save_libdir\n    ])\n  shlibpath_overrides_runpath=$lt_cv_shlibpath_overrides_runpath\n\n  # This implies no fast_install, which is unacceptable.\n  # Some rework will be needed to allow for fast_install\n  # before this can be enabled.\n  hardcode_into_libs=yes\n\n  # Append ld.so.conf contents to the search path\n  if test -f /etc/ld.so.conf; then\n    lt_ld_extra=`awk '/^include / { system(sprintf(\"cd /etc; cat %s 2>/dev/null\", \\[$]2)); skip = 1; } { if (!skip) print \\[$]0; skip = 0; }' < /etc/ld.so.conf | $SED -e 's/#.*//;/^[\t ]*hwcap[\t ]/d;s/[:,\t]/ /g;s/=[^=]*$//;s/=[^= ]* / /g;s/\"//g;/^$/d' | tr '\\n' ' '`\n    sys_lib_dlsearch_path_spec=\"/lib /usr/lib $lt_ld_extra\"\n  fi\n\n  # We used to test for /lib/ld.so.1 and disable shared libraries on\n  # powerpc, because MkLinux only supported shared libraries with the\n  # GNU dynamic linker.  Since this was broken with cross compilers,\n  # most powerpc-linux boxes support dynamic linking these days and\n  # people can always --disable-shared, the test was removed, and we\n  # assume the GNU/Linux dynamic linker is in use.\n  dynamic_linker='GNU/Linux ld.so'\n  ;;\n\nnetbsdelf*-gnu)\n  version_type=linux\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=no\n  hardcode_into_libs=yes\n  dynamic_linker='NetBSD ld.elf_so'\n  ;;\n\nnetbsd*)\n  version_type=sunos\n  need_lib_prefix=no\n  need_version=no\n  if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then\n    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'\n    finish_cmds='PATH=\"\\$PATH:/sbin\" ldconfig -m $libdir'\n    dynamic_linker='NetBSD (a.out) ld.so'\n  else\n    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'\n    soname_spec='${libname}${release}${shared_ext}$major'\n    dynamic_linker='NetBSD ld.elf_so'\n  fi\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=yes\n  hardcode_into_libs=yes\n  ;;\n\nnewsos6)\n  version_type=linux # correct to gnu/linux during the next big refactor\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=yes\n  ;;\n\n*nto* | *qnx*)\n  version_type=qnx\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=no\n  hardcode_into_libs=yes\n  dynamic_linker='ldqnx.so'\n  ;;\n\nopenbsd*)\n  version_type=sunos\n  sys_lib_dlsearch_path_spec=\"/usr/lib\"\n  need_lib_prefix=no\n  # Some older versions of OpenBSD (3.3 at least) *do* need versioned libs.\n  case $host_os in\n    openbsd3.3 | openbsd3.3.*)\tneed_version=yes ;;\n    *)\t\t\t\tneed_version=no  ;;\n  esac\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'\n  finish_cmds='PATH=\"\\$PATH:/sbin\" ldconfig -m $libdir'\n  shlibpath_var=LD_LIBRARY_PATH\n  if test -z \"`echo __ELF__ | $CC -E - | $GREP __ELF__`\" || test \"$host_os-$host_cpu\" = \"openbsd2.8-powerpc\"; then\n    case $host_os in\n      openbsd2.[[89]] | openbsd2.[[89]].*)\n\tshlibpath_overrides_runpath=no\n\t;;\n      *)\n\tshlibpath_overrides_runpath=yes\n\t;;\n      esac\n  else\n    shlibpath_overrides_runpath=yes\n  fi\n  ;;\n\nos2*)\n  libname_spec='$name'\n  shrext_cmds=\".dll\"\n  need_lib_prefix=no\n  library_names_spec='$libname${shared_ext} $libname.a'\n  dynamic_linker='OS/2 ld.exe'\n  shlibpath_var=LIBPATH\n  ;;\n\nosf3* | osf4* | osf5*)\n  version_type=osf\n  need_lib_prefix=no\n  need_version=no\n  soname_spec='${libname}${release}${shared_ext}$major'\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  shlibpath_var=LD_LIBRARY_PATH\n  sys_lib_search_path_spec=\"/usr/shlib /usr/ccs/lib /usr/lib/cmplrs/cc /usr/lib /usr/local/lib /var/shlib\"\n  sys_lib_dlsearch_path_spec=\"$sys_lib_search_path_spec\"\n  ;;\n\nrdos*)\n  dynamic_linker=no\n  ;;\n\nsolaris*)\n  version_type=linux # correct to gnu/linux during the next big refactor\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=yes\n  hardcode_into_libs=yes\n  # ldd complains unless libraries are executable\n  postinstall_cmds='chmod +x $lib'\n  ;;\n\nsunos4*)\n  version_type=sunos\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'\n  finish_cmds='PATH=\"\\$PATH:/usr/etc\" ldconfig $libdir'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=yes\n  if test \"$with_gnu_ld\" = yes; then\n    need_lib_prefix=no\n  fi\n  need_version=yes\n  ;;\n\nsysv4 | sysv4.3*)\n  version_type=linux # correct to gnu/linux during the next big refactor\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  case $host_vendor in\n    sni)\n      shlibpath_overrides_runpath=no\n      need_lib_prefix=no\n      runpath_var=LD_RUN_PATH\n      ;;\n    siemens)\n      need_lib_prefix=no\n      ;;\n    motorola)\n      need_lib_prefix=no\n      need_version=no\n      shlibpath_overrides_runpath=no\n      sys_lib_search_path_spec='/lib /usr/lib /usr/ccs/lib'\n      ;;\n  esac\n  ;;\n\nsysv4*MP*)\n  if test -d /usr/nec ;then\n    version_type=linux # correct to gnu/linux during the next big refactor\n    library_names_spec='$libname${shared_ext}.$versuffix $libname${shared_ext}.$major $libname${shared_ext}'\n    soname_spec='$libname${shared_ext}.$major'\n    shlibpath_var=LD_LIBRARY_PATH\n  fi\n  ;;\n\nsysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)\n  version_type=freebsd-elf\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext} $libname${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=yes\n  hardcode_into_libs=yes\n  if test \"$with_gnu_ld\" = yes; then\n    sys_lib_search_path_spec='/usr/local/lib /usr/gnu/lib /usr/ccs/lib /usr/lib /lib'\n  else\n    sys_lib_search_path_spec='/usr/ccs/lib /usr/lib'\n    case $host_os in\n      sco3.2v5*)\n        sys_lib_search_path_spec=\"$sys_lib_search_path_spec /lib\"\n\t;;\n    esac\n  fi\n  sys_lib_dlsearch_path_spec='/usr/lib'\n  ;;\n\ntpf*)\n  # TPF is a cross-target only.  Preferred cross-host = GNU/Linux.\n  version_type=linux # correct to gnu/linux during the next big refactor\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=no\n  hardcode_into_libs=yes\n  ;;\n\nuts4*)\n  version_type=linux # correct to gnu/linux during the next big refactor\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  ;;\n\n*)\n  dynamic_linker=no\n  ;;\nesac\nAC_MSG_RESULT([$dynamic_linker])\ntest \"$dynamic_linker\" = no && can_build_shared=no\n\nvariables_saved_for_relink=\"PATH $shlibpath_var $runpath_var\"\nif test \"$GCC\" = yes; then\n  variables_saved_for_relink=\"$variables_saved_for_relink GCC_EXEC_PREFIX COMPILER_PATH LIBRARY_PATH\"\nfi\n\nif test \"${lt_cv_sys_lib_search_path_spec+set}\" = set; then\n  sys_lib_search_path_spec=\"$lt_cv_sys_lib_search_path_spec\"\nfi\nif test \"${lt_cv_sys_lib_dlsearch_path_spec+set}\" = set; then\n  sys_lib_dlsearch_path_spec=\"$lt_cv_sys_lib_dlsearch_path_spec\"\nfi\n\n_LT_DECL([], [variables_saved_for_relink], [1],\n    [Variables whose values should be saved in libtool wrapper scripts and\n    restored at link time])\n_LT_DECL([], [need_lib_prefix], [0],\n    [Do we need the \"lib\" prefix for modules?])\n_LT_DECL([], [need_version], [0], [Do we need a version for libraries?])\n_LT_DECL([], [version_type], [0], [Library versioning type])\n_LT_DECL([], [runpath_var], [0],  [Shared library runtime path variable])\n_LT_DECL([], [shlibpath_var], [0],[Shared library path variable])\n_LT_DECL([], [shlibpath_overrides_runpath], [0],\n    [Is shlibpath searched before the hard-coded library search path?])\n_LT_DECL([], [libname_spec], [1], [Format of library name prefix])\n_LT_DECL([], [library_names_spec], [1],\n    [[List of archive names.  First name is the real one, the rest are links.\n    The last name is the one that the linker finds with -lNAME]])\n_LT_DECL([], [soname_spec], [1],\n    [[The coded name of the library, if different from the real name]])\n_LT_DECL([], [install_override_mode], [1],\n    [Permission mode override for installation of shared libraries])\n_LT_DECL([], [postinstall_cmds], [2],\n    [Command to use after installation of a shared archive])\n_LT_DECL([], [postuninstall_cmds], [2],\n    [Command to use after uninstallation of a shared archive])\n_LT_DECL([], [finish_cmds], [2],\n    [Commands used to finish a libtool library installation in a directory])\n_LT_DECL([], [finish_eval], [1],\n    [[As \"finish_cmds\", except a single script fragment to be evaled but\n    not shown]])\n_LT_DECL([], [hardcode_into_libs], [0],\n    [Whether we should hardcode library paths into libraries])\n_LT_DECL([], [sys_lib_search_path_spec], [2],\n    [Compile-time system search path for libraries])\n_LT_DECL([], [sys_lib_dlsearch_path_spec], [2],\n    [Run-time system search path for libraries])\n])# _LT_SYS_DYNAMIC_LINKER\n\n\n# _LT_PATH_TOOL_PREFIX(TOOL)\n# --------------------------\n# find a file program which can recognize shared library\nAC_DEFUN([_LT_PATH_TOOL_PREFIX],\n[m4_require([_LT_DECL_EGREP])dnl\nAC_MSG_CHECKING([for $1])\nAC_CACHE_VAL(lt_cv_path_MAGIC_CMD,\n[case $MAGIC_CMD in\n[[\\\\/*] |  ?:[\\\\/]*])\n  lt_cv_path_MAGIC_CMD=\"$MAGIC_CMD\" # Let the user override the test with a path.\n  ;;\n*)\n  lt_save_MAGIC_CMD=\"$MAGIC_CMD\"\n  lt_save_ifs=\"$IFS\"; IFS=$PATH_SEPARATOR\ndnl $ac_dummy forces splitting on constant user-supplied paths.\ndnl POSIX.2 word splitting is done only on the output of word expansions,\ndnl not every word.  This closes a longstanding sh security hole.\n  ac_dummy=\"m4_if([$2], , $PATH, [$2])\"\n  for ac_dir in $ac_dummy; do\n    IFS=\"$lt_save_ifs\"\n    test -z \"$ac_dir\" && ac_dir=.\n    if test -f $ac_dir/$1; then\n      lt_cv_path_MAGIC_CMD=\"$ac_dir/$1\"\n      if test -n \"$file_magic_test_file\"; then\n\tcase $deplibs_check_method in\n\t\"file_magic \"*)\n\t  file_magic_regex=`expr \"$deplibs_check_method\" : \"file_magic \\(.*\\)\"`\n\t  MAGIC_CMD=\"$lt_cv_path_MAGIC_CMD\"\n\t  if eval $file_magic_cmd \\$file_magic_test_file 2> /dev/null |\n\t    $EGREP \"$file_magic_regex\" > /dev/null; then\n\t    :\n\t  else\n\t    cat <<_LT_EOF 1>&2\n\n*** Warning: the command libtool uses to detect shared libraries,\n*** $file_magic_cmd, produces output that libtool cannot recognize.\n*** The result is that libtool may fail to recognize shared libraries\n*** as such.  This will affect the creation of libtool libraries that\n*** depend on shared libraries, but programs linked with such libtool\n*** libraries will work regardless of this problem.  Nevertheless, you\n*** may want to report the problem to your system manager and/or to\n*** bug-libtool@gnu.org\n\n_LT_EOF\n\t  fi ;;\n\tesac\n      fi\n      break\n    fi\n  done\n  IFS=\"$lt_save_ifs\"\n  MAGIC_CMD=\"$lt_save_MAGIC_CMD\"\n  ;;\nesac])\nMAGIC_CMD=\"$lt_cv_path_MAGIC_CMD\"\nif test -n \"$MAGIC_CMD\"; then\n  AC_MSG_RESULT($MAGIC_CMD)\nelse\n  AC_MSG_RESULT(no)\nfi\n_LT_DECL([], [MAGIC_CMD], [0],\n\t [Used to examine libraries when file_magic_cmd begins with \"file\"])dnl\n])# _LT_PATH_TOOL_PREFIX\n\n# Old name:\nAU_ALIAS([AC_PATH_TOOL_PREFIX], [_LT_PATH_TOOL_PREFIX])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_PATH_TOOL_PREFIX], [])\n\n\n# _LT_PATH_MAGIC\n# --------------\n# find a file program which can recognize a shared library\nm4_defun([_LT_PATH_MAGIC],\n[_LT_PATH_TOOL_PREFIX(${ac_tool_prefix}file, /usr/bin$PATH_SEPARATOR$PATH)\nif test -z \"$lt_cv_path_MAGIC_CMD\"; then\n  if test -n \"$ac_tool_prefix\"; then\n    _LT_PATH_TOOL_PREFIX(file, /usr/bin$PATH_SEPARATOR$PATH)\n  else\n    MAGIC_CMD=:\n  fi\nfi\n])# _LT_PATH_MAGIC\n\n\n# LT_PATH_LD\n# ----------\n# find the pathname to the GNU or non-GNU linker\nAC_DEFUN([LT_PATH_LD],\n[AC_REQUIRE([AC_PROG_CC])dnl\nAC_REQUIRE([AC_CANONICAL_HOST])dnl\nAC_REQUIRE([AC_CANONICAL_BUILD])dnl\nm4_require([_LT_DECL_SED])dnl\nm4_require([_LT_DECL_EGREP])dnl\nm4_require([_LT_PROG_ECHO_BACKSLASH])dnl\n\nAC_ARG_WITH([gnu-ld],\n    [AS_HELP_STRING([--with-gnu-ld],\n\t[assume the C compiler uses GNU ld @<:@default=no@:>@])],\n    [test \"$withval\" = no || with_gnu_ld=yes],\n    [with_gnu_ld=no])dnl\n\nac_prog=ld\nif test \"$GCC\" = yes; then\n  # Check if gcc -print-prog-name=ld gives a path.\n  AC_MSG_CHECKING([for ld used by $CC])\n  case $host in\n  *-*-mingw*)\n    # gcc leaves a trailing carriage return which upsets mingw\n    ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\\015'` ;;\n  *)\n    ac_prog=`($CC -print-prog-name=ld) 2>&5` ;;\n  esac\n  case $ac_prog in\n    # Accept absolute paths.\n    [[\\\\/]]* | ?:[[\\\\/]]*)\n      re_direlt='/[[^/]][[^/]]*/\\.\\./'\n      # Canonicalize the pathname of ld\n      ac_prog=`$ECHO \"$ac_prog\"| $SED 's%\\\\\\\\%/%g'`\n      while $ECHO \"$ac_prog\" | $GREP \"$re_direlt\" > /dev/null 2>&1; do\n\tac_prog=`$ECHO $ac_prog| $SED \"s%$re_direlt%/%\"`\n      done\n      test -z \"$LD\" && LD=\"$ac_prog\"\n      ;;\n  \"\")\n    # If it fails, then pretend we aren't using GCC.\n    ac_prog=ld\n    ;;\n  *)\n    # If it is relative, then search for the first ld in PATH.\n    with_gnu_ld=unknown\n    ;;\n  esac\nelif test \"$with_gnu_ld\" = yes; then\n  AC_MSG_CHECKING([for GNU ld])\nelse\n  AC_MSG_CHECKING([for non-GNU ld])\nfi\nAC_CACHE_VAL(lt_cv_path_LD,\n[if test -z \"$LD\"; then\n  lt_save_ifs=\"$IFS\"; IFS=$PATH_SEPARATOR\n  for ac_dir in $PATH; do\n    IFS=\"$lt_save_ifs\"\n    test -z \"$ac_dir\" && ac_dir=.\n    if test -f \"$ac_dir/$ac_prog\" || test -f \"$ac_dir/$ac_prog$ac_exeext\"; then\n      lt_cv_path_LD=\"$ac_dir/$ac_prog\"\n      # Check to see if the program is GNU ld.  I'd rather use --version,\n      # but apparently some variants of GNU ld only accept -v.\n      # Break only if it was the GNU/non-GNU ld that we prefer.\n      case `\"$lt_cv_path_LD\" -v 2>&1 </dev/null` in\n      *GNU* | *'with BFD'*)\n\ttest \"$with_gnu_ld\" != no && break\n\t;;\n      *)\n\ttest \"$with_gnu_ld\" != yes && break\n\t;;\n      esac\n    fi\n  done\n  IFS=\"$lt_save_ifs\"\nelse\n  lt_cv_path_LD=\"$LD\" # Let the user override the test with a path.\nfi])\nLD=\"$lt_cv_path_LD\"\nif test -n \"$LD\"; then\n  AC_MSG_RESULT($LD)\nelse\n  AC_MSG_RESULT(no)\nfi\ntest -z \"$LD\" && AC_MSG_ERROR([no acceptable ld found in \\$PATH])\n_LT_PATH_LD_GNU\nAC_SUBST([LD])\n\n_LT_TAGDECL([], [LD], [1], [The linker used to build libraries])\n])# LT_PATH_LD\n\n# Old names:\nAU_ALIAS([AM_PROG_LD], [LT_PATH_LD])\nAU_ALIAS([AC_PROG_LD], [LT_PATH_LD])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AM_PROG_LD], [])\ndnl AC_DEFUN([AC_PROG_LD], [])\n\n\n# _LT_PATH_LD_GNU\n#- --------------\nm4_defun([_LT_PATH_LD_GNU],\n[AC_CACHE_CHECK([if the linker ($LD) is GNU ld], lt_cv_prog_gnu_ld,\n[# I'd rather use --version here, but apparently some GNU lds only accept -v.\ncase `$LD -v 2>&1 </dev/null` in\n*GNU* | *'with BFD'*)\n  lt_cv_prog_gnu_ld=yes\n  ;;\n*)\n  lt_cv_prog_gnu_ld=no\n  ;;\nesac])\nwith_gnu_ld=$lt_cv_prog_gnu_ld\n])# _LT_PATH_LD_GNU\n\n\n# _LT_CMD_RELOAD\n# --------------\n# find reload flag for linker\n#   -- PORTME Some linkers may need a different reload flag.\nm4_defun([_LT_CMD_RELOAD],\n[AC_CACHE_CHECK([for $LD option to reload object files],\n  lt_cv_ld_reload_flag,\n  [lt_cv_ld_reload_flag='-r'])\nreload_flag=$lt_cv_ld_reload_flag\ncase $reload_flag in\n\"\" | \" \"*) ;;\n*) reload_flag=\" $reload_flag\" ;;\nesac\nreload_cmds='$LD$reload_flag -o $output$reload_objs'\ncase $host_os in\n  cygwin* | mingw* | pw32* | cegcc*)\n    if test \"$GCC\" != yes; then\n      reload_cmds=false\n    fi\n    ;;\n  darwin*)\n    if test \"$GCC\" = yes; then\n      reload_cmds='$LTCC $LTCFLAGS -nostdlib ${wl}-r -o $output$reload_objs'\n    else\n      reload_cmds='$LD$reload_flag -o $output$reload_objs'\n    fi\n    ;;\nesac\n_LT_TAGDECL([], [reload_flag], [1], [How to create reloadable object files])dnl\n_LT_TAGDECL([], [reload_cmds], [2])dnl\n])# _LT_CMD_RELOAD\n\n\n# _LT_CHECK_MAGIC_METHOD\n# ----------------------\n# how to check for library dependencies\n#  -- PORTME fill in with the dynamic library characteristics\nm4_defun([_LT_CHECK_MAGIC_METHOD],\n[m4_require([_LT_DECL_EGREP])\nm4_require([_LT_DECL_OBJDUMP])\nAC_CACHE_CHECK([how to recognize dependent libraries],\nlt_cv_deplibs_check_method,\n[lt_cv_file_magic_cmd='$MAGIC_CMD'\nlt_cv_file_magic_test_file=\nlt_cv_deplibs_check_method='unknown'\n# Need to set the preceding variable on all platforms that support\n# interlibrary dependencies.\n# 'none' -- dependencies not supported.\n# `unknown' -- same as none, but documents that we really don't know.\n# 'pass_all' -- all dependencies passed with no checks.\n# 'test_compile' -- check by making test program.\n# 'file_magic [[regex]]' -- check by looking for files in library path\n# which responds to the $file_magic_cmd with a given extended regex.\n# If you have `file' or equivalent on your system and you're not sure\n# whether `pass_all' will *always* work, you probably want this one.\n\ncase $host_os in\naix[[4-9]]*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nbeos*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nbsdi[[45]]*)\n  lt_cv_deplibs_check_method='file_magic ELF [[0-9]][[0-9]]*-bit [[ML]]SB (shared object|dynamic lib)'\n  lt_cv_file_magic_cmd='/usr/bin/file -L'\n  lt_cv_file_magic_test_file=/shlib/libc.so\n  ;;\n\ncygwin*)\n  # func_win32_libid is a shell function defined in ltmain.sh\n  lt_cv_deplibs_check_method='file_magic ^x86 archive import|^x86 DLL'\n  lt_cv_file_magic_cmd='func_win32_libid'\n  ;;\n\nmingw* | pw32*)\n  # Base MSYS/MinGW do not provide the 'file' command needed by\n  # func_win32_libid shell function, so use a weaker test based on 'objdump',\n  # unless we find 'file', for example because we are cross-compiling.\n  # func_win32_libid assumes BSD nm, so disallow it if using MS dumpbin.\n  if ( test \"$lt_cv_nm_interface\" = \"BSD nm\" && file / ) >/dev/null 2>&1; then\n    lt_cv_deplibs_check_method='file_magic ^x86 archive import|^x86 DLL'\n    lt_cv_file_magic_cmd='func_win32_libid'\n  else\n    # Keep this pattern in sync with the one in func_win32_libid.\n    lt_cv_deplibs_check_method='file_magic file format (pei*-i386(.*architecture: i386)?|pe-arm-wince|pe-x86-64)'\n    lt_cv_file_magic_cmd='$OBJDUMP -f'\n  fi\n  ;;\n\ncegcc*)\n  # use the weaker test based on 'objdump'. See mingw*.\n  lt_cv_deplibs_check_method='file_magic file format pe-arm-.*little(.*architecture: arm)?'\n  lt_cv_file_magic_cmd='$OBJDUMP -f'\n  ;;\n\ndarwin* | rhapsody*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nfreebsd* | dragonfly*)\n  if echo __ELF__ | $CC -E - | $GREP __ELF__ > /dev/null; then\n    case $host_cpu in\n    i*86 )\n      # Not sure whether the presence of OpenBSD here was a mistake.\n      # Let's accept both of them until this is cleared up.\n      lt_cv_deplibs_check_method='file_magic (FreeBSD|OpenBSD|DragonFly)/i[[3-9]]86 (compact )?demand paged shared library'\n      lt_cv_file_magic_cmd=/usr/bin/file\n      lt_cv_file_magic_test_file=`echo /usr/lib/libc.so.*`\n      ;;\n    esac\n  else\n    lt_cv_deplibs_check_method=pass_all\n  fi\n  ;;\n\ngnu*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nhaiku*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nhpux10.20* | hpux11*)\n  lt_cv_file_magic_cmd=/usr/bin/file\n  case $host_cpu in\n  ia64*)\n    lt_cv_deplibs_check_method='file_magic (s[[0-9]][[0-9]][[0-9]]|ELF-[[0-9]][[0-9]]) shared object file - IA64'\n    lt_cv_file_magic_test_file=/usr/lib/hpux32/libc.so\n    ;;\n  hppa*64*)\n    [lt_cv_deplibs_check_method='file_magic (s[0-9][0-9][0-9]|ELF[ -][0-9][0-9])(-bit)?( [LM]SB)? shared object( file)?[, -]* PA-RISC [0-9]\\.[0-9]']\n    lt_cv_file_magic_test_file=/usr/lib/pa20_64/libc.sl\n    ;;\n  *)\n    lt_cv_deplibs_check_method='file_magic (s[[0-9]][[0-9]][[0-9]]|PA-RISC[[0-9]]\\.[[0-9]]) shared library'\n    lt_cv_file_magic_test_file=/usr/lib/libc.sl\n    ;;\n  esac\n  ;;\n\ninterix[[3-9]]*)\n  # PIC code is broken on Interix 3.x, that's why |\\.a not |_pic\\.a here\n  lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\\.so|\\.a)$'\n  ;;\n\nirix5* | irix6* | nonstopux*)\n  case $LD in\n  *-32|*\"-32 \") libmagic=32-bit;;\n  *-n32|*\"-n32 \") libmagic=N32;;\n  *-64|*\"-64 \") libmagic=64-bit;;\n  *) libmagic=never-match;;\n  esac\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\n# This must be glibc/ELF.\nlinux* | k*bsd*-gnu | kopensolaris*-gnu)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nnetbsd* | netbsdelf*-gnu)\n  if echo __ELF__ | $CC -E - | $GREP __ELF__ > /dev/null; then\n    lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\\.so\\.[[0-9]]+\\.[[0-9]]+|_pic\\.a)$'\n  else\n    lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\\.so|_pic\\.a)$'\n  fi\n  ;;\n\nnewos6*)\n  lt_cv_deplibs_check_method='file_magic ELF [[0-9]][[0-9]]*-bit [[ML]]SB (executable|dynamic lib)'\n  lt_cv_file_magic_cmd=/usr/bin/file\n  lt_cv_file_magic_test_file=/usr/lib/libnls.so\n  ;;\n\n*nto* | *qnx*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nopenbsd*)\n  if test -z \"`echo __ELF__ | $CC -E - | $GREP __ELF__`\" || test \"$host_os-$host_cpu\" = \"openbsd2.8-powerpc\"; then\n    lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\\.so\\.[[0-9]]+\\.[[0-9]]+|\\.so|_pic\\.a)$'\n  else\n    lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\\.so\\.[[0-9]]+\\.[[0-9]]+|_pic\\.a)$'\n  fi\n  ;;\n\nosf3* | osf4* | osf5*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nrdos*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nsolaris*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nsysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nsysv4 | sysv4.3*)\n  case $host_vendor in\n  motorola)\n    lt_cv_deplibs_check_method='file_magic ELF [[0-9]][[0-9]]*-bit [[ML]]SB (shared object|dynamic lib) M[[0-9]][[0-9]]* Version [[0-9]]'\n    lt_cv_file_magic_test_file=`echo /usr/lib/libc.so*`\n    ;;\n  ncr)\n    lt_cv_deplibs_check_method=pass_all\n    ;;\n  sequent)\n    lt_cv_file_magic_cmd='/bin/file'\n    lt_cv_deplibs_check_method='file_magic ELF [[0-9]][[0-9]]*-bit [[LM]]SB (shared object|dynamic lib )'\n    ;;\n  sni)\n    lt_cv_file_magic_cmd='/bin/file'\n    lt_cv_deplibs_check_method=\"file_magic ELF [[0-9]][[0-9]]*-bit [[LM]]SB dynamic lib\"\n    lt_cv_file_magic_test_file=/lib/libc.so\n    ;;\n  siemens)\n    lt_cv_deplibs_check_method=pass_all\n    ;;\n  pc)\n    lt_cv_deplibs_check_method=pass_all\n    ;;\n  esac\n  ;;\n\ntpf*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\nesac\n])\n\nfile_magic_glob=\nwant_nocaseglob=no\nif test \"$build\" = \"$host\"; then\n  case $host_os in\n  mingw* | pw32*)\n    if ( shopt | grep nocaseglob ) >/dev/null 2>&1; then\n      want_nocaseglob=yes\n    else\n      file_magic_glob=`echo aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ | $SED -e \"s/\\(..\\)/s\\/[[\\1]]\\/[[\\1]]\\/g;/g\"`\n    fi\n    ;;\n  esac\nfi\n\nfile_magic_cmd=$lt_cv_file_magic_cmd\ndeplibs_check_method=$lt_cv_deplibs_check_method\ntest -z \"$deplibs_check_method\" && deplibs_check_method=unknown\n\n_LT_DECL([], [deplibs_check_method], [1],\n    [Method to check whether dependent libraries are shared objects])\n_LT_DECL([], [file_magic_cmd], [1],\n    [Command to use when deplibs_check_method = \"file_magic\"])\n_LT_DECL([], [file_magic_glob], [1],\n    [How to find potential files when deplibs_check_method = \"file_magic\"])\n_LT_DECL([], [want_nocaseglob], [1],\n    [Find potential files using nocaseglob when deplibs_check_method = \"file_magic\"])\n])# _LT_CHECK_MAGIC_METHOD\n\n\n# LT_PATH_NM\n# ----------\n# find the pathname to a BSD- or MS-compatible name lister\nAC_DEFUN([LT_PATH_NM],\n[AC_REQUIRE([AC_PROG_CC])dnl\nAC_CACHE_CHECK([for BSD- or MS-compatible name lister (nm)], lt_cv_path_NM,\n[if test -n \"$NM\"; then\n  # Let the user override the test.\n  lt_cv_path_NM=\"$NM\"\nelse\n  lt_nm_to_check=\"${ac_tool_prefix}nm\"\n  if test -n \"$ac_tool_prefix\" && test \"$build\" = \"$host\"; then\n    lt_nm_to_check=\"$lt_nm_to_check nm\"\n  fi\n  for lt_tmp_nm in $lt_nm_to_check; do\n    lt_save_ifs=\"$IFS\"; IFS=$PATH_SEPARATOR\n    for ac_dir in $PATH /usr/ccs/bin/elf /usr/ccs/bin /usr/ucb /bin; do\n      IFS=\"$lt_save_ifs\"\n      test -z \"$ac_dir\" && ac_dir=.\n      tmp_nm=\"$ac_dir/$lt_tmp_nm\"\n      if test -f \"$tmp_nm\" || test -f \"$tmp_nm$ac_exeext\" ; then\n\t# Check to see if the nm accepts a BSD-compat flag.\n\t# Adding the `sed 1q' prevents false positives on HP-UX, which says:\n\t#   nm: unknown option \"B\" ignored\n\t# Tru64's nm complains that /dev/null is an invalid object file\n\tcase `\"$tmp_nm\" -B /dev/null 2>&1 | sed '1q'` in\n\t*/dev/null* | *'Invalid file or object type'*)\n\t  lt_cv_path_NM=\"$tmp_nm -B\"\n\t  break\n\t  ;;\n\t*)\n\t  case `\"$tmp_nm\" -p /dev/null 2>&1 | sed '1q'` in\n\t  */dev/null*)\n\t    lt_cv_path_NM=\"$tmp_nm -p\"\n\t    break\n\t    ;;\n\t  *)\n\t    lt_cv_path_NM=${lt_cv_path_NM=\"$tmp_nm\"} # keep the first match, but\n\t    continue # so that we can try to find one that supports BSD flags\n\t    ;;\n\t  esac\n\t  ;;\n\tesac\n      fi\n    done\n    IFS=\"$lt_save_ifs\"\n  done\n  : ${lt_cv_path_NM=no}\nfi])\nif test \"$lt_cv_path_NM\" != \"no\"; then\n  NM=\"$lt_cv_path_NM\"\nelse\n  # Didn't find any BSD compatible name lister, look for dumpbin.\n  if test -n \"$DUMPBIN\"; then :\n    # Let the user override the test.\n  else\n    AC_CHECK_TOOLS(DUMPBIN, [dumpbin \"link -dump\"], :)\n    case `$DUMPBIN -symbols /dev/null 2>&1 | sed '1q'` in\n    *COFF*)\n      DUMPBIN=\"$DUMPBIN -symbols\"\n      ;;\n    *)\n      DUMPBIN=:\n      ;;\n    esac\n  fi\n  AC_SUBST([DUMPBIN])\n  if test \"$DUMPBIN\" != \":\"; then\n    NM=\"$DUMPBIN\"\n  fi\nfi\ntest -z \"$NM\" && NM=nm\nAC_SUBST([NM])\n_LT_DECL([], [NM], [1], [A BSD- or MS-compatible name lister])dnl\n\nAC_CACHE_CHECK([the name lister ($NM) interface], [lt_cv_nm_interface],\n  [lt_cv_nm_interface=\"BSD nm\"\n  echo \"int some_variable = 0;\" > conftest.$ac_ext\n  (eval echo \"\\\"\\$as_me:$LINENO: $ac_compile\\\"\" >&AS_MESSAGE_LOG_FD)\n  (eval \"$ac_compile\" 2>conftest.err)\n  cat conftest.err >&AS_MESSAGE_LOG_FD\n  (eval echo \"\\\"\\$as_me:$LINENO: $NM \\\\\\\"conftest.$ac_objext\\\\\\\"\\\"\" >&AS_MESSAGE_LOG_FD)\n  (eval \"$NM \\\"conftest.$ac_objext\\\"\" 2>conftest.err > conftest.out)\n  cat conftest.err >&AS_MESSAGE_LOG_FD\n  (eval echo \"\\\"\\$as_me:$LINENO: output\\\"\" >&AS_MESSAGE_LOG_FD)\n  cat conftest.out >&AS_MESSAGE_LOG_FD\n  if $GREP 'External.*some_variable' conftest.out > /dev/null; then\n    lt_cv_nm_interface=\"MS dumpbin\"\n  fi\n  rm -f conftest*])\n])# LT_PATH_NM\n\n# Old names:\nAU_ALIAS([AM_PROG_NM], [LT_PATH_NM])\nAU_ALIAS([AC_PROG_NM], [LT_PATH_NM])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AM_PROG_NM], [])\ndnl AC_DEFUN([AC_PROG_NM], [])\n\n# _LT_CHECK_SHAREDLIB_FROM_LINKLIB\n# --------------------------------\n# how to determine the name of the shared library\n# associated with a specific link library.\n#  -- PORTME fill in with the dynamic library characteristics\nm4_defun([_LT_CHECK_SHAREDLIB_FROM_LINKLIB],\n[m4_require([_LT_DECL_EGREP])\nm4_require([_LT_DECL_OBJDUMP])\nm4_require([_LT_DECL_DLLTOOL])\nAC_CACHE_CHECK([how to associate runtime and link libraries],\nlt_cv_sharedlib_from_linklib_cmd,\n[lt_cv_sharedlib_from_linklib_cmd='unknown'\n\ncase $host_os in\ncygwin* | mingw* | pw32* | cegcc*)\n  # two different shell functions defined in ltmain.sh\n  # decide which to use based on capabilities of $DLLTOOL\n  case `$DLLTOOL --help 2>&1` in\n  *--identify-strict*)\n    lt_cv_sharedlib_from_linklib_cmd=func_cygming_dll_for_implib\n    ;;\n  *)\n    lt_cv_sharedlib_from_linklib_cmd=func_cygming_dll_for_implib_fallback\n    ;;\n  esac\n  ;;\n*)\n  # fallback: assume linklib IS sharedlib\n  lt_cv_sharedlib_from_linklib_cmd=\"$ECHO\"\n  ;;\nesac\n])\nsharedlib_from_linklib_cmd=$lt_cv_sharedlib_from_linklib_cmd\ntest -z \"$sharedlib_from_linklib_cmd\" && sharedlib_from_linklib_cmd=$ECHO\n\n_LT_DECL([], [sharedlib_from_linklib_cmd], [1],\n    [Command to associate shared and link libraries])\n])# _LT_CHECK_SHAREDLIB_FROM_LINKLIB\n\n\n# _LT_PATH_MANIFEST_TOOL\n# ----------------------\n# locate the manifest tool\nm4_defun([_LT_PATH_MANIFEST_TOOL],\n[AC_CHECK_TOOL(MANIFEST_TOOL, mt, :)\ntest -z \"$MANIFEST_TOOL\" && MANIFEST_TOOL=mt\nAC_CACHE_CHECK([if $MANIFEST_TOOL is a manifest tool], [lt_cv_path_mainfest_tool],\n  [lt_cv_path_mainfest_tool=no\n  echo \"$as_me:$LINENO: $MANIFEST_TOOL '-?'\" >&AS_MESSAGE_LOG_FD\n  $MANIFEST_TOOL '-?' 2>conftest.err > conftest.out\n  cat conftest.err >&AS_MESSAGE_LOG_FD\n  if $GREP 'Manifest Tool' conftest.out > /dev/null; then\n    lt_cv_path_mainfest_tool=yes\n  fi\n  rm -f conftest*])\nif test \"x$lt_cv_path_mainfest_tool\" != xyes; then\n  MANIFEST_TOOL=:\nfi\n_LT_DECL([], [MANIFEST_TOOL], [1], [Manifest tool])dnl\n])# _LT_PATH_MANIFEST_TOOL\n\n\n# LT_LIB_M\n# --------\n# check for math library\nAC_DEFUN([LT_LIB_M],\n[AC_REQUIRE([AC_CANONICAL_HOST])dnl\nLIBM=\ncase $host in\n*-*-beos* | *-*-cegcc* | *-*-cygwin* | *-*-haiku* | *-*-pw32* | *-*-darwin*)\n  # These system don't have libm, or don't need it\n  ;;\n*-ncr-sysv4.3*)\n  AC_CHECK_LIB(mw, _mwvalidcheckl, LIBM=\"-lmw\")\n  AC_CHECK_LIB(m, cos, LIBM=\"$LIBM -lm\")\n  ;;\n*)\n  AC_CHECK_LIB(m, cos, LIBM=\"-lm\")\n  ;;\nesac\nAC_SUBST([LIBM])\n])# LT_LIB_M\n\n# Old name:\nAU_ALIAS([AC_CHECK_LIBM], [LT_LIB_M])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_CHECK_LIBM], [])\n\n\n# _LT_COMPILER_NO_RTTI([TAGNAME])\n# -------------------------------\nm4_defun([_LT_COMPILER_NO_RTTI],\n[m4_require([_LT_TAG_COMPILER])dnl\n\n_LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=\n\nif test \"$GCC\" = yes; then\n  case $cc_basename in\n  nvcc*)\n    _LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=' -Xcompiler -fno-builtin' ;;\n  *)\n    _LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=' -fno-builtin' ;;\n  esac\n\n  _LT_COMPILER_OPTION([if $compiler supports -fno-rtti -fno-exceptions],\n    lt_cv_prog_compiler_rtti_exceptions,\n    [-fno-rtti -fno-exceptions], [],\n    [_LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=\"$_LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1) -fno-rtti -fno-exceptions\"])\nfi\n_LT_TAGDECL([no_builtin_flag], [lt_prog_compiler_no_builtin_flag], [1],\n\t[Compiler flag to turn off builtin functions])\n])# _LT_COMPILER_NO_RTTI\n\n\n# _LT_CMD_GLOBAL_SYMBOLS\n# ----------------------\nm4_defun([_LT_CMD_GLOBAL_SYMBOLS],\n[AC_REQUIRE([AC_CANONICAL_HOST])dnl\nAC_REQUIRE([AC_PROG_CC])dnl\nAC_REQUIRE([AC_PROG_AWK])dnl\nAC_REQUIRE([LT_PATH_NM])dnl\nAC_REQUIRE([LT_PATH_LD])dnl\nm4_require([_LT_DECL_SED])dnl\nm4_require([_LT_DECL_EGREP])dnl\nm4_require([_LT_TAG_COMPILER])dnl\n\n# Check for command to grab the raw symbol name followed by C symbol from nm.\nAC_MSG_CHECKING([command to parse $NM output from $compiler object])\nAC_CACHE_VAL([lt_cv_sys_global_symbol_pipe],\n[\n# These are sane defaults that work on at least a few old systems.\n# [They come from Ultrix.  What could be older than Ultrix?!! ;)]\n\n# Character class describing NM global symbol codes.\nsymcode='[[BCDEGRST]]'\n\n# Regexp to match symbols that can be accessed directly from C.\nsympat='\\([[_A-Za-z]][[_A-Za-z0-9]]*\\)'\n\n# Define system-specific variables.\ncase $host_os in\naix*)\n  symcode='[[BCDT]]'\n  ;;\ncygwin* | mingw* | pw32* | cegcc*)\n  symcode='[[ABCDGISTW]]'\n  ;;\nhpux*)\n  if test \"$host_cpu\" = ia64; then\n    symcode='[[ABCDEGRST]]'\n  fi\n  ;;\nirix* | nonstopux*)\n  symcode='[[BCDEGRST]]'\n  ;;\nosf*)\n  symcode='[[BCDEGQRST]]'\n  ;;\nsolaris*)\n  symcode='[[BDRT]]'\n  ;;\nsco3.2v5*)\n  symcode='[[DT]]'\n  ;;\nsysv4.2uw2*)\n  symcode='[[DT]]'\n  ;;\nsysv5* | sco5v6* | unixware* | OpenUNIX*)\n  symcode='[[ABDT]]'\n  ;;\nsysv4)\n  symcode='[[DFNSTU]]'\n  ;;\nesac\n\n# If we're using GNU nm, then use its standard symbol codes.\ncase `$NM -V 2>&1` in\n*GNU* | *'with BFD'*)\n  symcode='[[ABCDGIRSTW]]' ;;\nesac\n\n# Transform an extracted symbol line into a proper C declaration.\n# Some systems (esp. on ia64) link data and code symbols differently,\n# so use this general approach.\nlt_cv_sys_global_symbol_to_cdecl=\"sed -n -e 's/^T .* \\(.*\\)$/extern int \\1();/p' -e 's/^$symcode* .* \\(.*\\)$/extern char \\1;/p'\"\n\n# Transform an extracted symbol line into symbol name and symbol address\nlt_cv_sys_global_symbol_to_c_name_address=\"sed -n -e 's/^: \\([[^ ]]*\\)[[ ]]*$/  {\\\\\\\"\\1\\\\\\\", (void *) 0},/p' -e 's/^$symcode* \\([[^ ]]*\\) \\([[^ ]]*\\)$/  {\\\"\\2\\\", (void *) \\&\\2},/p'\"\nlt_cv_sys_global_symbol_to_c_name_address_lib_prefix=\"sed -n -e 's/^: \\([[^ ]]*\\)[[ ]]*$/  {\\\\\\\"\\1\\\\\\\", (void *) 0},/p' -e 's/^$symcode* \\([[^ ]]*\\) \\(lib[[^ ]]*\\)$/  {\\\"\\2\\\", (void *) \\&\\2},/p' -e 's/^$symcode* \\([[^ ]]*\\) \\([[^ ]]*\\)$/  {\\\"lib\\2\\\", (void *) \\&\\2},/p'\"\n\n# Handle CRLF in mingw tool chain\nopt_cr=\ncase $build_os in\nmingw*)\n  opt_cr=`$ECHO 'x\\{0,1\\}' | tr x '\\015'` # option cr in regexp\n  ;;\nesac\n\n# Try without a prefix underscore, then with it.\nfor ac_symprfx in \"\" \"_\"; do\n\n  # Transform symcode, sympat, and symprfx into a raw symbol and a C symbol.\n  symxfrm=\"\\\\1 $ac_symprfx\\\\2 \\\\2\"\n\n  # Write the raw and C identifiers.\n  if test \"$lt_cv_nm_interface\" = \"MS dumpbin\"; then\n    # Fake it for dumpbin and say T for any non-static function\n    # and D for any global variable.\n    # Also find C++ and __fastcall symbols from MSVC++,\n    # which start with @ or ?.\n    lt_cv_sys_global_symbol_pipe=\"$AWK ['\"\\\n\"     {last_section=section; section=\\$ 3};\"\\\n\"     /^COFF SYMBOL TABLE/{for(i in hide) delete hide[i]};\"\\\n\"     /Section length .*#relocs.*(pick any)/{hide[last_section]=1};\"\\\n\"     \\$ 0!~/External *\\|/{next};\"\\\n\"     / 0+ UNDEF /{next}; / UNDEF \\([^|]\\)*()/{next};\"\\\n\"     {if(hide[section]) next};\"\\\n\"     {f=0}; \\$ 0~/\\(\\).*\\|/{f=1}; {printf f ? \\\"T \\\" : \\\"D \\\"};\"\\\n\"     {split(\\$ 0, a, /\\||\\r/); split(a[2], s)};\"\\\n\"     s[1]~/^[@?]/{print s[1], s[1]; next};\"\\\n\"     s[1]~prfx {split(s[1],t,\\\"@\\\"); print t[1], substr(t[1],length(prfx))}\"\\\n\"     ' prfx=^$ac_symprfx]\"\n  else\n    lt_cv_sys_global_symbol_pipe=\"sed -n -e 's/^.*[[\t ]]\\($symcode$symcode*\\)[[\t ]][[\t ]]*$ac_symprfx$sympat$opt_cr$/$symxfrm/p'\"\n  fi\n  lt_cv_sys_global_symbol_pipe=\"$lt_cv_sys_global_symbol_pipe | sed '/ __gnu_lto/d'\"\n\n  # Check to see that the pipe works correctly.\n  pipe_works=no\n\n  rm -f conftest*\n  cat > conftest.$ac_ext <<_LT_EOF\n#ifdef __cplusplus\nextern \"C\" {\n#endif\nchar nm_test_var;\nvoid nm_test_func(void);\nvoid nm_test_func(void){}\n#ifdef __cplusplus\n}\n#endif\nint main(){nm_test_var='a';nm_test_func();return(0);}\n_LT_EOF\n\n  if AC_TRY_EVAL(ac_compile); then\n    # Now try to grab the symbols.\n    nlist=conftest.nm\n    if AC_TRY_EVAL(NM conftest.$ac_objext \\| \"$lt_cv_sys_global_symbol_pipe\" \\> $nlist) && test -s \"$nlist\"; then\n      # Try sorting and uniquifying the output.\n      if sort \"$nlist\" | uniq > \"$nlist\"T; then\n\tmv -f \"$nlist\"T \"$nlist\"\n      else\n\trm -f \"$nlist\"T\n      fi\n\n      # Make sure that we snagged all the symbols we need.\n      if $GREP ' nm_test_var$' \"$nlist\" >/dev/null; then\n\tif $GREP ' nm_test_func$' \"$nlist\" >/dev/null; then\n\t  cat <<_LT_EOF > conftest.$ac_ext\n/* Keep this code in sync between libtool.m4, ltmain, lt_system.h, and tests.  */\n#if defined(_WIN32) || defined(__CYGWIN__) || defined(_WIN32_WCE)\n/* DATA imports from DLLs on WIN32 con't be const, because runtime\n   relocations are performed -- see ld's documentation on pseudo-relocs.  */\n# define LT@&t@_DLSYM_CONST\n#elif defined(__osf__)\n/* This system does not cope well with relocations in const data.  */\n# define LT@&t@_DLSYM_CONST\n#else\n# define LT@&t@_DLSYM_CONST const\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n_LT_EOF\n\t  # Now generate the symbol file.\n\t  eval \"$lt_cv_sys_global_symbol_to_cdecl\"' < \"$nlist\" | $GREP -v main >> conftest.$ac_ext'\n\n\t  cat <<_LT_EOF >> conftest.$ac_ext\n\n/* The mapping between symbol names and symbols.  */\nLT@&t@_DLSYM_CONST struct {\n  const char *name;\n  void       *address;\n}\nlt__PROGRAM__LTX_preloaded_symbols[[]] =\n{\n  { \"@PROGRAM@\", (void *) 0 },\n_LT_EOF\n\t  $SED \"s/^$symcode$symcode* \\(.*\\) \\(.*\\)$/  {\\\"\\2\\\", (void *) \\&\\2},/\" < \"$nlist\" | $GREP -v main >> conftest.$ac_ext\n\t  cat <<\\_LT_EOF >> conftest.$ac_ext\n  {0, (void *) 0}\n};\n\n/* This works around a problem in FreeBSD linker */\n#ifdef FREEBSD_WORKAROUND\nstatic const void *lt_preloaded_setup() {\n  return lt__PROGRAM__LTX_preloaded_symbols;\n}\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n_LT_EOF\n\t  # Now try linking the two files.\n\t  mv conftest.$ac_objext conftstm.$ac_objext\n\t  lt_globsym_save_LIBS=$LIBS\n\t  lt_globsym_save_CFLAGS=$CFLAGS\n\t  LIBS=\"conftstm.$ac_objext\"\n\t  CFLAGS=\"$CFLAGS$_LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)\"\n\t  if AC_TRY_EVAL(ac_link) && test -s conftest${ac_exeext}; then\n\t    pipe_works=yes\n\t  fi\n\t  LIBS=$lt_globsym_save_LIBS\n\t  CFLAGS=$lt_globsym_save_CFLAGS\n\telse\n\t  echo \"cannot find nm_test_func in $nlist\" >&AS_MESSAGE_LOG_FD\n\tfi\n      else\n\techo \"cannot find nm_test_var in $nlist\" >&AS_MESSAGE_LOG_FD\n      fi\n    else\n      echo \"cannot run $lt_cv_sys_global_symbol_pipe\" >&AS_MESSAGE_LOG_FD\n    fi\n  else\n    echo \"$progname: failed program was:\" >&AS_MESSAGE_LOG_FD\n    cat conftest.$ac_ext >&5\n  fi\n  rm -rf conftest* conftst*\n\n  # Do not use the global_symbol_pipe unless it works.\n  if test \"$pipe_works\" = yes; then\n    break\n  else\n    lt_cv_sys_global_symbol_pipe=\n  fi\ndone\n])\nif test -z \"$lt_cv_sys_global_symbol_pipe\"; then\n  lt_cv_sys_global_symbol_to_cdecl=\nfi\nif test -z \"$lt_cv_sys_global_symbol_pipe$lt_cv_sys_global_symbol_to_cdecl\"; then\n  AC_MSG_RESULT(failed)\nelse\n  AC_MSG_RESULT(ok)\nfi\n\n# Response file support.\nif test \"$lt_cv_nm_interface\" = \"MS dumpbin\"; then\n  nm_file_list_spec='@'\nelif $NM --help 2>/dev/null | grep '[[@]]FILE' >/dev/null; then\n  nm_file_list_spec='@'\nfi\n\n_LT_DECL([global_symbol_pipe], [lt_cv_sys_global_symbol_pipe], [1],\n    [Take the output of nm and produce a listing of raw symbols and C names])\n_LT_DECL([global_symbol_to_cdecl], [lt_cv_sys_global_symbol_to_cdecl], [1],\n    [Transform the output of nm in a proper C declaration])\n_LT_DECL([global_symbol_to_c_name_address],\n    [lt_cv_sys_global_symbol_to_c_name_address], [1],\n    [Transform the output of nm in a C name address pair])\n_LT_DECL([global_symbol_to_c_name_address_lib_prefix],\n    [lt_cv_sys_global_symbol_to_c_name_address_lib_prefix], [1],\n    [Transform the output of nm in a C name address pair when lib prefix is needed])\n_LT_DECL([], [nm_file_list_spec], [1],\n    [Specify filename containing input files for $NM])\n]) # _LT_CMD_GLOBAL_SYMBOLS\n\n\n# _LT_COMPILER_PIC([TAGNAME])\n# ---------------------------\nm4_defun([_LT_COMPILER_PIC],\n[m4_require([_LT_TAG_COMPILER])dnl\n_LT_TAGVAR(lt_prog_compiler_wl, $1)=\n_LT_TAGVAR(lt_prog_compiler_pic, $1)=\n_LT_TAGVAR(lt_prog_compiler_static, $1)=\n\nm4_if([$1], [CXX], [\n  # C++ specific cases for pic, static, wl, etc.\n  if test \"$GXX\" = yes; then\n    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n    _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n\n    case $host_os in\n    aix*)\n      # All AIX code is PIC.\n      if test \"$host_cpu\" = ia64; then\n\t# AIX 5 now supports IA64 processor\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      fi\n      ;;\n\n    amigaos*)\n      case $host_cpu in\n      powerpc)\n            # see comment about AmigaOS4 .so support\n            _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n        ;;\n      m68k)\n            # FIXME: we need at least 68020 code to build shared libraries, but\n            # adding the `-m68020' flag to GCC prevents building anything better,\n            # like `-m68040'.\n            _LT_TAGVAR(lt_prog_compiler_pic, $1)='-m68020 -resident32 -malways-restore-a4'\n        ;;\n      esac\n      ;;\n\n    beos* | irix5* | irix6* | nonstopux* | osf3* | osf4* | osf5*)\n      # PIC is the default for these OSes.\n      ;;\n    mingw* | cygwin* | os2* | pw32* | cegcc*)\n      # This hack is so that the source file can tell whether it is being\n      # built for inclusion in a dll (and should export symbols for example).\n      # Although the cygwin gcc ignores -fPIC, still need this for old-style\n      # (--disable-auto-import) libraries\n      m4_if([$1], [GCJ], [],\n\t[_LT_TAGVAR(lt_prog_compiler_pic, $1)='-DDLL_EXPORT'])\n      ;;\n    darwin* | rhapsody*)\n      # PIC is the default on this platform\n      # Common symbols not allowed in MH_DYLIB files\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fno-common'\n      ;;\n    *djgpp*)\n      # DJGPP does not support shared libraries at all\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)=\n      ;;\n    haiku*)\n      # PIC is the default for Haiku.\n      # The \"-static\" flag exists, but is broken.\n      _LT_TAGVAR(lt_prog_compiler_static, $1)=\n      ;;\n    interix[[3-9]]*)\n      # Interix 3.x gcc -fpic/-fPIC options generate broken code.\n      # Instead, we relocate shared libraries at runtime.\n      ;;\n    sysv4*MP*)\n      if test -d /usr/nec; then\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)=-Kconform_pic\n      fi\n      ;;\n    hpux*)\n      # PIC is the default for 64-bit PA HP-UX, but not for 32-bit\n      # PA HP-UX.  On IA64 HP-UX, PIC is the default but the pic flag\n      # sets the default TLS model and affects inlining.\n      case $host_cpu in\n      hppa*64*)\n\t;;\n      *)\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n\t;;\n      esac\n      ;;\n    *qnx* | *nto*)\n      # QNX uses GNU C++, but need to define -shared option too, otherwise\n      # it will coredump.\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC -shared'\n      ;;\n    *)\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n      ;;\n    esac\n  else\n    case $host_os in\n      aix[[4-9]]*)\n\t# All AIX code is PIC.\n\tif test \"$host_cpu\" = ia64; then\n\t  # AIX 5 now supports IA64 processor\n\t  _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\telse\n\t  _LT_TAGVAR(lt_prog_compiler_static, $1)='-bnso -bI:/lib/syscalls.exp'\n\tfi\n\t;;\n      chorus*)\n\tcase $cc_basename in\n\tcxch68*)\n\t  # Green Hills C++ Compiler\n\t  # _LT_TAGVAR(lt_prog_compiler_static, $1)=\"--no_auto_instantiation -u __main -u __premain -u _abort -r $COOL_DIR/lib/libOrb.a $MVME_DIR/lib/CC/libC.a $MVME_DIR/lib/classix/libcx.s.a\"\n\t  ;;\n\tesac\n\t;;\n      mingw* | cygwin* | os2* | pw32* | cegcc*)\n\t# This hack is so that the source file can tell whether it is being\n\t# built for inclusion in a dll (and should export symbols for example).\n\tm4_if([$1], [GCJ], [],\n\t  [_LT_TAGVAR(lt_prog_compiler_pic, $1)='-DDLL_EXPORT'])\n\t;;\n      dgux*)\n\tcase $cc_basename in\n\t  ec++*)\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t    ;;\n\t  ghcx*)\n\t    # Green Hills C++ Compiler\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      freebsd* | dragonfly*)\n\t# FreeBSD uses GNU C++\n\t;;\n      hpux9* | hpux10* | hpux11*)\n\tcase $cc_basename in\n\t  CC*)\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='${wl}-a ${wl}archive'\n\t    if test \"$host_cpu\" != ia64; then\n\t      _LT_TAGVAR(lt_prog_compiler_pic, $1)='+Z'\n\t    fi\n\t    ;;\n\t  aCC*)\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='${wl}-a ${wl}archive'\n\t    case $host_cpu in\n\t    hppa*64*|ia64*)\n\t      # +Z the default\n\t      ;;\n\t    *)\n\t      _LT_TAGVAR(lt_prog_compiler_pic, $1)='+Z'\n\t      ;;\n\t    esac\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      interix*)\n\t# This is c89, which is MS Visual C++ (no shared libs)\n\t# Anyone wants to do a port?\n\t;;\n      irix5* | irix6* | nonstopux*)\n\tcase $cc_basename in\n\t  CC*)\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n\t    # CC pic flag -KPIC is the default.\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      linux* | k*bsd*-gnu | kopensolaris*-gnu)\n\tcase $cc_basename in\n\t  KCC*)\n\t    # KAI C++ Compiler\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='--backend -Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n\t    ;;\n\t  ecpc* )\n\t    # old Intel C++ for x86_64 which still supported -KPIC.\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n\t    ;;\n\t  icpc* )\n\t    # Intel C++, used to be incompatible with GCC.\n\t    # ICC 10 doesn't accept -KPIC any more.\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n\t    ;;\n\t  pgCC* | pgcpp*)\n\t    # Portland Group C++ compiler\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fpic'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t    ;;\n\t  cxx*)\n\t    # Compaq C++\n\t    # Make sure the PIC flag is empty.  It appears that all Alpha\n\t    # Linux and Compaq Tru64 Unix objects are PIC.\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)=\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n\t    ;;\n\t  xlc* | xlC* | bgxl[[cC]]* | mpixl[[cC]]*)\n\t    # IBM XL 8.0, 9.0 on PPC and BlueGene\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-qpic'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-qstaticlink'\n\t    ;;\n\t  *)\n\t    case `$CC -V 2>&1 | sed 5q` in\n\t    *Sun\\ C*)\n\t      # Sun C++ 5.9\n\t      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld '\n\t      ;;\n\t    esac\n\t    ;;\n\tesac\n\t;;\n      lynxos*)\n\t;;\n      m88k*)\n\t;;\n      mvs*)\n\tcase $cc_basename in\n\t  cxx*)\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-W c,exportall'\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      netbsd* | netbsdelf*-gnu)\n\t;;\n      *qnx* | *nto*)\n        # QNX uses GNU C++, but need to define -shared option too, otherwise\n        # it will coredump.\n        _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC -shared'\n        ;;\n      osf3* | osf4* | osf5*)\n\tcase $cc_basename in\n\t  KCC*)\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='--backend -Wl,'\n\t    ;;\n\t  RCC*)\n\t    # Rational C++ 2.4.1\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'\n\t    ;;\n\t  cxx*)\n\t    # Digital/Compaq C++\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    # Make sure the PIC flag is empty.  It appears that all Alpha\n\t    # Linux and Compaq Tru64 Unix objects are PIC.\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)=\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      psos*)\n\t;;\n      solaris*)\n\tcase $cc_basename in\n\t  CC* | sunCC*)\n\t    # Sun C++ 4.2, 5.x and Centerline C++\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld '\n\t    ;;\n\t  gcx*)\n\t    # Green Hills C++ Compiler\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-PIC'\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      sunos4*)\n\tcase $cc_basename in\n\t  CC*)\n\t    # Sun C++ 4.x\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t    ;;\n\t  lcc*)\n\t    # Lucid\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      sysv5* | unixware* | sco3.2v5* | sco5v6* | OpenUNIX*)\n\tcase $cc_basename in\n\t  CC*)\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t    ;;\n\tesac\n\t;;\n      tandem*)\n\tcase $cc_basename in\n\t  NCC*)\n\t    # NonStop-UX NCC 3.20\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      vxworks*)\n\t;;\n      *)\n\t_LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no\n\t;;\n    esac\n  fi\n],\n[\n  if test \"$GCC\" = yes; then\n    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n    _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n\n    case $host_os in\n      aix*)\n      # All AIX code is PIC.\n      if test \"$host_cpu\" = ia64; then\n\t# AIX 5 now supports IA64 processor\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      fi\n      ;;\n\n    amigaos*)\n      case $host_cpu in\n      powerpc)\n            # see comment about AmigaOS4 .so support\n            _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n        ;;\n      m68k)\n            # FIXME: we need at least 68020 code to build shared libraries, but\n            # adding the `-m68020' flag to GCC prevents building anything better,\n            # like `-m68040'.\n            _LT_TAGVAR(lt_prog_compiler_pic, $1)='-m68020 -resident32 -malways-restore-a4'\n        ;;\n      esac\n      ;;\n\n    beos* | irix5* | irix6* | nonstopux* | osf3* | osf4* | osf5*)\n      # PIC is the default for these OSes.\n      ;;\n\n    mingw* | cygwin* | pw32* | os2* | cegcc*)\n      # This hack is so that the source file can tell whether it is being\n      # built for inclusion in a dll (and should export symbols for example).\n      # Although the cygwin gcc ignores -fPIC, still need this for old-style\n      # (--disable-auto-import) libraries\n      m4_if([$1], [GCJ], [],\n\t[_LT_TAGVAR(lt_prog_compiler_pic, $1)='-DDLL_EXPORT'])\n      ;;\n\n    darwin* | rhapsody*)\n      # PIC is the default on this platform\n      # Common symbols not allowed in MH_DYLIB files\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fno-common'\n      ;;\n\n    haiku*)\n      # PIC is the default for Haiku.\n      # The \"-static\" flag exists, but is broken.\n      _LT_TAGVAR(lt_prog_compiler_static, $1)=\n      ;;\n\n    hpux*)\n      # PIC is the default for 64-bit PA HP-UX, but not for 32-bit\n      # PA HP-UX.  On IA64 HP-UX, PIC is the default but the pic flag\n      # sets the default TLS model and affects inlining.\n      case $host_cpu in\n      hppa*64*)\n\t# +Z the default\n\t;;\n      *)\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n\t;;\n      esac\n      ;;\n\n    interix[[3-9]]*)\n      # Interix 3.x gcc -fpic/-fPIC options generate broken code.\n      # Instead, we relocate shared libraries at runtime.\n      ;;\n\n    msdosdjgpp*)\n      # Just because we use GCC doesn't mean we suddenly get shared libraries\n      # on systems that don't support them.\n      _LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no\n      enable_shared=no\n      ;;\n\n    *nto* | *qnx*)\n      # QNX uses GNU C++, but need to define -shared option too, otherwise\n      # it will coredump.\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC -shared'\n      ;;\n\n    sysv4*MP*)\n      if test -d /usr/nec; then\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)=-Kconform_pic\n      fi\n      ;;\n\n    *)\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n      ;;\n    esac\n\n    case $cc_basename in\n    nvcc*) # Cuda Compiler Driver 2.2\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Xlinker '\n      if test -n \"$_LT_TAGVAR(lt_prog_compiler_pic, $1)\"; then\n        _LT_TAGVAR(lt_prog_compiler_pic, $1)=\"-Xcompiler $_LT_TAGVAR(lt_prog_compiler_pic, $1)\"\n      fi\n      ;;\n    esac\n  else\n    # PORTME Check for flag to pass linker flags through the system compiler.\n    case $host_os in\n    aix*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      if test \"$host_cpu\" = ia64; then\n\t# AIX 5 now supports IA64 processor\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      else\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-bnso -bI:/lib/syscalls.exp'\n      fi\n      ;;\n\n    mingw* | cygwin* | pw32* | os2* | cegcc*)\n      # This hack is so that the source file can tell whether it is being\n      # built for inclusion in a dll (and should export symbols for example).\n      m4_if([$1], [GCJ], [],\n\t[_LT_TAGVAR(lt_prog_compiler_pic, $1)='-DDLL_EXPORT'])\n      ;;\n\n    hpux9* | hpux10* | hpux11*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      # PIC is the default for IA64 HP-UX and 64-bit HP-UX, but\n      # not for PA HP-UX.\n      case $host_cpu in\n      hppa*64*|ia64*)\n\t# +Z the default\n\t;;\n      *)\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='+Z'\n\t;;\n      esac\n      # Is there a better lt_prog_compiler_static that works with the bundled CC?\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='${wl}-a ${wl}archive'\n      ;;\n\n    irix5* | irix6* | nonstopux*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      # PIC (with -KPIC) is the default.\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n      ;;\n\n    linux* | k*bsd*-gnu | kopensolaris*-gnu)\n      case $cc_basename in\n      # old Intel for x86_64 which still supported -KPIC.\n      ecc*)\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n        ;;\n      # icc used to be incompatible with GCC.\n      # ICC 10 doesn't accept -KPIC any more.\n      icc* | ifort*)\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n        ;;\n      # Lahey Fortran 8.1.\n      lf95*)\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='--shared'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='--static'\n\t;;\n      nagfor*)\n\t# NAG Fortran compiler\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,-Wl,,'\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-PIC'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t;;\n      pgcc* | pgf77* | pgf90* | pgf95* | pgfortran*)\n        # Portland Group compilers (*not* the Pentium gcc compiler,\n\t# which looks to be a dead project)\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-fpic'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n        ;;\n      ccc*)\n        _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n        # All Alpha code is PIC.\n        _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n        ;;\n      xl* | bgxl* | bgf* | mpixl*)\n\t# IBM XL C 8.0/Fortran 10.1, 11.1 on PPC and BlueGene\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-qpic'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-qstaticlink'\n\t;;\n      *)\n\tcase `$CC -V 2>&1 | sed 5q` in\n\t*Sun\\ Ceres\\ Fortran* | *Sun*Fortran*\\ [[1-7]].* | *Sun*Fortran*\\ 8.[[0-3]]*)\n\t  # Sun Fortran 8.3 passes all unrecognized flags to the linker\n\t  _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t  _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t  _LT_TAGVAR(lt_prog_compiler_wl, $1)=''\n\t  ;;\n\t*Sun\\ F* | *Sun*Fortran*)\n\t  _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t  _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t  _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld '\n\t  ;;\n\t*Sun\\ C*)\n\t  # Sun C 5.9\n\t  _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t  _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t  _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t  ;;\n        *Intel*\\ [[CF]]*Compiler*)\n\t  _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t  _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n\t  _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n\t  ;;\n\t*Portland\\ Group*)\n\t  _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t  _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fpic'\n\t  _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t  ;;\n\tesac\n\t;;\n      esac\n      ;;\n\n    newsos6)\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      ;;\n\n    *nto* | *qnx*)\n      # QNX uses GNU C++, but need to define -shared option too, otherwise\n      # it will coredump.\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC -shared'\n      ;;\n\n    osf3* | osf4* | osf5*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      # All OSF/1 code is PIC.\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n      ;;\n\n    rdos*)\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n      ;;\n\n    solaris*)\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      case $cc_basename in\n      f77* | f90* | f95* | sunf77* | sunf90* | sunf95*)\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld ';;\n      *)\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,';;\n      esac\n      ;;\n\n    sunos4*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld '\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-PIC'\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      ;;\n\n    sysv4 | sysv4.2uw2* | sysv4.3*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      ;;\n\n    sysv4*MP*)\n      if test -d /usr/nec ;then\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-Kconform_pic'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      fi\n      ;;\n\n    sysv5* | unixware* | sco3.2v5* | sco5v6* | OpenUNIX*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      ;;\n\n    unicos*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      _LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no\n      ;;\n\n    uts4*)\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      ;;\n\n    *)\n      _LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no\n      ;;\n    esac\n  fi\n])\ncase $host_os in\n  # For platforms which do not support PIC, -DPIC is meaningless:\n  *djgpp*)\n    _LT_TAGVAR(lt_prog_compiler_pic, $1)=\n    ;;\n  *)\n    _LT_TAGVAR(lt_prog_compiler_pic, $1)=\"$_LT_TAGVAR(lt_prog_compiler_pic, $1)@&t@m4_if([$1],[],[ -DPIC],[m4_if([$1],[CXX],[ -DPIC],[])])\"\n    ;;\nesac\n\nAC_CACHE_CHECK([for $compiler option to produce PIC],\n  [_LT_TAGVAR(lt_cv_prog_compiler_pic, $1)],\n  [_LT_TAGVAR(lt_cv_prog_compiler_pic, $1)=$_LT_TAGVAR(lt_prog_compiler_pic, $1)])\n_LT_TAGVAR(lt_prog_compiler_pic, $1)=$_LT_TAGVAR(lt_cv_prog_compiler_pic, $1)\n\n#\n# Check to make sure the PIC flag actually works.\n#\nif test -n \"$_LT_TAGVAR(lt_prog_compiler_pic, $1)\"; then\n  _LT_COMPILER_OPTION([if $compiler PIC flag $_LT_TAGVAR(lt_prog_compiler_pic, $1) works],\n    [_LT_TAGVAR(lt_cv_prog_compiler_pic_works, $1)],\n    [$_LT_TAGVAR(lt_prog_compiler_pic, $1)@&t@m4_if([$1],[],[ -DPIC],[m4_if([$1],[CXX],[ -DPIC],[])])], [],\n    [case $_LT_TAGVAR(lt_prog_compiler_pic, $1) in\n     \"\" | \" \"*) ;;\n     *) _LT_TAGVAR(lt_prog_compiler_pic, $1)=\" $_LT_TAGVAR(lt_prog_compiler_pic, $1)\" ;;\n     esac],\n    [_LT_TAGVAR(lt_prog_compiler_pic, $1)=\n     _LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no])\nfi\n_LT_TAGDECL([pic_flag], [lt_prog_compiler_pic], [1],\n\t[Additional compiler flags for building library objects])\n\n_LT_TAGDECL([wl], [lt_prog_compiler_wl], [1],\n\t[How to pass a linker flag through the compiler])\n#\n# Check to make sure the static flag actually works.\n#\nwl=$_LT_TAGVAR(lt_prog_compiler_wl, $1) eval lt_tmp_static_flag=\\\"$_LT_TAGVAR(lt_prog_compiler_static, $1)\\\"\n_LT_LINKER_OPTION([if $compiler static flag $lt_tmp_static_flag works],\n  _LT_TAGVAR(lt_cv_prog_compiler_static_works, $1),\n  $lt_tmp_static_flag,\n  [],\n  [_LT_TAGVAR(lt_prog_compiler_static, $1)=])\n_LT_TAGDECL([link_static_flag], [lt_prog_compiler_static], [1],\n\t[Compiler flag to prevent dynamic linking])\n])# _LT_COMPILER_PIC\n\n\n# _LT_LINKER_SHLIBS([TAGNAME])\n# ----------------------------\n# See if the linker supports building shared libraries.\nm4_defun([_LT_LINKER_SHLIBS],\n[AC_REQUIRE([LT_PATH_LD])dnl\nAC_REQUIRE([LT_PATH_NM])dnl\nm4_require([_LT_PATH_MANIFEST_TOOL])dnl\nm4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_DECL_EGREP])dnl\nm4_require([_LT_DECL_SED])dnl\nm4_require([_LT_CMD_GLOBAL_SYMBOLS])dnl\nm4_require([_LT_TAG_COMPILER])dnl\nAC_MSG_CHECKING([whether the $compiler linker ($LD) supports shared libraries])\nm4_if([$1], [CXX], [\n  _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\\''s/.* //'\\'' | sort | uniq > $export_symbols'\n  _LT_TAGVAR(exclude_expsyms, $1)=['_GLOBAL_OFFSET_TABLE_|_GLOBAL__F[ID]_.*']\n  case $host_os in\n  aix[[4-9]]*)\n    # If we're using GNU nm, then we don't want the \"-C\" option.\n    # -C means demangle to AIX nm, but means don't demangle with GNU nm\n    # Also, AIX nm treats weak defined symbols like other global defined\n    # symbols, whereas GNU nm marks them as \"W\".\n    if $NM -V 2>&1 | $GREP 'GNU' > /dev/null; then\n      _LT_TAGVAR(export_symbols_cmds, $1)='$NM -Bpg $libobjs $convenience | awk '\\''{ if (((\\$ 2 == \"T\") || (\\$ 2 == \"D\") || (\\$ 2 == \"B\") || (\\$ 2 == \"W\")) && ([substr](\\$ 3,1,1) != \".\")) { print \\$ 3 } }'\\'' | sort -u > $export_symbols'\n    else\n      _LT_TAGVAR(export_symbols_cmds, $1)='$NM -BCpg $libobjs $convenience | awk '\\''{ if (((\\$ 2 == \"T\") || (\\$ 2 == \"D\") || (\\$ 2 == \"B\")) && ([substr](\\$ 3,1,1) != \".\")) { print \\$ 3 } }'\\'' | sort -u > $export_symbols'\n    fi\n    ;;\n  pw32*)\n    _LT_TAGVAR(export_symbols_cmds, $1)=\"$ltdll_cmds\"\n    ;;\n  cygwin* | mingw* | cegcc*)\n    case $cc_basename in\n    cl*)\n      _LT_TAGVAR(exclude_expsyms, $1)='_NULL_IMPORT_DESCRIPTOR|_IMPORT_DESCRIPTOR_.*'\n      ;;\n    *)\n      _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED -e '\\''/^[[BCDGRS]][[ ]]/s/.*[[ ]]\\([[^ ]]*\\)/\\1 DATA/;s/^.*[[ ]]__nm__\\([[^ ]]*\\)[[ ]][[^ ]]*/\\1 DATA/;/^I[[ ]]/d;/^[[AITW]][[ ]]/s/.* //'\\'' | sort | uniq > $export_symbols'\n      _LT_TAGVAR(exclude_expsyms, $1)=['[_]+GLOBAL_OFFSET_TABLE_|[_]+GLOBAL__[FID]_.*|[_]+head_[A-Za-z0-9_]+_dll|[A-Za-z0-9_]+_dll_iname']\n      ;;\n    esac\n    ;;\n  linux* | k*bsd*-gnu | gnu*)\n    _LT_TAGVAR(link_all_deplibs, $1)=no\n    ;;\n  *)\n    _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\\''s/.* //'\\'' | sort | uniq > $export_symbols'\n    ;;\n  esac\n], [\n  runpath_var=\n  _LT_TAGVAR(allow_undefined_flag, $1)=\n  _LT_TAGVAR(always_export_symbols, $1)=no\n  _LT_TAGVAR(archive_cmds, $1)=\n  _LT_TAGVAR(archive_expsym_cmds, $1)=\n  _LT_TAGVAR(compiler_needs_object, $1)=no\n  _LT_TAGVAR(enable_shared_with_static_runtimes, $1)=no\n  _LT_TAGVAR(export_dynamic_flag_spec, $1)=\n  _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\\''s/.* //'\\'' | sort | uniq > $export_symbols'\n  _LT_TAGVAR(hardcode_automatic, $1)=no\n  _LT_TAGVAR(hardcode_direct, $1)=no\n  _LT_TAGVAR(hardcode_direct_absolute, $1)=no\n  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)=\n  _LT_TAGVAR(hardcode_libdir_separator, $1)=\n  _LT_TAGVAR(hardcode_minus_L, $1)=no\n  _LT_TAGVAR(hardcode_shlibpath_var, $1)=unsupported\n  _LT_TAGVAR(inherit_rpath, $1)=no\n  _LT_TAGVAR(link_all_deplibs, $1)=unknown\n  _LT_TAGVAR(module_cmds, $1)=\n  _LT_TAGVAR(module_expsym_cmds, $1)=\n  _LT_TAGVAR(old_archive_from_new_cmds, $1)=\n  _LT_TAGVAR(old_archive_from_expsyms_cmds, $1)=\n  _LT_TAGVAR(thread_safe_flag_spec, $1)=\n  _LT_TAGVAR(whole_archive_flag_spec, $1)=\n  # include_expsyms should be a list of space-separated symbols to be *always*\n  # included in the symbol list\n  _LT_TAGVAR(include_expsyms, $1)=\n  # exclude_expsyms can be an extended regexp of symbols to exclude\n  # it will be wrapped by ` (' and `)$', so one must not match beginning or\n  # end of line.  Example: `a|bc|.*d.*' will exclude the symbols `a' and `bc',\n  # as well as any symbol that contains `d'.\n  _LT_TAGVAR(exclude_expsyms, $1)=['_GLOBAL_OFFSET_TABLE_|_GLOBAL__F[ID]_.*']\n  # Although _GLOBAL_OFFSET_TABLE_ is a valid symbol C name, most a.out\n  # platforms (ab)use it in PIC code, but their linkers get confused if\n  # the symbol is explicitly referenced.  Since portable code cannot\n  # rely on this symbol name, it's probably fine to never include it in\n  # preloaded symbol tables.\n  # Exclude shared library initialization/finalization symbols.\ndnl Note also adjust exclude_expsyms for C++ above.\n  extract_expsyms_cmds=\n\n  case $host_os in\n  cygwin* | mingw* | pw32* | cegcc*)\n    # FIXME: the MSVC++ port hasn't been tested in a loooong time\n    # When not using gcc, we currently assume that we are using\n    # Microsoft Visual C++.\n    if test \"$GCC\" != yes; then\n      with_gnu_ld=no\n    fi\n    ;;\n  interix*)\n    # we just hope/assume this is gcc and not c89 (= MSVC++)\n    with_gnu_ld=yes\n    ;;\n  openbsd*)\n    with_gnu_ld=no\n    ;;\n  linux* | k*bsd*-gnu | gnu*)\n    _LT_TAGVAR(link_all_deplibs, $1)=no\n    ;;\n  esac\n\n  _LT_TAGVAR(ld_shlibs, $1)=yes\n\n  # On some targets, GNU ld is compatible enough with the native linker\n  # that we're better off using the native interface for both.\n  lt_use_gnu_ld_interface=no\n  if test \"$with_gnu_ld\" = yes; then\n    case $host_os in\n      aix*)\n\t# The AIX port of GNU ld has always aspired to compatibility\n\t# with the native linker.  However, as the warning in the GNU ld\n\t# block says, versions before 2.19.5* couldn't really create working\n\t# shared libraries, regardless of the interface used.\n\tcase `$LD -v 2>&1` in\n\t  *\\ \\(GNU\\ Binutils\\)\\ 2.19.5*) ;;\n\t  *\\ \\(GNU\\ Binutils\\)\\ 2.[[2-9]]*) ;;\n\t  *\\ \\(GNU\\ Binutils\\)\\ [[3-9]]*) ;;\n\t  *)\n\t    lt_use_gnu_ld_interface=yes\n\t    ;;\n\tesac\n\t;;\n      *)\n\tlt_use_gnu_ld_interface=yes\n\t;;\n    esac\n  fi\n\n  if test \"$lt_use_gnu_ld_interface\" = yes; then\n    # If archive_cmds runs LD, not CC, wlarc should be empty\n    wlarc='${wl}'\n\n    # Set some defaults for GNU ld with shared library support. These\n    # are reset later if shared libraries are not supported. Putting them\n    # here allows them to be overridden if necessary.\n    runpath_var=LD_RUN_PATH\n    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'\n    # ancient GNU ld didn't support --whole-archive et. al.\n    if $LD --help 2>&1 | $GREP 'no-whole-archive' > /dev/null; then\n      _LT_TAGVAR(whole_archive_flag_spec, $1)=\"$wlarc\"'--whole-archive$convenience '\"$wlarc\"'--no-whole-archive'\n    else\n      _LT_TAGVAR(whole_archive_flag_spec, $1)=\n    fi\n    supports_anon_versioning=no\n    case `$LD -v 2>&1` in\n      *GNU\\ gold*) supports_anon_versioning=yes ;;\n      *\\ [[01]].* | *\\ 2.[[0-9]].* | *\\ 2.10.*) ;; # catch versions < 2.11\n      *\\ 2.11.93.0.2\\ *) supports_anon_versioning=yes ;; # RH7.3 ...\n      *\\ 2.11.92.0.12\\ *) supports_anon_versioning=yes ;; # Mandrake 8.2 ...\n      *\\ 2.11.*) ;; # other 2.11 versions\n      *) supports_anon_versioning=yes ;;\n    esac\n\n    # See if GNU ld supports shared libraries.\n    case $host_os in\n    aix[[3-9]]*)\n      # On AIX/PPC, the GNU linker is very broken\n      if test \"$host_cpu\" != ia64; then\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n\tcat <<_LT_EOF 1>&2\n\n*** Warning: the GNU linker, at least up to release 2.19, is reported\n*** to be unable to reliably create shared libraries on AIX.\n*** Therefore, libtool is disabling shared libraries support.  If you\n*** really care for shared libraries, you may want to install binutils\n*** 2.20 or above, or modify your PATH so that a non-GNU linker is found.\n*** You will then need to restart the configuration process.\n\n_LT_EOF\n      fi\n      ;;\n\n    amigaos*)\n      case $host_cpu in\n      powerpc)\n            # see comment about AmigaOS4 .so support\n            _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n            _LT_TAGVAR(archive_expsym_cmds, $1)=''\n        ;;\n      m68k)\n            _LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/a2ixlibrary.data~$ECHO \"#define NAME $libname\" > $output_objdir/a2ixlibrary.data~$ECHO \"#define LIBRARY_ID 1\" >> $output_objdir/a2ixlibrary.data~$ECHO \"#define VERSION $major\" >> $output_objdir/a2ixlibrary.data~$ECHO \"#define REVISION $revision\" >> $output_objdir/a2ixlibrary.data~$AR $AR_FLAGS $lib $libobjs~$RANLIB $lib~(cd $output_objdir && a2ixlibrary -32)'\n            _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n            _LT_TAGVAR(hardcode_minus_L, $1)=yes\n        ;;\n      esac\n      ;;\n\n    beos*)\n      if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then\n\t_LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n\t# Joseph Beckenbach <jrb3@best.com> says some releases of gcc\n\t# support --undefined.  This deserves some investigation.  FIXME\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -nostart $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n      else\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n      fi\n      ;;\n\n    cygwin* | mingw* | pw32* | cegcc*)\n      # _LT_TAGVAR(hardcode_libdir_flag_spec, $1) is actually meaningless,\n      # as there is no search path for DLLs.\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-all-symbols'\n      _LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n      _LT_TAGVAR(always_export_symbols, $1)=no\n      _LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes\n      _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED -e '\\''/^[[BCDGRS]][[ ]]/s/.*[[ ]]\\([[^ ]]*\\)/\\1 DATA/;s/^.*[[ ]]__nm__\\([[^ ]]*\\)[[ ]][[^ ]]*/\\1 DATA/;/^I[[ ]]/d;/^[[AITW]][[ ]]/s/.* //'\\'' | sort | uniq > $export_symbols'\n      _LT_TAGVAR(exclude_expsyms, $1)=['[_]+GLOBAL_OFFSET_TABLE_|[_]+GLOBAL__[FID]_.*|[_]+head_[A-Za-z0-9_]+_dll|[A-Za-z0-9_]+_dll_iname']\n\n      if $LD --help 2>&1 | $GREP 'auto-import' > /dev/null; then\n        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'\n\t# If the export-symbols file already is a .def file (1st line\n\t# is EXPORTS), use it as is; otherwise, prepend...\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='if test \"x`$SED 1q $export_symbols`\" = xEXPORTS; then\n\t  cp $export_symbols $output_objdir/$soname.def;\n\telse\n\t  echo EXPORTS > $output_objdir/$soname.def;\n\t  cat $export_symbols >> $output_objdir/$soname.def;\n\tfi~\n\t$CC -shared $output_objdir/$soname.def $libobjs $deplibs $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'\n      else\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n      fi\n      ;;\n\n    haiku*)\n      _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n      _LT_TAGVAR(link_all_deplibs, $1)=yes\n      ;;\n\n    interix[[3-9]]*)\n      _LT_TAGVAR(hardcode_direct, $1)=no\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n      # Hack: On Interix 3.x, we cannot compile PIC because of a broken gcc.\n      # Instead, shared libraries are loaded at an image base (0x10000000 by\n      # default) and relocated if they conflict, which is a slow very memory\n      # consuming and fragmenting process.  To avoid this, we pick a random,\n      # 256 KiB-aligned image base between 0x50000000 and 0x6FFC0000 at link\n      # time.  Moving up from 0x10000000 also allows more sbrk(2) space.\n      _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \\* 262144 + 1342177280` -o $lib'\n      _LT_TAGVAR(archive_expsym_cmds, $1)='sed \"s,^,_,\" $export_symbols >$output_objdir/$soname.expsym~$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--retain-symbols-file,$output_objdir/$soname.expsym ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \\* 262144 + 1342177280` -o $lib'\n      ;;\n\n    gnu* | linux* | tpf* | k*bsd*-gnu | kopensolaris*-gnu)\n      tmp_diet=no\n      if test \"$host_os\" = linux-dietlibc; then\n\tcase $cc_basename in\n\t  diet\\ *) tmp_diet=yes;;\t# linux-dietlibc with static linking (!diet-dyn)\n\tesac\n      fi\n      if $LD --help 2>&1 | $EGREP ': supported targets:.* elf' > /dev/null \\\n\t && test \"$tmp_diet\" = no\n      then\n\ttmp_addflag=' $pic_flag'\n\ttmp_sharedflag='-shared'\n\tcase $cc_basename,$host_cpu in\n        pgcc*)\t\t\t\t# Portland Group C compiler\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`for conv in $convenience\\\"\\\"; do test  -n \\\"$conv\\\" && new_convenience=\\\"$new_convenience,$conv\\\"; done; func_echo_all \\\"$new_convenience\\\"` ${wl}--no-whole-archive'\n\t  tmp_addflag=' $pic_flag'\n\t  ;;\n\tpgf77* | pgf90* | pgf95* | pgfortran*)\n\t\t\t\t\t# Portland Group f77 and f90 compilers\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`for conv in $convenience\\\"\\\"; do test  -n \\\"$conv\\\" && new_convenience=\\\"$new_convenience,$conv\\\"; done; func_echo_all \\\"$new_convenience\\\"` ${wl}--no-whole-archive'\n\t  tmp_addflag=' $pic_flag -Mnomain' ;;\n\tecc*,ia64* | icc*,ia64*)\t# Intel C compiler on ia64\n\t  tmp_addflag=' -i_dynamic' ;;\n\tefc*,ia64* | ifort*,ia64*)\t# Intel Fortran compiler on ia64\n\t  tmp_addflag=' -i_dynamic -nofor_main' ;;\n\tifc* | ifort*)\t\t\t# Intel Fortran compiler\n\t  tmp_addflag=' -nofor_main' ;;\n\tlf95*)\t\t\t\t# Lahey Fortran 8.1\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)=\n\t  tmp_sharedflag='--shared' ;;\n\txl[[cC]]* | bgxl[[cC]]* | mpixl[[cC]]*) # IBM XL C 8.0 on PPC (deal with xlf below)\n\t  tmp_sharedflag='-qmkshrobj'\n\t  tmp_addflag= ;;\n\tnvcc*)\t# Cuda Compiler Driver 2.2\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`for conv in $convenience\\\"\\\"; do test  -n \\\"$conv\\\" && new_convenience=\\\"$new_convenience,$conv\\\"; done; func_echo_all \\\"$new_convenience\\\"` ${wl}--no-whole-archive'\n\t  _LT_TAGVAR(compiler_needs_object, $1)=yes\n\t  ;;\n\tesac\n\tcase `$CC -V 2>&1 | sed 5q` in\n\t*Sun\\ C*)\t\t\t# Sun C 5.9\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`new_convenience=; for conv in $convenience\\\"\\\"; do test -z \\\"$conv\\\" || new_convenience=\\\"$new_convenience,$conv\\\"; done; func_echo_all \\\"$new_convenience\\\"` ${wl}--no-whole-archive'\n\t  _LT_TAGVAR(compiler_needs_object, $1)=yes\n\t  tmp_sharedflag='-G' ;;\n\t*Sun\\ F*)\t\t\t# Sun Fortran 8.3\n\t  tmp_sharedflag='-G' ;;\n\tesac\n\t_LT_TAGVAR(archive_cmds, $1)='$CC '\"$tmp_sharedflag\"\"$tmp_addflag\"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\n        if test \"x$supports_anon_versioning\" = xyes; then\n          _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $output_objdir/$libname.ver~\n\t    cat $export_symbols | sed -e \"s/\\(.*\\)/\\1;/\" >> $output_objdir/$libname.ver~\n\t    echo \"local: *; };\" >> $output_objdir/$libname.ver~\n\t    $CC '\"$tmp_sharedflag\"\"$tmp_addflag\"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-version-script ${wl}$output_objdir/$libname.ver -o $lib'\n        fi\n\n\tcase $cc_basename in\n\txlf* | bgf* | bgxlf* | mpixlf*)\n\t  # IBM XL Fortran 10.1 on PPC cannot create shared libs itself\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='--whole-archive$convenience --no-whole-archive'\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n\t  _LT_TAGVAR(archive_cmds, $1)='$LD -shared $libobjs $deplibs $linker_flags -soname $soname -o $lib'\n\t  if test \"x$supports_anon_versioning\" = xyes; then\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $output_objdir/$libname.ver~\n\t      cat $export_symbols | sed -e \"s/\\(.*\\)/\\1;/\" >> $output_objdir/$libname.ver~\n\t      echo \"local: *; };\" >> $output_objdir/$libname.ver~\n\t      $LD -shared $libobjs $deplibs $linker_flags -soname $soname -version-script $output_objdir/$libname.ver -o $lib'\n\t  fi\n\t  ;;\n\tesac\n      else\n        _LT_TAGVAR(ld_shlibs, $1)=no\n      fi\n      ;;\n\n    netbsd* | netbsdelf*-gnu)\n      if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then\n\t_LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable $libobjs $deplibs $linker_flags -o $lib'\n\twlarc=\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'\n      fi\n      ;;\n\n    solaris*)\n      if $LD -v 2>&1 | $GREP 'BFD 2\\.8' > /dev/null; then\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n\tcat <<_LT_EOF 1>&2\n\n*** Warning: The releases 2.8.* of the GNU linker cannot reliably\n*** create shared libraries on Solaris systems.  Therefore, libtool\n*** is disabling shared libraries support.  We urge you to upgrade GNU\n*** binutils to release 2.9.1 or newer.  Another option is to modify\n*** your PATH or compiler configuration so that the native linker is\n*** used, and then restart.\n\n_LT_EOF\n      elif $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'\n      else\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n      fi\n      ;;\n\n    sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX*)\n      case `$LD -v 2>&1` in\n        *\\ [[01]].* | *\\ 2.[[0-9]].* | *\\ 2.1[[0-5]].*)\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n\tcat <<_LT_EOF 1>&2\n\n*** Warning: Releases of the GNU linker prior to 2.16.91.0.3 can not\n*** reliably create shared libraries on SCO systems.  Therefore, libtool\n*** is disabling shared libraries support.  We urge you to upgrade GNU\n*** binutils to release 2.16.91.0.3 or newer.  Another option is to modify\n*** your PATH or compiler configuration so that the native linker is\n*** used, and then restart.\n\n_LT_EOF\n\t;;\n\t*)\n\t  # For security reasons, it is highly recommended that you always\n\t  # use absolute paths for naming shared libraries, and exclude the\n\t  # DT_RUNPATH tag from executables and libraries.  But doing so\n\t  # requires that you compile everything twice, which is a pain.\n\t  if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'\n\t  else\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t  fi\n\t;;\n      esac\n      ;;\n\n    sunos4*)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -assert pure-text -Bshareable -o $lib $libobjs $deplibs $linker_flags'\n      wlarc=\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    *)\n      if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'\n      else\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n      fi\n      ;;\n    esac\n\n    if test \"$_LT_TAGVAR(ld_shlibs, $1)\" = no; then\n      runpath_var=\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)=\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)=\n      _LT_TAGVAR(whole_archive_flag_spec, $1)=\n    fi\n  else\n    # PORTME fill in a description of your system's linker (not GNU ld)\n    case $host_os in\n    aix3*)\n      _LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n      _LT_TAGVAR(always_export_symbols, $1)=yes\n      _LT_TAGVAR(archive_expsym_cmds, $1)='$LD -o $output_objdir/$soname $libobjs $deplibs $linker_flags -bE:$export_symbols -T512 -H512 -bM:SRE~$AR $AR_FLAGS $lib $output_objdir/$soname'\n      # Note: this linker hardcodes the directories in LIBPATH if there\n      # are no directories specified by -L.\n      _LT_TAGVAR(hardcode_minus_L, $1)=yes\n      if test \"$GCC\" = yes && test -z \"$lt_prog_compiler_static\"; then\n\t# Neither direct hardcoding nor static linking is supported with a\n\t# broken collect2.\n\t_LT_TAGVAR(hardcode_direct, $1)=unsupported\n      fi\n      ;;\n\n    aix[[4-9]]*)\n      if test \"$host_cpu\" = ia64; then\n\t# On IA64, the linker does run time linking by default, so we don't\n\t# have to do anything special.\n\taix_use_runtimelinking=no\n\texp_sym_flag='-Bexport'\n\tno_entry_flag=\"\"\n      else\n\t# If we're using GNU nm, then we don't want the \"-C\" option.\n\t# -C means demangle to AIX nm, but means don't demangle with GNU nm\n\t# Also, AIX nm treats weak defined symbols like other global\n\t# defined symbols, whereas GNU nm marks them as \"W\".\n\tif $NM -V 2>&1 | $GREP 'GNU' > /dev/null; then\n\t  _LT_TAGVAR(export_symbols_cmds, $1)='$NM -Bpg $libobjs $convenience | awk '\\''{ if (((\\$ 2 == \"T\") || (\\$ 2 == \"D\") || (\\$ 2 == \"B\") || (\\$ 2 == \"W\")) && ([substr](\\$ 3,1,1) != \".\")) { print \\$ 3 } }'\\'' | sort -u > $export_symbols'\n\telse\n\t  _LT_TAGVAR(export_symbols_cmds, $1)='$NM -BCpg $libobjs $convenience | awk '\\''{ if (((\\$ 2 == \"T\") || (\\$ 2 == \"D\") || (\\$ 2 == \"B\")) && ([substr](\\$ 3,1,1) != \".\")) { print \\$ 3 } }'\\'' | sort -u > $export_symbols'\n\tfi\n\taix_use_runtimelinking=no\n\n\t# Test if we are trying to use run time linking or normal\n\t# AIX style linking. If -brtl is somewhere in LDFLAGS, we\n\t# need to do runtime linking.\n\tcase $host_os in aix4.[[23]]|aix4.[[23]].*|aix[[5-9]]*)\n\t  for ld_flag in $LDFLAGS; do\n\t  if (test $ld_flag = \"-brtl\" || test $ld_flag = \"-Wl,-brtl\"); then\n\t    aix_use_runtimelinking=yes\n\t    break\n\t  fi\n\t  done\n\t  ;;\n\tesac\n\n\texp_sym_flag='-bexport'\n\tno_entry_flag='-bnoentry'\n      fi\n\n      # When large executables or shared objects are built, AIX ld can\n      # have problems creating the table of contents.  If linking a library\n      # or program results in \"error TOC overflow\" add -mminimal-toc to\n      # CXXFLAGS/CFLAGS for g++/gcc.  In the cases where that is not\n      # enough to fix the problem, add -Wl,-bbigtoc to LDFLAGS.\n\n      _LT_TAGVAR(archive_cmds, $1)=''\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=':'\n      _LT_TAGVAR(link_all_deplibs, $1)=yes\n      _LT_TAGVAR(file_list_spec, $1)='${wl}-f,'\n\n      if test \"$GCC\" = yes; then\n\tcase $host_os in aix4.[[012]]|aix4.[[012]].*)\n\t# We only want to do this on AIX 4.2 and lower, the check\n\t# below for broken collect2 doesn't work under 4.3+\n\t  collect2name=`${CC} -print-prog-name=collect2`\n\t  if test -f \"$collect2name\" &&\n\t   strings \"$collect2name\" | $GREP resolve_lib_name >/dev/null\n\t  then\n\t  # We have reworked collect2\n\t  :\n\t  else\n\t  # We have old collect2\n\t  _LT_TAGVAR(hardcode_direct, $1)=unsupported\n\t  # It fails to find uninstalled libraries when the uninstalled\n\t  # path is not listed in the libpath.  Setting hardcode_minus_L\n\t  # to unsupported forces relinking\n\t  _LT_TAGVAR(hardcode_minus_L, $1)=yes\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n\t  _LT_TAGVAR(hardcode_libdir_separator, $1)=\n\t  fi\n\t  ;;\n\tesac\n\tshared_flag='-shared'\n\tif test \"$aix_use_runtimelinking\" = yes; then\n\t  shared_flag=\"$shared_flag \"'${wl}-G'\n\tfi\n\t_LT_TAGVAR(link_all_deplibs, $1)=no\n      else\n\t# not using gcc\n\tif test \"$host_cpu\" = ia64; then\n\t# VisualAge C++, Version 5.5 for AIX 5L for IA-64, Beta 3 Release\n\t# chokes on -Wl,-G. The following line is correct:\n\t  shared_flag='-G'\n\telse\n\t  if test \"$aix_use_runtimelinking\" = yes; then\n\t    shared_flag='${wl}-G'\n\t  else\n\t    shared_flag='${wl}-bM:SRE'\n\t  fi\n\tfi\n      fi\n\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-bexpall'\n      # It seems that -bexpall does not export symbols beginning with\n      # underscore (_), so it is better to generate a list of symbols to export.\n      _LT_TAGVAR(always_export_symbols, $1)=yes\n      if test \"$aix_use_runtimelinking\" = yes; then\n\t# Warning - without using the other runtime loading flags (-brtl),\n\t# -berok will link without error, but may produce a broken library.\n\t_LT_TAGVAR(allow_undefined_flag, $1)='-berok'\n        # Determine the default libpath from the value encoded in an\n        # empty executable.\n        _LT_SYS_MODULE_PATH_AIX([$1])\n        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-blibpath:$libdir:'\"$aix_libpath\"\n        _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -o $output_objdir/$soname $libobjs $deplibs '\"\\${wl}$no_entry_flag\"' $compiler_flags `if test \"x${allow_undefined_flag}\" != \"x\"; then func_echo_all \"${wl}${allow_undefined_flag}\"; else :; fi` '\"\\${wl}$exp_sym_flag:\\$export_symbols $shared_flag\"\n      else\n\tif test \"$host_cpu\" = ia64; then\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-R $libdir:/usr/lib:/lib'\n\t  _LT_TAGVAR(allow_undefined_flag, $1)=\"-z nodefs\"\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)=\"\\$CC $shared_flag\"' -o $output_objdir/$soname $libobjs $deplibs '\"\\${wl}$no_entry_flag\"' $compiler_flags ${wl}${allow_undefined_flag} '\"\\${wl}$exp_sym_flag:\\$export_symbols\"\n\telse\n\t # Determine the default libpath from the value encoded in an\n\t # empty executable.\n\t _LT_SYS_MODULE_PATH_AIX([$1])\n\t _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-blibpath:$libdir:'\"$aix_libpath\"\n\t  # Warning - without using the other run time loading flags,\n\t  # -berok will link without error, but may produce a broken library.\n\t  _LT_TAGVAR(no_undefined_flag, $1)=' ${wl}-bernotok'\n\t  _LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-berok'\n\t  if test \"$with_gnu_ld\" = yes; then\n\t    # We only use this code for GNU lds that support --whole-archive.\n\t    _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive$convenience ${wl}--no-whole-archive'\n\t  else\n\t    # Exported symbols can be pulled into shared objects from archives\n\t    _LT_TAGVAR(whole_archive_flag_spec, $1)='$convenience'\n\t  fi\n\t  _LT_TAGVAR(archive_cmds_need_lc, $1)=yes\n\t  # This is similar to how AIX traditionally builds its shared libraries.\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)=\"\\$CC $shared_flag\"' -o $output_objdir/$soname $libobjs $deplibs ${wl}-bnoentry $compiler_flags ${wl}-bE:$export_symbols${allow_undefined_flag}~$AR $AR_FLAGS $output_objdir/$libname$release.a $output_objdir/$soname'\n\tfi\n      fi\n      ;;\n\n    amigaos*)\n      case $host_cpu in\n      powerpc)\n            # see comment about AmigaOS4 .so support\n            _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n            _LT_TAGVAR(archive_expsym_cmds, $1)=''\n        ;;\n      m68k)\n            _LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/a2ixlibrary.data~$ECHO \"#define NAME $libname\" > $output_objdir/a2ixlibrary.data~$ECHO \"#define LIBRARY_ID 1\" >> $output_objdir/a2ixlibrary.data~$ECHO \"#define VERSION $major\" >> $output_objdir/a2ixlibrary.data~$ECHO \"#define REVISION $revision\" >> $output_objdir/a2ixlibrary.data~$AR $AR_FLAGS $lib $libobjs~$RANLIB $lib~(cd $output_objdir && a2ixlibrary -32)'\n            _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n            _LT_TAGVAR(hardcode_minus_L, $1)=yes\n        ;;\n      esac\n      ;;\n\n    bsdi[[45]]*)\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)=-rdynamic\n      ;;\n\n    cygwin* | mingw* | pw32* | cegcc*)\n      # When not using gcc, we currently assume that we are using\n      # Microsoft Visual C++.\n      # hardcode_libdir_flag_spec is actually meaningless, as there is\n      # no search path for DLLs.\n      case $cc_basename in\n      cl*)\n\t# Native MSVC\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)=' '\n\t_LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n\t_LT_TAGVAR(always_export_symbols, $1)=yes\n\t_LT_TAGVAR(file_list_spec, $1)='@'\n\t# Tell ltmain to make .lib files, not .a files.\n\tlibext=lib\n\t# Tell ltmain to make .dll files, not .so files.\n\tshrext_cmds=\".dll\"\n\t# FIXME: Setting linknames here is a bad hack.\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -o $output_objdir/$soname $libobjs $compiler_flags $deplibs -Wl,-dll~linknames='\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='if test \"x`$SED 1q $export_symbols`\" = xEXPORTS; then\n\t    sed -n -e 's/\\\\\\\\\\\\\\(.*\\\\\\\\\\\\\\)/-link\\\\\\ -EXPORT:\\\\\\\\\\\\\\1/' -e '1\\\\\\!p' < $export_symbols > $output_objdir/$soname.exp;\n\t  else\n\t    sed -e 's/\\\\\\\\\\\\\\(.*\\\\\\\\\\\\\\)/-link\\\\\\ -EXPORT:\\\\\\\\\\\\\\1/' < $export_symbols > $output_objdir/$soname.exp;\n\t  fi~\n\t  $CC -o $tool_output_objdir$soname $libobjs $compiler_flags $deplibs \"@$tool_output_objdir$soname.exp\" -Wl,-DLL,-IMPLIB:\"$tool_output_objdir$libname.dll.lib\"~\n\t  linknames='\n\t# The linker will not automatically build a static lib if we build a DLL.\n\t# _LT_TAGVAR(old_archive_from_new_cmds, $1)='true'\n\t_LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes\n\t_LT_TAGVAR(exclude_expsyms, $1)='_NULL_IMPORT_DESCRIPTOR|_IMPORT_DESCRIPTOR_.*'\n\t_LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED -e '\\''/^[[BCDGRS]][[ ]]/s/.*[[ ]]\\([[^ ]]*\\)/\\1,DATA/'\\'' | $SED -e '\\''/^[[AITW]][[ ]]/s/.*[[ ]]//'\\'' | sort | uniq > $export_symbols'\n\t# Don't use ranlib\n\t_LT_TAGVAR(old_postinstall_cmds, $1)='chmod 644 $oldlib'\n\t_LT_TAGVAR(postlink_cmds, $1)='lt_outputfile=\"@OUTPUT@\"~\n\t  lt_tool_outputfile=\"@TOOL_OUTPUT@\"~\n\t  case $lt_outputfile in\n\t    *.exe|*.EXE) ;;\n\t    *)\n\t      lt_outputfile=\"$lt_outputfile.exe\"\n\t      lt_tool_outputfile=\"$lt_tool_outputfile.exe\"\n\t      ;;\n\t  esac~\n\t  if test \"$MANIFEST_TOOL\" != \":\" && test -f \"$lt_outputfile.manifest\"; then\n\t    $MANIFEST_TOOL -manifest \"$lt_tool_outputfile.manifest\" -outputresource:\"$lt_tool_outputfile\" || exit 1;\n\t    $RM \"$lt_outputfile.manifest\";\n\t  fi'\n\t;;\n      *)\n\t# Assume MSVC wrapper\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)=' '\n\t_LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n\t# Tell ltmain to make .lib files, not .a files.\n\tlibext=lib\n\t# Tell ltmain to make .dll files, not .so files.\n\tshrext_cmds=\".dll\"\n\t# FIXME: Setting linknames here is a bad hack.\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -o $lib $libobjs $compiler_flags `func_echo_all \"$deplibs\" | $SED '\\''s/ -lc$//'\\''` -link -dll~linknames='\n\t# The linker will automatically build a .lib file if we build a DLL.\n\t_LT_TAGVAR(old_archive_from_new_cmds, $1)='true'\n\t# FIXME: Should let the user specify the lib program.\n\t_LT_TAGVAR(old_archive_cmds, $1)='lib -OUT:$oldlib$oldobjs$old_deplibs'\n\t_LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes\n\t;;\n      esac\n      ;;\n\n    darwin* | rhapsody*)\n      _LT_DARWIN_LINKER_FEATURES($1)\n      ;;\n\n    dgux*)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    # FreeBSD 2.2.[012] allows us to include c++rt0.o to get C++ constructor\n    # support.  Future versions do this automatically, but an explicit c++rt0.o\n    # does not break anything, and helps significantly (at the cost of a little\n    # extra space).\n    freebsd2.2*)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags /usr/lib/c++rt0.o'\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    # Unfortunately, older versions of FreeBSD 2 do not have this feature.\n    freebsd2.*)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_minus_L, $1)=yes\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    # FreeBSD 3 and greater uses gcc -shared to do shared libraries.\n    freebsd* | dragonfly*)\n      _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    hpux9*)\n      if test \"$GCC\" = yes; then\n\t_LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/$soname~$CC -shared $pic_flag ${wl}+b ${wl}$install_libdir -o $output_objdir/$soname $libobjs $deplibs $compiler_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/$soname~$LD -b +b $install_libdir -o $output_objdir/$soname $libobjs $deplibs $linker_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'\n      fi\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n\n      # hardcode_minus_L: Not really in the search PATH,\n      # but as the default location of the library.\n      _LT_TAGVAR(hardcode_minus_L, $1)=yes\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n      ;;\n\n    hpux10*)\n      if test \"$GCC\" = yes && test \"$with_gnu_ld\" = no; then\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$LD -b +h $soname +b $install_libdir -o $lib $libobjs $deplibs $linker_flags'\n      fi\n      if test \"$with_gnu_ld\" = no; then\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'\n\t_LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\t_LT_TAGVAR(hardcode_direct, $1)=yes\n\t_LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n\t_LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n\t# hardcode_minus_L: Not really in the search PATH,\n\t# but as the default location of the library.\n\t_LT_TAGVAR(hardcode_minus_L, $1)=yes\n      fi\n      ;;\n\n    hpux11*)\n      if test \"$GCC\" = yes && test \"$with_gnu_ld\" = no; then\n\tcase $host_cpu in\n\thppa*64*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}+h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\tia64*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\t*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\tesac\n      else\n\tcase $host_cpu in\n\thppa*64*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\tia64*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\t*)\n\tm4_if($1, [], [\n\t  # Older versions of the 11.00 compiler do not understand -b yet\n\t  # (HP92453-01 A.11.01.20 doesn't, HP92453-01 B.11.X.35175-35176.GP does)\n\t  _LT_LINKER_OPTION([if $CC understands -b],\n\t    _LT_TAGVAR(lt_cv_prog_compiler__b, $1), [-b],\n\t    [_LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'],\n\t    [_LT_TAGVAR(archive_cmds, $1)='$LD -b +h $soname +b $install_libdir -o $lib $libobjs $deplibs $linker_flags'])],\n\t  [_LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'])\n\t  ;;\n\tesac\n      fi\n      if test \"$with_gnu_ld\" = no; then\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'\n\t_LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\n\tcase $host_cpu in\n\thppa*64*|ia64*)\n\t  _LT_TAGVAR(hardcode_direct, $1)=no\n\t  _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\t  ;;\n\t*)\n\t  _LT_TAGVAR(hardcode_direct, $1)=yes\n\t  _LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n\t  _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n\n\t  # hardcode_minus_L: Not really in the search PATH,\n\t  # but as the default location of the library.\n\t  _LT_TAGVAR(hardcode_minus_L, $1)=yes\n\t  ;;\n\tesac\n      fi\n      ;;\n\n    irix5* | irix6* | nonstopux*)\n      if test \"$GCC\" = yes; then\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n \"$verstring\" && func_echo_all \"${wl}-set_version ${wl}$verstring\"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'\n\t# Try to use the -exported_symbol ld option, if it does not\n\t# work, assume that -exports_file does not work either and\n\t# implicitly export all symbols.\n\t# This should be the same for all languages, so no per-tag cache variable.\n\tAC_CACHE_CHECK([whether the $host_os linker accepts -exported_symbol],\n\t  [lt_cv_irix_exported_symbol],\n\t  [save_LDFLAGS=\"$LDFLAGS\"\n\t   LDFLAGS=\"$LDFLAGS -shared ${wl}-exported_symbol ${wl}foo ${wl}-update_registry ${wl}/dev/null\"\n\t   AC_LINK_IFELSE(\n\t     [AC_LANG_SOURCE(\n\t        [AC_LANG_CASE([C], [[int foo (void) { return 0; }]],\n\t\t\t      [C++], [[int foo (void) { return 0; }]],\n\t\t\t      [Fortran 77], [[\n      subroutine foo\n      end]],\n\t\t\t      [Fortran], [[\n      subroutine foo\n      end]])])],\n\t      [lt_cv_irix_exported_symbol=yes],\n\t      [lt_cv_irix_exported_symbol=no])\n           LDFLAGS=\"$save_LDFLAGS\"])\n\tif test \"$lt_cv_irix_exported_symbol\" = yes; then\n          _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n \"$verstring\" && func_echo_all \"${wl}-set_version ${wl}$verstring\"` ${wl}-update_registry ${wl}${output_objdir}/so_locations ${wl}-exports_file ${wl}$export_symbols -o $lib'\n\tfi\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags -soname $soname `test -n \"$verstring\" && func_echo_all \"-set_version $verstring\"` -update_registry ${output_objdir}/so_locations -o $lib'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags -soname $soname `test -n \"$verstring\" && func_echo_all \"-set_version $verstring\"` -update_registry ${output_objdir}/so_locations -exports_file $export_symbols -o $lib'\n      fi\n      _LT_TAGVAR(archive_cmds_need_lc, $1)='no'\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n      _LT_TAGVAR(inherit_rpath, $1)=yes\n      _LT_TAGVAR(link_all_deplibs, $1)=yes\n      ;;\n\n    netbsd* | netbsdelf*-gnu)\n      if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then\n\t_LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'  # a.out\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$LD -shared -o $lib $libobjs $deplibs $linker_flags'      # ELF\n      fi\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    newsos6)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    *nto* | *qnx*)\n      ;;\n\n    openbsd*)\n      if test -f /usr/libexec/ld.so; then\n\t_LT_TAGVAR(hardcode_direct, $1)=yes\n\t_LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\t_LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n\tif test -z \"`echo __ELF__ | $CC -E - | $GREP __ELF__`\" || test \"$host_os-$host_cpu\" = \"openbsd2.8-powerpc\"; then\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags ${wl}-retain-symbols-file,$export_symbols'\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n\t  _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n\telse\n\t  case $host_os in\n\t   openbsd[[01]].* | openbsd2.[[0-7]] | openbsd2.[[0-7]].*)\n\t     _LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'\n\t     _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n\t     ;;\n\t   *)\n\t     _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'\n\t     _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n\t     ;;\n\t  esac\n\tfi\n      else\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n      fi\n      ;;\n\n    os2*)\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n      _LT_TAGVAR(hardcode_minus_L, $1)=yes\n      _LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n      _LT_TAGVAR(archive_cmds, $1)='$ECHO \"LIBRARY $libname INITINSTANCE\" > $output_objdir/$libname.def~$ECHO \"DESCRIPTION \\\"$libname\\\"\" >> $output_objdir/$libname.def~echo DATA >> $output_objdir/$libname.def~echo \" SINGLE NONSHARED\" >> $output_objdir/$libname.def~echo EXPORTS >> $output_objdir/$libname.def~emxexp $libobjs >> $output_objdir/$libname.def~$CC -Zdll -Zcrtdll -o $lib $libobjs $deplibs $compiler_flags $output_objdir/$libname.def'\n      _LT_TAGVAR(old_archive_from_new_cmds, $1)='emximp -o $output_objdir/$libname.a $output_objdir/$libname.def'\n      ;;\n\n    osf3*)\n      if test \"$GCC\" = yes; then\n\t_LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-expect_unresolved ${wl}\\*'\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n \"$verstring\" && func_echo_all \"${wl}-set_version ${wl}$verstring\"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'\n      else\n\t_LT_TAGVAR(allow_undefined_flag, $1)=' -expect_unresolved \\*'\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags -soname $soname `test -n \"$verstring\" && func_echo_all \"-set_version $verstring\"` -update_registry ${output_objdir}/so_locations -o $lib'\n      fi\n      _LT_TAGVAR(archive_cmds_need_lc, $1)='no'\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n      ;;\n\n    osf4* | osf5*)\t# as osf3* with the addition of -msym flag\n      if test \"$GCC\" = yes; then\n\t_LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-expect_unresolved ${wl}\\*'\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $pic_flag $libobjs $deplibs $compiler_flags ${wl}-msym ${wl}-soname ${wl}$soname `test -n \"$verstring\" && func_echo_all \"${wl}-set_version ${wl}$verstring\"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n      else\n\t_LT_TAGVAR(allow_undefined_flag, $1)=' -expect_unresolved \\*'\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags -msym -soname $soname `test -n \"$verstring\" && func_echo_all \"-set_version $verstring\"` -update_registry ${output_objdir}/so_locations -o $lib'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='for i in `cat $export_symbols`; do printf \"%s %s\\\\n\" -exported_symbol \"\\$i\" >> $lib.exp; done; printf \"%s\\\\n\" \"-hidden\">> $lib.exp~\n\t$CC -shared${allow_undefined_flag} ${wl}-input ${wl}$lib.exp $compiler_flags $libobjs $deplibs -soname $soname `test -n \"$verstring\" && $ECHO \"-set_version $verstring\"` -update_registry ${output_objdir}/so_locations -o $lib~$RM $lib.exp'\n\n\t# Both c and cxx compiler support -rpath directly\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-rpath $libdir'\n      fi\n      _LT_TAGVAR(archive_cmds_need_lc, $1)='no'\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n      ;;\n\n    solaris*)\n      _LT_TAGVAR(no_undefined_flag, $1)=' -z defs'\n      if test \"$GCC\" = yes; then\n\twlarc='${wl}'\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag ${wl}-z ${wl}text ${wl}-h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $lib.exp~cat $export_symbols | $SED -e \"s/\\(.*\\)/\\1;/\" >> $lib.exp~echo \"local: *; };\" >> $lib.exp~\n\t  $CC -shared $pic_flag ${wl}-z ${wl}text ${wl}-M ${wl}$lib.exp ${wl}-h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags~$RM $lib.exp'\n      else\n\tcase `$CC -V 2>&1` in\n\t*\"Compilers 5.0\"*)\n\t  wlarc=''\n\t  _LT_TAGVAR(archive_cmds, $1)='$LD -G${allow_undefined_flag} -h $soname -o $lib $libobjs $deplibs $linker_flags'\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $lib.exp~cat $export_symbols | $SED -e \"s/\\(.*\\)/\\1;/\" >> $lib.exp~echo \"local: *; };\" >> $lib.exp~\n\t  $LD -G${allow_undefined_flag} -M $lib.exp -h $soname -o $lib $libobjs $deplibs $linker_flags~$RM $lib.exp'\n\t  ;;\n\t*)\n\t  wlarc='${wl}'\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -G${allow_undefined_flag} -h $soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $lib.exp~cat $export_symbols | $SED -e \"s/\\(.*\\)/\\1;/\" >> $lib.exp~echo \"local: *; };\" >> $lib.exp~\n\t  $CC -G${allow_undefined_flag} -M $lib.exp -h $soname -o $lib $libobjs $deplibs $compiler_flags~$RM $lib.exp'\n\t  ;;\n\tesac\n      fi\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      case $host_os in\n      solaris2.[[0-5]] | solaris2.[[0-5]].*) ;;\n      *)\n\t# The compiler driver will combine and reorder linker options,\n\t# but understands `-z linker_flag'.  GCC discards it without `$wl',\n\t# but is careful enough not to reorder.\n\t# Supported since Solaris 2.6 (maybe 2.5.1?)\n\tif test \"$GCC\" = yes; then\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}-z ${wl}allextract$convenience ${wl}-z ${wl}defaultextract'\n\telse\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='-z allextract$convenience -z defaultextract'\n\tfi\n\t;;\n      esac\n      _LT_TAGVAR(link_all_deplibs, $1)=yes\n      ;;\n\n    sunos4*)\n      if test \"x$host_vendor\" = xsequent; then\n\t# Use $CC to link under sequent, because it throws in some extra .o\n\t# files that make .init and .fini sections work.\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h $soname -o $lib $libobjs $deplibs $compiler_flags'\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$LD -assert pure-text -Bstatic -o $lib $libobjs $deplibs $linker_flags'\n      fi\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_minus_L, $1)=yes\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    sysv4)\n      case $host_vendor in\n\tsni)\n\t  _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n\t  _LT_TAGVAR(hardcode_direct, $1)=yes # is this really true???\n\t;;\n\tsiemens)\n\t  ## LD is ld it makes a PLAMLIB\n\t  ## CC just makes a GrossModule.\n\t  _LT_TAGVAR(archive_cmds, $1)='$LD -G -o $lib $libobjs $deplibs $linker_flags'\n\t  _LT_TAGVAR(reload_cmds, $1)='$CC -r -o $output$reload_objs'\n\t  _LT_TAGVAR(hardcode_direct, $1)=no\n        ;;\n\tmotorola)\n\t  _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n\t  _LT_TAGVAR(hardcode_direct, $1)=no #Motorola manual says yes, but my tests say they lie\n\t;;\n      esac\n      runpath_var='LD_RUN_PATH'\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    sysv4.3*)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)='-Bexport'\n      ;;\n\n    sysv4*MP*)\n      if test -d /usr/nec; then\n\t_LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n\t_LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\trunpath_var=LD_RUN_PATH\n\thardcode_runpath_var=yes\n\t_LT_TAGVAR(ld_shlibs, $1)=yes\n      fi\n      ;;\n\n    sysv4*uw2* | sysv5OpenUNIX* | sysv5UnixWare7.[[01]].[[10]]* | unixware7* | sco3.2v5.0.[[024]]*)\n      _LT_TAGVAR(no_undefined_flag, $1)='${wl}-z,text'\n      _LT_TAGVAR(archive_cmds_need_lc, $1)=no\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      runpath_var='LD_RUN_PATH'\n\n      if test \"$GCC\" = yes; then\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n      fi\n      ;;\n\n    sysv5* | sco3.2v5* | sco5v6*)\n      # Note: We can NOT use -z defs as we might desire, because we do not\n      # link with -lc, and that would cause any symbols used from libc to\n      # always be unresolved, which means just about no library would\n      # ever link correctly.  If we're not using GNU ld we use -z text\n      # though, which does catch some bad symbols but isn't as heavy-handed\n      # as -z defs.\n      _LT_TAGVAR(no_undefined_flag, $1)='${wl}-z,text'\n      _LT_TAGVAR(allow_undefined_flag, $1)='${wl}-z,nodefs'\n      _LT_TAGVAR(archive_cmds_need_lc, $1)=no\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-R,$libdir'\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=':'\n      _LT_TAGVAR(link_all_deplibs, $1)=yes\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-Bexport'\n      runpath_var='LD_RUN_PATH'\n\n      if test \"$GCC\" = yes; then\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n      fi\n      ;;\n\n    uts4*)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    *)\n      _LT_TAGVAR(ld_shlibs, $1)=no\n      ;;\n    esac\n\n    if test x$host_vendor = xsni; then\n      case $host in\n      sysv4 | sysv4.2uw2* | sysv4.3* | sysv5*)\n\t_LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-Blargedynsym'\n\t;;\n      esac\n    fi\n  fi\n])\nAC_MSG_RESULT([$_LT_TAGVAR(ld_shlibs, $1)])\ntest \"$_LT_TAGVAR(ld_shlibs, $1)\" = no && can_build_shared=no\n\n_LT_TAGVAR(with_gnu_ld, $1)=$with_gnu_ld\n\n_LT_DECL([], [libext], [0], [Old archive suffix (normally \"a\")])dnl\n_LT_DECL([], [shrext_cmds], [1], [Shared library suffix (normally \".so\")])dnl\n_LT_DECL([], [extract_expsyms_cmds], [2],\n    [The commands to extract the exported symbol list from a shared archive])\n\n#\n# Do we need to explicitly link libc?\n#\ncase \"x$_LT_TAGVAR(archive_cmds_need_lc, $1)\" in\nx|xyes)\n  # Assume -lc should be added\n  _LT_TAGVAR(archive_cmds_need_lc, $1)=yes\n\n  if test \"$enable_shared\" = yes && test \"$GCC\" = yes; then\n    case $_LT_TAGVAR(archive_cmds, $1) in\n    *'~'*)\n      # FIXME: we may have to deal with multi-command sequences.\n      ;;\n    '$CC '*)\n      # Test whether the compiler implicitly links with -lc since on some\n      # systems, -lgcc has to come before -lc. If gcc already passes -lc\n      # to ld, don't add -lc before -lgcc.\n      AC_CACHE_CHECK([whether -lc should be explicitly linked in],\n\t[lt_cv_]_LT_TAGVAR(archive_cmds_need_lc, $1),\n\t[$RM conftest*\n\techo \"$lt_simple_compile_test_code\" > conftest.$ac_ext\n\n\tif AC_TRY_EVAL(ac_compile) 2>conftest.err; then\n\t  soname=conftest\n\t  lib=conftest\n\t  libobjs=conftest.$ac_objext\n\t  deplibs=\n\t  wl=$_LT_TAGVAR(lt_prog_compiler_wl, $1)\n\t  pic_flag=$_LT_TAGVAR(lt_prog_compiler_pic, $1)\n\t  compiler_flags=-v\n\t  linker_flags=-v\n\t  verstring=\n\t  output_objdir=.\n\t  libname=conftest\n\t  lt_save_allow_undefined_flag=$_LT_TAGVAR(allow_undefined_flag, $1)\n\t  _LT_TAGVAR(allow_undefined_flag, $1)=\n\t  if AC_TRY_EVAL(_LT_TAGVAR(archive_cmds, $1) 2\\>\\&1 \\| $GREP \\\" -lc \\\" \\>/dev/null 2\\>\\&1)\n\t  then\n\t    lt_cv_[]_LT_TAGVAR(archive_cmds_need_lc, $1)=no\n\t  else\n\t    lt_cv_[]_LT_TAGVAR(archive_cmds_need_lc, $1)=yes\n\t  fi\n\t  _LT_TAGVAR(allow_undefined_flag, $1)=$lt_save_allow_undefined_flag\n\telse\n\t  cat conftest.err 1>&5\n\tfi\n\t$RM conftest*\n\t])\n      _LT_TAGVAR(archive_cmds_need_lc, $1)=$lt_cv_[]_LT_TAGVAR(archive_cmds_need_lc, $1)\n      ;;\n    esac\n  fi\n  ;;\nesac\n\n_LT_TAGDECL([build_libtool_need_lc], [archive_cmds_need_lc], [0],\n    [Whether or not to add -lc for building shared libraries])\n_LT_TAGDECL([allow_libtool_libs_with_static_runtimes],\n    [enable_shared_with_static_runtimes], [0],\n    [Whether or not to disallow shared libs when runtime libs are static])\n_LT_TAGDECL([], [export_dynamic_flag_spec], [1],\n    [Compiler flag to allow reflexive dlopens])\n_LT_TAGDECL([], [whole_archive_flag_spec], [1],\n    [Compiler flag to generate shared objects directly from archives])\n_LT_TAGDECL([], [compiler_needs_object], [1],\n    [Whether the compiler copes with passing no objects directly])\n_LT_TAGDECL([], [old_archive_from_new_cmds], [2],\n    [Create an old-style archive from a shared archive])\n_LT_TAGDECL([], [old_archive_from_expsyms_cmds], [2],\n    [Create a temporary old-style archive to link instead of a shared archive])\n_LT_TAGDECL([], [archive_cmds], [2], [Commands used to build a shared archive])\n_LT_TAGDECL([], [archive_expsym_cmds], [2])\n_LT_TAGDECL([], [module_cmds], [2],\n    [Commands used to build a loadable module if different from building\n    a shared archive.])\n_LT_TAGDECL([], [module_expsym_cmds], [2])\n_LT_TAGDECL([], [with_gnu_ld], [1],\n    [Whether we are building with GNU ld or not])\n_LT_TAGDECL([], [allow_undefined_flag], [1],\n    [Flag that allows shared libraries with undefined symbols to be built])\n_LT_TAGDECL([], [no_undefined_flag], [1],\n    [Flag that enforces no undefined symbols])\n_LT_TAGDECL([], [hardcode_libdir_flag_spec], [1],\n    [Flag to hardcode $libdir into a binary during linking.\n    This must work even if $libdir does not exist])\n_LT_TAGDECL([], [hardcode_libdir_separator], [1],\n    [Whether we need a single \"-rpath\" flag with a separated argument])\n_LT_TAGDECL([], [hardcode_direct], [0],\n    [Set to \"yes\" if using DIR/libNAME${shared_ext} during linking hardcodes\n    DIR into the resulting binary])\n_LT_TAGDECL([], [hardcode_direct_absolute], [0],\n    [Set to \"yes\" if using DIR/libNAME${shared_ext} during linking hardcodes\n    DIR into the resulting binary and the resulting library dependency is\n    \"absolute\", i.e impossible to change by setting ${shlibpath_var} if the\n    library is relocated])\n_LT_TAGDECL([], [hardcode_minus_L], [0],\n    [Set to \"yes\" if using the -LDIR flag during linking hardcodes DIR\n    into the resulting binary])\n_LT_TAGDECL([], [hardcode_shlibpath_var], [0],\n    [Set to \"yes\" if using SHLIBPATH_VAR=DIR during linking hardcodes DIR\n    into the resulting binary])\n_LT_TAGDECL([], [hardcode_automatic], [0],\n    [Set to \"yes\" if building a shared library automatically hardcodes DIR\n    into the library and all subsequent libraries and executables linked\n    against it])\n_LT_TAGDECL([], [inherit_rpath], [0],\n    [Set to yes if linker adds runtime paths of dependent libraries\n    to runtime path list])\n_LT_TAGDECL([], [link_all_deplibs], [0],\n    [Whether libtool must link a program against all its dependency libraries])\n_LT_TAGDECL([], [always_export_symbols], [0],\n    [Set to \"yes\" if exported symbols are required])\n_LT_TAGDECL([], [export_symbols_cmds], [2],\n    [The commands to list exported symbols])\n_LT_TAGDECL([], [exclude_expsyms], [1],\n    [Symbols that should not be listed in the preloaded symbols])\n_LT_TAGDECL([], [include_expsyms], [1],\n    [Symbols that must always be exported])\n_LT_TAGDECL([], [prelink_cmds], [2],\n    [Commands necessary for linking programs (against libraries) with templates])\n_LT_TAGDECL([], [postlink_cmds], [2],\n    [Commands necessary for finishing linking programs])\n_LT_TAGDECL([], [file_list_spec], [1],\n    [Specify filename containing input files])\ndnl FIXME: Not yet implemented\ndnl _LT_TAGDECL([], [thread_safe_flag_spec], [1],\ndnl    [Compiler flag to generate thread safe objects])\n])# _LT_LINKER_SHLIBS\n\n\n# _LT_LANG_C_CONFIG([TAG])\n# ------------------------\n# Ensure that the configuration variables for a C compiler are suitably\n# defined.  These variables are subsequently used by _LT_CONFIG to write\n# the compiler configuration to `libtool'.\nm4_defun([_LT_LANG_C_CONFIG],\n[m4_require([_LT_DECL_EGREP])dnl\nlt_save_CC=\"$CC\"\nAC_LANG_PUSH(C)\n\n# Source file extension for C test sources.\nac_ext=c\n\n# Object file extension for compiled C test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# Code to be used in simple compile tests\nlt_simple_compile_test_code=\"int some_variable = 0;\"\n\n# Code to be used in simple link tests\nlt_simple_link_test_code='int main(){return(0);}'\n\n_LT_TAG_COMPILER\n# Save the default compiler, since it gets overwritten when the other\n# tags are being tested, and _LT_TAGVAR(compiler, []) is a NOP.\ncompiler_DEFAULT=$CC\n\n# save warnings/boilerplate of simple test code\n_LT_COMPILER_BOILERPLATE\n_LT_LINKER_BOILERPLATE\n\nif test -n \"$compiler\"; then\n  _LT_COMPILER_NO_RTTI($1)\n  _LT_COMPILER_PIC($1)\n  _LT_COMPILER_C_O($1)\n  _LT_COMPILER_FILE_LOCKS($1)\n  _LT_LINKER_SHLIBS($1)\n  _LT_SYS_DYNAMIC_LINKER($1)\n  _LT_LINKER_HARDCODE_LIBPATH($1)\n  LT_SYS_DLOPEN_SELF\n  _LT_CMD_STRIPLIB\n\n  # Report which library types will actually be built\n  AC_MSG_CHECKING([if libtool supports shared libraries])\n  AC_MSG_RESULT([$can_build_shared])\n\n  AC_MSG_CHECKING([whether to build shared libraries])\n  test \"$can_build_shared\" = \"no\" && enable_shared=no\n\n  # On AIX, shared libraries and static libraries use the same namespace, and\n  # are all built from PIC.\n  case $host_os in\n  aix3*)\n    test \"$enable_shared\" = yes && enable_static=no\n    if test -n \"$RANLIB\"; then\n      archive_cmds=\"$archive_cmds~\\$RANLIB \\$lib\"\n      postinstall_cmds='$RANLIB $lib'\n    fi\n    ;;\n\n  aix[[4-9]]*)\n    if test \"$host_cpu\" != ia64 && test \"$aix_use_runtimelinking\" = no ; then\n      test \"$enable_shared\" = yes && enable_static=no\n    fi\n    ;;\n  esac\n  AC_MSG_RESULT([$enable_shared])\n\n  AC_MSG_CHECKING([whether to build static libraries])\n  # Make sure either enable_shared or enable_static is yes.\n  test \"$enable_shared\" = yes || enable_static=yes\n  AC_MSG_RESULT([$enable_static])\n\n  _LT_CONFIG($1)\nfi\nAC_LANG_POP\nCC=\"$lt_save_CC\"\n])# _LT_LANG_C_CONFIG\n\n\n# _LT_LANG_CXX_CONFIG([TAG])\n# --------------------------\n# Ensure that the configuration variables for a C++ compiler are suitably\n# defined.  These variables are subsequently used by _LT_CONFIG to write\n# the compiler configuration to `libtool'.\nm4_defun([_LT_LANG_CXX_CONFIG],\n[m4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_DECL_EGREP])dnl\nm4_require([_LT_PATH_MANIFEST_TOOL])dnl\nif test -n \"$CXX\" && ( test \"X$CXX\" != \"Xno\" &&\n    ( (test \"X$CXX\" = \"Xg++\" && `g++ -v >/dev/null 2>&1` ) ||\n    (test \"X$CXX\" != \"Xg++\"))) ; then\n  AC_PROG_CXXCPP\nelse\n  _lt_caught_CXX_error=yes\nfi\n\nAC_LANG_PUSH(C++)\n_LT_TAGVAR(archive_cmds_need_lc, $1)=no\n_LT_TAGVAR(allow_undefined_flag, $1)=\n_LT_TAGVAR(always_export_symbols, $1)=no\n_LT_TAGVAR(archive_expsym_cmds, $1)=\n_LT_TAGVAR(compiler_needs_object, $1)=no\n_LT_TAGVAR(export_dynamic_flag_spec, $1)=\n_LT_TAGVAR(hardcode_direct, $1)=no\n_LT_TAGVAR(hardcode_direct_absolute, $1)=no\n_LT_TAGVAR(hardcode_libdir_flag_spec, $1)=\n_LT_TAGVAR(hardcode_libdir_separator, $1)=\n_LT_TAGVAR(hardcode_minus_L, $1)=no\n_LT_TAGVAR(hardcode_shlibpath_var, $1)=unsupported\n_LT_TAGVAR(hardcode_automatic, $1)=no\n_LT_TAGVAR(inherit_rpath, $1)=no\n_LT_TAGVAR(module_cmds, $1)=\n_LT_TAGVAR(module_expsym_cmds, $1)=\n_LT_TAGVAR(link_all_deplibs, $1)=unknown\n_LT_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds\n_LT_TAGVAR(reload_flag, $1)=$reload_flag\n_LT_TAGVAR(reload_cmds, $1)=$reload_cmds\n_LT_TAGVAR(no_undefined_flag, $1)=\n_LT_TAGVAR(whole_archive_flag_spec, $1)=\n_LT_TAGVAR(enable_shared_with_static_runtimes, $1)=no\n\n# Source file extension for C++ test sources.\nac_ext=cpp\n\n# Object file extension for compiled C++ test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# No sense in running all these tests if we already determined that\n# the CXX compiler isn't working.  Some variables (like enable_shared)\n# are currently assumed to apply to all compilers on this platform,\n# and will be corrupted by setting them based on a non-working compiler.\nif test \"$_lt_caught_CXX_error\" != yes; then\n  # Code to be used in simple compile tests\n  lt_simple_compile_test_code=\"int some_variable = 0;\"\n\n  # Code to be used in simple link tests\n  lt_simple_link_test_code='int main(int, char *[[]]) { return(0); }'\n\n  # ltmain only uses $CC for tagged configurations so make sure $CC is set.\n  _LT_TAG_COMPILER\n\n  # save warnings/boilerplate of simple test code\n  _LT_COMPILER_BOILERPLATE\n  _LT_LINKER_BOILERPLATE\n\n  # Allow CC to be a program name with arguments.\n  lt_save_CC=$CC\n  lt_save_CFLAGS=$CFLAGS\n  lt_save_LD=$LD\n  lt_save_GCC=$GCC\n  GCC=$GXX\n  lt_save_with_gnu_ld=$with_gnu_ld\n  lt_save_path_LD=$lt_cv_path_LD\n  if test -n \"${lt_cv_prog_gnu_ldcxx+set}\"; then\n    lt_cv_prog_gnu_ld=$lt_cv_prog_gnu_ldcxx\n  else\n    $as_unset lt_cv_prog_gnu_ld\n  fi\n  if test -n \"${lt_cv_path_LDCXX+set}\"; then\n    lt_cv_path_LD=$lt_cv_path_LDCXX\n  else\n    $as_unset lt_cv_path_LD\n  fi\n  test -z \"${LDCXX+set}\" || LD=$LDCXX\n  CC=${CXX-\"c++\"}\n  CFLAGS=$CXXFLAGS\n  compiler=$CC\n  _LT_TAGVAR(compiler, $1)=$CC\n  _LT_CC_BASENAME([$compiler])\n\n  if test -n \"$compiler\"; then\n    # We don't want -fno-exception when compiling C++ code, so set the\n    # no_builtin_flag separately\n    if test \"$GXX\" = yes; then\n      _LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=' -fno-builtin'\n    else\n      _LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=\n    fi\n\n    if test \"$GXX\" = yes; then\n      # Set up default GNU C++ configuration\n\n      LT_PATH_LD\n\n      # Check if GNU C++ uses GNU ld as the underlying linker, since the\n      # archiving commands below assume that GNU ld is being used.\n      if test \"$with_gnu_ld\" = yes; then\n        _LT_TAGVAR(archive_cmds, $1)='$CC $pic_flag -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname -o $lib'\n        _LT_TAGVAR(archive_expsym_cmds, $1)='$CC $pic_flag -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'\n\n        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n        _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'\n\n        # If archive_cmds runs LD, not CC, wlarc should be empty\n        # XXX I think wlarc can be eliminated in ltcf-cxx, but I need to\n        #     investigate it a little bit more. (MM)\n        wlarc='${wl}'\n\n        # ancient GNU ld didn't support --whole-archive et. al.\n        if eval \"`$CC -print-prog-name=ld` --help 2>&1\" |\n\t  $GREP 'no-whole-archive' > /dev/null; then\n          _LT_TAGVAR(whole_archive_flag_spec, $1)=\"$wlarc\"'--whole-archive$convenience '\"$wlarc\"'--no-whole-archive'\n        else\n          _LT_TAGVAR(whole_archive_flag_spec, $1)=\n        fi\n      else\n        with_gnu_ld=no\n        wlarc=\n\n        # A generic and very simple default shared library creation\n        # command for GNU C++ for the case where it uses the native\n        # linker, instead of GNU ld.  If possible, this setting should\n        # overridden to take advantage of the native linker features on\n        # the platform it is being used on.\n        _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $lib'\n      fi\n\n      # Commands to make compiler produce verbose output that lists\n      # what \"hidden\" libraries, object files and flags are used when\n      # linking a shared library.\n      output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP -v \"^Configured with:\" | $GREP \"\\-L\"'\n\n    else\n      GXX=no\n      with_gnu_ld=no\n      wlarc=\n    fi\n\n    # PORTME: fill in a description of your system's C++ link characteristics\n    AC_MSG_CHECKING([whether the $compiler linker ($LD) supports shared libraries])\n    _LT_TAGVAR(ld_shlibs, $1)=yes\n    case $host_os in\n      aix3*)\n        # FIXME: insert proper C++ library support\n        _LT_TAGVAR(ld_shlibs, $1)=no\n        ;;\n      aix[[4-9]]*)\n        if test \"$host_cpu\" = ia64; then\n          # On IA64, the linker does run time linking by default, so we don't\n          # have to do anything special.\n          aix_use_runtimelinking=no\n          exp_sym_flag='-Bexport'\n          no_entry_flag=\"\"\n        else\n          aix_use_runtimelinking=no\n\n          # Test if we are trying to use run time linking or normal\n          # AIX style linking. If -brtl is somewhere in LDFLAGS, we\n          # need to do runtime linking.\n          case $host_os in aix4.[[23]]|aix4.[[23]].*|aix[[5-9]]*)\n\t    for ld_flag in $LDFLAGS; do\n\t      case $ld_flag in\n\t      *-brtl*)\n\t        aix_use_runtimelinking=yes\n\t        break\n\t        ;;\n\t      esac\n\t    done\n\t    ;;\n          esac\n\n          exp_sym_flag='-bexport'\n          no_entry_flag='-bnoentry'\n        fi\n\n        # When large executables or shared objects are built, AIX ld can\n        # have problems creating the table of contents.  If linking a library\n        # or program results in \"error TOC overflow\" add -mminimal-toc to\n        # CXXFLAGS/CFLAGS for g++/gcc.  In the cases where that is not\n        # enough to fix the problem, add -Wl,-bbigtoc to LDFLAGS.\n\n        _LT_TAGVAR(archive_cmds, $1)=''\n        _LT_TAGVAR(hardcode_direct, $1)=yes\n        _LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n        _LT_TAGVAR(hardcode_libdir_separator, $1)=':'\n        _LT_TAGVAR(link_all_deplibs, $1)=yes\n        _LT_TAGVAR(file_list_spec, $1)='${wl}-f,'\n\n        if test \"$GXX\" = yes; then\n          case $host_os in aix4.[[012]]|aix4.[[012]].*)\n          # We only want to do this on AIX 4.2 and lower, the check\n          # below for broken collect2 doesn't work under 4.3+\n\t  collect2name=`${CC} -print-prog-name=collect2`\n\t  if test -f \"$collect2name\" &&\n\t     strings \"$collect2name\" | $GREP resolve_lib_name >/dev/null\n\t  then\n\t    # We have reworked collect2\n\t    :\n\t  else\n\t    # We have old collect2\n\t    _LT_TAGVAR(hardcode_direct, $1)=unsupported\n\t    # It fails to find uninstalled libraries when the uninstalled\n\t    # path is not listed in the libpath.  Setting hardcode_minus_L\n\t    # to unsupported forces relinking\n\t    _LT_TAGVAR(hardcode_minus_L, $1)=yes\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n\t    _LT_TAGVAR(hardcode_libdir_separator, $1)=\n\t  fi\n          esac\n          shared_flag='-shared'\n\t  if test \"$aix_use_runtimelinking\" = yes; then\n\t    shared_flag=\"$shared_flag \"'${wl}-G'\n\t  fi\n        else\n          # not using gcc\n          if test \"$host_cpu\" = ia64; then\n\t  # VisualAge C++, Version 5.5 for AIX 5L for IA-64, Beta 3 Release\n\t  # chokes on -Wl,-G. The following line is correct:\n\t  shared_flag='-G'\n          else\n\t    if test \"$aix_use_runtimelinking\" = yes; then\n\t      shared_flag='${wl}-G'\n\t    else\n\t      shared_flag='${wl}-bM:SRE'\n\t    fi\n          fi\n        fi\n\n        _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-bexpall'\n        # It seems that -bexpall does not export symbols beginning with\n        # underscore (_), so it is better to generate a list of symbols to\n\t# export.\n        _LT_TAGVAR(always_export_symbols, $1)=yes\n        if test \"$aix_use_runtimelinking\" = yes; then\n          # Warning - without using the other runtime loading flags (-brtl),\n          # -berok will link without error, but may produce a broken library.\n          _LT_TAGVAR(allow_undefined_flag, $1)='-berok'\n          # Determine the default libpath from the value encoded in an empty\n          # executable.\n          _LT_SYS_MODULE_PATH_AIX([$1])\n          _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-blibpath:$libdir:'\"$aix_libpath\"\n\n          _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -o $output_objdir/$soname $libobjs $deplibs '\"\\${wl}$no_entry_flag\"' $compiler_flags `if test \"x${allow_undefined_flag}\" != \"x\"; then func_echo_all \"${wl}${allow_undefined_flag}\"; else :; fi` '\"\\${wl}$exp_sym_flag:\\$export_symbols $shared_flag\"\n        else\n          if test \"$host_cpu\" = ia64; then\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-R $libdir:/usr/lib:/lib'\n\t    _LT_TAGVAR(allow_undefined_flag, $1)=\"-z nodefs\"\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)=\"\\$CC $shared_flag\"' -o $output_objdir/$soname $libobjs $deplibs '\"\\${wl}$no_entry_flag\"' $compiler_flags ${wl}${allow_undefined_flag} '\"\\${wl}$exp_sym_flag:\\$export_symbols\"\n          else\n\t    # Determine the default libpath from the value encoded in an\n\t    # empty executable.\n\t    _LT_SYS_MODULE_PATH_AIX([$1])\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-blibpath:$libdir:'\"$aix_libpath\"\n\t    # Warning - without using the other run time loading flags,\n\t    # -berok will link without error, but may produce a broken library.\n\t    _LT_TAGVAR(no_undefined_flag, $1)=' ${wl}-bernotok'\n\t    _LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-berok'\n\t    if test \"$with_gnu_ld\" = yes; then\n\t      # We only use this code for GNU lds that support --whole-archive.\n\t      _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive$convenience ${wl}--no-whole-archive'\n\t    else\n\t      # Exported symbols can be pulled into shared objects from archives\n\t      _LT_TAGVAR(whole_archive_flag_spec, $1)='$convenience'\n\t    fi\n\t    _LT_TAGVAR(archive_cmds_need_lc, $1)=yes\n\t    # This is similar to how AIX traditionally builds its shared\n\t    # libraries.\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)=\"\\$CC $shared_flag\"' -o $output_objdir/$soname $libobjs $deplibs ${wl}-bnoentry $compiler_flags ${wl}-bE:$export_symbols${allow_undefined_flag}~$AR $AR_FLAGS $output_objdir/$libname$release.a $output_objdir/$soname'\n          fi\n        fi\n        ;;\n\n      beos*)\n\tif $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then\n\t  _LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n\t  # Joseph Beckenbach <jrb3@best.com> says some releases of gcc\n\t  # support --undefined.  This deserves some investigation.  FIXME\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -nostart $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\telse\n\t  _LT_TAGVAR(ld_shlibs, $1)=no\n\tfi\n\t;;\n\n      chorus*)\n        case $cc_basename in\n          *)\n\t  # FIXME: insert proper C++ library support\n\t  _LT_TAGVAR(ld_shlibs, $1)=no\n\t  ;;\n        esac\n        ;;\n\n      cygwin* | mingw* | pw32* | cegcc*)\n\tcase $GXX,$cc_basename in\n\t,cl* | no,cl*)\n\t  # Native MSVC\n\t  # hardcode_libdir_flag_spec is actually meaningless, as there is\n\t  # no search path for DLLs.\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)=' '\n\t  _LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n\t  _LT_TAGVAR(always_export_symbols, $1)=yes\n\t  _LT_TAGVAR(file_list_spec, $1)='@'\n\t  # Tell ltmain to make .lib files, not .a files.\n\t  libext=lib\n\t  # Tell ltmain to make .dll files, not .so files.\n\t  shrext_cmds=\".dll\"\n\t  # FIXME: Setting linknames here is a bad hack.\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -o $output_objdir/$soname $libobjs $compiler_flags $deplibs -Wl,-dll~linknames='\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)='if test \"x`$SED 1q $export_symbols`\" = xEXPORTS; then\n\t      $SED -n -e 's/\\\\\\\\\\\\\\(.*\\\\\\\\\\\\\\)/-link\\\\\\ -EXPORT:\\\\\\\\\\\\\\1/' -e '1\\\\\\!p' < $export_symbols > $output_objdir/$soname.exp;\n\t    else\n\t      $SED -e 's/\\\\\\\\\\\\\\(.*\\\\\\\\\\\\\\)/-link\\\\\\ -EXPORT:\\\\\\\\\\\\\\1/' < $export_symbols > $output_objdir/$soname.exp;\n\t    fi~\n\t    $CC -o $tool_output_objdir$soname $libobjs $compiler_flags $deplibs \"@$tool_output_objdir$soname.exp\" -Wl,-DLL,-IMPLIB:\"$tool_output_objdir$libname.dll.lib\"~\n\t    linknames='\n\t  # The linker will not automatically build a static lib if we build a DLL.\n\t  # _LT_TAGVAR(old_archive_from_new_cmds, $1)='true'\n\t  _LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes\n\t  # Don't use ranlib\n\t  _LT_TAGVAR(old_postinstall_cmds, $1)='chmod 644 $oldlib'\n\t  _LT_TAGVAR(postlink_cmds, $1)='lt_outputfile=\"@OUTPUT@\"~\n\t    lt_tool_outputfile=\"@TOOL_OUTPUT@\"~\n\t    case $lt_outputfile in\n\t      *.exe|*.EXE) ;;\n\t      *)\n\t\tlt_outputfile=\"$lt_outputfile.exe\"\n\t\tlt_tool_outputfile=\"$lt_tool_outputfile.exe\"\n\t\t;;\n\t    esac~\n\t    func_to_tool_file \"$lt_outputfile\"~\n\t    if test \"$MANIFEST_TOOL\" != \":\" && test -f \"$lt_outputfile.manifest\"; then\n\t      $MANIFEST_TOOL -manifest \"$lt_tool_outputfile.manifest\" -outputresource:\"$lt_tool_outputfile\" || exit 1;\n\t      $RM \"$lt_outputfile.manifest\";\n\t    fi'\n\t  ;;\n\t*)\n\t  # g++\n\t  # _LT_TAGVAR(hardcode_libdir_flag_spec, $1) is actually meaningless,\n\t  # as there is no search path for DLLs.\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n\t  _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-all-symbols'\n\t  _LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n\t  _LT_TAGVAR(always_export_symbols, $1)=no\n\t  _LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes\n\n\t  if $LD --help 2>&1 | $GREP 'auto-import' > /dev/null; then\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'\n\t    # If the export-symbols file already is a .def file (1st line\n\t    # is EXPORTS), use it as is; otherwise, prepend...\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='if test \"x`$SED 1q $export_symbols`\" = xEXPORTS; then\n\t      cp $export_symbols $output_objdir/$soname.def;\n\t    else\n\t      echo EXPORTS > $output_objdir/$soname.def;\n\t      cat $export_symbols >> $output_objdir/$soname.def;\n\t    fi~\n\t    $CC -shared -nostdlib $output_objdir/$soname.def $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'\n\t  else\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t  fi\n\t  ;;\n\tesac\n\t;;\n      darwin* | rhapsody*)\n        _LT_DARWIN_LINKER_FEATURES($1)\n\t;;\n\n      dgux*)\n        case $cc_basename in\n          ec++*)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          ghcx*)\n\t    # Green Hills C++ Compiler\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          *)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n        esac\n        ;;\n\n      freebsd2.*)\n        # C++ shared libraries reported to be fairly broken before\n\t# switch to ELF\n        _LT_TAGVAR(ld_shlibs, $1)=no\n        ;;\n\n      freebsd-elf*)\n        _LT_TAGVAR(archive_cmds_need_lc, $1)=no\n        ;;\n\n      freebsd* | dragonfly*)\n        # FreeBSD 3 and later use GNU C++ and GNU ld with standard ELF\n        # conventions\n        _LT_TAGVAR(ld_shlibs, $1)=yes\n        ;;\n\n      gnu*)\n        ;;\n\n      haiku*)\n        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n        _LT_TAGVAR(link_all_deplibs, $1)=yes\n        ;;\n\n      hpux9*)\n        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'\n        _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n        _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n        _LT_TAGVAR(hardcode_direct, $1)=yes\n        _LT_TAGVAR(hardcode_minus_L, $1)=yes # Not in the search PATH,\n\t\t\t\t             # but as the default\n\t\t\t\t             # location of the library.\n\n        case $cc_basename in\n          CC*)\n            # FIXME: insert proper C++ library support\n            _LT_TAGVAR(ld_shlibs, $1)=no\n            ;;\n          aCC*)\n            _LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/$soname~$CC -b ${wl}+b ${wl}$install_libdir -o $output_objdir/$soname $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'\n            # Commands to make compiler produce verbose output that lists\n            # what \"hidden\" libraries, object files and flags are used when\n            # linking a shared library.\n            #\n            # There doesn't appear to be a way to prevent this compiler from\n            # explicitly linking system object files so we need to strip them\n            # from the output so that they don't get included in the library\n            # dependencies.\n            output_verbose_link_cmd='templist=`($CC -b $CFLAGS -v conftest.$objext 2>&1) | $EGREP \"\\-L\"`; list=\"\"; for z in $templist; do case $z in conftest.$objext) list=\"$list $z\";; *.$objext);; *) list=\"$list $z\";;esac; done; func_echo_all \"$list\"'\n            ;;\n          *)\n            if test \"$GXX\" = yes; then\n              _LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/$soname~$CC -shared -nostdlib $pic_flag ${wl}+b ${wl}$install_libdir -o $output_objdir/$soname $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'\n            else\n              # FIXME: insert proper C++ library support\n              _LT_TAGVAR(ld_shlibs, $1)=no\n            fi\n            ;;\n        esac\n        ;;\n\n      hpux10*|hpux11*)\n        if test $with_gnu_ld = no; then\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'\n\t  _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\n          case $host_cpu in\n            hppa*64*|ia64*)\n              ;;\n            *)\n\t      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n              ;;\n          esac\n        fi\n        case $host_cpu in\n          hppa*64*|ia64*)\n            _LT_TAGVAR(hardcode_direct, $1)=no\n            _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n            ;;\n          *)\n            _LT_TAGVAR(hardcode_direct, $1)=yes\n            _LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n            _LT_TAGVAR(hardcode_minus_L, $1)=yes # Not in the search PATH,\n\t\t\t\t\t         # but as the default\n\t\t\t\t\t         # location of the library.\n            ;;\n        esac\n\n        case $cc_basename in\n          CC*)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          aCC*)\n\t    case $host_cpu in\n\t      hppa*64*)\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t        ;;\n\t      ia64*)\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t        ;;\n\t      *)\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t        ;;\n\t    esac\n\t    # Commands to make compiler produce verbose output that lists\n\t    # what \"hidden\" libraries, object files and flags are used when\n\t    # linking a shared library.\n\t    #\n\t    # There doesn't appear to be a way to prevent this compiler from\n\t    # explicitly linking system object files so we need to strip them\n\t    # from the output so that they don't get included in the library\n\t    # dependencies.\n\t    output_verbose_link_cmd='templist=`($CC -b $CFLAGS -v conftest.$objext 2>&1) | $GREP \"\\-L\"`; list=\"\"; for z in $templist; do case $z in conftest.$objext) list=\"$list $z\";; *.$objext);; *) list=\"$list $z\";;esac; done; func_echo_all \"$list\"'\n\t    ;;\n          *)\n\t    if test \"$GXX\" = yes; then\n\t      if test $with_gnu_ld = no; then\n\t        case $host_cpu in\n\t          hppa*64*)\n\t            _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib -fPIC ${wl}+h ${wl}$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t            ;;\n\t          ia64*)\n\t            _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $pic_flag ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t            ;;\n\t          *)\n\t            _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $pic_flag ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t            ;;\n\t        esac\n\t      fi\n\t    else\n\t      # FIXME: insert proper C++ library support\n\t      _LT_TAGVAR(ld_shlibs, $1)=no\n\t    fi\n\t    ;;\n        esac\n        ;;\n\n      interix[[3-9]]*)\n\t_LT_TAGVAR(hardcode_direct, $1)=no\n\t_LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n\t_LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n\t# Hack: On Interix 3.x, we cannot compile PIC because of a broken gcc.\n\t# Instead, shared libraries are loaded at an image base (0x10000000 by\n\t# default) and relocated if they conflict, which is a slow very memory\n\t# consuming and fragmenting process.  To avoid this, we pick a random,\n\t# 256 KiB-aligned image base between 0x50000000 and 0x6FFC0000 at link\n\t# time.  Moving up from 0x10000000 also allows more sbrk(2) space.\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \\* 262144 + 1342177280` -o $lib'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='sed \"s,^,_,\" $export_symbols >$output_objdir/$soname.expsym~$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--retain-symbols-file,$output_objdir/$soname.expsym ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \\* 262144 + 1342177280` -o $lib'\n\t;;\n      irix5* | irix6*)\n        case $cc_basename in\n          CC*)\n\t    # SGI C++\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -shared -all -multigot $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -soname $soname `test -n \"$verstring\" && func_echo_all \"-set_version $verstring\"` -update_registry ${output_objdir}/so_locations -o $lib'\n\n\t    # Archives containing C++ object files must be created using\n\t    # \"CC -ar\", where \"CC\" is the IRIX C++ compiler.  This is\n\t    # necessary to make sure instantiated templates are included\n\t    # in the archive.\n\t    _LT_TAGVAR(old_archive_cmds, $1)='$CC -ar -WR,-u -o $oldlib $oldobjs'\n\t    ;;\n          *)\n\t    if test \"$GXX\" = yes; then\n\t      if test \"$with_gnu_ld\" = no; then\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname `test -n \"$verstring\" && func_echo_all \"${wl}-set_version ${wl}$verstring\"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'\n\t      else\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname `test -n \"$verstring\" && func_echo_all \"${wl}-set_version ${wl}$verstring\"` -o $lib'\n\t      fi\n\t    fi\n\t    _LT_TAGVAR(link_all_deplibs, $1)=yes\n\t    ;;\n        esac\n        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n        _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n        _LT_TAGVAR(inherit_rpath, $1)=yes\n        ;;\n\n      linux* | k*bsd*-gnu | kopensolaris*-gnu)\n        case $cc_basename in\n          KCC*)\n\t    # Kuck and Associates, Inc. (KAI) C++ Compiler\n\n\t    # KCC will only create a shared library if the output file\n\t    # ends with \".so\" (or \".sl\" for HP-UX), so rename the library\n\t    # to its proper name (with version) after linking.\n\t    _LT_TAGVAR(archive_cmds, $1)='tempext=`echo $shared_ext | $SED -e '\\''s/\\([[^()0-9A-Za-z{}]]\\)/\\\\\\\\\\1/g'\\''`; templib=`echo $lib | $SED -e \"s/\\${tempext}\\..*/.so/\"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \\$templib; mv \\$templib $lib'\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='tempext=`echo $shared_ext | $SED -e '\\''s/\\([[^()0-9A-Za-z{}]]\\)/\\\\\\\\\\1/g'\\''`; templib=`echo $lib | $SED -e \"s/\\${tempext}\\..*/.so/\"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \\$templib ${wl}-retain-symbols-file,$export_symbols; mv \\$templib $lib'\n\t    # Commands to make compiler produce verbose output that lists\n\t    # what \"hidden\" libraries, object files and flags are used when\n\t    # linking a shared library.\n\t    #\n\t    # There doesn't appear to be a way to prevent this compiler from\n\t    # explicitly linking system object files so we need to strip them\n\t    # from the output so that they don't get included in the library\n\t    # dependencies.\n\t    output_verbose_link_cmd='templist=`$CC $CFLAGS -v conftest.$objext -o libconftest$shared_ext 2>&1 | $GREP \"ld\"`; rm -f libconftest$shared_ext; list=\"\"; for z in $templist; do case $z in conftest.$objext) list=\"$list $z\";; *.$objext);; *) list=\"$list $z\";;esac; done; func_echo_all \"$list\"'\n\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n\t    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'\n\n\t    # Archives containing C++ object files must be created using\n\t    # \"CC -Bstatic\", where \"CC\" is the KAI C++ compiler.\n\t    _LT_TAGVAR(old_archive_cmds, $1)='$CC -Bstatic -o $oldlib $oldobjs'\n\t    ;;\n\t  icpc* | ecpc* )\n\t    # Intel C++\n\t    with_gnu_ld=yes\n\t    # version 8.0 and above of icpc choke on multiply defined symbols\n\t    # if we add $predep_objects and $postdep_objects, however 7.1 and\n\t    # earlier do not add the objects themselves.\n\t    case `$CC -V 2>&1` in\n\t      *\"Version 7.\"*)\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\t\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'\n\t\t;;\n\t      *)  # Version 8.0 or newer\n\t        tmp_idyn=\n\t        case $host_cpu in\n\t\t  ia64*) tmp_idyn=' -i_dynamic';;\n\t\tesac\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared'\"$tmp_idyn\"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\t\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared'\"$tmp_idyn\"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'\n\t\t;;\n\t    esac\n\t    _LT_TAGVAR(archive_cmds_need_lc, $1)=no\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n\t    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'\n\t    _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive$convenience ${wl}--no-whole-archive'\n\t    ;;\n          pgCC* | pgcpp*)\n            # Portland Group C++ compiler\n\t    case `$CC -V` in\n\t    *pgCC\\ [[1-5]].* | *pgcpp\\ [[1-5]].*)\n\t      _LT_TAGVAR(prelink_cmds, $1)='tpldir=Template.dir~\n\t\trm -rf $tpldir~\n\t\t$CC --prelink_objects --instantiation_dir $tpldir $objs $libobjs $compile_deplibs~\n\t\tcompile_command=\"$compile_command `find $tpldir -name \\*.o | sort | $NL2SP`\"'\n\t      _LT_TAGVAR(old_archive_cmds, $1)='tpldir=Template.dir~\n\t\trm -rf $tpldir~\n\t\t$CC --prelink_objects --instantiation_dir $tpldir $oldobjs$old_deplibs~\n\t\t$AR $AR_FLAGS $oldlib$oldobjs$old_deplibs `find $tpldir -name \\*.o | sort | $NL2SP`~\n\t\t$RANLIB $oldlib'\n\t      _LT_TAGVAR(archive_cmds, $1)='tpldir=Template.dir~\n\t\trm -rf $tpldir~\n\t\t$CC --prelink_objects --instantiation_dir $tpldir $predep_objects $libobjs $deplibs $convenience $postdep_objects~\n\t\t$CC -shared $pic_flag $predep_objects $libobjs $deplibs `find $tpldir -name \\*.o | sort | $NL2SP` $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname -o $lib'\n\t      _LT_TAGVAR(archive_expsym_cmds, $1)='tpldir=Template.dir~\n\t\trm -rf $tpldir~\n\t\t$CC --prelink_objects --instantiation_dir $tpldir $predep_objects $libobjs $deplibs $convenience $postdep_objects~\n\t\t$CC -shared $pic_flag $predep_objects $libobjs $deplibs `find $tpldir -name \\*.o | sort | $NL2SP` $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname ${wl}-retain-symbols-file ${wl}$export_symbols -o $lib'\n\t      ;;\n\t    *) # Version 6 and above use weak symbols\n\t      _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname -o $lib'\n\t      _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname ${wl}-retain-symbols-file ${wl}$export_symbols -o $lib'\n\t      ;;\n\t    esac\n\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}--rpath ${wl}$libdir'\n\t    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'\n\t    _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`for conv in $convenience\\\"\\\"; do test  -n \\\"$conv\\\" && new_convenience=\\\"$new_convenience,$conv\\\"; done; func_echo_all \\\"$new_convenience\\\"` ${wl}--no-whole-archive'\n            ;;\n\t  cxx*)\n\t    # Compaq C++\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname  -o $lib ${wl}-retain-symbols-file $wl$export_symbols'\n\n\t    runpath_var=LD_RUN_PATH\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-rpath $libdir'\n\t    _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\n\t    # Commands to make compiler produce verbose output that lists\n\t    # what \"hidden\" libraries, object files and flags are used when\n\t    # linking a shared library.\n\t    #\n\t    # There doesn't appear to be a way to prevent this compiler from\n\t    # explicitly linking system object files so we need to strip them\n\t    # from the output so that they don't get included in the library\n\t    # dependencies.\n\t    output_verbose_link_cmd='templist=`$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP \"ld\"`; templist=`func_echo_all \"$templist\" | $SED \"s/\\(^.*ld.*\\)\\( .*ld .*$\\)/\\1/\"`; list=\"\"; for z in $templist; do case $z in conftest.$objext) list=\"$list $z\";; *.$objext);; *) list=\"$list $z\";;esac; done; func_echo_all \"X$list\" | $Xsed'\n\t    ;;\n\t  xl* | mpixl* | bgxl*)\n\t    # IBM XL 8.0 on PPC, with GNU ld\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n\t    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -qmkshrobj $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\t    if test \"x$supports_anon_versioning\" = xyes; then\n\t      _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $output_objdir/$libname.ver~\n\t\tcat $export_symbols | sed -e \"s/\\(.*\\)/\\1;/\" >> $output_objdir/$libname.ver~\n\t\techo \"local: *; };\" >> $output_objdir/$libname.ver~\n\t\t$CC -qmkshrobj $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-version-script ${wl}$output_objdir/$libname.ver -o $lib'\n\t    fi\n\t    ;;\n\t  *)\n\t    case `$CC -V 2>&1 | sed 5q` in\n\t    *Sun\\ C*)\n\t      # Sun C++ 5.9\n\t      _LT_TAGVAR(no_undefined_flag, $1)=' -zdefs'\n\t      _LT_TAGVAR(archive_cmds, $1)='$CC -G${allow_undefined_flag} -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t      _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G${allow_undefined_flag} -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-retain-symbols-file ${wl}$export_symbols'\n\t      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n\t      _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`new_convenience=; for conv in $convenience\\\"\\\"; do test -z \\\"$conv\\\" || new_convenience=\\\"$new_convenience,$conv\\\"; done; func_echo_all \\\"$new_convenience\\\"` ${wl}--no-whole-archive'\n\t      _LT_TAGVAR(compiler_needs_object, $1)=yes\n\n\t      # Not sure whether something based on\n\t      # $CC $CFLAGS -v conftest.$objext -o libconftest$shared_ext 2>&1\n\t      # would be better.\n\t      output_verbose_link_cmd='func_echo_all'\n\n\t      # Archives containing C++ object files must be created using\n\t      # \"CC -xar\", where \"CC\" is the Sun C++ compiler.  This is\n\t      # necessary to make sure instantiated templates are included\n\t      # in the archive.\n\t      _LT_TAGVAR(old_archive_cmds, $1)='$CC -xar -o $oldlib $oldobjs'\n\t      ;;\n\t    esac\n\t    ;;\n\tesac\n\t;;\n\n      lynxos*)\n        # FIXME: insert proper C++ library support\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n\t;;\n\n      m88k*)\n        # FIXME: insert proper C++ library support\n        _LT_TAGVAR(ld_shlibs, $1)=no\n\t;;\n\n      mvs*)\n        case $cc_basename in\n          cxx*)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n\t  *)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n\tesac\n\t;;\n\n      netbsd*)\n        if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then\n\t  _LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable  -o $lib $predep_objects $libobjs $deplibs $postdep_objects $linker_flags'\n\t  wlarc=\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n\t  _LT_TAGVAR(hardcode_direct, $1)=yes\n\t  _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\tfi\n\t# Workaround some broken pre-1.5 toolchains\n\toutput_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP conftest.$objext | $SED -e \"s:-lgcc -lc -lgcc::\"'\n\t;;\n\n      *nto* | *qnx*)\n        _LT_TAGVAR(ld_shlibs, $1)=yes\n\t;;\n\n      openbsd2*)\n        # C++ shared libraries are fairly broken\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n\t;;\n\n      openbsd*)\n\tif test -f /usr/libexec/ld.so; then\n\t  _LT_TAGVAR(hardcode_direct, $1)=yes\n\t  _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\t  _LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $lib'\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n\t  if test -z \"`echo __ELF__ | $CC -E - | grep __ELF__`\" || test \"$host_os-$host_cpu\" = \"openbsd2.8-powerpc\"; then\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-retain-symbols-file,$export_symbols -o $lib'\n\t    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n\t    _LT_TAGVAR(whole_archive_flag_spec, $1)=\"$wlarc\"'--whole-archive$convenience '\"$wlarc\"'--no-whole-archive'\n\t  fi\n\t  output_verbose_link_cmd=func_echo_all\n\telse\n\t  _LT_TAGVAR(ld_shlibs, $1)=no\n\tfi\n\t;;\n\n      osf3* | osf4* | osf5*)\n        case $cc_basename in\n          KCC*)\n\t    # Kuck and Associates, Inc. (KAI) C++ Compiler\n\n\t    # KCC will only create a shared library if the output file\n\t    # ends with \".so\" (or \".sl\" for HP-UX), so rename the library\n\t    # to its proper name (with version) after linking.\n\t    _LT_TAGVAR(archive_cmds, $1)='tempext=`echo $shared_ext | $SED -e '\\''s/\\([[^()0-9A-Za-z{}]]\\)/\\\\\\\\\\1/g'\\''`; templib=`echo \"$lib\" | $SED -e \"s/\\${tempext}\\..*/.so/\"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \\$templib; mv \\$templib $lib'\n\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n\t    _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\n\t    # Archives containing C++ object files must be created using\n\t    # the KAI C++ compiler.\n\t    case $host in\n\t      osf3*) _LT_TAGVAR(old_archive_cmds, $1)='$CC -Bstatic -o $oldlib $oldobjs' ;;\n\t      *) _LT_TAGVAR(old_archive_cmds, $1)='$CC -o $oldlib $oldobjs' ;;\n\t    esac\n\t    ;;\n          RCC*)\n\t    # Rational C++ 2.4.1\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          cxx*)\n\t    case $host in\n\t      osf3*)\n\t        _LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-expect_unresolved ${wl}\\*'\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $soname `test -n \"$verstring\" && func_echo_all \"${wl}-set_version $verstring\"` -update_registry ${output_objdir}/so_locations -o $lib'\n\t        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n\t\t;;\n\t      *)\n\t        _LT_TAGVAR(allow_undefined_flag, $1)=' -expect_unresolved \\*'\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -msym -soname $soname `test -n \"$verstring\" && func_echo_all \"-set_version $verstring\"` -update_registry ${output_objdir}/so_locations -o $lib'\n\t        _LT_TAGVAR(archive_expsym_cmds, $1)='for i in `cat $export_symbols`; do printf \"%s %s\\\\n\" -exported_symbol \"\\$i\" >> $lib.exp; done~\n\t          echo \"-hidden\">> $lib.exp~\n\t          $CC -shared$allow_undefined_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -msym -soname $soname ${wl}-input ${wl}$lib.exp  `test -n \"$verstring\" && $ECHO \"-set_version $verstring\"` -update_registry ${output_objdir}/so_locations -o $lib~\n\t          $RM $lib.exp'\n\t        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-rpath $libdir'\n\t\t;;\n\t    esac\n\n\t    _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\n\t    # Commands to make compiler produce verbose output that lists\n\t    # what \"hidden\" libraries, object files and flags are used when\n\t    # linking a shared library.\n\t    #\n\t    # There doesn't appear to be a way to prevent this compiler from\n\t    # explicitly linking system object files so we need to strip them\n\t    # from the output so that they don't get included in the library\n\t    # dependencies.\n\t    output_verbose_link_cmd='templist=`$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP \"ld\" | $GREP -v \"ld:\"`; templist=`func_echo_all \"$templist\" | $SED \"s/\\(^.*ld.*\\)\\( .*ld.*$\\)/\\1/\"`; list=\"\"; for z in $templist; do case $z in conftest.$objext) list=\"$list $z\";; *.$objext);; *) list=\"$list $z\";;esac; done; func_echo_all \"$list\"'\n\t    ;;\n\t  *)\n\t    if test \"$GXX\" = yes && test \"$with_gnu_ld\" = no; then\n\t      _LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-expect_unresolved ${wl}\\*'\n\t      case $host in\n\t        osf3*)\n\t          _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib ${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname `test -n \"$verstring\" && func_echo_all \"${wl}-set_version ${wl}$verstring\"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'\n\t\t  ;;\n\t        *)\n\t          _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -nostdlib ${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-msym ${wl}-soname ${wl}$soname `test -n \"$verstring\" && func_echo_all \"${wl}-set_version ${wl}$verstring\"` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'\n\t\t  ;;\n\t      esac\n\n\t      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n\t      _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\n\t      # Commands to make compiler produce verbose output that lists\n\t      # what \"hidden\" libraries, object files and flags are used when\n\t      # linking a shared library.\n\t      output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP -v \"^Configured with:\" | $GREP \"\\-L\"'\n\n\t    else\n\t      # FIXME: insert proper C++ library support\n\t      _LT_TAGVAR(ld_shlibs, $1)=no\n\t    fi\n\t    ;;\n        esac\n        ;;\n\n      psos*)\n        # FIXME: insert proper C++ library support\n        _LT_TAGVAR(ld_shlibs, $1)=no\n        ;;\n\n      sunos4*)\n        case $cc_basename in\n          CC*)\n\t    # Sun C++ 4.x\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          lcc*)\n\t    # Lucid\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          *)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n        esac\n        ;;\n\n      solaris*)\n        case $cc_basename in\n          CC* | sunCC*)\n\t    # Sun C++ 4.2, 5.x and Centerline C++\n            _LT_TAGVAR(archive_cmds_need_lc,$1)=yes\n\t    _LT_TAGVAR(no_undefined_flag, $1)=' -zdefs'\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -G${allow_undefined_flag}  -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $lib.exp~cat $export_symbols | $SED -e \"s/\\(.*\\)/\\1;/\" >> $lib.exp~echo \"local: *; };\" >> $lib.exp~\n\t      $CC -G${allow_undefined_flag} ${wl}-M ${wl}$lib.exp -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$RM $lib.exp'\n\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n\t    _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\t    case $host_os in\n\t      solaris2.[[0-5]] | solaris2.[[0-5]].*) ;;\n\t      *)\n\t\t# The compiler driver will combine and reorder linker options,\n\t\t# but understands `-z linker_flag'.\n\t        # Supported since Solaris 2.6 (maybe 2.5.1?)\n\t\t_LT_TAGVAR(whole_archive_flag_spec, $1)='-z allextract$convenience -z defaultextract'\n\t        ;;\n\t    esac\n\t    _LT_TAGVAR(link_all_deplibs, $1)=yes\n\n\t    output_verbose_link_cmd='func_echo_all'\n\n\t    # Archives containing C++ object files must be created using\n\t    # \"CC -xar\", where \"CC\" is the Sun C++ compiler.  This is\n\t    # necessary to make sure instantiated templates are included\n\t    # in the archive.\n\t    _LT_TAGVAR(old_archive_cmds, $1)='$CC -xar -o $oldlib $oldobjs'\n\t    ;;\n          gcx*)\n\t    # Green Hills C++ Compiler\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-h $wl$soname -o $lib'\n\n\t    # The C++ compiler must be used to create the archive.\n\t    _LT_TAGVAR(old_archive_cmds, $1)='$CC $LDFLAGS -archive -o $oldlib $oldobjs'\n\t    ;;\n          *)\n\t    # GNU C++ compiler with Solaris linker\n\t    if test \"$GXX\" = yes && test \"$with_gnu_ld\" = no; then\n\t      _LT_TAGVAR(no_undefined_flag, $1)=' ${wl}-z ${wl}defs'\n\t      if $CC --version | $GREP -v '^2\\.7' > /dev/null; then\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -nostdlib $LDFLAGS $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-h $wl$soname -o $lib'\n\t        _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $lib.exp~cat $export_symbols | $SED -e \"s/\\(.*\\)/\\1;/\" >> $lib.exp~echo \"local: *; };\" >> $lib.exp~\n\t\t  $CC -shared $pic_flag -nostdlib ${wl}-M $wl$lib.exp -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$RM $lib.exp'\n\n\t        # Commands to make compiler produce verbose output that lists\n\t        # what \"hidden\" libraries, object files and flags are used when\n\t        # linking a shared library.\n\t        output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP -v \"^Configured with:\" | $GREP \"\\-L\"'\n\t      else\n\t        # g++ 2.7 appears to require `-G' NOT `-shared' on this\n\t        # platform.\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -G -nostdlib $LDFLAGS $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-h $wl$soname -o $lib'\n\t        _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $lib.exp~cat $export_symbols | $SED -e \"s/\\(.*\\)/\\1;/\" >> $lib.exp~echo \"local: *; };\" >> $lib.exp~\n\t\t  $CC -G -nostdlib ${wl}-M $wl$lib.exp -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$RM $lib.exp'\n\n\t        # Commands to make compiler produce verbose output that lists\n\t        # what \"hidden\" libraries, object files and flags are used when\n\t        # linking a shared library.\n\t        output_verbose_link_cmd='$CC -G $CFLAGS -v conftest.$objext 2>&1 | $GREP -v \"^Configured with:\" | $GREP \"\\-L\"'\n\t      fi\n\n\t      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-R $wl$libdir'\n\t      case $host_os in\n\t\tsolaris2.[[0-5]] | solaris2.[[0-5]].*) ;;\n\t\t*)\n\t\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}-z ${wl}allextract$convenience ${wl}-z ${wl}defaultextract'\n\t\t  ;;\n\t      esac\n\t    fi\n\t    ;;\n        esac\n        ;;\n\n    sysv4*uw2* | sysv5OpenUNIX* | sysv5UnixWare7.[[01]].[[10]]* | unixware7* | sco3.2v5.0.[[024]]*)\n      _LT_TAGVAR(no_undefined_flag, $1)='${wl}-z,text'\n      _LT_TAGVAR(archive_cmds_need_lc, $1)=no\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      runpath_var='LD_RUN_PATH'\n\n      case $cc_basename in\n        CC*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\t*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n      esac\n      ;;\n\n      sysv5* | sco3.2v5* | sco5v6*)\n\t# Note: We can NOT use -z defs as we might desire, because we do not\n\t# link with -lc, and that would cause any symbols used from libc to\n\t# always be unresolved, which means just about no library would\n\t# ever link correctly.  If we're not using GNU ld we use -z text\n\t# though, which does catch some bad symbols but isn't as heavy-handed\n\t# as -z defs.\n\t_LT_TAGVAR(no_undefined_flag, $1)='${wl}-z,text'\n\t_LT_TAGVAR(allow_undefined_flag, $1)='${wl}-z,nodefs'\n\t_LT_TAGVAR(archive_cmds_need_lc, $1)=no\n\t_LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-R,$libdir'\n\t_LT_TAGVAR(hardcode_libdir_separator, $1)=':'\n\t_LT_TAGVAR(link_all_deplibs, $1)=yes\n\t_LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-Bexport'\n\trunpath_var='LD_RUN_PATH'\n\n\tcase $cc_basename in\n          CC*)\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t    _LT_TAGVAR(old_archive_cmds, $1)='$CC -Tprelink_objects $oldobjs~\n\t      '\"$_LT_TAGVAR(old_archive_cmds, $1)\"\n\t    _LT_TAGVAR(reload_cmds, $1)='$CC -Tprelink_objects $reload_objs~\n\t      '\"$_LT_TAGVAR(reload_cmds, $1)\"\n\t    ;;\n\t  *)\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t    ;;\n\tesac\n      ;;\n\n      tandem*)\n        case $cc_basename in\n          NCC*)\n\t    # NonStop-UX NCC 3.20\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          *)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n        esac\n        ;;\n\n      vxworks*)\n        # FIXME: insert proper C++ library support\n        _LT_TAGVAR(ld_shlibs, $1)=no\n        ;;\n\n      *)\n        # FIXME: insert proper C++ library support\n        _LT_TAGVAR(ld_shlibs, $1)=no\n        ;;\n    esac\n\n    AC_MSG_RESULT([$_LT_TAGVAR(ld_shlibs, $1)])\n    test \"$_LT_TAGVAR(ld_shlibs, $1)\" = no && can_build_shared=no\n\n    _LT_TAGVAR(GCC, $1)=\"$GXX\"\n    _LT_TAGVAR(LD, $1)=\"$LD\"\n\n    ## CAVEAT EMPTOR:\n    ## There is no encapsulation within the following macros, do not change\n    ## the running order or otherwise move them around unless you know exactly\n    ## what you are doing...\n    _LT_SYS_HIDDEN_LIBDEPS($1)\n    _LT_COMPILER_PIC($1)\n    _LT_COMPILER_C_O($1)\n    _LT_COMPILER_FILE_LOCKS($1)\n    _LT_LINKER_SHLIBS($1)\n    _LT_SYS_DYNAMIC_LINKER($1)\n    _LT_LINKER_HARDCODE_LIBPATH($1)\n\n    _LT_CONFIG($1)\n  fi # test -n \"$compiler\"\n\n  CC=$lt_save_CC\n  CFLAGS=$lt_save_CFLAGS\n  LDCXX=$LD\n  LD=$lt_save_LD\n  GCC=$lt_save_GCC\n  with_gnu_ld=$lt_save_with_gnu_ld\n  lt_cv_path_LDCXX=$lt_cv_path_LD\n  lt_cv_path_LD=$lt_save_path_LD\n  lt_cv_prog_gnu_ldcxx=$lt_cv_prog_gnu_ld\n  lt_cv_prog_gnu_ld=$lt_save_with_gnu_ld\nfi # test \"$_lt_caught_CXX_error\" != yes\n\nAC_LANG_POP\n])# _LT_LANG_CXX_CONFIG\n\n\n# _LT_FUNC_STRIPNAME_CNF\n# ----------------------\n# func_stripname_cnf prefix suffix name\n# strip PREFIX and SUFFIX off of NAME.\n# PREFIX and SUFFIX must not contain globbing or regex special\n# characters, hashes, percent signs, but SUFFIX may contain a leading\n# dot (in which case that matches only a dot).\n#\n# This function is identical to the (non-XSI) version of func_stripname,\n# except this one can be used by m4 code that may be executed by configure,\n# rather than the libtool script.\nm4_defun([_LT_FUNC_STRIPNAME_CNF],[dnl\nAC_REQUIRE([_LT_DECL_SED])\nAC_REQUIRE([_LT_PROG_ECHO_BACKSLASH])\nfunc_stripname_cnf ()\n{\n  case ${2} in\n  .*) func_stripname_result=`$ECHO \"${3}\" | $SED \"s%^${1}%%; s%\\\\\\\\${2}\\$%%\"`;;\n  *)  func_stripname_result=`$ECHO \"${3}\" | $SED \"s%^${1}%%; s%${2}\\$%%\"`;;\n  esac\n} # func_stripname_cnf\n])# _LT_FUNC_STRIPNAME_CNF\n\n# _LT_SYS_HIDDEN_LIBDEPS([TAGNAME])\n# ---------------------------------\n# Figure out \"hidden\" library dependencies from verbose\n# compiler output when linking a shared library.\n# Parse the compiler output and extract the necessary\n# objects, libraries and library flags.\nm4_defun([_LT_SYS_HIDDEN_LIBDEPS],\n[m4_require([_LT_FILEUTILS_DEFAULTS])dnl\nAC_REQUIRE([_LT_FUNC_STRIPNAME_CNF])dnl\n# Dependencies to place before and after the object being linked:\n_LT_TAGVAR(predep_objects, $1)=\n_LT_TAGVAR(postdep_objects, $1)=\n_LT_TAGVAR(predeps, $1)=\n_LT_TAGVAR(postdeps, $1)=\n_LT_TAGVAR(compiler_lib_search_path, $1)=\n\ndnl we can't use the lt_simple_compile_test_code here,\ndnl because it contains code intended for an executable,\ndnl not a library.  It's possible we should let each\ndnl tag define a new lt_????_link_test_code variable,\ndnl but it's only used here...\nm4_if([$1], [], [cat > conftest.$ac_ext <<_LT_EOF\nint a;\nvoid foo (void) { a = 0; }\n_LT_EOF\n], [$1], [CXX], [cat > conftest.$ac_ext <<_LT_EOF\nclass Foo\n{\npublic:\n  Foo (void) { a = 0; }\nprivate:\n  int a;\n};\n_LT_EOF\n], [$1], [F77], [cat > conftest.$ac_ext <<_LT_EOF\n      subroutine foo\n      implicit none\n      integer*4 a\n      a=0\n      return\n      end\n_LT_EOF\n], [$1], [FC], [cat > conftest.$ac_ext <<_LT_EOF\n      subroutine foo\n      implicit none\n      integer a\n      a=0\n      return\n      end\n_LT_EOF\n], [$1], [GCJ], [cat > conftest.$ac_ext <<_LT_EOF\npublic class foo {\n  private int a;\n  public void bar (void) {\n    a = 0;\n  }\n};\n_LT_EOF\n], [$1], [GO], [cat > conftest.$ac_ext <<_LT_EOF\npackage foo\nfunc foo() {\n}\n_LT_EOF\n])\n\n_lt_libdeps_save_CFLAGS=$CFLAGS\ncase \"$CC $CFLAGS \" in #(\n*\\ -flto*\\ *) CFLAGS=\"$CFLAGS -fno-lto\" ;;\n*\\ -fwhopr*\\ *) CFLAGS=\"$CFLAGS -fno-whopr\" ;;\n*\\ -fuse-linker-plugin*\\ *) CFLAGS=\"$CFLAGS -fno-use-linker-plugin\" ;;\nesac\n\ndnl Parse the compiler output and extract the necessary\ndnl objects, libraries and library flags.\nif AC_TRY_EVAL(ac_compile); then\n  # Parse the compiler output and extract the necessary\n  # objects, libraries and library flags.\n\n  # Sentinel used to keep track of whether or not we are before\n  # the conftest object file.\n  pre_test_object_deps_done=no\n\n  for p in `eval \"$output_verbose_link_cmd\"`; do\n    case ${prev}${p} in\n\n    -L* | -R* | -l*)\n       # Some compilers place space between \"-{L,R}\" and the path.\n       # Remove the space.\n       if test $p = \"-L\" ||\n          test $p = \"-R\"; then\n\t prev=$p\n\t continue\n       fi\n\n       # Expand the sysroot to ease extracting the directories later.\n       if test -z \"$prev\"; then\n         case $p in\n         -L*) func_stripname_cnf '-L' '' \"$p\"; prev=-L; p=$func_stripname_result ;;\n         -R*) func_stripname_cnf '-R' '' \"$p\"; prev=-R; p=$func_stripname_result ;;\n         -l*) func_stripname_cnf '-l' '' \"$p\"; prev=-l; p=$func_stripname_result ;;\n         esac\n       fi\n       case $p in\n       =*) func_stripname_cnf '=' '' \"$p\"; p=$lt_sysroot$func_stripname_result ;;\n       esac\n       if test \"$pre_test_object_deps_done\" = no; then\n\t case ${prev} in\n\t -L | -R)\n\t   # Internal compiler library paths should come after those\n\t   # provided the user.  The postdeps already come after the\n\t   # user supplied libs so there is no need to process them.\n\t   if test -z \"$_LT_TAGVAR(compiler_lib_search_path, $1)\"; then\n\t     _LT_TAGVAR(compiler_lib_search_path, $1)=\"${prev}${p}\"\n\t   else\n\t     _LT_TAGVAR(compiler_lib_search_path, $1)=\"${_LT_TAGVAR(compiler_lib_search_path, $1)} ${prev}${p}\"\n\t   fi\n\t   ;;\n\t # The \"-l\" case would never come before the object being\n\t # linked, so don't bother handling this case.\n\t esac\n       else\n\t if test -z \"$_LT_TAGVAR(postdeps, $1)\"; then\n\t   _LT_TAGVAR(postdeps, $1)=\"${prev}${p}\"\n\t else\n\t   _LT_TAGVAR(postdeps, $1)=\"${_LT_TAGVAR(postdeps, $1)} ${prev}${p}\"\n\t fi\n       fi\n       prev=\n       ;;\n\n    *.lto.$objext) ;; # Ignore GCC LTO objects\n    *.$objext)\n       # This assumes that the test object file only shows up\n       # once in the compiler output.\n       if test \"$p\" = \"conftest.$objext\"; then\n\t pre_test_object_deps_done=yes\n\t continue\n       fi\n\n       if test \"$pre_test_object_deps_done\" = no; then\n\t if test -z \"$_LT_TAGVAR(predep_objects, $1)\"; then\n\t   _LT_TAGVAR(predep_objects, $1)=\"$p\"\n\t else\n\t   _LT_TAGVAR(predep_objects, $1)=\"$_LT_TAGVAR(predep_objects, $1) $p\"\n\t fi\n       else\n\t if test -z \"$_LT_TAGVAR(postdep_objects, $1)\"; then\n\t   _LT_TAGVAR(postdep_objects, $1)=\"$p\"\n\t else\n\t   _LT_TAGVAR(postdep_objects, $1)=\"$_LT_TAGVAR(postdep_objects, $1) $p\"\n\t fi\n       fi\n       ;;\n\n    *) ;; # Ignore the rest.\n\n    esac\n  done\n\n  # Clean up.\n  rm -f a.out a.exe\nelse\n  echo \"libtool.m4: error: problem compiling $1 test program\"\nfi\n\n$RM -f confest.$objext\nCFLAGS=$_lt_libdeps_save_CFLAGS\n\n# PORTME: override above test on systems where it is broken\nm4_if([$1], [CXX],\n[case $host_os in\ninterix[[3-9]]*)\n  # Interix 3.5 installs completely hosed .la files for C++, so rather than\n  # hack all around it, let's just trust \"g++\" to DTRT.\n  _LT_TAGVAR(predep_objects,$1)=\n  _LT_TAGVAR(postdep_objects,$1)=\n  _LT_TAGVAR(postdeps,$1)=\n  ;;\n\nlinux*)\n  case `$CC -V 2>&1 | sed 5q` in\n  *Sun\\ C*)\n    # Sun C++ 5.9\n\n    # The more standards-conforming stlport4 library is\n    # incompatible with the Cstd library. Avoid specifying\n    # it if it's in CXXFLAGS. Ignore libCrun as\n    # -library=stlport4 depends on it.\n    case \" $CXX $CXXFLAGS \" in\n    *\" -library=stlport4 \"*)\n      solaris_use_stlport4=yes\n      ;;\n    esac\n\n    if test \"$solaris_use_stlport4\" != yes; then\n      _LT_TAGVAR(postdeps,$1)='-library=Cstd -library=Crun'\n    fi\n    ;;\n  esac\n  ;;\n\nsolaris*)\n  case $cc_basename in\n  CC* | sunCC*)\n    # The more standards-conforming stlport4 library is\n    # incompatible with the Cstd library. Avoid specifying\n    # it if it's in CXXFLAGS. Ignore libCrun as\n    # -library=stlport4 depends on it.\n    case \" $CXX $CXXFLAGS \" in\n    *\" -library=stlport4 \"*)\n      solaris_use_stlport4=yes\n      ;;\n    esac\n\n    # Adding this requires a known-good setup of shared libraries for\n    # Sun compiler versions before 5.6, else PIC objects from an old\n    # archive will be linked into the output, leading to subtle bugs.\n    if test \"$solaris_use_stlport4\" != yes; then\n      _LT_TAGVAR(postdeps,$1)='-library=Cstd -library=Crun'\n    fi\n    ;;\n  esac\n  ;;\nesac\n])\n\ncase \" $_LT_TAGVAR(postdeps, $1) \" in\n*\" -lc \"*) _LT_TAGVAR(archive_cmds_need_lc, $1)=no ;;\nesac\n _LT_TAGVAR(compiler_lib_search_dirs, $1)=\nif test -n \"${_LT_TAGVAR(compiler_lib_search_path, $1)}\"; then\n _LT_TAGVAR(compiler_lib_search_dirs, $1)=`echo \" ${_LT_TAGVAR(compiler_lib_search_path, $1)}\" | ${SED} -e 's! -L! !g' -e 's!^ !!'`\nfi\n_LT_TAGDECL([], [compiler_lib_search_dirs], [1],\n    [The directories searched by this compiler when creating a shared library])\n_LT_TAGDECL([], [predep_objects], [1],\n    [Dependencies to place before and after the objects being linked to\n    create a shared library])\n_LT_TAGDECL([], [postdep_objects], [1])\n_LT_TAGDECL([], [predeps], [1])\n_LT_TAGDECL([], [postdeps], [1])\n_LT_TAGDECL([], [compiler_lib_search_path], [1],\n    [The library search path used internally by the compiler when linking\n    a shared library])\n])# _LT_SYS_HIDDEN_LIBDEPS\n\n\n# _LT_LANG_F77_CONFIG([TAG])\n# --------------------------\n# Ensure that the configuration variables for a Fortran 77 compiler are\n# suitably defined.  These variables are subsequently used by _LT_CONFIG\n# to write the compiler configuration to `libtool'.\nm4_defun([_LT_LANG_F77_CONFIG],\n[AC_LANG_PUSH(Fortran 77)\nif test -z \"$F77\" || test \"X$F77\" = \"Xno\"; then\n  _lt_disable_F77=yes\nfi\n\n_LT_TAGVAR(archive_cmds_need_lc, $1)=no\n_LT_TAGVAR(allow_undefined_flag, $1)=\n_LT_TAGVAR(always_export_symbols, $1)=no\n_LT_TAGVAR(archive_expsym_cmds, $1)=\n_LT_TAGVAR(export_dynamic_flag_spec, $1)=\n_LT_TAGVAR(hardcode_direct, $1)=no\n_LT_TAGVAR(hardcode_direct_absolute, $1)=no\n_LT_TAGVAR(hardcode_libdir_flag_spec, $1)=\n_LT_TAGVAR(hardcode_libdir_separator, $1)=\n_LT_TAGVAR(hardcode_minus_L, $1)=no\n_LT_TAGVAR(hardcode_automatic, $1)=no\n_LT_TAGVAR(inherit_rpath, $1)=no\n_LT_TAGVAR(module_cmds, $1)=\n_LT_TAGVAR(module_expsym_cmds, $1)=\n_LT_TAGVAR(link_all_deplibs, $1)=unknown\n_LT_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds\n_LT_TAGVAR(reload_flag, $1)=$reload_flag\n_LT_TAGVAR(reload_cmds, $1)=$reload_cmds\n_LT_TAGVAR(no_undefined_flag, $1)=\n_LT_TAGVAR(whole_archive_flag_spec, $1)=\n_LT_TAGVAR(enable_shared_with_static_runtimes, $1)=no\n\n# Source file extension for f77 test sources.\nac_ext=f\n\n# Object file extension for compiled f77 test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# No sense in running all these tests if we already determined that\n# the F77 compiler isn't working.  Some variables (like enable_shared)\n# are currently assumed to apply to all compilers on this platform,\n# and will be corrupted by setting them based on a non-working compiler.\nif test \"$_lt_disable_F77\" != yes; then\n  # Code to be used in simple compile tests\n  lt_simple_compile_test_code=\"\\\n      subroutine t\n      return\n      end\n\"\n\n  # Code to be used in simple link tests\n  lt_simple_link_test_code=\"\\\n      program t\n      end\n\"\n\n  # ltmain only uses $CC for tagged configurations so make sure $CC is set.\n  _LT_TAG_COMPILER\n\n  # save warnings/boilerplate of simple test code\n  _LT_COMPILER_BOILERPLATE\n  _LT_LINKER_BOILERPLATE\n\n  # Allow CC to be a program name with arguments.\n  lt_save_CC=\"$CC\"\n  lt_save_GCC=$GCC\n  lt_save_CFLAGS=$CFLAGS\n  CC=${F77-\"f77\"}\n  CFLAGS=$FFLAGS\n  compiler=$CC\n  _LT_TAGVAR(compiler, $1)=$CC\n  _LT_CC_BASENAME([$compiler])\n  GCC=$G77\n  if test -n \"$compiler\"; then\n    AC_MSG_CHECKING([if libtool supports shared libraries])\n    AC_MSG_RESULT([$can_build_shared])\n\n    AC_MSG_CHECKING([whether to build shared libraries])\n    test \"$can_build_shared\" = \"no\" && enable_shared=no\n\n    # On AIX, shared libraries and static libraries use the same namespace, and\n    # are all built from PIC.\n    case $host_os in\n      aix3*)\n        test \"$enable_shared\" = yes && enable_static=no\n        if test -n \"$RANLIB\"; then\n          archive_cmds=\"$archive_cmds~\\$RANLIB \\$lib\"\n          postinstall_cmds='$RANLIB $lib'\n        fi\n        ;;\n      aix[[4-9]]*)\n\tif test \"$host_cpu\" != ia64 && test \"$aix_use_runtimelinking\" = no ; then\n\t  test \"$enable_shared\" = yes && enable_static=no\n\tfi\n        ;;\n    esac\n    AC_MSG_RESULT([$enable_shared])\n\n    AC_MSG_CHECKING([whether to build static libraries])\n    # Make sure either enable_shared or enable_static is yes.\n    test \"$enable_shared\" = yes || enable_static=yes\n    AC_MSG_RESULT([$enable_static])\n\n    _LT_TAGVAR(GCC, $1)=\"$G77\"\n    _LT_TAGVAR(LD, $1)=\"$LD\"\n\n    ## CAVEAT EMPTOR:\n    ## There is no encapsulation within the following macros, do not change\n    ## the running order or otherwise move them around unless you know exactly\n    ## what you are doing...\n    _LT_COMPILER_PIC($1)\n    _LT_COMPILER_C_O($1)\n    _LT_COMPILER_FILE_LOCKS($1)\n    _LT_LINKER_SHLIBS($1)\n    _LT_SYS_DYNAMIC_LINKER($1)\n    _LT_LINKER_HARDCODE_LIBPATH($1)\n\n    _LT_CONFIG($1)\n  fi # test -n \"$compiler\"\n\n  GCC=$lt_save_GCC\n  CC=\"$lt_save_CC\"\n  CFLAGS=\"$lt_save_CFLAGS\"\nfi # test \"$_lt_disable_F77\" != yes\n\nAC_LANG_POP\n])# _LT_LANG_F77_CONFIG\n\n\n# _LT_LANG_FC_CONFIG([TAG])\n# -------------------------\n# Ensure that the configuration variables for a Fortran compiler are\n# suitably defined.  These variables are subsequently used by _LT_CONFIG\n# to write the compiler configuration to `libtool'.\nm4_defun([_LT_LANG_FC_CONFIG],\n[AC_LANG_PUSH(Fortran)\n\nif test -z \"$FC\" || test \"X$FC\" = \"Xno\"; then\n  _lt_disable_FC=yes\nfi\n\n_LT_TAGVAR(archive_cmds_need_lc, $1)=no\n_LT_TAGVAR(allow_undefined_flag, $1)=\n_LT_TAGVAR(always_export_symbols, $1)=no\n_LT_TAGVAR(archive_expsym_cmds, $1)=\n_LT_TAGVAR(export_dynamic_flag_spec, $1)=\n_LT_TAGVAR(hardcode_direct, $1)=no\n_LT_TAGVAR(hardcode_direct_absolute, $1)=no\n_LT_TAGVAR(hardcode_libdir_flag_spec, $1)=\n_LT_TAGVAR(hardcode_libdir_separator, $1)=\n_LT_TAGVAR(hardcode_minus_L, $1)=no\n_LT_TAGVAR(hardcode_automatic, $1)=no\n_LT_TAGVAR(inherit_rpath, $1)=no\n_LT_TAGVAR(module_cmds, $1)=\n_LT_TAGVAR(module_expsym_cmds, $1)=\n_LT_TAGVAR(link_all_deplibs, $1)=unknown\n_LT_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds\n_LT_TAGVAR(reload_flag, $1)=$reload_flag\n_LT_TAGVAR(reload_cmds, $1)=$reload_cmds\n_LT_TAGVAR(no_undefined_flag, $1)=\n_LT_TAGVAR(whole_archive_flag_spec, $1)=\n_LT_TAGVAR(enable_shared_with_static_runtimes, $1)=no\n\n# Source file extension for fc test sources.\nac_ext=${ac_fc_srcext-f}\n\n# Object file extension for compiled fc test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# No sense in running all these tests if we already determined that\n# the FC compiler isn't working.  Some variables (like enable_shared)\n# are currently assumed to apply to all compilers on this platform,\n# and will be corrupted by setting them based on a non-working compiler.\nif test \"$_lt_disable_FC\" != yes; then\n  # Code to be used in simple compile tests\n  lt_simple_compile_test_code=\"\\\n      subroutine t\n      return\n      end\n\"\n\n  # Code to be used in simple link tests\n  lt_simple_link_test_code=\"\\\n      program t\n      end\n\"\n\n  # ltmain only uses $CC for tagged configurations so make sure $CC is set.\n  _LT_TAG_COMPILER\n\n  # save warnings/boilerplate of simple test code\n  _LT_COMPILER_BOILERPLATE\n  _LT_LINKER_BOILERPLATE\n\n  # Allow CC to be a program name with arguments.\n  lt_save_CC=\"$CC\"\n  lt_save_GCC=$GCC\n  lt_save_CFLAGS=$CFLAGS\n  CC=${FC-\"f95\"}\n  CFLAGS=$FCFLAGS\n  compiler=$CC\n  GCC=$ac_cv_fc_compiler_gnu\n\n  _LT_TAGVAR(compiler, $1)=$CC\n  _LT_CC_BASENAME([$compiler])\n\n  if test -n \"$compiler\"; then\n    AC_MSG_CHECKING([if libtool supports shared libraries])\n    AC_MSG_RESULT([$can_build_shared])\n\n    AC_MSG_CHECKING([whether to build shared libraries])\n    test \"$can_build_shared\" = \"no\" && enable_shared=no\n\n    # On AIX, shared libraries and static libraries use the same namespace, and\n    # are all built from PIC.\n    case $host_os in\n      aix3*)\n        test \"$enable_shared\" = yes && enable_static=no\n        if test -n \"$RANLIB\"; then\n          archive_cmds=\"$archive_cmds~\\$RANLIB \\$lib\"\n          postinstall_cmds='$RANLIB $lib'\n        fi\n        ;;\n      aix[[4-9]]*)\n\tif test \"$host_cpu\" != ia64 && test \"$aix_use_runtimelinking\" = no ; then\n\t  test \"$enable_shared\" = yes && enable_static=no\n\tfi\n        ;;\n    esac\n    AC_MSG_RESULT([$enable_shared])\n\n    AC_MSG_CHECKING([whether to build static libraries])\n    # Make sure either enable_shared or enable_static is yes.\n    test \"$enable_shared\" = yes || enable_static=yes\n    AC_MSG_RESULT([$enable_static])\n\n    _LT_TAGVAR(GCC, $1)=\"$ac_cv_fc_compiler_gnu\"\n    _LT_TAGVAR(LD, $1)=\"$LD\"\n\n    ## CAVEAT EMPTOR:\n    ## There is no encapsulation within the following macros, do not change\n    ## the running order or otherwise move them around unless you know exactly\n    ## what you are doing...\n    _LT_SYS_HIDDEN_LIBDEPS($1)\n    _LT_COMPILER_PIC($1)\n    _LT_COMPILER_C_O($1)\n    _LT_COMPILER_FILE_LOCKS($1)\n    _LT_LINKER_SHLIBS($1)\n    _LT_SYS_DYNAMIC_LINKER($1)\n    _LT_LINKER_HARDCODE_LIBPATH($1)\n\n    _LT_CONFIG($1)\n  fi # test -n \"$compiler\"\n\n  GCC=$lt_save_GCC\n  CC=$lt_save_CC\n  CFLAGS=$lt_save_CFLAGS\nfi # test \"$_lt_disable_FC\" != yes\n\nAC_LANG_POP\n])# _LT_LANG_FC_CONFIG\n\n\n# _LT_LANG_GCJ_CONFIG([TAG])\n# --------------------------\n# Ensure that the configuration variables for the GNU Java Compiler compiler\n# are suitably defined.  These variables are subsequently used by _LT_CONFIG\n# to write the compiler configuration to `libtool'.\nm4_defun([_LT_LANG_GCJ_CONFIG],\n[AC_REQUIRE([LT_PROG_GCJ])dnl\nAC_LANG_SAVE\n\n# Source file extension for Java test sources.\nac_ext=java\n\n# Object file extension for compiled Java test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# Code to be used in simple compile tests\nlt_simple_compile_test_code=\"class foo {}\"\n\n# Code to be used in simple link tests\nlt_simple_link_test_code='public class conftest { public static void main(String[[]] argv) {}; }'\n\n# ltmain only uses $CC for tagged configurations so make sure $CC is set.\n_LT_TAG_COMPILER\n\n# save warnings/boilerplate of simple test code\n_LT_COMPILER_BOILERPLATE\n_LT_LINKER_BOILERPLATE\n\n# Allow CC to be a program name with arguments.\nlt_save_CC=$CC\nlt_save_CFLAGS=$CFLAGS\nlt_save_GCC=$GCC\nGCC=yes\nCC=${GCJ-\"gcj\"}\nCFLAGS=$GCJFLAGS\ncompiler=$CC\n_LT_TAGVAR(compiler, $1)=$CC\n_LT_TAGVAR(LD, $1)=\"$LD\"\n_LT_CC_BASENAME([$compiler])\n\n# GCJ did not exist at the time GCC didn't implicitly link libc in.\n_LT_TAGVAR(archive_cmds_need_lc, $1)=no\n\n_LT_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds\n_LT_TAGVAR(reload_flag, $1)=$reload_flag\n_LT_TAGVAR(reload_cmds, $1)=$reload_cmds\n\nif test -n \"$compiler\"; then\n  _LT_COMPILER_NO_RTTI($1)\n  _LT_COMPILER_PIC($1)\n  _LT_COMPILER_C_O($1)\n  _LT_COMPILER_FILE_LOCKS($1)\n  _LT_LINKER_SHLIBS($1)\n  _LT_LINKER_HARDCODE_LIBPATH($1)\n\n  _LT_CONFIG($1)\nfi\n\nAC_LANG_RESTORE\n\nGCC=$lt_save_GCC\nCC=$lt_save_CC\nCFLAGS=$lt_save_CFLAGS\n])# _LT_LANG_GCJ_CONFIG\n\n\n# _LT_LANG_GO_CONFIG([TAG])\n# --------------------------\n# Ensure that the configuration variables for the GNU Go compiler\n# are suitably defined.  These variables are subsequently used by _LT_CONFIG\n# to write the compiler configuration to `libtool'.\nm4_defun([_LT_LANG_GO_CONFIG],\n[AC_REQUIRE([LT_PROG_GO])dnl\nAC_LANG_SAVE\n\n# Source file extension for Go test sources.\nac_ext=go\n\n# Object file extension for compiled Go test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# Code to be used in simple compile tests\nlt_simple_compile_test_code=\"package main; func main() { }\"\n\n# Code to be used in simple link tests\nlt_simple_link_test_code='package main; func main() { }'\n\n# ltmain only uses $CC for tagged configurations so make sure $CC is set.\n_LT_TAG_COMPILER\n\n# save warnings/boilerplate of simple test code\n_LT_COMPILER_BOILERPLATE\n_LT_LINKER_BOILERPLATE\n\n# Allow CC to be a program name with arguments.\nlt_save_CC=$CC\nlt_save_CFLAGS=$CFLAGS\nlt_save_GCC=$GCC\nGCC=yes\nCC=${GOC-\"gccgo\"}\nCFLAGS=$GOFLAGS\ncompiler=$CC\n_LT_TAGVAR(compiler, $1)=$CC\n_LT_TAGVAR(LD, $1)=\"$LD\"\n_LT_CC_BASENAME([$compiler])\n\n# Go did not exist at the time GCC didn't implicitly link libc in.\n_LT_TAGVAR(archive_cmds_need_lc, $1)=no\n\n_LT_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds\n_LT_TAGVAR(reload_flag, $1)=$reload_flag\n_LT_TAGVAR(reload_cmds, $1)=$reload_cmds\n\nif test -n \"$compiler\"; then\n  _LT_COMPILER_NO_RTTI($1)\n  _LT_COMPILER_PIC($1)\n  _LT_COMPILER_C_O($1)\n  _LT_COMPILER_FILE_LOCKS($1)\n  _LT_LINKER_SHLIBS($1)\n  _LT_LINKER_HARDCODE_LIBPATH($1)\n\n  _LT_CONFIG($1)\nfi\n\nAC_LANG_RESTORE\n\nGCC=$lt_save_GCC\nCC=$lt_save_CC\nCFLAGS=$lt_save_CFLAGS\n])# _LT_LANG_GO_CONFIG\n\n\n# _LT_LANG_RC_CONFIG([TAG])\n# -------------------------\n# Ensure that the configuration variables for the Windows resource compiler\n# are suitably defined.  These variables are subsequently used by _LT_CONFIG\n# to write the compiler configuration to `libtool'.\nm4_defun([_LT_LANG_RC_CONFIG],\n[AC_REQUIRE([LT_PROG_RC])dnl\nAC_LANG_SAVE\n\n# Source file extension for RC test sources.\nac_ext=rc\n\n# Object file extension for compiled RC test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# Code to be used in simple compile tests\nlt_simple_compile_test_code='sample MENU { MENUITEM \"&Soup\", 100, CHECKED }'\n\n# Code to be used in simple link tests\nlt_simple_link_test_code=\"$lt_simple_compile_test_code\"\n\n# ltmain only uses $CC for tagged configurations so make sure $CC is set.\n_LT_TAG_COMPILER\n\n# save warnings/boilerplate of simple test code\n_LT_COMPILER_BOILERPLATE\n_LT_LINKER_BOILERPLATE\n\n# Allow CC to be a program name with arguments.\nlt_save_CC=\"$CC\"\nlt_save_CFLAGS=$CFLAGS\nlt_save_GCC=$GCC\nGCC=\nCC=${RC-\"windres\"}\nCFLAGS=\ncompiler=$CC\n_LT_TAGVAR(compiler, $1)=$CC\n_LT_CC_BASENAME([$compiler])\n_LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)=yes\n\nif test -n \"$compiler\"; then\n  :\n  _LT_CONFIG($1)\nfi\n\nGCC=$lt_save_GCC\nAC_LANG_RESTORE\nCC=$lt_save_CC\nCFLAGS=$lt_save_CFLAGS\n])# _LT_LANG_RC_CONFIG\n\n\n# LT_PROG_GCJ\n# -----------\nAC_DEFUN([LT_PROG_GCJ],\n[m4_ifdef([AC_PROG_GCJ], [AC_PROG_GCJ],\n  [m4_ifdef([A][M_PROG_GCJ], [A][M_PROG_GCJ],\n    [AC_CHECK_TOOL(GCJ, gcj,)\n      test \"x${GCJFLAGS+set}\" = xset || GCJFLAGS=\"-g -O2\"\n      AC_SUBST(GCJFLAGS)])])[]dnl\n])\n\n# Old name:\nAU_ALIAS([LT_AC_PROG_GCJ], [LT_PROG_GCJ])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([LT_AC_PROG_GCJ], [])\n\n\n# LT_PROG_GO\n# ----------\nAC_DEFUN([LT_PROG_GO],\n[AC_CHECK_TOOL(GOC, gccgo,)\n])\n\n\n# LT_PROG_RC\n# ----------\nAC_DEFUN([LT_PROG_RC],\n[AC_CHECK_TOOL(RC, windres,)\n])\n\n# Old name:\nAU_ALIAS([LT_AC_PROG_RC], [LT_PROG_RC])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([LT_AC_PROG_RC], [])\n\n\n# _LT_DECL_EGREP\n# --------------\n# If we don't have a new enough Autoconf to choose the best grep\n# available, choose the one first in the user's PATH.\nm4_defun([_LT_DECL_EGREP],\n[AC_REQUIRE([AC_PROG_EGREP])dnl\nAC_REQUIRE([AC_PROG_FGREP])dnl\ntest -z \"$GREP\" && GREP=grep\n_LT_DECL([], [GREP], [1], [A grep program that handles long lines])\n_LT_DECL([], [EGREP], [1], [An ERE matcher])\n_LT_DECL([], [FGREP], [1], [A literal string matcher])\ndnl Non-bleeding-edge autoconf doesn't subst GREP, so do it here too\nAC_SUBST([GREP])\n])\n\n\n# _LT_DECL_OBJDUMP\n# --------------\n# If we don't have a new enough Autoconf to choose the best objdump\n# available, choose the one first in the user's PATH.\nm4_defun([_LT_DECL_OBJDUMP],\n[AC_CHECK_TOOL(OBJDUMP, objdump, false)\ntest -z \"$OBJDUMP\" && OBJDUMP=objdump\n_LT_DECL([], [OBJDUMP], [1], [An object symbol dumper])\nAC_SUBST([OBJDUMP])\n])\n\n# _LT_DECL_DLLTOOL\n# ----------------\n# Ensure DLLTOOL variable is set.\nm4_defun([_LT_DECL_DLLTOOL],\n[AC_CHECK_TOOL(DLLTOOL, dlltool, false)\ntest -z \"$DLLTOOL\" && DLLTOOL=dlltool\n_LT_DECL([], [DLLTOOL], [1], [DLL creation program])\nAC_SUBST([DLLTOOL])\n])\n\n# _LT_DECL_SED\n# ------------\n# Check for a fully-functional sed program, that truncates\n# as few characters as possible.  Prefer GNU sed if found.\nm4_defun([_LT_DECL_SED],\n[AC_PROG_SED\ntest -z \"$SED\" && SED=sed\nXsed=\"$SED -e 1s/^X//\"\n_LT_DECL([], [SED], [1], [A sed program that does not truncate output])\n_LT_DECL([], [Xsed], [\"\\$SED -e 1s/^X//\"],\n    [Sed that helps us avoid accidentally triggering echo(1) options like -n])\n])# _LT_DECL_SED\n\nm4_ifndef([AC_PROG_SED], [\n# NOTE: This macro has been submitted for inclusion into   #\n#  GNU Autoconf as AC_PROG_SED.  When it is available in   #\n#  a released version of Autoconf we should remove this    #\n#  macro and use it instead.                               #\n\nm4_defun([AC_PROG_SED],\n[AC_MSG_CHECKING([for a sed that does not truncate output])\nAC_CACHE_VAL(lt_cv_path_SED,\n[# Loop through the user's path and test for sed and gsed.\n# Then use that list of sed's as ones to test for truncation.\nas_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  test -z \"$as_dir\" && as_dir=.\n  for lt_ac_prog in sed gsed; do\n    for ac_exec_ext in '' $ac_executable_extensions; do\n      if $as_executable_p \"$as_dir/$lt_ac_prog$ac_exec_ext\"; then\n        lt_ac_sed_list=\"$lt_ac_sed_list $as_dir/$lt_ac_prog$ac_exec_ext\"\n      fi\n    done\n  done\ndone\nIFS=$as_save_IFS\nlt_ac_max=0\nlt_ac_count=0\n# Add /usr/xpg4/bin/sed as it is typically found on Solaris\n# along with /bin/sed that truncates output.\nfor lt_ac_sed in $lt_ac_sed_list /usr/xpg4/bin/sed; do\n  test ! -f $lt_ac_sed && continue\n  cat /dev/null > conftest.in\n  lt_ac_count=0\n  echo $ECHO_N \"0123456789$ECHO_C\" >conftest.in\n  # Check for GNU sed and select it if it is found.\n  if \"$lt_ac_sed\" --version 2>&1 < /dev/null | grep 'GNU' > /dev/null; then\n    lt_cv_path_SED=$lt_ac_sed\n    break\n  fi\n  while true; do\n    cat conftest.in conftest.in >conftest.tmp\n    mv conftest.tmp conftest.in\n    cp conftest.in conftest.nl\n    echo >>conftest.nl\n    $lt_ac_sed -e 's/a$//' < conftest.nl >conftest.out || break\n    cmp -s conftest.out conftest.nl || break\n    # 10000 chars as input seems more than enough\n    test $lt_ac_count -gt 10 && break\n    lt_ac_count=`expr $lt_ac_count + 1`\n    if test $lt_ac_count -gt $lt_ac_max; then\n      lt_ac_max=$lt_ac_count\n      lt_cv_path_SED=$lt_ac_sed\n    fi\n  done\ndone\n])\nSED=$lt_cv_path_SED\nAC_SUBST([SED])\nAC_MSG_RESULT([$SED])\n])#AC_PROG_SED\n])#m4_ifndef\n\n# Old name:\nAU_ALIAS([LT_AC_PROG_SED], [AC_PROG_SED])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([LT_AC_PROG_SED], [])\n\n\n# _LT_CHECK_SHELL_FEATURES\n# ------------------------\n# Find out whether the shell is Bourne or XSI compatible,\n# or has some other useful features.\nm4_defun([_LT_CHECK_SHELL_FEATURES],\n[AC_MSG_CHECKING([whether the shell understands some XSI constructs])\n# Try some XSI features\nxsi_shell=no\n( _lt_dummy=\"a/b/c\"\n  test \"${_lt_dummy##*/},${_lt_dummy%/*},${_lt_dummy#??}\"${_lt_dummy%\"$_lt_dummy\"}, \\\n      = c,a/b,b/c, \\\n    && eval 'test $(( 1 + 1 )) -eq 2 \\\n    && test \"${#_lt_dummy}\" -eq 5' ) >/dev/null 2>&1 \\\n  && xsi_shell=yes\nAC_MSG_RESULT([$xsi_shell])\n_LT_CONFIG_LIBTOOL_INIT([xsi_shell='$xsi_shell'])\n\nAC_MSG_CHECKING([whether the shell understands \"+=\"])\nlt_shell_append=no\n( foo=bar; set foo baz; eval \"$[1]+=\\$[2]\" && test \"$foo\" = barbaz ) \\\n    >/dev/null 2>&1 \\\n  && lt_shell_append=yes\nAC_MSG_RESULT([$lt_shell_append])\n_LT_CONFIG_LIBTOOL_INIT([lt_shell_append='$lt_shell_append'])\n\nif ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then\n  lt_unset=unset\nelse\n  lt_unset=false\nfi\n_LT_DECL([], [lt_unset], [0], [whether the shell understands \"unset\"])dnl\n\n# test EBCDIC or ASCII\ncase `echo X|tr X '\\101'` in\n A) # ASCII based system\n    # \\n is not interpreted correctly by Solaris 8 /usr/ucb/tr\n  lt_SP2NL='tr \\040 \\012'\n  lt_NL2SP='tr \\015\\012 \\040\\040'\n  ;;\n *) # EBCDIC based system\n  lt_SP2NL='tr \\100 \\n'\n  lt_NL2SP='tr \\r\\n \\100\\100'\n  ;;\nesac\n_LT_DECL([SP2NL], [lt_SP2NL], [1], [turn spaces into newlines])dnl\n_LT_DECL([NL2SP], [lt_NL2SP], [1], [turn newlines into spaces])dnl\n])# _LT_CHECK_SHELL_FEATURES\n\n\n# _LT_PROG_FUNCTION_REPLACE (FUNCNAME, REPLACEMENT-BODY)\n# ------------------------------------------------------\n# In `$cfgfile', look for function FUNCNAME delimited by `^FUNCNAME ()$' and\n# '^} FUNCNAME ', and replace its body with REPLACEMENT-BODY.\nm4_defun([_LT_PROG_FUNCTION_REPLACE],\n[dnl {\nsed -e '/^$1 ()$/,/^} # $1 /c\\\n$1 ()\\\n{\\\nm4_bpatsubsts([$2], [$], [\\\\], [^\\([\t ]\\)], [\\\\\\1])\n} # Extended-shell $1 implementation' \"$cfgfile\" > $cfgfile.tmp \\\n  && mv -f \"$cfgfile.tmp\" \"$cfgfile\" \\\n    || (rm -f \"$cfgfile\" && cp \"$cfgfile.tmp\" \"$cfgfile\" && rm -f \"$cfgfile.tmp\")\ntest 0 -eq $? || _lt_function_replace_fail=:\n])\n\n\n# _LT_PROG_REPLACE_SHELLFNS\n# -------------------------\n# Replace existing portable implementations of several shell functions with\n# equivalent extended shell implementations where those features are available..\nm4_defun([_LT_PROG_REPLACE_SHELLFNS],\n[if test x\"$xsi_shell\" = xyes; then\n  _LT_PROG_FUNCTION_REPLACE([func_dirname], [dnl\n    case ${1} in\n      */*) func_dirname_result=\"${1%/*}${2}\" ;;\n      *  ) func_dirname_result=\"${3}\" ;;\n    esac])\n\n  _LT_PROG_FUNCTION_REPLACE([func_basename], [dnl\n    func_basename_result=\"${1##*/}\"])\n\n  _LT_PROG_FUNCTION_REPLACE([func_dirname_and_basename], [dnl\n    case ${1} in\n      */*) func_dirname_result=\"${1%/*}${2}\" ;;\n      *  ) func_dirname_result=\"${3}\" ;;\n    esac\n    func_basename_result=\"${1##*/}\"])\n\n  _LT_PROG_FUNCTION_REPLACE([func_stripname], [dnl\n    # pdksh 5.2.14 does not do ${X%$Y} correctly if both X and Y are\n    # positional parameters, so assign one to ordinary parameter first.\n    func_stripname_result=${3}\n    func_stripname_result=${func_stripname_result#\"${1}\"}\n    func_stripname_result=${func_stripname_result%\"${2}\"}])\n\n  _LT_PROG_FUNCTION_REPLACE([func_split_long_opt], [dnl\n    func_split_long_opt_name=${1%%=*}\n    func_split_long_opt_arg=${1#*=}])\n\n  _LT_PROG_FUNCTION_REPLACE([func_split_short_opt], [dnl\n    func_split_short_opt_arg=${1#??}\n    func_split_short_opt_name=${1%\"$func_split_short_opt_arg\"}])\n\n  _LT_PROG_FUNCTION_REPLACE([func_lo2o], [dnl\n    case ${1} in\n      *.lo) func_lo2o_result=${1%.lo}.${objext} ;;\n      *)    func_lo2o_result=${1} ;;\n    esac])\n\n  _LT_PROG_FUNCTION_REPLACE([func_xform], [    func_xform_result=${1%.*}.lo])\n\n  _LT_PROG_FUNCTION_REPLACE([func_arith], [    func_arith_result=$(( $[*] ))])\n\n  _LT_PROG_FUNCTION_REPLACE([func_len], [    func_len_result=${#1}])\nfi\n\nif test x\"$lt_shell_append\" = xyes; then\n  _LT_PROG_FUNCTION_REPLACE([func_append], [    eval \"${1}+=\\\\${2}\"])\n\n  _LT_PROG_FUNCTION_REPLACE([func_append_quoted], [dnl\n    func_quote_for_eval \"${2}\"\ndnl m4 expansion turns \\\\\\\\ into \\\\, and then the shell eval turns that into \\\n    eval \"${1}+=\\\\\\\\ \\\\$func_quote_for_eval_result\"])\n\n  # Save a `func_append' function call where possible by direct use of '+='\n  sed -e 's%func_append \\([[a-zA-Z_]]\\{1,\\}\\) \"%\\1+=\"%g' $cfgfile > $cfgfile.tmp \\\n    && mv -f \"$cfgfile.tmp\" \"$cfgfile\" \\\n      || (rm -f \"$cfgfile\" && cp \"$cfgfile.tmp\" \"$cfgfile\" && rm -f \"$cfgfile.tmp\")\n  test 0 -eq $? || _lt_function_replace_fail=:\nelse\n  # Save a `func_append' function call even when '+=' is not available\n  sed -e 's%func_append \\([[a-zA-Z_]]\\{1,\\}\\) \"%\\1=\"$\\1%g' $cfgfile > $cfgfile.tmp \\\n    && mv -f \"$cfgfile.tmp\" \"$cfgfile\" \\\n      || (rm -f \"$cfgfile\" && cp \"$cfgfile.tmp\" \"$cfgfile\" && rm -f \"$cfgfile.tmp\")\n  test 0 -eq $? || _lt_function_replace_fail=:\nfi\n\nif test x\"$_lt_function_replace_fail\" = x\":\"; then\n  AC_MSG_WARN([Unable to substitute extended shell functions in $ofile])\nfi\n])\n\n# _LT_PATH_CONVERSION_FUNCTIONS\n# -----------------------------\n# Determine which file name conversion functions should be used by\n# func_to_host_file (and, implicitly, by func_to_host_path).  These are needed\n# for certain cross-compile configurations and native mingw.\nm4_defun([_LT_PATH_CONVERSION_FUNCTIONS],\n[AC_REQUIRE([AC_CANONICAL_HOST])dnl\nAC_REQUIRE([AC_CANONICAL_BUILD])dnl\nAC_MSG_CHECKING([how to convert $build file names to $host format])\nAC_CACHE_VAL(lt_cv_to_host_file_cmd,\n[case $host in\n  *-*-mingw* )\n    case $build in\n      *-*-mingw* ) # actually msys\n        lt_cv_to_host_file_cmd=func_convert_file_msys_to_w32\n        ;;\n      *-*-cygwin* )\n        lt_cv_to_host_file_cmd=func_convert_file_cygwin_to_w32\n        ;;\n      * ) # otherwise, assume *nix\n        lt_cv_to_host_file_cmd=func_convert_file_nix_to_w32\n        ;;\n    esac\n    ;;\n  *-*-cygwin* )\n    case $build in\n      *-*-mingw* ) # actually msys\n        lt_cv_to_host_file_cmd=func_convert_file_msys_to_cygwin\n        ;;\n      *-*-cygwin* )\n        lt_cv_to_host_file_cmd=func_convert_file_noop\n        ;;\n      * ) # otherwise, assume *nix\n        lt_cv_to_host_file_cmd=func_convert_file_nix_to_cygwin\n        ;;\n    esac\n    ;;\n  * ) # unhandled hosts (and \"normal\" native builds)\n    lt_cv_to_host_file_cmd=func_convert_file_noop\n    ;;\nesac\n])\nto_host_file_cmd=$lt_cv_to_host_file_cmd\nAC_MSG_RESULT([$lt_cv_to_host_file_cmd])\n_LT_DECL([to_host_file_cmd], [lt_cv_to_host_file_cmd],\n         [0], [convert $build file names to $host format])dnl\n\nAC_MSG_CHECKING([how to convert $build file names to toolchain format])\nAC_CACHE_VAL(lt_cv_to_tool_file_cmd,\n[#assume ordinary cross tools, or native build.\nlt_cv_to_tool_file_cmd=func_convert_file_noop\ncase $host in\n  *-*-mingw* )\n    case $build in\n      *-*-mingw* ) # actually msys\n        lt_cv_to_tool_file_cmd=func_convert_file_msys_to_w32\n        ;;\n    esac\n    ;;\nesac\n])\nto_tool_file_cmd=$lt_cv_to_tool_file_cmd\nAC_MSG_RESULT([$lt_cv_to_tool_file_cmd])\n_LT_DECL([to_tool_file_cmd], [lt_cv_to_tool_file_cmd],\n         [0], [convert $build files to toolchain format])dnl\n])# _LT_PATH_CONVERSION_FUNCTIONS\n\n# Helper functions for option handling.                    -*- Autoconf -*-\n#\n#   Copyright (C) 2004, 2005, 2007, 2008, 2009 Free Software Foundation,\n#   Inc.\n#   Written by Gary V. Vaughan, 2004\n#\n# This file is free software; the Free Software Foundation gives\n# unlimited permission to copy and/or distribute it, with or without\n# modifications, as long as this notice is preserved.\n\n# serial 7 ltoptions.m4\n\n# This is to help aclocal find these macros, as it can't see m4_define.\nAC_DEFUN([LTOPTIONS_VERSION], [m4_if([1])])\n\n\n# _LT_MANGLE_OPTION(MACRO-NAME, OPTION-NAME)\n# ------------------------------------------\nm4_define([_LT_MANGLE_OPTION],\n[[_LT_OPTION_]m4_bpatsubst($1__$2, [[^a-zA-Z0-9_]], [_])])\n\n\n# _LT_SET_OPTION(MACRO-NAME, OPTION-NAME)\n# ---------------------------------------\n# Set option OPTION-NAME for macro MACRO-NAME, and if there is a\n# matching handler defined, dispatch to it.  Other OPTION-NAMEs are\n# saved as a flag.\nm4_define([_LT_SET_OPTION],\n[m4_define(_LT_MANGLE_OPTION([$1], [$2]))dnl\nm4_ifdef(_LT_MANGLE_DEFUN([$1], [$2]),\n        _LT_MANGLE_DEFUN([$1], [$2]),\n    [m4_warning([Unknown $1 option `$2'])])[]dnl\n])\n\n\n# _LT_IF_OPTION(MACRO-NAME, OPTION-NAME, IF-SET, [IF-NOT-SET])\n# ------------------------------------------------------------\n# Execute IF-SET if OPTION is set, IF-NOT-SET otherwise.\nm4_define([_LT_IF_OPTION],\n[m4_ifdef(_LT_MANGLE_OPTION([$1], [$2]), [$3], [$4])])\n\n\n# _LT_UNLESS_OPTIONS(MACRO-NAME, OPTION-LIST, IF-NOT-SET)\n# -------------------------------------------------------\n# Execute IF-NOT-SET unless all options in OPTION-LIST for MACRO-NAME\n# are set.\nm4_define([_LT_UNLESS_OPTIONS],\n[m4_foreach([_LT_Option], m4_split(m4_normalize([$2])),\n\t    [m4_ifdef(_LT_MANGLE_OPTION([$1], _LT_Option),\n\t\t      [m4_define([$0_found])])])[]dnl\nm4_ifdef([$0_found], [m4_undefine([$0_found])], [$3\n])[]dnl\n])\n\n\n# _LT_SET_OPTIONS(MACRO-NAME, OPTION-LIST)\n# ----------------------------------------\n# OPTION-LIST is a space-separated list of Libtool options associated\n# with MACRO-NAME.  If any OPTION has a matching handler declared with\n# LT_OPTION_DEFINE, dispatch to that macro; otherwise complain about\n# the unknown option and exit.\nm4_defun([_LT_SET_OPTIONS],\n[# Set options\nm4_foreach([_LT_Option], m4_split(m4_normalize([$2])),\n    [_LT_SET_OPTION([$1], _LT_Option)])\n\nm4_if([$1],[LT_INIT],[\n  dnl\n  dnl Simply set some default values (i.e off) if boolean options were not\n  dnl specified:\n  _LT_UNLESS_OPTIONS([LT_INIT], [dlopen], [enable_dlopen=no\n  ])\n  _LT_UNLESS_OPTIONS([LT_INIT], [win32-dll], [enable_win32_dll=no\n  ])\n  dnl\n  dnl If no reference was made to various pairs of opposing options, then\n  dnl we run the default mode handler for the pair.  For example, if neither\n  dnl `shared' nor `disable-shared' was passed, we enable building of shared\n  dnl archives by default:\n  _LT_UNLESS_OPTIONS([LT_INIT], [shared disable-shared], [_LT_ENABLE_SHARED])\n  _LT_UNLESS_OPTIONS([LT_INIT], [static disable-static], [_LT_ENABLE_STATIC])\n  _LT_UNLESS_OPTIONS([LT_INIT], [pic-only no-pic], [_LT_WITH_PIC])\n  _LT_UNLESS_OPTIONS([LT_INIT], [fast-install disable-fast-install],\n  \t\t   [_LT_ENABLE_FAST_INSTALL])\n  ])\n])# _LT_SET_OPTIONS\n\n\n\n# _LT_MANGLE_DEFUN(MACRO-NAME, OPTION-NAME)\n# -----------------------------------------\nm4_define([_LT_MANGLE_DEFUN],\n[[_LT_OPTION_DEFUN_]m4_bpatsubst(m4_toupper([$1__$2]), [[^A-Z0-9_]], [_])])\n\n\n# LT_OPTION_DEFINE(MACRO-NAME, OPTION-NAME, CODE)\n# -----------------------------------------------\nm4_define([LT_OPTION_DEFINE],\n[m4_define(_LT_MANGLE_DEFUN([$1], [$2]), [$3])[]dnl\n])# LT_OPTION_DEFINE\n\n\n# dlopen\n# ------\nLT_OPTION_DEFINE([LT_INIT], [dlopen], [enable_dlopen=yes\n])\n\nAU_DEFUN([AC_LIBTOOL_DLOPEN],\n[_LT_SET_OPTION([LT_INIT], [dlopen])\nAC_DIAGNOSE([obsolete],\n[$0: Remove this warning and the call to _LT_SET_OPTION when you\nput the `dlopen' option into LT_INIT's first parameter.])\n])\n\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_DLOPEN], [])\n\n\n# win32-dll\n# ---------\n# Declare package support for building win32 dll's.\nLT_OPTION_DEFINE([LT_INIT], [win32-dll],\n[enable_win32_dll=yes\n\ncase $host in\n*-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-cegcc*)\n  AC_CHECK_TOOL(AS, as, false)\n  AC_CHECK_TOOL(DLLTOOL, dlltool, false)\n  AC_CHECK_TOOL(OBJDUMP, objdump, false)\n  ;;\nesac\n\ntest -z \"$AS\" && AS=as\n_LT_DECL([], [AS],      [1], [Assembler program])dnl\n\ntest -z \"$DLLTOOL\" && DLLTOOL=dlltool\n_LT_DECL([], [DLLTOOL], [1], [DLL creation program])dnl\n\ntest -z \"$OBJDUMP\" && OBJDUMP=objdump\n_LT_DECL([], [OBJDUMP], [1], [Object dumper program])dnl\n])# win32-dll\n\nAU_DEFUN([AC_LIBTOOL_WIN32_DLL],\n[AC_REQUIRE([AC_CANONICAL_HOST])dnl\n_LT_SET_OPTION([LT_INIT], [win32-dll])\nAC_DIAGNOSE([obsolete],\n[$0: Remove this warning and the call to _LT_SET_OPTION when you\nput the `win32-dll' option into LT_INIT's first parameter.])\n])\n\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_WIN32_DLL], [])\n\n\n# _LT_ENABLE_SHARED([DEFAULT])\n# ----------------------------\n# implement the --enable-shared flag, and supports the `shared' and\n# `disable-shared' LT_INIT options.\n# DEFAULT is either `yes' or `no'.  If omitted, it defaults to `yes'.\nm4_define([_LT_ENABLE_SHARED],\n[m4_define([_LT_ENABLE_SHARED_DEFAULT], [m4_if($1, no, no, yes)])dnl\nAC_ARG_ENABLE([shared],\n    [AS_HELP_STRING([--enable-shared@<:@=PKGS@:>@],\n\t[build shared libraries @<:@default=]_LT_ENABLE_SHARED_DEFAULT[@:>@])],\n    [p=${PACKAGE-default}\n    case $enableval in\n    yes) enable_shared=yes ;;\n    no) enable_shared=no ;;\n    *)\n      enable_shared=no\n      # Look at the argument we got.  We use all the common list separators.\n      lt_save_ifs=\"$IFS\"; IFS=\"${IFS}$PATH_SEPARATOR,\"\n      for pkg in $enableval; do\n\tIFS=\"$lt_save_ifs\"\n\tif test \"X$pkg\" = \"X$p\"; then\n\t  enable_shared=yes\n\tfi\n      done\n      IFS=\"$lt_save_ifs\"\n      ;;\n    esac],\n    [enable_shared=]_LT_ENABLE_SHARED_DEFAULT)\n\n    _LT_DECL([build_libtool_libs], [enable_shared], [0],\n\t[Whether or not to build shared libraries])\n])# _LT_ENABLE_SHARED\n\nLT_OPTION_DEFINE([LT_INIT], [shared], [_LT_ENABLE_SHARED([yes])])\nLT_OPTION_DEFINE([LT_INIT], [disable-shared], [_LT_ENABLE_SHARED([no])])\n\n# Old names:\nAC_DEFUN([AC_ENABLE_SHARED],\n[_LT_SET_OPTION([LT_INIT], m4_if([$1], [no], [disable-])[shared])\n])\n\nAC_DEFUN([AC_DISABLE_SHARED],\n[_LT_SET_OPTION([LT_INIT], [disable-shared])\n])\n\nAU_DEFUN([AM_ENABLE_SHARED], [AC_ENABLE_SHARED($@)])\nAU_DEFUN([AM_DISABLE_SHARED], [AC_DISABLE_SHARED($@)])\n\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AM_ENABLE_SHARED], [])\ndnl AC_DEFUN([AM_DISABLE_SHARED], [])\n\n\n\n# _LT_ENABLE_STATIC([DEFAULT])\n# ----------------------------\n# implement the --enable-static flag, and support the `static' and\n# `disable-static' LT_INIT options.\n# DEFAULT is either `yes' or `no'.  If omitted, it defaults to `yes'.\nm4_define([_LT_ENABLE_STATIC],\n[m4_define([_LT_ENABLE_STATIC_DEFAULT], [m4_if($1, no, no, yes)])dnl\nAC_ARG_ENABLE([static],\n    [AS_HELP_STRING([--enable-static@<:@=PKGS@:>@],\n\t[build static libraries @<:@default=]_LT_ENABLE_STATIC_DEFAULT[@:>@])],\n    [p=${PACKAGE-default}\n    case $enableval in\n    yes) enable_static=yes ;;\n    no) enable_static=no ;;\n    *)\n     enable_static=no\n      # Look at the argument we got.  We use all the common list separators.\n      lt_save_ifs=\"$IFS\"; IFS=\"${IFS}$PATH_SEPARATOR,\"\n      for pkg in $enableval; do\n\tIFS=\"$lt_save_ifs\"\n\tif test \"X$pkg\" = \"X$p\"; then\n\t  enable_static=yes\n\tfi\n      done\n      IFS=\"$lt_save_ifs\"\n      ;;\n    esac],\n    [enable_static=]_LT_ENABLE_STATIC_DEFAULT)\n\n    _LT_DECL([build_old_libs], [enable_static], [0],\n\t[Whether or not to build static libraries])\n])# _LT_ENABLE_STATIC\n\nLT_OPTION_DEFINE([LT_INIT], [static], [_LT_ENABLE_STATIC([yes])])\nLT_OPTION_DEFINE([LT_INIT], [disable-static], [_LT_ENABLE_STATIC([no])])\n\n# Old names:\nAC_DEFUN([AC_ENABLE_STATIC],\n[_LT_SET_OPTION([LT_INIT], m4_if([$1], [no], [disable-])[static])\n])\n\nAC_DEFUN([AC_DISABLE_STATIC],\n[_LT_SET_OPTION([LT_INIT], [disable-static])\n])\n\nAU_DEFUN([AM_ENABLE_STATIC], [AC_ENABLE_STATIC($@)])\nAU_DEFUN([AM_DISABLE_STATIC], [AC_DISABLE_STATIC($@)])\n\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AM_ENABLE_STATIC], [])\ndnl AC_DEFUN([AM_DISABLE_STATIC], [])\n\n\n\n# _LT_ENABLE_FAST_INSTALL([DEFAULT])\n# ----------------------------------\n# implement the --enable-fast-install flag, and support the `fast-install'\n# and `disable-fast-install' LT_INIT options.\n# DEFAULT is either `yes' or `no'.  If omitted, it defaults to `yes'.\nm4_define([_LT_ENABLE_FAST_INSTALL],\n[m4_define([_LT_ENABLE_FAST_INSTALL_DEFAULT], [m4_if($1, no, no, yes)])dnl\nAC_ARG_ENABLE([fast-install],\n    [AS_HELP_STRING([--enable-fast-install@<:@=PKGS@:>@],\n    [optimize for fast installation @<:@default=]_LT_ENABLE_FAST_INSTALL_DEFAULT[@:>@])],\n    [p=${PACKAGE-default}\n    case $enableval in\n    yes) enable_fast_install=yes ;;\n    no) enable_fast_install=no ;;\n    *)\n      enable_fast_install=no\n      # Look at the argument we got.  We use all the common list separators.\n      lt_save_ifs=\"$IFS\"; IFS=\"${IFS}$PATH_SEPARATOR,\"\n      for pkg in $enableval; do\n\tIFS=\"$lt_save_ifs\"\n\tif test \"X$pkg\" = \"X$p\"; then\n\t  enable_fast_install=yes\n\tfi\n      done\n      IFS=\"$lt_save_ifs\"\n      ;;\n    esac],\n    [enable_fast_install=]_LT_ENABLE_FAST_INSTALL_DEFAULT)\n\n_LT_DECL([fast_install], [enable_fast_install], [0],\n\t [Whether or not to optimize for fast installation])dnl\n])# _LT_ENABLE_FAST_INSTALL\n\nLT_OPTION_DEFINE([LT_INIT], [fast-install], [_LT_ENABLE_FAST_INSTALL([yes])])\nLT_OPTION_DEFINE([LT_INIT], [disable-fast-install], [_LT_ENABLE_FAST_INSTALL([no])])\n\n# Old names:\nAU_DEFUN([AC_ENABLE_FAST_INSTALL],\n[_LT_SET_OPTION([LT_INIT], m4_if([$1], [no], [disable-])[fast-install])\nAC_DIAGNOSE([obsolete],\n[$0: Remove this warning and the call to _LT_SET_OPTION when you put\nthe `fast-install' option into LT_INIT's first parameter.])\n])\n\nAU_DEFUN([AC_DISABLE_FAST_INSTALL],\n[_LT_SET_OPTION([LT_INIT], [disable-fast-install])\nAC_DIAGNOSE([obsolete],\n[$0: Remove this warning and the call to _LT_SET_OPTION when you put\nthe `disable-fast-install' option into LT_INIT's first parameter.])\n])\n\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_ENABLE_FAST_INSTALL], [])\ndnl AC_DEFUN([AM_DISABLE_FAST_INSTALL], [])\n\n\n# _LT_WITH_PIC([MODE])\n# --------------------\n# implement the --with-pic flag, and support the `pic-only' and `no-pic'\n# LT_INIT options.\n# MODE is either `yes' or `no'.  If omitted, it defaults to `both'.\nm4_define([_LT_WITH_PIC],\n[AC_ARG_WITH([pic],\n    [AS_HELP_STRING([--with-pic@<:@=PKGS@:>@],\n\t[try to use only PIC/non-PIC objects @<:@default=use both@:>@])],\n    [lt_p=${PACKAGE-default}\n    case $withval in\n    yes|no) pic_mode=$withval ;;\n    *)\n      pic_mode=default\n      # Look at the argument we got.  We use all the common list separators.\n      lt_save_ifs=\"$IFS\"; IFS=\"${IFS}$PATH_SEPARATOR,\"\n      for lt_pkg in $withval; do\n\tIFS=\"$lt_save_ifs\"\n\tif test \"X$lt_pkg\" = \"X$lt_p\"; then\n\t  pic_mode=yes\n\tfi\n      done\n      IFS=\"$lt_save_ifs\"\n      ;;\n    esac],\n    [pic_mode=default])\n\ntest -z \"$pic_mode\" && pic_mode=m4_default([$1], [default])\n\n_LT_DECL([], [pic_mode], [0], [What type of objects to build])dnl\n])# _LT_WITH_PIC\n\nLT_OPTION_DEFINE([LT_INIT], [pic-only], [_LT_WITH_PIC([yes])])\nLT_OPTION_DEFINE([LT_INIT], [no-pic], [_LT_WITH_PIC([no])])\n\n# Old name:\nAU_DEFUN([AC_LIBTOOL_PICMODE],\n[_LT_SET_OPTION([LT_INIT], [pic-only])\nAC_DIAGNOSE([obsolete],\n[$0: Remove this warning and the call to _LT_SET_OPTION when you\nput the `pic-only' option into LT_INIT's first parameter.])\n])\n\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_PICMODE], [])\n\n\nm4_define([_LTDL_MODE], [])\nLT_OPTION_DEFINE([LTDL_INIT], [nonrecursive],\n\t\t [m4_define([_LTDL_MODE], [nonrecursive])])\nLT_OPTION_DEFINE([LTDL_INIT], [recursive],\n\t\t [m4_define([_LTDL_MODE], [recursive])])\nLT_OPTION_DEFINE([LTDL_INIT], [subproject],\n\t\t [m4_define([_LTDL_MODE], [subproject])])\n\nm4_define([_LTDL_TYPE], [])\nLT_OPTION_DEFINE([LTDL_INIT], [installable],\n\t\t [m4_define([_LTDL_TYPE], [installable])])\nLT_OPTION_DEFINE([LTDL_INIT], [convenience],\n\t\t [m4_define([_LTDL_TYPE], [convenience])])\n\n# ltsugar.m4 -- libtool m4 base layer.                         -*-Autoconf-*-\n#\n# Copyright (C) 2004, 2005, 2007, 2008 Free Software Foundation, Inc.\n# Written by Gary V. Vaughan, 2004\n#\n# This file is free software; the Free Software Foundation gives\n# unlimited permission to copy and/or distribute it, with or without\n# modifications, as long as this notice is preserved.\n\n# serial 6 ltsugar.m4\n\n# This is to help aclocal find these macros, as it can't see m4_define.\nAC_DEFUN([LTSUGAR_VERSION], [m4_if([0.1])])\n\n\n# lt_join(SEP, ARG1, [ARG2...])\n# -----------------------------\n# Produce ARG1SEPARG2...SEPARGn, omitting [] arguments and their\n# associated separator.\n# Needed until we can rely on m4_join from Autoconf 2.62, since all earlier\n# versions in m4sugar had bugs.\nm4_define([lt_join],\n[m4_if([$#], [1], [],\n       [$#], [2], [[$2]],\n       [m4_if([$2], [], [], [[$2]_])$0([$1], m4_shift(m4_shift($@)))])])\nm4_define([_lt_join],\n[m4_if([$#$2], [2], [],\n       [m4_if([$2], [], [], [[$1$2]])$0([$1], m4_shift(m4_shift($@)))])])\n\n\n# lt_car(LIST)\n# lt_cdr(LIST)\n# ------------\n# Manipulate m4 lists.\n# These macros are necessary as long as will still need to support\n# Autoconf-2.59 which quotes differently.\nm4_define([lt_car], [[$1]])\nm4_define([lt_cdr],\n[m4_if([$#], 0, [m4_fatal([$0: cannot be called without arguments])],\n       [$#], 1, [],\n       [m4_dquote(m4_shift($@))])])\nm4_define([lt_unquote], $1)\n\n\n# lt_append(MACRO-NAME, STRING, [SEPARATOR])\n# ------------------------------------------\n# Redefine MACRO-NAME to hold its former content plus `SEPARATOR'`STRING'.\n# Note that neither SEPARATOR nor STRING are expanded; they are appended\n# to MACRO-NAME as is (leaving the expansion for when MACRO-NAME is invoked).\n# No SEPARATOR is output if MACRO-NAME was previously undefined (different\n# than defined and empty).\n#\n# This macro is needed until we can rely on Autoconf 2.62, since earlier\n# versions of m4sugar mistakenly expanded SEPARATOR but not STRING.\nm4_define([lt_append],\n[m4_define([$1],\n\t   m4_ifdef([$1], [m4_defn([$1])[$3]])[$2])])\n\n\n\n# lt_combine(SEP, PREFIX-LIST, INFIX, SUFFIX1, [SUFFIX2...])\n# ----------------------------------------------------------\n# Produce a SEP delimited list of all paired combinations of elements of\n# PREFIX-LIST with SUFFIX1 through SUFFIXn.  Each element of the list\n# has the form PREFIXmINFIXSUFFIXn.\n# Needed until we can rely on m4_combine added in Autoconf 2.62.\nm4_define([lt_combine],\n[m4_if(m4_eval([$# > 3]), [1],\n       [m4_pushdef([_Lt_sep], [m4_define([_Lt_sep], m4_defn([lt_car]))])]]dnl\n[[m4_foreach([_Lt_prefix], [$2],\n\t     [m4_foreach([_Lt_suffix],\n\t\t]m4_dquote(m4_dquote(m4_shift(m4_shift(m4_shift($@)))))[,\n\t[_Lt_sep([$1])[]m4_defn([_Lt_prefix])[$3]m4_defn([_Lt_suffix])])])])])\n\n\n# lt_if_append_uniq(MACRO-NAME, VARNAME, [SEPARATOR], [UNIQ], [NOT-UNIQ])\n# -----------------------------------------------------------------------\n# Iff MACRO-NAME does not yet contain VARNAME, then append it (delimited\n# by SEPARATOR if supplied) and expand UNIQ, else NOT-UNIQ.\nm4_define([lt_if_append_uniq],\n[m4_ifdef([$1],\n\t  [m4_if(m4_index([$3]m4_defn([$1])[$3], [$3$2$3]), [-1],\n\t\t [lt_append([$1], [$2], [$3])$4],\n\t\t [$5])],\n\t  [lt_append([$1], [$2], [$3])$4])])\n\n\n# lt_dict_add(DICT, KEY, VALUE)\n# -----------------------------\nm4_define([lt_dict_add],\n[m4_define([$1($2)], [$3])])\n\n\n# lt_dict_add_subkey(DICT, KEY, SUBKEY, VALUE)\n# --------------------------------------------\nm4_define([lt_dict_add_subkey],\n[m4_define([$1($2:$3)], [$4])])\n\n\n# lt_dict_fetch(DICT, KEY, [SUBKEY])\n# ----------------------------------\nm4_define([lt_dict_fetch],\n[m4_ifval([$3],\n\tm4_ifdef([$1($2:$3)], [m4_defn([$1($2:$3)])]),\n    m4_ifdef([$1($2)], [m4_defn([$1($2)])]))])\n\n\n# lt_if_dict_fetch(DICT, KEY, [SUBKEY], VALUE, IF-TRUE, [IF-FALSE])\n# -----------------------------------------------------------------\nm4_define([lt_if_dict_fetch],\n[m4_if(lt_dict_fetch([$1], [$2], [$3]), [$4],\n\t[$5],\n    [$6])])\n\n\n# lt_dict_filter(DICT, [SUBKEY], VALUE, [SEPARATOR], KEY, [...])\n# --------------------------------------------------------------\nm4_define([lt_dict_filter],\n[m4_if([$5], [], [],\n  [lt_join(m4_quote(m4_default([$4], [[, ]])),\n           lt_unquote(m4_split(m4_normalize(m4_foreach(_Lt_key, lt_car([m4_shiftn(4, $@)]),\n\t\t      [lt_if_dict_fetch([$1], _Lt_key, [$2], [$3], [_Lt_key ])])))))])[]dnl\n])\n\n# ltversion.m4 -- version numbers\t\t\t-*- Autoconf -*-\n#\n#   Copyright (C) 2004 Free Software Foundation, Inc.\n#   Written by Scott James Remnant, 2004\n#\n# This file is free software; the Free Software Foundation gives\n# unlimited permission to copy and/or distribute it, with or without\n# modifications, as long as this notice is preserved.\n\n# @configure_input@\n\n# serial 3337 ltversion.m4\n# This file is part of GNU Libtool\n\nm4_define([LT_PACKAGE_VERSION], [2.4.2])\nm4_define([LT_PACKAGE_REVISION], [1.3337])\n\nAC_DEFUN([LTVERSION_VERSION],\n[macro_version='2.4.2'\nmacro_revision='1.3337'\n_LT_DECL(, macro_version, 0, [Which release of libtool.m4 was used?])\n_LT_DECL(, macro_revision, 0)\n])\n\n# lt~obsolete.m4 -- aclocal satisfying obsolete definitions.    -*-Autoconf-*-\n#\n#   Copyright (C) 2004, 2005, 2007, 2009 Free Software Foundation, Inc.\n#   Written by Scott James Remnant, 2004.\n#\n# This file is free software; the Free Software Foundation gives\n# unlimited permission to copy and/or distribute it, with or without\n# modifications, as long as this notice is preserved.\n\n# serial 5 lt~obsolete.m4\n\n# These exist entirely to fool aclocal when bootstrapping libtool.\n#\n# In the past libtool.m4 has provided macros via AC_DEFUN (or AU_DEFUN)\n# which have later been changed to m4_define as they aren't part of the\n# exported API, or moved to Autoconf or Automake where they belong.\n#\n# The trouble is, aclocal is a bit thick.  It'll see the old AC_DEFUN\n# in /usr/share/aclocal/libtool.m4 and remember it, then when it sees us\n# using a macro with the same name in our local m4/libtool.m4 it'll\n# pull the old libtool.m4 in (it doesn't see our shiny new m4_define\n# and doesn't know about Autoconf macros at all.)\n#\n# So we provide this file, which has a silly filename so it's always\n# included after everything else.  This provides aclocal with the\n# AC_DEFUNs it wants, but when m4 processes it, it doesn't do anything\n# because those macros already exist, or will be overwritten later.\n# We use AC_DEFUN over AU_DEFUN for compatibility with aclocal-1.6. \n#\n# Anytime we withdraw an AC_DEFUN or AU_DEFUN, remember to add it here.\n# Yes, that means every name once taken will need to remain here until\n# we give up compatibility with versions before 1.7, at which point\n# we need to keep only those names which we still refer to.\n\n# This is to help aclocal find these macros, as it can't see m4_define.\nAC_DEFUN([LTOBSOLETE_VERSION], [m4_if([1])])\n\nm4_ifndef([AC_LIBTOOL_LINKER_OPTION],\t[AC_DEFUN([AC_LIBTOOL_LINKER_OPTION])])\nm4_ifndef([AC_PROG_EGREP],\t\t[AC_DEFUN([AC_PROG_EGREP])])\nm4_ifndef([_LT_AC_PROG_ECHO_BACKSLASH],\t[AC_DEFUN([_LT_AC_PROG_ECHO_BACKSLASH])])\nm4_ifndef([_LT_AC_SHELL_INIT],\t\t[AC_DEFUN([_LT_AC_SHELL_INIT])])\nm4_ifndef([_LT_AC_SYS_LIBPATH_AIX],\t[AC_DEFUN([_LT_AC_SYS_LIBPATH_AIX])])\nm4_ifndef([_LT_PROG_LTMAIN],\t\t[AC_DEFUN([_LT_PROG_LTMAIN])])\nm4_ifndef([_LT_AC_TAGVAR],\t\t[AC_DEFUN([_LT_AC_TAGVAR])])\nm4_ifndef([AC_LTDL_ENABLE_INSTALL],\t[AC_DEFUN([AC_LTDL_ENABLE_INSTALL])])\nm4_ifndef([AC_LTDL_PREOPEN],\t\t[AC_DEFUN([AC_LTDL_PREOPEN])])\nm4_ifndef([_LT_AC_SYS_COMPILER],\t[AC_DEFUN([_LT_AC_SYS_COMPILER])])\nm4_ifndef([_LT_AC_LOCK],\t\t[AC_DEFUN([_LT_AC_LOCK])])\nm4_ifndef([AC_LIBTOOL_SYS_OLD_ARCHIVE],\t[AC_DEFUN([AC_LIBTOOL_SYS_OLD_ARCHIVE])])\nm4_ifndef([_LT_AC_TRY_DLOPEN_SELF],\t[AC_DEFUN([_LT_AC_TRY_DLOPEN_SELF])])\nm4_ifndef([AC_LIBTOOL_PROG_CC_C_O],\t[AC_DEFUN([AC_LIBTOOL_PROG_CC_C_O])])\nm4_ifndef([AC_LIBTOOL_SYS_HARD_LINK_LOCKS], [AC_DEFUN([AC_LIBTOOL_SYS_HARD_LINK_LOCKS])])\nm4_ifndef([AC_LIBTOOL_OBJDIR],\t\t[AC_DEFUN([AC_LIBTOOL_OBJDIR])])\nm4_ifndef([AC_LTDL_OBJDIR],\t\t[AC_DEFUN([AC_LTDL_OBJDIR])])\nm4_ifndef([AC_LIBTOOL_PROG_LD_HARDCODE_LIBPATH], [AC_DEFUN([AC_LIBTOOL_PROG_LD_HARDCODE_LIBPATH])])\nm4_ifndef([AC_LIBTOOL_SYS_LIB_STRIP],\t[AC_DEFUN([AC_LIBTOOL_SYS_LIB_STRIP])])\nm4_ifndef([AC_PATH_MAGIC],\t\t[AC_DEFUN([AC_PATH_MAGIC])])\nm4_ifndef([AC_PROG_LD_GNU],\t\t[AC_DEFUN([AC_PROG_LD_GNU])])\nm4_ifndef([AC_PROG_LD_RELOAD_FLAG],\t[AC_DEFUN([AC_PROG_LD_RELOAD_FLAG])])\nm4_ifndef([AC_DEPLIBS_CHECK_METHOD],\t[AC_DEFUN([AC_DEPLIBS_CHECK_METHOD])])\nm4_ifndef([AC_LIBTOOL_PROG_COMPILER_NO_RTTI], [AC_DEFUN([AC_LIBTOOL_PROG_COMPILER_NO_RTTI])])\nm4_ifndef([AC_LIBTOOL_SYS_GLOBAL_SYMBOL_PIPE], [AC_DEFUN([AC_LIBTOOL_SYS_GLOBAL_SYMBOL_PIPE])])\nm4_ifndef([AC_LIBTOOL_PROG_COMPILER_PIC], [AC_DEFUN([AC_LIBTOOL_PROG_COMPILER_PIC])])\nm4_ifndef([AC_LIBTOOL_PROG_LD_SHLIBS],\t[AC_DEFUN([AC_LIBTOOL_PROG_LD_SHLIBS])])\nm4_ifndef([AC_LIBTOOL_POSTDEP_PREDEP],\t[AC_DEFUN([AC_LIBTOOL_POSTDEP_PREDEP])])\nm4_ifndef([LT_AC_PROG_EGREP],\t\t[AC_DEFUN([LT_AC_PROG_EGREP])])\nm4_ifndef([LT_AC_PROG_SED],\t\t[AC_DEFUN([LT_AC_PROG_SED])])\nm4_ifndef([_LT_CC_BASENAME],\t\t[AC_DEFUN([_LT_CC_BASENAME])])\nm4_ifndef([_LT_COMPILER_BOILERPLATE],\t[AC_DEFUN([_LT_COMPILER_BOILERPLATE])])\nm4_ifndef([_LT_LINKER_BOILERPLATE],\t[AC_DEFUN([_LT_LINKER_BOILERPLATE])])\nm4_ifndef([_AC_PROG_LIBTOOL],\t\t[AC_DEFUN([_AC_PROG_LIBTOOL])])\nm4_ifndef([AC_LIBTOOL_SETUP],\t\t[AC_DEFUN([AC_LIBTOOL_SETUP])])\nm4_ifndef([_LT_AC_CHECK_DLFCN],\t\t[AC_DEFUN([_LT_AC_CHECK_DLFCN])])\nm4_ifndef([AC_LIBTOOL_SYS_DYNAMIC_LINKER],\t[AC_DEFUN([AC_LIBTOOL_SYS_DYNAMIC_LINKER])])\nm4_ifndef([_LT_AC_TAGCONFIG],\t\t[AC_DEFUN([_LT_AC_TAGCONFIG])])\nm4_ifndef([AC_DISABLE_FAST_INSTALL],\t[AC_DEFUN([AC_DISABLE_FAST_INSTALL])])\nm4_ifndef([_LT_AC_LANG_CXX],\t\t[AC_DEFUN([_LT_AC_LANG_CXX])])\nm4_ifndef([_LT_AC_LANG_F77],\t\t[AC_DEFUN([_LT_AC_LANG_F77])])\nm4_ifndef([_LT_AC_LANG_GCJ],\t\t[AC_DEFUN([_LT_AC_LANG_GCJ])])\nm4_ifndef([AC_LIBTOOL_LANG_C_CONFIG],\t[AC_DEFUN([AC_LIBTOOL_LANG_C_CONFIG])])\nm4_ifndef([_LT_AC_LANG_C_CONFIG],\t[AC_DEFUN([_LT_AC_LANG_C_CONFIG])])\nm4_ifndef([AC_LIBTOOL_LANG_CXX_CONFIG],\t[AC_DEFUN([AC_LIBTOOL_LANG_CXX_CONFIG])])\nm4_ifndef([_LT_AC_LANG_CXX_CONFIG],\t[AC_DEFUN([_LT_AC_LANG_CXX_CONFIG])])\nm4_ifndef([AC_LIBTOOL_LANG_F77_CONFIG],\t[AC_DEFUN([AC_LIBTOOL_LANG_F77_CONFIG])])\nm4_ifndef([_LT_AC_LANG_F77_CONFIG],\t[AC_DEFUN([_LT_AC_LANG_F77_CONFIG])])\nm4_ifndef([AC_LIBTOOL_LANG_GCJ_CONFIG],\t[AC_DEFUN([AC_LIBTOOL_LANG_GCJ_CONFIG])])\nm4_ifndef([_LT_AC_LANG_GCJ_CONFIG],\t[AC_DEFUN([_LT_AC_LANG_GCJ_CONFIG])])\nm4_ifndef([AC_LIBTOOL_LANG_RC_CONFIG],\t[AC_DEFUN([AC_LIBTOOL_LANG_RC_CONFIG])])\nm4_ifndef([_LT_AC_LANG_RC_CONFIG],\t[AC_DEFUN([_LT_AC_LANG_RC_CONFIG])])\nm4_ifndef([AC_LIBTOOL_CONFIG],\t\t[AC_DEFUN([AC_LIBTOOL_CONFIG])])\nm4_ifndef([_LT_AC_FILE_LTDLL_C],\t[AC_DEFUN([_LT_AC_FILE_LTDLL_C])])\nm4_ifndef([_LT_REQUIRED_DARWIN_CHECKS],\t[AC_DEFUN([_LT_REQUIRED_DARWIN_CHECKS])])\nm4_ifndef([_LT_AC_PROG_CXXCPP],\t\t[AC_DEFUN([_LT_AC_PROG_CXXCPP])])\nm4_ifndef([_LT_PREPARE_SED_QUOTE_VARS],\t[AC_DEFUN([_LT_PREPARE_SED_QUOTE_VARS])])\nm4_ifndef([_LT_PROG_ECHO_BACKSLASH],\t[AC_DEFUN([_LT_PROG_ECHO_BACKSLASH])])\nm4_ifndef([_LT_PROG_F77],\t\t[AC_DEFUN([_LT_PROG_F77])])\nm4_ifndef([_LT_PROG_FC],\t\t[AC_DEFUN([_LT_PROG_FC])])\nm4_ifndef([_LT_PROG_CXX],\t\t[AC_DEFUN([_LT_PROG_CXX])])\n\n# pkg.m4 - Macros to locate and utilise pkg-config.            -*- Autoconf -*-\n# serial 1 (pkg-config-0.24)\n# \n# Copyright \u00a9 2004 Scott James Remnant <scott@netsplit.com>.\n#\n# This program is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation; either version 2 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful, but\n# WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1335  USA.\n#\n# As a special exception to the GNU General Public License, if you\n# distribute this file as part of a program that contains a\n# configuration script generated by Autoconf, you may include it under\n# the same distribution terms that you use for the rest of that program.\n\n# PKG_PROG_PKG_CONFIG([MIN-VERSION])\n# ----------------------------------\nAC_DEFUN([PKG_PROG_PKG_CONFIG],\n[m4_pattern_forbid([^_?PKG_[A-Z_]+$])\nm4_pattern_allow([^PKG_CONFIG(_(PATH|LIBDIR|SYSROOT_DIR|ALLOW_SYSTEM_(CFLAGS|LIBS)))?$])\nm4_pattern_allow([^PKG_CONFIG_(DISABLE_UNINSTALLED|TOP_BUILD_DIR|DEBUG_SPEW)$])\nAC_ARG_VAR([PKG_CONFIG], [path to pkg-config utility])\nAC_ARG_VAR([PKG_CONFIG_PATH], [directories to add to pkg-config's search path])\nAC_ARG_VAR([PKG_CONFIG_LIBDIR], [path overriding pkg-config's built-in search path])\n\nif test \"x$ac_cv_env_PKG_CONFIG_set\" != \"xset\"; then\n\tAC_PATH_TOOL([PKG_CONFIG], [pkg-config])\nfi\nif test -n \"$PKG_CONFIG\"; then\n\t_pkg_min_version=m4_default([$1], [0.9.0])\n\tAC_MSG_CHECKING([pkg-config is at least version $_pkg_min_version])\n\tif $PKG_CONFIG --atleast-pkgconfig-version $_pkg_min_version; then\n\t\tAC_MSG_RESULT([yes])\n\telse\n\t\tAC_MSG_RESULT([no])\n\t\tPKG_CONFIG=\"\"\n\tfi\nfi[]dnl\n])# PKG_PROG_PKG_CONFIG\n\n# PKG_CHECK_EXISTS(MODULES, [ACTION-IF-FOUND], [ACTION-IF-NOT-FOUND])\n#\n# Check to see whether a particular set of modules exists.  Similar\n# to PKG_CHECK_MODULES(), but does not set variables or print errors.\n#\n# Please remember that m4 expands AC_REQUIRE([PKG_PROG_PKG_CONFIG])\n# only at the first occurence in configure.ac, so if the first place\n# it's called might be skipped (such as if it is within an \"if\", you\n# have to call PKG_CHECK_EXISTS manually\n# --------------------------------------------------------------\nAC_DEFUN([PKG_CHECK_EXISTS],\n[AC_REQUIRE([PKG_PROG_PKG_CONFIG])dnl\nif test -n \"$PKG_CONFIG\" && \\\n    AC_RUN_LOG([$PKG_CONFIG --exists --print-errors \"$1\"]); then\n  m4_default([$2], [:])\nm4_ifvaln([$3], [else\n  $3])dnl\nfi])\n\n# _PKG_CONFIG([VARIABLE], [COMMAND], [MODULES])\n# ---------------------------------------------\nm4_define([_PKG_CONFIG],\n[if test -n \"$$1\"; then\n    pkg_cv_[]$1=\"$$1\"\n elif test -n \"$PKG_CONFIG\"; then\n    PKG_CHECK_EXISTS([$3],\n                     [pkg_cv_[]$1=`$PKG_CONFIG --[]$2 \"$3\" 2>/dev/null`\n\t\t      test \"x$?\" != \"x0\" && pkg_failed=yes ],\n\t\t     [pkg_failed=yes])\n else\n    pkg_failed=untried\nfi[]dnl\n])# _PKG_CONFIG\n\n# _PKG_SHORT_ERRORS_SUPPORTED\n# -----------------------------\nAC_DEFUN([_PKG_SHORT_ERRORS_SUPPORTED],\n[AC_REQUIRE([PKG_PROG_PKG_CONFIG])\nif $PKG_CONFIG --atleast-pkgconfig-version 0.20; then\n        _pkg_short_errors_supported=yes\nelse\n        _pkg_short_errors_supported=no\nfi[]dnl\n])# _PKG_SHORT_ERRORS_SUPPORTED\n\n\n# PKG_CHECK_MODULES(VARIABLE-PREFIX, MODULES, [ACTION-IF-FOUND],\n# [ACTION-IF-NOT-FOUND])\n#\n#\n# Note that if there is a possibility the first call to\n# PKG_CHECK_MODULES might not happen, you should be sure to include an\n# explicit call to PKG_PROG_PKG_CONFIG in your configure.ac\n#\n#\n# --------------------------------------------------------------\nAC_DEFUN([PKG_CHECK_MODULES],\n[AC_REQUIRE([PKG_PROG_PKG_CONFIG])dnl\nAC_ARG_VAR([$1][_CFLAGS], [C compiler flags for $1, overriding pkg-config])dnl\nAC_ARG_VAR([$1][_LIBS], [linker flags for $1, overriding pkg-config])dnl\n\npkg_failed=no\nAC_MSG_CHECKING([for $1])\n\n_PKG_CONFIG([$1][_CFLAGS], [cflags], [$2])\n_PKG_CONFIG([$1][_LIBS], [libs], [$2])\n\nm4_define([_PKG_TEXT], [Alternatively, you may set the environment variables $1[]_CFLAGS\nand $1[]_LIBS to avoid the need to call pkg-config.\nSee the pkg-config man page for more details.])\n\nif test $pkg_failed = yes; then\n   \tAC_MSG_RESULT([no])\n        _PKG_SHORT_ERRORS_SUPPORTED\n        if test $_pkg_short_errors_supported = yes; then\n\t        $1[]_PKG_ERRORS=`$PKG_CONFIG --short-errors --print-errors --cflags --libs \"$2\" 2>&1`\n        else \n\t        $1[]_PKG_ERRORS=`$PKG_CONFIG --print-errors --cflags --libs \"$2\" 2>&1`\n        fi\n\t# Put the nasty error message in config.log where it belongs\n\techo \"$$1[]_PKG_ERRORS\" >&AS_MESSAGE_LOG_FD\n\n\tm4_default([$4], [AC_MSG_ERROR(\n[Package requirements ($2) were not met:\n\n$$1_PKG_ERRORS\n\nConsider adjusting the PKG_CONFIG_PATH environment variable if you\ninstalled software in a non-standard prefix.\n\n_PKG_TEXT])[]dnl\n        ])\nelif test $pkg_failed = untried; then\n     \tAC_MSG_RESULT([no])\n\tm4_default([$4], [AC_MSG_FAILURE(\n[The pkg-config script could not be found or is too old.  Make sure it\nis in your PATH or set the PKG_CONFIG environment variable to the full\npath to pkg-config.\n\n_PKG_TEXT\n\nTo get pkg-config, see <http://pkg-config.freedesktop.org/>.])[]dnl\n        ])\nelse\n\t$1[]_CFLAGS=$pkg_cv_[]$1[]_CFLAGS\n\t$1[]_LIBS=$pkg_cv_[]$1[]_LIBS\n        AC_MSG_RESULT([yes])\n\t$3\nfi[]dnl\n])# PKG_CHECK_MODULES\n\n# Copyright (C) 2002, 2003, 2005, 2006, 2007, 2008, 2011 Free Software\n# Foundation, Inc.\n#\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n# serial 1\n\n# AM_AUTOMAKE_VERSION(VERSION)\n# ----------------------------\n# Automake X.Y traces this macro to ensure aclocal.m4 has been\n# generated from the m4 files accompanying Automake X.Y.\n# (This private macro should not be called outside this file.)\nAC_DEFUN([AM_AUTOMAKE_VERSION],\n[am__api_version='1.11'\ndnl Some users find AM_AUTOMAKE_VERSION and mistake it for a way to\ndnl require some minimum version.  Point them to the right macro.\nm4_if([$1], [1.11.3], [],\n      [AC_FATAL([Do not call $0, use AM_INIT_AUTOMAKE([$1]).])])dnl\n])\n\n# _AM_AUTOCONF_VERSION(VERSION)\n# -----------------------------\n# aclocal traces this macro to find the Autoconf version.\n# This is a private macro too.  Using m4_define simplifies\n# the logic in aclocal, which can simply ignore this definition.\nm4_define([_AM_AUTOCONF_VERSION], [])\n\n# AM_SET_CURRENT_AUTOMAKE_VERSION\n# -------------------------------\n# Call AM_AUTOMAKE_VERSION and AM_AUTOMAKE_VERSION so they can be traced.\n# This function is AC_REQUIREd by AM_INIT_AUTOMAKE.\nAC_DEFUN([AM_SET_CURRENT_AUTOMAKE_VERSION],\n[AM_AUTOMAKE_VERSION([1.11.3])dnl\nm4_ifndef([AC_AUTOCONF_VERSION],\n  [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl\n_AM_AUTOCONF_VERSION(m4_defn([AC_AUTOCONF_VERSION]))])\n\n# AM_AUX_DIR_EXPAND                                         -*- Autoconf -*-\n\n# Copyright (C) 2001, 2003, 2005, 2011 Free Software Foundation, Inc.\n#\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n# serial 1\n\n# For projects using AC_CONFIG_AUX_DIR([foo]), Autoconf sets\n# $ac_aux_dir to `$srcdir/foo'.  In other projects, it is set to\n# `$srcdir', `$srcdir/..', or `$srcdir/../..'.\n#\n# Of course, Automake must honor this variable whenever it calls a\n# tool from the auxiliary directory.  The problem is that $srcdir (and\n# therefore $ac_aux_dir as well) can be either absolute or relative,\n# depending on how configure is run.  This is pretty annoying, since\n# it makes $ac_aux_dir quite unusable in subdirectories: in the top\n# source directory, any form will work fine, but in subdirectories a\n# relative path needs to be adjusted first.\n#\n# $ac_aux_dir/missing\n#    fails when called from a subdirectory if $ac_aux_dir is relative\n# $top_srcdir/$ac_aux_dir/missing\n#    fails if $ac_aux_dir is absolute,\n#    fails when called from a subdirectory in a VPATH build with\n#          a relative $ac_aux_dir\n#\n# The reason of the latter failure is that $top_srcdir and $ac_aux_dir\n# are both prefixed by $srcdir.  In an in-source build this is usually\n# harmless because $srcdir is `.', but things will broke when you\n# start a VPATH build or use an absolute $srcdir.\n#\n# So we could use something similar to $top_srcdir/$ac_aux_dir/missing,\n# iff we strip the leading $srcdir from $ac_aux_dir.  That would be:\n#   am_aux_dir='\\$(top_srcdir)/'`expr \"$ac_aux_dir\" : \"$srcdir//*\\(.*\\)\"`\n# and then we would define $MISSING as\n#   MISSING=\"\\${SHELL} $am_aux_dir/missing\"\n# This will work as long as MISSING is not called from configure, because\n# unfortunately $(top_srcdir) has no meaning in configure.\n# However there are other variables, like CC, which are often used in\n# configure, and could therefore not use this \"fixed\" $ac_aux_dir.\n#\n# Another solution, used here, is to always expand $ac_aux_dir to an\n# absolute PATH.  The drawback is that using absolute paths prevent a\n# configured tree to be moved without reconfiguration.\n\nAC_DEFUN([AM_AUX_DIR_EXPAND],\n[dnl Rely on autoconf to set up CDPATH properly.\nAC_PREREQ([2.50])dnl\n# expand $ac_aux_dir to an absolute path\nam_aux_dir=`cd $ac_aux_dir && pwd`\n])\n\n# AM_CONDITIONAL                                            -*- Autoconf -*-\n\n# Copyright (C) 1997, 2000, 2001, 2003, 2004, 2005, 2006, 2008\n# Free Software Foundation, Inc.\n#\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n# serial 9\n\n# AM_CONDITIONAL(NAME, SHELL-CONDITION)\n# -------------------------------------\n# Define a conditional.\nAC_DEFUN([AM_CONDITIONAL],\n[AC_PREREQ(2.52)dnl\n ifelse([$1], [TRUE],  [AC_FATAL([$0: invalid condition: $1])],\n\t[$1], [FALSE], [AC_FATAL([$0: invalid condition: $1])])dnl\nAC_SUBST([$1_TRUE])dnl\nAC_SUBST([$1_FALSE])dnl\n_AM_SUBST_NOTMAKE([$1_TRUE])dnl\n_AM_SUBST_NOTMAKE([$1_FALSE])dnl\nm4_define([_AM_COND_VALUE_$1], [$2])dnl\nif $2; then\n  $1_TRUE=\n  $1_FALSE='#'\nelse\n  $1_TRUE='#'\n  $1_FALSE=\nfi\nAC_CONFIG_COMMANDS_PRE(\n[if test -z \"${$1_TRUE}\" && test -z \"${$1_FALSE}\"; then\n  AC_MSG_ERROR([[conditional \"$1\" was never defined.\nUsually this means the macro was only invoked conditionally.]])\nfi])])\n\n# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2009,\n# 2010, 2011 Free Software Foundation, Inc.\n#\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n# serial 12\n\n# There are a few dirty hacks below to avoid letting `AC_PROG_CC' be\n# written in clear, in which case automake, when reading aclocal.m4,\n# will think it sees a *use*, and therefore will trigger all it's\n# C support machinery.  Also note that it means that autoscan, seeing\n# CC etc. in the Makefile, will ask for an AC_PROG_CC use...\n\n\n# _AM_DEPENDENCIES(NAME)\n# ----------------------\n# See how the compiler implements dependency checking.\n# NAME is \"CC\", \"CXX\", \"GCJ\", or \"OBJC\".\n# We try a few techniques and use that to set a single cache variable.\n#\n# We don't AC_REQUIRE the corresponding AC_PROG_CC since the latter was\n# modified to invoke _AM_DEPENDENCIES(CC); we would have a circular\n# dependency, and given that the user is not expected to run this macro,\n# just rely on AC_PROG_CC.\nAC_DEFUN([_AM_DEPENDENCIES],\n[AC_REQUIRE([AM_SET_DEPDIR])dnl\nAC_REQUIRE([AM_OUTPUT_DEPENDENCY_COMMANDS])dnl\nAC_REQUIRE([AM_MAKE_INCLUDE])dnl\nAC_REQUIRE([AM_DEP_TRACK])dnl\n\nifelse([$1], CC,   [depcc=\"$CC\"   am_compiler_list=],\n       [$1], CXX,  [depcc=\"$CXX\"  am_compiler_list=],\n       [$1], OBJC, [depcc=\"$OBJC\" am_compiler_list='gcc3 gcc'],\n       [$1], UPC,  [depcc=\"$UPC\"  am_compiler_list=],\n       [$1], GCJ,  [depcc=\"$GCJ\"  am_compiler_list='gcc3 gcc'],\n                   [depcc=\"$$1\"   am_compiler_list=])\n\nAC_CACHE_CHECK([dependency style of $depcc],\n               [am_cv_$1_dependencies_compiler_type],\n[if test -z \"$AMDEP_TRUE\" && test -f \"$am_depcomp\"; then\n  # We make a subdir and do the tests there.  Otherwise we can end up\n  # making bogus files that we don't know about and never remove.  For\n  # instance it was reported that on HP-UX the gcc test will end up\n  # making a dummy file named `D' -- because `-MD' means `put the output\n  # in D'.\n  rm -rf conftest.dir\n  mkdir conftest.dir\n  # Copy depcomp to subdir because otherwise we won't find it if we're\n  # using a relative directory.\n  cp \"$am_depcomp\" conftest.dir\n  cd conftest.dir\n  # We will build objects and dependencies in a subdirectory because\n  # it helps to detect inapplicable dependency modes.  For instance\n  # both Tru64's cc and ICC support -MD to output dependencies as a\n  # side effect of compilation, but ICC will put the dependencies in\n  # the current directory while Tru64 will put them in the object\n  # directory.\n  mkdir sub\n\n  am_cv_$1_dependencies_compiler_type=none\n  if test \"$am_compiler_list\" = \"\"; then\n     am_compiler_list=`sed -n ['s/^#*\\([a-zA-Z0-9]*\\))$/\\1/p'] < ./depcomp`\n  fi\n  am__universal=false\n  m4_case([$1], [CC],\n    [case \" $depcc \" in #(\n     *\\ -arch\\ *\\ -arch\\ *) am__universal=true ;;\n     esac],\n    [CXX],\n    [case \" $depcc \" in #(\n     *\\ -arch\\ *\\ -arch\\ *) am__universal=true ;;\n     esac])\n\n  for depmode in $am_compiler_list; do\n    # Setup a source with many dependencies, because some compilers\n    # like to wrap large dependency lists on column 80 (with \\), and\n    # we should not choose a depcomp mode which is confused by this.\n    #\n    # We need to recreate these files for each test, as the compiler may\n    # overwrite some of them when testing with obscure command lines.\n    # This happens at least with the AIX C compiler.\n    : > sub/conftest.c\n    for i in 1 2 3 4 5 6; do\n      echo '#include \"conftst'$i'.h\"' >> sub/conftest.c\n      # Using `: > sub/conftst$i.h' creates only sub/conftst1.h with\n      # Solaris 8's {/usr,}/bin/sh.\n      touch sub/conftst$i.h\n    done\n    echo \"${am__include} ${am__quote}sub/conftest.Po${am__quote}\" > confmf\n\n    # We check with `-c' and `-o' for the sake of the \"dashmstdout\"\n    # mode.  It turns out that the SunPro C++ compiler does not properly\n    # handle `-M -o', and we need to detect this.  Also, some Intel\n    # versions had trouble with output in subdirs\n    am__obj=sub/conftest.${OBJEXT-o}\n    am__minus_obj=\"-o $am__obj\"\n    case $depmode in\n    gcc)\n      # This depmode causes a compiler race in universal mode.\n      test \"$am__universal\" = false || continue\n      ;;\n    nosideeffect)\n      # after this tag, mechanisms are not by side-effect, so they'll\n      # only be used when explicitly requested\n      if test \"x$enable_dependency_tracking\" = xyes; then\n\tcontinue\n      else\n\tbreak\n      fi\n      ;;\n    msvc7 | msvc7msys | msvisualcpp | msvcmsys)\n      # This compiler won't grok `-c -o', but also, the minuso test has\n      # not run yet.  These depmodes are late enough in the game, and\n      # so weak that their functioning should not be impacted.\n      am__obj=conftest.${OBJEXT-o}\n      am__minus_obj=\n      ;;\n    none) break ;;\n    esac\n    if depmode=$depmode \\\n       source=sub/conftest.c object=$am__obj \\\n       depfile=sub/conftest.Po tmpdepfile=sub/conftest.TPo \\\n       $SHELL ./depcomp $depcc -c $am__minus_obj sub/conftest.c \\\n         >/dev/null 2>conftest.err &&\n       grep sub/conftst1.h sub/conftest.Po > /dev/null 2>&1 &&\n       grep sub/conftst6.h sub/conftest.Po > /dev/null 2>&1 &&\n       grep $am__obj sub/conftest.Po > /dev/null 2>&1 &&\n       ${MAKE-make} -s -f confmf > /dev/null 2>&1; then\n      # icc doesn't choke on unknown options, it will just issue warnings\n      # or remarks (even with -Werror).  So we grep stderr for any message\n      # that says an option was ignored or not supported.\n      # When given -MP, icc 7.0 and 7.1 complain thusly:\n      #   icc: Command line warning: ignoring option '-M'; no argument required\n      # The diagnosis changed in icc 8.0:\n      #   icc: Command line remark: option '-MP' not supported\n      if (grep 'ignoring option' conftest.err ||\n          grep 'not supported' conftest.err) >/dev/null 2>&1; then :; else\n        am_cv_$1_dependencies_compiler_type=$depmode\n        break\n      fi\n    fi\n  done\n\n  cd ..\n  rm -rf conftest.dir\nelse\n  am_cv_$1_dependencies_compiler_type=none\nfi\n])\nAC_SUBST([$1DEPMODE], [depmode=$am_cv_$1_dependencies_compiler_type])\nAM_CONDITIONAL([am__fastdep$1], [\n  test \"x$enable_dependency_tracking\" != xno \\\n  && test \"$am_cv_$1_dependencies_compiler_type\" = gcc3])\n])\n\n\n# AM_SET_DEPDIR\n# -------------\n# Choose a directory name for dependency files.\n# This macro is AC_REQUIREd in _AM_DEPENDENCIES\nAC_DEFUN([AM_SET_DEPDIR],\n[AC_REQUIRE([AM_SET_LEADING_DOT])dnl\nAC_SUBST([DEPDIR], [\"${am__leading_dot}deps\"])dnl\n])\n\n\n# AM_DEP_TRACK\n# ------------\nAC_DEFUN([AM_DEP_TRACK],\n[AC_ARG_ENABLE(dependency-tracking,\n[  --disable-dependency-tracking  speeds up one-time build\n  --enable-dependency-tracking   do not reject slow dependency extractors])\nif test \"x$enable_dependency_tracking\" != xno; then\n  am_depcomp=\"$ac_aux_dir/depcomp\"\n  AMDEPBACKSLASH='\\'\n  am__nodep='_no'\nfi\nAM_CONDITIONAL([AMDEP], [test \"x$enable_dependency_tracking\" != xno])\nAC_SUBST([AMDEPBACKSLASH])dnl\n_AM_SUBST_NOTMAKE([AMDEPBACKSLASH])dnl\nAC_SUBST([am__nodep])dnl\n_AM_SUBST_NOTMAKE([am__nodep])dnl\n])\n\n# Generate code to set up dependency tracking.              -*- Autoconf -*-\n\n# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2008\n# Free Software Foundation, Inc.\n#\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n#serial 5\n\n# _AM_OUTPUT_DEPENDENCY_COMMANDS\n# ------------------------------\nAC_DEFUN([_AM_OUTPUT_DEPENDENCY_COMMANDS],\n[{\n  # Autoconf 2.62 quotes --file arguments for eval, but not when files\n  # are listed without --file.  Let's play safe and only enable the eval\n  # if we detect the quoting.\n  case $CONFIG_FILES in\n  *\\'*) eval set x \"$CONFIG_FILES\" ;;\n  *)   set x $CONFIG_FILES ;;\n  esac\n  shift\n  for mf\n  do\n    # Strip MF so we end up with the name of the file.\n    mf=`echo \"$mf\" | sed -e 's/:.*$//'`\n    # Check whether this is an Automake generated Makefile or not.\n    # We used to match only the files named `Makefile.in', but\n    # some people rename them; so instead we look at the file content.\n    # Grep'ing the first line is not enough: some people post-process\n    # each Makefile.in and add a new line on top of each file to say so.\n    # Grep'ing the whole file is not good either: AIX grep has a line\n    # limit of 2048, but all sed's we know have understand at least 4000.\n    if sed -n 's,^#.*generated by automake.*,X,p' \"$mf\" | grep X >/dev/null 2>&1; then\n      dirpart=`AS_DIRNAME(\"$mf\")`\n    else\n      continue\n    fi\n    # Extract the definition of DEPDIR, am__include, and am__quote\n    # from the Makefile without running `make'.\n    DEPDIR=`sed -n 's/^DEPDIR = //p' < \"$mf\"`\n    test -z \"$DEPDIR\" && continue\n    am__include=`sed -n 's/^am__include = //p' < \"$mf\"`\n    test -z \"am__include\" && continue\n    am__quote=`sed -n 's/^am__quote = //p' < \"$mf\"`\n    # When using ansi2knr, U may be empty or an underscore; expand it\n    U=`sed -n 's/^U = //p' < \"$mf\"`\n    # Find all dependency output files, they are included files with\n    # $(DEPDIR) in their names.  We invoke sed twice because it is the\n    # simplest approach to changing $(DEPDIR) to its actual value in the\n    # expansion.\n    for file in `sed -n \"\n      s/^$am__include $am__quote\\(.*(DEPDIR).*\\)$am__quote\"'$/\\1/p' <\"$mf\" | \\\n\t sed -e 's/\\$(DEPDIR)/'\"$DEPDIR\"'/g' -e 's/\\$U/'\"$U\"'/g'`; do\n      # Make sure the directory exists.\n      test -f \"$dirpart/$file\" && continue\n      fdir=`AS_DIRNAME([\"$file\"])`\n      AS_MKDIR_P([$dirpart/$fdir])\n      # echo \"creating $dirpart/$file\"\n      echo '# dummy' > \"$dirpart/$file\"\n    done\n  done\n}\n])# _AM_OUTPUT_DEPENDENCY_COMMANDS\n\n\n# AM_OUTPUT_DEPENDENCY_COMMANDS\n# -----------------------------\n# This macro should only be invoked once -- use via AC_REQUIRE.\n#\n# This code is only required when automatic dependency tracking\n# is enabled.  FIXME.  This creates each `.P' file that we will\n# need in order to bootstrap the dependency handling code.\nAC_DEFUN([AM_OUTPUT_DEPENDENCY_COMMANDS],\n[AC_CONFIG_COMMANDS([depfiles],\n     [test x\"$AMDEP_TRUE\" != x\"\" || _AM_OUTPUT_DEPENDENCY_COMMANDS],\n     [AMDEP_TRUE=\"$AMDEP_TRUE\" ac_aux_dir=\"$ac_aux_dir\"])\n])\n\n# Do all the work for Automake.                             -*- Autoconf -*-\n\n# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,\n# 2005, 2006, 2008, 2009 Free Software Foundation, Inc.\n#\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n# serial 16\n\n# This macro actually does too much.  Some checks are only needed if\n# your package does certain things.  But this isn't really a big deal.\n\n# AM_INIT_AUTOMAKE(PACKAGE, VERSION, [NO-DEFINE])\n# AM_INIT_AUTOMAKE([OPTIONS])\n# -----------------------------------------------\n# The call with PACKAGE and VERSION arguments is the old style\n# call (pre autoconf-2.50), which is being phased out.  PACKAGE\n# and VERSION should now be passed to AC_INIT and removed from\n# the call to AM_INIT_AUTOMAKE.\n# We support both call styles for the transition.  After\n# the next Automake release, Autoconf can make the AC_INIT\n# arguments mandatory, and then we can depend on a new Autoconf\n# release and drop the old call support.\nAC_DEFUN([AM_INIT_AUTOMAKE],\n[AC_PREREQ([2.62])dnl\ndnl Autoconf wants to disallow AM_ names.  We explicitly allow\ndnl the ones we care about.\nm4_pattern_allow([^AM_[A-Z]+FLAGS$])dnl\nAC_REQUIRE([AM_SET_CURRENT_AUTOMAKE_VERSION])dnl\nAC_REQUIRE([AC_PROG_INSTALL])dnl\nif test \"`cd $srcdir && pwd`\" != \"`pwd`\"; then\n  # Use -I$(srcdir) only when $(srcdir) != ., so that make's output\n  # is not polluted with repeated \"-I.\"\n  AC_SUBST([am__isrc], [' -I$(srcdir)'])_AM_SUBST_NOTMAKE([am__isrc])dnl\n  # test to see if srcdir already configured\n  if test -f $srcdir/config.status; then\n    AC_MSG_ERROR([source directory already configured; run \"make distclean\" there first])\n  fi\nfi\n\n# test whether we have cygpath\nif test -z \"$CYGPATH_W\"; then\n  if (cygpath --version) >/dev/null 2>/dev/null; then\n    CYGPATH_W='cygpath -w'\n  else\n    CYGPATH_W=echo\n  fi\nfi\nAC_SUBST([CYGPATH_W])\n\n# Define the identity of the package.\ndnl Distinguish between old-style and new-style calls.\nm4_ifval([$2],\n[m4_ifval([$3], [_AM_SET_OPTION([no-define])])dnl\n AC_SUBST([PACKAGE], [$1])dnl\n AC_SUBST([VERSION], [$2])],\n[_AM_SET_OPTIONS([$1])dnl\ndnl Diagnose old-style AC_INIT with new-style AM_AUTOMAKE_INIT.\nm4_if(m4_ifdef([AC_PACKAGE_NAME], 1)m4_ifdef([AC_PACKAGE_VERSION], 1), 11,,\n  [m4_fatal([AC_INIT should be called with package and version arguments])])dnl\n AC_SUBST([PACKAGE], ['AC_PACKAGE_TARNAME'])dnl\n AC_SUBST([VERSION], ['AC_PACKAGE_VERSION'])])dnl\n\n_AM_IF_OPTION([no-define],,\n[AC_DEFINE_UNQUOTED(PACKAGE, \"$PACKAGE\", [Name of package])\n AC_DEFINE_UNQUOTED(VERSION, \"$VERSION\", [Version number of package])])dnl\n\n# Some tools Automake needs.\nAC_REQUIRE([AM_SANITY_CHECK])dnl\nAC_REQUIRE([AC_ARG_PROGRAM])dnl\nAM_MISSING_PROG(ACLOCAL, aclocal-${am__api_version})\nAM_MISSING_PROG(AUTOCONF, autoconf)\nAM_MISSING_PROG(AUTOMAKE, automake-${am__api_version})\nAM_MISSING_PROG(AUTOHEADER, autoheader)\nAM_MISSING_PROG(MAKEINFO, makeinfo)\nAC_REQUIRE([AM_PROG_INSTALL_SH])dnl\nAC_REQUIRE([AM_PROG_INSTALL_STRIP])dnl\nAC_REQUIRE([AM_PROG_MKDIR_P])dnl\n# We need awk for the \"check\" target.  The system \"awk\" is bad on\n# some platforms.\nAC_REQUIRE([AC_PROG_AWK])dnl\nAC_REQUIRE([AC_PROG_MAKE_SET])dnl\nAC_REQUIRE([AM_SET_LEADING_DOT])dnl\n_AM_IF_OPTION([tar-ustar], [_AM_PROG_TAR([ustar])],\n\t      [_AM_IF_OPTION([tar-pax], [_AM_PROG_TAR([pax])],\n\t\t\t     [_AM_PROG_TAR([v7])])])\n_AM_IF_OPTION([no-dependencies],,\n[AC_PROVIDE_IFELSE([AC_PROG_CC],\n\t\t  [_AM_DEPENDENCIES(CC)],\n\t\t  [define([AC_PROG_CC],\n\t\t\t  defn([AC_PROG_CC])[_AM_DEPENDENCIES(CC)])])dnl\nAC_PROVIDE_IFELSE([AC_PROG_CXX],\n\t\t  [_AM_DEPENDENCIES(CXX)],\n\t\t  [define([AC_PROG_CXX],\n\t\t\t  defn([AC_PROG_CXX])[_AM_DEPENDENCIES(CXX)])])dnl\nAC_PROVIDE_IFELSE([AC_PROG_OBJC],\n\t\t  [_AM_DEPENDENCIES(OBJC)],\n\t\t  [define([AC_PROG_OBJC],\n\t\t\t  defn([AC_PROG_OBJC])[_AM_DEPENDENCIES(OBJC)])])dnl\n])\n_AM_IF_OPTION([silent-rules], [AC_REQUIRE([AM_SILENT_RULES])])dnl\ndnl The `parallel-tests' driver may need to know about EXEEXT, so add the\ndnl `am__EXEEXT' conditional if _AM_COMPILER_EXEEXT was seen.  This macro\ndnl is hooked onto _AC_COMPILER_EXEEXT early, see below.\nAC_CONFIG_COMMANDS_PRE(dnl\n[m4_provide_if([_AM_COMPILER_EXEEXT],\n  [AM_CONDITIONAL([am__EXEEXT], [test -n \"$EXEEXT\"])])])dnl\n])\n\ndnl Hook into `_AC_COMPILER_EXEEXT' early to learn its expansion.  Do not\ndnl add the conditional right here, as _AC_COMPILER_EXEEXT may be further\ndnl mangled by Autoconf and run in a shell conditional statement.\nm4_define([_AC_COMPILER_EXEEXT],\nm4_defn([_AC_COMPILER_EXEEXT])[m4_provide([_AM_COMPILER_EXEEXT])])\n\n\n# When config.status generates a header, we must update the stamp-h file.\n# This file resides in the same directory as the config header\n# that is generated.  The stamp files are numbered to have different names.\n\n# Autoconf calls _AC_AM_CONFIG_HEADER_HOOK (when defined) in the\n# loop where config.status creates the headers, so we can generate\n# our stamp files there.\nAC_DEFUN([_AC_AM_CONFIG_HEADER_HOOK],\n[# Compute $1's index in $config_headers.\n_am_arg=$1\n_am_stamp_count=1\nfor _am_header in $config_headers :; do\n  case $_am_header in\n    $_am_arg | $_am_arg:* )\n      break ;;\n    * )\n      _am_stamp_count=`expr $_am_stamp_count + 1` ;;\n  esac\ndone\necho \"timestamp for $_am_arg\" >`AS_DIRNAME([\"$_am_arg\"])`/stamp-h[]$_am_stamp_count])\n\n# Copyright (C) 2001, 2003, 2005, 2008, 2011 Free Software Foundation,\n# Inc.\n#\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n# serial 1\n\n# AM_PROG_INSTALL_SH\n# ------------------\n# Define $install_sh.\nAC_DEFUN([AM_PROG_INSTALL_SH],\n[AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl\nif test x\"${install_sh}\" != xset; then\n  case $am_aux_dir in\n  *\\ * | *\\\t*)\n    install_sh=\"\\${SHELL} '$am_aux_dir/install-sh'\" ;;\n  *)\n    install_sh=\"\\${SHELL} $am_aux_dir/install-sh\"\n  esac\nfi\nAC_SUBST(install_sh)])\n\n# Copyright (C) 2003, 2005  Free Software Foundation, Inc.\n#\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n# serial 2\n\n# Check whether the underlying file-system supports filenames\n# with a leading dot.  For instance MS-DOS doesn't.\nAC_DEFUN([AM_SET_LEADING_DOT],\n[rm -rf .tst 2>/dev/null\nmkdir .tst 2>/dev/null\nif test -d .tst; then\n  am__leading_dot=.\nelse\n  am__leading_dot=_\nfi\nrmdir .tst 2>/dev/null\nAC_SUBST([am__leading_dot])])\n\n# Check to see how 'make' treats includes.\t            -*- Autoconf -*-\n\n# Copyright (C) 2001, 2002, 2003, 2005, 2009  Free Software Foundation, Inc.\n#\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n# serial 4\n\n# AM_MAKE_INCLUDE()\n# -----------------\n# Check to see how make treats includes.\nAC_DEFUN([AM_MAKE_INCLUDE],\n[am_make=${MAKE-make}\ncat > confinc << 'END'\nam__doit:\n\t@echo this is the am__doit target\n.PHONY: am__doit\nEND\n# If we don't find an include directive, just comment out the code.\nAC_MSG_CHECKING([for style of include used by $am_make])\nam__include=\"#\"\nam__quote=\n_am_result=none\n# First try GNU make style include.\necho \"include confinc\" > confmf\n# Ignore all kinds of additional output from `make'.\ncase `$am_make -s -f confmf 2> /dev/null` in #(\n*the\\ am__doit\\ target*)\n  am__include=include\n  am__quote=\n  _am_result=GNU\n  ;;\nesac\n# Now try BSD make style include.\nif test \"$am__include\" = \"#\"; then\n   echo '.include \"confinc\"' > confmf\n   case `$am_make -s -f confmf 2> /dev/null` in #(\n   *the\\ am__doit\\ target*)\n     am__include=.include\n     am__quote=\"\\\"\"\n     _am_result=BSD\n     ;;\n   esac\nfi\nAC_SUBST([am__include])\nAC_SUBST([am__quote])\nAC_MSG_RESULT([$_am_result])\nrm -f confinc confmf\n])\n\n# Fake the existence of programs that GNU maintainers use.  -*- Autoconf -*-\n\n# Copyright (C) 1997, 1999, 2000, 2001, 2003, 2004, 2005, 2008\n# Free Software Foundation, Inc.\n#\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n# serial 6\n\n# AM_MISSING_PROG(NAME, PROGRAM)\n# ------------------------------\nAC_DEFUN([AM_MISSING_PROG],\n[AC_REQUIRE([AM_MISSING_HAS_RUN])\n$1=${$1-\"${am_missing_run}$2\"}\nAC_SUBST($1)])\n\n\n# AM_MISSING_HAS_RUN\n# ------------------\n# Define MISSING if not defined so far and test if it supports --run.\n# If it does, set am_missing_run to use it, otherwise, to nothing.\nAC_DEFUN([AM_MISSING_HAS_RUN],\n[AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl\nAC_REQUIRE_AUX_FILE([missing])dnl\nif test x\"${MISSING+set}\" != xset; then\n  case $am_aux_dir in\n  *\\ * | *\\\t*)\n    MISSING=\"\\${SHELL} \\\"$am_aux_dir/missing\\\"\" ;;\n  *)\n    MISSING=\"\\${SHELL} $am_aux_dir/missing\" ;;\n  esac\nfi\n# Use eval to expand $SHELL\nif eval \"$MISSING --run true\"; then\n  am_missing_run=\"$MISSING --run \"\nelse\n  am_missing_run=\n  AC_MSG_WARN([`missing' script is too old or missing])\nfi\n])\n\n# Copyright (C) 2003, 2004, 2005, 2006, 2011 Free Software Foundation,\n# Inc.\n#\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n# serial 1\n\n# AM_PROG_MKDIR_P\n# ---------------\n# Check for `mkdir -p'.\nAC_DEFUN([AM_PROG_MKDIR_P],\n[AC_PREREQ([2.60])dnl\nAC_REQUIRE([AC_PROG_MKDIR_P])dnl\ndnl Automake 1.8 to 1.9.6 used to define mkdir_p.  We now use MKDIR_P,\ndnl while keeping a definition of mkdir_p for backward compatibility.\ndnl @MKDIR_P@ is magic: AC_OUTPUT adjusts its value for each Makefile.\ndnl However we cannot define mkdir_p as $(MKDIR_P) for the sake of\ndnl Makefile.ins that do not define MKDIR_P, so we do our own\ndnl adjustment using top_builddir (which is defined more often than\ndnl MKDIR_P).\nAC_SUBST([mkdir_p], [\"$MKDIR_P\"])dnl\ncase $mkdir_p in\n  [[\\\\/$]]* | ?:[[\\\\/]]*) ;;\n  */*) mkdir_p=\"\\$(top_builddir)/$mkdir_p\" ;;\nesac\n])\n\n# Helper functions for option handling.                     -*- Autoconf -*-\n\n# Copyright (C) 2001, 2002, 2003, 2005, 2008, 2010 Free Software\n# Foundation, Inc.\n#\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n# serial 5\n\n# _AM_MANGLE_OPTION(NAME)\n# -----------------------\nAC_DEFUN([_AM_MANGLE_OPTION],\n[[_AM_OPTION_]m4_bpatsubst($1, [[^a-zA-Z0-9_]], [_])])\n\n# _AM_SET_OPTION(NAME)\n# --------------------\n# Set option NAME.  Presently that only means defining a flag for this option.\nAC_DEFUN([_AM_SET_OPTION],\n[m4_define(_AM_MANGLE_OPTION([$1]), 1)])\n\n# _AM_SET_OPTIONS(OPTIONS)\n# ------------------------\n# OPTIONS is a space-separated list of Automake options.\nAC_DEFUN([_AM_SET_OPTIONS],\n[m4_foreach_w([_AM_Option], [$1], [_AM_SET_OPTION(_AM_Option)])])\n\n# _AM_IF_OPTION(OPTION, IF-SET, [IF-NOT-SET])\n# -------------------------------------------\n# Execute IF-SET if OPTION is set, IF-NOT-SET otherwise.\nAC_DEFUN([_AM_IF_OPTION],\n[m4_ifset(_AM_MANGLE_OPTION([$1]), [$2], [$3])])\n\n# Check to make sure that the build environment is sane.    -*- Autoconf -*-\n\n# Copyright (C) 1996, 1997, 2000, 2001, 2003, 2005, 2008\n# Free Software Foundation, Inc.\n#\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n# serial 5\n\n# AM_SANITY_CHECK\n# ---------------\nAC_DEFUN([AM_SANITY_CHECK],\n[AC_MSG_CHECKING([whether build environment is sane])\n# Just in case\nsleep 1\necho timestamp > conftest.file\n# Reject unsafe characters in $srcdir or the absolute working directory\n# name.  Accept space and tab only in the latter.\nam_lf='\n'\ncase `pwd` in\n  *[[\\\\\\\"\\#\\$\\&\\'\\`$am_lf]]*)\n    AC_MSG_ERROR([unsafe absolute working directory name]);;\nesac\ncase $srcdir in\n  *[[\\\\\\\"\\#\\$\\&\\'\\`$am_lf\\ \\\t]]*)\n    AC_MSG_ERROR([unsafe srcdir value: `$srcdir']);;\nesac\n\n# Do `set' in a subshell so we don't clobber the current shell's\n# arguments.  Must try -L first in case configure is actually a\n# symlink; some systems play weird games with the mod time of symlinks\n# (eg FreeBSD returns the mod time of the symlink's containing\n# directory).\nif (\n   set X `ls -Lt \"$srcdir/configure\" conftest.file 2> /dev/null`\n   if test \"$[*]\" = \"X\"; then\n      # -L didn't work.\n      set X `ls -t \"$srcdir/configure\" conftest.file`\n   fi\n   rm -f conftest.file\n   if test \"$[*]\" != \"X $srcdir/configure conftest.file\" \\\n      && test \"$[*]\" != \"X conftest.file $srcdir/configure\"; then\n\n      # If neither matched, then we have a broken ls.  This can happen\n      # if, for instance, CONFIG_SHELL is bash and it inherits a\n      # broken ls alias from the environment.  This has actually\n      # happened.  Such a system could not be considered \"sane\".\n      AC_MSG_ERROR([ls -t appears to fail.  Make sure there is not a broken\nalias in your environment])\n   fi\n\n   test \"$[2]\" = conftest.file\n   )\nthen\n   # Ok.\n   :\nelse\n   AC_MSG_ERROR([newly created file is older than distributed files!\nCheck your system clock])\nfi\nAC_MSG_RESULT(yes)])\n\n# Copyright (C) 2001, 2003, 2005, 2011 Free Software Foundation, Inc.\n#\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n# serial 1\n\n# AM_PROG_INSTALL_STRIP\n# ---------------------\n# One issue with vendor `install' (even GNU) is that you can't\n# specify the program used to strip binaries.  This is especially\n# annoying in cross-compiling environments, where the build's strip\n# is unlikely to handle the host's binaries.\n# Fortunately install-sh will honor a STRIPPROG variable, so we\n# always use install-sh in `make install-strip', and initialize\n# STRIPPROG with the value of the STRIP variable (set by the user).\nAC_DEFUN([AM_PROG_INSTALL_STRIP],\n[AC_REQUIRE([AM_PROG_INSTALL_SH])dnl\n# Installed binaries are usually stripped using `strip' when the user\n# run `make install-strip'.  However `strip' might not be the right\n# tool to use in cross-compilation environments, therefore Automake\n# will honor the `STRIP' environment variable to overrule this program.\ndnl Don't test for $cross_compiling = yes, because it might be `maybe'.\nif test \"$cross_compiling\" != no; then\n  AC_CHECK_TOOL([STRIP], [strip], :)\nfi\nINSTALL_STRIP_PROGRAM=\"\\$(install_sh) -c -s\"\nAC_SUBST([INSTALL_STRIP_PROGRAM])])\n\n# Copyright (C) 2006, 2008, 2010 Free Software Foundation, Inc.\n#\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n# serial 3\n\n# _AM_SUBST_NOTMAKE(VARIABLE)\n# ---------------------------\n# Prevent Automake from outputting VARIABLE = @VARIABLE@ in Makefile.in.\n# This macro is traced by Automake.\nAC_DEFUN([_AM_SUBST_NOTMAKE])\n\n# AM_SUBST_NOTMAKE(VARIABLE)\n# --------------------------\n# Public sister of _AM_SUBST_NOTMAKE.\nAC_DEFUN([AM_SUBST_NOTMAKE], [_AM_SUBST_NOTMAKE($@)])\n\n# Check how to create a tarball.                            -*- Autoconf -*-\n\n# Copyright (C) 2004, 2005, 2012 Free Software Foundation, Inc.\n#\n# This file is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n# serial 2\n\n# _AM_PROG_TAR(FORMAT)\n# --------------------\n# Check how to create a tarball in format FORMAT.\n# FORMAT should be one of `v7', `ustar', or `pax'.\n#\n# Substitute a variable $(am__tar) that is a command\n# writing to stdout a FORMAT-tarball containing the directory\n# $tardir.\n#     tardir=directory && $(am__tar) > result.tar\n#\n# Substitute a variable $(am__untar) that extract such\n# a tarball read from stdin.\n#     $(am__untar) < result.tar\nAC_DEFUN([_AM_PROG_TAR],\n[# Always define AMTAR for backward compatibility.  Yes, it's still used\n# in the wild :-(  We should find a proper way to deprecate it ...\nAC_SUBST([AMTAR], ['$${TAR-tar}'])\nm4_if([$1], [v7],\n     [am__tar='$${TAR-tar} chof - \"$$tardir\"' am__untar='$${TAR-tar} xf -'],\n     [m4_case([$1], [ustar],, [pax],,\n              [m4_fatal([Unknown tar format])])\nAC_MSG_CHECKING([how to create a $1 tar archive])\n# Loop over all known methods to create a tar archive until one works.\n_am_tools='gnutar m4_if([$1], [ustar], [plaintar]) pax cpio none'\n_am_tools=${am_cv_prog_tar_$1-$_am_tools}\n# Do not fold the above two line into one, because Tru64 sh and\n# Solaris sh will not grok spaces in the rhs of `-'.\nfor _am_tool in $_am_tools\ndo\n  case $_am_tool in\n  gnutar)\n    for _am_tar in tar gnutar gtar;\n    do\n      AM_RUN_LOG([$_am_tar --version]) && break\n    done\n    am__tar=\"$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - \"'\"$$tardir\"'\n    am__tar_=\"$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - \"'\"$tardir\"'\n    am__untar=\"$_am_tar -xf -\"\n    ;;\n  plaintar)\n    # Must skip GNU tar: if it does not support --format= it doesn't create\n    # ustar tarball either.\n    (tar --version) >/dev/null 2>&1 && continue\n    am__tar='tar chf - \"$$tardir\"'\n    am__tar_='tar chf - \"$tardir\"'\n    am__untar='tar xf -'\n    ;;\n  pax)\n    am__tar='pax -L -x $1 -w \"$$tardir\"'\n    am__tar_='pax -L -x $1 -w \"$tardir\"'\n    am__untar='pax -r'\n    ;;\n  cpio)\n    am__tar='find \"$$tardir\" -print | cpio -o -H $1 -L'\n    am__tar_='find \"$tardir\" -print | cpio -o -H $1 -L'\n    am__untar='cpio -i -H $1 -d'\n    ;;\n  none)\n    am__tar=false\n    am__tar_=false\n    am__untar=false\n    ;;\n  esac\n\n  # If the value was cached, stop now.  We just wanted to have am__tar\n  # and am__untar set.\n  test -n \"${am_cv_prog_tar_$1}\" && break\n\n  # tar/untar a dummy directory, and stop if the command works\n  rm -rf conftest.dir\n  mkdir conftest.dir\n  echo GrepMe > conftest.dir/file\n  AM_RUN_LOG([tardir=conftest.dir && eval $am__tar_ >conftest.tar])\n  rm -rf conftest.dir\n  if test -s conftest.tar; then\n    AM_RUN_LOG([$am__untar <conftest.tar])\n    grep GrepMe conftest.dir/file >/dev/null 2>&1 && break\n  fi\ndone\nrm -rf conftest.dir\n\nAC_CACHE_VAL([am_cv_prog_tar_$1], [am_cv_prog_tar_$1=$_am_tool])\nAC_MSG_RESULT([$am_cv_prog_tar_$1])])\nAC_SUBST([am__tar])\nAC_SUBST([am__untar])\n]) # _AM_PROG_TAR\n\nm4_include([m4/gtest.m4])\n",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/tokudb/PerconaFT/third_party/xz-4.999.9beta/m4/libtool.m4": "# libtool.m4 - Configure libtool for the host system. -*-Autoconf-*-\n#\n#   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005,\n#                 2006, 2007, 2008 Free Software Foundation, Inc.\n#   Written by Gordon Matzigkeit, 1996\n#\n# This file is free software; the Free Software Foundation gives\n# unlimited permission to copy and/or distribute it, with or without\n# modifications, as long as this notice is preserved.\n\nm4_define([_LT_COPYING], [dnl\n#   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005,\n#                 2006, 2007, 2008 Free Software Foundation, Inc.\n#   Written by Gordon Matzigkeit, 1996\n#\n#   This file is part of GNU Libtool.\n#\n# GNU Libtool is free software; you can redistribute it and/or\n# modify it under the terms of the GNU General Public License as\n# published by the Free Software Foundation; either version 2 of\n# the License, or (at your option) any later version.\n#\n# As a special exception to the GNU General Public License,\n# if you distribute this file as part of a program or library that\n# is built using GNU Libtool, you may include this file under the\n# same distribution terms that you use for the rest of that program.\n#\n# GNU Libtool is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with GNU Libtool; see the file COPYING.  If not, a copy\n# can be downloaded from http://www.gnu.org/licenses/gpl.html, or\n# obtained by writing to the Free Software Foundation, Inc.,\n# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1335  USA.\n])\n\n# serial 56 LT_INIT\n\n\n# LT_PREREQ(VERSION)\n# ------------------\n# Complain and exit if this libtool version is less that VERSION.\nm4_defun([LT_PREREQ],\n[m4_if(m4_version_compare(m4_defn([LT_PACKAGE_VERSION]), [$1]), -1,\n       [m4_default([$3],\n\t\t   [m4_fatal([Libtool version $1 or higher is required],\n\t\t             63)])],\n       [$2])])\n\n\n# _LT_CHECK_BUILDDIR\n# ------------------\n# Complain if the absolute build directory name contains unusual characters\nm4_defun([_LT_CHECK_BUILDDIR],\n[case `pwd` in\n  *\\ * | *\\\t*)\n    AC_MSG_WARN([Libtool does not cope well with whitespace in `pwd`]) ;;\nesac\n])\n\n\n# LT_INIT([OPTIONS])\n# ------------------\nAC_DEFUN([LT_INIT],\n[AC_PREREQ([2.58])dnl We use AC_INCLUDES_DEFAULT\nAC_BEFORE([$0], [LT_LANG])dnl\nAC_BEFORE([$0], [LT_OUTPUT])dnl\nAC_BEFORE([$0], [LTDL_INIT])dnl\nm4_require([_LT_CHECK_BUILDDIR])dnl\n\ndnl Autoconf doesn't catch unexpanded LT_ macros by default:\nm4_pattern_forbid([^_?LT_[A-Z_]+$])dnl\nm4_pattern_allow([^(_LT_EOF|LT_DLGLOBAL|LT_DLLAZY_OR_NOW|LT_MULTI_MODULE)$])dnl\ndnl aclocal doesn't pull ltoptions.m4, ltsugar.m4, or ltversion.m4\ndnl unless we require an AC_DEFUNed macro:\nAC_REQUIRE([LTOPTIONS_VERSION])dnl\nAC_REQUIRE([LTSUGAR_VERSION])dnl\nAC_REQUIRE([LTVERSION_VERSION])dnl\nAC_REQUIRE([LTOBSOLETE_VERSION])dnl\nm4_require([_LT_PROG_LTMAIN])dnl\n\ndnl Parse OPTIONS\n_LT_SET_OPTIONS([$0], [$1])\n\n# This can be used to rebuild libtool when needed\nLIBTOOL_DEPS=\"$ltmain\"\n\n# Always use our own libtool.\nLIBTOOL='$(SHELL) $(top_builddir)/libtool'\nAC_SUBST(LIBTOOL)dnl\n\n_LT_SETUP\n\n# Only expand once:\nm4_define([LT_INIT])\n])# LT_INIT\n\n# Old names:\nAU_ALIAS([AC_PROG_LIBTOOL], [LT_INIT])\nAU_ALIAS([AM_PROG_LIBTOOL], [LT_INIT])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_PROG_LIBTOOL], [])\ndnl AC_DEFUN([AM_PROG_LIBTOOL], [])\n\n\n# _LT_CC_BASENAME(CC)\n# -------------------\n# Calculate cc_basename.  Skip known compiler wrappers and cross-prefix.\nm4_defun([_LT_CC_BASENAME],\n[for cc_temp in $1\"\"; do\n  case $cc_temp in\n    compile | *[[\\\\/]]compile | ccache | *[[\\\\/]]ccache ) ;;\n    distcc | *[[\\\\/]]distcc | purify | *[[\\\\/]]purify ) ;;\n    \\-*) ;;\n    *) break;;\n  esac\ndone\ncc_basename=`$ECHO \"X$cc_temp\" | $Xsed -e 's%.*/%%' -e \"s%^$host_alias-%%\"`\n])\n\n\n# _LT_FILEUTILS_DEFAULTS\n# ----------------------\n# It is okay to use these file commands and assume they have been set\n# sensibly after `m4_require([_LT_FILEUTILS_DEFAULTS])'.\nm4_defun([_LT_FILEUTILS_DEFAULTS],\n[: ${CP=\"cp -f\"}\n: ${MV=\"mv -f\"}\n: ${RM=\"rm -f\"}\n])# _LT_FILEUTILS_DEFAULTS\n\n\n# _LT_SETUP\n# ---------\nm4_defun([_LT_SETUP],\n[AC_REQUIRE([AC_CANONICAL_HOST])dnl\nAC_REQUIRE([AC_CANONICAL_BUILD])dnl\n_LT_DECL([], [host_alias], [0], [The host system])dnl\n_LT_DECL([], [host], [0])dnl\n_LT_DECL([], [host_os], [0])dnl\ndnl\n_LT_DECL([], [build_alias], [0], [The build system])dnl\n_LT_DECL([], [build], [0])dnl\n_LT_DECL([], [build_os], [0])dnl\ndnl\nAC_REQUIRE([AC_PROG_CC])dnl\nAC_REQUIRE([LT_PATH_LD])dnl\nAC_REQUIRE([LT_PATH_NM])dnl\ndnl\nAC_REQUIRE([AC_PROG_LN_S])dnl\ntest -z \"$LN_S\" && LN_S=\"ln -s\"\n_LT_DECL([], [LN_S], [1], [Whether we need soft or hard links])dnl\ndnl\nAC_REQUIRE([LT_CMD_MAX_LEN])dnl\n_LT_DECL([objext], [ac_objext], [0], [Object file suffix (normally \"o\")])dnl\n_LT_DECL([], [exeext], [0], [Executable file suffix (normally \"\")])dnl\ndnl\nm4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_CHECK_SHELL_FEATURES])dnl\nm4_require([_LT_CMD_RELOAD])dnl\nm4_require([_LT_CHECK_MAGIC_METHOD])dnl\nm4_require([_LT_CMD_OLD_ARCHIVE])dnl\nm4_require([_LT_CMD_GLOBAL_SYMBOLS])dnl\n\n_LT_CONFIG_LIBTOOL_INIT([\n# See if we are running on zsh, and set the options which allow our\n# commands through without removal of \\ escapes INIT.\nif test -n \"\\${ZSH_VERSION+set}\" ; then\n   setopt NO_GLOB_SUBST\nfi\n])\nif test -n \"${ZSH_VERSION+set}\" ; then\n   setopt NO_GLOB_SUBST\nfi\n\n_LT_CHECK_OBJDIR\n\nm4_require([_LT_TAG_COMPILER])dnl\n_LT_PROG_ECHO_BACKSLASH\n\ncase $host_os in\naix3*)\n  # AIX sometimes has problems with the GCC collect2 program.  For some\n  # reason, if we set the COLLECT_NAMES environment variable, the problems\n  # vanish in a puff of smoke.\n  if test \"X${COLLECT_NAMES+set}\" != Xset; then\n    COLLECT_NAMES=\n    export COLLECT_NAMES\n  fi\n  ;;\nesac\n\n# Sed substitution that helps us do robust quoting.  It backslashifies\n# metacharacters that are still active within double-quoted strings.\nsed_quote_subst='s/\\([[\"`$\\\\]]\\)/\\\\\\1/g'\n\n# Same as above, but do not quote variable references.\ndouble_quote_subst='s/\\([[\"`\\\\]]\\)/\\\\\\1/g'\n\n# Sed substitution to delay expansion of an escaped shell variable in a\n# double_quote_subst'ed string.\ndelay_variable_subst='s/\\\\\\\\\\\\\\\\\\\\\\$/\\\\\\\\\\\\$/g'\n\n# Sed substitution to delay expansion of an escaped single quote.\ndelay_single_quote_subst='s/'\\''/'\\'\\\\\\\\\\\\\\'\\''/g'\n\n# Sed substitution to avoid accidental globbing in evaled expressions\nno_glob_subst='s/\\*/\\\\\\*/g'\n\n# Global variables:\nofile=libtool\ncan_build_shared=yes\n\n# All known linkers require a `.a' archive for static linking (except MSVC,\n# which needs '.lib').\nlibext=a\n\nwith_gnu_ld=\"$lt_cv_prog_gnu_ld\"\n\nold_CC=\"$CC\"\nold_CFLAGS=\"$CFLAGS\"\n\n# Set sane defaults for various variables\ntest -z \"$CC\" && CC=cc\ntest -z \"$LTCC\" && LTCC=$CC\ntest -z \"$LTCFLAGS\" && LTCFLAGS=$CFLAGS\ntest -z \"$LD\" && LD=ld\ntest -z \"$ac_objext\" && ac_objext=o\n\n_LT_CC_BASENAME([$compiler])\n\n# Only perform the check for file, if the check method requires it\ntest -z \"$MAGIC_CMD\" && MAGIC_CMD=file\ncase $deplibs_check_method in\nfile_magic*)\n  if test \"$file_magic_cmd\" = '$MAGIC_CMD'; then\n    _LT_PATH_MAGIC\n  fi\n  ;;\nesac\n\n# Use C for the default configuration in the libtool script\nLT_SUPPORTED_TAG([CC])\n_LT_LANG_C_CONFIG\n_LT_LANG_DEFAULT_CONFIG\n_LT_CONFIG_COMMANDS\n])# _LT_SETUP\n\n\n# _LT_PROG_LTMAIN\n# ---------------\n# Note that this code is called both from `configure', and `config.status'\n# now that we use AC_CONFIG_COMMANDS to generate libtool.  Notably,\n# `config.status' has no value for ac_aux_dir unless we are using Automake,\n# so we pass a copy along to make sure it has a sensible value anyway.\nm4_defun([_LT_PROG_LTMAIN],\n[m4_ifdef([AC_REQUIRE_AUX_FILE], [AC_REQUIRE_AUX_FILE([ltmain.sh])])dnl\n_LT_CONFIG_LIBTOOL_INIT([ac_aux_dir='$ac_aux_dir'])\nltmain=\"$ac_aux_dir/ltmain.sh\"\n])# _LT_PROG_LTMAIN\n\n\n## ------------------------------------- ##\n## Accumulate code for creating libtool. ##\n## ------------------------------------- ##\n\n# So that we can recreate a full libtool script including additional\n# tags, we accumulate the chunks of code to send to AC_CONFIG_COMMANDS\n# in macros and then make a single call at the end using the `libtool'\n# label.\n\n\n# _LT_CONFIG_LIBTOOL_INIT([INIT-COMMANDS])\n# ----------------------------------------\n# Register INIT-COMMANDS to be passed to AC_CONFIG_COMMANDS later.\nm4_define([_LT_CONFIG_LIBTOOL_INIT],\n[m4_ifval([$1],\n          [m4_append([_LT_OUTPUT_LIBTOOL_INIT],\n                     [$1\n])])])\n\n# Initialize.\nm4_define([_LT_OUTPUT_LIBTOOL_INIT])\n\n\n# _LT_CONFIG_LIBTOOL([COMMANDS])\n# ------------------------------\n# Register COMMANDS to be passed to AC_CONFIG_COMMANDS later.\nm4_define([_LT_CONFIG_LIBTOOL],\n[m4_ifval([$1],\n          [m4_append([_LT_OUTPUT_LIBTOOL_COMMANDS],\n                     [$1\n])])])\n\n# Initialize.\nm4_define([_LT_OUTPUT_LIBTOOL_COMMANDS])\n\n\n# _LT_CONFIG_SAVE_COMMANDS([COMMANDS], [INIT_COMMANDS])\n# -----------------------------------------------------\nm4_defun([_LT_CONFIG_SAVE_COMMANDS],\n[_LT_CONFIG_LIBTOOL([$1])\n_LT_CONFIG_LIBTOOL_INIT([$2])\n])\n\n\n# _LT_FORMAT_COMMENT([COMMENT])\n# -----------------------------\n# Add leading comment marks to the start of each line, and a trailing\n# full-stop to the whole comment if one is not present already.\nm4_define([_LT_FORMAT_COMMENT],\n[m4_ifval([$1], [\nm4_bpatsubst([m4_bpatsubst([$1], [^ *], [# ])],\n              [['`$\\]], [\\\\\\&])]m4_bmatch([$1], [[!?.]$], [], [.])\n)])\n\n\n\n## ------------------------ ##\n## FIXME: Eliminate VARNAME ##\n## ------------------------ ##\n\n\n# _LT_DECL([CONFIGNAME], VARNAME, VALUE, [DESCRIPTION], [IS-TAGGED?])\n# -------------------------------------------------------------------\n# CONFIGNAME is the name given to the value in the libtool script.\n# VARNAME is the (base) name used in the configure script.\n# VALUE may be 0, 1 or 2 for a computed quote escaped value based on\n# VARNAME.  Any other value will be used directly.\nm4_define([_LT_DECL],\n[lt_if_append_uniq([lt_decl_varnames], [$2], [, ],\n    [lt_dict_add_subkey([lt_decl_dict], [$2], [libtool_name],\n\t[m4_ifval([$1], [$1], [$2])])\n    lt_dict_add_subkey([lt_decl_dict], [$2], [value], [$3])\n    m4_ifval([$4],\n\t[lt_dict_add_subkey([lt_decl_dict], [$2], [description], [$4])])\n    lt_dict_add_subkey([lt_decl_dict], [$2],\n\t[tagged?], [m4_ifval([$5], [yes], [no])])])\n])\n\n\n# _LT_TAGDECL([CONFIGNAME], VARNAME, VALUE, [DESCRIPTION])\n# --------------------------------------------------------\nm4_define([_LT_TAGDECL], [_LT_DECL([$1], [$2], [$3], [$4], [yes])])\n\n\n# lt_decl_tag_varnames([SEPARATOR], [VARNAME1...])\n# ------------------------------------------------\nm4_define([lt_decl_tag_varnames],\n[_lt_decl_filter([tagged?], [yes], $@)])\n\n\n# _lt_decl_filter(SUBKEY, VALUE, [SEPARATOR], [VARNAME1..])\n# ---------------------------------------------------------\nm4_define([_lt_decl_filter],\n[m4_case([$#],\n  [0], [m4_fatal([$0: too few arguments: $#])],\n  [1], [m4_fatal([$0: too few arguments: $#: $1])],\n  [2], [lt_dict_filter([lt_decl_dict], [$1], [$2], [], lt_decl_varnames)],\n  [3], [lt_dict_filter([lt_decl_dict], [$1], [$2], [$3], lt_decl_varnames)],\n  [lt_dict_filter([lt_decl_dict], $@)])[]dnl\n])\n\n\n# lt_decl_quote_varnames([SEPARATOR], [VARNAME1...])\n# --------------------------------------------------\nm4_define([lt_decl_quote_varnames],\n[_lt_decl_filter([value], [1], $@)])\n\n\n# lt_decl_dquote_varnames([SEPARATOR], [VARNAME1...])\n# ---------------------------------------------------\nm4_define([lt_decl_dquote_varnames],\n[_lt_decl_filter([value], [2], $@)])\n\n\n# lt_decl_varnames_tagged([SEPARATOR], [VARNAME1...])\n# ---------------------------------------------------\nm4_define([lt_decl_varnames_tagged],\n[m4_assert([$# <= 2])dnl\n_$0(m4_quote(m4_default([$1], [[, ]])),\n    m4_ifval([$2], [[$2]], [m4_dquote(lt_decl_tag_varnames)]),\n    m4_split(m4_normalize(m4_quote(_LT_TAGS)), [ ]))])\nm4_define([_lt_decl_varnames_tagged],\n[m4_ifval([$3], [lt_combine([$1], [$2], [_], $3)])])\n\n\n# lt_decl_all_varnames([SEPARATOR], [VARNAME1...])\n# ------------------------------------------------\nm4_define([lt_decl_all_varnames],\n[_$0(m4_quote(m4_default([$1], [[, ]])),\n     m4_if([$2], [],\n\t   m4_quote(lt_decl_varnames),\n\tm4_quote(m4_shift($@))))[]dnl\n])\nm4_define([_lt_decl_all_varnames],\n[lt_join($@, lt_decl_varnames_tagged([$1],\n\t\t\tlt_decl_tag_varnames([[, ]], m4_shift($@))))dnl\n])\n\n\n# _LT_CONFIG_STATUS_DECLARE([VARNAME])\n# ------------------------------------\n# Quote a variable value, and forward it to `config.status' so that its\n# declaration there will have the same value as in `configure'.  VARNAME\n# must have a single quote delimited value for this to work.\nm4_define([_LT_CONFIG_STATUS_DECLARE],\n[$1='`$ECHO \"X$][$1\" | $Xsed -e \"$delay_single_quote_subst\"`'])\n\n\n# _LT_CONFIG_STATUS_DECLARATIONS\n# ------------------------------\n# We delimit libtool config variables with single quotes, so when\n# we write them to config.status, we have to be sure to quote all\n# embedded single quotes properly.  In configure, this macro expands\n# each variable declared with _LT_DECL (and _LT_TAGDECL) into:\n#\n#    <var>='`$ECHO \"X$<var>\" | $Xsed -e \"$delay_single_quote_subst\"`'\nm4_defun([_LT_CONFIG_STATUS_DECLARATIONS],\n[m4_foreach([_lt_var], m4_quote(lt_decl_all_varnames),\n    [m4_n([_LT_CONFIG_STATUS_DECLARE(_lt_var)])])])\n\n\n# _LT_LIBTOOL_TAGS\n# ----------------\n# Output comment and list of tags supported by the script\nm4_defun([_LT_LIBTOOL_TAGS],\n[_LT_FORMAT_COMMENT([The names of the tagged configurations supported by this script])dnl\navailable_tags=\"_LT_TAGS\"dnl\n])\n\n\n# _LT_LIBTOOL_DECLARE(VARNAME, [TAG])\n# -----------------------------------\n# Extract the dictionary values for VARNAME (optionally with TAG) and\n# expand to a commented shell variable setting:\n#\n#    # Some comment about what VAR is for.\n#    visible_name=$lt_internal_name\nm4_define([_LT_LIBTOOL_DECLARE],\n[_LT_FORMAT_COMMENT(m4_quote(lt_dict_fetch([lt_decl_dict], [$1],\n\t\t\t\t\t   [description])))[]dnl\nm4_pushdef([_libtool_name],\n    m4_quote(lt_dict_fetch([lt_decl_dict], [$1], [libtool_name])))[]dnl\nm4_case(m4_quote(lt_dict_fetch([lt_decl_dict], [$1], [value])),\n    [0], [_libtool_name=[$]$1],\n    [1], [_libtool_name=$lt_[]$1],\n    [2], [_libtool_name=$lt_[]$1],\n    [_libtool_name=lt_dict_fetch([lt_decl_dict], [$1], [value])])[]dnl\nm4_ifval([$2], [_$2])[]m4_popdef([_libtool_name])[]dnl\n])\n\n\n# _LT_LIBTOOL_CONFIG_VARS\n# -----------------------\n# Produce commented declarations of non-tagged libtool config variables\n# suitable for insertion in the LIBTOOL CONFIG section of the `libtool'\n# script.  Tagged libtool config variables (even for the LIBTOOL CONFIG\n# section) are produced by _LT_LIBTOOL_TAG_VARS.\nm4_defun([_LT_LIBTOOL_CONFIG_VARS],\n[m4_foreach([_lt_var],\n    m4_quote(_lt_decl_filter([tagged?], [no], [], lt_decl_varnames)),\n    [m4_n([_LT_LIBTOOL_DECLARE(_lt_var)])])])\n\n\n# _LT_LIBTOOL_TAG_VARS(TAG)\n# -------------------------\nm4_define([_LT_LIBTOOL_TAG_VARS],\n[m4_foreach([_lt_var], m4_quote(lt_decl_tag_varnames),\n    [m4_n([_LT_LIBTOOL_DECLARE(_lt_var, [$1])])])])\n\n\n# _LT_TAGVAR(VARNAME, [TAGNAME])\n# ------------------------------\nm4_define([_LT_TAGVAR], [m4_ifval([$2], [$1_$2], [$1])])\n\n\n# _LT_CONFIG_COMMANDS\n# -------------------\n# Send accumulated output to $CONFIG_STATUS.  Thanks to the lists of\n# variables for single and double quote escaping we saved from calls\n# to _LT_DECL, we can put quote escaped variables declarations\n# into `config.status', and then the shell code to quote escape them in\n# for loops in `config.status'.  Finally, any additional code accumulated\n# from calls to _LT_CONFIG_LIBTOOL_INIT is expanded.\nm4_defun([_LT_CONFIG_COMMANDS],\n[AC_PROVIDE_IFELSE([LT_OUTPUT],\n\tdnl If the libtool generation code has been placed in $CONFIG_LT,\n\tdnl instead of duplicating it all over again into config.status,\n\tdnl then we will have config.status run $CONFIG_LT later, so it\n\tdnl needs to know what name is stored there:\n        [AC_CONFIG_COMMANDS([libtool],\n            [$SHELL $CONFIG_LT || AS_EXIT(1)], [CONFIG_LT='$CONFIG_LT'])],\n    dnl If the libtool generation code is destined for config.status,\n    dnl expand the accumulated commands and init code now:\n    [AC_CONFIG_COMMANDS([libtool],\n        [_LT_OUTPUT_LIBTOOL_COMMANDS], [_LT_OUTPUT_LIBTOOL_COMMANDS_INIT])])\n])#_LT_CONFIG_COMMANDS\n\n\n# Initialize.\nm4_define([_LT_OUTPUT_LIBTOOL_COMMANDS_INIT],\n[\n\n# The HP-UX ksh and POSIX shell print the target directory to stdout\n# if CDPATH is set.\n(unset CDPATH) >/dev/null 2>&1 && unset CDPATH\n\nsed_quote_subst='$sed_quote_subst'\ndouble_quote_subst='$double_quote_subst'\ndelay_variable_subst='$delay_variable_subst'\n_LT_CONFIG_STATUS_DECLARATIONS\nLTCC='$LTCC'\nLTCFLAGS='$LTCFLAGS'\ncompiler='$compiler_DEFAULT'\n\n# Quote evaled strings.\nfor var in lt_decl_all_varnames([[ \\\n]], lt_decl_quote_varnames); do\n    case \\`eval \\\\\\\\\\$ECHO \"X\\\\\\\\\\$\\$var\"\\` in\n    *[[\\\\\\\\\\\\\\`\\\\\"\\\\\\$]]*)\n      eval \"lt_\\$var=\\\\\\\\\\\\\"\\\\\\`\\\\\\$ECHO \\\\\"X\\\\\\$\\$var\\\\\" | \\\\\\$Xsed -e \\\\\"\\\\\\$sed_quote_subst\\\\\"\\\\\\`\\\\\\\\\\\\\"\"\n      ;;\n    *)\n      eval \"lt_\\$var=\\\\\\\\\\\\\"\\\\\\$\\$var\\\\\\\\\\\\\"\"\n      ;;\n    esac\ndone\n\n# Double-quote double-evaled strings.\nfor var in lt_decl_all_varnames([[ \\\n]], lt_decl_dquote_varnames); do\n    case \\`eval \\\\\\\\\\$ECHO \"X\\\\\\\\\\$\\$var\"\\` in\n    *[[\\\\\\\\\\\\\\`\\\\\"\\\\\\$]]*)\n      eval \"lt_\\$var=\\\\\\\\\\\\\"\\\\\\`\\\\\\$ECHO \\\\\"X\\\\\\$\\$var\\\\\" | \\\\\\$Xsed -e \\\\\"\\\\\\$double_quote_subst\\\\\" -e \\\\\"\\\\\\$sed_quote_subst\\\\\" -e \\\\\"\\\\\\$delay_variable_subst\\\\\"\\\\\\`\\\\\\\\\\\\\"\"\n      ;;\n    *)\n      eval \"lt_\\$var=\\\\\\\\\\\\\"\\\\\\$\\$var\\\\\\\\\\\\\"\"\n      ;;\n    esac\ndone\n\n# Fix-up fallback echo if it was mangled by the above quoting rules.\ncase \\$lt_ECHO in\n*'\\\\\\[$]0 --fallback-echo\"')dnl \"\n  lt_ECHO=\\`\\$ECHO \"X\\$lt_ECHO\" | \\$Xsed -e 's/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\[$]0 --fallback-echo\"\\[$]/\\[$]0 --fallback-echo\"/'\\`\n  ;;\nesac\n\n_LT_OUTPUT_LIBTOOL_INIT\n])\n\n\n# LT_OUTPUT\n# ---------\n# This macro allows early generation of the libtool script (before\n# AC_OUTPUT is called), incase it is used in configure for compilation\n# tests.\nAC_DEFUN([LT_OUTPUT],\n[: ${CONFIG_LT=./config.lt}\nAC_MSG_NOTICE([creating $CONFIG_LT])\ncat >\"$CONFIG_LT\" <<_LTEOF\n#! $SHELL\n# Generated by $as_me.\n# Run this file to recreate a libtool stub with the current configuration.\n\nlt_cl_silent=false\nSHELL=\\${CONFIG_SHELL-$SHELL}\n_LTEOF\n\ncat >>\"$CONFIG_LT\" <<\\_LTEOF\nAS_SHELL_SANITIZE\n_AS_PREPARE\n\nexec AS_MESSAGE_FD>&1\nexec AS_MESSAGE_LOG_FD>>config.log\n{\n  echo\n  AS_BOX([Running $as_me.])\n} >&AS_MESSAGE_LOG_FD\n\nlt_cl_help=\"\\\n\\`$as_me' creates a local libtool stub from the current configuration,\nfor use in further configure time tests before the real libtool is\ngenerated.\n\nUsage: $[0] [[OPTIONS]]\n\n  -h, --help      print this help, then exit\n  -V, --version   print version number, then exit\n  -q, --quiet     do not print progress messages\n  -d, --debug     don't remove temporary files\n\nReport bugs to <bug-libtool@gnu.org>.\"\n\nlt_cl_version=\"\\\nm4_ifset([AC_PACKAGE_NAME], [AC_PACKAGE_NAME ])config.lt[]dnl\nm4_ifset([AC_PACKAGE_VERSION], [ AC_PACKAGE_VERSION])\nconfigured by $[0], generated by m4_PACKAGE_STRING.\n\nCopyright (C) 2008 Free Software Foundation, Inc.\nThis config.lt script is free software; the Free Software Foundation\ngives unlimited permision to copy, distribute and modify it.\"\n\nwhile test $[#] != 0\ndo\n  case $[1] in\n    --version | --v* | -V )\n      echo \"$lt_cl_version\"; exit 0 ;;\n    --help | --h* | -h )\n      echo \"$lt_cl_help\"; exit 0 ;;\n    --debug | --d* | -d )\n      debug=: ;;\n    --quiet | --q* | --silent | --s* | -q )\n      lt_cl_silent=: ;;\n\n    -*) AC_MSG_ERROR([unrecognized option: $[1]\nTry \\`$[0] --help' for more information.]) ;;\n\n    *) AC_MSG_ERROR([unrecognized argument: $[1]\nTry \\`$[0] --help' for more information.]) ;;\n  esac\n  shift\ndone\n\nif $lt_cl_silent; then\n  exec AS_MESSAGE_FD>/dev/null\nfi\n_LTEOF\n\ncat >>\"$CONFIG_LT\" <<_LTEOF\n_LT_OUTPUT_LIBTOOL_COMMANDS_INIT\n_LTEOF\n\ncat >>\"$CONFIG_LT\" <<\\_LTEOF\nAC_MSG_NOTICE([creating $ofile])\n_LT_OUTPUT_LIBTOOL_COMMANDS\nAS_EXIT(0)\n_LTEOF\nchmod +x \"$CONFIG_LT\"\n\n# configure is writing to config.log, but config.lt does its own redirection,\n# appending to config.log, which fails on DOS, as config.log is still kept\n# open by configure.  Here we exec the FD to /dev/null, effectively closing\n# config.log, so it can be properly (re)opened and appended to by config.lt.\nif test \"$no_create\" != yes; then\n  lt_cl_success=:\n  test \"$silent\" = yes &&\n    lt_config_lt_args=\"$lt_config_lt_args --quiet\"\n  exec AS_MESSAGE_LOG_FD>/dev/null\n  $SHELL \"$CONFIG_LT\" $lt_config_lt_args || lt_cl_success=false\n  exec AS_MESSAGE_LOG_FD>>config.log\n  $lt_cl_success || AS_EXIT(1)\nfi\n])# LT_OUTPUT\n\n\n# _LT_CONFIG(TAG)\n# ---------------\n# If TAG is the built-in tag, create an initial libtool script with a\n# default configuration from the untagged config vars.  Otherwise add code\n# to config.status for appending the configuration named by TAG from the\n# matching tagged config vars.\nm4_defun([_LT_CONFIG],\n[m4_require([_LT_FILEUTILS_DEFAULTS])dnl\n_LT_CONFIG_SAVE_COMMANDS([\n  m4_define([_LT_TAG], m4_if([$1], [], [C], [$1]))dnl\n  m4_if(_LT_TAG, [C], [\n    # See if we are running on zsh, and set the options which allow our\n    # commands through without removal of \\ escapes.\n    if test -n \"${ZSH_VERSION+set}\" ; then\n      setopt NO_GLOB_SUBST\n    fi\n\n    cfgfile=\"${ofile}T\"\n    trap \"$RM \\\"$cfgfile\\\"; exit 1\" 1 2 15\n    $RM \"$cfgfile\"\n\n    cat <<_LT_EOF >> \"$cfgfile\"\n#! $SHELL\n\n# `$ECHO \"$ofile\" | sed 's%^.*/%%'` - Provide generalized library-building support services.\n# Generated automatically by $as_me ($PACKAGE$TIMESTAMP) $VERSION\n# Libtool was configured on host `(hostname || uname -n) 2>/dev/null | sed 1q`:\n# NOTE: Changes made to this file will be lost: look at ltmain.sh.\n#\n_LT_COPYING\n_LT_LIBTOOL_TAGS\n\n# ### BEGIN LIBTOOL CONFIG\n_LT_LIBTOOL_CONFIG_VARS\n_LT_LIBTOOL_TAG_VARS\n# ### END LIBTOOL CONFIG\n\n_LT_EOF\n\n  case $host_os in\n  aix3*)\n    cat <<\\_LT_EOF >> \"$cfgfile\"\n# AIX sometimes has problems with the GCC collect2 program.  For some\n# reason, if we set the COLLECT_NAMES environment variable, the problems\n# vanish in a puff of smoke.\nif test \"X${COLLECT_NAMES+set}\" != Xset; then\n  COLLECT_NAMES=\n  export COLLECT_NAMES\nfi\n_LT_EOF\n    ;;\n  esac\n\n  _LT_PROG_LTMAIN\n\n  # We use sed instead of cat because bash on DJGPP gets confused if\n  # if finds mixed CR/LF and LF-only lines.  Since sed operates in\n  # text mode, it properly converts lines to CR/LF.  This bash problem\n  # is reportedly fixed, but why not run on old versions too?\n  sed '/^# Generated shell functions inserted here/q' \"$ltmain\" >> \"$cfgfile\" \\\n    || (rm -f \"$cfgfile\"; exit 1)\n\n  _LT_PROG_XSI_SHELLFNS\n\n  sed -n '/^# Generated shell functions inserted here/,$p' \"$ltmain\" >> \"$cfgfile\" \\\n    || (rm -f \"$cfgfile\"; exit 1)\n\n  mv -f \"$cfgfile\" \"$ofile\" ||\n    (rm -f \"$ofile\" && cp \"$cfgfile\" \"$ofile\" && rm -f \"$cfgfile\")\n  chmod +x \"$ofile\"\n],\n[cat <<_LT_EOF >> \"$ofile\"\n\ndnl Unfortunately we have to use $1 here, since _LT_TAG is not expanded\ndnl in a comment (ie after a #).\n# ### BEGIN LIBTOOL TAG CONFIG: $1\n_LT_LIBTOOL_TAG_VARS(_LT_TAG)\n# ### END LIBTOOL TAG CONFIG: $1\n_LT_EOF\n])dnl /m4_if\n],\n[m4_if([$1], [], [\n    PACKAGE='$PACKAGE'\n    VERSION='$VERSION'\n    TIMESTAMP='$TIMESTAMP'\n    RM='$RM'\n    ofile='$ofile'], [])\n])dnl /_LT_CONFIG_SAVE_COMMANDS\n])# _LT_CONFIG\n\n\n# LT_SUPPORTED_TAG(TAG)\n# ---------------------\n# Trace this macro to discover what tags are supported by the libtool\n# --tag option, using:\n#    autoconf --trace 'LT_SUPPORTED_TAG:$1'\nAC_DEFUN([LT_SUPPORTED_TAG], [])\n\n\n# C support is built-in for now\nm4_define([_LT_LANG_C_enabled], [])\nm4_define([_LT_TAGS], [])\n\n\n# LT_LANG(LANG)\n# -------------\n# Enable libtool support for the given language if not already enabled.\nAC_DEFUN([LT_LANG],\n[AC_BEFORE([$0], [LT_OUTPUT])dnl\nm4_case([$1],\n  [C],\t\t\t[_LT_LANG(C)],\n  [C++],\t\t[_LT_LANG(CXX)],\n  [Java],\t\t[_LT_LANG(GCJ)],\n  [Fortran 77],\t\t[_LT_LANG(F77)],\n  [Fortran],\t\t[_LT_LANG(FC)],\n  [Windows Resource],\t[_LT_LANG(RC)],\n  [m4_ifdef([_LT_LANG_]$1[_CONFIG],\n    [_LT_LANG($1)],\n    [m4_fatal([$0: unsupported language: \"$1\"])])])dnl\n])# LT_LANG\n\n\n# _LT_LANG(LANGNAME)\n# ------------------\nm4_defun([_LT_LANG],\n[m4_ifdef([_LT_LANG_]$1[_enabled], [],\n  [LT_SUPPORTED_TAG([$1])dnl\n  m4_append([_LT_TAGS], [$1 ])dnl\n  m4_define([_LT_LANG_]$1[_enabled], [])dnl\n  _LT_LANG_$1_CONFIG($1)])dnl\n])# _LT_LANG\n\n\n# _LT_LANG_DEFAULT_CONFIG\n# -----------------------\nm4_defun([_LT_LANG_DEFAULT_CONFIG],\n[AC_PROVIDE_IFELSE([AC_PROG_CXX],\n  [LT_LANG(CXX)],\n  [m4_define([AC_PROG_CXX], defn([AC_PROG_CXX])[LT_LANG(CXX)])])\n\nAC_PROVIDE_IFELSE([AC_PROG_F77],\n  [LT_LANG(F77)],\n  [m4_define([AC_PROG_F77], defn([AC_PROG_F77])[LT_LANG(F77)])])\n\nAC_PROVIDE_IFELSE([AC_PROG_FC],\n  [LT_LANG(FC)],\n  [m4_define([AC_PROG_FC], defn([AC_PROG_FC])[LT_LANG(FC)])])\n\ndnl The call to [A][M_PROG_GCJ] is quoted like that to stop aclocal\ndnl pulling things in needlessly.\nAC_PROVIDE_IFELSE([AC_PROG_GCJ],\n  [LT_LANG(GCJ)],\n  [AC_PROVIDE_IFELSE([A][M_PROG_GCJ],\n    [LT_LANG(GCJ)],\n    [AC_PROVIDE_IFELSE([LT_PROG_GCJ],\n      [LT_LANG(GCJ)],\n      [m4_ifdef([AC_PROG_GCJ],\n\t[m4_define([AC_PROG_GCJ], defn([AC_PROG_GCJ])[LT_LANG(GCJ)])])\n       m4_ifdef([A][M_PROG_GCJ],\n\t[m4_define([A][M_PROG_GCJ], defn([A][M_PROG_GCJ])[LT_LANG(GCJ)])])\n       m4_ifdef([LT_PROG_GCJ],\n\t[m4_define([LT_PROG_GCJ], defn([LT_PROG_GCJ])[LT_LANG(GCJ)])])])])])\n\nAC_PROVIDE_IFELSE([LT_PROG_RC],\n  [LT_LANG(RC)],\n  [m4_define([LT_PROG_RC], defn([LT_PROG_RC])[LT_LANG(RC)])])\n])# _LT_LANG_DEFAULT_CONFIG\n\n# Obsolete macros:\nAU_DEFUN([AC_LIBTOOL_CXX], [LT_LANG(C++)])\nAU_DEFUN([AC_LIBTOOL_F77], [LT_LANG(Fortran 77)])\nAU_DEFUN([AC_LIBTOOL_FC], [LT_LANG(Fortran)])\nAU_DEFUN([AC_LIBTOOL_GCJ], [LT_LANG(Java)])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_CXX], [])\ndnl AC_DEFUN([AC_LIBTOOL_F77], [])\ndnl AC_DEFUN([AC_LIBTOOL_FC], [])\ndnl AC_DEFUN([AC_LIBTOOL_GCJ], [])\n\n\n# _LT_TAG_COMPILER\n# ----------------\nm4_defun([_LT_TAG_COMPILER],\n[AC_REQUIRE([AC_PROG_CC])dnl\n\n_LT_DECL([LTCC], [CC], [1], [A C compiler])dnl\n_LT_DECL([LTCFLAGS], [CFLAGS], [1], [LTCC compiler flags])dnl\n_LT_TAGDECL([CC], [compiler], [1], [A language specific compiler])dnl\n_LT_TAGDECL([with_gcc], [GCC], [0], [Is the compiler the GNU compiler?])dnl\n\n# If no C compiler was specified, use CC.\nLTCC=${LTCC-\"$CC\"}\n\n# If no C compiler flags were specified, use CFLAGS.\nLTCFLAGS=${LTCFLAGS-\"$CFLAGS\"}\n\n# Allow CC to be a program name with arguments.\ncompiler=$CC\n])# _LT_TAG_COMPILER\n\n\n# _LT_COMPILER_BOILERPLATE\n# ------------------------\n# Check for compiler boilerplate output or warnings with\n# the simple compiler test code.\nm4_defun([_LT_COMPILER_BOILERPLATE],\n[m4_require([_LT_DECL_SED])dnl\nac_outfile=conftest.$ac_objext\necho \"$lt_simple_compile_test_code\" >conftest.$ac_ext\neval \"$ac_compile\" 2>&1 >/dev/null | $SED '/^$/d; /^ *+/d' >conftest.err\n_lt_compiler_boilerplate=`cat conftest.err`\n$RM conftest*\n])# _LT_COMPILER_BOILERPLATE\n\n\n# _LT_LINKER_BOILERPLATE\n# ----------------------\n# Check for linker boilerplate output or warnings with\n# the simple link test code.\nm4_defun([_LT_LINKER_BOILERPLATE],\n[m4_require([_LT_DECL_SED])dnl\nac_outfile=conftest.$ac_objext\necho \"$lt_simple_link_test_code\" >conftest.$ac_ext\neval \"$ac_link\" 2>&1 >/dev/null | $SED '/^$/d; /^ *+/d' >conftest.err\n_lt_linker_boilerplate=`cat conftest.err`\n$RM -r conftest*\n])# _LT_LINKER_BOILERPLATE\n\n# _LT_REQUIRED_DARWIN_CHECKS\n# -------------------------\nm4_defun_once([_LT_REQUIRED_DARWIN_CHECKS],[\n  case $host_os in\n    rhapsody* | darwin*)\n    AC_CHECK_TOOL([DSYMUTIL], [dsymutil], [:])\n    AC_CHECK_TOOL([NMEDIT], [nmedit], [:])\n    AC_CHECK_TOOL([LIPO], [lipo], [:])\n    AC_CHECK_TOOL([OTOOL], [otool], [:])\n    AC_CHECK_TOOL([OTOOL64], [otool64], [:])\n    _LT_DECL([], [DSYMUTIL], [1],\n      [Tool to manipulate archived DWARF debug symbol files on Mac OS X])\n    _LT_DECL([], [NMEDIT], [1],\n      [Tool to change global to local symbols on Mac OS X])\n    _LT_DECL([], [LIPO], [1],\n      [Tool to manipulate fat objects and archives on Mac OS X])\n    _LT_DECL([], [OTOOL], [1],\n      [ldd/readelf like tool for Mach-O binaries on Mac OS X])\n    _LT_DECL([], [OTOOL64], [1],\n      [ldd/readelf like tool for 64 bit Mach-O binaries on Mac OS X 10.4])\n\n    AC_CACHE_CHECK([for -single_module linker flag],[lt_cv_apple_cc_single_mod],\n      [lt_cv_apple_cc_single_mod=no\n      if test -z \"${LT_MULTI_MODULE}\"; then\n\t# By default we will add the -single_module flag. You can override\n\t# by either setting the environment variable LT_MULTI_MODULE\n\t# non-empty at configure time, or by adding -multi_module to the\n\t# link flags.\n\trm -rf libconftest.dylib*\n\techo \"int foo(void){return 1;}\" > conftest.c\n\techo \"$LTCC $LTCFLAGS $LDFLAGS -o libconftest.dylib \\\n-dynamiclib -Wl,-single_module conftest.c\" >&AS_MESSAGE_LOG_FD\n\t$LTCC $LTCFLAGS $LDFLAGS -o libconftest.dylib \\\n\t  -dynamiclib -Wl,-single_module conftest.c 2>conftest.err\n        _lt_result=$?\n\tif test -f libconftest.dylib && test ! -s conftest.err && test $_lt_result = 0; then\n\t  lt_cv_apple_cc_single_mod=yes\n\telse\n\t  cat conftest.err >&AS_MESSAGE_LOG_FD\n\tfi\n\trm -rf libconftest.dylib*\n\trm -f conftest.*\n      fi])\n    AC_CACHE_CHECK([for -exported_symbols_list linker flag],\n      [lt_cv_ld_exported_symbols_list],\n      [lt_cv_ld_exported_symbols_list=no\n      save_LDFLAGS=$LDFLAGS\n      echo \"_main\" > conftest.sym\n      LDFLAGS=\"$LDFLAGS -Wl,-exported_symbols_list,conftest.sym\"\n      AC_LINK_IFELSE([AC_LANG_PROGRAM([],[])],\n\t[lt_cv_ld_exported_symbols_list=yes],\n\t[lt_cv_ld_exported_symbols_list=no])\n\tLDFLAGS=\"$save_LDFLAGS\"\n    ])\n    case $host_os in\n    rhapsody* | darwin1.[[012]])\n      _lt_dar_allow_undefined='${wl}-undefined ${wl}suppress' ;;\n    darwin1.*)\n      _lt_dar_allow_undefined='${wl}-flat_namespace ${wl}-undefined ${wl}suppress' ;;\n    darwin*) # darwin 5.x on\n      # if running on 10.5 or later, the deployment target defaults\n      # to the OS version, if on x86, and 10.4, the deployment\n      # target defaults to 10.4. Don't you love it?\n      case ${MACOSX_DEPLOYMENT_TARGET-10.0},$host in\n\t10.0,*86*-darwin8*|10.0,*-darwin[[91]]*)\n\t  _lt_dar_allow_undefined='${wl}-undefined ${wl}dynamic_lookup' ;;\n\t10.[[012]]*)\n\t  _lt_dar_allow_undefined='${wl}-flat_namespace ${wl}-undefined ${wl}suppress' ;;\n\t10.*)\n\t  _lt_dar_allow_undefined='${wl}-undefined ${wl}dynamic_lookup' ;;\n      esac\n    ;;\n  esac\n    if test \"$lt_cv_apple_cc_single_mod\" = \"yes\"; then\n      _lt_dar_single_mod='$single_module'\n    fi\n    if test \"$lt_cv_ld_exported_symbols_list\" = \"yes\"; then\n      _lt_dar_export_syms=' ${wl}-exported_symbols_list,$output_objdir/${libname}-symbols.expsym'\n    else\n      _lt_dar_export_syms='~$NMEDIT -s $output_objdir/${libname}-symbols.expsym ${lib}'\n    fi\n    if test \"$DSYMUTIL\" != \":\"; then\n      _lt_dsymutil='~$DSYMUTIL $lib || :'\n    else\n      _lt_dsymutil=\n    fi\n    ;;\n  esac\n])\n\n\n# _LT_DARWIN_LINKER_FEATURES\n# --------------------------\n# Checks for linker and compiler features on darwin\nm4_defun([_LT_DARWIN_LINKER_FEATURES],\n[\n  m4_require([_LT_REQUIRED_DARWIN_CHECKS])\n  _LT_TAGVAR(archive_cmds_need_lc, $1)=no\n  _LT_TAGVAR(hardcode_direct, $1)=no\n  _LT_TAGVAR(hardcode_automatic, $1)=yes\n  _LT_TAGVAR(hardcode_shlibpath_var, $1)=unsupported\n  _LT_TAGVAR(whole_archive_flag_spec, $1)=''\n  _LT_TAGVAR(link_all_deplibs, $1)=yes\n  _LT_TAGVAR(allow_undefined_flag, $1)=\"$_lt_dar_allow_undefined\"\n  case $cc_basename in\n     ifort*) _lt_dar_can_shared=yes ;;\n     *) _lt_dar_can_shared=$GCC ;;\n  esac\n  if test \"$_lt_dar_can_shared\" = \"yes\"; then\n    output_verbose_link_cmd=echo\n    _LT_TAGVAR(archive_cmds, $1)=\"\\$CC -dynamiclib \\$allow_undefined_flag -o \\$lib \\$libobjs \\$deplibs \\$compiler_flags -install_name \\$rpath/\\$soname \\$verstring $_lt_dar_single_mod${_lt_dsymutil}\"\n    _LT_TAGVAR(module_cmds, $1)=\"\\$CC \\$allow_undefined_flag -o \\$lib -bundle \\$libobjs \\$deplibs \\$compiler_flags${_lt_dsymutil}\"\n    _LT_TAGVAR(archive_expsym_cmds, $1)=\"sed 's,^,_,' < \\$export_symbols > \\$output_objdir/\\${libname}-symbols.expsym~\\$CC -dynamiclib \\$allow_undefined_flag -o \\$lib \\$libobjs \\$deplibs \\$compiler_flags -install_name \\$rpath/\\$soname \\$verstring ${_lt_dar_single_mod}${_lt_dar_export_syms}${_lt_dsymutil}\"\n    _LT_TAGVAR(module_expsym_cmds, $1)=\"sed -e 's,^,_,' < \\$export_symbols > \\$output_objdir/\\${libname}-symbols.expsym~\\$CC \\$allow_undefined_flag -o \\$lib -bundle \\$libobjs \\$deplibs \\$compiler_flags${_lt_dar_export_syms}${_lt_dsymutil}\"\n    m4_if([$1], [CXX],\n[   if test \"$lt_cv_apple_cc_single_mod\" != \"yes\"; then\n      _LT_TAGVAR(archive_cmds, $1)=\"\\$CC -r -keep_private_externs -nostdlib -o \\${lib}-master.o \\$libobjs~\\$CC -dynamiclib \\$allow_undefined_flag -o \\$lib \\${lib}-master.o \\$deplibs \\$compiler_flags -install_name \\$rpath/\\$soname \\$verstring${_lt_dsymutil}\"\n      _LT_TAGVAR(archive_expsym_cmds, $1)=\"sed 's,^,_,' < \\$export_symbols > \\$output_objdir/\\${libname}-symbols.expsym~\\$CC -r -keep_private_externs -nostdlib -o \\${lib}-master.o \\$libobjs~\\$CC -dynamiclib \\$allow_undefined_flag -o \\$lib \\${lib}-master.o \\$deplibs \\$compiler_flags -install_name \\$rpath/\\$soname \\$verstring${_lt_dar_export_syms}${_lt_dsymutil}\"\n    fi\n],[])\n  else\n  _LT_TAGVAR(ld_shlibs, $1)=no\n  fi\n])\n\n# _LT_SYS_MODULE_PATH_AIX\n# -----------------------\n# Links a minimal program and checks the executable\n# for the system default hardcoded library path. In most cases,\n# this is /usr/lib:/lib, but when the MPI compilers are used\n# the location of the communication and MPI libs are included too.\n# If we don't find anything, use the default library path according\n# to the aix ld manual.\nm4_defun([_LT_SYS_MODULE_PATH_AIX],\n[m4_require([_LT_DECL_SED])dnl\nAC_LINK_IFELSE([AC_LANG_PROGRAM],[\nlt_aix_libpath_sed='\n    /Import File Strings/,/^$/ {\n\t/^0/ {\n\t    s/^0  *\\(.*\\)$/\\1/\n\t    p\n\t}\n    }'\naix_libpath=`dump -H conftest$ac_exeext 2>/dev/null | $SED -n -e \"$lt_aix_libpath_sed\"`\n# Check for a 64-bit object if we didn't find anything.\nif test -z \"$aix_libpath\"; then\n  aix_libpath=`dump -HX64 conftest$ac_exeext 2>/dev/null | $SED -n -e \"$lt_aix_libpath_sed\"`\nfi],[])\nif test -z \"$aix_libpath\"; then aix_libpath=\"/usr/lib:/lib\"; fi\n])# _LT_SYS_MODULE_PATH_AIX\n\n\n# _LT_SHELL_INIT(ARG)\n# -------------------\nm4_define([_LT_SHELL_INIT],\n[ifdef([AC_DIVERSION_NOTICE],\n\t     [AC_DIVERT_PUSH(AC_DIVERSION_NOTICE)],\n\t [AC_DIVERT_PUSH(NOTICE)])\n$1\nAC_DIVERT_POP\n])# _LT_SHELL_INIT\n\n\n# _LT_PROG_ECHO_BACKSLASH\n# -----------------------\n# Add some code to the start of the generated configure script which\n# will find an echo command which doesn't interpret backslashes.\nm4_defun([_LT_PROG_ECHO_BACKSLASH],\n[_LT_SHELL_INIT([\n# Check that we are running under the correct shell.\nSHELL=${CONFIG_SHELL-/bin/sh}\n\ncase X$lt_ECHO in\nX*--fallback-echo)\n  # Remove one level of quotation (which was required for Make).\n  ECHO=`echo \"$lt_ECHO\" | sed 's,\\\\\\\\\\[$]\\\\[$]0,'[$]0','`\n  ;;\nesac\n\nECHO=${lt_ECHO-echo}\nif test \"X[$]1\" = X--no-reexec; then\n  # Discard the --no-reexec flag, and continue.\n  shift\nelif test \"X[$]1\" = X--fallback-echo; then\n  # Avoid inline document here, it may be left over\n  :\nelif test \"X`{ $ECHO '\\t'; } 2>/dev/null`\" = 'X\\t' ; then\n  # Yippee, $ECHO works!\n  :\nelse\n  # Restart under the correct shell.\n  exec $SHELL \"[$]0\" --no-reexec ${1+\"[$]@\"}\nfi\n\nif test \"X[$]1\" = X--fallback-echo; then\n  # used as fallback echo\n  shift\n  cat <<_LT_EOF\n[$]*\n_LT_EOF\n  exit 0\nfi\n\n# The HP-UX ksh and POSIX shell print the target directory to stdout\n# if CDPATH is set.\n(unset CDPATH) >/dev/null 2>&1 && unset CDPATH\n\nif test -z \"$lt_ECHO\"; then\n  if test \"X${echo_test_string+set}\" != Xset; then\n    # find a string as large as possible, as long as the shell can cope with it\n    for cmd in 'sed 50q \"[$]0\"' 'sed 20q \"[$]0\"' 'sed 10q \"[$]0\"' 'sed 2q \"[$]0\"' 'echo test'; do\n      # expected sizes: less than 2Kb, 1Kb, 512 bytes, 16 bytes, ...\n      if { echo_test_string=`eval $cmd`; } 2>/dev/null &&\n\t { test \"X$echo_test_string\" = \"X$echo_test_string\"; } 2>/dev/null\n      then\n        break\n      fi\n    done\n  fi\n\n  if test \"X`{ $ECHO '\\t'; } 2>/dev/null`\" = 'X\\t' &&\n     echo_testing_string=`{ $ECHO \"$echo_test_string\"; } 2>/dev/null` &&\n     test \"X$echo_testing_string\" = \"X$echo_test_string\"; then\n    :\n  else\n    # The Solaris, AIX, and Digital Unix default echo programs unquote\n    # backslashes.  This makes it impossible to quote backslashes using\n    #   echo \"$something\" | sed 's/\\\\/\\\\\\\\/g'\n    #\n    # So, first we look for a working echo in the user's PATH.\n\n    lt_save_ifs=\"$IFS\"; IFS=$PATH_SEPARATOR\n    for dir in $PATH /usr/ucb; do\n      IFS=\"$lt_save_ifs\"\n      if (test -f $dir/echo || test -f $dir/echo$ac_exeext) &&\n         test \"X`($dir/echo '\\t') 2>/dev/null`\" = 'X\\t' &&\n         echo_testing_string=`($dir/echo \"$echo_test_string\") 2>/dev/null` &&\n         test \"X$echo_testing_string\" = \"X$echo_test_string\"; then\n        ECHO=\"$dir/echo\"\n        break\n      fi\n    done\n    IFS=\"$lt_save_ifs\"\n\n    if test \"X$ECHO\" = Xecho; then\n      # We didn't find a better echo, so look for alternatives.\n      if test \"X`{ print -r '\\t'; } 2>/dev/null`\" = 'X\\t' &&\n         echo_testing_string=`{ print -r \"$echo_test_string\"; } 2>/dev/null` &&\n         test \"X$echo_testing_string\" = \"X$echo_test_string\"; then\n        # This shell has a builtin print -r that does the trick.\n        ECHO='print -r'\n      elif { test -f /bin/ksh || test -f /bin/ksh$ac_exeext; } &&\n\t   test \"X$CONFIG_SHELL\" != X/bin/ksh; then\n        # If we have ksh, try running configure again with it.\n        ORIGINAL_CONFIG_SHELL=${CONFIG_SHELL-/bin/sh}\n        export ORIGINAL_CONFIG_SHELL\n        CONFIG_SHELL=/bin/ksh\n        export CONFIG_SHELL\n        exec $CONFIG_SHELL \"[$]0\" --no-reexec ${1+\"[$]@\"}\n      else\n        # Try using printf.\n        ECHO='printf %s\\n'\n        if test \"X`{ $ECHO '\\t'; } 2>/dev/null`\" = 'X\\t' &&\n\t   echo_testing_string=`{ $ECHO \"$echo_test_string\"; } 2>/dev/null` &&\n\t   test \"X$echo_testing_string\" = \"X$echo_test_string\"; then\n\t  # Cool, printf works\n\t  :\n        elif echo_testing_string=`($ORIGINAL_CONFIG_SHELL \"[$]0\" --fallback-echo '\\t') 2>/dev/null` &&\n\t     test \"X$echo_testing_string\" = 'X\\t' &&\n\t     echo_testing_string=`($ORIGINAL_CONFIG_SHELL \"[$]0\" --fallback-echo \"$echo_test_string\") 2>/dev/null` &&\n\t     test \"X$echo_testing_string\" = \"X$echo_test_string\"; then\n\t  CONFIG_SHELL=$ORIGINAL_CONFIG_SHELL\n\t  export CONFIG_SHELL\n\t  SHELL=\"$CONFIG_SHELL\"\n\t  export SHELL\n\t  ECHO=\"$CONFIG_SHELL [$]0 --fallback-echo\"\n        elif echo_testing_string=`($CONFIG_SHELL \"[$]0\" --fallback-echo '\\t') 2>/dev/null` &&\n\t     test \"X$echo_testing_string\" = 'X\\t' &&\n\t     echo_testing_string=`($CONFIG_SHELL \"[$]0\" --fallback-echo \"$echo_test_string\") 2>/dev/null` &&\n\t     test \"X$echo_testing_string\" = \"X$echo_test_string\"; then\n\t  ECHO=\"$CONFIG_SHELL [$]0 --fallback-echo\"\n        else\n\t  # maybe with a smaller string...\n\t  prev=:\n\n\t  for cmd in 'echo test' 'sed 2q \"[$]0\"' 'sed 10q \"[$]0\"' 'sed 20q \"[$]0\"' 'sed 50q \"[$]0\"'; do\n\t    if { test \"X$echo_test_string\" = \"X`eval $cmd`\"; } 2>/dev/null\n\t    then\n\t      break\n\t    fi\n\t    prev=\"$cmd\"\n\t  done\n\n\t  if test \"$prev\" != 'sed 50q \"[$]0\"'; then\n\t    echo_test_string=`eval $prev`\n\t    export echo_test_string\n\t    exec ${ORIGINAL_CONFIG_SHELL-${CONFIG_SHELL-/bin/sh}} \"[$]0\" ${1+\"[$]@\"}\n\t  else\n\t    # Oops.  We lost completely, so just stick with echo.\n\t    ECHO=echo\n\t  fi\n        fi\n      fi\n    fi\n  fi\nfi\n\n# Copy echo and quote the copy suitably for passing to libtool from\n# the Makefile, instead of quoting the original, which is used later.\nlt_ECHO=$ECHO\nif test \"X$lt_ECHO\" = \"X$CONFIG_SHELL [$]0 --fallback-echo\"; then\n   lt_ECHO=\"$CONFIG_SHELL \\\\\\$\\[$]0 --fallback-echo\"\nfi\n\nAC_SUBST(lt_ECHO)\n])\n_LT_DECL([], [SHELL], [1], [Shell to use when invoking shell scripts])\n_LT_DECL([], [ECHO], [1],\n    [An echo program that does not interpret backslashes])\n])# _LT_PROG_ECHO_BACKSLASH\n\n\n# _LT_ENABLE_LOCK\n# ---------------\nm4_defun([_LT_ENABLE_LOCK],\n[AC_ARG_ENABLE([libtool-lock],\n  [AS_HELP_STRING([--disable-libtool-lock],\n    [avoid locking (might break parallel builds)])])\ntest \"x$enable_libtool_lock\" != xno && enable_libtool_lock=yes\n\n# Some flags need to be propagated to the compiler or linker for good\n# libtool support.\ncase $host in\nia64-*-hpux*)\n  # Find out which ABI we are using.\n  echo 'int i;' > conftest.$ac_ext\n  if AC_TRY_EVAL(ac_compile); then\n    case `/usr/bin/file conftest.$ac_objext` in\n      *ELF-32*)\n\tHPUX_IA64_MODE=\"32\"\n\t;;\n      *ELF-64*)\n\tHPUX_IA64_MODE=\"64\"\n\t;;\n    esac\n  fi\n  rm -rf conftest*\n  ;;\n*-*-irix6*)\n  # Find out which ABI we are using.\n  echo '[#]line __oline__ \"configure\"' > conftest.$ac_ext\n  if AC_TRY_EVAL(ac_compile); then\n    if test \"$lt_cv_prog_gnu_ld\" = yes; then\n      case `/usr/bin/file conftest.$ac_objext` in\n\t*32-bit*)\n\t  LD=\"${LD-ld} -melf32bsmip\"\n\t  ;;\n\t*N32*)\n\t  LD=\"${LD-ld} -melf32bmipn32\"\n\t  ;;\n\t*64-bit*)\n\t  LD=\"${LD-ld} -melf64bmip\"\n\t;;\n      esac\n    else\n      case `/usr/bin/file conftest.$ac_objext` in\n\t*32-bit*)\n\t  LD=\"${LD-ld} -32\"\n\t  ;;\n\t*N32*)\n\t  LD=\"${LD-ld} -n32\"\n\t  ;;\n\t*64-bit*)\n\t  LD=\"${LD-ld} -64\"\n\t  ;;\n      esac\n    fi\n  fi\n  rm -rf conftest*\n  ;;\n\nx86_64-*kfreebsd*-gnu|x86_64-*linux*|ppc*-*linux*|powerpc*-*linux*| \\\ns390*-*linux*|s390*-*tpf*|sparc*-*linux*)\n  # Find out which ABI we are using.\n  echo 'int i;' > conftest.$ac_ext\n  if AC_TRY_EVAL(ac_compile); then\n    case `/usr/bin/file conftest.o` in\n      *32-bit*)\n\tcase $host in\n\t  x86_64-*kfreebsd*-gnu)\n\t    LD=\"${LD-ld} -m elf_i386_fbsd\"\n\t    ;;\n\t  x86_64-*linux*)\n\t    LD=\"${LD-ld} -m elf_i386\"\n\t    ;;\n\t  ppc64-*linux*|powerpc64-*linux*)\n\t    LD=\"${LD-ld} -m elf32ppclinux\"\n\t    ;;\n\t  s390x-*linux*)\n\t    LD=\"${LD-ld} -m elf_s390\"\n\t    ;;\n\t  sparc64-*linux*)\n\t    LD=\"${LD-ld} -m elf32_sparc\"\n\t    ;;\n\tesac\n\t;;\n      *64-bit*)\n\tcase $host in\n\t  x86_64-*kfreebsd*-gnu)\n\t    LD=\"${LD-ld} -m elf_x86_64_fbsd\"\n\t    ;;\n\t  x86_64-*linux*)\n\t    LD=\"${LD-ld} -m elf_x86_64\"\n\t    ;;\n\t  ppc*-*linux*|powerpc*-*linux*)\n\t    LD=\"${LD-ld} -m elf64ppc\"\n\t    ;;\n\t  s390*-*linux*|s390*-*tpf*)\n\t    LD=\"${LD-ld} -m elf64_s390\"\n\t    ;;\n\t  sparc*-*linux*)\n\t    LD=\"${LD-ld} -m elf64_sparc\"\n\t    ;;\n\tesac\n\t;;\n    esac\n  fi\n  rm -rf conftest*\n  ;;\n\n*-*-sco3.2v5*)\n  # On SCO OpenServer 5, we need -belf to get full-featured binaries.\n  SAVE_CFLAGS=\"$CFLAGS\"\n  CFLAGS=\"$CFLAGS -belf\"\n  AC_CACHE_CHECK([whether the C compiler needs -belf], lt_cv_cc_needs_belf,\n    [AC_LANG_PUSH(C)\n     AC_LINK_IFELSE([AC_LANG_PROGRAM([[]],[[]])],[lt_cv_cc_needs_belf=yes],[lt_cv_cc_needs_belf=no])\n     AC_LANG_POP])\n  if test x\"$lt_cv_cc_needs_belf\" != x\"yes\"; then\n    # this is probably gcc 2.8.0, egcs 1.0 or newer; no need for -belf\n    CFLAGS=\"$SAVE_CFLAGS\"\n  fi\n  ;;\nsparc*-*solaris*)\n  # Find out which ABI we are using.\n  echo 'int i;' > conftest.$ac_ext\n  if AC_TRY_EVAL(ac_compile); then\n    case `/usr/bin/file conftest.o` in\n    *64-bit*)\n      case $lt_cv_prog_gnu_ld in\n      yes*) LD=\"${LD-ld} -m elf64_sparc\" ;;\n      *)\n\tif ${LD-ld} -64 -r -o conftest2.o conftest.o >/dev/null 2>&1; then\n\t  LD=\"${LD-ld} -64\"\n\tfi\n\t;;\n      esac\n      ;;\n    esac\n  fi\n  rm -rf conftest*\n  ;;\nesac\n\nneed_locks=\"$enable_libtool_lock\"\n])# _LT_ENABLE_LOCK\n\n\n# _LT_CMD_OLD_ARCHIVE\n# -------------------\nm4_defun([_LT_CMD_OLD_ARCHIVE],\n[AC_CHECK_TOOL(AR, ar, false)\ntest -z \"$AR\" && AR=ar\ntest -z \"$AR_FLAGS\" && AR_FLAGS=cru\n_LT_DECL([], [AR], [1], [The archiver])\n_LT_DECL([], [AR_FLAGS], [1])\n\nAC_CHECK_TOOL(STRIP, strip, :)\ntest -z \"$STRIP\" && STRIP=:\n_LT_DECL([], [STRIP], [1], [A symbol stripping program])\n\nAC_CHECK_TOOL(RANLIB, ranlib, :)\ntest -z \"$RANLIB\" && RANLIB=:\n_LT_DECL([], [RANLIB], [1],\n    [Commands used to install an old-style archive])\n\n# Determine commands to create old-style static archives.\nold_archive_cmds='$AR $AR_FLAGS $oldlib$oldobjs'\nold_postinstall_cmds='chmod 644 $oldlib'\nold_postuninstall_cmds=\n\nif test -n \"$RANLIB\"; then\n  case $host_os in\n  openbsd*)\n    old_postinstall_cmds=\"$old_postinstall_cmds~\\$RANLIB -t \\$oldlib\"\n    ;;\n  *)\n    old_postinstall_cmds=\"$old_postinstall_cmds~\\$RANLIB \\$oldlib\"\n    ;;\n  esac\n  old_archive_cmds=\"$old_archive_cmds~\\$RANLIB \\$oldlib\"\nfi\n_LT_DECL([], [old_postinstall_cmds], [2])\n_LT_DECL([], [old_postuninstall_cmds], [2])\n_LT_TAGDECL([], [old_archive_cmds], [2],\n    [Commands used to build an old-style archive])\n])# _LT_CMD_OLD_ARCHIVE\n\n\n# _LT_COMPILER_OPTION(MESSAGE, VARIABLE-NAME, FLAGS,\n#\t\t[OUTPUT-FILE], [ACTION-SUCCESS], [ACTION-FAILURE])\n# ----------------------------------------------------------------\n# Check whether the given compiler option works\nAC_DEFUN([_LT_COMPILER_OPTION],\n[m4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_DECL_SED])dnl\nAC_CACHE_CHECK([$1], [$2],\n  [$2=no\n   m4_if([$4], , [ac_outfile=conftest.$ac_objext], [ac_outfile=$4])\n   echo \"$lt_simple_compile_test_code\" > conftest.$ac_ext\n   lt_compiler_flag=\"$3\"\n   # Insert the option either (1) after the last *FLAGS variable, or\n   # (2) before a word containing \"conftest.\", or (3) at the end.\n   # Note that $ac_compile itself does not contain backslashes and begins\n   # with a dollar sign (not a hyphen), so the echo should work correctly.\n   # The option is referenced via a variable to avoid confusing sed.\n   lt_compile=`echo \"$ac_compile\" | $SED \\\n   -e 's:.*FLAGS}\\{0,1\\} :&$lt_compiler_flag :; t' \\\n   -e 's: [[^ ]]*conftest\\.: $lt_compiler_flag&:; t' \\\n   -e 's:$: $lt_compiler_flag:'`\n   (eval echo \"\\\"\\$as_me:__oline__: $lt_compile\\\"\" >&AS_MESSAGE_LOG_FD)\n   (eval \"$lt_compile\" 2>conftest.err)\n   ac_status=$?\n   cat conftest.err >&AS_MESSAGE_LOG_FD\n   echo \"$as_me:__oline__: \\$? = $ac_status\" >&AS_MESSAGE_LOG_FD\n   if (exit $ac_status) && test -s \"$ac_outfile\"; then\n     # The compiler can only warn and ignore the option if not recognized\n     # So say no if there are warnings other than the usual output.\n     $ECHO \"X$_lt_compiler_boilerplate\" | $Xsed -e '/^$/d' >conftest.exp\n     $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2\n     if test ! -s conftest.er2 || diff conftest.exp conftest.er2 >/dev/null; then\n       $2=yes\n     fi\n   fi\n   $RM conftest*\n])\n\nif test x\"[$]$2\" = xyes; then\n    m4_if([$5], , :, [$5])\nelse\n    m4_if([$6], , :, [$6])\nfi\n])# _LT_COMPILER_OPTION\n\n# Old name:\nAU_ALIAS([AC_LIBTOOL_COMPILER_OPTION], [_LT_COMPILER_OPTION])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_COMPILER_OPTION], [])\n\n\n# _LT_LINKER_OPTION(MESSAGE, VARIABLE-NAME, FLAGS,\n#                  [ACTION-SUCCESS], [ACTION-FAILURE])\n# ----------------------------------------------------\n# Check whether the given linker option works\nAC_DEFUN([_LT_LINKER_OPTION],\n[m4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_DECL_SED])dnl\nAC_CACHE_CHECK([$1], [$2],\n  [$2=no\n   save_LDFLAGS=\"$LDFLAGS\"\n   LDFLAGS=\"$LDFLAGS $3\"\n   echo \"$lt_simple_link_test_code\" > conftest.$ac_ext\n   if (eval $ac_link 2>conftest.err) && test -s conftest$ac_exeext; then\n     # The linker can only warn and ignore the option if not recognized\n     # So say no if there are warnings\n     if test -s conftest.err; then\n       # Append any errors to the config.log.\n       cat conftest.err 1>&AS_MESSAGE_LOG_FD\n       $ECHO \"X$_lt_linker_boilerplate\" | $Xsed -e '/^$/d' > conftest.exp\n       $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2\n       if diff conftest.exp conftest.er2 >/dev/null; then\n         $2=yes\n       fi\n     else\n       $2=yes\n     fi\n   fi\n   $RM -r conftest*\n   LDFLAGS=\"$save_LDFLAGS\"\n])\n\nif test x\"[$]$2\" = xyes; then\n    m4_if([$4], , :, [$4])\nelse\n    m4_if([$5], , :, [$5])\nfi\n])# _LT_LINKER_OPTION\n\n# Old name:\nAU_ALIAS([AC_LIBTOOL_LINKER_OPTION], [_LT_LINKER_OPTION])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_LINKER_OPTION], [])\n\n\n# LT_CMD_MAX_LEN\n#---------------\nAC_DEFUN([LT_CMD_MAX_LEN],\n[AC_REQUIRE([AC_CANONICAL_HOST])dnl\n# find the maximum length of command line arguments\nAC_MSG_CHECKING([the maximum length of command line arguments])\nAC_CACHE_VAL([lt_cv_sys_max_cmd_len], [dnl\n  i=0\n  teststring=\"ABCD\"\n\n  case $build_os in\n  msdosdjgpp*)\n    # On DJGPP, this test can blow up pretty badly due to problems in libc\n    # (any single argument exceeding 2000 bytes causes a buffer overrun\n    # during glob expansion).  Even if it were fixed, the result of this\n    # check would be larger than it should be.\n    lt_cv_sys_max_cmd_len=12288;    # 12K is about right\n    ;;\n\n  gnu*)\n    # Under GNU Hurd, this test is not required because there is\n    # no limit to the length of command line arguments.\n    # Libtool will interpret -1 as no limit whatsoever\n    lt_cv_sys_max_cmd_len=-1;\n    ;;\n\n  cygwin* | mingw* | cegcc*)\n    # On Win9x/ME, this test blows up -- it succeeds, but takes\n    # about 5 minutes as the teststring grows exponentially.\n    # Worse, since 9x/ME are not pre-emptively multitasking,\n    # you end up with a \"frozen\" computer, even though with patience\n    # the test eventually succeeds (with a max line length of 256k).\n    # Instead, let's just punt: use the minimum linelength reported by\n    # all of the supported platforms: 8192 (on NT/2K/XP).\n    lt_cv_sys_max_cmd_len=8192;\n    ;;\n\n  amigaos*)\n    # On AmigaOS with pdksh, this test takes hours, literally.\n    # So we just punt and use a minimum line length of 8192.\n    lt_cv_sys_max_cmd_len=8192;\n    ;;\n\n  netbsd* | freebsd* | openbsd* | darwin* | dragonfly*)\n    # This has been around since 386BSD, at least.  Likely further.\n    if test -x /sbin/sysctl; then\n      lt_cv_sys_max_cmd_len=`/sbin/sysctl -n kern.argmax`\n    elif test -x /usr/sbin/sysctl; then\n      lt_cv_sys_max_cmd_len=`/usr/sbin/sysctl -n kern.argmax`\n    else\n      lt_cv_sys_max_cmd_len=65536\t# usable default for all BSDs\n    fi\n    # And add a safety zone\n    lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \\/ 4`\n    lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \\* 3`\n    ;;\n\n  interix*)\n    # We know the value 262144 and hardcode it with a safety zone (like BSD)\n    lt_cv_sys_max_cmd_len=196608\n    ;;\n\n  osf*)\n    # Dr. Hans Ekkehard Plesser reports seeing a kernel panic running configure\n    # due to this test when exec_disable_arg_limit is 1 on Tru64. It is not\n    # nice to cause kernel panics so lets avoid the loop below.\n    # First set a reasonable default.\n    lt_cv_sys_max_cmd_len=16384\n    #\n    if test -x /sbin/sysconfig; then\n      case `/sbin/sysconfig -q proc exec_disable_arg_limit` in\n        *1*) lt_cv_sys_max_cmd_len=-1 ;;\n      esac\n    fi\n    ;;\n  sco3.2v5*)\n    lt_cv_sys_max_cmd_len=102400\n    ;;\n  sysv5* | sco5v6* | sysv4.2uw2*)\n    kargmax=`grep ARG_MAX /etc/conf/cf.d/stune 2>/dev/null`\n    if test -n \"$kargmax\"; then\n      lt_cv_sys_max_cmd_len=`echo $kargmax | sed 's/.*[[\t ]]//'`\n    else\n      lt_cv_sys_max_cmd_len=32768\n    fi\n    ;;\n  *)\n    lt_cv_sys_max_cmd_len=`(getconf ARG_MAX) 2> /dev/null`\n    if test -n \"$lt_cv_sys_max_cmd_len\"; then\n      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \\/ 4`\n      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \\* 3`\n    else\n      # Make teststring a little bigger before we do anything with it.\n      # a 1K string should be a reasonable start.\n      for i in 1 2 3 4 5 6 7 8 ; do\n        teststring=$teststring$teststring\n      done\n      SHELL=${SHELL-${CONFIG_SHELL-/bin/sh}}\n      # If test is not a shell built-in, we'll probably end up computing a\n      # maximum length that is only half of the actual maximum length, but\n      # we can't tell.\n      while { test \"X\"`$SHELL [$]0 --fallback-echo \"X$teststring$teststring\" 2>/dev/null` \\\n\t         = \"XX$teststring$teststring\"; } >/dev/null 2>&1 &&\n\t      test $i != 17 # 1/2 MB should be enough\n      do\n        i=`expr $i + 1`\n        teststring=$teststring$teststring\n      done\n      # Only check the string length outside the loop.\n      lt_cv_sys_max_cmd_len=`expr \"X$teststring\" : \".*\" 2>&1`\n      teststring=\n      # Add a significant safety factor because C++ compilers can tack on\n      # massive amounts of additional arguments before passing them to the\n      # linker.  It appears as though 1/2 is a usable value.\n      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \\/ 2`\n    fi\n    ;;\n  esac\n])\nif test -n $lt_cv_sys_max_cmd_len ; then\n  AC_MSG_RESULT($lt_cv_sys_max_cmd_len)\nelse\n  AC_MSG_RESULT(none)\nfi\nmax_cmd_len=$lt_cv_sys_max_cmd_len\n_LT_DECL([], [max_cmd_len], [0],\n    [What is the maximum length of a command?])\n])# LT_CMD_MAX_LEN\n\n# Old name:\nAU_ALIAS([AC_LIBTOOL_SYS_MAX_CMD_LEN], [LT_CMD_MAX_LEN])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_SYS_MAX_CMD_LEN], [])\n\n\n# _LT_HEADER_DLFCN\n# ----------------\nm4_defun([_LT_HEADER_DLFCN],\n[AC_CHECK_HEADERS([dlfcn.h], [], [], [AC_INCLUDES_DEFAULT])dnl\n])# _LT_HEADER_DLFCN\n\n\n# _LT_TRY_DLOPEN_SELF (ACTION-IF-TRUE, ACTION-IF-TRUE-W-USCORE,\n#                      ACTION-IF-FALSE, ACTION-IF-CROSS-COMPILING)\n# ----------------------------------------------------------------\nm4_defun([_LT_TRY_DLOPEN_SELF],\n[m4_require([_LT_HEADER_DLFCN])dnl\nif test \"$cross_compiling\" = yes; then :\n  [$4]\nelse\n  lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n  lt_status=$lt_dlunknown\n  cat > conftest.$ac_ext <<_LT_EOF\n[#line __oline__ \"configure\"\n#include \"confdefs.h\"\n\n#if HAVE_DLFCN_H\n#include <dlfcn.h>\n#endif\n\n#include <stdio.h>\n\n#ifdef RTLD_GLOBAL\n#  define LT_DLGLOBAL\t\tRTLD_GLOBAL\n#else\n#  ifdef DL_GLOBAL\n#    define LT_DLGLOBAL\t\tDL_GLOBAL\n#  else\n#    define LT_DLGLOBAL\t\t0\n#  endif\n#endif\n\n/* We may have to define LT_DLLAZY_OR_NOW in the command line if we\n   find out it does not work in some platform. */\n#ifndef LT_DLLAZY_OR_NOW\n#  ifdef RTLD_LAZY\n#    define LT_DLLAZY_OR_NOW\t\tRTLD_LAZY\n#  else\n#    ifdef DL_LAZY\n#      define LT_DLLAZY_OR_NOW\t\tDL_LAZY\n#    else\n#      ifdef RTLD_NOW\n#        define LT_DLLAZY_OR_NOW\tRTLD_NOW\n#      else\n#        ifdef DL_NOW\n#          define LT_DLLAZY_OR_NOW\tDL_NOW\n#        else\n#          define LT_DLLAZY_OR_NOW\t0\n#        endif\n#      endif\n#    endif\n#  endif\n#endif\n\nvoid fnord() { int i=42;}\nint main ()\n{\n  void *self = dlopen (0, LT_DLGLOBAL|LT_DLLAZY_OR_NOW);\n  int status = $lt_dlunknown;\n\n  if (self)\n    {\n      if (dlsym (self,\"fnord\"))       status = $lt_dlno_uscore;\n      else if (dlsym( self,\"_fnord\")) status = $lt_dlneed_uscore;\n      /* dlclose (self); */\n    }\n  else\n    puts (dlerror ());\n\n  return status;\n}]\n_LT_EOF\n  if AC_TRY_EVAL(ac_link) && test -s conftest${ac_exeext} 2>/dev/null; then\n    (./conftest; exit; ) >&AS_MESSAGE_LOG_FD 2>/dev/null\n    lt_status=$?\n    case x$lt_status in\n      x$lt_dlno_uscore) $1 ;;\n      x$lt_dlneed_uscore) $2 ;;\n      x$lt_dlunknown|x*) $3 ;;\n    esac\n  else :\n    # compilation failed\n    $3\n  fi\nfi\nrm -fr conftest*\n])# _LT_TRY_DLOPEN_SELF\n\n\n# LT_SYS_DLOPEN_SELF\n# ------------------\nAC_DEFUN([LT_SYS_DLOPEN_SELF],\n[m4_require([_LT_HEADER_DLFCN])dnl\nif test \"x$enable_dlopen\" != xyes; then\n  enable_dlopen=unknown\n  enable_dlopen_self=unknown\n  enable_dlopen_self_static=unknown\nelse\n  lt_cv_dlopen=no\n  lt_cv_dlopen_libs=\n\n  case $host_os in\n  beos*)\n    lt_cv_dlopen=\"load_add_on\"\n    lt_cv_dlopen_libs=\n    lt_cv_dlopen_self=yes\n    ;;\n\n  mingw* | pw32* | cegcc*)\n    lt_cv_dlopen=\"LoadLibrary\"\n    lt_cv_dlopen_libs=\n    ;;\n\n  cygwin*)\n    lt_cv_dlopen=\"dlopen\"\n    lt_cv_dlopen_libs=\n    ;;\n\n  darwin*)\n  # if libdl is installed we need to link against it\n    AC_CHECK_LIB([dl], [dlopen],\n\t\t[lt_cv_dlopen=\"dlopen\" lt_cv_dlopen_libs=\"-ldl\"],[\n    lt_cv_dlopen=\"dyld\"\n    lt_cv_dlopen_libs=\n    lt_cv_dlopen_self=yes\n    ])\n    ;;\n\n  *)\n    AC_CHECK_FUNC([shl_load],\n\t  [lt_cv_dlopen=\"shl_load\"],\n      [AC_CHECK_LIB([dld], [shl_load],\n\t    [lt_cv_dlopen=\"shl_load\" lt_cv_dlopen_libs=\"-ldld\"],\n\t[AC_CHECK_FUNC([dlopen],\n\t      [lt_cv_dlopen=\"dlopen\"],\n\t  [AC_CHECK_LIB([dl], [dlopen],\n\t\t[lt_cv_dlopen=\"dlopen\" lt_cv_dlopen_libs=\"-ldl\"],\n\t    [AC_CHECK_LIB([svld], [dlopen],\n\t\t  [lt_cv_dlopen=\"dlopen\" lt_cv_dlopen_libs=\"-lsvld\"],\n\t      [AC_CHECK_LIB([dld], [dld_link],\n\t\t    [lt_cv_dlopen=\"dld_link\" lt_cv_dlopen_libs=\"-ldld\"])\n\t      ])\n\t    ])\n\t  ])\n\t])\n      ])\n    ;;\n  esac\n\n  if test \"x$lt_cv_dlopen\" != xno; then\n    enable_dlopen=yes\n  else\n    enable_dlopen=no\n  fi\n\n  case $lt_cv_dlopen in\n  dlopen)\n    save_CPPFLAGS=\"$CPPFLAGS\"\n    test \"x$ac_cv_header_dlfcn_h\" = xyes && CPPFLAGS=\"$CPPFLAGS -DHAVE_DLFCN_H\"\n\n    save_LDFLAGS=\"$LDFLAGS\"\n    wl=$lt_prog_compiler_wl eval LDFLAGS=\\\"\\$LDFLAGS $export_dynamic_flag_spec\\\"\n\n    save_LIBS=\"$LIBS\"\n    LIBS=\"$lt_cv_dlopen_libs $LIBS\"\n\n    AC_CACHE_CHECK([whether a program can dlopen itself],\n\t  lt_cv_dlopen_self, [dnl\n\t  _LT_TRY_DLOPEN_SELF(\n\t    lt_cv_dlopen_self=yes, lt_cv_dlopen_self=yes,\n\t    lt_cv_dlopen_self=no, lt_cv_dlopen_self=cross)\n    ])\n\n    if test \"x$lt_cv_dlopen_self\" = xyes; then\n      wl=$lt_prog_compiler_wl eval LDFLAGS=\\\"\\$LDFLAGS $lt_prog_compiler_static\\\"\n      AC_CACHE_CHECK([whether a statically linked program can dlopen itself],\n\t  lt_cv_dlopen_self_static, [dnl\n\t  _LT_TRY_DLOPEN_SELF(\n\t    lt_cv_dlopen_self_static=yes, lt_cv_dlopen_self_static=yes,\n\t    lt_cv_dlopen_self_static=no,  lt_cv_dlopen_self_static=cross)\n      ])\n    fi\n\n    CPPFLAGS=\"$save_CPPFLAGS\"\n    LDFLAGS=\"$save_LDFLAGS\"\n    LIBS=\"$save_LIBS\"\n    ;;\n  esac\n\n  case $lt_cv_dlopen_self in\n  yes|no) enable_dlopen_self=$lt_cv_dlopen_self ;;\n  *) enable_dlopen_self=unknown ;;\n  esac\n\n  case $lt_cv_dlopen_self_static in\n  yes|no) enable_dlopen_self_static=$lt_cv_dlopen_self_static ;;\n  *) enable_dlopen_self_static=unknown ;;\n  esac\nfi\n_LT_DECL([dlopen_support], [enable_dlopen], [0],\n\t [Whether dlopen is supported])\n_LT_DECL([dlopen_self], [enable_dlopen_self], [0],\n\t [Whether dlopen of programs is supported])\n_LT_DECL([dlopen_self_static], [enable_dlopen_self_static], [0],\n\t [Whether dlopen of statically linked programs is supported])\n])# LT_SYS_DLOPEN_SELF\n\n# Old name:\nAU_ALIAS([AC_LIBTOOL_DLOPEN_SELF], [LT_SYS_DLOPEN_SELF])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_DLOPEN_SELF], [])\n\n\n# _LT_COMPILER_C_O([TAGNAME])\n# ---------------------------\n# Check to see if options -c and -o are simultaneously supported by compiler.\n# This macro does not hard code the compiler like AC_PROG_CC_C_O.\nm4_defun([_LT_COMPILER_C_O],\n[m4_require([_LT_DECL_SED])dnl\nm4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_TAG_COMPILER])dnl\nAC_CACHE_CHECK([if $compiler supports -c -o file.$ac_objext],\n  [_LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)],\n  [_LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)=no\n   $RM -r conftest 2>/dev/null\n   mkdir conftest\n   cd conftest\n   mkdir out\n   echo \"$lt_simple_compile_test_code\" > conftest.$ac_ext\n\n   lt_compiler_flag=\"-o out/conftest2.$ac_objext\"\n   # Insert the option either (1) after the last *FLAGS variable, or\n   # (2) before a word containing \"conftest.\", or (3) at the end.\n   # Note that $ac_compile itself does not contain backslashes and begins\n   # with a dollar sign (not a hyphen), so the echo should work correctly.\n   lt_compile=`echo \"$ac_compile\" | $SED \\\n   -e 's:.*FLAGS}\\{0,1\\} :&$lt_compiler_flag :; t' \\\n   -e 's: [[^ ]]*conftest\\.: $lt_compiler_flag&:; t' \\\n   -e 's:$: $lt_compiler_flag:'`\n   (eval echo \"\\\"\\$as_me:__oline__: $lt_compile\\\"\" >&AS_MESSAGE_LOG_FD)\n   (eval \"$lt_compile\" 2>out/conftest.err)\n   ac_status=$?\n   cat out/conftest.err >&AS_MESSAGE_LOG_FD\n   echo \"$as_me:__oline__: \\$? = $ac_status\" >&AS_MESSAGE_LOG_FD\n   if (exit $ac_status) && test -s out/conftest2.$ac_objext\n   then\n     # The compiler can only warn and ignore the option if not recognized\n     # So say no if there are warnings\n     $ECHO \"X$_lt_compiler_boilerplate\" | $Xsed -e '/^$/d' > out/conftest.exp\n     $SED '/^$/d; /^ *+/d' out/conftest.err >out/conftest.er2\n     if test ! -s out/conftest.er2 || diff out/conftest.exp out/conftest.er2 >/dev/null; then\n       _LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)=yes\n     fi\n   fi\n   chmod u+w . 2>&AS_MESSAGE_LOG_FD\n   $RM conftest*\n   # SGI C++ compiler will create directory out/ii_files/ for\n   # template instantiation\n   test -d out/ii_files && $RM out/ii_files/* && rmdir out/ii_files\n   $RM out/* && rmdir out\n   cd ..\n   $RM -r conftest\n   $RM conftest*\n])\n_LT_TAGDECL([compiler_c_o], [lt_cv_prog_compiler_c_o], [1],\n\t[Does compiler simultaneously support -c and -o options?])\n])# _LT_COMPILER_C_O\n\n\n# _LT_COMPILER_FILE_LOCKS([TAGNAME])\n# ----------------------------------\n# Check to see if we can do hard links to lock some files if needed\nm4_defun([_LT_COMPILER_FILE_LOCKS],\n[m4_require([_LT_ENABLE_LOCK])dnl\nm4_require([_LT_FILEUTILS_DEFAULTS])dnl\n_LT_COMPILER_C_O([$1])\n\nhard_links=\"nottested\"\nif test \"$_LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)\" = no && test \"$need_locks\" != no; then\n  # do not overwrite the value of need_locks provided by the user\n  AC_MSG_CHECKING([if we can lock with hard links])\n  hard_links=yes\n  $RM conftest*\n  ln conftest.a conftest.b 2>/dev/null && hard_links=no\n  touch conftest.a\n  ln conftest.a conftest.b 2>&5 || hard_links=no\n  ln conftest.a conftest.b 2>/dev/null && hard_links=no\n  AC_MSG_RESULT([$hard_links])\n  if test \"$hard_links\" = no; then\n    AC_MSG_WARN([`$CC' does not support `-c -o', so `make -j' may be unsafe])\n    need_locks=warn\n  fi\nelse\n  need_locks=no\nfi\n_LT_DECL([], [need_locks], [1], [Must we lock files when doing compilation?])\n])# _LT_COMPILER_FILE_LOCKS\n\n\n# _LT_CHECK_OBJDIR\n# ----------------\nm4_defun([_LT_CHECK_OBJDIR],\n[AC_CACHE_CHECK([for objdir], [lt_cv_objdir],\n[rm -f .libs 2>/dev/null\nmkdir .libs 2>/dev/null\nif test -d .libs; then\n  lt_cv_objdir=.libs\nelse\n  # MS-DOS does not allow filenames that begin with a dot.\n  lt_cv_objdir=_libs\nfi\nrmdir .libs 2>/dev/null])\nobjdir=$lt_cv_objdir\n_LT_DECL([], [objdir], [0],\n         [The name of the directory that contains temporary libtool files])dnl\nm4_pattern_allow([LT_OBJDIR])dnl\nAC_DEFINE_UNQUOTED(LT_OBJDIR, \"$lt_cv_objdir/\",\n  [Define to the sub-directory in which libtool stores uninstalled libraries.])\n])# _LT_CHECK_OBJDIR\n\n\n# _LT_LINKER_HARDCODE_LIBPATH([TAGNAME])\n# --------------------------------------\n# Check hardcoding attributes.\nm4_defun([_LT_LINKER_HARDCODE_LIBPATH],\n[AC_MSG_CHECKING([how to hardcode library paths into programs])\n_LT_TAGVAR(hardcode_action, $1)=\nif test -n \"$_LT_TAGVAR(hardcode_libdir_flag_spec, $1)\" ||\n   test -n \"$_LT_TAGVAR(runpath_var, $1)\" ||\n   test \"X$_LT_TAGVAR(hardcode_automatic, $1)\" = \"Xyes\" ; then\n\n  # We can hardcode non-existent directories.\n  if test \"$_LT_TAGVAR(hardcode_direct, $1)\" != no &&\n     # If the only mechanism to avoid hardcoding is shlibpath_var, we\n     # have to relink, otherwise we might link with an installed library\n     # when we should be linking with a yet-to-be-installed one\n     ## test \"$_LT_TAGVAR(hardcode_shlibpath_var, $1)\" != no &&\n     test \"$_LT_TAGVAR(hardcode_minus_L, $1)\" != no; then\n    # Linking always hardcodes the temporary library directory.\n    _LT_TAGVAR(hardcode_action, $1)=relink\n  else\n    # We can link without hardcoding, and we can hardcode nonexisting dirs.\n    _LT_TAGVAR(hardcode_action, $1)=immediate\n  fi\nelse\n  # We cannot hardcode anything, or else we can only hardcode existing\n  # directories.\n  _LT_TAGVAR(hardcode_action, $1)=unsupported\nfi\nAC_MSG_RESULT([$_LT_TAGVAR(hardcode_action, $1)])\n\nif test \"$_LT_TAGVAR(hardcode_action, $1)\" = relink ||\n   test \"$_LT_TAGVAR(inherit_rpath, $1)\" = yes; then\n  # Fast installation is not supported\n  enable_fast_install=no\nelif test \"$shlibpath_overrides_runpath\" = yes ||\n     test \"$enable_shared\" = no; then\n  # Fast installation is not necessary\n  enable_fast_install=needless\nfi\n_LT_TAGDECL([], [hardcode_action], [0],\n    [How to hardcode a shared library path into an executable])\n])# _LT_LINKER_HARDCODE_LIBPATH\n\n\n# _LT_CMD_STRIPLIB\n# ----------------\nm4_defun([_LT_CMD_STRIPLIB],\n[m4_require([_LT_DECL_EGREP])\nstriplib=\nold_striplib=\nAC_MSG_CHECKING([whether stripping libraries is possible])\nif test -n \"$STRIP\" && $STRIP -V 2>&1 | $GREP \"GNU strip\" >/dev/null; then\n  test -z \"$old_striplib\" && old_striplib=\"$STRIP --strip-debug\"\n  test -z \"$striplib\" && striplib=\"$STRIP --strip-unneeded\"\n  AC_MSG_RESULT([yes])\nelse\n# FIXME - insert some real tests, host_os isn't really good enough\n  case $host_os in\n  darwin*)\n    if test -n \"$STRIP\" ; then\n      striplib=\"$STRIP -x\"\n      old_striplib=\"$STRIP -S\"\n      AC_MSG_RESULT([yes])\n    else\n      AC_MSG_RESULT([no])\n    fi\n    ;;\n  *)\n    AC_MSG_RESULT([no])\n    ;;\n  esac\nfi\n_LT_DECL([], [old_striplib], [1], [Commands to strip libraries])\n_LT_DECL([], [striplib], [1])\n])# _LT_CMD_STRIPLIB\n\n\n# _LT_SYS_DYNAMIC_LINKER([TAG])\n# -----------------------------\n# PORTME Fill in your ld.so characteristics\nm4_defun([_LT_SYS_DYNAMIC_LINKER],\n[AC_REQUIRE([AC_CANONICAL_HOST])dnl\nm4_require([_LT_DECL_EGREP])dnl\nm4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_DECL_OBJDUMP])dnl\nm4_require([_LT_DECL_SED])dnl\nAC_MSG_CHECKING([dynamic linker characteristics])\nm4_if([$1],\n\t[], [\nif test \"$GCC\" = yes; then\n  case $host_os in\n    darwin*) lt_awk_arg=\"/^libraries:/,/LR/\" ;;\n    *) lt_awk_arg=\"/^libraries:/\" ;;\n  esac\n  lt_search_path_spec=`$CC -print-search-dirs | awk $lt_awk_arg | $SED -e \"s/^libraries://\" -e \"s,=/,/,g\"`\n  if $ECHO \"$lt_search_path_spec\" | $GREP ';' >/dev/null ; then\n    # if the path contains \";\" then we assume it to be the separator\n    # otherwise default to the standard path separator (i.e. \":\") - it is\n    # assumed that no part of a normal pathname contains \";\" but that should\n    # okay in the real world where \";\" in dirpaths is itself problematic.\n    lt_search_path_spec=`$ECHO \"$lt_search_path_spec\" | $SED -e 's/;/ /g'`\n  else\n    lt_search_path_spec=`$ECHO \"$lt_search_path_spec\" | $SED  -e \"s/$PATH_SEPARATOR/ /g\"`\n  fi\n  # Ok, now we have the path, separated by spaces, we can step through it\n  # and add multilib dir if necessary.\n  lt_tmp_lt_search_path_spec=\n  lt_multi_os_dir=`$CC $CPPFLAGS $CFLAGS $LDFLAGS -print-multi-os-directory 2>/dev/null`\n  for lt_sys_path in $lt_search_path_spec; do\n    if test -d \"$lt_sys_path/$lt_multi_os_dir\"; then\n      lt_tmp_lt_search_path_spec=\"$lt_tmp_lt_search_path_spec $lt_sys_path/$lt_multi_os_dir\"\n    else\n      test -d \"$lt_sys_path\" && \\\n\tlt_tmp_lt_search_path_spec=\"$lt_tmp_lt_search_path_spec $lt_sys_path\"\n    fi\n  done\n  lt_search_path_spec=`$ECHO $lt_tmp_lt_search_path_spec | awk '\nBEGIN {RS=\" \"; FS=\"/|\\n\";} {\n  lt_foo=\"\";\n  lt_count=0;\n  for (lt_i = NF; lt_i > 0; lt_i--) {\n    if ($lt_i != \"\" && $lt_i != \".\") {\n      if ($lt_i == \"..\") {\n        lt_count++;\n      } else {\n        if (lt_count == 0) {\n          lt_foo=\"/\" $lt_i lt_foo;\n        } else {\n          lt_count--;\n        }\n      }\n    }\n  }\n  if (lt_foo != \"\") { lt_freq[[lt_foo]]++; }\n  if (lt_freq[[lt_foo]] == 1) { print lt_foo; }\n}'`\n  sys_lib_search_path_spec=`$ECHO $lt_search_path_spec`\nelse\n  sys_lib_search_path_spec=\"/lib /usr/lib /usr/local/lib\"\nfi])\nlibrary_names_spec=\nlibname_spec='lib$name'\nsoname_spec=\nshrext_cmds=\".so\"\npostinstall_cmds=\npostuninstall_cmds=\nfinish_cmds=\nfinish_eval=\nshlibpath_var=\nshlibpath_overrides_runpath=unknown\nversion_type=none\ndynamic_linker=\"$host_os ld.so\"\nsys_lib_dlsearch_path_spec=\"/lib /usr/lib\"\nneed_lib_prefix=unknown\nhardcode_into_libs=no\n\n# when you set need_version to no, make sure it does not cause -set_version\n# flags to be left without arguments\nneed_version=unknown\n\ncase $host_os in\naix3*)\n  version_type=linux\n  library_names_spec='${libname}${release}${shared_ext}$versuffix $libname.a'\n  shlibpath_var=LIBPATH\n\n  # AIX 3 has no versioning support, so we append a major version to the name.\n  soname_spec='${libname}${release}${shared_ext}$major'\n  ;;\n\naix[[4-9]]*)\n  version_type=linux\n  need_lib_prefix=no\n  need_version=no\n  hardcode_into_libs=yes\n  if test \"$host_cpu\" = ia64; then\n    # AIX 5 supports IA64\n    library_names_spec='${libname}${release}${shared_ext}$major ${libname}${release}${shared_ext}$versuffix $libname${shared_ext}'\n    shlibpath_var=LD_LIBRARY_PATH\n  else\n    # With GCC up to 2.95.x, collect2 would create an import file\n    # for dependence libraries.  The import file would start with\n    # the line `#! .'.  This would cause the generated library to\n    # depend on `.', always an invalid library.  This was fixed in\n    # development snapshots of GCC prior to 3.0.\n    case $host_os in\n      aix4 | aix4.[[01]] | aix4.[[01]].*)\n      if { echo '#if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 97)'\n\t   echo ' yes '\n\t   echo '#endif'; } | ${CC} -E - | $GREP yes > /dev/null; then\n\t:\n      else\n\tcan_build_shared=no\n      fi\n      ;;\n    esac\n    # AIX (on Power*) has no versioning support, so currently we can not hardcode correct\n    # soname into executable. Probably we can add versioning support to\n    # collect2, so additional links can be useful in future.\n    if test \"$aix_use_runtimelinking\" = yes; then\n      # If using run time linking (on AIX 4.2 or later) use lib<name>.so\n      # instead of lib<name>.a to let people know that these are not\n      # typical AIX shared libraries.\n      library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n    else\n      # We preserve .a as extension for shared libraries through AIX4.2\n      # and later when we are not doing run time linking.\n      library_names_spec='${libname}${release}.a $libname.a'\n      soname_spec='${libname}${release}${shared_ext}$major'\n    fi\n    shlibpath_var=LIBPATH\n  fi\n  ;;\n\namigaos*)\n  case $host_cpu in\n  powerpc)\n    # Since July 2007 AmigaOS4 officially supports .so libraries.\n    # When compiling the executable, add -use-dynld -Lsobjs: to the compileline.\n    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n    ;;\n  m68k)\n    library_names_spec='$libname.ixlibrary $libname.a'\n    # Create ${libname}_ixlibrary.a entries in /sys/libs.\n    finish_eval='for lib in `ls $libdir/*.ixlibrary 2>/dev/null`; do libname=`$ECHO \"X$lib\" | $Xsed -e '\\''s%^.*/\\([[^/]]*\\)\\.ixlibrary$%\\1%'\\''`; test $RM /sys/libs/${libname}_ixlibrary.a; $show \"cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a\"; cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a || exit 1; done'\n    ;;\n  esac\n  ;;\n\nbeos*)\n  library_names_spec='${libname}${shared_ext}'\n  dynamic_linker=\"$host_os ld.so\"\n  shlibpath_var=LIBRARY_PATH\n  ;;\n\nbsdi[[45]]*)\n  version_type=linux\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  finish_cmds='PATH=\"\\$PATH:/sbin\" ldconfig $libdir'\n  shlibpath_var=LD_LIBRARY_PATH\n  sys_lib_search_path_spec=\"/shlib /usr/lib /usr/X11/lib /usr/contrib/lib /lib /usr/local/lib\"\n  sys_lib_dlsearch_path_spec=\"/shlib /usr/lib /usr/local/lib\"\n  # the default ld.so.conf also contains /usr/contrib/lib and\n  # /usr/X11R6/lib (/usr/X11 is a link to /usr/X11R6), but let us allow\n  # libtool to hard-code these into programs\n  ;;\n\ncygwin* | mingw* | pw32* | cegcc*)\n  version_type=windows\n  shrext_cmds=\".dll\"\n  need_version=no\n  need_lib_prefix=no\n\n  case $GCC,$host_os in\n  yes,cygwin* | yes,mingw* | yes,pw32* | yes,cegcc*)\n    library_names_spec='$libname.dll.a'\n    # DLL is installed to $(libdir)/../bin by postinstall_cmds\n    postinstall_cmds='base_file=`basename \\${file}`~\n      dlpath=`$SHELL 2>&1 -c '\\''. $dir/'\\''\\${base_file}'\\''i; echo \\$dlname'\\''`~\n      dldir=$destdir/`dirname \\$dlpath`~\n      test -d \\$dldir || mkdir -p \\$dldir~\n      $install_prog $dir/$dlname \\$dldir/$dlname~\n      chmod a+x \\$dldir/$dlname~\n      if test -n '\\''$stripme'\\'' && test -n '\\''$striplib'\\''; then\n        eval '\\''$striplib \\$dldir/$dlname'\\'' || exit \\$?;\n      fi'\n    postuninstall_cmds='dldll=`$SHELL 2>&1 -c '\\''. $file; echo \\$dlname'\\''`~\n      dlpath=$dir/\\$dldll~\n       $RM \\$dlpath'\n    shlibpath_overrides_runpath=yes\n\n    case $host_os in\n    cygwin*)\n      # Cygwin DLLs use 'cyg' prefix rather than 'lib'\n      soname_spec='`echo ${libname} | sed -e 's/^lib/cyg/'``echo ${release} | $SED -e 's/[[.]]/-/g'`${versuffix}${shared_ext}'\n      sys_lib_search_path_spec=\"/usr/lib /lib/w32api /lib /usr/local/lib\"\n      ;;\n    mingw* | cegcc*)\n      # MinGW DLLs use traditional 'lib' prefix\n      soname_spec='${libname}`echo ${release} | $SED -e 's/[[.]]/-/g'`${versuffix}${shared_ext}'\n      sys_lib_search_path_spec=`$CC -print-search-dirs | $GREP \"^libraries:\" | $SED -e \"s/^libraries://\" -e \"s,=/,/,g\"`\n      if $ECHO \"$sys_lib_search_path_spec\" | [$GREP ';[c-zC-Z]:/' >/dev/null]; then\n        # It is most probably a Windows format PATH printed by\n        # mingw gcc, but we are running on Cygwin. Gcc prints its search\n        # path with ; separators, and with drive letters. We can handle the\n        # drive letters (cygwin fileutils understands them), so leave them,\n        # especially as we might pass files found there to a mingw objdump,\n        # which wouldn't understand a cygwinified path. Ahh.\n        sys_lib_search_path_spec=`$ECHO \"$sys_lib_search_path_spec\" | $SED -e 's/;/ /g'`\n      else\n        sys_lib_search_path_spec=`$ECHO \"$sys_lib_search_path_spec\" | $SED  -e \"s/$PATH_SEPARATOR/ /g\"`\n      fi\n      ;;\n    pw32*)\n      # pw32 DLLs use 'pw' prefix rather than 'lib'\n      library_names_spec='`echo ${libname} | sed -e 's/^lib/pw/'``echo ${release} | $SED -e 's/[[.]]/-/g'`${versuffix}${shared_ext}'\n      ;;\n    esac\n    ;;\n\n  *)\n    library_names_spec='${libname}`echo ${release} | $SED -e 's/[[.]]/-/g'`${versuffix}${shared_ext} $libname.lib'\n    ;;\n  esac\n  dynamic_linker='Win32 ld.exe'\n  # FIXME: first we should search . and the directory the executable is in\n  shlibpath_var=PATH\n  ;;\n\ndarwin* | rhapsody*)\n  dynamic_linker=\"$host_os dyld\"\n  version_type=darwin\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${major}$shared_ext ${libname}$shared_ext'\n  soname_spec='${libname}${release}${major}$shared_ext'\n  shlibpath_overrides_runpath=yes\n  shlibpath_var=DYLD_LIBRARY_PATH\n  shrext_cmds='`test .$module = .yes && echo .so || echo .dylib`'\nm4_if([$1], [],[\n  sys_lib_search_path_spec=\"$sys_lib_search_path_spec /usr/local/lib\"])\n  sys_lib_dlsearch_path_spec='/usr/local/lib /lib /usr/lib'\n  ;;\n\ndgux*)\n  version_type=linux\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname$shared_ext'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  ;;\n\nfreebsd1*)\n  dynamic_linker=no\n  ;;\n\nfreebsd* | dragonfly*)\n  # DragonFly does not have aout.  When/if they implement a new\n  # versioning mechanism, adjust this.\n  if test -x /usr/bin/objformat; then\n    objformat=`/usr/bin/objformat`\n  else\n    case $host_os in\n    freebsd[[123]]*) objformat=aout ;;\n    *) objformat=elf ;;\n    esac\n  fi\n  version_type=freebsd-$objformat\n  case $version_type in\n    freebsd-elf*)\n      library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext} $libname${shared_ext}'\n      need_version=no\n      need_lib_prefix=no\n      ;;\n    freebsd-*)\n      library_names_spec='${libname}${release}${shared_ext}$versuffix $libname${shared_ext}$versuffix'\n      need_version=yes\n      ;;\n  esac\n  shlibpath_var=LD_LIBRARY_PATH\n  case $host_os in\n  freebsd2*)\n    shlibpath_overrides_runpath=yes\n    ;;\n  freebsd3.[[01]]* | freebsdelf3.[[01]]*)\n    shlibpath_overrides_runpath=yes\n    hardcode_into_libs=yes\n    ;;\n  freebsd3.[[2-9]]* | freebsdelf3.[[2-9]]* | \\\n  freebsd4.[[0-5]] | freebsdelf4.[[0-5]] | freebsd4.1.1 | freebsdelf4.1.1)\n    shlibpath_overrides_runpath=no\n    hardcode_into_libs=yes\n    ;;\n  *) # from 4.6 on, and DragonFly\n    shlibpath_overrides_runpath=yes\n    hardcode_into_libs=yes\n    ;;\n  esac\n  ;;\n\ngnu*)\n  version_type=linux\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}${major} ${libname}${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  hardcode_into_libs=yes\n  ;;\n\nhpux9* | hpux10* | hpux11*)\n  # Give a soname corresponding to the major version so that dld.sl refuses to\n  # link against other versions.\n  version_type=sunos\n  need_lib_prefix=no\n  need_version=no\n  case $host_cpu in\n  ia64*)\n    shrext_cmds='.so'\n    hardcode_into_libs=yes\n    dynamic_linker=\"$host_os dld.so\"\n    shlibpath_var=LD_LIBRARY_PATH\n    shlibpath_overrides_runpath=yes # Unless +noenvvar is specified.\n    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n    soname_spec='${libname}${release}${shared_ext}$major'\n    if test \"X$HPUX_IA64_MODE\" = X32; then\n      sys_lib_search_path_spec=\"/usr/lib/hpux32 /usr/local/lib/hpux32 /usr/local/lib\"\n    else\n      sys_lib_search_path_spec=\"/usr/lib/hpux64 /usr/local/lib/hpux64\"\n    fi\n    sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec\n    ;;\n  hppa*64*)\n    shrext_cmds='.sl'\n    hardcode_into_libs=yes\n    dynamic_linker=\"$host_os dld.sl\"\n    shlibpath_var=LD_LIBRARY_PATH # How should we handle SHLIB_PATH\n    shlibpath_overrides_runpath=yes # Unless +noenvvar is specified.\n    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n    soname_spec='${libname}${release}${shared_ext}$major'\n    sys_lib_search_path_spec=\"/usr/lib/pa20_64 /usr/ccs/lib/pa20_64\"\n    sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec\n    ;;\n  *)\n    shrext_cmds='.sl'\n    dynamic_linker=\"$host_os dld.sl\"\n    shlibpath_var=SHLIB_PATH\n    shlibpath_overrides_runpath=no # +s is required to enable SHLIB_PATH\n    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n    soname_spec='${libname}${release}${shared_ext}$major'\n    ;;\n  esac\n  # HP-UX runs *really* slowly unless shared libraries are mode 555.\n  postinstall_cmds='chmod 555 $lib'\n  ;;\n\ninterix[[3-9]]*)\n  version_type=linux\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  dynamic_linker='Interix 3.x ld.so.1 (PE, like ELF)'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=no\n  hardcode_into_libs=yes\n  ;;\n\nirix5* | irix6* | nonstopux*)\n  case $host_os in\n    nonstopux*) version_type=nonstopux ;;\n    *)\n\tif test \"$lt_cv_prog_gnu_ld\" = yes; then\n\t\tversion_type=linux\n\telse\n\t\tversion_type=irix\n\tfi ;;\n  esac\n  need_lib_prefix=no\n  need_version=no\n  soname_spec='${libname}${release}${shared_ext}$major'\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${release}${shared_ext} $libname${shared_ext}'\n  case $host_os in\n  irix5* | nonstopux*)\n    libsuff= shlibsuff=\n    ;;\n  *)\n    case $LD in # libtool.m4 will add one of these switches to LD\n    *-32|*\"-32 \"|*-melf32bsmip|*\"-melf32bsmip \")\n      libsuff= shlibsuff= libmagic=32-bit;;\n    *-n32|*\"-n32 \"|*-melf32bmipn32|*\"-melf32bmipn32 \")\n      libsuff=32 shlibsuff=N32 libmagic=N32;;\n    *-64|*\"-64 \"|*-melf64bmip|*\"-melf64bmip \")\n      libsuff=64 shlibsuff=64 libmagic=64-bit;;\n    *) libsuff= shlibsuff= libmagic=never-match;;\n    esac\n    ;;\n  esac\n  shlibpath_var=LD_LIBRARY${shlibsuff}_PATH\n  shlibpath_overrides_runpath=no\n  sys_lib_search_path_spec=\"/usr/lib${libsuff} /lib${libsuff} /usr/local/lib${libsuff}\"\n  sys_lib_dlsearch_path_spec=\"/usr/lib${libsuff} /lib${libsuff}\"\n  hardcode_into_libs=yes\n  ;;\n\n# No shared lib support for Linux oldld, aout, or coff.\nlinux*oldld* | linux*aout* | linux*coff*)\n  dynamic_linker=no\n  ;;\n\n# This must be Linux ELF.\nlinux* | k*bsd*-gnu)\n  version_type=linux\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  finish_cmds='PATH=\"\\$PATH:/sbin\" ldconfig -n $libdir'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=no\n  # Some binutils ld are patched to set DT_RUNPATH\n  save_LDFLAGS=$LDFLAGS\n  save_libdir=$libdir\n  eval \"libdir=/foo; wl=\\\"$_LT_TAGVAR(lt_prog_compiler_wl, $1)\\\"; \\\n       LDFLAGS=\\\"\\$LDFLAGS $_LT_TAGVAR(hardcode_libdir_flag_spec, $1)\\\"\"\n  AC_LINK_IFELSE([AC_LANG_PROGRAM([],[])],\n    [AS_IF([ ($OBJDUMP -p conftest$ac_exeext) 2>/dev/null | grep \"RUNPATH.*$libdir\" >/dev/null],\n       [shlibpath_overrides_runpath=yes])])\n  LDFLAGS=$save_LDFLAGS\n  libdir=$save_libdir\n\n  # This implies no fast_install, which is unacceptable.\n  # Some rework will be needed to allow for fast_install\n  # before this can be enabled.\n  hardcode_into_libs=yes\n\n  # Append ld.so.conf contents to the search path\n  if test -f /etc/ld.so.conf; then\n    lt_ld_extra=`awk '/^include / { system(sprintf(\"cd /etc; cat %s 2>/dev/null\", \\[$]2)); skip = 1; } { if (!skip) print \\[$]0; skip = 0; }' < /etc/ld.so.conf | $SED -e 's/#.*//;/^[\t ]*hwcap[\t ]/d;s/[:,\t]/ /g;s/=[^=]*$//;s/=[^= ]* / /g;/^$/d' | tr '\\n' ' '`\n    sys_lib_dlsearch_path_spec=\"/lib /usr/lib $lt_ld_extra\"\n  fi\n\n  # We used to test for /lib/ld.so.1 and disable shared libraries on\n  # powerpc, because MkLinux only supported shared libraries with the\n  # GNU dynamic linker.  Since this was broken with cross compilers,\n  # most powerpc-linux boxes support dynamic linking these days and\n  # people can always --disable-shared, the test was removed, and we\n  # assume the GNU/Linux dynamic linker is in use.\n  dynamic_linker='GNU/Linux ld.so'\n  ;;\n\nnetbsd*)\n  version_type=sunos\n  need_lib_prefix=no\n  need_version=no\n  if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then\n    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'\n    finish_cmds='PATH=\"\\$PATH:/sbin\" ldconfig -m $libdir'\n    dynamic_linker='NetBSD (a.out) ld.so'\n  else\n    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'\n    soname_spec='${libname}${release}${shared_ext}$major'\n    dynamic_linker='NetBSD ld.elf_so'\n  fi\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=yes\n  hardcode_into_libs=yes\n  ;;\n\nnewsos6)\n  version_type=linux\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=yes\n  ;;\n\n*nto* | *qnx*)\n  version_type=qnx\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=no\n  hardcode_into_libs=yes\n  dynamic_linker='ldqnx.so'\n  ;;\n\nopenbsd*)\n  version_type=sunos\n  sys_lib_dlsearch_path_spec=\"/usr/lib\"\n  need_lib_prefix=no\n  # Some older versions of OpenBSD (3.3 at least) *do* need versioned libs.\n  case $host_os in\n    openbsd3.3 | openbsd3.3.*)\tneed_version=yes ;;\n    *)\t\t\t\tneed_version=no  ;;\n  esac\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'\n  finish_cmds='PATH=\"\\$PATH:/sbin\" ldconfig -m $libdir'\n  shlibpath_var=LD_LIBRARY_PATH\n  if test -z \"`echo __ELF__ | $CC -E - | $GREP __ELF__`\" || test \"$host_os-$host_cpu\" = \"openbsd2.8-powerpc\"; then\n    case $host_os in\n      openbsd2.[[89]] | openbsd2.[[89]].*)\n\tshlibpath_overrides_runpath=no\n\t;;\n      *)\n\tshlibpath_overrides_runpath=yes\n\t;;\n      esac\n  else\n    shlibpath_overrides_runpath=yes\n  fi\n  ;;\n\nos2*)\n  libname_spec='$name'\n  shrext_cmds=\".dll\"\n  need_lib_prefix=no\n  library_names_spec='$libname${shared_ext} $libname.a'\n  dynamic_linker='OS/2 ld.exe'\n  shlibpath_var=LIBPATH\n  ;;\n\nosf3* | osf4* | osf5*)\n  version_type=osf\n  need_lib_prefix=no\n  need_version=no\n  soname_spec='${libname}${release}${shared_ext}$major'\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  shlibpath_var=LD_LIBRARY_PATH\n  sys_lib_search_path_spec=\"/usr/shlib /usr/ccs/lib /usr/lib/cmplrs/cc /usr/lib /usr/local/lib /var/shlib\"\n  sys_lib_dlsearch_path_spec=\"$sys_lib_search_path_spec\"\n  ;;\n\nrdos*)\n  dynamic_linker=no\n  ;;\n\nsolaris*)\n  version_type=linux\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=yes\n  hardcode_into_libs=yes\n  # ldd complains unless libraries are executable\n  postinstall_cmds='chmod +x $lib'\n  ;;\n\nsunos4*)\n  version_type=sunos\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'\n  finish_cmds='PATH=\"\\$PATH:/usr/etc\" ldconfig $libdir'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=yes\n  if test \"$with_gnu_ld\" = yes; then\n    need_lib_prefix=no\n  fi\n  need_version=yes\n  ;;\n\nsysv4 | sysv4.3*)\n  version_type=linux\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  case $host_vendor in\n    sni)\n      shlibpath_overrides_runpath=no\n      need_lib_prefix=no\n      runpath_var=LD_RUN_PATH\n      ;;\n    siemens)\n      need_lib_prefix=no\n      ;;\n    motorola)\n      need_lib_prefix=no\n      need_version=no\n      shlibpath_overrides_runpath=no\n      sys_lib_search_path_spec='/lib /usr/lib /usr/ccs/lib'\n      ;;\n  esac\n  ;;\n\nsysv4*MP*)\n  if test -d /usr/nec ;then\n    version_type=linux\n    library_names_spec='$libname${shared_ext}.$versuffix $libname${shared_ext}.$major $libname${shared_ext}'\n    soname_spec='$libname${shared_ext}.$major'\n    shlibpath_var=LD_LIBRARY_PATH\n  fi\n  ;;\n\nsysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)\n  version_type=freebsd-elf\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext} $libname${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=yes\n  hardcode_into_libs=yes\n  if test \"$with_gnu_ld\" = yes; then\n    sys_lib_search_path_spec='/usr/local/lib /usr/gnu/lib /usr/ccs/lib /usr/lib /lib'\n  else\n    sys_lib_search_path_spec='/usr/ccs/lib /usr/lib'\n    case $host_os in\n      sco3.2v5*)\n        sys_lib_search_path_spec=\"$sys_lib_search_path_spec /lib\"\n\t;;\n    esac\n  fi\n  sys_lib_dlsearch_path_spec='/usr/lib'\n  ;;\n\ntpf*)\n  # TPF is a cross-target only.  Preferred cross-host = GNU/Linux.\n  version_type=linux\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=no\n  hardcode_into_libs=yes\n  ;;\n\nuts4*)\n  version_type=linux\n  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'\n  soname_spec='${libname}${release}${shared_ext}$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  ;;\n\n*)\n  dynamic_linker=no\n  ;;\nesac\nAC_MSG_RESULT([$dynamic_linker])\ntest \"$dynamic_linker\" = no && can_build_shared=no\n\nvariables_saved_for_relink=\"PATH $shlibpath_var $runpath_var\"\nif test \"$GCC\" = yes; then\n  variables_saved_for_relink=\"$variables_saved_for_relink GCC_EXEC_PREFIX COMPILER_PATH LIBRARY_PATH\"\nfi\n\nif test \"${lt_cv_sys_lib_search_path_spec+set}\" = set; then\n  sys_lib_search_path_spec=\"$lt_cv_sys_lib_search_path_spec\"\nfi\nif test \"${lt_cv_sys_lib_dlsearch_path_spec+set}\" = set; then\n  sys_lib_dlsearch_path_spec=\"$lt_cv_sys_lib_dlsearch_path_spec\"\nfi\n\n_LT_DECL([], [variables_saved_for_relink], [1],\n    [Variables whose values should be saved in libtool wrapper scripts and\n    restored at link time])\n_LT_DECL([], [need_lib_prefix], [0],\n    [Do we need the \"lib\" prefix for modules?])\n_LT_DECL([], [need_version], [0], [Do we need a version for libraries?])\n_LT_DECL([], [version_type], [0], [Library versioning type])\n_LT_DECL([], [runpath_var], [0],  [Shared library runtime path variable])\n_LT_DECL([], [shlibpath_var], [0],[Shared library path variable])\n_LT_DECL([], [shlibpath_overrides_runpath], [0],\n    [Is shlibpath searched before the hard-coded library search path?])\n_LT_DECL([], [libname_spec], [1], [Format of library name prefix])\n_LT_DECL([], [library_names_spec], [1],\n    [[List of archive names.  First name is the real one, the rest are links.\n    The last name is the one that the linker finds with -lNAME]])\n_LT_DECL([], [soname_spec], [1],\n    [[The coded name of the library, if different from the real name]])\n_LT_DECL([], [postinstall_cmds], [2],\n    [Command to use after installation of a shared archive])\n_LT_DECL([], [postuninstall_cmds], [2],\n    [Command to use after uninstallation of a shared archive])\n_LT_DECL([], [finish_cmds], [2],\n    [Commands used to finish a libtool library installation in a directory])\n_LT_DECL([], [finish_eval], [1],\n    [[As \"finish_cmds\", except a single script fragment to be evaled but\n    not shown]])\n_LT_DECL([], [hardcode_into_libs], [0],\n    [Whether we should hardcode library paths into libraries])\n_LT_DECL([], [sys_lib_search_path_spec], [2],\n    [Compile-time system search path for libraries])\n_LT_DECL([], [sys_lib_dlsearch_path_spec], [2],\n    [Run-time system search path for libraries])\n])# _LT_SYS_DYNAMIC_LINKER\n\n\n# _LT_PATH_TOOL_PREFIX(TOOL)\n# --------------------------\n# find a file program which can recognize shared library\nAC_DEFUN([_LT_PATH_TOOL_PREFIX],\n[m4_require([_LT_DECL_EGREP])dnl\nAC_MSG_CHECKING([for $1])\nAC_CACHE_VAL(lt_cv_path_MAGIC_CMD,\n[case $MAGIC_CMD in\n[[\\\\/*] |  ?:[\\\\/]*])\n  lt_cv_path_MAGIC_CMD=\"$MAGIC_CMD\" # Let the user override the test with a path.\n  ;;\n*)\n  lt_save_MAGIC_CMD=\"$MAGIC_CMD\"\n  lt_save_ifs=\"$IFS\"; IFS=$PATH_SEPARATOR\ndnl $ac_dummy forces splitting on constant user-supplied paths.\ndnl POSIX.2 word splitting is done only on the output of word expansions,\ndnl not every word.  This closes a longstanding sh security hole.\n  ac_dummy=\"m4_if([$2], , $PATH, [$2])\"\n  for ac_dir in $ac_dummy; do\n    IFS=\"$lt_save_ifs\"\n    test -z \"$ac_dir\" && ac_dir=.\n    if test -f $ac_dir/$1; then\n      lt_cv_path_MAGIC_CMD=\"$ac_dir/$1\"\n      if test -n \"$file_magic_test_file\"; then\n\tcase $deplibs_check_method in\n\t\"file_magic \"*)\n\t  file_magic_regex=`expr \"$deplibs_check_method\" : \"file_magic \\(.*\\)\"`\n\t  MAGIC_CMD=\"$lt_cv_path_MAGIC_CMD\"\n\t  if eval $file_magic_cmd \\$file_magic_test_file 2> /dev/null |\n\t    $EGREP \"$file_magic_regex\" > /dev/null; then\n\t    :\n\t  else\n\t    cat <<_LT_EOF 1>&2\n\n*** Warning: the command libtool uses to detect shared libraries,\n*** $file_magic_cmd, produces output that libtool cannot recognize.\n*** The result is that libtool may fail to recognize shared libraries\n*** as such.  This will affect the creation of libtool libraries that\n*** depend on shared libraries, but programs linked with such libtool\n*** libraries will work regardless of this problem.  Nevertheless, you\n*** may want to report the problem to your system manager and/or to\n*** bug-libtool@gnu.org\n\n_LT_EOF\n\t  fi ;;\n\tesac\n      fi\n      break\n    fi\n  done\n  IFS=\"$lt_save_ifs\"\n  MAGIC_CMD=\"$lt_save_MAGIC_CMD\"\n  ;;\nesac])\nMAGIC_CMD=\"$lt_cv_path_MAGIC_CMD\"\nif test -n \"$MAGIC_CMD\"; then\n  AC_MSG_RESULT($MAGIC_CMD)\nelse\n  AC_MSG_RESULT(no)\nfi\n_LT_DECL([], [MAGIC_CMD], [0],\n\t [Used to examine libraries when file_magic_cmd begins with \"file\"])dnl\n])# _LT_PATH_TOOL_PREFIX\n\n# Old name:\nAU_ALIAS([AC_PATH_TOOL_PREFIX], [_LT_PATH_TOOL_PREFIX])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_PATH_TOOL_PREFIX], [])\n\n\n# _LT_PATH_MAGIC\n# --------------\n# find a file program which can recognize a shared library\nm4_defun([_LT_PATH_MAGIC],\n[_LT_PATH_TOOL_PREFIX(${ac_tool_prefix}file, /usr/bin$PATH_SEPARATOR$PATH)\nif test -z \"$lt_cv_path_MAGIC_CMD\"; then\n  if test -n \"$ac_tool_prefix\"; then\n    _LT_PATH_TOOL_PREFIX(file, /usr/bin$PATH_SEPARATOR$PATH)\n  else\n    MAGIC_CMD=:\n  fi\nfi\n])# _LT_PATH_MAGIC\n\n\n# LT_PATH_LD\n# ----------\n# find the pathname to the GNU or non-GNU linker\nAC_DEFUN([LT_PATH_LD],\n[AC_REQUIRE([AC_PROG_CC])dnl\nAC_REQUIRE([AC_CANONICAL_HOST])dnl\nAC_REQUIRE([AC_CANONICAL_BUILD])dnl\nm4_require([_LT_DECL_SED])dnl\nm4_require([_LT_DECL_EGREP])dnl\n\nAC_ARG_WITH([gnu-ld],\n    [AS_HELP_STRING([--with-gnu-ld],\n\t[assume the C compiler uses GNU ld @<:@default=no@:>@])],\n    [test \"$withval\" = no || with_gnu_ld=yes],\n    [with_gnu_ld=no])dnl\n\nac_prog=ld\nif test \"$GCC\" = yes; then\n  # Check if gcc -print-prog-name=ld gives a path.\n  AC_MSG_CHECKING([for ld used by $CC])\n  case $host in\n  *-*-mingw*)\n    # gcc leaves a trailing carriage return which upsets mingw\n    ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\\015'` ;;\n  *)\n    ac_prog=`($CC -print-prog-name=ld) 2>&5` ;;\n  esac\n  case $ac_prog in\n    # Accept absolute paths.\n    [[\\\\/]]* | ?:[[\\\\/]]*)\n      re_direlt='/[[^/]][[^/]]*/\\.\\./'\n      # Canonicalize the pathname of ld\n      ac_prog=`$ECHO \"$ac_prog\"| $SED 's%\\\\\\\\%/%g'`\n      while $ECHO \"$ac_prog\" | $GREP \"$re_direlt\" > /dev/null 2>&1; do\n\tac_prog=`$ECHO $ac_prog| $SED \"s%$re_direlt%/%\"`\n      done\n      test -z \"$LD\" && LD=\"$ac_prog\"\n      ;;\n  \"\")\n    # If it fails, then pretend we aren't using GCC.\n    ac_prog=ld\n    ;;\n  *)\n    # If it is relative, then search for the first ld in PATH.\n    with_gnu_ld=unknown\n    ;;\n  esac\nelif test \"$with_gnu_ld\" = yes; then\n  AC_MSG_CHECKING([for GNU ld])\nelse\n  AC_MSG_CHECKING([for non-GNU ld])\nfi\nAC_CACHE_VAL(lt_cv_path_LD,\n[if test -z \"$LD\"; then\n  lt_save_ifs=\"$IFS\"; IFS=$PATH_SEPARATOR\n  for ac_dir in $PATH; do\n    IFS=\"$lt_save_ifs\"\n    test -z \"$ac_dir\" && ac_dir=.\n    if test -f \"$ac_dir/$ac_prog\" || test -f \"$ac_dir/$ac_prog$ac_exeext\"; then\n      lt_cv_path_LD=\"$ac_dir/$ac_prog\"\n      # Check to see if the program is GNU ld.  I'd rather use --version,\n      # but apparently some variants of GNU ld only accept -v.\n      # Break only if it was the GNU/non-GNU ld that we prefer.\n      case `\"$lt_cv_path_LD\" -v 2>&1 </dev/null` in\n      *GNU* | *'with BFD'*)\n\ttest \"$with_gnu_ld\" != no && break\n\t;;\n      *)\n\ttest \"$with_gnu_ld\" != yes && break\n\t;;\n      esac\n    fi\n  done\n  IFS=\"$lt_save_ifs\"\nelse\n  lt_cv_path_LD=\"$LD\" # Let the user override the test with a path.\nfi])\nLD=\"$lt_cv_path_LD\"\nif test -n \"$LD\"; then\n  AC_MSG_RESULT($LD)\nelse\n  AC_MSG_RESULT(no)\nfi\ntest -z \"$LD\" && AC_MSG_ERROR([no acceptable ld found in \\$PATH])\n_LT_PATH_LD_GNU\nAC_SUBST([LD])\n\n_LT_TAGDECL([], [LD], [1], [The linker used to build libraries])\n])# LT_PATH_LD\n\n# Old names:\nAU_ALIAS([AM_PROG_LD], [LT_PATH_LD])\nAU_ALIAS([AC_PROG_LD], [LT_PATH_LD])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AM_PROG_LD], [])\ndnl AC_DEFUN([AC_PROG_LD], [])\n\n\n# _LT_PATH_LD_GNU\n#- --------------\nm4_defun([_LT_PATH_LD_GNU],\n[AC_CACHE_CHECK([if the linker ($LD) is GNU ld], lt_cv_prog_gnu_ld,\n[# I'd rather use --version here, but apparently some GNU lds only accept -v.\ncase `$LD -v 2>&1 </dev/null` in\n*GNU* | *'with BFD'*)\n  lt_cv_prog_gnu_ld=yes\n  ;;\n*)\n  lt_cv_prog_gnu_ld=no\n  ;;\nesac])\nwith_gnu_ld=$lt_cv_prog_gnu_ld\n])# _LT_PATH_LD_GNU\n\n\n# _LT_CMD_RELOAD\n# --------------\n# find reload flag for linker\n#   -- PORTME Some linkers may need a different reload flag.\nm4_defun([_LT_CMD_RELOAD],\n[AC_CACHE_CHECK([for $LD option to reload object files],\n  lt_cv_ld_reload_flag,\n  [lt_cv_ld_reload_flag='-r'])\nreload_flag=$lt_cv_ld_reload_flag\ncase $reload_flag in\n\"\" | \" \"*) ;;\n*) reload_flag=\" $reload_flag\" ;;\nesac\nreload_cmds='$LD$reload_flag -o $output$reload_objs'\ncase $host_os in\n  darwin*)\n    if test \"$GCC\" = yes; then\n      reload_cmds='$LTCC $LTCFLAGS -nostdlib ${wl}-r -o $output$reload_objs'\n    else\n      reload_cmds='$LD$reload_flag -o $output$reload_objs'\n    fi\n    ;;\nesac\n_LT_DECL([], [reload_flag], [1], [How to create reloadable object files])dnl\n_LT_DECL([], [reload_cmds], [2])dnl\n])# _LT_CMD_RELOAD\n\n\n# _LT_CHECK_MAGIC_METHOD\n# ----------------------\n# how to check for library dependencies\n#  -- PORTME fill in with the dynamic library characteristics\nm4_defun([_LT_CHECK_MAGIC_METHOD],\n[m4_require([_LT_DECL_EGREP])\nm4_require([_LT_DECL_OBJDUMP])\nAC_CACHE_CHECK([how to recognize dependent libraries],\nlt_cv_deplibs_check_method,\n[lt_cv_file_magic_cmd='$MAGIC_CMD'\nlt_cv_file_magic_test_file=\nlt_cv_deplibs_check_method='unknown'\n# Need to set the preceding variable on all platforms that support\n# interlibrary dependencies.\n# 'none' -- dependencies not supported.\n# `unknown' -- same as none, but documents that we really don't know.\n# 'pass_all' -- all dependencies passed with no checks.\n# 'test_compile' -- check by making test program.\n# 'file_magic [[regex]]' -- check by looking for files in library path\n# which responds to the $file_magic_cmd with a given extended regex.\n# If you have `file' or equivalent on your system and you're not sure\n# whether `pass_all' will *always* work, you probably want this one.\n\ncase $host_os in\naix[[4-9]]*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nbeos*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nbsdi[[45]]*)\n  lt_cv_deplibs_check_method='file_magic ELF [[0-9]][[0-9]]*-bit [[ML]]SB (shared object|dynamic lib)'\n  lt_cv_file_magic_cmd='/usr/bin/file -L'\n  lt_cv_file_magic_test_file=/shlib/libc.so\n  ;;\n\ncygwin*)\n  # func_win32_libid is a shell function defined in ltmain.sh\n  lt_cv_deplibs_check_method='file_magic ^x86 archive import|^x86 DLL'\n  lt_cv_file_magic_cmd='func_win32_libid'\n  ;;\n\nmingw* | pw32*)\n  # Base MSYS/MinGW do not provide the 'file' command needed by\n  # func_win32_libid shell function, so use a weaker test based on 'objdump',\n  # unless we find 'file', for example because we are cross-compiling.\n  if ( file / ) >/dev/null 2>&1; then\n    lt_cv_deplibs_check_method='file_magic ^x86 archive import|^x86 DLL'\n    lt_cv_file_magic_cmd='func_win32_libid'\n  else\n    lt_cv_deplibs_check_method='file_magic file format pei*-i386(.*architecture: i386)?'\n    lt_cv_file_magic_cmd='$OBJDUMP -f'\n  fi\n  ;;\n\ncegcc)\n  # use the weaker test based on 'objdump'. See mingw*.\n  lt_cv_deplibs_check_method='file_magic file format pe-arm-.*little(.*architecture: arm)?'\n  lt_cv_file_magic_cmd='$OBJDUMP -f'\n  ;;\n\ndarwin* | rhapsody*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nfreebsd* | dragonfly*)\n  if echo __ELF__ | $CC -E - | $GREP __ELF__ > /dev/null; then\n    case $host_cpu in\n    i*86 )\n      # Not sure whether the presence of OpenBSD here was a mistake.\n      # Let's accept both of them until this is cleared up.\n      lt_cv_deplibs_check_method='file_magic (FreeBSD|OpenBSD|DragonFly)/i[[3-9]]86 (compact )?demand paged shared library'\n      lt_cv_file_magic_cmd=/usr/bin/file\n      lt_cv_file_magic_test_file=`echo /usr/lib/libc.so.*`\n      ;;\n    esac\n  else\n    lt_cv_deplibs_check_method=pass_all\n  fi\n  ;;\n\ngnu*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nhpux10.20* | hpux11*)\n  lt_cv_file_magic_cmd=/usr/bin/file\n  case $host_cpu in\n  ia64*)\n    lt_cv_deplibs_check_method='file_magic (s[[0-9]][[0-9]][[0-9]]|ELF-[[0-9]][[0-9]]) shared object file - IA64'\n    lt_cv_file_magic_test_file=/usr/lib/hpux32/libc.so\n    ;;\n  hppa*64*)\n    [lt_cv_deplibs_check_method='file_magic (s[0-9][0-9][0-9]|ELF-[0-9][0-9]) shared object file - PA-RISC [0-9].[0-9]']\n    lt_cv_file_magic_test_file=/usr/lib/pa20_64/libc.sl\n    ;;\n  *)\n    lt_cv_deplibs_check_method='file_magic (s[[0-9]][[0-9]][[0-9]]|PA-RISC[[0-9]].[[0-9]]) shared library'\n    lt_cv_file_magic_test_file=/usr/lib/libc.sl\n    ;;\n  esac\n  ;;\n\ninterix[[3-9]]*)\n  # PIC code is broken on Interix 3.x, that's why |\\.a not |_pic\\.a here\n  lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\\.so|\\.a)$'\n  ;;\n\nirix5* | irix6* | nonstopux*)\n  case $LD in\n  *-32|*\"-32 \") libmagic=32-bit;;\n  *-n32|*\"-n32 \") libmagic=N32;;\n  *-64|*\"-64 \") libmagic=64-bit;;\n  *) libmagic=never-match;;\n  esac\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\n# This must be Linux ELF.\nlinux* | k*bsd*-gnu)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nnetbsd*)\n  if echo __ELF__ | $CC -E - | $GREP __ELF__ > /dev/null; then\n    lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\\.so\\.[[0-9]]+\\.[[0-9]]+|_pic\\.a)$'\n  else\n    lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\\.so|_pic\\.a)$'\n  fi\n  ;;\n\nnewos6*)\n  lt_cv_deplibs_check_method='file_magic ELF [[0-9]][[0-9]]*-bit [[ML]]SB (executable|dynamic lib)'\n  lt_cv_file_magic_cmd=/usr/bin/file\n  lt_cv_file_magic_test_file=/usr/lib/libnls.so\n  ;;\n\n*nto* | *qnx*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nopenbsd*)\n  if test -z \"`echo __ELF__ | $CC -E - | $GREP __ELF__`\" || test \"$host_os-$host_cpu\" = \"openbsd2.8-powerpc\"; then\n    lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\\.so\\.[[0-9]]+\\.[[0-9]]+|\\.so|_pic\\.a)$'\n  else\n    lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\\.so\\.[[0-9]]+\\.[[0-9]]+|_pic\\.a)$'\n  fi\n  ;;\n\nosf3* | osf4* | osf5*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nrdos*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nsolaris*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nsysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nsysv4 | sysv4.3*)\n  case $host_vendor in\n  motorola)\n    lt_cv_deplibs_check_method='file_magic ELF [[0-9]][[0-9]]*-bit [[ML]]SB (shared object|dynamic lib) M[[0-9]][[0-9]]* Version [[0-9]]'\n    lt_cv_file_magic_test_file=`echo /usr/lib/libc.so*`\n    ;;\n  ncr)\n    lt_cv_deplibs_check_method=pass_all\n    ;;\n  sequent)\n    lt_cv_file_magic_cmd='/bin/file'\n    lt_cv_deplibs_check_method='file_magic ELF [[0-9]][[0-9]]*-bit [[LM]]SB (shared object|dynamic lib )'\n    ;;\n  sni)\n    lt_cv_file_magic_cmd='/bin/file'\n    lt_cv_deplibs_check_method=\"file_magic ELF [[0-9]][[0-9]]*-bit [[LM]]SB dynamic lib\"\n    lt_cv_file_magic_test_file=/lib/libc.so\n    ;;\n  siemens)\n    lt_cv_deplibs_check_method=pass_all\n    ;;\n  pc)\n    lt_cv_deplibs_check_method=pass_all\n    ;;\n  esac\n  ;;\n\ntpf*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\nesac\n])\nfile_magic_cmd=$lt_cv_file_magic_cmd\ndeplibs_check_method=$lt_cv_deplibs_check_method\ntest -z \"$deplibs_check_method\" && deplibs_check_method=unknown\n\n_LT_DECL([], [deplibs_check_method], [1],\n    [Method to check whether dependent libraries are shared objects])\n_LT_DECL([], [file_magic_cmd], [1],\n    [Command to use when deplibs_check_method == \"file_magic\"])\n])# _LT_CHECK_MAGIC_METHOD\n\n\n# LT_PATH_NM\n# ----------\n# find the pathname to a BSD- or MS-compatible name lister\nAC_DEFUN([LT_PATH_NM],\n[AC_REQUIRE([AC_PROG_CC])dnl\nAC_CACHE_CHECK([for BSD- or MS-compatible name lister (nm)], lt_cv_path_NM,\n[if test -n \"$NM\"; then\n  # Let the user override the test.\n  lt_cv_path_NM=\"$NM\"\nelse\n  lt_nm_to_check=\"${ac_tool_prefix}nm\"\n  if test -n \"$ac_tool_prefix\" && test \"$build\" = \"$host\"; then\n    lt_nm_to_check=\"$lt_nm_to_check nm\"\n  fi\n  for lt_tmp_nm in $lt_nm_to_check; do\n    lt_save_ifs=\"$IFS\"; IFS=$PATH_SEPARATOR\n    for ac_dir in $PATH /usr/ccs/bin/elf /usr/ccs/bin /usr/ucb /bin; do\n      IFS=\"$lt_save_ifs\"\n      test -z \"$ac_dir\" && ac_dir=.\n      tmp_nm=\"$ac_dir/$lt_tmp_nm\"\n      if test -f \"$tmp_nm\" || test -f \"$tmp_nm$ac_exeext\" ; then\n\t# Check to see if the nm accepts a BSD-compat flag.\n\t# Adding the `sed 1q' prevents false positives on HP-UX, which says:\n\t#   nm: unknown option \"B\" ignored\n\t# Tru64's nm complains that /dev/null is an invalid object file\n\tcase `\"$tmp_nm\" -B /dev/null 2>&1 | sed '1q'` in\n\t*/dev/null* | *'Invalid file or object type'*)\n\t  lt_cv_path_NM=\"$tmp_nm -B\"\n\t  break\n\t  ;;\n\t*)\n\t  case `\"$tmp_nm\" -p /dev/null 2>&1 | sed '1q'` in\n\t  */dev/null*)\n\t    lt_cv_path_NM=\"$tmp_nm -p\"\n\t    break\n\t    ;;\n\t  *)\n\t    lt_cv_path_NM=${lt_cv_path_NM=\"$tmp_nm\"} # keep the first match, but\n\t    continue # so that we can try to find one that supports BSD flags\n\t    ;;\n\t  esac\n\t  ;;\n\tesac\n      fi\n    done\n    IFS=\"$lt_save_ifs\"\n  done\n  : ${lt_cv_path_NM=no}\nfi])\nif test \"$lt_cv_path_NM\" != \"no\"; then\n  NM=\"$lt_cv_path_NM\"\nelse\n  # Didn't find any BSD compatible name lister, look for dumpbin.\n  AC_CHECK_TOOLS(DUMPBIN, [\"dumpbin -symbols\" \"link -dump -symbols\"], :)\n  AC_SUBST([DUMPBIN])\n  if test \"$DUMPBIN\" != \":\"; then\n    NM=\"$DUMPBIN\"\n  fi\nfi\ntest -z \"$NM\" && NM=nm\nAC_SUBST([NM])\n_LT_DECL([], [NM], [1], [A BSD- or MS-compatible name lister])dnl\n\nAC_CACHE_CHECK([the name lister ($NM) interface], [lt_cv_nm_interface],\n  [lt_cv_nm_interface=\"BSD nm\"\n  echo \"int some_variable = 0;\" > conftest.$ac_ext\n  (eval echo \"\\\"\\$as_me:__oline__: $ac_compile\\\"\" >&AS_MESSAGE_LOG_FD)\n  (eval \"$ac_compile\" 2>conftest.err)\n  cat conftest.err >&AS_MESSAGE_LOG_FD\n  (eval echo \"\\\"\\$as_me:__oline__: $NM \\\\\\\"conftest.$ac_objext\\\\\\\"\\\"\" >&AS_MESSAGE_LOG_FD)\n  (eval \"$NM \\\"conftest.$ac_objext\\\"\" 2>conftest.err > conftest.out)\n  cat conftest.err >&AS_MESSAGE_LOG_FD\n  (eval echo \"\\\"\\$as_me:__oline__: output\\\"\" >&AS_MESSAGE_LOG_FD)\n  cat conftest.out >&AS_MESSAGE_LOG_FD\n  if $GREP 'External.*some_variable' conftest.out > /dev/null; then\n    lt_cv_nm_interface=\"MS dumpbin\"\n  fi\n  rm -f conftest*])\n])# LT_PATH_NM\n\n# Old names:\nAU_ALIAS([AM_PROG_NM], [LT_PATH_NM])\nAU_ALIAS([AC_PROG_NM], [LT_PATH_NM])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AM_PROG_NM], [])\ndnl AC_DEFUN([AC_PROG_NM], [])\n\n\n# LT_LIB_M\n# --------\n# check for math library\nAC_DEFUN([LT_LIB_M],\n[AC_REQUIRE([AC_CANONICAL_HOST])dnl\nLIBM=\ncase $host in\n*-*-beos* | *-*-cygwin* | *-*-pw32* | *-*-darwin*)\n  # These system don't have libm, or don't need it\n  ;;\n*-ncr-sysv4.3*)\n  AC_CHECK_LIB(mw, _mwvalidcheckl, LIBM=\"-lmw\")\n  AC_CHECK_LIB(m, cos, LIBM=\"$LIBM -lm\")\n  ;;\n*)\n  AC_CHECK_LIB(m, cos, LIBM=\"-lm\")\n  ;;\nesac\nAC_SUBST([LIBM])\n])# LT_LIB_M\n\n# Old name:\nAU_ALIAS([AC_CHECK_LIBM], [LT_LIB_M])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_CHECK_LIBM], [])\n\n\n# _LT_COMPILER_NO_RTTI([TAGNAME])\n# -------------------------------\nm4_defun([_LT_COMPILER_NO_RTTI],\n[m4_require([_LT_TAG_COMPILER])dnl\n\n_LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=\n\nif test \"$GCC\" = yes; then\n  _LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=' -fno-builtin'\n\n  _LT_COMPILER_OPTION([if $compiler supports -fno-rtti -fno-exceptions],\n    lt_cv_prog_compiler_rtti_exceptions,\n    [-fno-rtti -fno-exceptions], [],\n    [_LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=\"$_LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1) -fno-rtti -fno-exceptions\"])\nfi\n_LT_TAGDECL([no_builtin_flag], [lt_prog_compiler_no_builtin_flag], [1],\n\t[Compiler flag to turn off builtin functions])\n])# _LT_COMPILER_NO_RTTI\n\n\n# _LT_CMD_GLOBAL_SYMBOLS\n# ----------------------\nm4_defun([_LT_CMD_GLOBAL_SYMBOLS],\n[AC_REQUIRE([AC_CANONICAL_HOST])dnl\nAC_REQUIRE([AC_PROG_CC])dnl\nAC_REQUIRE([LT_PATH_NM])dnl\nAC_REQUIRE([LT_PATH_LD])dnl\nm4_require([_LT_DECL_SED])dnl\nm4_require([_LT_DECL_EGREP])dnl\nm4_require([_LT_TAG_COMPILER])dnl\n\n# Check for command to grab the raw symbol name followed by C symbol from nm.\nAC_MSG_CHECKING([command to parse $NM output from $compiler object])\nAC_CACHE_VAL([lt_cv_sys_global_symbol_pipe],\n[\n# These are sane defaults that work on at least a few old systems.\n# [They come from Ultrix.  What could be older than Ultrix?!! ;)]\n\n# Character class describing NM global symbol codes.\nsymcode='[[BCDEGRST]]'\n\n# Regexp to match symbols that can be accessed directly from C.\nsympat='\\([[_A-Za-z]][[_A-Za-z0-9]]*\\)'\n\n# Define system-specific variables.\ncase $host_os in\naix*)\n  symcode='[[BCDT]]'\n  ;;\ncygwin* | mingw* | pw32* | cegcc*)\n  symcode='[[ABCDGISTW]]'\n  ;;\nhpux*)\n  if test \"$host_cpu\" = ia64; then\n    symcode='[[ABCDEGRST]]'\n  fi\n  ;;\nirix* | nonstopux*)\n  symcode='[[BCDEGRST]]'\n  ;;\nosf*)\n  symcode='[[BCDEGQRST]]'\n  ;;\nsolaris*)\n  symcode='[[BDRT]]'\n  ;;\nsco3.2v5*)\n  symcode='[[DT]]'\n  ;;\nsysv4.2uw2*)\n  symcode='[[DT]]'\n  ;;\nsysv5* | sco5v6* | unixware* | OpenUNIX*)\n  symcode='[[ABDT]]'\n  ;;\nsysv4)\n  symcode='[[DFNSTU]]'\n  ;;\nesac\n\n# If we're using GNU nm, then use its standard symbol codes.\ncase `$NM -V 2>&1` in\n*GNU* | *'with BFD'*)\n  symcode='[[ABCDGIRSTW]]' ;;\nesac\n\n# Transform an extracted symbol line into a proper C declaration.\n# Some systems (esp. on ia64) link data and code symbols differently,\n# so use this general approach.\nlt_cv_sys_global_symbol_to_cdecl=\"sed -n -e 's/^T .* \\(.*\\)$/extern int \\1();/p' -e 's/^$symcode* .* \\(.*\\)$/extern char \\1;/p'\"\n\n# Transform an extracted symbol line into symbol name and symbol address\nlt_cv_sys_global_symbol_to_c_name_address=\"sed -n -e 's/^: \\([[^ ]]*\\) $/  {\\\\\\\"\\1\\\\\\\", (void *) 0},/p' -e 's/^$symcode* \\([[^ ]]*\\) \\([[^ ]]*\\)$/  {\\\"\\2\\\", (void *) \\&\\2},/p'\"\nlt_cv_sys_global_symbol_to_c_name_address_lib_prefix=\"sed -n -e 's/^: \\([[^ ]]*\\) $/  {\\\\\\\"\\1\\\\\\\", (void *) 0},/p' -e 's/^$symcode* \\([[^ ]]*\\) \\(lib[[^ ]]*\\)$/  {\\\"\\2\\\", (void *) \\&\\2},/p' -e 's/^$symcode* \\([[^ ]]*\\) \\([[^ ]]*\\)$/  {\\\"lib\\2\\\", (void *) \\&\\2},/p'\"\n\n# Handle CRLF in mingw tool chain\nopt_cr=\ncase $build_os in\nmingw*)\n  opt_cr=`$ECHO 'x\\{0,1\\}' | tr x '\\015'` # option cr in regexp\n  ;;\nesac\n\n# Try without a prefix underscore, then with it.\nfor ac_symprfx in \"\" \"_\"; do\n\n  # Transform symcode, sympat, and symprfx into a raw symbol and a C symbol.\n  symxfrm=\"\\\\1 $ac_symprfx\\\\2 \\\\2\"\n\n  # Write the raw and C identifiers.\n  if test \"$lt_cv_nm_interface\" = \"MS dumpbin\"; then\n    # Fake it for dumpbin and say T for any non-static function\n    # and D for any global variable.\n    # Also find C++ and __fastcall symbols from MSVC++,\n    # which start with @ or ?.\n    lt_cv_sys_global_symbol_pipe=\"$AWK ['\"\\\n\"     {last_section=section; section=\\$ 3};\"\\\n\"     /Section length .*#relocs.*(pick any)/{hide[last_section]=1};\"\\\n\"     \\$ 0!~/External *\\|/{next};\"\\\n\"     / 0+ UNDEF /{next}; / UNDEF \\([^|]\\)*()/{next};\"\\\n\"     {if(hide[section]) next};\"\\\n\"     {f=0}; \\$ 0~/\\(\\).*\\|/{f=1}; {printf f ? \\\"T \\\" : \\\"D \\\"};\"\\\n\"     {split(\\$ 0, a, /\\||\\r/); split(a[2], s)};\"\\\n\"     s[1]~/^[@?]/{print s[1], s[1]; next};\"\\\n\"     s[1]~prfx {split(s[1],t,\\\"@\\\"); print t[1], substr(t[1],length(prfx))}\"\\\n\"     ' prfx=^$ac_symprfx]\"\n  else\n    lt_cv_sys_global_symbol_pipe=\"sed -n -e 's/^.*[[\t ]]\\($symcode$symcode*\\)[[\t ]][[\t ]]*$ac_symprfx$sympat$opt_cr$/$symxfrm/p'\"\n  fi\n\n  # Check to see that the pipe works correctly.\n  pipe_works=no\n\n  rm -f conftest*\n  cat > conftest.$ac_ext <<_LT_EOF\n#ifdef __cplusplus\nextern \"C\" {\n#endif\nchar nm_test_var;\nvoid nm_test_func(void);\nvoid nm_test_func(void){}\n#ifdef __cplusplus\n}\n#endif\nint main(){nm_test_var='a';nm_test_func();return(0);}\n_LT_EOF\n\n  if AC_TRY_EVAL(ac_compile); then\n    # Now try to grab the symbols.\n    nlist=conftest.nm\n    if AC_TRY_EVAL(NM conftest.$ac_objext \\| $lt_cv_sys_global_symbol_pipe \\> $nlist) && test -s \"$nlist\"; then\n      # Try sorting and uniquifying the output.\n      if sort \"$nlist\" | uniq > \"$nlist\"T; then\n\tmv -f \"$nlist\"T \"$nlist\"\n      else\n\trm -f \"$nlist\"T\n      fi\n\n      # Make sure that we snagged all the symbols we need.\n      if $GREP ' nm_test_var$' \"$nlist\" >/dev/null; then\n\tif $GREP ' nm_test_func$' \"$nlist\" >/dev/null; then\n\t  cat <<_LT_EOF > conftest.$ac_ext\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n_LT_EOF\n\t  # Now generate the symbol file.\n\t  eval \"$lt_cv_sys_global_symbol_to_cdecl\"' < \"$nlist\" | $GREP -v main >> conftest.$ac_ext'\n\n\t  cat <<_LT_EOF >> conftest.$ac_ext\n\n/* The mapping between symbol names and symbols.  */\nconst struct {\n  const char *name;\n  void       *address;\n}\nlt__PROGRAM__LTX_preloaded_symbols[[]] =\n{\n  { \"@PROGRAM@\", (void *) 0 },\n_LT_EOF\n\t  $SED \"s/^$symcode$symcode* \\(.*\\) \\(.*\\)$/  {\\\"\\2\\\", (void *) \\&\\2},/\" < \"$nlist\" | $GREP -v main >> conftest.$ac_ext\n\t  cat <<\\_LT_EOF >> conftest.$ac_ext\n  {0, (void *) 0}\n};\n\n/* This works around a problem in FreeBSD linker */\n#ifdef FREEBSD_WORKAROUND\nstatic const void *lt_preloaded_setup() {\n  return lt__PROGRAM__LTX_preloaded_symbols;\n}\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n_LT_EOF\n\t  # Now try linking the two files.\n\t  mv conftest.$ac_objext conftstm.$ac_objext\n\t  lt_save_LIBS=\"$LIBS\"\n\t  lt_save_CFLAGS=\"$CFLAGS\"\n\t  LIBS=\"conftstm.$ac_objext\"\n\t  CFLAGS=\"$CFLAGS$_LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)\"\n\t  if AC_TRY_EVAL(ac_link) && test -s conftest${ac_exeext}; then\n\t    pipe_works=yes\n\t  fi\n\t  LIBS=\"$lt_save_LIBS\"\n\t  CFLAGS=\"$lt_save_CFLAGS\"\n\telse\n\t  echo \"cannot find nm_test_func in $nlist\" >&AS_MESSAGE_LOG_FD\n\tfi\n      else\n\techo \"cannot find nm_test_var in $nlist\" >&AS_MESSAGE_LOG_FD\n      fi\n    else\n      echo \"cannot run $lt_cv_sys_global_symbol_pipe\" >&AS_MESSAGE_LOG_FD\n    fi\n  else\n    echo \"$progname: failed program was:\" >&AS_MESSAGE_LOG_FD\n    cat conftest.$ac_ext >&5\n  fi\n  rm -rf conftest* conftst*\n\n  # Do not use the global_symbol_pipe unless it works.\n  if test \"$pipe_works\" = yes; then\n    break\n  else\n    lt_cv_sys_global_symbol_pipe=\n  fi\ndone\n])\nif test -z \"$lt_cv_sys_global_symbol_pipe\"; then\n  lt_cv_sys_global_symbol_to_cdecl=\nfi\nif test -z \"$lt_cv_sys_global_symbol_pipe$lt_cv_sys_global_symbol_to_cdecl\"; then\n  AC_MSG_RESULT(failed)\nelse\n  AC_MSG_RESULT(ok)\nfi\n\n_LT_DECL([global_symbol_pipe], [lt_cv_sys_global_symbol_pipe], [1],\n    [Take the output of nm and produce a listing of raw symbols and C names])\n_LT_DECL([global_symbol_to_cdecl], [lt_cv_sys_global_symbol_to_cdecl], [1],\n    [Transform the output of nm in a proper C declaration])\n_LT_DECL([global_symbol_to_c_name_address],\n    [lt_cv_sys_global_symbol_to_c_name_address], [1],\n    [Transform the output of nm in a C name address pair])\n_LT_DECL([global_symbol_to_c_name_address_lib_prefix],\n    [lt_cv_sys_global_symbol_to_c_name_address_lib_prefix], [1],\n    [Transform the output of nm in a C name address pair when lib prefix is needed])\n]) # _LT_CMD_GLOBAL_SYMBOLS\n\n\n# _LT_COMPILER_PIC([TAGNAME])\n# ---------------------------\nm4_defun([_LT_COMPILER_PIC],\n[m4_require([_LT_TAG_COMPILER])dnl\n_LT_TAGVAR(lt_prog_compiler_wl, $1)=\n_LT_TAGVAR(lt_prog_compiler_pic, $1)=\n_LT_TAGVAR(lt_prog_compiler_static, $1)=\n\nAC_MSG_CHECKING([for $compiler option to produce PIC])\nm4_if([$1], [CXX], [\n  # C++ specific cases for pic, static, wl, etc.\n  if test \"$GXX\" = yes; then\n    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n    _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n\n    case $host_os in\n    aix*)\n      # All AIX code is PIC.\n      if test \"$host_cpu\" = ia64; then\n\t# AIX 5 now supports IA64 processor\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      fi\n      ;;\n\n    amigaos*)\n      case $host_cpu in\n      powerpc)\n            # see comment about AmigaOS4 .so support\n            _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n        ;;\n      m68k)\n            # FIXME: we need at least 68020 code to build shared libraries, but\n            # adding the `-m68020' flag to GCC prevents building anything better,\n            # like `-m68040'.\n            _LT_TAGVAR(lt_prog_compiler_pic, $1)='-m68020 -resident32 -malways-restore-a4'\n        ;;\n      esac\n      ;;\n\n    beos* | irix5* | irix6* | nonstopux* | osf3* | osf4* | osf5*)\n      # PIC is the default for these OSes.\n      ;;\n    mingw* | cygwin* | os2* | pw32* | cegcc*)\n      # This hack is so that the source file can tell whether it is being\n      # built for inclusion in a dll (and should export symbols for example).\n      # Although the cygwin gcc ignores -fPIC, still need this for old-style\n      # (--disable-auto-import) libraries\n      m4_if([$1], [GCJ], [],\n\t[_LT_TAGVAR(lt_prog_compiler_pic, $1)='-DDLL_EXPORT'])\n      ;;\n    darwin* | rhapsody*)\n      # PIC is the default on this platform\n      # Common symbols not allowed in MH_DYLIB files\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fno-common'\n      ;;\n    *djgpp*)\n      # DJGPP does not support shared libraries at all\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)=\n      ;;\n    interix[[3-9]]*)\n      # Interix 3.x gcc -fpic/-fPIC options generate broken code.\n      # Instead, we relocate shared libraries at runtime.\n      ;;\n    sysv4*MP*)\n      if test -d /usr/nec; then\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)=-Kconform_pic\n      fi\n      ;;\n    hpux*)\n      # PIC is the default for 64-bit PA HP-UX, but not for 32-bit\n      # PA HP-UX.  On IA64 HP-UX, PIC is the default but the pic flag\n      # sets the default TLS model and affects inlining.\n      case $host_cpu in\n      hppa*64*)\n\t;;\n      *)\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n\t;;\n      esac\n      ;;\n    *qnx* | *nto*)\n      # QNX uses GNU C++, but need to define -shared option too, otherwise\n      # it will coredump.\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC -shared'\n      ;;\n    *)\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n      ;;\n    esac\n  else\n    case $host_os in\n      aix[[4-9]]*)\n\t# All AIX code is PIC.\n\tif test \"$host_cpu\" = ia64; then\n\t  # AIX 5 now supports IA64 processor\n\t  _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\telse\n\t  _LT_TAGVAR(lt_prog_compiler_static, $1)='-bnso -bI:/lib/syscalls.exp'\n\tfi\n\t;;\n      chorus*)\n\tcase $cc_basename in\n\tcxch68*)\n\t  # Green Hills C++ Compiler\n\t  # _LT_TAGVAR(lt_prog_compiler_static, $1)=\"--no_auto_instantiation -u __main -u __premain -u _abort -r $COOL_DIR/lib/libOrb.a $MVME_DIR/lib/CC/libC.a $MVME_DIR/lib/classix/libcx.s.a\"\n\t  ;;\n\tesac\n\t;;\n      dgux*)\n\tcase $cc_basename in\n\t  ec++*)\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t    ;;\n\t  ghcx*)\n\t    # Green Hills C++ Compiler\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      freebsd* | dragonfly*)\n\t# FreeBSD uses GNU C++\n\t;;\n      hpux9* | hpux10* | hpux11*)\n\tcase $cc_basename in\n\t  CC*)\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='${wl}-a ${wl}archive'\n\t    if test \"$host_cpu\" != ia64; then\n\t      _LT_TAGVAR(lt_prog_compiler_pic, $1)='+Z'\n\t    fi\n\t    ;;\n\t  aCC*)\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='${wl}-a ${wl}archive'\n\t    case $host_cpu in\n\t    hppa*64*|ia64*)\n\t      # +Z the default\n\t      ;;\n\t    *)\n\t      _LT_TAGVAR(lt_prog_compiler_pic, $1)='+Z'\n\t      ;;\n\t    esac\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      interix*)\n\t# This is c89, which is MS Visual C++ (no shared libs)\n\t# Anyone wants to do a port?\n\t;;\n      irix5* | irix6* | nonstopux*)\n\tcase $cc_basename in\n\t  CC*)\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n\t    # CC pic flag -KPIC is the default.\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      linux* | k*bsd*-gnu)\n\tcase $cc_basename in\n\t  KCC*)\n\t    # KAI C++ Compiler\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='--backend -Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n\t    ;;\n\t  ecpc* )\n\t    # old Intel C++ for x86_64 which still supported -KPIC.\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n\t    ;;\n\t  icpc* )\n\t    # Intel C++, used to be incompatible with GCC.\n\t    # ICC 10 doesn't accept -KPIC any more.\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n\t    ;;\n\t  pgCC* | pgcpp*)\n\t    # Portland Group C++ compiler\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fpic'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t    ;;\n\t  cxx*)\n\t    # Compaq C++\n\t    # Make sure the PIC flag is empty.  It appears that all Alpha\n\t    # Linux and Compaq Tru64 Unix objects are PIC.\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)=\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n\t    ;;\n\t  xlc* | xlC*)\n\t    # IBM XL 8.0 on PPC\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-qpic'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-qstaticlink'\n\t    ;;\n\t  *)\n\t    case `$CC -V 2>&1 | sed 5q` in\n\t    *Sun\\ C*)\n\t      # Sun C++ 5.9\n\t      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld '\n\t      ;;\n\t    esac\n\t    ;;\n\tesac\n\t;;\n      lynxos*)\n\t;;\n      m88k*)\n\t;;\n      mvs*)\n\tcase $cc_basename in\n\t  cxx*)\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-W c,exportall'\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      netbsd*)\n\t;;\n      *qnx* | *nto*)\n        # QNX uses GNU C++, but need to define -shared option too, otherwise\n        # it will coredump.\n        _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC -shared'\n        ;;\n      osf3* | osf4* | osf5*)\n\tcase $cc_basename in\n\t  KCC*)\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='--backend -Wl,'\n\t    ;;\n\t  RCC*)\n\t    # Rational C++ 2.4.1\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'\n\t    ;;\n\t  cxx*)\n\t    # Digital/Compaq C++\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    # Make sure the PIC flag is empty.  It appears that all Alpha\n\t    # Linux and Compaq Tru64 Unix objects are PIC.\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)=\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      psos*)\n\t;;\n      solaris*)\n\tcase $cc_basename in\n\t  CC*)\n\t    # Sun C++ 4.2, 5.x and Centerline C++\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld '\n\t    ;;\n\t  gcx*)\n\t    # Green Hills C++ Compiler\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-PIC'\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      sunos4*)\n\tcase $cc_basename in\n\t  CC*)\n\t    # Sun C++ 4.x\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t    ;;\n\t  lcc*)\n\t    # Lucid\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      sysv5* | unixware* | sco3.2v5* | sco5v6* | OpenUNIX*)\n\tcase $cc_basename in\n\t  CC*)\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t    ;;\n\tesac\n\t;;\n      tandem*)\n\tcase $cc_basename in\n\t  NCC*)\n\t    # NonStop-UX NCC 3.20\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      vxworks*)\n\t;;\n      *)\n\t_LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no\n\t;;\n    esac\n  fi\n],\n[\n  if test \"$GCC\" = yes; then\n    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n    _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n\n    case $host_os in\n      aix*)\n      # All AIX code is PIC.\n      if test \"$host_cpu\" = ia64; then\n\t# AIX 5 now supports IA64 processor\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      fi\n      ;;\n\n    amigaos*)\n      case $host_cpu in\n      powerpc)\n            # see comment about AmigaOS4 .so support\n            _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n        ;;\n      m68k)\n            # FIXME: we need at least 68020 code to build shared libraries, but\n            # adding the `-m68020' flag to GCC prevents building anything better,\n            # like `-m68040'.\n            _LT_TAGVAR(lt_prog_compiler_pic, $1)='-m68020 -resident32 -malways-restore-a4'\n        ;;\n      esac\n      ;;\n\n    beos* | irix5* | irix6* | nonstopux* | osf3* | osf4* | osf5*)\n      # PIC is the default for these OSes.\n      ;;\n\n    mingw* | cygwin* | pw32* | os2* | cegcc*)\n      # This hack is so that the source file can tell whether it is being\n      # built for inclusion in a dll (and should export symbols for example).\n      # Although the cygwin gcc ignores -fPIC, still need this for old-style\n      # (--disable-auto-import) libraries\n      m4_if([$1], [GCJ], [],\n\t[_LT_TAGVAR(lt_prog_compiler_pic, $1)='-DDLL_EXPORT'])\n      ;;\n\n    darwin* | rhapsody*)\n      # PIC is the default on this platform\n      # Common symbols not allowed in MH_DYLIB files\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fno-common'\n      ;;\n\n    hpux*)\n      # PIC is the default for 64-bit PA HP-UX, but not for 32-bit\n      # PA HP-UX.  On IA64 HP-UX, PIC is the default but the pic flag\n      # sets the default TLS model and affects inlining.\n      case $host_cpu in\n      hppa*64*)\n\t# +Z the default\n\t;;\n      *)\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n\t;;\n      esac\n      ;;\n\n    interix[[3-9]]*)\n      # Interix 3.x gcc -fpic/-fPIC options generate broken code.\n      # Instead, we relocate shared libraries at runtime.\n      ;;\n\n    msdosdjgpp*)\n      # Just because we use GCC doesn't mean we suddenly get shared libraries\n      # on systems that don't support them.\n      _LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no\n      enable_shared=no\n      ;;\n\n    *nto* | *qnx*)\n      # QNX uses GNU C++, but need to define -shared option too, otherwise\n      # it will coredump.\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC -shared'\n      ;;\n\n    sysv4*MP*)\n      if test -d /usr/nec; then\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)=-Kconform_pic\n      fi\n      ;;\n\n    *)\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n      ;;\n    esac\n  else\n    # PORTME Check for flag to pass linker flags through the system compiler.\n    case $host_os in\n    aix*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      if test \"$host_cpu\" = ia64; then\n\t# AIX 5 now supports IA64 processor\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      else\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-bnso -bI:/lib/syscalls.exp'\n      fi\n      ;;\n\n    mingw* | cygwin* | pw32* | os2* | cegcc*)\n      # This hack is so that the source file can tell whether it is being\n      # built for inclusion in a dll (and should export symbols for example).\n      m4_if([$1], [GCJ], [],\n\t[_LT_TAGVAR(lt_prog_compiler_pic, $1)='-DDLL_EXPORT'])\n      ;;\n\n    hpux9* | hpux10* | hpux11*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      # PIC is the default for IA64 HP-UX and 64-bit HP-UX, but\n      # not for PA HP-UX.\n      case $host_cpu in\n      hppa*64*|ia64*)\n\t# +Z the default\n\t;;\n      *)\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='+Z'\n\t;;\n      esac\n      # Is there a better lt_prog_compiler_static that works with the bundled CC?\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='${wl}-a ${wl}archive'\n      ;;\n\n    irix5* | irix6* | nonstopux*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      # PIC (with -KPIC) is the default.\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n      ;;\n\n    linux* | k*bsd*-gnu)\n      case $cc_basename in\n      # old Intel for x86_64 which still supported -KPIC.\n      ecc*)\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n        ;;\n      # icc used to be incompatible with GCC.\n      # ICC 10 doesn't accept -KPIC any more.\n      icc* | ifort*)\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n        ;;\n      # Lahey Fortran 8.1.\n      lf95*)\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='--shared'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='--static'\n\t;;\n      pgcc* | pgf77* | pgf90* | pgf95*)\n        # Portland Group compilers (*not* the Pentium gcc compiler,\n\t# which looks to be a dead project)\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-fpic'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n        ;;\n      ccc*)\n        _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n        # All Alpha code is PIC.\n        _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n        ;;\n      xl*)\n\t# IBM XL C 8.0/Fortran 10.1 on PPC\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-qpic'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-qstaticlink'\n\t;;\n      *)\n\tcase `$CC -V 2>&1 | sed 5q` in\n\t*Sun\\ C*)\n\t  # Sun C 5.9\n\t  _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t  _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t  _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t  ;;\n\t*Sun\\ F*)\n\t  # Sun Fortran 8.3 passes all unrecognized flags to the linker\n\t  _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t  _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t  _LT_TAGVAR(lt_prog_compiler_wl, $1)=''\n\t  ;;\n\tesac\n\t;;\n      esac\n      ;;\n\n    newsos6)\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      ;;\n\n    *nto* | *qnx*)\n      # QNX uses GNU C++, but need to define -shared option too, otherwise\n      # it will coredump.\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC -shared'\n      ;;\n\n    osf3* | osf4* | osf5*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      # All OSF/1 code is PIC.\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n      ;;\n\n    rdos*)\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n      ;;\n\n    solaris*)\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      case $cc_basename in\n      f77* | f90* | f95*)\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld ';;\n      *)\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,';;\n      esac\n      ;;\n\n    sunos4*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld '\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-PIC'\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      ;;\n\n    sysv4 | sysv4.2uw2* | sysv4.3*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      ;;\n\n    sysv4*MP*)\n      if test -d /usr/nec ;then\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-Kconform_pic'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      fi\n      ;;\n\n    sysv5* | unixware* | sco3.2v5* | sco5v6* | OpenUNIX*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      ;;\n\n    unicos*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      _LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no\n      ;;\n\n    uts4*)\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      ;;\n\n    *)\n      _LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no\n      ;;\n    esac\n  fi\n])\ncase $host_os in\n  # For platforms which do not support PIC, -DPIC is meaningless:\n  *djgpp*)\n    _LT_TAGVAR(lt_prog_compiler_pic, $1)=\n    ;;\n  *)\n    _LT_TAGVAR(lt_prog_compiler_pic, $1)=\"$_LT_TAGVAR(lt_prog_compiler_pic, $1)@&t@m4_if([$1],[],[ -DPIC],[m4_if([$1],[CXX],[ -DPIC],[])])\"\n    ;;\nesac\nAC_MSG_RESULT([$_LT_TAGVAR(lt_prog_compiler_pic, $1)])\n_LT_TAGDECL([wl], [lt_prog_compiler_wl], [1],\n\t[How to pass a linker flag through the compiler])\n\n#\n# Check to make sure the PIC flag actually works.\n#\nif test -n \"$_LT_TAGVAR(lt_prog_compiler_pic, $1)\"; then\n  _LT_COMPILER_OPTION([if $compiler PIC flag $_LT_TAGVAR(lt_prog_compiler_pic, $1) works],\n    [_LT_TAGVAR(lt_cv_prog_compiler_pic_works, $1)],\n    [$_LT_TAGVAR(lt_prog_compiler_pic, $1)@&t@m4_if([$1],[],[ -DPIC],[m4_if([$1],[CXX],[ -DPIC],[])])], [],\n    [case $_LT_TAGVAR(lt_prog_compiler_pic, $1) in\n     \"\" | \" \"*) ;;\n     *) _LT_TAGVAR(lt_prog_compiler_pic, $1)=\" $_LT_TAGVAR(lt_prog_compiler_pic, $1)\" ;;\n     esac],\n    [_LT_TAGVAR(lt_prog_compiler_pic, $1)=\n     _LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no])\nfi\n_LT_TAGDECL([pic_flag], [lt_prog_compiler_pic], [1],\n\t[Additional compiler flags for building library objects])\n\n#\n# Check to make sure the static flag actually works.\n#\nwl=$_LT_TAGVAR(lt_prog_compiler_wl, $1) eval lt_tmp_static_flag=\\\"$_LT_TAGVAR(lt_prog_compiler_static, $1)\\\"\n_LT_LINKER_OPTION([if $compiler static flag $lt_tmp_static_flag works],\n  _LT_TAGVAR(lt_cv_prog_compiler_static_works, $1),\n  $lt_tmp_static_flag,\n  [],\n  [_LT_TAGVAR(lt_prog_compiler_static, $1)=])\n_LT_TAGDECL([link_static_flag], [lt_prog_compiler_static], [1],\n\t[Compiler flag to prevent dynamic linking])\n])# _LT_COMPILER_PIC\n\n\n# _LT_LINKER_SHLIBS([TAGNAME])\n# ----------------------------\n# See if the linker supports building shared libraries.\nm4_defun([_LT_LINKER_SHLIBS],\n[AC_REQUIRE([LT_PATH_LD])dnl\nAC_REQUIRE([LT_PATH_NM])dnl\nm4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_DECL_EGREP])dnl\nm4_require([_LT_DECL_SED])dnl\nm4_require([_LT_CMD_GLOBAL_SYMBOLS])dnl\nm4_require([_LT_TAG_COMPILER])dnl\nAC_MSG_CHECKING([whether the $compiler linker ($LD) supports shared libraries])\nm4_if([$1], [CXX], [\n  _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\\''s/.* //'\\'' | sort | uniq > $export_symbols'\n  case $host_os in\n  aix[[4-9]]*)\n    # If we're using GNU nm, then we don't want the \"-C\" option.\n    # -C means demangle to AIX nm, but means don't demangle with GNU nm\n    if $NM -V 2>&1 | $GREP 'GNU' > /dev/null; then\n      _LT_TAGVAR(export_symbols_cmds, $1)='$NM -Bpg $libobjs $convenience | awk '\\''{ if (((\\$ 2 == \"T\") || (\\$ 2 == \"D\") || (\\$ 2 == \"B\")) && ([substr](\\$ 3,1,1) != \".\")) { print \\$ 3 } }'\\'' | sort -u > $export_symbols'\n    else\n      _LT_TAGVAR(export_symbols_cmds, $1)='$NM -BCpg $libobjs $convenience | awk '\\''{ if (((\\$ 2 == \"T\") || (\\$ 2 == \"D\") || (\\$ 2 == \"B\")) && ([substr](\\$ 3,1,1) != \".\")) { print \\$ 3 } }'\\'' | sort -u > $export_symbols'\n    fi\n    ;;\n  pw32*)\n    _LT_TAGVAR(export_symbols_cmds, $1)=\"$ltdll_cmds\"\n  ;;\n  cygwin* | mingw* | cegcc*)\n    _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED -e '\\''/^[[BCDGRS]][[ ]]/s/.*[[ ]]\\([[^ ]]*\\)/\\1 DATA/;/^.*[[ ]]__nm__/s/^.*[[ ]]__nm__\\([[^ ]]*\\)[[ ]][[^ ]]*/\\1 DATA/;/^I[[ ]]/d;/^[[AITW]][[ ]]/s/.* //'\\'' | sort | uniq > $export_symbols'\n  ;;\n  *)\n    _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\\''s/.* //'\\'' | sort | uniq > $export_symbols'\n  ;;\n  esac\n  _LT_TAGVAR(exclude_expsyms, $1)=['_GLOBAL_OFFSET_TABLE_|_GLOBAL__F[ID]_.*']\n], [\n  runpath_var=\n  _LT_TAGVAR(allow_undefined_flag, $1)=\n  _LT_TAGVAR(always_export_symbols, $1)=no\n  _LT_TAGVAR(archive_cmds, $1)=\n  _LT_TAGVAR(archive_expsym_cmds, $1)=\n  _LT_TAGVAR(compiler_needs_object, $1)=no\n  _LT_TAGVAR(enable_shared_with_static_runtimes, $1)=no\n  _LT_TAGVAR(export_dynamic_flag_spec, $1)=\n  _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\\''s/.* //'\\'' | sort | uniq > $export_symbols'\n  _LT_TAGVAR(hardcode_automatic, $1)=no\n  _LT_TAGVAR(hardcode_direct, $1)=no\n  _LT_TAGVAR(hardcode_direct_absolute, $1)=no\n  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)=\n  _LT_TAGVAR(hardcode_libdir_flag_spec_ld, $1)=\n  _LT_TAGVAR(hardcode_libdir_separator, $1)=\n  _LT_TAGVAR(hardcode_minus_L, $1)=no\n  _LT_TAGVAR(hardcode_shlibpath_var, $1)=unsupported\n  _LT_TAGVAR(inherit_rpath, $1)=no\n  _LT_TAGVAR(link_all_deplibs, $1)=unknown\n  _LT_TAGVAR(module_cmds, $1)=\n  _LT_TAGVAR(module_expsym_cmds, $1)=\n  _LT_TAGVAR(old_archive_from_new_cmds, $1)=\n  _LT_TAGVAR(old_archive_from_expsyms_cmds, $1)=\n  _LT_TAGVAR(thread_safe_flag_spec, $1)=\n  _LT_TAGVAR(whole_archive_flag_spec, $1)=\n  # include_expsyms should be a list of space-separated symbols to be *always*\n  # included in the symbol list\n  _LT_TAGVAR(include_expsyms, $1)=\n  # exclude_expsyms can be an extended regexp of symbols to exclude\n  # it will be wrapped by ` (' and `)$', so one must not match beginning or\n  # end of line.  Example: `a|bc|.*d.*' will exclude the symbols `a' and `bc',\n  # as well as any symbol that contains `d'.\n  _LT_TAGVAR(exclude_expsyms, $1)=['_GLOBAL_OFFSET_TABLE_|_GLOBAL__F[ID]_.*']\n  # Although _GLOBAL_OFFSET_TABLE_ is a valid symbol C name, most a.out\n  # platforms (ab)use it in PIC code, but their linkers get confused if\n  # the symbol is explicitly referenced.  Since portable code cannot\n  # rely on this symbol name, it's probably fine to never include it in\n  # preloaded symbol tables.\n  # Exclude shared library initialization/finalization symbols.\ndnl Note also adjust exclude_expsyms for C++ above.\n  extract_expsyms_cmds=\n\n  case $host_os in\n  cygwin* | mingw* | pw32* | cegcc*)\n    # FIXME: the MSVC++ port hasn't been tested in a loooong time\n    # When not using gcc, we currently assume that we are using\n    # Microsoft Visual C++.\n    if test \"$GCC\" != yes; then\n      with_gnu_ld=no\n    fi\n    ;;\n  interix*)\n    # we just hope/assume this is gcc and not c89 (= MSVC++)\n    with_gnu_ld=yes\n    ;;\n  openbsd*)\n    with_gnu_ld=no\n    ;;\n  esac\n\n  _LT_TAGVAR(ld_shlibs, $1)=yes\n  if test \"$with_gnu_ld\" = yes; then\n    # If archive_cmds runs LD, not CC, wlarc should be empty\n    wlarc='${wl}'\n\n    # Set some defaults for GNU ld with shared library support. These\n    # are reset later if shared libraries are not supported. Putting them\n    # here allows them to be overridden if necessary.\n    runpath_var=LD_RUN_PATH\n    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'\n    # ancient GNU ld didn't support --whole-archive et. al.\n    if $LD --help 2>&1 | $GREP 'no-whole-archive' > /dev/null; then\n      _LT_TAGVAR(whole_archive_flag_spec, $1)=\"$wlarc\"'--whole-archive$convenience '\"$wlarc\"'--no-whole-archive'\n    else\n      _LT_TAGVAR(whole_archive_flag_spec, $1)=\n    fi\n    supports_anon_versioning=no\n    case `$LD -v 2>&1` in\n      *\\ [[01]].* | *\\ 2.[[0-9]].* | *\\ 2.10.*) ;; # catch versions < 2.11\n      *\\ 2.11.93.0.2\\ *) supports_anon_versioning=yes ;; # RH7.3 ...\n      *\\ 2.11.92.0.12\\ *) supports_anon_versioning=yes ;; # Mandrake 8.2 ...\n      *\\ 2.11.*) ;; # other 2.11 versions\n      *) supports_anon_versioning=yes ;;\n    esac\n\n    # See if GNU ld supports shared libraries.\n    case $host_os in\n    aix[[3-9]]*)\n      # On AIX/PPC, the GNU linker is very broken\n      if test \"$host_cpu\" != ia64; then\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n\tcat <<_LT_EOF 1>&2\n\n*** Warning: the GNU linker, at least up to release 2.9.1, is reported\n*** to be unable to reliably create shared libraries on AIX.\n*** Therefore, libtool is disabling shared libraries support.  If you\n*** really care for shared libraries, you may want to modify your PATH\n*** so that a non-GNU linker is found, and then restart.\n\n_LT_EOF\n      fi\n      ;;\n\n    amigaos*)\n      case $host_cpu in\n      powerpc)\n            # see comment about AmigaOS4 .so support\n            _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n            _LT_TAGVAR(archive_expsym_cmds, $1)=''\n        ;;\n      m68k)\n            _LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/a2ixlibrary.data~$ECHO \"#define NAME $libname\" > $output_objdir/a2ixlibrary.data~$ECHO \"#define LIBRARY_ID 1\" >> $output_objdir/a2ixlibrary.data~$ECHO \"#define VERSION $major\" >> $output_objdir/a2ixlibrary.data~$ECHO \"#define REVISION $revision\" >> $output_objdir/a2ixlibrary.data~$AR $AR_FLAGS $lib $libobjs~$RANLIB $lib~(cd $output_objdir && a2ixlibrary -32)'\n            _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n            _LT_TAGVAR(hardcode_minus_L, $1)=yes\n        ;;\n      esac\n      ;;\n\n    beos*)\n      if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then\n\t_LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n\t# Joseph Beckenbach <jrb3@best.com> says some releases of gcc\n\t# support --undefined.  This deserves some investigation.  FIXME\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -nostart $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n      else\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n      fi\n      ;;\n\n    cygwin* | mingw* | pw32* | cegcc*)\n      # _LT_TAGVAR(hardcode_libdir_flag_spec, $1) is actually meaningless,\n      # as there is no search path for DLLs.\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n      _LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n      _LT_TAGVAR(always_export_symbols, $1)=no\n      _LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes\n      _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED -e '\\''/^[[BCDGRS]][[ ]]/s/.*[[ ]]\\([[^ ]]*\\)/\\1 DATA/'\\'' | $SED -e '\\''/^[[AITW]][[ ]]/s/.*[[ ]]//'\\'' | sort | uniq > $export_symbols'\n\n      if $LD --help 2>&1 | $GREP 'auto-import' > /dev/null; then\n        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'\n\t# If the export-symbols file already is a .def file (1st line\n\t# is EXPORTS), use it as is; otherwise, prepend...\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='if test \"x`$SED 1q $export_symbols`\" = xEXPORTS; then\n\t  cp $export_symbols $output_objdir/$soname.def;\n\telse\n\t  echo EXPORTS > $output_objdir/$soname.def;\n\t  cat $export_symbols >> $output_objdir/$soname.def;\n\tfi~\n\t$CC -shared $output_objdir/$soname.def $libobjs $deplibs $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'\n      else\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n      fi\n      ;;\n\n    interix[[3-9]]*)\n      _LT_TAGVAR(hardcode_direct, $1)=no\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n      # Hack: On Interix 3.x, we cannot compile PIC because of a broken gcc.\n      # Instead, shared libraries are loaded at an image base (0x10000000 by\n      # default) and relocated if they conflict, which is a slow very memory\n      # consuming and fragmenting process.  To avoid this, we pick a random,\n      # 256 KiB-aligned image base between 0x50000000 and 0x6FFC0000 at link\n      # time.  Moving up from 0x10000000 also allows more sbrk(2) space.\n      _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \\* 262144 + 1342177280` -o $lib'\n      _LT_TAGVAR(archive_expsym_cmds, $1)='sed \"s,^,_,\" $export_symbols >$output_objdir/$soname.expsym~$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--retain-symbols-file,$output_objdir/$soname.expsym ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \\* 262144 + 1342177280` -o $lib'\n      ;;\n\n    gnu* | linux* | tpf* | k*bsd*-gnu)\n      tmp_diet=no\n      if test \"$host_os\" = linux-dietlibc; then\n\tcase $cc_basename in\n\t  diet\\ *) tmp_diet=yes;;\t# linux-dietlibc with static linking (!diet-dyn)\n\tesac\n      fi\n      if $LD --help 2>&1 | $EGREP ': supported targets:.* elf' > /dev/null \\\n\t && test \"$tmp_diet\" = no\n      then\n\ttmp_addflag=\n\ttmp_sharedflag='-shared'\n\tcase $cc_basename,$host_cpu in\n        pgcc*)\t\t\t\t# Portland Group C compiler\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`for conv in $convenience\\\"\\\"; do test  -n \\\"$conv\\\" && new_convenience=\\\"$new_convenience,$conv\\\"; done; $ECHO \\\"$new_convenience\\\"` ${wl}--no-whole-archive'\n\t  tmp_addflag=' $pic_flag'\n\t  ;;\n\tpgf77* | pgf90* | pgf95*)\t# Portland Group f77 and f90 compilers\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`for conv in $convenience\\\"\\\"; do test  -n \\\"$conv\\\" && new_convenience=\\\"$new_convenience,$conv\\\"; done; $ECHO \\\"$new_convenience\\\"` ${wl}--no-whole-archive'\n\t  tmp_addflag=' $pic_flag -Mnomain' ;;\n\tecc*,ia64* | icc*,ia64*)\t# Intel C compiler on ia64\n\t  tmp_addflag=' -i_dynamic' ;;\n\tefc*,ia64* | ifort*,ia64*)\t# Intel Fortran compiler on ia64\n\t  tmp_addflag=' -i_dynamic -nofor_main' ;;\n\tifc* | ifort*)\t\t\t# Intel Fortran compiler\n\t  tmp_addflag=' -nofor_main' ;;\n\tlf95*)\t\t\t\t# Lahey Fortran 8.1\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)=\n\t  tmp_sharedflag='--shared' ;;\n\txl[[cC]]*)\t\t\t# IBM XL C 8.0 on PPC (deal with xlf below)\n\t  tmp_sharedflag='-qmkshrobj'\n\t  tmp_addflag= ;;\n\tesac\n\tcase `$CC -V 2>&1 | sed 5q` in\n\t*Sun\\ C*)\t\t\t# Sun C 5.9\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`new_convenience=; for conv in $convenience\\\"\\\"; do test -z \\\"$conv\\\" || new_convenience=\\\"$new_convenience,$conv\\\"; done; $ECHO \\\"$new_convenience\\\"` ${wl}--no-whole-archive'\n\t  _LT_TAGVAR(compiler_needs_object, $1)=yes\n\t  tmp_sharedflag='-G' ;;\n\t*Sun\\ F*)\t\t\t# Sun Fortran 8.3\n\t  tmp_sharedflag='-G' ;;\n\tesac\n\t_LT_TAGVAR(archive_cmds, $1)='$CC '\"$tmp_sharedflag\"\"$tmp_addflag\"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\n        if test \"x$supports_anon_versioning\" = xyes; then\n          _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $output_objdir/$libname.ver~\n\t    cat $export_symbols | sed -e \"s/\\(.*\\)/\\1;/\" >> $output_objdir/$libname.ver~\n\t    echo \"local: *; };\" >> $output_objdir/$libname.ver~\n\t    $CC '\"$tmp_sharedflag\"\"$tmp_addflag\"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-version-script ${wl}$output_objdir/$libname.ver -o $lib'\n        fi\n\n\tcase $cc_basename in\n\txlf*)\n\t  # IBM XL Fortran 10.1 on PPC cannot create shared libs itself\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='--whole-archive$convenience --no-whole-archive'\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)=\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec_ld, $1)='-rpath $libdir'\n\t  _LT_TAGVAR(archive_cmds, $1)='$LD -shared $libobjs $deplibs $compiler_flags -soname $soname -o $lib'\n\t  if test \"x$supports_anon_versioning\" = xyes; then\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $output_objdir/$libname.ver~\n\t      cat $export_symbols | sed -e \"s/\\(.*\\)/\\1;/\" >> $output_objdir/$libname.ver~\n\t      echo \"local: *; };\" >> $output_objdir/$libname.ver~\n\t      $LD -shared $libobjs $deplibs $compiler_flags -soname $soname -version-script $output_objdir/$libname.ver -o $lib'\n\t  fi\n\t  ;;\n\tesac\n      else\n        _LT_TAGVAR(ld_shlibs, $1)=no\n      fi\n      ;;\n\n    netbsd*)\n      if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then\n\t_LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable $libobjs $deplibs $linker_flags -o $lib'\n\twlarc=\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'\n      fi\n      ;;\n\n    solaris*)\n      if $LD -v 2>&1 | $GREP 'BFD 2\\.8' > /dev/null; then\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n\tcat <<_LT_EOF 1>&2\n\n*** Warning: The releases 2.8.* of the GNU linker cannot reliably\n*** create shared libraries on Solaris systems.  Therefore, libtool\n*** is disabling shared libraries support.  We urge you to upgrade GNU\n*** binutils to release 2.9.1 or newer.  Another option is to modify\n*** your PATH or compiler configuration so that the native linker is\n*** used, and then restart.\n\n_LT_EOF\n      elif $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'\n      else\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n      fi\n      ;;\n\n    sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX*)\n      case `$LD -v 2>&1` in\n        *\\ [[01]].* | *\\ 2.[[0-9]].* | *\\ 2.1[[0-5]].*)\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n\tcat <<_LT_EOF 1>&2\n\n*** Warning: Releases of the GNU linker prior to 2.16.91.0.3 can not\n*** reliably create shared libraries on SCO systems.  Therefore, libtool\n*** is disabling shared libraries support.  We urge you to upgrade GNU\n*** binutils to release 2.16.91.0.3 or newer.  Another option is to modify\n*** your PATH or compiler configuration so that the native linker is\n*** used, and then restart.\n\n_LT_EOF\n\t;;\n\t*)\n\t  # For security reasons, it is highly recommended that you always\n\t  # use absolute paths for naming shared libraries, and exclude the\n\t  # DT_RUNPATH tag from executables and libraries.  But doing so\n\t  # requires that you compile everything twice, which is a pain.\n\t  if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'\n\t  else\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t  fi\n\t;;\n      esac\n      ;;\n\n    sunos4*)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -assert pure-text -Bshareable -o $lib $libobjs $deplibs $linker_flags'\n      wlarc=\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    *)\n      if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'\n      else\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n      fi\n      ;;\n    esac\n\n    if test \"$_LT_TAGVAR(ld_shlibs, $1)\" = no; then\n      runpath_var=\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)=\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)=\n      _LT_TAGVAR(whole_archive_flag_spec, $1)=\n    fi\n  else\n    # PORTME fill in a description of your system's linker (not GNU ld)\n    case $host_os in\n    aix3*)\n      _LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n      _LT_TAGVAR(always_export_symbols, $1)=yes\n      _LT_TAGVAR(archive_expsym_cmds, $1)='$LD -o $output_objdir/$soname $libobjs $deplibs $linker_flags -bE:$export_symbols -T512 -H512 -bM:SRE~$AR $AR_FLAGS $lib $output_objdir/$soname'\n      # Note: this linker hardcodes the directories in LIBPATH if there\n      # are no directories specified by -L.\n      _LT_TAGVAR(hardcode_minus_L, $1)=yes\n      if test \"$GCC\" = yes && test -z \"$lt_prog_compiler_static\"; then\n\t# Neither direct hardcoding nor static linking is supported with a\n\t# broken collect2.\n\t_LT_TAGVAR(hardcode_direct, $1)=unsupported\n      fi\n      ;;\n\n    aix[[4-9]]*)\n      if test \"$host_cpu\" = ia64; then\n\t# On IA64, the linker does run time linking by default, so we don't\n\t# have to do anything special.\n\taix_use_runtimelinking=no\n\texp_sym_flag='-Bexport'\n\tno_entry_flag=\"\"\n      else\n\t# If we're using GNU nm, then we don't want the \"-C\" option.\n\t# -C means demangle to AIX nm, but means don't demangle with GNU nm\n\tif $NM -V 2>&1 | $GREP 'GNU' > /dev/null; then\n\t  _LT_TAGVAR(export_symbols_cmds, $1)='$NM -Bpg $libobjs $convenience | awk '\\''{ if (((\\$ 2 == \"T\") || (\\$ 2 == \"D\") || (\\$ 2 == \"B\")) && ([substr](\\$ 3,1,1) != \".\")) { print \\$ 3 } }'\\'' | sort -u > $export_symbols'\n\telse\n\t  _LT_TAGVAR(export_symbols_cmds, $1)='$NM -BCpg $libobjs $convenience | awk '\\''{ if (((\\$ 2 == \"T\") || (\\$ 2 == \"D\") || (\\$ 2 == \"B\")) && ([substr](\\$ 3,1,1) != \".\")) { print \\$ 3 } }'\\'' | sort -u > $export_symbols'\n\tfi\n\taix_use_runtimelinking=no\n\n\t# Test if we are trying to use run time linking or normal\n\t# AIX style linking. If -brtl is somewhere in LDFLAGS, we\n\t# need to do runtime linking.\n\tcase $host_os in aix4.[[23]]|aix4.[[23]].*|aix[[5-9]]*)\n\t  for ld_flag in $LDFLAGS; do\n\t  if (test $ld_flag = \"-brtl\" || test $ld_flag = \"-Wl,-brtl\"); then\n\t    aix_use_runtimelinking=yes\n\t    break\n\t  fi\n\t  done\n\t  ;;\n\tesac\n\n\texp_sym_flag='-bexport'\n\tno_entry_flag='-bnoentry'\n      fi\n\n      # When large executables or shared objects are built, AIX ld can\n      # have problems creating the table of contents.  If linking a library\n      # or program results in \"error TOC overflow\" add -mminimal-toc to\n      # CXXFLAGS/CFLAGS for g++/gcc.  In the cases where that is not\n      # enough to fix the problem, add -Wl,-bbigtoc to LDFLAGS.\n\n      _LT_TAGVAR(archive_cmds, $1)=''\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=':'\n      _LT_TAGVAR(link_all_deplibs, $1)=yes\n      _LT_TAGVAR(file_list_spec, $1)='${wl}-f,'\n\n      if test \"$GCC\" = yes; then\n\tcase $host_os in aix4.[[012]]|aix4.[[012]].*)\n\t# We only want to do this on AIX 4.2 and lower, the check\n\t# below for broken collect2 doesn't work under 4.3+\n\t  collect2name=`${CC} -print-prog-name=collect2`\n\t  if test -f \"$collect2name\" &&\n\t   strings \"$collect2name\" | $GREP resolve_lib_name >/dev/null\n\t  then\n\t  # We have reworked collect2\n\t  :\n\t  else\n\t  # We have old collect2\n\t  _LT_TAGVAR(hardcode_direct, $1)=unsupported\n\t  # It fails to find uninstalled libraries when the uninstalled\n\t  # path is not listed in the libpath.  Setting hardcode_minus_L\n\t  # to unsupported forces relinking\n\t  _LT_TAGVAR(hardcode_minus_L, $1)=yes\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n\t  _LT_TAGVAR(hardcode_libdir_separator, $1)=\n\t  fi\n\t  ;;\n\tesac\n\tshared_flag='-shared'\n\tif test \"$aix_use_runtimelinking\" = yes; then\n\t  shared_flag=\"$shared_flag \"'${wl}-G'\n\tfi\n      else\n\t# not using gcc\n\tif test \"$host_cpu\" = ia64; then\n\t# VisualAge C++, Version 5.5 for AIX 5L for IA-64, Beta 3 Release\n\t# chokes on -Wl,-G. The following line is correct:\n\t  shared_flag='-G'\n\telse\n\t  if test \"$aix_use_runtimelinking\" = yes; then\n\t    shared_flag='${wl}-G'\n\t  else\n\t    shared_flag='${wl}-bM:SRE'\n\t  fi\n\tfi\n      fi\n\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-bexpall'\n      # It seems that -bexpall does not export symbols beginning with\n      # underscore (_), so it is better to generate a list of symbols to export.\n      _LT_TAGVAR(always_export_symbols, $1)=yes\n      if test \"$aix_use_runtimelinking\" = yes; then\n\t# Warning - without using the other runtime loading flags (-brtl),\n\t# -berok will link without error, but may produce a broken library.\n\t_LT_TAGVAR(allow_undefined_flag, $1)='-berok'\n        # Determine the default libpath from the value encoded in an\n        # empty executable.\n        _LT_SYS_MODULE_PATH_AIX\n        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-blibpath:$libdir:'\"$aix_libpath\"\n        _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -o $output_objdir/$soname $libobjs $deplibs '\"\\${wl}$no_entry_flag\"' $compiler_flags `if test \"x${allow_undefined_flag}\" != \"x\"; then $ECHO \"X${wl}${allow_undefined_flag}\" | $Xsed; else :; fi` '\"\\${wl}$exp_sym_flag:\\$export_symbols $shared_flag\"\n      else\n\tif test \"$host_cpu\" = ia64; then\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-R $libdir:/usr/lib:/lib'\n\t  _LT_TAGVAR(allow_undefined_flag, $1)=\"-z nodefs\"\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)=\"\\$CC $shared_flag\"' -o $output_objdir/$soname $libobjs $deplibs '\"\\${wl}$no_entry_flag\"' $compiler_flags ${wl}${allow_undefined_flag} '\"\\${wl}$exp_sym_flag:\\$export_symbols\"\n\telse\n\t # Determine the default libpath from the value encoded in an\n\t # empty executable.\n\t _LT_SYS_MODULE_PATH_AIX\n\t _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-blibpath:$libdir:'\"$aix_libpath\"\n\t  # Warning - without using the other run time loading flags,\n\t  # -berok will link without error, but may produce a broken library.\n\t  _LT_TAGVAR(no_undefined_flag, $1)=' ${wl}-bernotok'\n\t  _LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-berok'\n\t  # Exported symbols can be pulled into shared objects from archives\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='$convenience'\n\t  _LT_TAGVAR(archive_cmds_need_lc, $1)=yes\n\t  # This is similar to how AIX traditionally builds its shared libraries.\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)=\"\\$CC $shared_flag\"' -o $output_objdir/$soname $libobjs $deplibs ${wl}-bnoentry $compiler_flags ${wl}-bE:$export_symbols${allow_undefined_flag}~$AR $AR_FLAGS $output_objdir/$libname$release.a $output_objdir/$soname'\n\tfi\n      fi\n      ;;\n\n    amigaos*)\n      case $host_cpu in\n      powerpc)\n            # see comment about AmigaOS4 .so support\n            _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n            _LT_TAGVAR(archive_expsym_cmds, $1)=''\n        ;;\n      m68k)\n            _LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/a2ixlibrary.data~$ECHO \"#define NAME $libname\" > $output_objdir/a2ixlibrary.data~$ECHO \"#define LIBRARY_ID 1\" >> $output_objdir/a2ixlibrary.data~$ECHO \"#define VERSION $major\" >> $output_objdir/a2ixlibrary.data~$ECHO \"#define REVISION $revision\" >> $output_objdir/a2ixlibrary.data~$AR $AR_FLAGS $lib $libobjs~$RANLIB $lib~(cd $output_objdir && a2ixlibrary -32)'\n            _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n            _LT_TAGVAR(hardcode_minus_L, $1)=yes\n        ;;\n      esac\n      ;;\n\n    bsdi[[45]]*)\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)=-rdynamic\n      ;;\n\n    cygwin* | mingw* | pw32* | cegcc*)\n      # When not using gcc, we currently assume that we are using\n      # Microsoft Visual C++.\n      # hardcode_libdir_flag_spec is actually meaningless, as there is\n      # no search path for DLLs.\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)=' '\n      _LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n      # Tell ltmain to make .lib files, not .a files.\n      libext=lib\n      # Tell ltmain to make .dll files, not .so files.\n      shrext_cmds=\".dll\"\n      # FIXME: Setting linknames here is a bad hack.\n      _LT_TAGVAR(archive_cmds, $1)='$CC -o $lib $libobjs $compiler_flags `$ECHO \"X$deplibs\" | $Xsed -e '\\''s/ -lc$//'\\''` -link -dll~linknames='\n      # The linker will automatically build a .lib file if we build a DLL.\n      _LT_TAGVAR(old_archive_from_new_cmds, $1)='true'\n      # FIXME: Should let the user specify the lib program.\n      _LT_TAGVAR(old_archive_cmds, $1)='lib -OUT:$oldlib$oldobjs$old_deplibs'\n      _LT_TAGVAR(fix_srcfile_path, $1)='`cygpath -w \"$srcfile\"`'\n      _LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes\n      ;;\n\n    darwin* | rhapsody*)\n      _LT_DARWIN_LINKER_FEATURES($1)\n      ;;\n\n    dgux*)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    freebsd1*)\n      _LT_TAGVAR(ld_shlibs, $1)=no\n      ;;\n\n    # FreeBSD 2.2.[012] allows us to include c++rt0.o to get C++ constructor\n    # support.  Future versions do this automatically, but an explicit c++rt0.o\n    # does not break anything, and helps significantly (at the cost of a little\n    # extra space).\n    freebsd2.2*)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags /usr/lib/c++rt0.o'\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    # Unfortunately, older versions of FreeBSD 2 do not have this feature.\n    freebsd2*)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_minus_L, $1)=yes\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    # FreeBSD 3 and greater uses gcc -shared to do shared libraries.\n    freebsd* | dragonfly*)\n      _LT_TAGVAR(archive_cmds, $1)='$CC -shared -o $lib $libobjs $deplibs $compiler_flags'\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    hpux9*)\n      if test \"$GCC\" = yes; then\n\t_LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/$soname~$CC -shared -fPIC ${wl}+b ${wl}$install_libdir -o $output_objdir/$soname $libobjs $deplibs $compiler_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/$soname~$LD -b +b $install_libdir -o $output_objdir/$soname $libobjs $deplibs $linker_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'\n      fi\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n\n      # hardcode_minus_L: Not really in the search PATH,\n      # but as the default location of the library.\n      _LT_TAGVAR(hardcode_minus_L, $1)=yes\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n      ;;\n\n    hpux10*)\n      if test \"$GCC\" = yes -a \"$with_gnu_ld\" = no; then\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared -fPIC ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$LD -b +h $soname +b $install_libdir -o $lib $libobjs $deplibs $linker_flags'\n      fi\n      if test \"$with_gnu_ld\" = no; then\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'\n\t_LT_TAGVAR(hardcode_libdir_flag_spec_ld, $1)='+b $libdir'\n\t_LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\t_LT_TAGVAR(hardcode_direct, $1)=yes\n\t_LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n\t_LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n\t# hardcode_minus_L: Not really in the search PATH,\n\t# but as the default location of the library.\n\t_LT_TAGVAR(hardcode_minus_L, $1)=yes\n      fi\n      ;;\n\n    hpux11*)\n      if test \"$GCC\" = yes -a \"$with_gnu_ld\" = no; then\n\tcase $host_cpu in\n\thppa*64*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}+h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\tia64*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -shared -fPIC ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\t*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -shared -fPIC ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\tesac\n      else\n\tcase $host_cpu in\n\thppa*64*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\tia64*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\t*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\tesac\n      fi\n      if test \"$with_gnu_ld\" = no; then\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'\n\t_LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\n\tcase $host_cpu in\n\thppa*64*|ia64*)\n\t  _LT_TAGVAR(hardcode_direct, $1)=no\n\t  _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\t  ;;\n\t*)\n\t  _LT_TAGVAR(hardcode_direct, $1)=yes\n\t  _LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n\t  _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n\n\t  # hardcode_minus_L: Not really in the search PATH,\n\t  # but as the default location of the library.\n\t  _LT_TAGVAR(hardcode_minus_L, $1)=yes\n\t  ;;\n\tesac\n      fi\n      ;;\n\n    irix5* | irix6* | nonstopux*)\n      if test \"$GCC\" = yes; then\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n \"$verstring\" && $ECHO \"X${wl}-set_version ${wl}$verstring\" | $Xsed` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'\n\t# Try to use the -exported_symbol ld option, if it does not\n\t# work, assume that -exports_file does not work either and\n\t# implicitly export all symbols.\n        save_LDFLAGS=\"$LDFLAGS\"\n        LDFLAGS=\"$LDFLAGS -shared ${wl}-exported_symbol ${wl}foo ${wl}-update_registry ${wl}/dev/null\"\n        AC_LINK_IFELSE([AC_LANG_SOURCE([int foo(void) {}]),\n          _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n \"$verstring\" && $ECHO \"X${wl}-set_version ${wl}$verstring\" | $Xsed` ${wl}-update_registry ${wl}${output_objdir}/so_locations ${wl}-exports_file ${wl}$export_symbols -o $lib'\n        ])\n        LDFLAGS=\"$save_LDFLAGS\"\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags -soname $soname `test -n \"$verstring\" && $ECHO \"X-set_version $verstring\" | $Xsed` -update_registry ${output_objdir}/so_locations -o $lib'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags -soname $soname `test -n \"$verstring\" && $ECHO \"X-set_version $verstring\" | $Xsed` -update_registry ${output_objdir}/so_locations -exports_file $export_symbols -o $lib'\n      fi\n      _LT_TAGVAR(archive_cmds_need_lc, $1)='no'\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n      _LT_TAGVAR(inherit_rpath, $1)=yes\n      _LT_TAGVAR(link_all_deplibs, $1)=yes\n      ;;\n\n    netbsd*)\n      if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then\n\t_LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'  # a.out\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$LD -shared -o $lib $libobjs $deplibs $linker_flags'      # ELF\n      fi\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    newsos6)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    *nto* | *qnx*)\n      ;;\n\n    openbsd*)\n      if test -f /usr/libexec/ld.so; then\n\t_LT_TAGVAR(hardcode_direct, $1)=yes\n\t_LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\t_LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n\tif test -z \"`echo __ELF__ | $CC -E - | $GREP __ELF__`\" || test \"$host_os-$host_cpu\" = \"openbsd2.8-powerpc\"; then\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags ${wl}-retain-symbols-file,$export_symbols'\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n\t  _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n\telse\n\t  case $host_os in\n\t   openbsd[[01]].* | openbsd2.[[0-7]] | openbsd2.[[0-7]].*)\n\t     _LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'\n\t     _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n\t     ;;\n\t   *)\n\t     _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'\n\t     _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n\t     ;;\n\t  esac\n\tfi\n      else\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n      fi\n      ;;\n\n    os2*)\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n      _LT_TAGVAR(hardcode_minus_L, $1)=yes\n      _LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n      _LT_TAGVAR(archive_cmds, $1)='$ECHO \"LIBRARY $libname INITINSTANCE\" > $output_objdir/$libname.def~$ECHO \"DESCRIPTION \\\"$libname\\\"\" >> $output_objdir/$libname.def~$ECHO DATA >> $output_objdir/$libname.def~$ECHO \" SINGLE NONSHARED\" >> $output_objdir/$libname.def~$ECHO EXPORTS >> $output_objdir/$libname.def~emxexp $libobjs >> $output_objdir/$libname.def~$CC -Zdll -Zcrtdll -o $lib $libobjs $deplibs $compiler_flags $output_objdir/$libname.def'\n      _LT_TAGVAR(old_archive_from_new_cmds, $1)='emximp -o $output_objdir/$libname.a $output_objdir/$libname.def'\n      ;;\n\n    osf3*)\n      if test \"$GCC\" = yes; then\n\t_LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-expect_unresolved ${wl}\\*'\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n \"$verstring\" && $ECHO \"X${wl}-set_version ${wl}$verstring\" | $Xsed` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'\n      else\n\t_LT_TAGVAR(allow_undefined_flag, $1)=' -expect_unresolved \\*'\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags -soname $soname `test -n \"$verstring\" && $ECHO \"X-set_version $verstring\" | $Xsed` -update_registry ${output_objdir}/so_locations -o $lib'\n      fi\n      _LT_TAGVAR(archive_cmds_need_lc, $1)='no'\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n      ;;\n\n    osf4* | osf5*)\t# as osf3* with the addition of -msym flag\n      if test \"$GCC\" = yes; then\n\t_LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-expect_unresolved ${wl}\\*'\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags ${wl}-msym ${wl}-soname ${wl}$soname `test -n \"$verstring\" && $ECHO \"X${wl}-set_version ${wl}$verstring\" | $Xsed` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n      else\n\t_LT_TAGVAR(allow_undefined_flag, $1)=' -expect_unresolved \\*'\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $libobjs $deplibs $compiler_flags -msym -soname $soname `test -n \"$verstring\" && $ECHO \"X-set_version $verstring\" | $Xsed` -update_registry ${output_objdir}/so_locations -o $lib'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='for i in `cat $export_symbols`; do printf \"%s %s\\\\n\" -exported_symbol \"\\$i\" >> $lib.exp; done; printf \"%s\\\\n\" \"-hidden\">> $lib.exp~\n\t$CC -shared${allow_undefined_flag} ${wl}-input ${wl}$lib.exp $compiler_flags $libobjs $deplibs -soname $soname `test -n \"$verstring\" && $ECHO \"X-set_version $verstring\" | $Xsed` -update_registry ${output_objdir}/so_locations -o $lib~$RM $lib.exp'\n\n\t# Both c and cxx compiler support -rpath directly\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-rpath $libdir'\n      fi\n      _LT_TAGVAR(archive_cmds_need_lc, $1)='no'\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n      ;;\n\n    solaris*)\n      _LT_TAGVAR(no_undefined_flag, $1)=' -z defs'\n      if test \"$GCC\" = yes; then\n\twlarc='${wl}'\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}-z ${wl}text ${wl}-h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $lib.exp~cat $export_symbols | $SED -e \"s/\\(.*\\)/\\1;/\" >> $lib.exp~echo \"local: *; };\" >> $lib.exp~\n\t  $CC -shared ${wl}-z ${wl}text ${wl}-M ${wl}$lib.exp ${wl}-h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags~$RM $lib.exp'\n      else\n\tcase `$CC -V 2>&1` in\n\t*\"Compilers 5.0\"*)\n\t  wlarc=''\n\t  _LT_TAGVAR(archive_cmds, $1)='$LD -G${allow_undefined_flag} -h $soname -o $lib $libobjs $deplibs $linker_flags'\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $lib.exp~cat $export_symbols | $SED -e \"s/\\(.*\\)/\\1;/\" >> $lib.exp~echo \"local: *; };\" >> $lib.exp~\n\t  $LD -G${allow_undefined_flag} -M $lib.exp -h $soname -o $lib $libobjs $deplibs $linker_flags~$RM $lib.exp'\n\t  ;;\n\t*)\n\t  wlarc='${wl}'\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -G${allow_undefined_flag} -h $soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $lib.exp~cat $export_symbols | $SED -e \"s/\\(.*\\)/\\1;/\" >> $lib.exp~echo \"local: *; };\" >> $lib.exp~\n\t  $CC -G${allow_undefined_flag} -M $lib.exp -h $soname -o $lib $libobjs $deplibs $compiler_flags~$RM $lib.exp'\n\t  ;;\n\tesac\n      fi\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      case $host_os in\n      solaris2.[[0-5]] | solaris2.[[0-5]].*) ;;\n      *)\n\t# The compiler driver will combine and reorder linker options,\n\t# but understands `-z linker_flag'.  GCC discards it without `$wl',\n\t# but is careful enough not to reorder.\n\t# Supported since Solaris 2.6 (maybe 2.5.1?)\n\tif test \"$GCC\" = yes; then\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}-z ${wl}allextract$convenience ${wl}-z ${wl}defaultextract'\n\telse\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='-z allextract$convenience -z defaultextract'\n\tfi\n\t;;\n      esac\n      _LT_TAGVAR(link_all_deplibs, $1)=yes\n      ;;\n\n    sunos4*)\n      if test \"x$host_vendor\" = xsequent; then\n\t# Use $CC to link under sequent, because it throws in some extra .o\n\t# files that make .init and .fini sections work.\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h $soname -o $lib $libobjs $deplibs $compiler_flags'\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$LD -assert pure-text -Bstatic -o $lib $libobjs $deplibs $linker_flags'\n      fi\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_minus_L, $1)=yes\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    sysv4)\n      case $host_vendor in\n\tsni)\n\t  _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n\t  _LT_TAGVAR(hardcode_direct, $1)=yes # is this really true???\n\t;;\n\tsiemens)\n\t  ## LD is ld it makes a PLAMLIB\n\t  ## CC just makes a GrossModule.\n\t  _LT_TAGVAR(archive_cmds, $1)='$LD -G -o $lib $libobjs $deplibs $linker_flags'\n\t  _LT_TAGVAR(reload_cmds, $1)='$CC -r -o $output$reload_objs'\n\t  _LT_TAGVAR(hardcode_direct, $1)=no\n        ;;\n\tmotorola)\n\t  _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n\t  _LT_TAGVAR(hardcode_direct, $1)=no #Motorola manual says yes, but my tests say they lie\n\t;;\n      esac\n      runpath_var='LD_RUN_PATH'\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    sysv4.3*)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)='-Bexport'\n      ;;\n\n    sysv4*MP*)\n      if test -d /usr/nec; then\n\t_LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n\t_LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\trunpath_var=LD_RUN_PATH\n\thardcode_runpath_var=yes\n\t_LT_TAGVAR(ld_shlibs, $1)=yes\n      fi\n      ;;\n\n    sysv4*uw2* | sysv5OpenUNIX* | sysv5UnixWare7.[[01]].[[10]]* | unixware7* | sco3.2v5.0.[[024]]*)\n      _LT_TAGVAR(no_undefined_flag, $1)='${wl}-z,text'\n      _LT_TAGVAR(archive_cmds_need_lc, $1)=no\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      runpath_var='LD_RUN_PATH'\n\n      if test \"$GCC\" = yes; then\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n      fi\n      ;;\n\n    sysv5* | sco3.2v5* | sco5v6*)\n      # Note: We can NOT use -z defs as we might desire, because we do not\n      # link with -lc, and that would cause any symbols used from libc to\n      # always be unresolved, which means just about no library would\n      # ever link correctly.  If we're not using GNU ld we use -z text\n      # though, which does catch some bad symbols but isn't as heavy-handed\n      # as -z defs.\n      _LT_TAGVAR(no_undefined_flag, $1)='${wl}-z,text'\n      _LT_TAGVAR(allow_undefined_flag, $1)='${wl}-z,nodefs'\n      _LT_TAGVAR(archive_cmds_need_lc, $1)=no\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-R,$libdir'\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=':'\n      _LT_TAGVAR(link_all_deplibs, $1)=yes\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-Bexport'\n      runpath_var='LD_RUN_PATH'\n\n      if test \"$GCC\" = yes; then\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n      fi\n      ;;\n\n    uts4*)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    *)\n      _LT_TAGVAR(ld_shlibs, $1)=no\n      ;;\n    esac\n\n    if test x$host_vendor = xsni; then\n      case $host in\n      sysv4 | sysv4.2uw2* | sysv4.3* | sysv5*)\n\t_LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-Blargedynsym'\n\t;;\n      esac\n    fi\n  fi\n])\nAC_MSG_RESULT([$_LT_TAGVAR(ld_shlibs, $1)])\ntest \"$_LT_TAGVAR(ld_shlibs, $1)\" = no && can_build_shared=no\n\n_LT_TAGVAR(with_gnu_ld, $1)=$with_gnu_ld\n\n_LT_DECL([], [libext], [0], [Old archive suffix (normally \"a\")])dnl\n_LT_DECL([], [shrext_cmds], [1], [Shared library suffix (normally \".so\")])dnl\n_LT_DECL([], [extract_expsyms_cmds], [2],\n    [The commands to extract the exported symbol list from a shared archive])\n\n#\n# Do we need to explicitly link libc?\n#\ncase \"x$_LT_TAGVAR(archive_cmds_need_lc, $1)\" in\nx|xyes)\n  # Assume -lc should be added\n  _LT_TAGVAR(archive_cmds_need_lc, $1)=yes\n\n  if test \"$enable_shared\" = yes && test \"$GCC\" = yes; then\n    case $_LT_TAGVAR(archive_cmds, $1) in\n    *'~'*)\n      # FIXME: we may have to deal with multi-command sequences.\n      ;;\n    '$CC '*)\n      # Test whether the compiler implicitly links with -lc since on some\n      # systems, -lgcc has to come before -lc. If gcc already passes -lc\n      # to ld, don't add -lc before -lgcc.\n      AC_MSG_CHECKING([whether -lc should be explicitly linked in])\n      $RM conftest*\n      echo \"$lt_simple_compile_test_code\" > conftest.$ac_ext\n\n      if AC_TRY_EVAL(ac_compile) 2>conftest.err; then\n        soname=conftest\n        lib=conftest\n        libobjs=conftest.$ac_objext\n        deplibs=\n        wl=$_LT_TAGVAR(lt_prog_compiler_wl, $1)\n\tpic_flag=$_LT_TAGVAR(lt_prog_compiler_pic, $1)\n        compiler_flags=-v\n        linker_flags=-v\n        verstring=\n        output_objdir=.\n        libname=conftest\n        lt_save_allow_undefined_flag=$_LT_TAGVAR(allow_undefined_flag, $1)\n        _LT_TAGVAR(allow_undefined_flag, $1)=\n        if AC_TRY_EVAL(_LT_TAGVAR(archive_cmds, $1) 2\\>\\&1 \\| $GREP \\\" -lc \\\" \\>/dev/null 2\\>\\&1)\n        then\n\t  _LT_TAGVAR(archive_cmds_need_lc, $1)=no\n        else\n\t  _LT_TAGVAR(archive_cmds_need_lc, $1)=yes\n        fi\n        _LT_TAGVAR(allow_undefined_flag, $1)=$lt_save_allow_undefined_flag\n      else\n        cat conftest.err 1>&5\n      fi\n      $RM conftest*\n      AC_MSG_RESULT([$_LT_TAGVAR(archive_cmds_need_lc, $1)])\n      ;;\n    esac\n  fi\n  ;;\nesac\n\n_LT_TAGDECL([build_libtool_need_lc], [archive_cmds_need_lc], [0],\n    [Whether or not to add -lc for building shared libraries])\n_LT_TAGDECL([allow_libtool_libs_with_static_runtimes],\n    [enable_shared_with_static_runtimes], [0],\n    [Whether or not to disallow shared libs when runtime libs are static])\n_LT_TAGDECL([], [export_dynamic_flag_spec], [1],\n    [Compiler flag to allow reflexive dlopens])\n_LT_TAGDECL([], [whole_archive_flag_spec], [1],\n    [Compiler flag to generate shared objects directly from archives])\n_LT_TAGDECL([], [compiler_needs_object], [1],\n    [Whether the compiler copes with passing no objects directly])\n_LT_TAGDECL([], [old_archive_from_new_cmds], [2],\n    [Create an old-style archive from a shared archive])\n_LT_TAGDECL([], [old_archive_from_expsyms_cmds], [2],\n    [Create a temporary old-style archive to link instead of a shared archive])\n_LT_TAGDECL([], [archive_cmds], [2], [Commands used to build a shared archive])\n_LT_TAGDECL([], [archive_expsym_cmds], [2])\n_LT_TAGDECL([], [module_cmds], [2],\n    [Commands used to build a loadable module if different from building\n    a shared archive.])\n_LT_TAGDECL([], [module_expsym_cmds], [2])\n_LT_TAGDECL([], [with_gnu_ld], [1],\n    [Whether we are building with GNU ld or not])\n_LT_TAGDECL([], [allow_undefined_flag], [1],\n    [Flag that allows shared libraries with undefined symbols to be built])\n_LT_TAGDECL([], [no_undefined_flag], [1],\n    [Flag that enforces no undefined symbols])\n_LT_TAGDECL([], [hardcode_libdir_flag_spec], [1],\n    [Flag to hardcode $libdir into a binary during linking.\n    This must work even if $libdir does not exist])\n_LT_TAGDECL([], [hardcode_libdir_flag_spec_ld], [1],\n    [[If ld is used when linking, flag to hardcode $libdir into a binary\n    during linking.  This must work even if $libdir does not exist]])\n_LT_TAGDECL([], [hardcode_libdir_separator], [1],\n    [Whether we need a single \"-rpath\" flag with a separated argument])\n_LT_TAGDECL([], [hardcode_direct], [0],\n    [Set to \"yes\" if using DIR/libNAME${shared_ext} during linking hardcodes\n    DIR into the resulting binary])\n_LT_TAGDECL([], [hardcode_direct_absolute], [0],\n    [Set to \"yes\" if using DIR/libNAME${shared_ext} during linking hardcodes\n    DIR into the resulting binary and the resulting library dependency is\n    \"absolute\", i.e impossible to change by setting ${shlibpath_var} if the\n    library is relocated])\n_LT_TAGDECL([], [hardcode_minus_L], [0],\n    [Set to \"yes\" if using the -LDIR flag during linking hardcodes DIR\n    into the resulting binary])\n_LT_TAGDECL([], [hardcode_shlibpath_var], [0],\n    [Set to \"yes\" if using SHLIBPATH_VAR=DIR during linking hardcodes DIR\n    into the resulting binary])\n_LT_TAGDECL([], [hardcode_automatic], [0],\n    [Set to \"yes\" if building a shared library automatically hardcodes DIR\n    into the library and all subsequent libraries and executables linked\n    against it])\n_LT_TAGDECL([], [inherit_rpath], [0],\n    [Set to yes if linker adds runtime paths of dependent libraries\n    to runtime path list])\n_LT_TAGDECL([], [link_all_deplibs], [0],\n    [Whether libtool must link a program against all its dependency libraries])\n_LT_TAGDECL([], [fix_srcfile_path], [1],\n    [Fix the shell variable $srcfile for the compiler])\n_LT_TAGDECL([], [always_export_symbols], [0],\n    [Set to \"yes\" if exported symbols are required])\n_LT_TAGDECL([], [export_symbols_cmds], [2],\n    [The commands to list exported symbols])\n_LT_TAGDECL([], [exclude_expsyms], [1],\n    [Symbols that should not be listed in the preloaded symbols])\n_LT_TAGDECL([], [include_expsyms], [1],\n    [Symbols that must always be exported])\n_LT_TAGDECL([], [prelink_cmds], [2],\n    [Commands necessary for linking programs (against libraries) with templates])\n_LT_TAGDECL([], [file_list_spec], [1],\n    [Specify filename containing input files])\ndnl FIXME: Not yet implemented\ndnl _LT_TAGDECL([], [thread_safe_flag_spec], [1],\ndnl    [Compiler flag to generate thread safe objects])\n])# _LT_LINKER_SHLIBS\n\n\n# _LT_LANG_C_CONFIG([TAG])\n# ------------------------\n# Ensure that the configuration variables for a C compiler are suitably\n# defined.  These variables are subsequently used by _LT_CONFIG to write\n# the compiler configuration to `libtool'.\nm4_defun([_LT_LANG_C_CONFIG],\n[m4_require([_LT_DECL_EGREP])dnl\nlt_save_CC=\"$CC\"\nAC_LANG_PUSH(C)\n\n# Source file extension for C test sources.\nac_ext=c\n\n# Object file extension for compiled C test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# Code to be used in simple compile tests\nlt_simple_compile_test_code=\"int some_variable = 0;\"\n\n# Code to be used in simple link tests\nlt_simple_link_test_code='int main(){return(0);}'\n\n_LT_TAG_COMPILER\n# Save the default compiler, since it gets overwritten when the other\n# tags are being tested, and _LT_TAGVAR(compiler, []) is a NOP.\ncompiler_DEFAULT=$CC\n\n# save warnings/boilerplate of simple test code\n_LT_COMPILER_BOILERPLATE\n_LT_LINKER_BOILERPLATE\n\n## CAVEAT EMPTOR:\n## There is no encapsulation within the following macros, do not change\n## the running order or otherwise move them around unless you know exactly\n## what you are doing...\nif test -n \"$compiler\"; then\n  _LT_COMPILER_NO_RTTI($1)\n  _LT_COMPILER_PIC($1)\n  _LT_COMPILER_C_O($1)\n  _LT_COMPILER_FILE_LOCKS($1)\n  _LT_LINKER_SHLIBS($1)\n  _LT_SYS_DYNAMIC_LINKER($1)\n  _LT_LINKER_HARDCODE_LIBPATH($1)\n  LT_SYS_DLOPEN_SELF\n  _LT_CMD_STRIPLIB\n\n  # Report which library types will actually be built\n  AC_MSG_CHECKING([if libtool supports shared libraries])\n  AC_MSG_RESULT([$can_build_shared])\n\n  AC_MSG_CHECKING([whether to build shared libraries])\n  test \"$can_build_shared\" = \"no\" && enable_shared=no\n\n  # On AIX, shared libraries and static libraries use the same namespace, and\n  # are all built from PIC.\n  case $host_os in\n  aix3*)\n    test \"$enable_shared\" = yes && enable_static=no\n    if test -n \"$RANLIB\"; then\n      archive_cmds=\"$archive_cmds~\\$RANLIB \\$lib\"\n      postinstall_cmds='$RANLIB $lib'\n    fi\n    ;;\n\n  aix[[4-9]]*)\n    if test \"$host_cpu\" != ia64 && test \"$aix_use_runtimelinking\" = no ; then\n      test \"$enable_shared\" = yes && enable_static=no\n    fi\n    ;;\n  esac\n  AC_MSG_RESULT([$enable_shared])\n\n  AC_MSG_CHECKING([whether to build static libraries])\n  # Make sure either enable_shared or enable_static is yes.\n  test \"$enable_shared\" = yes || enable_static=yes\n  AC_MSG_RESULT([$enable_static])\n\n  _LT_CONFIG($1)\nfi\nAC_LANG_POP\nCC=\"$lt_save_CC\"\n])# _LT_LANG_C_CONFIG\n\n\n# _LT_PROG_CXX\n# ------------\n# Since AC_PROG_CXX is broken, in that it returns g++ if there is no c++\n# compiler, we have our own version here.\nm4_defun([_LT_PROG_CXX],\n[\npushdef([AC_MSG_ERROR], [_lt_caught_CXX_error=yes])\nAC_PROG_CXX\nif test -n \"$CXX\" && ( test \"X$CXX\" != \"Xno\" &&\n    ( (test \"X$CXX\" = \"Xg++\" && `g++ -v >/dev/null 2>&1` ) ||\n    (test \"X$CXX\" != \"Xg++\"))) ; then\n  AC_PROG_CXXCPP\nelse\n  _lt_caught_CXX_error=yes\nfi\npopdef([AC_MSG_ERROR])\n])# _LT_PROG_CXX\n\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([_LT_PROG_CXX], [])\n\n\n# _LT_LANG_CXX_CONFIG([TAG])\n# --------------------------\n# Ensure that the configuration variables for a C++ compiler are suitably\n# defined.  These variables are subsequently used by _LT_CONFIG to write\n# the compiler configuration to `libtool'.\nm4_defun([_LT_LANG_CXX_CONFIG],\n[AC_REQUIRE([_LT_PROG_CXX])dnl\nm4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_DECL_EGREP])dnl\n\nAC_LANG_PUSH(C++)\n_LT_TAGVAR(archive_cmds_need_lc, $1)=no\n_LT_TAGVAR(allow_undefined_flag, $1)=\n_LT_TAGVAR(always_export_symbols, $1)=no\n_LT_TAGVAR(archive_expsym_cmds, $1)=\n_LT_TAGVAR(compiler_needs_object, $1)=no\n_LT_TAGVAR(export_dynamic_flag_spec, $1)=\n_LT_TAGVAR(hardcode_direct, $1)=no\n_LT_TAGVAR(hardcode_direct_absolute, $1)=no\n_LT_TAGVAR(hardcode_libdir_flag_spec, $1)=\n_LT_TAGVAR(hardcode_libdir_flag_spec_ld, $1)=\n_LT_TAGVAR(hardcode_libdir_separator, $1)=\n_LT_TAGVAR(hardcode_minus_L, $1)=no\n_LT_TAGVAR(hardcode_shlibpath_var, $1)=unsupported\n_LT_TAGVAR(hardcode_automatic, $1)=no\n_LT_TAGVAR(inherit_rpath, $1)=no\n_LT_TAGVAR(module_cmds, $1)=\n_LT_TAGVAR(module_expsym_cmds, $1)=\n_LT_TAGVAR(link_all_deplibs, $1)=unknown\n_LT_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds\n_LT_TAGVAR(no_undefined_flag, $1)=\n_LT_TAGVAR(whole_archive_flag_spec, $1)=\n_LT_TAGVAR(enable_shared_with_static_runtimes, $1)=no\n\n# Source file extension for C++ test sources.\nac_ext=cpp\n\n# Object file extension for compiled C++ test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# No sense in running all these tests if we already determined that\n# the CXX compiler isn't working.  Some variables (like enable_shared)\n# are currently assumed to apply to all compilers on this platform,\n# and will be corrupted by setting them based on a non-working compiler.\nif test \"$_lt_caught_CXX_error\" != yes; then\n  # Code to be used in simple compile tests\n  lt_simple_compile_test_code=\"int some_variable = 0;\"\n\n  # Code to be used in simple link tests\n  lt_simple_link_test_code='int main(int, char *[[]]) { return(0); }'\n\n  # ltmain only uses $CC for tagged configurations so make sure $CC is set.\n  _LT_TAG_COMPILER\n\n  # save warnings/boilerplate of simple test code\n  _LT_COMPILER_BOILERPLATE\n  _LT_LINKER_BOILERPLATE\n\n  # Allow CC to be a program name with arguments.\n  lt_save_CC=$CC\n  lt_save_LD=$LD\n  lt_save_GCC=$GCC\n  GCC=$GXX\n  lt_save_with_gnu_ld=$with_gnu_ld\n  lt_save_path_LD=$lt_cv_path_LD\n  if test -n \"${lt_cv_prog_gnu_ldcxx+set}\"; then\n    lt_cv_prog_gnu_ld=$lt_cv_prog_gnu_ldcxx\n  else\n    $as_unset lt_cv_prog_gnu_ld\n  fi\n  if test -n \"${lt_cv_path_LDCXX+set}\"; then\n    lt_cv_path_LD=$lt_cv_path_LDCXX\n  else\n    $as_unset lt_cv_path_LD\n  fi\n  test -z \"${LDCXX+set}\" || LD=$LDCXX\n  CC=${CXX-\"c++\"}\n  compiler=$CC\n  _LT_TAGVAR(compiler, $1)=$CC\n  _LT_CC_BASENAME([$compiler])\n\n  if test -n \"$compiler\"; then\n    # We don't want -fno-exception when compiling C++ code, so set the\n    # no_builtin_flag separately\n    if test \"$GXX\" = yes; then\n      _LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=' -fno-builtin'\n    else\n      _LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=\n    fi\n\n    if test \"$GXX\" = yes; then\n      # Set up default GNU C++ configuration\n\n      LT_PATH_LD\n\n      # Check if GNU C++ uses GNU ld as the underlying linker, since the\n      # archiving commands below assume that GNU ld is being used.\n      if test \"$with_gnu_ld\" = yes; then\n        _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname -o $lib'\n        _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'\n\n        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n        _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'\n\n        # If archive_cmds runs LD, not CC, wlarc should be empty\n        # XXX I think wlarc can be eliminated in ltcf-cxx, but I need to\n        #     investigate it a little bit more. (MM)\n        wlarc='${wl}'\n\n        # ancient GNU ld didn't support --whole-archive et. al.\n        if eval \"`$CC -print-prog-name=ld` --help 2>&1\" |\n\t  $GREP 'no-whole-archive' > /dev/null; then\n          _LT_TAGVAR(whole_archive_flag_spec, $1)=\"$wlarc\"'--whole-archive$convenience '\"$wlarc\"'--no-whole-archive'\n        else\n          _LT_TAGVAR(whole_archive_flag_spec, $1)=\n        fi\n      else\n        with_gnu_ld=no\n        wlarc=\n\n        # A generic and very simple default shared library creation\n        # command for GNU C++ for the case where it uses the native\n        # linker, instead of GNU ld.  If possible, this setting should\n        # overridden to take advantage of the native linker features on\n        # the platform it is being used on.\n        _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $lib'\n      fi\n\n      # Commands to make compiler produce verbose output that lists\n      # what \"hidden\" libraries, object files and flags are used when\n      # linking a shared library.\n      output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP \"\\-L\"'\n\n    else\n      GXX=no\n      with_gnu_ld=no\n      wlarc=\n    fi\n\n    # PORTME: fill in a description of your system's C++ link characteristics\n    AC_MSG_CHECKING([whether the $compiler linker ($LD) supports shared libraries])\n    _LT_TAGVAR(ld_shlibs, $1)=yes\n    case $host_os in\n      aix3*)\n        # FIXME: insert proper C++ library support\n        _LT_TAGVAR(ld_shlibs, $1)=no\n        ;;\n      aix[[4-9]]*)\n        if test \"$host_cpu\" = ia64; then\n          # On IA64, the linker does run time linking by default, so we don't\n          # have to do anything special.\n          aix_use_runtimelinking=no\n          exp_sym_flag='-Bexport'\n          no_entry_flag=\"\"\n        else\n          aix_use_runtimelinking=no\n\n          # Test if we are trying to use run time linking or normal\n          # AIX style linking. If -brtl is somewhere in LDFLAGS, we\n          # need to do runtime linking.\n          case $host_os in aix4.[[23]]|aix4.[[23]].*|aix[[5-9]]*)\n\t    for ld_flag in $LDFLAGS; do\n\t      case $ld_flag in\n\t      *-brtl*)\n\t        aix_use_runtimelinking=yes\n\t        break\n\t        ;;\n\t      esac\n\t    done\n\t    ;;\n          esac\n\n          exp_sym_flag='-bexport'\n          no_entry_flag='-bnoentry'\n        fi\n\n        # When large executables or shared objects are built, AIX ld can\n        # have problems creating the table of contents.  If linking a library\n        # or program results in \"error TOC overflow\" add -mminimal-toc to\n        # CXXFLAGS/CFLAGS for g++/gcc.  In the cases where that is not\n        # enough to fix the problem, add -Wl,-bbigtoc to LDFLAGS.\n\n        _LT_TAGVAR(archive_cmds, $1)=''\n        _LT_TAGVAR(hardcode_direct, $1)=yes\n        _LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n        _LT_TAGVAR(hardcode_libdir_separator, $1)=':'\n        _LT_TAGVAR(link_all_deplibs, $1)=yes\n        _LT_TAGVAR(file_list_spec, $1)='${wl}-f,'\n\n        if test \"$GXX\" = yes; then\n          case $host_os in aix4.[[012]]|aix4.[[012]].*)\n          # We only want to do this on AIX 4.2 and lower, the check\n          # below for broken collect2 doesn't work under 4.3+\n\t  collect2name=`${CC} -print-prog-name=collect2`\n\t  if test -f \"$collect2name\" &&\n\t     strings \"$collect2name\" | $GREP resolve_lib_name >/dev/null\n\t  then\n\t    # We have reworked collect2\n\t    :\n\t  else\n\t    # We have old collect2\n\t    _LT_TAGVAR(hardcode_direct, $1)=unsupported\n\t    # It fails to find uninstalled libraries when the uninstalled\n\t    # path is not listed in the libpath.  Setting hardcode_minus_L\n\t    # to unsupported forces relinking\n\t    _LT_TAGVAR(hardcode_minus_L, $1)=yes\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n\t    _LT_TAGVAR(hardcode_libdir_separator, $1)=\n\t  fi\n          esac\n          shared_flag='-shared'\n\t  if test \"$aix_use_runtimelinking\" = yes; then\n\t    shared_flag=\"$shared_flag \"'${wl}-G'\n\t  fi\n        else\n          # not using gcc\n          if test \"$host_cpu\" = ia64; then\n\t  # VisualAge C++, Version 5.5 for AIX 5L for IA-64, Beta 3 Release\n\t  # chokes on -Wl,-G. The following line is correct:\n\t  shared_flag='-G'\n          else\n\t    if test \"$aix_use_runtimelinking\" = yes; then\n\t      shared_flag='${wl}-G'\n\t    else\n\t      shared_flag='${wl}-bM:SRE'\n\t    fi\n          fi\n        fi\n\n        _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-bexpall'\n        # It seems that -bexpall does not export symbols beginning with\n        # underscore (_), so it is better to generate a list of symbols to\n\t# export.\n        _LT_TAGVAR(always_export_symbols, $1)=yes\n        if test \"$aix_use_runtimelinking\" = yes; then\n          # Warning - without using the other runtime loading flags (-brtl),\n          # -berok will link without error, but may produce a broken library.\n          _LT_TAGVAR(allow_undefined_flag, $1)='-berok'\n          # Determine the default libpath from the value encoded in an empty\n          # executable.\n          _LT_SYS_MODULE_PATH_AIX\n          _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-blibpath:$libdir:'\"$aix_libpath\"\n\n          _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -o $output_objdir/$soname $libobjs $deplibs '\"\\${wl}$no_entry_flag\"' $compiler_flags `if test \"x${allow_undefined_flag}\" != \"x\"; then $ECHO \"X${wl}${allow_undefined_flag}\" | $Xsed; else :; fi` '\"\\${wl}$exp_sym_flag:\\$export_symbols $shared_flag\"\n        else\n          if test \"$host_cpu\" = ia64; then\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-R $libdir:/usr/lib:/lib'\n\t    _LT_TAGVAR(allow_undefined_flag, $1)=\"-z nodefs\"\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)=\"\\$CC $shared_flag\"' -o $output_objdir/$soname $libobjs $deplibs '\"\\${wl}$no_entry_flag\"' $compiler_flags ${wl}${allow_undefined_flag} '\"\\${wl}$exp_sym_flag:\\$export_symbols\"\n          else\n\t    # Determine the default libpath from the value encoded in an\n\t    # empty executable.\n\t    _LT_SYS_MODULE_PATH_AIX\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-blibpath:$libdir:'\"$aix_libpath\"\n\t    # Warning - without using the other run time loading flags,\n\t    # -berok will link without error, but may produce a broken library.\n\t    _LT_TAGVAR(no_undefined_flag, $1)=' ${wl}-bernotok'\n\t    _LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-berok'\n\t    # Exported symbols can be pulled into shared objects from archives\n\t    _LT_TAGVAR(whole_archive_flag_spec, $1)='$convenience'\n\t    _LT_TAGVAR(archive_cmds_need_lc, $1)=yes\n\t    # This is similar to how AIX traditionally builds its shared\n\t    # libraries.\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)=\"\\$CC $shared_flag\"' -o $output_objdir/$soname $libobjs $deplibs ${wl}-bnoentry $compiler_flags ${wl}-bE:$export_symbols${allow_undefined_flag}~$AR $AR_FLAGS $output_objdir/$libname$release.a $output_objdir/$soname'\n          fi\n        fi\n        ;;\n\n      beos*)\n\tif $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then\n\t  _LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n\t  # Joseph Beckenbach <jrb3@best.com> says some releases of gcc\n\t  # support --undefined.  This deserves some investigation.  FIXME\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -nostart $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\telse\n\t  _LT_TAGVAR(ld_shlibs, $1)=no\n\tfi\n\t;;\n\n      chorus*)\n        case $cc_basename in\n          *)\n\t  # FIXME: insert proper C++ library support\n\t  _LT_TAGVAR(ld_shlibs, $1)=no\n\t  ;;\n        esac\n        ;;\n\n      cygwin* | mingw* | pw32* | cegcc*)\n        # _LT_TAGVAR(hardcode_libdir_flag_spec, $1) is actually meaningless,\n        # as there is no search path for DLLs.\n        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n        _LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n        _LT_TAGVAR(always_export_symbols, $1)=no\n        _LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes\n\n        if $LD --help 2>&1 | $GREP 'auto-import' > /dev/null; then\n          _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'\n          # If the export-symbols file already is a .def file (1st line\n          # is EXPORTS), use it as is; otherwise, prepend...\n          _LT_TAGVAR(archive_expsym_cmds, $1)='if test \"x`$SED 1q $export_symbols`\" = xEXPORTS; then\n\t    cp $export_symbols $output_objdir/$soname.def;\n          else\n\t    echo EXPORTS > $output_objdir/$soname.def;\n\t    cat $export_symbols >> $output_objdir/$soname.def;\n          fi~\n          $CC -shared -nostdlib $output_objdir/$soname.def $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $output_objdir/$soname ${wl}--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'\n        else\n          _LT_TAGVAR(ld_shlibs, $1)=no\n        fi\n        ;;\n      darwin* | rhapsody*)\n        _LT_DARWIN_LINKER_FEATURES($1)\n\t;;\n\n      dgux*)\n        case $cc_basename in\n          ec++*)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          ghcx*)\n\t    # Green Hills C++ Compiler\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          *)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n        esac\n        ;;\n\n      freebsd[[12]]*)\n        # C++ shared libraries reported to be fairly broken before\n\t# switch to ELF\n        _LT_TAGVAR(ld_shlibs, $1)=no\n        ;;\n\n      freebsd-elf*)\n        _LT_TAGVAR(archive_cmds_need_lc, $1)=no\n        ;;\n\n      freebsd* | dragonfly*)\n        # FreeBSD 3 and later use GNU C++ and GNU ld with standard ELF\n        # conventions\n        _LT_TAGVAR(ld_shlibs, $1)=yes\n        ;;\n\n      gnu*)\n        ;;\n\n      hpux9*)\n        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'\n        _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n        _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n        _LT_TAGVAR(hardcode_direct, $1)=yes\n        _LT_TAGVAR(hardcode_minus_L, $1)=yes # Not in the search PATH,\n\t\t\t\t             # but as the default\n\t\t\t\t             # location of the library.\n\n        case $cc_basename in\n          CC*)\n            # FIXME: insert proper C++ library support\n            _LT_TAGVAR(ld_shlibs, $1)=no\n            ;;\n          aCC*)\n            _LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/$soname~$CC -b ${wl}+b ${wl}$install_libdir -o $output_objdir/$soname $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'\n            # Commands to make compiler produce verbose output that lists\n            # what \"hidden\" libraries, object files and flags are used when\n            # linking a shared library.\n            #\n            # There doesn't appear to be a way to prevent this compiler from\n            # explicitly linking system object files so we need to strip them\n            # from the output so that they don't get included in the library\n            # dependencies.\n            output_verbose_link_cmd='templist=`($CC -b $CFLAGS -v conftest.$objext 2>&1) | $EGREP \"\\-L\"`; list=\"\"; for z in $templist; do case $z in conftest.$objext) list=\"$list $z\";; *.$objext);; *) list=\"$list $z\";;esac; done; $ECHO \"X$list\" | $Xsed'\n            ;;\n          *)\n            if test \"$GXX\" = yes; then\n              _LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/$soname~$CC -shared -nostdlib -fPIC ${wl}+b ${wl}$install_libdir -o $output_objdir/$soname $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~test $output_objdir/$soname = $lib || mv $output_objdir/$soname $lib'\n            else\n              # FIXME: insert proper C++ library support\n              _LT_TAGVAR(ld_shlibs, $1)=no\n            fi\n            ;;\n        esac\n        ;;\n\n      hpux10*|hpux11*)\n        if test $with_gnu_ld = no; then\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}+b ${wl}$libdir'\n\t  _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\n          case $host_cpu in\n            hppa*64*|ia64*)\n              ;;\n            *)\n\t      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n              ;;\n          esac\n        fi\n        case $host_cpu in\n          hppa*64*|ia64*)\n            _LT_TAGVAR(hardcode_direct, $1)=no\n            _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n            ;;\n          *)\n            _LT_TAGVAR(hardcode_direct, $1)=yes\n            _LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n            _LT_TAGVAR(hardcode_minus_L, $1)=yes # Not in the search PATH,\n\t\t\t\t\t         # but as the default\n\t\t\t\t\t         # location of the library.\n            ;;\n        esac\n\n        case $cc_basename in\n          CC*)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          aCC*)\n\t    case $host_cpu in\n\t      hppa*64*)\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t        ;;\n\t      ia64*)\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t        ;;\n\t      *)\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -b ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t        ;;\n\t    esac\n\t    # Commands to make compiler produce verbose output that lists\n\t    # what \"hidden\" libraries, object files and flags are used when\n\t    # linking a shared library.\n\t    #\n\t    # There doesn't appear to be a way to prevent this compiler from\n\t    # explicitly linking system object files so we need to strip them\n\t    # from the output so that they don't get included in the library\n\t    # dependencies.\n\t    output_verbose_link_cmd='templist=`($CC -b $CFLAGS -v conftest.$objext 2>&1) | $GREP \"\\-L\"`; list=\"\"; for z in $templist; do case $z in conftest.$objext) list=\"$list $z\";; *.$objext);; *) list=\"$list $z\";;esac; done; $ECHO \"X$list\" | $Xsed'\n\t    ;;\n          *)\n\t    if test \"$GXX\" = yes; then\n\t      if test $with_gnu_ld = no; then\n\t        case $host_cpu in\n\t          hppa*64*)\n\t            _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib -fPIC ${wl}+h ${wl}$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t            ;;\n\t          ia64*)\n\t            _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib -fPIC ${wl}+h ${wl}$soname ${wl}+nodefaultrpath -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t            ;;\n\t          *)\n\t            _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib -fPIC ${wl}+h ${wl}$soname ${wl}+b ${wl}$install_libdir -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t            ;;\n\t        esac\n\t      fi\n\t    else\n\t      # FIXME: insert proper C++ library support\n\t      _LT_TAGVAR(ld_shlibs, $1)=no\n\t    fi\n\t    ;;\n        esac\n        ;;\n\n      interix[[3-9]]*)\n\t_LT_TAGVAR(hardcode_direct, $1)=no\n\t_LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n\t_LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n\t# Hack: On Interix 3.x, we cannot compile PIC because of a broken gcc.\n\t# Instead, shared libraries are loaded at an image base (0x10000000 by\n\t# default) and relocated if they conflict, which is a slow very memory\n\t# consuming and fragmenting process.  To avoid this, we pick a random,\n\t# 256 KiB-aligned image base between 0x50000000 and 0x6FFC0000 at link\n\t# time.  Moving up from 0x10000000 also allows more sbrk(2) space.\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \\* 262144 + 1342177280` -o $lib'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='sed \"s,^,_,\" $export_symbols >$output_objdir/$soname.expsym~$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--retain-symbols-file,$output_objdir/$soname.expsym ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \\* 262144 + 1342177280` -o $lib'\n\t;;\n      irix5* | irix6*)\n        case $cc_basename in\n          CC*)\n\t    # SGI C++\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -shared -all -multigot $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -soname $soname `test -n \"$verstring\" && $ECHO \"X-set_version $verstring\" | $Xsed` -update_registry ${output_objdir}/so_locations -o $lib'\n\n\t    # Archives containing C++ object files must be created using\n\t    # \"CC -ar\", where \"CC\" is the IRIX C++ compiler.  This is\n\t    # necessary to make sure instantiated templates are included\n\t    # in the archive.\n\t    _LT_TAGVAR(old_archive_cmds, $1)='$CC -ar -WR,-u -o $oldlib $oldobjs'\n\t    ;;\n          *)\n\t    if test \"$GXX\" = yes; then\n\t      if test \"$with_gnu_ld\" = no; then\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname `test -n \"$verstring\" && $ECHO \"X${wl}-set_version ${wl}$verstring\" | $Xsed` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'\n\t      else\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname `test -n \"$verstring\" && $ECHO \"X${wl}-set_version ${wl}$verstring\" | $Xsed` -o $lib'\n\t      fi\n\t    fi\n\t    _LT_TAGVAR(link_all_deplibs, $1)=yes\n\t    ;;\n        esac\n        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n        _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n        _LT_TAGVAR(inherit_rpath, $1)=yes\n        ;;\n\n      linux* | k*bsd*-gnu)\n        case $cc_basename in\n          KCC*)\n\t    # Kuck and Associates, Inc. (KAI) C++ Compiler\n\n\t    # KCC will only create a shared library if the output file\n\t    # ends with \".so\" (or \".sl\" for HP-UX), so rename the library\n\t    # to its proper name (with version) after linking.\n\t    _LT_TAGVAR(archive_cmds, $1)='tempext=`echo $shared_ext | $SED -e '\\''s/\\([[^()0-9A-Za-z{}]]\\)/\\\\\\\\\\1/g'\\''`; templib=`echo $lib | $SED -e \"s/\\${tempext}\\..*/.so/\"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \\$templib; mv \\$templib $lib'\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='tempext=`echo $shared_ext | $SED -e '\\''s/\\([[^()0-9A-Za-z{}]]\\)/\\\\\\\\\\1/g'\\''`; templib=`echo $lib | $SED -e \"s/\\${tempext}\\..*/.so/\"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \\$templib ${wl}-retain-symbols-file,$export_symbols; mv \\$templib $lib'\n\t    # Commands to make compiler produce verbose output that lists\n\t    # what \"hidden\" libraries, object files and flags are used when\n\t    # linking a shared library.\n\t    #\n\t    # There doesn't appear to be a way to prevent this compiler from\n\t    # explicitly linking system object files so we need to strip them\n\t    # from the output so that they don't get included in the library\n\t    # dependencies.\n\t    output_verbose_link_cmd='templist=`$CC $CFLAGS -v conftest.$objext -o libconftest$shared_ext 2>&1 | $GREP \"ld\"`; rm -f libconftest$shared_ext; list=\"\"; for z in $templist; do case $z in conftest.$objext) list=\"$list $z\";; *.$objext);; *) list=\"$list $z\";;esac; done; $ECHO \"X$list\" | $Xsed'\n\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n\t    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'\n\n\t    # Archives containing C++ object files must be created using\n\t    # \"CC -Bstatic\", where \"CC\" is the KAI C++ compiler.\n\t    _LT_TAGVAR(old_archive_cmds, $1)='$CC -Bstatic -o $oldlib $oldobjs'\n\t    ;;\n\t  icpc* | ecpc* )\n\t    # Intel C++\n\t    with_gnu_ld=yes\n\t    # version 8.0 and above of icpc choke on multiply defined symbols\n\t    # if we add $predep_objects and $postdep_objects, however 7.1 and\n\t    # earlier do not add the objects themselves.\n\t    case `$CC -V 2>&1` in\n\t      *\"Version 7.\"*)\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\t\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'\n\t\t;;\n\t      *)  # Version 8.0 or newer\n\t        tmp_idyn=\n\t        case $host_cpu in\n\t\t  ia64*) tmp_idyn=' -i_dynamic';;\n\t\tesac\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared'\"$tmp_idyn\"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\t\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared'\"$tmp_idyn\"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'\n\t\t;;\n\t    esac\n\t    _LT_TAGVAR(archive_cmds_need_lc, $1)=no\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n\t    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'\n\t    _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive$convenience ${wl}--no-whole-archive'\n\t    ;;\n          pgCC* | pgcpp*)\n            # Portland Group C++ compiler\n\t    case `$CC -V` in\n\t    *pgCC\\ [[1-5]]* | *pgcpp\\ [[1-5]]*)\n\t      _LT_TAGVAR(prelink_cmds, $1)='tpldir=Template.dir~\n\t\trm -rf $tpldir~\n\t\t$CC --prelink_objects --instantiation_dir $tpldir $objs $libobjs $compile_deplibs~\n\t\tcompile_command=\"$compile_command `find $tpldir -name \\*.o | $NL2SP`\"'\n\t      _LT_TAGVAR(old_archive_cmds, $1)='tpldir=Template.dir~\n\t\trm -rf $tpldir~\n\t\t$CC --prelink_objects --instantiation_dir $tpldir $oldobjs$old_deplibs~\n\t\t$AR $AR_FLAGS $oldlib$oldobjs$old_deplibs `find $tpldir -name \\*.o | $NL2SP`~\n\t\t$RANLIB $oldlib'\n\t      _LT_TAGVAR(archive_cmds, $1)='tpldir=Template.dir~\n\t\trm -rf $tpldir~\n\t\t$CC --prelink_objects --instantiation_dir $tpldir $predep_objects $libobjs $deplibs $convenience $postdep_objects~\n\t\t$CC -shared $pic_flag $predep_objects $libobjs $deplibs `find $tpldir -name \\*.o | $NL2SP` $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname -o $lib'\n\t      _LT_TAGVAR(archive_expsym_cmds, $1)='tpldir=Template.dir~\n\t\trm -rf $tpldir~\n\t\t$CC --prelink_objects --instantiation_dir $tpldir $predep_objects $libobjs $deplibs $convenience $postdep_objects~\n\t\t$CC -shared $pic_flag $predep_objects $libobjs $deplibs `find $tpldir -name \\*.o | $NL2SP` $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname ${wl}-retain-symbols-file ${wl}$export_symbols -o $lib'\n\t      ;;\n\t    *) # Version 6 will use weak symbols\n\t      _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname -o $lib'\n\t      _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname ${wl}-retain-symbols-file ${wl}$export_symbols -o $lib'\n\t      ;;\n\t    esac\n\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}--rpath ${wl}$libdir'\n\t    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'\n\t    _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`for conv in $convenience\\\"\\\"; do test  -n \\\"$conv\\\" && new_convenience=\\\"$new_convenience,$conv\\\"; done; $ECHO \\\"$new_convenience\\\"` ${wl}--no-whole-archive'\n            ;;\n\t  cxx*)\n\t    # Compaq C++\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname  -o $lib ${wl}-retain-symbols-file $wl$export_symbols'\n\n\t    runpath_var=LD_RUN_PATH\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-rpath $libdir'\n\t    _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\n\t    # Commands to make compiler produce verbose output that lists\n\t    # what \"hidden\" libraries, object files and flags are used when\n\t    # linking a shared library.\n\t    #\n\t    # There doesn't appear to be a way to prevent this compiler from\n\t    # explicitly linking system object files so we need to strip them\n\t    # from the output so that they don't get included in the library\n\t    # dependencies.\n\t    output_verbose_link_cmd='templist=`$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP \"ld\"`; templist=`$ECHO \"X$templist\" | $Xsed -e \"s/\\(^.*ld.*\\)\\( .*ld .*$\\)/\\1/\"`; list=\"\"; for z in $templist; do case $z in conftest.$objext) list=\"$list $z\";; *.$objext);; *) list=\"$list $z\";;esac; done; $ECHO \"X$list\" | $Xsed'\n\t    ;;\n\t  xl*)\n\t    # IBM XL 8.0 on PPC, with GNU ld\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n\t    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -qmkshrobj $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname -o $lib'\n\t    if test \"x$supports_anon_versioning\" = xyes; then\n\t      _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $output_objdir/$libname.ver~\n\t\tcat $export_symbols | sed -e \"s/\\(.*\\)/\\1;/\" >> $output_objdir/$libname.ver~\n\t\techo \"local: *; };\" >> $output_objdir/$libname.ver~\n\t\t$CC -qmkshrobj $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-version-script ${wl}$output_objdir/$libname.ver -o $lib'\n\t    fi\n\t    ;;\n\t  *)\n\t    case `$CC -V 2>&1 | sed 5q` in\n\t    *Sun\\ C*)\n\t      # Sun C++ 5.9\n\t      _LT_TAGVAR(no_undefined_flag, $1)=' -zdefs'\n\t      _LT_TAGVAR(archive_cmds, $1)='$CC -G${allow_undefined_flag} -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t      _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G${allow_undefined_flag} -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-retain-symbols-file ${wl}$export_symbols'\n\t      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n\t      _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}--whole-archive`new_convenience=; for conv in $convenience\\\"\\\"; do test -z \\\"$conv\\\" || new_convenience=\\\"$new_convenience,$conv\\\"; done; $ECHO \\\"$new_convenience\\\"` ${wl}--no-whole-archive'\n\t      _LT_TAGVAR(compiler_needs_object, $1)=yes\n\n\t      # Not sure whether something based on\n\t      # $CC $CFLAGS -v conftest.$objext -o libconftest$shared_ext 2>&1\n\t      # would be better.\n\t      output_verbose_link_cmd='echo'\n\n\t      # Archives containing C++ object files must be created using\n\t      # \"CC -xar\", where \"CC\" is the Sun C++ compiler.  This is\n\t      # necessary to make sure instantiated templates are included\n\t      # in the archive.\n\t      _LT_TAGVAR(old_archive_cmds, $1)='$CC -xar -o $oldlib $oldobjs'\n\t      ;;\n\t    esac\n\t    ;;\n\tesac\n\t;;\n\n      lynxos*)\n        # FIXME: insert proper C++ library support\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n\t;;\n\n      m88k*)\n        # FIXME: insert proper C++ library support\n        _LT_TAGVAR(ld_shlibs, $1)=no\n\t;;\n\n      mvs*)\n        case $cc_basename in\n          cxx*)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n\t  *)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n\tesac\n\t;;\n\n      netbsd*)\n        if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then\n\t  _LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable  -o $lib $predep_objects $libobjs $deplibs $postdep_objects $linker_flags'\n\t  wlarc=\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n\t  _LT_TAGVAR(hardcode_direct, $1)=yes\n\t  _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\tfi\n\t# Workaround some broken pre-1.5 toolchains\n\toutput_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP conftest.$objext | $SED -e \"s:-lgcc -lc -lgcc::\"'\n\t;;\n\n      *nto* | *qnx*)\n        _LT_TAGVAR(ld_shlibs, $1)=yes\n\t;;\n\n      openbsd2*)\n        # C++ shared libraries are fairly broken\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n\t;;\n\n      openbsd*)\n\tif test -f /usr/libexec/ld.so; then\n\t  _LT_TAGVAR(hardcode_direct, $1)=yes\n\t  _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\t  _LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $lib'\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n\t  if test -z \"`echo __ELF__ | $CC -E - | grep __ELF__`\" || test \"$host_os-$host_cpu\" = \"openbsd2.8-powerpc\"; then\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-retain-symbols-file,$export_symbols -o $lib'\n\t    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'\n\t    _LT_TAGVAR(whole_archive_flag_spec, $1)=\"$wlarc\"'--whole-archive$convenience '\"$wlarc\"'--no-whole-archive'\n\t  fi\n\t  output_verbose_link_cmd=echo\n\telse\n\t  _LT_TAGVAR(ld_shlibs, $1)=no\n\tfi\n\t;;\n\n      osf3* | osf4* | osf5*)\n        case $cc_basename in\n          KCC*)\n\t    # Kuck and Associates, Inc. (KAI) C++ Compiler\n\n\t    # KCC will only create a shared library if the output file\n\t    # ends with \".so\" (or \".sl\" for HP-UX), so rename the library\n\t    # to its proper name (with version) after linking.\n\t    _LT_TAGVAR(archive_cmds, $1)='tempext=`echo $shared_ext | $SED -e '\\''s/\\([[^()0-9A-Za-z{}]]\\)/\\\\\\\\\\1/g'\\''`; templib=`echo \"$lib\" | $SED -e \"s/\\${tempext}\\..*/.so/\"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \\$templib; mv \\$templib $lib'\n\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath,$libdir'\n\t    _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\n\t    # Archives containing C++ object files must be created using\n\t    # the KAI C++ compiler.\n\t    case $host in\n\t      osf3*) _LT_TAGVAR(old_archive_cmds, $1)='$CC -Bstatic -o $oldlib $oldobjs' ;;\n\t      *) _LT_TAGVAR(old_archive_cmds, $1)='$CC -o $oldlib $oldobjs' ;;\n\t    esac\n\t    ;;\n          RCC*)\n\t    # Rational C++ 2.4.1\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          cxx*)\n\t    case $host in\n\t      osf3*)\n\t        _LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-expect_unresolved ${wl}\\*'\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $soname `test -n \"$verstring\" && $ECHO \"X${wl}-set_version $verstring\" | $Xsed` -update_registry ${output_objdir}/so_locations -o $lib'\n\t        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n\t\t;;\n\t      *)\n\t        _LT_TAGVAR(allow_undefined_flag, $1)=' -expect_unresolved \\*'\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -msym -soname $soname `test -n \"$verstring\" && $ECHO \"X-set_version $verstring\" | $Xsed` -update_registry ${output_objdir}/so_locations -o $lib'\n\t        _LT_TAGVAR(archive_expsym_cmds, $1)='for i in `cat $export_symbols`; do printf \"%s %s\\\\n\" -exported_symbol \"\\$i\" >> $lib.exp; done~\n\t          echo \"-hidden\">> $lib.exp~\n\t          $CC -shared$allow_undefined_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -msym -soname $soname ${wl}-input ${wl}$lib.exp  `test -n \"$verstring\" && $ECHO \"X-set_version $verstring\" | $Xsed` -update_registry ${output_objdir}/so_locations -o $lib~\n\t          $RM $lib.exp'\n\t        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-rpath $libdir'\n\t\t;;\n\t    esac\n\n\t    _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\n\t    # Commands to make compiler produce verbose output that lists\n\t    # what \"hidden\" libraries, object files and flags are used when\n\t    # linking a shared library.\n\t    #\n\t    # There doesn't appear to be a way to prevent this compiler from\n\t    # explicitly linking system object files so we need to strip them\n\t    # from the output so that they don't get included in the library\n\t    # dependencies.\n\t    output_verbose_link_cmd='templist=`$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP \"ld\" | $GREP -v \"ld:\"`; templist=`$ECHO \"X$templist\" | $Xsed -e \"s/\\(^.*ld.*\\)\\( .*ld.*$\\)/\\1/\"`; list=\"\"; for z in $templist; do case $z in conftest.$objext) list=\"$list $z\";; *.$objext);; *) list=\"$list $z\";;esac; done; $ECHO \"X$list\" | $Xsed'\n\t    ;;\n\t  *)\n\t    if test \"$GXX\" = yes && test \"$with_gnu_ld\" = no; then\n\t      _LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-expect_unresolved ${wl}\\*'\n\t      case $host in\n\t        osf3*)\n\t          _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib ${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname `test -n \"$verstring\" && $ECHO \"X${wl}-set_version ${wl}$verstring\" | $Xsed` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'\n\t\t  ;;\n\t        *)\n\t          _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib ${allow_undefined_flag} $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-msym ${wl}-soname ${wl}$soname `test -n \"$verstring\" && $ECHO \"${wl}-set_version ${wl}$verstring\" | $Xsed` ${wl}-update_registry ${wl}${output_objdir}/so_locations -o $lib'\n\t\t  ;;\n\t      esac\n\n\t      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-rpath ${wl}$libdir'\n\t      _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\n\t      # Commands to make compiler produce verbose output that lists\n\t      # what \"hidden\" libraries, object files and flags are used when\n\t      # linking a shared library.\n\t      output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP \"\\-L\"'\n\n\t    else\n\t      # FIXME: insert proper C++ library support\n\t      _LT_TAGVAR(ld_shlibs, $1)=no\n\t    fi\n\t    ;;\n        esac\n        ;;\n\n      psos*)\n        # FIXME: insert proper C++ library support\n        _LT_TAGVAR(ld_shlibs, $1)=no\n        ;;\n\n      sunos4*)\n        case $cc_basename in\n          CC*)\n\t    # Sun C++ 4.x\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          lcc*)\n\t    # Lucid\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          *)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n        esac\n        ;;\n\n      solaris*)\n        case $cc_basename in\n          CC*)\n\t    # Sun C++ 4.2, 5.x and Centerline C++\n            _LT_TAGVAR(archive_cmds_need_lc,$1)=yes\n\t    _LT_TAGVAR(no_undefined_flag, $1)=' -zdefs'\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -G${allow_undefined_flag}  -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $lib.exp~cat $export_symbols | $SED -e \"s/\\(.*\\)/\\1;/\" >> $lib.exp~echo \"local: *; };\" >> $lib.exp~\n\t      $CC -G${allow_undefined_flag} ${wl}-M ${wl}$lib.exp -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$RM $lib.exp'\n\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n\t    _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\t    case $host_os in\n\t      solaris2.[[0-5]] | solaris2.[[0-5]].*) ;;\n\t      *)\n\t\t# The compiler driver will combine and reorder linker options,\n\t\t# but understands `-z linker_flag'.\n\t        # Supported since Solaris 2.6 (maybe 2.5.1?)\n\t\t_LT_TAGVAR(whole_archive_flag_spec, $1)='-z allextract$convenience -z defaultextract'\n\t        ;;\n\t    esac\n\t    _LT_TAGVAR(link_all_deplibs, $1)=yes\n\n\t    output_verbose_link_cmd='echo'\n\n\t    # Archives containing C++ object files must be created using\n\t    # \"CC -xar\", where \"CC\" is the Sun C++ compiler.  This is\n\t    # necessary to make sure instantiated templates are included\n\t    # in the archive.\n\t    _LT_TAGVAR(old_archive_cmds, $1)='$CC -xar -o $oldlib $oldobjs'\n\t    ;;\n          gcx*)\n\t    # Green Hills C++ Compiler\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-h $wl$soname -o $lib'\n\n\t    # The C++ compiler must be used to create the archive.\n\t    _LT_TAGVAR(old_archive_cmds, $1)='$CC $LDFLAGS -archive -o $oldlib $oldobjs'\n\t    ;;\n          *)\n\t    # GNU C++ compiler with Solaris linker\n\t    if test \"$GXX\" = yes && test \"$with_gnu_ld\" = no; then\n\t      _LT_TAGVAR(no_undefined_flag, $1)=' ${wl}-z ${wl}defs'\n\t      if $CC --version | $GREP -v '^2\\.7' > /dev/null; then\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $LDFLAGS $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-h $wl$soname -o $lib'\n\t        _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $lib.exp~cat $export_symbols | $SED -e \"s/\\(.*\\)/\\1;/\" >> $lib.exp~echo \"local: *; };\" >> $lib.exp~\n\t\t  $CC -shared -nostdlib ${wl}-M $wl$lib.exp -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$RM $lib.exp'\n\n\t        # Commands to make compiler produce verbose output that lists\n\t        # what \"hidden\" libraries, object files and flags are used when\n\t        # linking a shared library.\n\t        output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP \"\\-L\"'\n\t      else\n\t        # g++ 2.7 appears to require `-G' NOT `-shared' on this\n\t        # platform.\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -G -nostdlib $LDFLAGS $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-h $wl$soname -o $lib'\n\t        _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $lib.exp~cat $export_symbols | $SED -e \"s/\\(.*\\)/\\1;/\" >> $lib.exp~echo \"local: *; };\" >> $lib.exp~\n\t\t  $CC -G -nostdlib ${wl}-M $wl$lib.exp -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$RM $lib.exp'\n\n\t        # Commands to make compiler produce verbose output that lists\n\t        # what \"hidden\" libraries, object files and flags are used when\n\t        # linking a shared library.\n\t        output_verbose_link_cmd='$CC -G $CFLAGS -v conftest.$objext 2>&1 | $GREP \"\\-L\"'\n\t      fi\n\n\t      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-R $wl$libdir'\n\t      case $host_os in\n\t\tsolaris2.[[0-5]] | solaris2.[[0-5]].*) ;;\n\t\t*)\n\t\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}-z ${wl}allextract$convenience ${wl}-z ${wl}defaultextract'\n\t\t  ;;\n\t      esac\n\t    fi\n\t    ;;\n        esac\n        ;;\n\n    sysv4*uw2* | sysv5OpenUNIX* | sysv5UnixWare7.[[01]].[[10]]* | unixware7* | sco3.2v5.0.[[024]]*)\n      _LT_TAGVAR(no_undefined_flag, $1)='${wl}-z,text'\n      _LT_TAGVAR(archive_cmds_need_lc, $1)=no\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      runpath_var='LD_RUN_PATH'\n\n      case $cc_basename in\n        CC*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\t*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n      esac\n      ;;\n\n      sysv5* | sco3.2v5* | sco5v6*)\n\t# Note: We can NOT use -z defs as we might desire, because we do not\n\t# link with -lc, and that would cause any symbols used from libc to\n\t# always be unresolved, which means just about no library would\n\t# ever link correctly.  If we're not using GNU ld we use -z text\n\t# though, which does catch some bad symbols but isn't as heavy-handed\n\t# as -z defs.\n\t_LT_TAGVAR(no_undefined_flag, $1)='${wl}-z,text'\n\t_LT_TAGVAR(allow_undefined_flag, $1)='${wl}-z,nodefs'\n\t_LT_TAGVAR(archive_cmds_need_lc, $1)=no\n\t_LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-R,$libdir'\n\t_LT_TAGVAR(hardcode_libdir_separator, $1)=':'\n\t_LT_TAGVAR(link_all_deplibs, $1)=yes\n\t_LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-Bexport'\n\trunpath_var='LD_RUN_PATH'\n\n\tcase $cc_basename in\n          CC*)\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -G ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t    ;;\n\t  *)\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -shared ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t    ;;\n\tesac\n      ;;\n\n      tandem*)\n        case $cc_basename in\n          NCC*)\n\t    # NonStop-UX NCC 3.20\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          *)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n        esac\n        ;;\n\n      vxworks*)\n        # FIXME: insert proper C++ library support\n        _LT_TAGVAR(ld_shlibs, $1)=no\n        ;;\n\n      *)\n        # FIXME: insert proper C++ library support\n        _LT_TAGVAR(ld_shlibs, $1)=no\n        ;;\n    esac\n\n    AC_MSG_RESULT([$_LT_TAGVAR(ld_shlibs, $1)])\n    test \"$_LT_TAGVAR(ld_shlibs, $1)\" = no && can_build_shared=no\n\n    _LT_TAGVAR(GCC, $1)=\"$GXX\"\n    _LT_TAGVAR(LD, $1)=\"$LD\"\n\n    ## CAVEAT EMPTOR:\n    ## There is no encapsulation within the following macros, do not change\n    ## the running order or otherwise move them around unless you know exactly\n    ## what you are doing...\n    _LT_SYS_HIDDEN_LIBDEPS($1)\n    _LT_COMPILER_PIC($1)\n    _LT_COMPILER_C_O($1)\n    _LT_COMPILER_FILE_LOCKS($1)\n    _LT_LINKER_SHLIBS($1)\n    _LT_SYS_DYNAMIC_LINKER($1)\n    _LT_LINKER_HARDCODE_LIBPATH($1)\n\n    _LT_CONFIG($1)\n  fi # test -n \"$compiler\"\n\n  CC=$lt_save_CC\n  LDCXX=$LD\n  LD=$lt_save_LD\n  GCC=$lt_save_GCC\n  with_gnu_ld=$lt_save_with_gnu_ld\n  lt_cv_path_LDCXX=$lt_cv_path_LD\n  lt_cv_path_LD=$lt_save_path_LD\n  lt_cv_prog_gnu_ldcxx=$lt_cv_prog_gnu_ld\n  lt_cv_prog_gnu_ld=$lt_save_with_gnu_ld\nfi # test \"$_lt_caught_CXX_error\" != yes\n\nAC_LANG_POP\n])# _LT_LANG_CXX_CONFIG\n\n\n# _LT_SYS_HIDDEN_LIBDEPS([TAGNAME])\n# ---------------------------------\n# Figure out \"hidden\" library dependencies from verbose\n# compiler output when linking a shared library.\n# Parse the compiler output and extract the necessary\n# objects, libraries and library flags.\nm4_defun([_LT_SYS_HIDDEN_LIBDEPS],\n[m4_require([_LT_FILEUTILS_DEFAULTS])dnl\n# Dependencies to place before and after the object being linked:\n_LT_TAGVAR(predep_objects, $1)=\n_LT_TAGVAR(postdep_objects, $1)=\n_LT_TAGVAR(predeps, $1)=\n_LT_TAGVAR(postdeps, $1)=\n_LT_TAGVAR(compiler_lib_search_path, $1)=\n\ndnl we can't use the lt_simple_compile_test_code here,\ndnl because it contains code intended for an executable,\ndnl not a library.  It's possible we should let each\ndnl tag define a new lt_????_link_test_code variable,\ndnl but it's only used here...\nm4_if([$1], [], [cat > conftest.$ac_ext <<_LT_EOF\nint a;\nvoid foo (void) { a = 0; }\n_LT_EOF\n], [$1], [CXX], [cat > conftest.$ac_ext <<_LT_EOF\nclass Foo\n{\npublic:\n  Foo (void) { a = 0; }\nprivate:\n  int a;\n};\n_LT_EOF\n], [$1], [F77], [cat > conftest.$ac_ext <<_LT_EOF\n      subroutine foo\n      implicit none\n      integer*4 a\n      a=0\n      return\n      end\n_LT_EOF\n], [$1], [FC], [cat > conftest.$ac_ext <<_LT_EOF\n      subroutine foo\n      implicit none\n      integer a\n      a=0\n      return\n      end\n_LT_EOF\n], [$1], [GCJ], [cat > conftest.$ac_ext <<_LT_EOF\npublic class foo {\n  private int a;\n  public void bar (void) {\n    a = 0;\n  }\n};\n_LT_EOF\n])\ndnl Parse the compiler output and extract the necessary\ndnl objects, libraries and library flags.\nif AC_TRY_EVAL(ac_compile); then\n  # Parse the compiler output and extract the necessary\n  # objects, libraries and library flags.\n\n  # Sentinel used to keep track of whether or not we are before\n  # the conftest object file.\n  pre_test_object_deps_done=no\n\n  for p in `eval \"$output_verbose_link_cmd\"`; do\n    case $p in\n\n    -L* | -R* | -l*)\n       # Some compilers place space between \"-{L,R}\" and the path.\n       # Remove the space.\n       if test $p = \"-L\" ||\n          test $p = \"-R\"; then\n\t prev=$p\n\t continue\n       else\n\t prev=\n       fi\n\n       if test \"$pre_test_object_deps_done\" = no; then\n\t case $p in\n\t -L* | -R*)\n\t   # Internal compiler library paths should come after those\n\t   # provided the user.  The postdeps already come after the\n\t   # user supplied libs so there is no need to process them.\n\t   if test -z \"$_LT_TAGVAR(compiler_lib_search_path, $1)\"; then\n\t     _LT_TAGVAR(compiler_lib_search_path, $1)=\"${prev}${p}\"\n\t   else\n\t     _LT_TAGVAR(compiler_lib_search_path, $1)=\"${_LT_TAGVAR(compiler_lib_search_path, $1)} ${prev}${p}\"\n\t   fi\n\t   ;;\n\t # The \"-l\" case would never come before the object being\n\t # linked, so don't bother handling this case.\n\t esac\n       else\n\t if test -z \"$_LT_TAGVAR(postdeps, $1)\"; then\n\t   _LT_TAGVAR(postdeps, $1)=\"${prev}${p}\"\n\t else\n\t   _LT_TAGVAR(postdeps, $1)=\"${_LT_TAGVAR(postdeps, $1)} ${prev}${p}\"\n\t fi\n       fi\n       ;;\n\n    *.$objext)\n       # This assumes that the test object file only shows up\n       # once in the compiler output.\n       if test \"$p\" = \"conftest.$objext\"; then\n\t pre_test_object_deps_done=yes\n\t continue\n       fi\n\n       if test \"$pre_test_object_deps_done\" = no; then\n\t if test -z \"$_LT_TAGVAR(predep_objects, $1)\"; then\n\t   _LT_TAGVAR(predep_objects, $1)=\"$p\"\n\t else\n\t   _LT_TAGVAR(predep_objects, $1)=\"$_LT_TAGVAR(predep_objects, $1) $p\"\n\t fi\n       else\n\t if test -z \"$_LT_TAGVAR(postdep_objects, $1)\"; then\n\t   _LT_TAGVAR(postdep_objects, $1)=\"$p\"\n\t else\n\t   _LT_TAGVAR(postdep_objects, $1)=\"$_LT_TAGVAR(postdep_objects, $1) $p\"\n\t fi\n       fi\n       ;;\n\n    *) ;; # Ignore the rest.\n\n    esac\n  done\n\n  # Clean up.\n  rm -f a.out a.exe\nelse\n  echo \"libtool.m4: error: problem compiling $1 test program\"\nfi\n\n$RM -f confest.$objext\n\n# PORTME: override above test on systems where it is broken\nm4_if([$1], [CXX],\n[case $host_os in\ninterix[[3-9]]*)\n  # Interix 3.5 installs completely hosed .la files for C++, so rather than\n  # hack all around it, let's just trust \"g++\" to DTRT.\n  _LT_TAGVAR(predep_objects,$1)=\n  _LT_TAGVAR(postdep_objects,$1)=\n  _LT_TAGVAR(postdeps,$1)=\n  ;;\n\nlinux*)\n  case `$CC -V 2>&1 | sed 5q` in\n  *Sun\\ C*)\n    # Sun C++ 5.9\n\n    # The more standards-conforming stlport4 library is\n    # incompatible with the Cstd library. Avoid specifying\n    # it if it's in CXXFLAGS. Ignore libCrun as\n    # -library=stlport4 depends on it.\n    case \" $CXX $CXXFLAGS \" in\n    *\" -library=stlport4 \"*)\n      solaris_use_stlport4=yes\n      ;;\n    esac\n\n    if test \"$solaris_use_stlport4\" != yes; then\n      _LT_TAGVAR(postdeps,$1)='-library=Cstd -library=Crun'\n    fi\n    ;;\n  esac\n  ;;\n\nsolaris*)\n  case $cc_basename in\n  CC*)\n    # The more standards-conforming stlport4 library is\n    # incompatible with the Cstd library. Avoid specifying\n    # it if it's in CXXFLAGS. Ignore libCrun as\n    # -library=stlport4 depends on it.\n    case \" $CXX $CXXFLAGS \" in\n    *\" -library=stlport4 \"*)\n      solaris_use_stlport4=yes\n      ;;\n    esac\n\n    # Adding this requires a known-good setup of shared libraries for\n    # Sun compiler versions before 5.6, else PIC objects from an old\n    # archive will be linked into the output, leading to subtle bugs.\n    if test \"$solaris_use_stlport4\" != yes; then\n      _LT_TAGVAR(postdeps,$1)='-library=Cstd -library=Crun'\n    fi\n    ;;\n  esac\n  ;;\nesac\n])\n\ncase \" $_LT_TAGVAR(postdeps, $1) \" in\n*\" -lc \"*) _LT_TAGVAR(archive_cmds_need_lc, $1)=no ;;\nesac\n _LT_TAGVAR(compiler_lib_search_dirs, $1)=\nif test -n \"${_LT_TAGVAR(compiler_lib_search_path, $1)}\"; then\n _LT_TAGVAR(compiler_lib_search_dirs, $1)=`echo \" ${_LT_TAGVAR(compiler_lib_search_path, $1)}\" | ${SED} -e 's! -L! !g' -e 's!^ !!'`\nfi\n_LT_TAGDECL([], [compiler_lib_search_dirs], [1],\n    [The directories searched by this compiler when creating a shared library])\n_LT_TAGDECL([], [predep_objects], [1],\n    [Dependencies to place before and after the objects being linked to\n    create a shared library])\n_LT_TAGDECL([], [postdep_objects], [1])\n_LT_TAGDECL([], [predeps], [1])\n_LT_TAGDECL([], [postdeps], [1])\n_LT_TAGDECL([], [compiler_lib_search_path], [1],\n    [The library search path used internally by the compiler when linking\n    a shared library])\n])# _LT_SYS_HIDDEN_LIBDEPS\n\n\n# _LT_PROG_F77\n# ------------\n# Since AC_PROG_F77 is broken, in that it returns the empty string\n# if there is no fortran compiler, we have our own version here.\nm4_defun([_LT_PROG_F77],\n[\npushdef([AC_MSG_ERROR], [_lt_disable_F77=yes])\nAC_PROG_F77\nif test -z \"$F77\" || test \"X$F77\" = \"Xno\"; then\n  _lt_disable_F77=yes\nfi\npopdef([AC_MSG_ERROR])\n])# _LT_PROG_F77\n\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([_LT_PROG_F77], [])\n\n\n# _LT_LANG_F77_CONFIG([TAG])\n# --------------------------\n# Ensure that the configuration variables for a Fortran 77 compiler are\n# suitably defined.  These variables are subsequently used by _LT_CONFIG\n# to write the compiler configuration to `libtool'.\nm4_defun([_LT_LANG_F77_CONFIG],\n[AC_REQUIRE([_LT_PROG_F77])dnl\nAC_LANG_PUSH(Fortran 77)\n\n_LT_TAGVAR(archive_cmds_need_lc, $1)=no\n_LT_TAGVAR(allow_undefined_flag, $1)=\n_LT_TAGVAR(always_export_symbols, $1)=no\n_LT_TAGVAR(archive_expsym_cmds, $1)=\n_LT_TAGVAR(export_dynamic_flag_spec, $1)=\n_LT_TAGVAR(hardcode_direct, $1)=no\n_LT_TAGVAR(hardcode_direct_absolute, $1)=no\n_LT_TAGVAR(hardcode_libdir_flag_spec, $1)=\n_LT_TAGVAR(hardcode_libdir_flag_spec_ld, $1)=\n_LT_TAGVAR(hardcode_libdir_separator, $1)=\n_LT_TAGVAR(hardcode_minus_L, $1)=no\n_LT_TAGVAR(hardcode_automatic, $1)=no\n_LT_TAGVAR(inherit_rpath, $1)=no\n_LT_TAGVAR(module_cmds, $1)=\n_LT_TAGVAR(module_expsym_cmds, $1)=\n_LT_TAGVAR(link_all_deplibs, $1)=unknown\n_LT_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds\n_LT_TAGVAR(no_undefined_flag, $1)=\n_LT_TAGVAR(whole_archive_flag_spec, $1)=\n_LT_TAGVAR(enable_shared_with_static_runtimes, $1)=no\n\n# Source file extension for f77 test sources.\nac_ext=f\n\n# Object file extension for compiled f77 test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# No sense in running all these tests if we already determined that\n# the F77 compiler isn't working.  Some variables (like enable_shared)\n# are currently assumed to apply to all compilers on this platform,\n# and will be corrupted by setting them based on a non-working compiler.\nif test \"$_lt_disable_F77\" != yes; then\n  # Code to be used in simple compile tests\n  lt_simple_compile_test_code=\"\\\n      subroutine t\n      return\n      end\n\"\n\n  # Code to be used in simple link tests\n  lt_simple_link_test_code=\"\\\n      program t\n      end\n\"\n\n  # ltmain only uses $CC for tagged configurations so make sure $CC is set.\n  _LT_TAG_COMPILER\n\n  # save warnings/boilerplate of simple test code\n  _LT_COMPILER_BOILERPLATE\n  _LT_LINKER_BOILERPLATE\n\n  # Allow CC to be a program name with arguments.\n  lt_save_CC=\"$CC\"\n  lt_save_GCC=$GCC\n  CC=${F77-\"f77\"}\n  compiler=$CC\n  _LT_TAGVAR(compiler, $1)=$CC\n  _LT_CC_BASENAME([$compiler])\n  GCC=$G77\n  if test -n \"$compiler\"; then\n    AC_MSG_CHECKING([if libtool supports shared libraries])\n    AC_MSG_RESULT([$can_build_shared])\n\n    AC_MSG_CHECKING([whether to build shared libraries])\n    test \"$can_build_shared\" = \"no\" && enable_shared=no\n\n    # On AIX, shared libraries and static libraries use the same namespace, and\n    # are all built from PIC.\n    case $host_os in\n      aix3*)\n        test \"$enable_shared\" = yes && enable_static=no\n        if test -n \"$RANLIB\"; then\n          archive_cmds=\"$archive_cmds~\\$RANLIB \\$lib\"\n          postinstall_cmds='$RANLIB $lib'\n        fi\n        ;;\n      aix[[4-9]]*)\n\tif test \"$host_cpu\" != ia64 && test \"$aix_use_runtimelinking\" = no ; then\n\t  test \"$enable_shared\" = yes && enable_static=no\n\tfi\n        ;;\n    esac\n    AC_MSG_RESULT([$enable_shared])\n\n    AC_MSG_CHECKING([whether to build static libraries])\n    # Make sure either enable_shared or enable_static is yes.\n    test \"$enable_shared\" = yes || enable_static=yes\n    AC_MSG_RESULT([$enable_static])\n\n    _LT_TAGVAR(GCC, $1)=\"$G77\"\n    _LT_TAGVAR(LD, $1)=\"$LD\"\n\n    ## CAVEAT EMPTOR:\n    ## There is no encapsulation within the following macros, do not change\n    ## the running order or otherwise move them around unless you know exactly\n    ## what you are doing...\n    _LT_COMPILER_PIC($1)\n    _LT_COMPILER_C_O($1)\n    _LT_COMPILER_FILE_LOCKS($1)\n    _LT_LINKER_SHLIBS($1)\n    _LT_SYS_DYNAMIC_LINKER($1)\n    _LT_LINKER_HARDCODE_LIBPATH($1)\n\n    _LT_CONFIG($1)\n  fi # test -n \"$compiler\"\n\n  GCC=$lt_save_GCC\n  CC=\"$lt_save_CC\"\nfi # test \"$_lt_disable_F77\" != yes\n\nAC_LANG_POP\n])# _LT_LANG_F77_CONFIG\n\n\n# _LT_PROG_FC\n# -----------\n# Since AC_PROG_FC is broken, in that it returns the empty string\n# if there is no fortran compiler, we have our own version here.\nm4_defun([_LT_PROG_FC],\n[\npushdef([AC_MSG_ERROR], [_lt_disable_FC=yes])\nAC_PROG_FC\nif test -z \"$FC\" || test \"X$FC\" = \"Xno\"; then\n  _lt_disable_FC=yes\nfi\npopdef([AC_MSG_ERROR])\n])# _LT_PROG_FC\n\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([_LT_PROG_FC], [])\n\n\n# _LT_LANG_FC_CONFIG([TAG])\n# -------------------------\n# Ensure that the configuration variables for a Fortran compiler are\n# suitably defined.  These variables are subsequently used by _LT_CONFIG\n# to write the compiler configuration to `libtool'.\nm4_defun([_LT_LANG_FC_CONFIG],\n[AC_REQUIRE([_LT_PROG_FC])dnl\nAC_LANG_PUSH(Fortran)\n\n_LT_TAGVAR(archive_cmds_need_lc, $1)=no\n_LT_TAGVAR(allow_undefined_flag, $1)=\n_LT_TAGVAR(always_export_symbols, $1)=no\n_LT_TAGVAR(archive_expsym_cmds, $1)=\n_LT_TAGVAR(export_dynamic_flag_spec, $1)=\n_LT_TAGVAR(hardcode_direct, $1)=no\n_LT_TAGVAR(hardcode_direct_absolute, $1)=no\n_LT_TAGVAR(hardcode_libdir_flag_spec, $1)=\n_LT_TAGVAR(hardcode_libdir_flag_spec_ld, $1)=\n_LT_TAGVAR(hardcode_libdir_separator, $1)=\n_LT_TAGVAR(hardcode_minus_L, $1)=no\n_LT_TAGVAR(hardcode_automatic, $1)=no\n_LT_TAGVAR(inherit_rpath, $1)=no\n_LT_TAGVAR(module_cmds, $1)=\n_LT_TAGVAR(module_expsym_cmds, $1)=\n_LT_TAGVAR(link_all_deplibs, $1)=unknown\n_LT_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds\n_LT_TAGVAR(no_undefined_flag, $1)=\n_LT_TAGVAR(whole_archive_flag_spec, $1)=\n_LT_TAGVAR(enable_shared_with_static_runtimes, $1)=no\n\n# Source file extension for fc test sources.\nac_ext=${ac_fc_srcext-f}\n\n# Object file extension for compiled fc test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# No sense in running all these tests if we already determined that\n# the FC compiler isn't working.  Some variables (like enable_shared)\n# are currently assumed to apply to all compilers on this platform,\n# and will be corrupted by setting them based on a non-working compiler.\nif test \"$_lt_disable_FC\" != yes; then\n  # Code to be used in simple compile tests\n  lt_simple_compile_test_code=\"\\\n      subroutine t\n      return\n      end\n\"\n\n  # Code to be used in simple link tests\n  lt_simple_link_test_code=\"\\\n      program t\n      end\n\"\n\n  # ltmain only uses $CC for tagged configurations so make sure $CC is set.\n  _LT_TAG_COMPILER\n\n  # save warnings/boilerplate of simple test code\n  _LT_COMPILER_BOILERPLATE\n  _LT_LINKER_BOILERPLATE\n\n  # Allow CC to be a program name with arguments.\n  lt_save_CC=\"$CC\"\n  lt_save_GCC=$GCC\n  CC=${FC-\"f95\"}\n  compiler=$CC\n  GCC=$ac_cv_fc_compiler_gnu\n\n  _LT_TAGVAR(compiler, $1)=$CC\n  _LT_CC_BASENAME([$compiler])\n\n  if test -n \"$compiler\"; then\n    AC_MSG_CHECKING([if libtool supports shared libraries])\n    AC_MSG_RESULT([$can_build_shared])\n\n    AC_MSG_CHECKING([whether to build shared libraries])\n    test \"$can_build_shared\" = \"no\" && enable_shared=no\n\n    # On AIX, shared libraries and static libraries use the same namespace, and\n    # are all built from PIC.\n    case $host_os in\n      aix3*)\n        test \"$enable_shared\" = yes && enable_static=no\n        if test -n \"$RANLIB\"; then\n          archive_cmds=\"$archive_cmds~\\$RANLIB \\$lib\"\n          postinstall_cmds='$RANLIB $lib'\n        fi\n        ;;\n      aix[[4-9]]*)\n\tif test \"$host_cpu\" != ia64 && test \"$aix_use_runtimelinking\" = no ; then\n\t  test \"$enable_shared\" = yes && enable_static=no\n\tfi\n        ;;\n    esac\n    AC_MSG_RESULT([$enable_shared])\n\n    AC_MSG_CHECKING([whether to build static libraries])\n    # Make sure either enable_shared or enable_static is yes.\n    test \"$enable_shared\" = yes || enable_static=yes\n    AC_MSG_RESULT([$enable_static])\n\n    _LT_TAGVAR(GCC, $1)=\"$ac_cv_fc_compiler_gnu\"\n    _LT_TAGVAR(LD, $1)=\"$LD\"\n\n    ## CAVEAT EMPTOR:\n    ## There is no encapsulation within the following macros, do not change\n    ## the running order or otherwise move them around unless you know exactly\n    ## what you are doing...\n    _LT_SYS_HIDDEN_LIBDEPS($1)\n    _LT_COMPILER_PIC($1)\n    _LT_COMPILER_C_O($1)\n    _LT_COMPILER_FILE_LOCKS($1)\n    _LT_LINKER_SHLIBS($1)\n    _LT_SYS_DYNAMIC_LINKER($1)\n    _LT_LINKER_HARDCODE_LIBPATH($1)\n\n    _LT_CONFIG($1)\n  fi # test -n \"$compiler\"\n\n  GCC=$lt_save_GCC\n  CC=\"$lt_save_CC\"\nfi # test \"$_lt_disable_FC\" != yes\n\nAC_LANG_POP\n])# _LT_LANG_FC_CONFIG\n\n\n# _LT_LANG_GCJ_CONFIG([TAG])\n# --------------------------\n# Ensure that the configuration variables for the GNU Java Compiler compiler\n# are suitably defined.  These variables are subsequently used by _LT_CONFIG\n# to write the compiler configuration to `libtool'.\nm4_defun([_LT_LANG_GCJ_CONFIG],\n[AC_REQUIRE([LT_PROG_GCJ])dnl\nAC_LANG_SAVE\n\n# Source file extension for Java test sources.\nac_ext=java\n\n# Object file extension for compiled Java test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# Code to be used in simple compile tests\nlt_simple_compile_test_code=\"class foo {}\"\n\n# Code to be used in simple link tests\nlt_simple_link_test_code='public class conftest { public static void main(String[[]] argv) {}; }'\n\n# ltmain only uses $CC for tagged configurations so make sure $CC is set.\n_LT_TAG_COMPILER\n\n# save warnings/boilerplate of simple test code\n_LT_COMPILER_BOILERPLATE\n_LT_LINKER_BOILERPLATE\n\n# Allow CC to be a program name with arguments.\nlt_save_CC=\"$CC\"\nlt_save_GCC=$GCC\nGCC=yes\nCC=${GCJ-\"gcj\"}\ncompiler=$CC\n_LT_TAGVAR(compiler, $1)=$CC\n_LT_TAGVAR(LD, $1)=\"$LD\"\n_LT_CC_BASENAME([$compiler])\n\n# GCJ did not exist at the time GCC didn't implicitly link libc in.\n_LT_TAGVAR(archive_cmds_need_lc, $1)=no\n\n_LT_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds\n\n## CAVEAT EMPTOR:\n## There is no encapsulation within the following macros, do not change\n## the running order or otherwise move them around unless you know exactly\n## what you are doing...\nif test -n \"$compiler\"; then\n  _LT_COMPILER_NO_RTTI($1)\n  _LT_COMPILER_PIC($1)\n  _LT_COMPILER_C_O($1)\n  _LT_COMPILER_FILE_LOCKS($1)\n  _LT_LINKER_SHLIBS($1)\n  _LT_LINKER_HARDCODE_LIBPATH($1)\n\n  _LT_CONFIG($1)\nfi\n\nAC_LANG_RESTORE\n\nGCC=$lt_save_GCC\nCC=\"$lt_save_CC\"\n])# _LT_LANG_GCJ_CONFIG\n\n\n# _LT_LANG_RC_CONFIG([TAG])\n# -------------------------\n# Ensure that the configuration variables for the Windows resource compiler\n# are suitably defined.  These variables are subsequently used by _LT_CONFIG\n# to write the compiler configuration to `libtool'.\nm4_defun([_LT_LANG_RC_CONFIG],\n[AC_REQUIRE([LT_PROG_RC])dnl\nAC_LANG_SAVE\n\n# Source file extension for RC test sources.\nac_ext=rc\n\n# Object file extension for compiled RC test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# Code to be used in simple compile tests\nlt_simple_compile_test_code='sample MENU { MENUITEM \"&Soup\", 100, CHECKED }'\n\n# Code to be used in simple link tests\nlt_simple_link_test_code=\"$lt_simple_compile_test_code\"\n\n# ltmain only uses $CC for tagged configurations so make sure $CC is set.\n_LT_TAG_COMPILER\n\n# save warnings/boilerplate of simple test code\n_LT_COMPILER_BOILERPLATE\n_LT_LINKER_BOILERPLATE\n\n# Allow CC to be a program name with arguments.\nlt_save_CC=\"$CC\"\nlt_save_GCC=$GCC\nGCC=\nCC=${RC-\"windres\"}\ncompiler=$CC\n_LT_TAGVAR(compiler, $1)=$CC\n_LT_CC_BASENAME([$compiler])\n_LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)=yes\n\nif test -n \"$compiler\"; then\n  :\n  _LT_CONFIG($1)\nfi\n\nGCC=$lt_save_GCC\nAC_LANG_RESTORE\nCC=\"$lt_save_CC\"\n])# _LT_LANG_RC_CONFIG\n\n\n# LT_PROG_GCJ\n# -----------\nAC_DEFUN([LT_PROG_GCJ],\n[m4_ifdef([AC_PROG_GCJ], [AC_PROG_GCJ],\n  [m4_ifdef([A][M_PROG_GCJ], [A][M_PROG_GCJ],\n    [AC_CHECK_TOOL(GCJ, gcj,)\n      test \"x${GCJFLAGS+set}\" = xset || GCJFLAGS=\"-g -O2\"\n      AC_SUBST(GCJFLAGS)])])[]dnl\n])\n\n# Old name:\nAU_ALIAS([LT_AC_PROG_GCJ], [LT_PROG_GCJ])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([LT_AC_PROG_GCJ], [])\n\n\n# LT_PROG_RC\n# ----------\nAC_DEFUN([LT_PROG_RC],\n[AC_CHECK_TOOL(RC, windres,)\n])\n\n# Old name:\nAU_ALIAS([LT_AC_PROG_RC], [LT_PROG_RC])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([LT_AC_PROG_RC], [])\n\n\n# _LT_DECL_EGREP\n# --------------\n# If we don't have a new enough Autoconf to choose the best grep\n# available, choose the one first in the user's PATH.\nm4_defun([_LT_DECL_EGREP],\n[AC_REQUIRE([AC_PROG_EGREP])dnl\nAC_REQUIRE([AC_PROG_FGREP])dnl\ntest -z \"$GREP\" && GREP=grep\n_LT_DECL([], [GREP], [1], [A grep program that handles long lines])\n_LT_DECL([], [EGREP], [1], [An ERE matcher])\n_LT_DECL([], [FGREP], [1], [A literal string matcher])\ndnl Non-bleeding-edge autoconf doesn't subst GREP, so do it here too\nAC_SUBST([GREP])\n])\n\n\n# _LT_DECL_OBJDUMP\n# --------------\n# If we don't have a new enough Autoconf to choose the best objdump\n# available, choose the one first in the user's PATH.\nm4_defun([_LT_DECL_OBJDUMP],\n[AC_CHECK_TOOL(OBJDUMP, objdump, false)\ntest -z \"$OBJDUMP\" && OBJDUMP=objdump\n_LT_DECL([], [OBJDUMP], [1], [An object symbol dumper])\nAC_SUBST([OBJDUMP])\n])\n\n\n# _LT_DECL_SED\n# ------------\n# Check for a fully-functional sed program, that truncates\n# as few characters as possible.  Prefer GNU sed if found.\nm4_defun([_LT_DECL_SED],\n[AC_PROG_SED\ntest -z \"$SED\" && SED=sed\nXsed=\"$SED -e 1s/^X//\"\n_LT_DECL([], [SED], [1], [A sed program that does not truncate output])\n_LT_DECL([], [Xsed], [\"\\$SED -e 1s/^X//\"],\n    [Sed that helps us avoid accidentally triggering echo(1) options like -n])\n])# _LT_DECL_SED\n\nm4_ifndef([AC_PROG_SED], [\n############################################################\n# NOTE: This macro has been submitted for inclusion into   #\n#  GNU Autoconf as AC_PROG_SED.  When it is available in   #\n#  a released version of Autoconf we should remove this    #\n#  macro and use it instead.                               #\n############################################################\n\nm4_defun([AC_PROG_SED],\n[AC_MSG_CHECKING([for a sed that does not truncate output])\nAC_CACHE_VAL(lt_cv_path_SED,\n[# Loop through the user's path and test for sed and gsed.\n# Then use that list of sed's as ones to test for truncation.\nas_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  test -z \"$as_dir\" && as_dir=.\n  for lt_ac_prog in sed gsed; do\n    for ac_exec_ext in '' $ac_executable_extensions; do\n      if $as_executable_p \"$as_dir/$lt_ac_prog$ac_exec_ext\"; then\n        lt_ac_sed_list=\"$lt_ac_sed_list $as_dir/$lt_ac_prog$ac_exec_ext\"\n      fi\n    done\n  done\ndone\nIFS=$as_save_IFS\nlt_ac_max=0\nlt_ac_count=0\n# Add /usr/xpg4/bin/sed as it is typically found on Solaris\n# along with /bin/sed that truncates output.\nfor lt_ac_sed in $lt_ac_sed_list /usr/xpg4/bin/sed; do\n  test ! -f $lt_ac_sed && continue\n  cat /dev/null > conftest.in\n  lt_ac_count=0\n  echo $ECHO_N \"0123456789$ECHO_C\" >conftest.in\n  # Check for GNU sed and select it if it is found.\n  if \"$lt_ac_sed\" --version 2>&1 < /dev/null | grep 'GNU' > /dev/null; then\n    lt_cv_path_SED=$lt_ac_sed\n    break\n  fi\n  while true; do\n    cat conftest.in conftest.in >conftest.tmp\n    mv conftest.tmp conftest.in\n    cp conftest.in conftest.nl\n    echo >>conftest.nl\n    $lt_ac_sed -e 's/a$//' < conftest.nl >conftest.out || break\n    cmp -s conftest.out conftest.nl || break\n    # 10000 chars as input seems more than enough\n    test $lt_ac_count -gt 10 && break\n    lt_ac_count=`expr $lt_ac_count + 1`\n    if test $lt_ac_count -gt $lt_ac_max; then\n      lt_ac_max=$lt_ac_count\n      lt_cv_path_SED=$lt_ac_sed\n    fi\n  done\ndone\n])\nSED=$lt_cv_path_SED\nAC_SUBST([SED])\nAC_MSG_RESULT([$SED])\n])#AC_PROG_SED\n])#m4_ifndef\n\n# Old name:\nAU_ALIAS([LT_AC_PROG_SED], [AC_PROG_SED])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([LT_AC_PROG_SED], [])\n\n\n# _LT_CHECK_SHELL_FEATURES\n# ------------------------\n# Find out whether the shell is Bourne or XSI compatible,\n# or has some other useful features.\nm4_defun([_LT_CHECK_SHELL_FEATURES],\n[AC_MSG_CHECKING([whether the shell understands some XSI constructs])\n# Try some XSI features\nxsi_shell=no\n( _lt_dummy=\"a/b/c\"\n  test \"${_lt_dummy##*/},${_lt_dummy%/*},\"${_lt_dummy%\"$_lt_dummy\"}, \\\n      = c,a/b,, \\\n    && eval 'test $(( 1 + 1 )) -eq 2 \\\n    && test \"${#_lt_dummy}\" -eq 5' ) >/dev/null 2>&1 \\\n  && xsi_shell=yes\nAC_MSG_RESULT([$xsi_shell])\n_LT_CONFIG_LIBTOOL_INIT([xsi_shell='$xsi_shell'])\n\nAC_MSG_CHECKING([whether the shell understands \"+=\"])\nlt_shell_append=no\n( foo=bar; set foo baz; eval \"$[1]+=\\$[2]\" && test \"$foo\" = barbaz ) \\\n    >/dev/null 2>&1 \\\n  && lt_shell_append=yes\nAC_MSG_RESULT([$lt_shell_append])\n_LT_CONFIG_LIBTOOL_INIT([lt_shell_append='$lt_shell_append'])\n\nif ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then\n  lt_unset=unset\nelse\n  lt_unset=false\nfi\n_LT_DECL([], [lt_unset], [0], [whether the shell understands \"unset\"])dnl\n\n# test EBCDIC or ASCII\ncase `echo X|tr X '\\101'` in\n A) # ASCII based system\n    # \\n is not interpreted correctly by Solaris 8 /usr/ucb/tr\n  lt_SP2NL='tr \\040 \\012'\n  lt_NL2SP='tr \\015\\012 \\040\\040'\n  ;;\n *) # EBCDIC based system\n  lt_SP2NL='tr \\100 \\n'\n  lt_NL2SP='tr \\r\\n \\100\\100'\n  ;;\nesac\n_LT_DECL([SP2NL], [lt_SP2NL], [1], [turn spaces into newlines])dnl\n_LT_DECL([NL2SP], [lt_NL2SP], [1], [turn newlines into spaces])dnl\n])# _LT_CHECK_SHELL_FEATURES\n\n\n# _LT_PROG_XSI_SHELLFNS\n# ---------------------\n# Bourne and XSI compatible variants of some useful shell functions.\nm4_defun([_LT_PROG_XSI_SHELLFNS],\n[case $xsi_shell in\n  yes)\n    cat << \\_LT_EOF >> \"$cfgfile\"\n\n# func_dirname file append nondir_replacement\n# Compute the dirname of FILE.  If nonempty, add APPEND to the result,\n# otherwise set result to NONDIR_REPLACEMENT.\nfunc_dirname ()\n{\n  case ${1} in\n    */*) func_dirname_result=\"${1%/*}${2}\" ;;\n    *  ) func_dirname_result=\"${3}\" ;;\n  esac\n}\n\n# func_basename file\nfunc_basename ()\n{\n  func_basename_result=\"${1##*/}\"\n}\n\n# func_dirname_and_basename file append nondir_replacement\n# perform func_basename and func_dirname in a single function\n# call:\n#   dirname:  Compute the dirname of FILE.  If nonempty,\n#             add APPEND to the result, otherwise set result\n#             to NONDIR_REPLACEMENT.\n#             value returned in \"$func_dirname_result\"\n#   basename: Compute filename of FILE.\n#             value retuned in \"$func_basename_result\"\n# Implementation must be kept synchronized with func_dirname\n# and func_basename. For efficiency, we do not delegate to\n# those functions but instead duplicate the functionality here.\nfunc_dirname_and_basename ()\n{\n  case ${1} in\n    */*) func_dirname_result=\"${1%/*}${2}\" ;;\n    *  ) func_dirname_result=\"${3}\" ;;\n  esac\n  func_basename_result=\"${1##*/}\"\n}\n\n# func_stripname prefix suffix name\n# strip PREFIX and SUFFIX off of NAME.\n# PREFIX and SUFFIX must not contain globbing or regex special\n# characters, hashes, percent signs, but SUFFIX may contain a leading\n# dot (in which case that matches only a dot).\nfunc_stripname ()\n{\n  # pdksh 5.2.14 does not do ${X%$Y} correctly if both X and Y are\n  # positional parameters, so assign one to ordinary parameter first.\n  func_stripname_result=${3}\n  func_stripname_result=${func_stripname_result#\"${1}\"}\n  func_stripname_result=${func_stripname_result%\"${2}\"}\n}\n\n# func_opt_split\nfunc_opt_split ()\n{\n  func_opt_split_opt=${1%%=*}\n  func_opt_split_arg=${1#*=}\n}\n\n# func_lo2o object\nfunc_lo2o ()\n{\n  case ${1} in\n    *.lo) func_lo2o_result=${1%.lo}.${objext} ;;\n    *)    func_lo2o_result=${1} ;;\n  esac\n}\n\n# func_xform libobj-or-source\nfunc_xform ()\n{\n  func_xform_result=${1%.*}.lo\n}\n\n# func_arith arithmetic-term...\nfunc_arith ()\n{\n  func_arith_result=$(( $[*] ))\n}\n\n# func_len string\n# STRING may not start with a hyphen.\nfunc_len ()\n{\n  func_len_result=${#1}\n}\n\n_LT_EOF\n    ;;\n  *) # Bourne compatible functions.\n    cat << \\_LT_EOF >> \"$cfgfile\"\n\n# func_dirname file append nondir_replacement\n# Compute the dirname of FILE.  If nonempty, add APPEND to the result,\n# otherwise set result to NONDIR_REPLACEMENT.\nfunc_dirname ()\n{\n  # Extract subdirectory from the argument.\n  func_dirname_result=`$ECHO \"X${1}\" | $Xsed -e \"$dirname\"`\n  if test \"X$func_dirname_result\" = \"X${1}\"; then\n    func_dirname_result=\"${3}\"\n  else\n    func_dirname_result=\"$func_dirname_result${2}\"\n  fi\n}\n\n# func_basename file\nfunc_basename ()\n{\n  func_basename_result=`$ECHO \"X${1}\" | $Xsed -e \"$basename\"`\n}\n\ndnl func_dirname_and_basename\ndnl A portable version of this function is already defined in general.m4sh\ndnl so there is no need for it here.\n\n# func_stripname prefix suffix name\n# strip PREFIX and SUFFIX off of NAME.\n# PREFIX and SUFFIX must not contain globbing or regex special\n# characters, hashes, percent signs, but SUFFIX may contain a leading\n# dot (in which case that matches only a dot).\n# func_strip_suffix prefix name\nfunc_stripname ()\n{\n  case ${2} in\n    .*) func_stripname_result=`$ECHO \"X${3}\" \\\n           | $Xsed -e \"s%^${1}%%\" -e \"s%\\\\\\\\${2}\\$%%\"`;;\n    *)  func_stripname_result=`$ECHO \"X${3}\" \\\n           | $Xsed -e \"s%^${1}%%\" -e \"s%${2}\\$%%\"`;;\n  esac\n}\n\n# sed scripts:\nmy_sed_long_opt='1s/^\\(-[[^=]]*\\)=.*/\\1/;q'\nmy_sed_long_arg='1s/^-[[^=]]*=//'\n\n# func_opt_split\nfunc_opt_split ()\n{\n  func_opt_split_opt=`$ECHO \"X${1}\" | $Xsed -e \"$my_sed_long_opt\"`\n  func_opt_split_arg=`$ECHO \"X${1}\" | $Xsed -e \"$my_sed_long_arg\"`\n}\n\n# func_lo2o object\nfunc_lo2o ()\n{\n  func_lo2o_result=`$ECHO \"X${1}\" | $Xsed -e \"$lo2o\"`\n}\n\n# func_xform libobj-or-source\nfunc_xform ()\n{\n  func_xform_result=`$ECHO \"X${1}\" | $Xsed -e 's/\\.[[^.]]*$/.lo/'`\n}\n\n# func_arith arithmetic-term...\nfunc_arith ()\n{\n  func_arith_result=`expr \"$[@]\"`\n}\n\n# func_len string\n# STRING may not start with a hyphen.\nfunc_len ()\n{\n  func_len_result=`expr \"$[1]\" : \".*\" 2>/dev/null || echo $max_cmd_len`\n}\n\n_LT_EOF\nesac\n\ncase $lt_shell_append in\n  yes)\n    cat << \\_LT_EOF >> \"$cfgfile\"\n\n# func_append var value\n# Append VALUE to the end of shell variable VAR.\nfunc_append ()\n{\n  eval \"$[1]+=\\$[2]\"\n}\n_LT_EOF\n    ;;\n  *)\n    cat << \\_LT_EOF >> \"$cfgfile\"\n\n# func_append var value\n# Append VALUE to the end of shell variable VAR.\nfunc_append ()\n{\n  eval \"$[1]=\\$$[1]\\$[2]\"\n}\n\n_LT_EOF\n    ;;\n  esac\n])\n",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/tokudb/PerconaFT/third_party/xz-4.999.9beta/m4/ltoptions.m4": "# Helper functions for option handling.                    -*- Autoconf -*-\n#\n#   Copyright (C) 2004, 2005, 2007, 2008 Free Software Foundation, Inc.\n#   Written by Gary V. Vaughan, 2004\n#\n# This file is free software; the Free Software Foundation gives\n# unlimited permission to copy and/or distribute it, with or without\n# modifications, as long as this notice is preserved.\n\n# serial 6 ltoptions.m4\n\n# This is to help aclocal find these macros, as it can't see m4_define.\nAC_DEFUN([LTOPTIONS_VERSION], [m4_if([1])])\n\n\n# _LT_MANGLE_OPTION(MACRO-NAME, OPTION-NAME)\n# ------------------------------------------\nm4_define([_LT_MANGLE_OPTION],\n[[_LT_OPTION_]m4_bpatsubst($1__$2, [[^a-zA-Z0-9_]], [_])])\n\n\n# _LT_SET_OPTION(MACRO-NAME, OPTION-NAME)\n# ---------------------------------------\n# Set option OPTION-NAME for macro MACRO-NAME, and if there is a\n# matching handler defined, dispatch to it.  Other OPTION-NAMEs are\n# saved as a flag.\nm4_define([_LT_SET_OPTION],\n[m4_define(_LT_MANGLE_OPTION([$1], [$2]))dnl\nm4_ifdef(_LT_MANGLE_DEFUN([$1], [$2]),\n        _LT_MANGLE_DEFUN([$1], [$2]),\n    [m4_warning([Unknown $1 option `$2'])])[]dnl\n])\n\n\n# _LT_IF_OPTION(MACRO-NAME, OPTION-NAME, IF-SET, [IF-NOT-SET])\n# ------------------------------------------------------------\n# Execute IF-SET if OPTION is set, IF-NOT-SET otherwise.\nm4_define([_LT_IF_OPTION],\n[m4_ifdef(_LT_MANGLE_OPTION([$1], [$2]), [$3], [$4])])\n\n\n# _LT_UNLESS_OPTIONS(MACRO-NAME, OPTION-LIST, IF-NOT-SET)\n# -------------------------------------------------------\n# Execute IF-NOT-SET unless all options in OPTION-LIST for MACRO-NAME\n# are set.\nm4_define([_LT_UNLESS_OPTIONS],\n[m4_foreach([_LT_Option], m4_split(m4_normalize([$2])),\n\t    [m4_ifdef(_LT_MANGLE_OPTION([$1], _LT_Option),\n\t\t      [m4_define([$0_found])])])[]dnl\nm4_ifdef([$0_found], [m4_undefine([$0_found])], [$3\n])[]dnl\n])\n\n\n# _LT_SET_OPTIONS(MACRO-NAME, OPTION-LIST)\n# ----------------------------------------\n# OPTION-LIST is a space-separated list of Libtool options associated\n# with MACRO-NAME.  If any OPTION has a matching handler declared with\n# LT_OPTION_DEFINE, dispatch to that macro; otherwise complain about\n# the unknown option and exit.\nm4_defun([_LT_SET_OPTIONS],\n[# Set options\nm4_foreach([_LT_Option], m4_split(m4_normalize([$2])),\n    [_LT_SET_OPTION([$1], _LT_Option)])\n\nm4_if([$1],[LT_INIT],[\n  dnl\n  dnl Simply set some default values (i.e off) if boolean options were not\n  dnl specified:\n  _LT_UNLESS_OPTIONS([LT_INIT], [dlopen], [enable_dlopen=no\n  ])\n  _LT_UNLESS_OPTIONS([LT_INIT], [win32-dll], [enable_win32_dll=no\n  ])\n  dnl\n  dnl If no reference was made to various pairs of opposing options, then\n  dnl we run the default mode handler for the pair.  For example, if neither\n  dnl `shared' nor `disable-shared' was passed, we enable building of shared\n  dnl archives by default:\n  _LT_UNLESS_OPTIONS([LT_INIT], [shared disable-shared], [_LT_ENABLE_SHARED])\n  _LT_UNLESS_OPTIONS([LT_INIT], [static disable-static], [_LT_ENABLE_STATIC])\n  _LT_UNLESS_OPTIONS([LT_INIT], [pic-only no-pic], [_LT_WITH_PIC])\n  _LT_UNLESS_OPTIONS([LT_INIT], [fast-install disable-fast-install],\n  \t\t   [_LT_ENABLE_FAST_INSTALL])\n  ])\n])# _LT_SET_OPTIONS\n\n\n## --------------------------------- ##\n## Macros to handle LT_INIT options. ##\n## --------------------------------- ##\n\n# _LT_MANGLE_DEFUN(MACRO-NAME, OPTION-NAME)\n# -----------------------------------------\nm4_define([_LT_MANGLE_DEFUN],\n[[_LT_OPTION_DEFUN_]m4_bpatsubst(m4_toupper([$1__$2]), [[^A-Z0-9_]], [_])])\n\n\n# LT_OPTION_DEFINE(MACRO-NAME, OPTION-NAME, CODE)\n# -----------------------------------------------\nm4_define([LT_OPTION_DEFINE],\n[m4_define(_LT_MANGLE_DEFUN([$1], [$2]), [$3])[]dnl\n])# LT_OPTION_DEFINE\n\n\n# dlopen\n# ------\nLT_OPTION_DEFINE([LT_INIT], [dlopen], [enable_dlopen=yes\n])\n\nAU_DEFUN([AC_LIBTOOL_DLOPEN],\n[_LT_SET_OPTION([LT_INIT], [dlopen])\nAC_DIAGNOSE([obsolete],\n[$0: Remove this warning and the call to _LT_SET_OPTION when you\nput the `dlopen' option into LT_INIT's first parameter.])\n])\n\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_DLOPEN], [])\n\n\n# win32-dll\n# ---------\n# Declare package support for building win32 dll's.\nLT_OPTION_DEFINE([LT_INIT], [win32-dll],\n[enable_win32_dll=yes\n\ncase $host in\n*-*-cygwin* | *-*-mingw* | *-*-pw32* | *-cegcc*)\n  AC_CHECK_TOOL(AS, as, false)\n  AC_CHECK_TOOL(DLLTOOL, dlltool, false)\n  AC_CHECK_TOOL(OBJDUMP, objdump, false)\n  ;;\nesac\n\ntest -z \"$AS\" && AS=as\n_LT_DECL([], [AS],      [0], [Assembler program])dnl\n\ntest -z \"$DLLTOOL\" && DLLTOOL=dlltool\n_LT_DECL([], [DLLTOOL], [0], [DLL creation program])dnl\n\ntest -z \"$OBJDUMP\" && OBJDUMP=objdump\n_LT_DECL([], [OBJDUMP], [0], [Object dumper program])dnl\n])# win32-dll\n\nAU_DEFUN([AC_LIBTOOL_WIN32_DLL],\n[AC_REQUIRE([AC_CANONICAL_HOST])dnl\n_LT_SET_OPTION([LT_INIT], [win32-dll])\nAC_DIAGNOSE([obsolete],\n[$0: Remove this warning and the call to _LT_SET_OPTION when you\nput the `win32-dll' option into LT_INIT's first parameter.])\n])\n\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_WIN32_DLL], [])\n\n\n# _LT_ENABLE_SHARED([DEFAULT])\n# ----------------------------\n# implement the --enable-shared flag, and supports the `shared' and\n# `disable-shared' LT_INIT options.\n# DEFAULT is either `yes' or `no'.  If omitted, it defaults to `yes'.\nm4_define([_LT_ENABLE_SHARED],\n[m4_define([_LT_ENABLE_SHARED_DEFAULT], [m4_if($1, no, no, yes)])dnl\nAC_ARG_ENABLE([shared],\n    [AS_HELP_STRING([--enable-shared@<:@=PKGS@:>@],\n\t[build shared libraries @<:@default=]_LT_ENABLE_SHARED_DEFAULT[@:>@])],\n    [p=${PACKAGE-default}\n    case $enableval in\n    yes) enable_shared=yes ;;\n    no) enable_shared=no ;;\n    *)\n      enable_shared=no\n      # Look at the argument we got.  We use all the common list separators.\n      lt_save_ifs=\"$IFS\"; IFS=\"${IFS}$PATH_SEPARATOR,\"\n      for pkg in $enableval; do\n\tIFS=\"$lt_save_ifs\"\n\tif test \"X$pkg\" = \"X$p\"; then\n\t  enable_shared=yes\n\tfi\n      done\n      IFS=\"$lt_save_ifs\"\n      ;;\n    esac],\n    [enable_shared=]_LT_ENABLE_SHARED_DEFAULT)\n\n    _LT_DECL([build_libtool_libs], [enable_shared], [0],\n\t[Whether or not to build shared libraries])\n])# _LT_ENABLE_SHARED\n\nLT_OPTION_DEFINE([LT_INIT], [shared], [_LT_ENABLE_SHARED([yes])])\nLT_OPTION_DEFINE([LT_INIT], [disable-shared], [_LT_ENABLE_SHARED([no])])\n\n# Old names:\nAC_DEFUN([AC_ENABLE_SHARED],\n[_LT_SET_OPTION([LT_INIT], m4_if([$1], [no], [disable-])[shared])\n])\n\nAC_DEFUN([AC_DISABLE_SHARED],\n[_LT_SET_OPTION([LT_INIT], [disable-shared])\n])\n\nAU_DEFUN([AM_ENABLE_SHARED], [AC_ENABLE_SHARED($@)])\nAU_DEFUN([AM_DISABLE_SHARED], [AC_DISABLE_SHARED($@)])\n\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AM_ENABLE_SHARED], [])\ndnl AC_DEFUN([AM_DISABLE_SHARED], [])\n\n\n\n# _LT_ENABLE_STATIC([DEFAULT])\n# ----------------------------\n# implement the --enable-static flag, and support the `static' and\n# `disable-static' LT_INIT options.\n# DEFAULT is either `yes' or `no'.  If omitted, it defaults to `yes'.\nm4_define([_LT_ENABLE_STATIC],\n[m4_define([_LT_ENABLE_STATIC_DEFAULT], [m4_if($1, no, no, yes)])dnl\nAC_ARG_ENABLE([static],\n    [AS_HELP_STRING([--enable-static@<:@=PKGS@:>@],\n\t[build static libraries @<:@default=]_LT_ENABLE_STATIC_DEFAULT[@:>@])],\n    [p=${PACKAGE-default}\n    case $enableval in\n    yes) enable_static=yes ;;\n    no) enable_static=no ;;\n    *)\n     enable_static=no\n      # Look at the argument we got.  We use all the common list separators.\n      lt_save_ifs=\"$IFS\"; IFS=\"${IFS}$PATH_SEPARATOR,\"\n      for pkg in $enableval; do\n\tIFS=\"$lt_save_ifs\"\n\tif test \"X$pkg\" = \"X$p\"; then\n\t  enable_static=yes\n\tfi\n      done\n      IFS=\"$lt_save_ifs\"\n      ;;\n    esac],\n    [enable_static=]_LT_ENABLE_STATIC_DEFAULT)\n\n    _LT_DECL([build_old_libs], [enable_static], [0],\n\t[Whether or not to build static libraries])\n])# _LT_ENABLE_STATIC\n\nLT_OPTION_DEFINE([LT_INIT], [static], [_LT_ENABLE_STATIC([yes])])\nLT_OPTION_DEFINE([LT_INIT], [disable-static], [_LT_ENABLE_STATIC([no])])\n\n# Old names:\nAC_DEFUN([AC_ENABLE_STATIC],\n[_LT_SET_OPTION([LT_INIT], m4_if([$1], [no], [disable-])[static])\n])\n\nAC_DEFUN([AC_DISABLE_STATIC],\n[_LT_SET_OPTION([LT_INIT], [disable-static])\n])\n\nAU_DEFUN([AM_ENABLE_STATIC], [AC_ENABLE_STATIC($@)])\nAU_DEFUN([AM_DISABLE_STATIC], [AC_DISABLE_STATIC($@)])\n\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AM_ENABLE_STATIC], [])\ndnl AC_DEFUN([AM_DISABLE_STATIC], [])\n\n\n\n# _LT_ENABLE_FAST_INSTALL([DEFAULT])\n# ----------------------------------\n# implement the --enable-fast-install flag, and support the `fast-install'\n# and `disable-fast-install' LT_INIT options.\n# DEFAULT is either `yes' or `no'.  If omitted, it defaults to `yes'.\nm4_define([_LT_ENABLE_FAST_INSTALL],\n[m4_define([_LT_ENABLE_FAST_INSTALL_DEFAULT], [m4_if($1, no, no, yes)])dnl\nAC_ARG_ENABLE([fast-install],\n    [AS_HELP_STRING([--enable-fast-install@<:@=PKGS@:>@],\n    [optimize for fast installation @<:@default=]_LT_ENABLE_FAST_INSTALL_DEFAULT[@:>@])],\n    [p=${PACKAGE-default}\n    case $enableval in\n    yes) enable_fast_install=yes ;;\n    no) enable_fast_install=no ;;\n    *)\n      enable_fast_install=no\n      # Look at the argument we got.  We use all the common list separators.\n      lt_save_ifs=\"$IFS\"; IFS=\"${IFS}$PATH_SEPARATOR,\"\n      for pkg in $enableval; do\n\tIFS=\"$lt_save_ifs\"\n\tif test \"X$pkg\" = \"X$p\"; then\n\t  enable_fast_install=yes\n\tfi\n      done\n      IFS=\"$lt_save_ifs\"\n      ;;\n    esac],\n    [enable_fast_install=]_LT_ENABLE_FAST_INSTALL_DEFAULT)\n\n_LT_DECL([fast_install], [enable_fast_install], [0],\n\t [Whether or not to optimize for fast installation])dnl\n])# _LT_ENABLE_FAST_INSTALL\n\nLT_OPTION_DEFINE([LT_INIT], [fast-install], [_LT_ENABLE_FAST_INSTALL([yes])])\nLT_OPTION_DEFINE([LT_INIT], [disable-fast-install], [_LT_ENABLE_FAST_INSTALL([no])])\n\n# Old names:\nAU_DEFUN([AC_ENABLE_FAST_INSTALL],\n[_LT_SET_OPTION([LT_INIT], m4_if([$1], [no], [disable-])[fast-install])\nAC_DIAGNOSE([obsolete],\n[$0: Remove this warning and the call to _LT_SET_OPTION when you put\nthe `fast-install' option into LT_INIT's first parameter.])\n])\n\nAU_DEFUN([AC_DISABLE_FAST_INSTALL],\n[_LT_SET_OPTION([LT_INIT], [disable-fast-install])\nAC_DIAGNOSE([obsolete],\n[$0: Remove this warning and the call to _LT_SET_OPTION when you put\nthe `disable-fast-install' option into LT_INIT's first parameter.])\n])\n\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_ENABLE_FAST_INSTALL], [])\ndnl AC_DEFUN([AM_DISABLE_FAST_INSTALL], [])\n\n\n# _LT_WITH_PIC([MODE])\n# --------------------\n# implement the --with-pic flag, and support the `pic-only' and `no-pic'\n# LT_INIT options.\n# MODE is either `yes' or `no'.  If omitted, it defaults to `both'.\nm4_define([_LT_WITH_PIC],\n[AC_ARG_WITH([pic],\n    [AS_HELP_STRING([--with-pic],\n\t[try to use only PIC/non-PIC objects @<:@default=use both@:>@])],\n    [pic_mode=\"$withval\"],\n    [pic_mode=default])\n\ntest -z \"$pic_mode\" && pic_mode=m4_default([$1], [default])\n\n_LT_DECL([], [pic_mode], [0], [What type of objects to build])dnl\n])# _LT_WITH_PIC\n\nLT_OPTION_DEFINE([LT_INIT], [pic-only], [_LT_WITH_PIC([yes])])\nLT_OPTION_DEFINE([LT_INIT], [no-pic], [_LT_WITH_PIC([no])])\n\n# Old name:\nAU_DEFUN([AC_LIBTOOL_PICMODE],\n[_LT_SET_OPTION([LT_INIT], [pic-only])\nAC_DIAGNOSE([obsolete],\n[$0: Remove this warning and the call to _LT_SET_OPTION when you\nput the `pic-only' option into LT_INIT's first parameter.])\n])\n\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_PICMODE], [])\n\n## ----------------- ##\n## LTDL_INIT Options ##\n## ----------------- ##\n\nm4_define([_LTDL_MODE], [])\nLT_OPTION_DEFINE([LTDL_INIT], [nonrecursive],\n\t\t [m4_define([_LTDL_MODE], [nonrecursive])])\nLT_OPTION_DEFINE([LTDL_INIT], [recursive],\n\t\t [m4_define([_LTDL_MODE], [recursive])])\nLT_OPTION_DEFINE([LTDL_INIT], [subproject],\n\t\t [m4_define([_LTDL_MODE], [subproject])])\n\nm4_define([_LTDL_TYPE], [])\nLT_OPTION_DEFINE([LTDL_INIT], [installable],\n\t\t [m4_define([_LTDL_TYPE], [installable])])\nLT_OPTION_DEFINE([LTDL_INIT], [convenience],\n\t\t [m4_define([_LTDL_TYPE], [convenience])])\n",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/tokudb/PerconaFT/third_party/xz-4.999.9beta/m4/lib-link.m4": "# lib-link.m4 serial 9 (gettext-0.16)\ndnl Copyright (C) 2001-2006 Free Software Foundation, Inc.\ndnl This file is free software; the Free Software Foundation\ndnl gives unlimited permission to copy and/or distribute it,\ndnl with or without modifications, as long as this notice is preserved.\n\ndnl From Bruno Haible.\n\nAC_PREREQ(2.50)\n\ndnl AC_LIB_LINKFLAGS(name [, dependencies]) searches for libname and\ndnl the libraries corresponding to explicit and implicit dependencies.\ndnl Sets and AC_SUBSTs the LIB${NAME} and LTLIB${NAME} variables and\ndnl augments the CPPFLAGS variable.\nAC_DEFUN([AC_LIB_LINKFLAGS],\n[\n  AC_REQUIRE([AC_LIB_PREPARE_PREFIX])\n  AC_REQUIRE([AC_LIB_RPATH])\n  define([Name],[translit([$1],[./-], [___])])\n  define([NAME],[translit([$1],[abcdefghijklmnopqrstuvwxyz./-],\n                               [ABCDEFGHIJKLMNOPQRSTUVWXYZ___])])\n  AC_CACHE_CHECK([how to link with lib[]$1], [ac_cv_lib[]Name[]_libs], [\n    AC_LIB_LINKFLAGS_BODY([$1], [$2])\n    ac_cv_lib[]Name[]_libs=\"$LIB[]NAME\"\n    ac_cv_lib[]Name[]_ltlibs=\"$LTLIB[]NAME\"\n    ac_cv_lib[]Name[]_cppflags=\"$INC[]NAME\"\n  ])\n  LIB[]NAME=\"$ac_cv_lib[]Name[]_libs\"\n  LTLIB[]NAME=\"$ac_cv_lib[]Name[]_ltlibs\"\n  INC[]NAME=\"$ac_cv_lib[]Name[]_cppflags\"\n  AC_LIB_APPENDTOVAR([CPPFLAGS], [$INC]NAME)\n  AC_SUBST([LIB]NAME)\n  AC_SUBST([LTLIB]NAME)\n  dnl Also set HAVE_LIB[]NAME so that AC_LIB_HAVE_LINKFLAGS can reuse the\n  dnl results of this search when this library appears as a dependency.\n  HAVE_LIB[]NAME=yes\n  undefine([Name])\n  undefine([NAME])\n])\n\ndnl AC_LIB_HAVE_LINKFLAGS(name, dependencies, includes, testcode)\ndnl searches for libname and the libraries corresponding to explicit and\ndnl implicit dependencies, together with the specified include files and\ndnl the ability to compile and link the specified testcode. If found, it\ndnl sets and AC_SUBSTs HAVE_LIB${NAME}=yes and the LIB${NAME} and\ndnl LTLIB${NAME} variables and augments the CPPFLAGS variable, and\ndnl #defines HAVE_LIB${NAME} to 1. Otherwise, it sets and AC_SUBSTs\ndnl HAVE_LIB${NAME}=no and LIB${NAME} and LTLIB${NAME} to empty.\nAC_DEFUN([AC_LIB_HAVE_LINKFLAGS],\n[\n  AC_REQUIRE([AC_LIB_PREPARE_PREFIX])\n  AC_REQUIRE([AC_LIB_RPATH])\n  define([Name],[translit([$1],[./-], [___])])\n  define([NAME],[translit([$1],[abcdefghijklmnopqrstuvwxyz./-],\n                               [ABCDEFGHIJKLMNOPQRSTUVWXYZ___])])\n\n  dnl Search for lib[]Name and define LIB[]NAME, LTLIB[]NAME and INC[]NAME\n  dnl accordingly.\n  AC_LIB_LINKFLAGS_BODY([$1], [$2])\n\n  dnl Add $INC[]NAME to CPPFLAGS before performing the following checks,\n  dnl because if the user has installed lib[]Name and not disabled its use\n  dnl via --without-lib[]Name-prefix, he wants to use it.\n  ac_save_CPPFLAGS=\"$CPPFLAGS\"\n  AC_LIB_APPENDTOVAR([CPPFLAGS], [$INC]NAME)\n\n  AC_CACHE_CHECK([for lib[]$1], [ac_cv_lib[]Name], [\n    ac_save_LIBS=\"$LIBS\"\n    LIBS=\"$LIBS $LIB[]NAME\"\n    AC_TRY_LINK([$3], [$4], [ac_cv_lib[]Name=yes], [ac_cv_lib[]Name=no])\n    LIBS=\"$ac_save_LIBS\"\n  ])\n  if test \"$ac_cv_lib[]Name\" = yes; then\n    HAVE_LIB[]NAME=yes\n    AC_DEFINE([HAVE_LIB]NAME, 1, [Define if you have the $1 library.])\n    AC_MSG_CHECKING([how to link with lib[]$1])\n    AC_MSG_RESULT([$LIB[]NAME])\n  else\n    HAVE_LIB[]NAME=no\n    dnl If $LIB[]NAME didn't lead to a usable library, we don't need\n    dnl $INC[]NAME either.\n    CPPFLAGS=\"$ac_save_CPPFLAGS\"\n    LIB[]NAME=\n    LTLIB[]NAME=\n  fi\n  AC_SUBST([HAVE_LIB]NAME)\n  AC_SUBST([LIB]NAME)\n  AC_SUBST([LTLIB]NAME)\n  undefine([Name])\n  undefine([NAME])\n])\n\ndnl Determine the platform dependent parameters needed to use rpath:\ndnl libext, shlibext, hardcode_libdir_flag_spec, hardcode_libdir_separator,\ndnl hardcode_direct, hardcode_minus_L.\nAC_DEFUN([AC_LIB_RPATH],\n[\n  dnl Tell automake >= 1.10 to complain if config.rpath is missing.\n  m4_ifdef([AC_REQUIRE_AUX_FILE], [AC_REQUIRE_AUX_FILE([config.rpath])])\n  AC_REQUIRE([AC_PROG_CC])                dnl we use $CC, $GCC, $LDFLAGS\n  AC_REQUIRE([AC_LIB_PROG_LD])            dnl we use $LD, $with_gnu_ld\n  AC_REQUIRE([AC_CANONICAL_HOST])         dnl we use $host\n  AC_REQUIRE([AC_CONFIG_AUX_DIR_DEFAULT]) dnl we use $ac_aux_dir\n  AC_CACHE_CHECK([for shared library run path origin], acl_cv_rpath, [\n    CC=\"$CC\" GCC=\"$GCC\" LDFLAGS=\"$LDFLAGS\" LD=\"$LD\" with_gnu_ld=\"$with_gnu_ld\" \\\n    ${CONFIG_SHELL-/bin/sh} \"$ac_aux_dir/config.rpath\" \"$host\" > conftest.sh\n    . ./conftest.sh\n    rm -f ./conftest.sh\n    acl_cv_rpath=done\n  ])\n  wl=\"$acl_cv_wl\"\n  libext=\"$acl_cv_libext\"\n  shlibext=\"$acl_cv_shlibext\"\n  hardcode_libdir_flag_spec=\"$acl_cv_hardcode_libdir_flag_spec\"\n  hardcode_libdir_separator=\"$acl_cv_hardcode_libdir_separator\"\n  hardcode_direct=\"$acl_cv_hardcode_direct\"\n  hardcode_minus_L=\"$acl_cv_hardcode_minus_L\"\n  dnl Determine whether the user wants rpath handling at all.\n  AC_ARG_ENABLE(rpath,\n    [  --disable-rpath         do not hardcode runtime library paths],\n    :, enable_rpath=yes)\n])\n\ndnl AC_LIB_LINKFLAGS_BODY(name [, dependencies]) searches for libname and\ndnl the libraries corresponding to explicit and implicit dependencies.\ndnl Sets the LIB${NAME}, LTLIB${NAME} and INC${NAME} variables.\nAC_DEFUN([AC_LIB_LINKFLAGS_BODY],\n[\n  AC_REQUIRE([AC_LIB_PREPARE_MULTILIB])\n  define([NAME],[translit([$1],[abcdefghijklmnopqrstuvwxyz./-],\n                               [ABCDEFGHIJKLMNOPQRSTUVWXYZ___])])\n  dnl By default, look in $includedir and $libdir.\n  use_additional=yes\n  AC_LIB_WITH_FINAL_PREFIX([\n    eval additional_includedir=\\\"$includedir\\\"\n    eval additional_libdir=\\\"$libdir\\\"\n  ])\n  AC_LIB_ARG_WITH([lib$1-prefix],\n[  --with-lib$1-prefix[=DIR]  search for lib$1 in DIR/include and DIR/lib\n  --without-lib$1-prefix     don't search for lib$1 in includedir and libdir],\n[\n    if test \"X$withval\" = \"Xno\"; then\n      use_additional=no\n    else\n      if test \"X$withval\" = \"X\"; then\n        AC_LIB_WITH_FINAL_PREFIX([\n          eval additional_includedir=\\\"$includedir\\\"\n          eval additional_libdir=\\\"$libdir\\\"\n        ])\n      else\n        additional_includedir=\"$withval/include\"\n        additional_libdir=\"$withval/$acl_libdirstem\"\n      fi\n    fi\n])\n  dnl Search the library and its dependencies in $additional_libdir and\n  dnl $LDFLAGS. Using breadth-first-seach.\n  LIB[]NAME=\n  LTLIB[]NAME=\n  INC[]NAME=\n  rpathdirs=\n  ltrpathdirs=\n  names_already_handled=\n  names_next_round='$1 $2'\n  while test -n \"$names_next_round\"; do\n    names_this_round=\"$names_next_round\"\n    names_next_round=\n    for name in $names_this_round; do\n      already_handled=\n      for n in $names_already_handled; do\n        if test \"$n\" = \"$name\"; then\n          already_handled=yes\n          break\n        fi\n      done\n      if test -z \"$already_handled\"; then\n        names_already_handled=\"$names_already_handled $name\"\n        dnl See if it was already located by an earlier AC_LIB_LINKFLAGS\n        dnl or AC_LIB_HAVE_LINKFLAGS call.\n        uppername=`echo \"$name\" | sed -e 'y|abcdefghijklmnopqrstuvwxyz./-|ABCDEFGHIJKLMNOPQRSTUVWXYZ___|'`\n        eval value=\\\"\\$HAVE_LIB$uppername\\\"\n        if test -n \"$value\"; then\n          if test \"$value\" = yes; then\n            eval value=\\\"\\$LIB$uppername\\\"\n            test -z \"$value\" || LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }$value\"\n            eval value=\\\"\\$LTLIB$uppername\\\"\n            test -z \"$value\" || LTLIB[]NAME=\"${LTLIB[]NAME}${LTLIB[]NAME:+ }$value\"\n          else\n            dnl An earlier call to AC_LIB_HAVE_LINKFLAGS has determined\n            dnl that this library doesn't exist. So just drop it.\n            :\n          fi\n        else\n          dnl Search the library lib$name in $additional_libdir and $LDFLAGS\n          dnl and the already constructed $LIBNAME/$LTLIBNAME.\n          found_dir=\n          found_la=\n          found_so=\n          found_a=\n          if test $use_additional = yes; then\n            if test -n \"$shlibext\" \\\n               && { test -f \"$additional_libdir/lib$name.$shlibext\" \\\n                    || { test \"$shlibext\" = dll \\\n                         && test -f \"$additional_libdir/lib$name.dll.a\"; }; }; then\n              found_dir=\"$additional_libdir\"\n              if test -f \"$additional_libdir/lib$name.$shlibext\"; then\n                found_so=\"$additional_libdir/lib$name.$shlibext\"\n              else\n                found_so=\"$additional_libdir/lib$name.dll.a\"\n              fi\n              if test -f \"$additional_libdir/lib$name.la\"; then\n                found_la=\"$additional_libdir/lib$name.la\"\n              fi\n            else\n              if test -f \"$additional_libdir/lib$name.$libext\"; then\n                found_dir=\"$additional_libdir\"\n                found_a=\"$additional_libdir/lib$name.$libext\"\n                if test -f \"$additional_libdir/lib$name.la\"; then\n                  found_la=\"$additional_libdir/lib$name.la\"\n                fi\n              fi\n            fi\n          fi\n          if test \"X$found_dir\" = \"X\"; then\n            for x in $LDFLAGS $LTLIB[]NAME; do\n              AC_LIB_WITH_FINAL_PREFIX([eval x=\\\"$x\\\"])\n              case \"$x\" in\n                -L*)\n                  dir=`echo \"X$x\" | sed -e 's/^X-L//'`\n                  if test -n \"$shlibext\" \\\n                     && { test -f \"$dir/lib$name.$shlibext\" \\\n                          || { test \"$shlibext\" = dll \\\n                               && test -f \"$dir/lib$name.dll.a\"; }; }; then\n                    found_dir=\"$dir\"\n                    if test -f \"$dir/lib$name.$shlibext\"; then\n                      found_so=\"$dir/lib$name.$shlibext\"\n                    else\n                      found_so=\"$dir/lib$name.dll.a\"\n                    fi\n                    if test -f \"$dir/lib$name.la\"; then\n                      found_la=\"$dir/lib$name.la\"\n                    fi\n                  else\n                    if test -f \"$dir/lib$name.$libext\"; then\n                      found_dir=\"$dir\"\n                      found_a=\"$dir/lib$name.$libext\"\n                      if test -f \"$dir/lib$name.la\"; then\n                        found_la=\"$dir/lib$name.la\"\n                      fi\n                    fi\n                  fi\n                  ;;\n              esac\n              if test \"X$found_dir\" != \"X\"; then\n                break\n              fi\n            done\n          fi\n          if test \"X$found_dir\" != \"X\"; then\n            dnl Found the library.\n            LTLIB[]NAME=\"${LTLIB[]NAME}${LTLIB[]NAME:+ }-L$found_dir -l$name\"\n            if test \"X$found_so\" != \"X\"; then\n              dnl Linking with a shared library. We attempt to hardcode its\n              dnl directory into the executable's runpath, unless it's the\n              dnl standard /usr/lib.\n              if test \"$enable_rpath\" = no || test \"X$found_dir\" = \"X/usr/$acl_libdirstem\"; then\n                dnl No hardcoding is needed.\n                LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }$found_so\"\n              else\n                dnl Use an explicit option to hardcode DIR into the resulting\n                dnl binary.\n                dnl Potentially add DIR to ltrpathdirs.\n                dnl The ltrpathdirs will be appended to $LTLIBNAME at the end.\n                haveit=\n                for x in $ltrpathdirs; do\n                  if test \"X$x\" = \"X$found_dir\"; then\n                    haveit=yes\n                    break\n                  fi\n                done\n                if test -z \"$haveit\"; then\n                  ltrpathdirs=\"$ltrpathdirs $found_dir\"\n                fi\n                dnl The hardcoding into $LIBNAME is system dependent.\n                if test \"$hardcode_direct\" = yes; then\n                  dnl Using DIR/libNAME.so during linking hardcodes DIR into the\n                  dnl resulting binary.\n                  LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }$found_so\"\n                else\n                  if test -n \"$hardcode_libdir_flag_spec\" && test \"$hardcode_minus_L\" = no; then\n                    dnl Use an explicit option to hardcode DIR into the resulting\n                    dnl binary.\n                    LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }$found_so\"\n                    dnl Potentially add DIR to rpathdirs.\n                    dnl The rpathdirs will be appended to $LIBNAME at the end.\n                    haveit=\n                    for x in $rpathdirs; do\n                      if test \"X$x\" = \"X$found_dir\"; then\n                        haveit=yes\n                        break\n                      fi\n                    done\n                    if test -z \"$haveit\"; then\n                      rpathdirs=\"$rpathdirs $found_dir\"\n                    fi\n                  else\n                    dnl Rely on \"-L$found_dir\".\n                    dnl But don't add it if it's already contained in the LDFLAGS\n                    dnl or the already constructed $LIBNAME\n                    haveit=\n                    for x in $LDFLAGS $LIB[]NAME; do\n                      AC_LIB_WITH_FINAL_PREFIX([eval x=\\\"$x\\\"])\n                      if test \"X$x\" = \"X-L$found_dir\"; then\n                        haveit=yes\n                        break\n                      fi\n                    done\n                    if test -z \"$haveit\"; then\n                      LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }-L$found_dir\"\n                    fi\n                    if test \"$hardcode_minus_L\" != no; then\n                      dnl FIXME: Not sure whether we should use\n                      dnl \"-L$found_dir -l$name\" or \"-L$found_dir $found_so\"\n                      dnl here.\n                      LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }$found_so\"\n                    else\n                      dnl We cannot use $hardcode_runpath_var and LD_RUN_PATH\n                      dnl here, because this doesn't fit in flags passed to the\n                      dnl compiler. So give up. No hardcoding. This affects only\n                      dnl very old systems.\n                      dnl FIXME: Not sure whether we should use\n                      dnl \"-L$found_dir -l$name\" or \"-L$found_dir $found_so\"\n                      dnl here.\n                      LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }-l$name\"\n                    fi\n                  fi\n                fi\n              fi\n            else\n              if test \"X$found_a\" != \"X\"; then\n                dnl Linking with a static library.\n                LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }$found_a\"\n              else\n                dnl We shouldn't come here, but anyway it's good to have a\n                dnl fallback.\n                LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }-L$found_dir -l$name\"\n              fi\n            fi\n            dnl Assume the include files are nearby.\n            additional_includedir=\n            case \"$found_dir\" in\n              */$acl_libdirstem | */$acl_libdirstem/)\n                basedir=`echo \"X$found_dir\" | sed -e 's,^X,,' -e \"s,/$acl_libdirstem/\"'*$,,'`\n                additional_includedir=\"$basedir/include\"\n                ;;\n            esac\n            if test \"X$additional_includedir\" != \"X\"; then\n              dnl Potentially add $additional_includedir to $INCNAME.\n              dnl But don't add it\n              dnl   1. if it's the standard /usr/include,\n              dnl   2. if it's /usr/local/include and we are using GCC on Linux,\n              dnl   3. if it's already present in $CPPFLAGS or the already\n              dnl      constructed $INCNAME,\n              dnl   4. if it doesn't exist as a directory.\n              if test \"X$additional_includedir\" != \"X/usr/include\"; then\n                haveit=\n                if test \"X$additional_includedir\" = \"X/usr/local/include\"; then\n                  if test -n \"$GCC\"; then\n                    case $host_os in\n                      linux* | gnu* | k*bsd*-gnu) haveit=yes;;\n                    esac\n                  fi\n                fi\n                if test -z \"$haveit\"; then\n                  for x in $CPPFLAGS $INC[]NAME; do\n                    AC_LIB_WITH_FINAL_PREFIX([eval x=\\\"$x\\\"])\n                    if test \"X$x\" = \"X-I$additional_includedir\"; then\n                      haveit=yes\n                      break\n                    fi\n                  done\n                  if test -z \"$haveit\"; then\n                    if test -d \"$additional_includedir\"; then\n                      dnl Really add $additional_includedir to $INCNAME.\n                      INC[]NAME=\"${INC[]NAME}${INC[]NAME:+ }-I$additional_includedir\"\n                    fi\n                  fi\n                fi\n              fi\n            fi\n            dnl Look for dependencies.\n            if test -n \"$found_la\"; then\n              dnl Read the .la file. It defines the variables\n              dnl dlname, library_names, old_library, dependency_libs, current,\n              dnl age, revision, installed, dlopen, dlpreopen, libdir.\n              save_libdir=\"$libdir\"\n              case \"$found_la\" in\n                */* | *\\\\*) . \"$found_la\" ;;\n                *) . \"./$found_la\" ;;\n              esac\n              libdir=\"$save_libdir\"\n              dnl We use only dependency_libs.\n              for dep in $dependency_libs; do\n                case \"$dep\" in\n                  -L*)\n                    additional_libdir=`echo \"X$dep\" | sed -e 's/^X-L//'`\n                    dnl Potentially add $additional_libdir to $LIBNAME and $LTLIBNAME.\n                    dnl But don't add it\n                    dnl   1. if it's the standard /usr/lib,\n                    dnl   2. if it's /usr/local/lib and we are using GCC on Linux,\n                    dnl   3. if it's already present in $LDFLAGS or the already\n                    dnl      constructed $LIBNAME,\n                    dnl   4. if it doesn't exist as a directory.\n                    if test \"X$additional_libdir\" != \"X/usr/$acl_libdirstem\"; then\n                      haveit=\n                      if test \"X$additional_libdir\" = \"X/usr/local/$acl_libdirstem\"; then\n                        if test -n \"$GCC\"; then\n                          case $host_os in\n                            linux* | gnu* | k*bsd*-gnu) haveit=yes;;\n                          esac\n                        fi\n                      fi\n                      if test -z \"$haveit\"; then\n                        haveit=\n                        for x in $LDFLAGS $LIB[]NAME; do\n                          AC_LIB_WITH_FINAL_PREFIX([eval x=\\\"$x\\\"])\n                          if test \"X$x\" = \"X-L$additional_libdir\"; then\n                            haveit=yes\n                            break\n                          fi\n                        done\n                        if test -z \"$haveit\"; then\n                          if test -d \"$additional_libdir\"; then\n                            dnl Really add $additional_libdir to $LIBNAME.\n                            LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }-L$additional_libdir\"\n                          fi\n                        fi\n                        haveit=\n                        for x in $LDFLAGS $LTLIB[]NAME; do\n                          AC_LIB_WITH_FINAL_PREFIX([eval x=\\\"$x\\\"])\n                          if test \"X$x\" = \"X-L$additional_libdir\"; then\n                            haveit=yes\n                            break\n                          fi\n                        done\n                        if test -z \"$haveit\"; then\n                          if test -d \"$additional_libdir\"; then\n                            dnl Really add $additional_libdir to $LTLIBNAME.\n                            LTLIB[]NAME=\"${LTLIB[]NAME}${LTLIB[]NAME:+ }-L$additional_libdir\"\n                          fi\n                        fi\n                      fi\n                    fi\n                    ;;\n                  -R*)\n                    dir=`echo \"X$dep\" | sed -e 's/^X-R//'`\n                    if test \"$enable_rpath\" != no; then\n                      dnl Potentially add DIR to rpathdirs.\n                      dnl The rpathdirs will be appended to $LIBNAME at the end.\n                      haveit=\n                      for x in $rpathdirs; do\n                        if test \"X$x\" = \"X$dir\"; then\n                          haveit=yes\n                          break\n                        fi\n                      done\n                      if test -z \"$haveit\"; then\n                        rpathdirs=\"$rpathdirs $dir\"\n                      fi\n                      dnl Potentially add DIR to ltrpathdirs.\n                      dnl The ltrpathdirs will be appended to $LTLIBNAME at the end.\n                      haveit=\n                      for x in $ltrpathdirs; do\n                        if test \"X$x\" = \"X$dir\"; then\n                          haveit=yes\n                          break\n                        fi\n                      done\n                      if test -z \"$haveit\"; then\n                        ltrpathdirs=\"$ltrpathdirs $dir\"\n                      fi\n                    fi\n                    ;;\n                  -l*)\n                    dnl Handle this in the next round.\n                    names_next_round=\"$names_next_round \"`echo \"X$dep\" | sed -e 's/^X-l//'`\n                    ;;\n                  *.la)\n                    dnl Handle this in the next round. Throw away the .la's\n                    dnl directory; it is already contained in a preceding -L\n                    dnl option.\n                    names_next_round=\"$names_next_round \"`echo \"X$dep\" | sed -e 's,^X.*/,,' -e 's,^lib,,' -e 's,\\.la$,,'`\n                    ;;\n                  *)\n                    dnl Most likely an immediate library name.\n                    LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }$dep\"\n                    LTLIB[]NAME=\"${LTLIB[]NAME}${LTLIB[]NAME:+ }$dep\"\n                    ;;\n                esac\n              done\n            fi\n          else\n            dnl Didn't find the library; assume it is in the system directories\n            dnl known to the linker and runtime loader. (All the system\n            dnl directories known to the linker should also be known to the\n            dnl runtime loader, otherwise the system is severely misconfigured.)\n            LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }-l$name\"\n            LTLIB[]NAME=\"${LTLIB[]NAME}${LTLIB[]NAME:+ }-l$name\"\n          fi\n        fi\n      fi\n    done\n  done\n  if test \"X$rpathdirs\" != \"X\"; then\n    if test -n \"$hardcode_libdir_separator\"; then\n      dnl Weird platform: only the last -rpath option counts, the user must\n      dnl pass all path elements in one option. We can arrange that for a\n      dnl single library, but not when more than one $LIBNAMEs are used.\n      alldirs=\n      for found_dir in $rpathdirs; do\n        alldirs=\"${alldirs}${alldirs:+$hardcode_libdir_separator}$found_dir\"\n      done\n      dnl Note: hardcode_libdir_flag_spec uses $libdir and $wl.\n      acl_save_libdir=\"$libdir\"\n      libdir=\"$alldirs\"\n      eval flag=\\\"$hardcode_libdir_flag_spec\\\"\n      libdir=\"$acl_save_libdir\"\n      LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }$flag\"\n    else\n      dnl The -rpath options are cumulative.\n      for found_dir in $rpathdirs; do\n        acl_save_libdir=\"$libdir\"\n        libdir=\"$found_dir\"\n        eval flag=\\\"$hardcode_libdir_flag_spec\\\"\n        libdir=\"$acl_save_libdir\"\n        LIB[]NAME=\"${LIB[]NAME}${LIB[]NAME:+ }$flag\"\n      done\n    fi\n  fi\n  if test \"X$ltrpathdirs\" != \"X\"; then\n    dnl When using libtool, the option that works for both libraries and\n    dnl executables is -R. The -R options are cumulative.\n    for found_dir in $ltrpathdirs; do\n      LTLIB[]NAME=\"${LTLIB[]NAME}${LTLIB[]NAME:+ }-R$found_dir\"\n    done\n  fi\n])\n\ndnl AC_LIB_APPENDTOVAR(VAR, CONTENTS) appends the elements of CONTENTS to VAR,\ndnl unless already present in VAR.\ndnl Works only for CPPFLAGS, not for LIB* variables because that sometimes\ndnl contains two or three consecutive elements that belong together.\nAC_DEFUN([AC_LIB_APPENDTOVAR],\n[\n  for element in [$2]; do\n    haveit=\n    for x in $[$1]; do\n      AC_LIB_WITH_FINAL_PREFIX([eval x=\\\"$x\\\"])\n      if test \"X$x\" = \"X$element\"; then\n        haveit=yes\n        break\n      fi\n    done\n    if test -z \"$haveit\"; then\n      [$1]=\"${[$1]}${[$1]:+ }$element\"\n    fi\n  done\n])\n\ndnl For those cases where a variable contains several -L and -l options\ndnl referring to unknown libraries and directories, this macro determines the\ndnl necessary additional linker options for the runtime path.\ndnl AC_LIB_LINKFLAGS_FROM_LIBS([LDADDVAR], [LIBSVALUE], [USE-LIBTOOL])\ndnl sets LDADDVAR to linker options needed together with LIBSVALUE.\ndnl If USE-LIBTOOL evaluates to non-empty, linking with libtool is assumed,\ndnl otherwise linking without libtool is assumed.\nAC_DEFUN([AC_LIB_LINKFLAGS_FROM_LIBS],\n[\n  AC_REQUIRE([AC_LIB_RPATH])\n  AC_REQUIRE([AC_LIB_PREPARE_MULTILIB])\n  $1=\n  if test \"$enable_rpath\" != no; then\n    if test -n \"$hardcode_libdir_flag_spec\" && test \"$hardcode_minus_L\" = no; then\n      dnl Use an explicit option to hardcode directories into the resulting\n      dnl binary.\n      rpathdirs=\n      next=\n      for opt in $2; do\n        if test -n \"$next\"; then\n          dir=\"$next\"\n          dnl No need to hardcode the standard /usr/lib.\n          if test \"X$dir\" != \"X/usr/$acl_libdirstem\"; then\n            rpathdirs=\"$rpathdirs $dir\"\n          fi\n          next=\n        else\n          case $opt in\n            -L) next=yes ;;\n            -L*) dir=`echo \"X$opt\" | sed -e 's,^X-L,,'`\n                 dnl No need to hardcode the standard /usr/lib.\n                 if test \"X$dir\" != \"X/usr/$acl_libdirstem\"; then\n                   rpathdirs=\"$rpathdirs $dir\"\n                 fi\n                 next= ;;\n            *) next= ;;\n          esac\n        fi\n      done\n      if test \"X$rpathdirs\" != \"X\"; then\n        if test -n \"\"$3\"\"; then\n          dnl libtool is used for linking. Use -R options.\n          for dir in $rpathdirs; do\n            $1=\"${$1}${$1:+ }-R$dir\"\n          done\n        else\n          dnl The linker is used for linking directly.\n          if test -n \"$hardcode_libdir_separator\"; then\n            dnl Weird platform: only the last -rpath option counts, the user\n            dnl must pass all path elements in one option.\n            alldirs=\n            for dir in $rpathdirs; do\n              alldirs=\"${alldirs}${alldirs:+$hardcode_libdir_separator}$dir\"\n            done\n            acl_save_libdir=\"$libdir\"\n            libdir=\"$alldirs\"\n            eval flag=\\\"$hardcode_libdir_flag_spec\\\"\n            libdir=\"$acl_save_libdir\"\n            $1=\"$flag\"\n          else\n            dnl The -rpath options are cumulative.\n            for dir in $rpathdirs; do\n              acl_save_libdir=\"$libdir\"\n              libdir=\"$dir\"\n              eval flag=\\\"$hardcode_libdir_flag_spec\\\"\n              libdir=\"$acl_save_libdir\"\n              $1=\"${$1}${$1:+ }$flag\"\n            done\n          fi\n        fi\n      fi\n    fi\n  fi\n  AC_SUBST([$1])\n])\n",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/tokudb/PerconaFT/third_party/xz-4.999.9beta/build-aux/ltmain.sh": "# Generated from ltmain.m4sh.\n\n# ltmain.sh (GNU libtool) 2.2.6\n# Written by Gordon Matzigkeit <gord@gnu.ai.mit.edu>, 1996\n\n# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004, 2005, 2006, 2007 2008 Free Software Foundation, Inc.\n# This is free software; see the source for copying conditions.  There is NO\n# warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\n# GNU Libtool is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation; either version 2 of the License, or\n# (at your option) any later version.\n#\n# As a special exception to the GNU General Public License,\n# if you distribute this file as part of a program or library that\n# is built using GNU Libtool, you may include this file under the\n# same distribution terms that you use for the rest of that program.\n#\n# GNU Libtool is distributed in the hope that it will be useful, but\n# WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with GNU Libtool; see the file COPYING.  If not, a copy\n# can be downloaded from http://www.gnu.org/licenses/gpl.html,\n# or obtained by writing to the Free Software Foundation, Inc.,\n# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1335  USA.\n\n# Usage: $progname [OPTION]... [MODE-ARG]...\n#\n# Provide generalized library-building support services.\n#\n#     --config             show all configuration variables\n#     --debug              enable verbose shell tracing\n# -n, --dry-run            display commands without modifying any files\n#     --features           display basic configuration information and exit\n#     --mode=MODE          use operation mode MODE\n#     --preserve-dup-deps  don't remove duplicate dependency libraries\n#     --quiet, --silent    don't print informational messages\n#     --tag=TAG            use configuration variables from tag TAG\n# -v, --verbose            print informational messages (default)\n#     --version            print version information\n# -h, --help               print short or long help message\n#\n# MODE must be one of the following:\n#\n#       clean              remove files from the build directory\n#       compile            compile a source file into a libtool object\n#       execute            automatically set library path, then run a program\n#       finish             complete the installation of libtool libraries\n#       install            install libraries or executables\n#       link               create a library or an executable\n#       uninstall          remove libraries from an installed directory\n#\n# MODE-ARGS vary depending on the MODE.\n# Try `$progname --help --mode=MODE' for a more detailed description of MODE.\n#\n# When reporting a bug, please describe a test case to reproduce it and\n# include the following information:\n#\n#       host-triplet:\t$host\n#       shell:\t\t$SHELL\n#       compiler:\t\t$LTCC\n#       compiler flags:\t\t$LTCFLAGS\n#       linker:\t\t$LD (gnu? $with_gnu_ld)\n#       $progname:\t\t(GNU libtool) 2.2.6\n#       automake:\t\t$automake_version\n#       autoconf:\t\t$autoconf_version\n#\n# Report bugs to <bug-libtool@gnu.org>.\n\nPROGRAM=ltmain.sh\nPACKAGE=libtool\nVERSION=2.2.6\nTIMESTAMP=\"\"\npackage_revision=1.3012\n\n# Be Bourne compatible\nif test -n \"${ZSH_VERSION+set}\" && (emulate sh) >/dev/null 2>&1; then\n  emulate sh\n  NULLCMD=:\n  # Zsh 3.x and 4.x performs word splitting on ${1+\"$@\"}, which\n  # is contrary to our usage.  Disable this feature.\n  alias -g '${1+\"$@\"}'='\"$@\"'\n  setopt NO_GLOB_SUBST\nelse\n  case `(set -o) 2>/dev/null` in *posix*) set -o posix;; esac\nfi\nBIN_SH=xpg4; export BIN_SH # for Tru64\nDUALCASE=1; export DUALCASE # for MKS sh\n\n# NLS nuisances: We save the old values to restore during execute mode.\n# Only set LANG and LC_ALL to C if already set.\n# These must not be set unconditionally because not all systems understand\n# e.g. LANG=C (notably SCO).\nlt_user_locale=\nlt_safe_locale=\nfor lt_var in LANG LANGUAGE LC_ALL LC_CTYPE LC_COLLATE LC_MESSAGES\ndo\n  eval \"if test \\\"\\${$lt_var+set}\\\" = set; then\n          save_$lt_var=\\$$lt_var\n          $lt_var=C\n\t  export $lt_var\n\t  lt_user_locale=\\\"$lt_var=\\\\\\$save_\\$lt_var; \\$lt_user_locale\\\"\n\t  lt_safe_locale=\\\"$lt_var=C; \\$lt_safe_locale\\\"\n\tfi\"\ndone\n\n$lt_unset CDPATH\n\n\n\n\n\n: ${CP=\"cp -f\"}\n: ${ECHO=\"echo\"}\n: ${EGREP=\"/usr/bin/grep -E\"}\n: ${FGREP=\"/usr/bin/grep -F\"}\n: ${GREP=\"/usr/bin/grep\"}\n: ${LN_S=\"ln -s\"}\n: ${MAKE=\"make\"}\n: ${MKDIR=\"mkdir\"}\n: ${MV=\"mv -f\"}\n: ${RM=\"rm -f\"}\n: ${SED=\"/opt/local/bin/gsed\"}\n: ${SHELL=\"${CONFIG_SHELL-/bin/sh}\"}\n: ${Xsed=\"$SED -e 1s/^X//\"}\n\n# Global variables:\nEXIT_SUCCESS=0\nEXIT_FAILURE=1\nEXIT_MISMATCH=63  # $? = 63 is used to indicate version mismatch to missing.\nEXIT_SKIP=77\t  # $? = 77 is used to indicate a skipped test to automake.\n\nexit_status=$EXIT_SUCCESS\n\n# Make sure IFS has a sensible default\nlt_nl='\n'\nIFS=\" \t$lt_nl\"\n\ndirname=\"s,/[^/]*$,,\"\nbasename=\"s,^.*/,,\"\n\n# func_dirname_and_basename file append nondir_replacement\n# perform func_basename and func_dirname in a single function\n# call:\n#   dirname:  Compute the dirname of FILE.  If nonempty,\n#             add APPEND to the result, otherwise set result\n#             to NONDIR_REPLACEMENT.\n#             value returned in \"$func_dirname_result\"\n#   basename: Compute filename of FILE.\n#             value retuned in \"$func_basename_result\"\n# Implementation must be kept synchronized with func_dirname\n# and func_basename. For efficiency, we do not delegate to\n# those functions but instead duplicate the functionality here.\nfunc_dirname_and_basename ()\n{\n  # Extract subdirectory from the argument.\n  func_dirname_result=`$ECHO \"X${1}\" | $Xsed -e \"$dirname\"`\n  if test \"X$func_dirname_result\" = \"X${1}\"; then\n    func_dirname_result=\"${3}\"\n  else\n    func_dirname_result=\"$func_dirname_result${2}\"\n  fi\n  func_basename_result=`$ECHO \"X${1}\" | $Xsed -e \"$basename\"`\n}\n\n# Generated shell functions inserted here.\n\n# Work around backward compatibility issue on IRIX 6.5. On IRIX 6.4+, sh\n# is ksh but when the shell is invoked as \"sh\" and the current value of\n# the _XPG environment variable is not equal to 1 (one), the special\n# positional parameter $0, within a function call, is the name of the\n# function.\nprogpath=\"$0\"\n\n# The name of this program:\n# In the unlikely event $progname began with a '-', it would play havoc with\n# func_echo (imagine progname=-n), so we prepend ./ in that case:\nfunc_dirname_and_basename \"$progpath\"\nprogname=$func_basename_result\ncase $progname in\n  -*) progname=./$progname ;;\nesac\n\n# Make sure we have an absolute path for reexecution:\ncase $progpath in\n  [\\\\/]*|[A-Za-z]:\\\\*) ;;\n  *[\\\\/]*)\n     progdir=$func_dirname_result\n     progdir=`cd \"$progdir\" && pwd`\n     progpath=\"$progdir/$progname\"\n     ;;\n  *)\n     save_IFS=\"$IFS\"\n     IFS=:\n     for progdir in $PATH; do\n       IFS=\"$save_IFS\"\n       test -x \"$progdir/$progname\" && break\n     done\n     IFS=\"$save_IFS\"\n     test -n \"$progdir\" || progdir=`pwd`\n     progpath=\"$progdir/$progname\"\n     ;;\nesac\n\n# Sed substitution that helps us do robust quoting.  It backslashifies\n# metacharacters that are still active within double-quoted strings.\nXsed=\"${SED}\"' -e 1s/^X//'\nsed_quote_subst='s/\\([`\"$\\\\]\\)/\\\\\\1/g'\n\n# Same as above, but do not quote variable references.\ndouble_quote_subst='s/\\([\"`\\\\]\\)/\\\\\\1/g'\n\n# Re-`\\' parameter expansions in output of double_quote_subst that were\n# `\\'-ed in input to the same.  If an odd number of `\\' preceded a '$'\n# in input to double_quote_subst, that '$' was protected from expansion.\n# Since each input `\\' is now two `\\'s, look for any number of runs of\n# four `\\'s followed by two `\\'s and then a '$'.  `\\' that '$'.\nbs='\\\\'\nbs2='\\\\\\\\'\nbs4='\\\\\\\\\\\\\\\\'\ndollar='\\$'\nsed_double_backslash=\"\\\n  s/$bs4/&\\\\\n/g\n  s/^$bs2$dollar/$bs&/\n  s/\\\\([^$bs]\\\\)$bs2$dollar/\\\\1$bs2$bs$dollar/g\n  s/\\n//g\"\n\n# Standard options:\nopt_dry_run=false\nopt_help=false\nopt_quiet=false\nopt_verbose=false\nopt_warning=:\n\n# func_echo arg...\n# Echo program name prefixed message, along with the current mode\n# name if it has been set yet.\nfunc_echo ()\n{\n    $ECHO \"$progname${mode+: }$mode: $*\"\n}\n\n# func_verbose arg...\n# Echo program name prefixed message in verbose mode only.\nfunc_verbose ()\n{\n    $opt_verbose && func_echo ${1+\"$@\"}\n\n    # A bug in bash halts the script if the last line of a function\n    # fails when set -e is in force, so we need another command to\n    # work around that:\n    :\n}\n\n# func_error arg...\n# Echo program name prefixed message to standard error.\nfunc_error ()\n{\n    $ECHO \"$progname${mode+: }$mode: \"${1+\"$@\"} 1>&2\n}\n\n# func_warning arg...\n# Echo program name prefixed warning message to standard error.\nfunc_warning ()\n{\n    $opt_warning && $ECHO \"$progname${mode+: }$mode: warning: \"${1+\"$@\"} 1>&2\n\n    # bash bug again:\n    :\n}\n\n# func_fatal_error arg...\n# Echo program name prefixed message to standard error, and exit.\nfunc_fatal_error ()\n{\n    func_error ${1+\"$@\"}\n    exit $EXIT_FAILURE\n}\n\n# func_fatal_help arg...\n# Echo program name prefixed message to standard error, followed by\n# a help hint, and exit.\nfunc_fatal_help ()\n{\n    func_error ${1+\"$@\"}\n    func_fatal_error \"$help\"\n}\nhelp=\"Try \\`$progname --help' for more information.\"  ## default\n\n\n# func_grep expression filename\n# Check whether EXPRESSION matches any line of FILENAME, without output.\nfunc_grep ()\n{\n    $GREP \"$1\" \"$2\" >/dev/null 2>&1\n}\n\n\n# func_mkdir_p directory-path\n# Make sure the entire path to DIRECTORY-PATH is available.\nfunc_mkdir_p ()\n{\n    my_directory_path=\"$1\"\n    my_dir_list=\n\n    if test -n \"$my_directory_path\" && test \"$opt_dry_run\" != \":\"; then\n\n      # Protect directory names starting with `-'\n      case $my_directory_path in\n        -*) my_directory_path=\"./$my_directory_path\" ;;\n      esac\n\n      # While some portion of DIR does not yet exist...\n      while test ! -d \"$my_directory_path\"; do\n        # ...make a list in topmost first order.  Use a colon delimited\n\t# list incase some portion of path contains whitespace.\n        my_dir_list=\"$my_directory_path:$my_dir_list\"\n\n        # If the last portion added has no slash in it, the list is done\n        case $my_directory_path in */*) ;; *) break ;; esac\n\n        # ...otherwise throw away the child directory and loop\n        my_directory_path=`$ECHO \"X$my_directory_path\" | $Xsed -e \"$dirname\"`\n      done\n      my_dir_list=`$ECHO \"X$my_dir_list\" | $Xsed -e 's,:*$,,'`\n\n      save_mkdir_p_IFS=\"$IFS\"; IFS=':'\n      for my_dir in $my_dir_list; do\n\tIFS=\"$save_mkdir_p_IFS\"\n        # mkdir can fail with a `File exist' error if two processes\n        # try to create one of the directories concurrently.  Don't\n        # stop in that case!\n        $MKDIR \"$my_dir\" 2>/dev/null || :\n      done\n      IFS=\"$save_mkdir_p_IFS\"\n\n      # Bail out if we (or some other process) failed to create a directory.\n      test -d \"$my_directory_path\" || \\\n        func_fatal_error \"Failed to create \\`$1'\"\n    fi\n}\n\n\n# func_mktempdir [string]\n# Make a temporary directory that won't clash with other running\n# libtool processes, and avoids race conditions if possible.  If\n# given, STRING is the basename for that directory.\nfunc_mktempdir ()\n{\n    my_template=\"${TMPDIR-/tmp}/${1-$progname}\"\n\n    if test \"$opt_dry_run\" = \":\"; then\n      # Return a directory name, but don't create it in dry-run mode\n      my_tmpdir=\"${my_template}-$$\"\n    else\n\n      # If mktemp works, use that first and foremost\n      my_tmpdir=`mktemp -d \"${my_template}-XXXXXXXX\" 2>/dev/null`\n\n      if test ! -d \"$my_tmpdir\"; then\n        # Failing that, at least try and use $RANDOM to avoid a race\n        my_tmpdir=\"${my_template}-${RANDOM-0}$$\"\n\n        save_mktempdir_umask=`umask`\n        umask 0077\n        $MKDIR \"$my_tmpdir\"\n        umask $save_mktempdir_umask\n      fi\n\n      # If we're not in dry-run mode, bomb out on failure\n      test -d \"$my_tmpdir\" || \\\n        func_fatal_error \"cannot create temporary directory \\`$my_tmpdir'\"\n    fi\n\n    $ECHO \"X$my_tmpdir\" | $Xsed\n}\n\n\n# func_quote_for_eval arg\n# Aesthetically quote ARG to be evaled later.\n# This function returns two values: FUNC_QUOTE_FOR_EVAL_RESULT\n# is double-quoted, suitable for a subsequent eval, whereas\n# FUNC_QUOTE_FOR_EVAL_UNQUOTED_RESULT has merely all characters\n# which are still active within double quotes backslashified.\nfunc_quote_for_eval ()\n{\n    case $1 in\n      *[\\\\\\`\\\"\\$]*)\n\tfunc_quote_for_eval_unquoted_result=`$ECHO \"X$1\" | $Xsed -e \"$sed_quote_subst\"` ;;\n      *)\n        func_quote_for_eval_unquoted_result=\"$1\" ;;\n    esac\n\n    case $func_quote_for_eval_unquoted_result in\n      # Double-quote args containing shell metacharacters to delay\n      # word splitting, command substitution and and variable\n      # expansion for a subsequent eval.\n      # Many Bourne shells cannot handle close brackets correctly\n      # in scan sets, so we specify it separately.\n      *[\\[\\~\\#\\^\\&\\*\\(\\)\\{\\}\\|\\;\\<\\>\\?\\'\\ \\\t]*|*]*|\"\")\n        func_quote_for_eval_result=\"\\\"$func_quote_for_eval_unquoted_result\\\"\"\n        ;;\n      *)\n        func_quote_for_eval_result=\"$func_quote_for_eval_unquoted_result\"\n    esac\n}\n\n\n# func_quote_for_expand arg\n# Aesthetically quote ARG to be evaled later; same as above,\n# but do not quote variable references.\nfunc_quote_for_expand ()\n{\n    case $1 in\n      *[\\\\\\`\\\"]*)\n\tmy_arg=`$ECHO \"X$1\" | $Xsed \\\n\t    -e \"$double_quote_subst\" -e \"$sed_double_backslash\"` ;;\n      *)\n        my_arg=\"$1\" ;;\n    esac\n\n    case $my_arg in\n      # Double-quote args containing shell metacharacters to delay\n      # word splitting and command substitution for a subsequent eval.\n      # Many Bourne shells cannot handle close brackets correctly\n      # in scan sets, so we specify it separately.\n      *[\\[\\~\\#\\^\\&\\*\\(\\)\\{\\}\\|\\;\\<\\>\\?\\'\\ \\\t]*|*]*|\"\")\n        my_arg=\"\\\"$my_arg\\\"\"\n        ;;\n    esac\n\n    func_quote_for_expand_result=\"$my_arg\"\n}\n\n\n# func_show_eval cmd [fail_exp]\n# Unless opt_silent is true, then output CMD.  Then, if opt_dryrun is\n# not true, evaluate CMD.  If the evaluation of CMD fails, and FAIL_EXP\n# is given, then evaluate it.\nfunc_show_eval ()\n{\n    my_cmd=\"$1\"\n    my_fail_exp=\"${2-:}\"\n\n    ${opt_silent-false} || {\n      func_quote_for_expand \"$my_cmd\"\n      eval \"func_echo $func_quote_for_expand_result\"\n    }\n\n    if ${opt_dry_run-false}; then :; else\n      eval \"$my_cmd\"\n      my_status=$?\n      if test \"$my_status\" -eq 0; then :; else\n\teval \"(exit $my_status); $my_fail_exp\"\n      fi\n    fi\n}\n\n\n# func_show_eval_locale cmd [fail_exp]\n# Unless opt_silent is true, then output CMD.  Then, if opt_dryrun is\n# not true, evaluate CMD.  If the evaluation of CMD fails, and FAIL_EXP\n# is given, then evaluate it.  Use the saved locale for evaluation.\nfunc_show_eval_locale ()\n{\n    my_cmd=\"$1\"\n    my_fail_exp=\"${2-:}\"\n\n    ${opt_silent-false} || {\n      func_quote_for_expand \"$my_cmd\"\n      eval \"func_echo $func_quote_for_expand_result\"\n    }\n\n    if ${opt_dry_run-false}; then :; else\n      eval \"$lt_user_locale\n\t    $my_cmd\"\n      my_status=$?\n      eval \"$lt_safe_locale\"\n      if test \"$my_status\" -eq 0; then :; else\n\teval \"(exit $my_status); $my_fail_exp\"\n      fi\n    fi\n}\n\n\n\n\n\n# func_version\n# Echo version message to standard output and exit.\nfunc_version ()\n{\n    $SED -n '/^# '$PROGRAM' (GNU /,/# warranty; / {\n        s/^# //\n\ts/^# *$//\n        s/\\((C)\\)[ 0-9,-]*\\( [1-9][0-9]*\\)/\\1\\2/\n        p\n     }' < \"$progpath\"\n     exit $?\n}\n\n# func_usage\n# Echo short help message to standard output and exit.\nfunc_usage ()\n{\n    $SED -n '/^# Usage:/,/# -h/ {\n        s/^# //\n\ts/^# *$//\n\ts/\\$progname/'$progname'/\n\tp\n    }' < \"$progpath\"\n    $ECHO\n    $ECHO \"run \\`$progname --help | more' for full usage\"\n    exit $?\n}\n\n# func_help\n# Echo long help message to standard output and exit.\nfunc_help ()\n{\n    $SED -n '/^# Usage:/,/# Report bugs to/ {\n        s/^# //\n\ts/^# *$//\n\ts*\\$progname*'$progname'*\n\ts*\\$host*'\"$host\"'*\n\ts*\\$SHELL*'\"$SHELL\"'*\n\ts*\\$LTCC*'\"$LTCC\"'*\n\ts*\\$LTCFLAGS*'\"$LTCFLAGS\"'*\n\ts*\\$LD*'\"$LD\"'*\n\ts/\\$with_gnu_ld/'\"$with_gnu_ld\"'/\n\ts/\\$automake_version/'\"`(automake --version) 2>/dev/null |$SED 1q`\"'/\n\ts/\\$autoconf_version/'\"`(autoconf --version) 2>/dev/null |$SED 1q`\"'/\n\tp\n     }' < \"$progpath\"\n    exit $?\n}\n\n# func_missing_arg argname\n# Echo program name prefixed message to standard error and set global\n# exit_cmd.\nfunc_missing_arg ()\n{\n    func_error \"missing argument for $1\"\n    exit_cmd=exit\n}\n\nexit_cmd=:\n\n\n\n\n\n# Check that we have a working $ECHO.\nif test \"X$1\" = X--no-reexec; then\n  # Discard the --no-reexec flag, and continue.\n  shift\nelif test \"X$1\" = X--fallback-echo; then\n  # Avoid inline document here, it may be left over\n  :\nelif test \"X`{ $ECHO '\\t'; } 2>/dev/null`\" = 'X\\t'; then\n  # Yippee, $ECHO works!\n  :\nelse\n  # Restart under the correct shell, and then maybe $ECHO will work.\n  exec $SHELL \"$progpath\" --no-reexec ${1+\"$@\"}\nfi\n\nif test \"X$1\" = X--fallback-echo; then\n  # used as fallback echo\n  shift\n  cat <<EOF\n$*\nEOF\n  exit $EXIT_SUCCESS\nfi\n\nmagic=\"%%%MAGIC variable%%%\"\nmagic_exe=\"%%%MAGIC EXE variable%%%\"\n\n# Global variables.\n# $mode is unset\nnonopt=\nexecute_dlfiles=\npreserve_args=\nlo2o=\"s/\\\\.lo\\$/.${objext}/\"\no2lo=\"s/\\\\.${objext}\\$/.lo/\"\nextracted_archives=\nextracted_serial=0\n\nopt_dry_run=false\nopt_duplicate_deps=false\nopt_silent=false\nopt_debug=:\n\n# If this variable is set in any of the actions, the command in it\n# will be execed at the end.  This prevents here-documents from being\n# left over by shells.\nexec_cmd=\n\n# func_fatal_configuration arg...\n# Echo program name prefixed message to standard error, followed by\n# a configuration failure hint, and exit.\nfunc_fatal_configuration ()\n{\n    func_error ${1+\"$@\"}\n    func_error \"See the $PACKAGE documentation for more information.\"\n    func_fatal_error \"Fatal configuration error.\"\n}\n\n\n# func_config\n# Display the configuration for all the tags in this script.\nfunc_config ()\n{\n    re_begincf='^# ### BEGIN LIBTOOL'\n    re_endcf='^# ### END LIBTOOL'\n\n    # Default configuration.\n    $SED \"1,/$re_begincf CONFIG/d;/$re_endcf CONFIG/,\\$d\" < \"$progpath\"\n\n    # Now print the configurations for the tags.\n    for tagname in $taglist; do\n      $SED -n \"/$re_begincf TAG CONFIG: $tagname\\$/,/$re_endcf TAG CONFIG: $tagname\\$/p\" < \"$progpath\"\n    done\n\n    exit $?\n}\n\n# func_features\n# Display the features supported by this script.\nfunc_features ()\n{\n    $ECHO \"host: $host\"\n    if test \"$build_libtool_libs\" = yes; then\n      $ECHO \"enable shared libraries\"\n    else\n      $ECHO \"disable shared libraries\"\n    fi\n    if test \"$build_old_libs\" = yes; then\n      $ECHO \"enable static libraries\"\n    else\n      $ECHO \"disable static libraries\"\n    fi\n\n    exit $?\n}\n\n# func_enable_tag tagname\n# Verify that TAGNAME is valid, and either flag an error and exit, or\n# enable the TAGNAME tag.  We also add TAGNAME to the global $taglist\n# variable here.\nfunc_enable_tag ()\n{\n  # Global variable:\n  tagname=\"$1\"\n\n  re_begincf=\"^# ### BEGIN LIBTOOL TAG CONFIG: $tagname\\$\"\n  re_endcf=\"^# ### END LIBTOOL TAG CONFIG: $tagname\\$\"\n  sed_extractcf=\"/$re_begincf/,/$re_endcf/p\"\n\n  # Validate tagname.\n  case $tagname in\n    *[!-_A-Za-z0-9,/]*)\n      func_fatal_error \"invalid tag name: $tagname\"\n      ;;\n  esac\n\n  # Don't test for the \"default\" C tag, as we know it's\n  # there but not specially marked.\n  case $tagname in\n    CC) ;;\n    *)\n      if $GREP \"$re_begincf\" \"$progpath\" >/dev/null 2>&1; then\n\ttaglist=\"$taglist $tagname\"\n\n\t# Evaluate the configuration.  Be careful to quote the path\n\t# and the sed script, to avoid splitting on whitespace, but\n\t# also don't use non-portable quotes within backquotes within\n\t# quotes we have to do it in 2 steps:\n\textractedcf=`$SED -n -e \"$sed_extractcf\" < \"$progpath\"`\n\teval \"$extractedcf\"\n      else\n\tfunc_error \"ignoring unknown tag $tagname\"\n      fi\n      ;;\n  esac\n}\n\n# Parse options once, thoroughly.  This comes as soon as possible in\n# the script to make things like `libtool --version' happen quickly.\n{\n\n  # Shorthand for --mode=foo, only valid as the first argument\n  case $1 in\n  clean|clea|cle|cl)\n    shift; set dummy --mode clean ${1+\"$@\"}; shift\n    ;;\n  compile|compil|compi|comp|com|co|c)\n    shift; set dummy --mode compile ${1+\"$@\"}; shift\n    ;;\n  execute|execut|execu|exec|exe|ex|e)\n    shift; set dummy --mode execute ${1+\"$@\"}; shift\n    ;;\n  finish|finis|fini|fin|fi|f)\n    shift; set dummy --mode finish ${1+\"$@\"}; shift\n    ;;\n  install|instal|insta|inst|ins|in|i)\n    shift; set dummy --mode install ${1+\"$@\"}; shift\n    ;;\n  link|lin|li|l)\n    shift; set dummy --mode link ${1+\"$@\"}; shift\n    ;;\n  uninstall|uninstal|uninsta|uninst|unins|unin|uni|un|u)\n    shift; set dummy --mode uninstall ${1+\"$@\"}; shift\n    ;;\n  esac\n\n  # Parse non-mode specific arguments:\n  while test \"$#\" -gt 0; do\n    opt=\"$1\"\n    shift\n\n    case $opt in\n      --config)\t\tfunc_config\t\t\t\t\t;;\n\n      --debug)\t\tpreserve_args=\"$preserve_args $opt\"\n\t\t\tfunc_echo \"enabling shell trace mode\"\n\t\t\topt_debug='set -x'\n\t\t\t$opt_debug\n\t\t\t;;\n\n      -dlopen)\t\ttest \"$#\" -eq 0 && func_missing_arg \"$opt\" && break\n\t\t\texecute_dlfiles=\"$execute_dlfiles $1\"\n\t\t\tshift\n\t\t\t;;\n\n      --dry-run | -n)\topt_dry_run=:\t\t\t\t\t;;\n      --features)       func_features\t\t\t\t\t;;\n      --finish)\t\tmode=\"finish\"\t\t\t\t\t;;\n\n      --mode)\t\ttest \"$#\" -eq 0 && func_missing_arg \"$opt\" && break\n\t\t\tcase $1 in\n\t\t\t  # Valid mode arguments:\n\t\t\t  clean)\t;;\n\t\t\t  compile)\t;;\n\t\t\t  execute)\t;;\n\t\t\t  finish)\t;;\n\t\t\t  install)\t;;\n\t\t\t  link)\t\t;;\n\t\t\t  relink)\t;;\n\t\t\t  uninstall)\t;;\n\n\t\t\t  # Catch anything else as an error\n\t\t\t  *) func_error \"invalid argument for $opt\"\n\t\t\t     exit_cmd=exit\n\t\t\t     break\n\t\t\t     ;;\n\t\t        esac\n\n\t\t\tmode=\"$1\"\n\t\t\tshift\n\t\t\t;;\n\n      --preserve-dup-deps)\n\t\t\topt_duplicate_deps=:\t\t\t\t;;\n\n      --quiet|--silent)\tpreserve_args=\"$preserve_args $opt\"\n\t\t\topt_silent=:\n\t\t\t;;\n\n      --verbose| -v)\tpreserve_args=\"$preserve_args $opt\"\n\t\t\topt_silent=false\n\t\t\t;;\n\n      --tag)\t\ttest \"$#\" -eq 0 && func_missing_arg \"$opt\" && break\n\t\t\tpreserve_args=\"$preserve_args $opt $1\"\n\t\t\tfunc_enable_tag \"$1\"\t# tagname is set here\n\t\t\tshift\n\t\t\t;;\n\n      # Separate optargs to long options:\n      -dlopen=*|--mode=*|--tag=*)\n\t\t\tfunc_opt_split \"$opt\"\n\t\t\tset dummy \"$func_opt_split_opt\" \"$func_opt_split_arg\" ${1+\"$@\"}\n\t\t\tshift\n\t\t\t;;\n\n      -\\?|-h)\t\tfunc_usage\t\t\t\t\t;;\n      --help)\t\topt_help=:\t\t\t\t\t;;\n      --version)\tfunc_version\t\t\t\t\t;;\n\n      -*)\t\tfunc_fatal_help \"unrecognized option \\`$opt'\"\t;;\n\n      *)\t\tnonopt=\"$opt\"\n\t\t\tbreak\n\t\t\t;;\n    esac\n  done\n\n\n  case $host in\n    *cygwin* | *mingw* | *pw32* | *cegcc*)\n      # don't eliminate duplications in $postdeps and $predeps\n      opt_duplicate_compiler_generated_deps=:\n      ;;\n    *)\n      opt_duplicate_compiler_generated_deps=$opt_duplicate_deps\n      ;;\n  esac\n\n  # Having warned about all mis-specified options, bail out if\n  # anything was wrong.\n  $exit_cmd $EXIT_FAILURE\n}\n\n# func_check_version_match\n# Ensure that we are using m4 macros, and libtool script from the same\n# release of libtool.\nfunc_check_version_match ()\n{\n  if test \"$package_revision\" != \"$macro_revision\"; then\n    if test \"$VERSION\" != \"$macro_version\"; then\n      if test -z \"$macro_version\"; then\n        cat >&2 <<_LT_EOF\n$progname: Version mismatch error.  This is $PACKAGE $VERSION, but the\n$progname: definition of this LT_INIT comes from an older release.\n$progname: You should recreate aclocal.m4 with macros from $PACKAGE $VERSION\n$progname: and run autoconf again.\n_LT_EOF\n      else\n        cat >&2 <<_LT_EOF\n$progname: Version mismatch error.  This is $PACKAGE $VERSION, but the\n$progname: definition of this LT_INIT comes from $PACKAGE $macro_version.\n$progname: You should recreate aclocal.m4 with macros from $PACKAGE $VERSION\n$progname: and run autoconf again.\n_LT_EOF\n      fi\n    else\n      cat >&2 <<_LT_EOF\n$progname: Version mismatch error.  This is $PACKAGE $VERSION, revision $package_revision,\n$progname: but the definition of this LT_INIT comes from revision $macro_revision.\n$progname: You should recreate aclocal.m4 with macros from revision $package_revision\n$progname: of $PACKAGE $VERSION and run autoconf again.\n_LT_EOF\n    fi\n\n    exit $EXIT_MISMATCH\n  fi\n}\n\n\n## ----------- ##\n##    Main.    ##\n## ----------- ##\n\n$opt_help || {\n  # Sanity checks first:\n  func_check_version_match\n\n  if test \"$build_libtool_libs\" != yes && test \"$build_old_libs\" != yes; then\n    func_fatal_configuration \"not configured to build any kind of library\"\n  fi\n\n  test -z \"$mode\" && func_fatal_error \"error: you must specify a MODE.\"\n\n\n  # Darwin sucks\n  eval std_shrext=\\\"$shrext_cmds\\\"\n\n\n  # Only execute mode is allowed to have -dlopen flags.\n  if test -n \"$execute_dlfiles\" && test \"$mode\" != execute; then\n    func_error \"unrecognized option \\`-dlopen'\"\n    $ECHO \"$help\" 1>&2\n    exit $EXIT_FAILURE\n  fi\n\n  # Change the help message to a mode-specific one.\n  generic_help=\"$help\"\n  help=\"Try \\`$progname --help --mode=$mode' for more information.\"\n}\n\n\n# func_lalib_p file\n# True iff FILE is a libtool `.la' library or `.lo' object file.\n# This function is only a basic sanity check; it will hardly flush out\n# determined imposters.\nfunc_lalib_p ()\n{\n    test -f \"$1\" &&\n      $SED -e 4q \"$1\" 2>/dev/null \\\n        | $GREP \"^# Generated by .*$PACKAGE\" > /dev/null 2>&1\n}\n\n# func_lalib_unsafe_p file\n# True iff FILE is a libtool `.la' library or `.lo' object file.\n# This function implements the same check as func_lalib_p without\n# resorting to external programs.  To this end, it redirects stdin and\n# closes it afterwards, without saving the original file descriptor.\n# As a safety measure, use it only where a negative result would be\n# fatal anyway.  Works if `file' does not exist.\nfunc_lalib_unsafe_p ()\n{\n    lalib_p=no\n    if test -f \"$1\" && test -r \"$1\" && exec 5<&0 <\"$1\"; then\n\tfor lalib_p_l in 1 2 3 4\n\tdo\n\t    read lalib_p_line\n\t    case \"$lalib_p_line\" in\n\t\t\\#\\ Generated\\ by\\ *$PACKAGE* ) lalib_p=yes; break;;\n\t    esac\n\tdone\n\texec 0<&5 5<&-\n    fi\n    test \"$lalib_p\" = yes\n}\n\n# func_ltwrapper_script_p file\n# True iff FILE is a libtool wrapper script\n# This function is only a basic sanity check; it will hardly flush out\n# determined imposters.\nfunc_ltwrapper_script_p ()\n{\n    func_lalib_p \"$1\"\n}\n\n# func_ltwrapper_executable_p file\n# True iff FILE is a libtool wrapper executable\n# This function is only a basic sanity check; it will hardly flush out\n# determined imposters.\nfunc_ltwrapper_executable_p ()\n{\n    func_ltwrapper_exec_suffix=\n    case $1 in\n    *.exe) ;;\n    *) func_ltwrapper_exec_suffix=.exe ;;\n    esac\n    $GREP \"$magic_exe\" \"$1$func_ltwrapper_exec_suffix\" >/dev/null 2>&1\n}\n\n# func_ltwrapper_scriptname file\n# Assumes file is an ltwrapper_executable\n# uses $file to determine the appropriate filename for a\n# temporary ltwrapper_script.\nfunc_ltwrapper_scriptname ()\n{\n    func_ltwrapper_scriptname_result=\"\"\n    if func_ltwrapper_executable_p \"$1\"; then\n\tfunc_dirname_and_basename \"$1\" \"\" \".\"\n\tfunc_stripname '' '.exe' \"$func_basename_result\"\n\tfunc_ltwrapper_scriptname_result=\"$func_dirname_result/$objdir/${func_stripname_result}_ltshwrapper\"\n    fi\n}\n\n# func_ltwrapper_p file\n# True iff FILE is a libtool wrapper script or wrapper executable\n# This function is only a basic sanity check; it will hardly flush out\n# determined imposters.\nfunc_ltwrapper_p ()\n{\n    func_ltwrapper_script_p \"$1\" || func_ltwrapper_executable_p \"$1\"\n}\n\n\n# func_execute_cmds commands fail_cmd\n# Execute tilde-delimited COMMANDS.\n# If FAIL_CMD is given, eval that upon failure.\n# FAIL_CMD may read-access the current command in variable CMD!\nfunc_execute_cmds ()\n{\n    $opt_debug\n    save_ifs=$IFS; IFS='~'\n    for cmd in $1; do\n      IFS=$save_ifs\n      eval cmd=\\\"$cmd\\\"\n      func_show_eval \"$cmd\" \"${2-:}\"\n    done\n    IFS=$save_ifs\n}\n\n\n# func_source file\n# Source FILE, adding directory component if necessary.\n# Note that it is not necessary on cygwin/mingw to append a dot to\n# FILE even if both FILE and FILE.exe exist: automatic-append-.exe\n# behavior happens only for exec(3), not for open(2)!  Also, sourcing\n# `FILE.' does not work on cygwin managed mounts.\nfunc_source ()\n{\n    $opt_debug\n    case $1 in\n    */* | *\\\\*)\t. \"$1\" ;;\n    *)\t\t. \"./$1\" ;;\n    esac\n}\n\n\n# func_infer_tag arg\n# Infer tagged configuration to use if any are available and\n# if one wasn't chosen via the \"--tag\" command line option.\n# Only attempt this if the compiler in the base compile\n# command doesn't match the default compiler.\n# arg is usually of the form 'gcc ...'\nfunc_infer_tag ()\n{\n    $opt_debug\n    if test -n \"$available_tags\" && test -z \"$tagname\"; then\n      CC_quoted=\n      for arg in $CC; do\n        func_quote_for_eval \"$arg\"\n\tCC_quoted=\"$CC_quoted $func_quote_for_eval_result\"\n      done\n      case $@ in\n      # Blanks in the command may have been stripped by the calling shell,\n      # but not from the CC environment variable when configure was run.\n      \" $CC \"* | \"$CC \"* | \" `$ECHO $CC` \"* | \"`$ECHO $CC` \"* | \" $CC_quoted\"* | \"$CC_quoted \"* | \" `$ECHO $CC_quoted` \"* | \"`$ECHO $CC_quoted` \"*) ;;\n      # Blanks at the start of $base_compile will cause this to fail\n      # if we don't check for them as well.\n      *)\n\tfor z in $available_tags; do\n\t  if $GREP \"^# ### BEGIN LIBTOOL TAG CONFIG: $z$\" < \"$progpath\" > /dev/null; then\n\t    # Evaluate the configuration.\n\t    eval \"`${SED} -n -e '/^# ### BEGIN LIBTOOL TAG CONFIG: '$z'$/,/^# ### END LIBTOOL TAG CONFIG: '$z'$/p' < $progpath`\"\n\t    CC_quoted=\n\t    for arg in $CC; do\n\t      # Double-quote args containing other shell metacharacters.\n\t      func_quote_for_eval \"$arg\"\n\t      CC_quoted=\"$CC_quoted $func_quote_for_eval_result\"\n\t    done\n\t    case \"$@ \" in\n\t      \" $CC \"* | \"$CC \"* | \" `$ECHO $CC` \"* | \"`$ECHO $CC` \"* | \" $CC_quoted\"* | \"$CC_quoted \"* | \" `$ECHO $CC_quoted` \"* | \"`$ECHO $CC_quoted` \"*)\n\t      # The compiler in the base compile command matches\n\t      # the one in the tagged configuration.\n\t      # Assume this is the tagged configuration we want.\n\t      tagname=$z\n\t      break\n\t      ;;\n\t    esac\n\t  fi\n\tdone\n\t# If $tagname still isn't set, then no tagged configuration\n\t# was found and let the user know that the \"--tag\" command\n\t# line option must be used.\n\tif test -z \"$tagname\"; then\n\t  func_echo \"unable to infer tagged configuration\"\n\t  func_fatal_error \"specify a tag with \\`--tag'\"\n#\telse\n#\t  func_verbose \"using $tagname tagged configuration\"\n\tfi\n\t;;\n      esac\n    fi\n}\n\n\n\n# func_write_libtool_object output_name pic_name nonpic_name\n# Create a libtool object file (analogous to a \".la\" file),\n# but don't create it if we're doing a dry run.\nfunc_write_libtool_object ()\n{\n    write_libobj=${1}\n    if test \"$build_libtool_libs\" = yes; then\n      write_lobj=\\'${2}\\'\n    else\n      write_lobj=none\n    fi\n\n    if test \"$build_old_libs\" = yes; then\n      write_oldobj=\\'${3}\\'\n    else\n      write_oldobj=none\n    fi\n\n    $opt_dry_run || {\n      cat >${write_libobj}T <<EOF\n# $write_libobj - a libtool object file\n# Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION\n#\n# Please DO NOT delete this file!\n# It is necessary for linking the library.\n\n# Name of the PIC object.\npic_object=$write_lobj\n\n# Name of the non-PIC object\nnon_pic_object=$write_oldobj\n\nEOF\n      $MV \"${write_libobj}T\" \"${write_libobj}\"\n    }\n}\n\n# func_mode_compile arg...\nfunc_mode_compile ()\n{\n    $opt_debug\n    # Get the compilation command and the source file.\n    base_compile=\n    srcfile=\"$nonopt\"  #  always keep a non-empty value in \"srcfile\"\n    suppress_opt=yes\n    suppress_output=\n    arg_mode=normal\n    libobj=\n    later=\n    pie_flag=\n\n    for arg\n    do\n      case $arg_mode in\n      arg  )\n\t# do not \"continue\".  Instead, add this to base_compile\n\tlastarg=\"$arg\"\n\targ_mode=normal\n\t;;\n\n      target )\n\tlibobj=\"$arg\"\n\targ_mode=normal\n\tcontinue\n\t;;\n\n      normal )\n\t# Accept any command-line options.\n\tcase $arg in\n\t-o)\n\t  test -n \"$libobj\" && \\\n\t    func_fatal_error \"you cannot specify \\`-o' more than once\"\n\t  arg_mode=target\n\t  continue\n\t  ;;\n\n\t-pie | -fpie | -fPIE)\n          pie_flag=\"$pie_flag $arg\"\n\t  continue\n\t  ;;\n\n\t-shared | -static | -prefer-pic | -prefer-non-pic)\n\t  later=\"$later $arg\"\n\t  continue\n\t  ;;\n\n\t-no-suppress)\n\t  suppress_opt=no\n\t  continue\n\t  ;;\n\n\t-Xcompiler)\n\t  arg_mode=arg  #  the next one goes into the \"base_compile\" arg list\n\t  continue      #  The current \"srcfile\" will either be retained or\n\t  ;;            #  replaced later.  I would guess that would be a bug.\n\n\t-Wc,*)\n\t  func_stripname '-Wc,' '' \"$arg\"\n\t  args=$func_stripname_result\n\t  lastarg=\n\t  save_ifs=\"$IFS\"; IFS=','\n\t  for arg in $args; do\n\t    IFS=\"$save_ifs\"\n\t    func_quote_for_eval \"$arg\"\n\t    lastarg=\"$lastarg $func_quote_for_eval_result\"\n\t  done\n\t  IFS=\"$save_ifs\"\n\t  func_stripname ' ' '' \"$lastarg\"\n\t  lastarg=$func_stripname_result\n\n\t  # Add the arguments to base_compile.\n\t  base_compile=\"$base_compile $lastarg\"\n\t  continue\n\t  ;;\n\n\t*)\n\t  # Accept the current argument as the source file.\n\t  # The previous \"srcfile\" becomes the current argument.\n\t  #\n\t  lastarg=\"$srcfile\"\n\t  srcfile=\"$arg\"\n\t  ;;\n\tesac  #  case $arg\n\t;;\n      esac    #  case $arg_mode\n\n      # Aesthetically quote the previous argument.\n      func_quote_for_eval \"$lastarg\"\n      base_compile=\"$base_compile $func_quote_for_eval_result\"\n    done # for arg\n\n    case $arg_mode in\n    arg)\n      func_fatal_error \"you must specify an argument for -Xcompile\"\n      ;;\n    target)\n      func_fatal_error \"you must specify a target with \\`-o'\"\n      ;;\n    *)\n      # Get the name of the library object.\n      test -z \"$libobj\" && {\n\tfunc_basename \"$srcfile\"\n\tlibobj=\"$func_basename_result\"\n      }\n      ;;\n    esac\n\n    # Recognize several different file suffixes.\n    # If the user specifies -o file.o, it is replaced with file.lo\n    case $libobj in\n    *.[cCFSifmso] | \\\n    *.ada | *.adb | *.ads | *.asm | \\\n    *.c++ | *.cc | *.ii | *.class | *.cpp | *.cxx | \\\n    *.[fF][09]? | *.for | *.java | *.obj | *.sx)\n      func_xform \"$libobj\"\n      libobj=$func_xform_result\n      ;;\n    esac\n\n    case $libobj in\n    *.lo) func_lo2o \"$libobj\"; obj=$func_lo2o_result ;;\n    *)\n      func_fatal_error \"cannot determine name of library object from \\`$libobj'\"\n      ;;\n    esac\n\n    func_infer_tag $base_compile\n\n    for arg in $later; do\n      case $arg in\n      -shared)\n\ttest \"$build_libtool_libs\" != yes && \\\n\t  func_fatal_configuration \"can not build a shared library\"\n\tbuild_old_libs=no\n\tcontinue\n\t;;\n\n      -static)\n\tbuild_libtool_libs=no\n\tbuild_old_libs=yes\n\tcontinue\n\t;;\n\n      -prefer-pic)\n\tpic_mode=yes\n\tcontinue\n\t;;\n\n      -prefer-non-pic)\n\tpic_mode=no\n\tcontinue\n\t;;\n      esac\n    done\n\n    func_quote_for_eval \"$libobj\"\n    test \"X$libobj\" != \"X$func_quote_for_eval_result\" \\\n      && $ECHO \"X$libobj\" | $GREP '[]~#^*{};<>?\"'\"'\"'\t &()|`$[]' \\\n      && func_warning \"libobj name \\`$libobj' may not contain shell special characters.\"\n    func_dirname_and_basename \"$obj\" \"/\" \"\"\n    objname=\"$func_basename_result\"\n    xdir=\"$func_dirname_result\"\n    lobj=${xdir}$objdir/$objname\n\n    test -z \"$base_compile\" && \\\n      func_fatal_help \"you must specify a compilation command\"\n\n    # Delete any leftover library objects.\n    if test \"$build_old_libs\" = yes; then\n      removelist=\"$obj $lobj $libobj ${libobj}T\"\n    else\n      removelist=\"$lobj $libobj ${libobj}T\"\n    fi\n\n    # On Cygwin there's no \"real\" PIC flag so we must build both object types\n    case $host_os in\n    cygwin* | mingw* | pw32* | os2* | cegcc*)\n      pic_mode=default\n      ;;\n    esac\n    if test \"$pic_mode\" = no && test \"$deplibs_check_method\" != pass_all; then\n      # non-PIC code in shared libraries is not supported\n      pic_mode=default\n    fi\n\n    # Calculate the filename of the output object if compiler does\n    # not support -o with -c\n    if test \"$compiler_c_o\" = no; then\n      output_obj=`$ECHO \"X$srcfile\" | $Xsed -e 's%^.*/%%' -e 's%\\.[^.]*$%%'`.${objext}\n      lockfile=\"$output_obj.lock\"\n    else\n      output_obj=\n      need_locks=no\n      lockfile=\n    fi\n\n    # Lock this critical section if it is needed\n    # We use this script file to make the link, it avoids creating a new file\n    if test \"$need_locks\" = yes; then\n      until $opt_dry_run || ln \"$progpath\" \"$lockfile\" 2>/dev/null; do\n\tfunc_echo \"Waiting for $lockfile to be removed\"\n\tsleep 2\n      done\n    elif test \"$need_locks\" = warn; then\n      if test -f \"$lockfile\"; then\n\t$ECHO \"\\\n*** ERROR, $lockfile exists and contains:\n`cat $lockfile 2>/dev/null`\n\nThis indicates that another process is trying to use the same\ntemporary object file, and libtool could not work around it because\nyour compiler does not support \\`-c' and \\`-o' together.  If you\nrepeat this compilation, it may succeed, by chance, but you had better\navoid parallel builds (make -j) in this platform, or get a better\ncompiler.\"\n\n\t$opt_dry_run || $RM $removelist\n\texit $EXIT_FAILURE\n      fi\n      removelist=\"$removelist $output_obj\"\n      $ECHO \"$srcfile\" > \"$lockfile\"\n    fi\n\n    $opt_dry_run || $RM $removelist\n    removelist=\"$removelist $lockfile\"\n    trap '$opt_dry_run || $RM $removelist; exit $EXIT_FAILURE' 1 2 15\n\n    if test -n \"$fix_srcfile_path\"; then\n      eval srcfile=\\\"$fix_srcfile_path\\\"\n    fi\n    func_quote_for_eval \"$srcfile\"\n    qsrcfile=$func_quote_for_eval_result\n\n    # Only build a PIC object if we are building libtool libraries.\n    if test \"$build_libtool_libs\" = yes; then\n      # Without this assignment, base_compile gets emptied.\n      fbsd_hideous_sh_bug=$base_compile\n\n      if test \"$pic_mode\" != no; then\n\tcommand=\"$base_compile $qsrcfile $pic_flag\"\n      else\n\t# Don't build PIC code\n\tcommand=\"$base_compile $qsrcfile\"\n      fi\n\n      func_mkdir_p \"$xdir$objdir\"\n\n      if test -z \"$output_obj\"; then\n\t# Place PIC objects in $objdir\n\tcommand=\"$command -o $lobj\"\n      fi\n\n      func_show_eval_locale \"$command\"\t\\\n          'test -n \"$output_obj\" && $RM $removelist; exit $EXIT_FAILURE'\n\n      if test \"$need_locks\" = warn &&\n\t test \"X`cat $lockfile 2>/dev/null`\" != \"X$srcfile\"; then\n\t$ECHO \"\\\n*** ERROR, $lockfile contains:\n`cat $lockfile 2>/dev/null`\n\nbut it should contain:\n$srcfile\n\nThis indicates that another process is trying to use the same\ntemporary object file, and libtool could not work around it because\nyour compiler does not support \\`-c' and \\`-o' together.  If you\nrepeat this compilation, it may succeed, by chance, but you had better\navoid parallel builds (make -j) in this platform, or get a better\ncompiler.\"\n\n\t$opt_dry_run || $RM $removelist\n\texit $EXIT_FAILURE\n      fi\n\n      # Just move the object if needed, then go on to compile the next one\n      if test -n \"$output_obj\" && test \"X$output_obj\" != \"X$lobj\"; then\n\tfunc_show_eval '$MV \"$output_obj\" \"$lobj\"' \\\n\t  'error=$?; $opt_dry_run || $RM $removelist; exit $error'\n      fi\n\n      # Allow error messages only from the first compilation.\n      if test \"$suppress_opt\" = yes; then\n\tsuppress_output=' >/dev/null 2>&1'\n      fi\n    fi\n\n    # Only build a position-dependent object if we build old libraries.\n    if test \"$build_old_libs\" = yes; then\n      if test \"$pic_mode\" != yes; then\n\t# Don't build PIC code\n\tcommand=\"$base_compile $qsrcfile$pie_flag\"\n      else\n\tcommand=\"$base_compile $qsrcfile $pic_flag\"\n      fi\n      if test \"$compiler_c_o\" = yes; then\n\tcommand=\"$command -o $obj\"\n      fi\n\n      # Suppress compiler output if we already did a PIC compilation.\n      command=\"$command$suppress_output\"\n      func_show_eval_locale \"$command\" \\\n        '$opt_dry_run || $RM $removelist; exit $EXIT_FAILURE'\n\n      if test \"$need_locks\" = warn &&\n\t test \"X`cat $lockfile 2>/dev/null`\" != \"X$srcfile\"; then\n\t$ECHO \"\\\n*** ERROR, $lockfile contains:\n`cat $lockfile 2>/dev/null`\n\nbut it should contain:\n$srcfile\n\nThis indicates that another process is trying to use the same\ntemporary object file, and libtool could not work around it because\nyour compiler does not support \\`-c' and \\`-o' together.  If you\nrepeat this compilation, it may succeed, by chance, but you had better\navoid parallel builds (make -j) in this platform, or get a better\ncompiler.\"\n\n\t$opt_dry_run || $RM $removelist\n\texit $EXIT_FAILURE\n      fi\n\n      # Just move the object if needed\n      if test -n \"$output_obj\" && test \"X$output_obj\" != \"X$obj\"; then\n\tfunc_show_eval '$MV \"$output_obj\" \"$obj\"' \\\n\t  'error=$?; $opt_dry_run || $RM $removelist; exit $error'\n      fi\n    fi\n\n    $opt_dry_run || {\n      func_write_libtool_object \"$libobj\" \"$objdir/$objname\" \"$objname\"\n\n      # Unlock the critical section if it was locked\n      if test \"$need_locks\" != no; then\n\tremovelist=$lockfile\n        $RM \"$lockfile\"\n      fi\n    }\n\n    exit $EXIT_SUCCESS\n}\n\n$opt_help || {\ntest \"$mode\" = compile && func_mode_compile ${1+\"$@\"}\n}\n\nfunc_mode_help ()\n{\n    # We need to display help for each of the modes.\n    case $mode in\n      \"\")\n        # Generic help is extracted from the usage comments\n        # at the start of this file.\n        func_help\n        ;;\n\n      clean)\n        $ECHO \\\n\"Usage: $progname [OPTION]... --mode=clean RM [RM-OPTION]... FILE...\n\nRemove files from the build directory.\n\nRM is the name of the program to use to delete files associated with each FILE\n(typically \\`/bin/rm').  RM-OPTIONS are options (such as \\`-f') to be passed\nto RM.\n\nIf FILE is a libtool library, object or program, all the files associated\nwith it are deleted. Otherwise, only FILE itself is deleted using RM.\"\n        ;;\n\n      compile)\n      $ECHO \\\n\"Usage: $progname [OPTION]... --mode=compile COMPILE-COMMAND... SOURCEFILE\n\nCompile a source file into a libtool library object.\n\nThis mode accepts the following additional options:\n\n  -o OUTPUT-FILE    set the output file name to OUTPUT-FILE\n  -no-suppress      do not suppress compiler output for multiple passes\n  -prefer-pic       try to building PIC objects only\n  -prefer-non-pic   try to building non-PIC objects only\n  -shared           do not build a \\`.o' file suitable for static linking\n  -static           only build a \\`.o' file suitable for static linking\n\nCOMPILE-COMMAND is a command to be used in creating a \\`standard' object file\nfrom the given SOURCEFILE.\n\nThe output file name is determined by removing the directory component from\nSOURCEFILE, then substituting the C source code suffix \\`.c' with the\nlibrary object suffix, \\`.lo'.\"\n        ;;\n\n      execute)\n        $ECHO \\\n\"Usage: $progname [OPTION]... --mode=execute COMMAND [ARGS]...\n\nAutomatically set library path, then run a program.\n\nThis mode accepts the following additional options:\n\n  -dlopen FILE      add the directory containing FILE to the library path\n\nThis mode sets the library path environment variable according to \\`-dlopen'\nflags.\n\nIf any of the ARGS are libtool executable wrappers, then they are translated\ninto their corresponding uninstalled binary, and any of their required library\ndirectories are added to the library path.\n\nThen, COMMAND is executed, with ARGS as arguments.\"\n        ;;\n\n      finish)\n        $ECHO \\\n\"Usage: $progname [OPTION]... --mode=finish [LIBDIR]...\n\nComplete the installation of libtool libraries.\n\nEach LIBDIR is a directory that contains libtool libraries.\n\nThe commands that this mode executes may require superuser privileges.  Use\nthe \\`--dry-run' option if you just want to see what would be executed.\"\n        ;;\n\n      install)\n        $ECHO \\\n\"Usage: $progname [OPTION]... --mode=install INSTALL-COMMAND...\n\nInstall executables or libraries.\n\nINSTALL-COMMAND is the installation command.  The first component should be\neither the \\`install' or \\`cp' program.\n\nThe following components of INSTALL-COMMAND are treated specially:\n\n  -inst-prefix PREFIX-DIR  Use PREFIX-DIR as a staging area for installation\n\nThe rest of the components are interpreted as arguments to that command (only\nBSD-compatible install options are recognized).\"\n        ;;\n\n      link)\n        $ECHO \\\n\"Usage: $progname [OPTION]... --mode=link LINK-COMMAND...\n\nLink object files or libraries together to form another library, or to\ncreate an executable program.\n\nLINK-COMMAND is a command using the C compiler that you would use to create\na program from several object files.\n\nThe following components of LINK-COMMAND are treated specially:\n\n  -all-static       do not do any dynamic linking at all\n  -avoid-version    do not add a version suffix if possible\n  -dlopen FILE      \\`-dlpreopen' FILE if it cannot be dlopened at runtime\n  -dlpreopen FILE   link in FILE and add its symbols to lt_preloaded_symbols\n  -export-dynamic   allow symbols from OUTPUT-FILE to be resolved with dlsym(3)\n  -export-symbols SYMFILE\n                    try to export only the symbols listed in SYMFILE\n  -export-symbols-regex REGEX\n                    try to export only the symbols matching REGEX\n  -LLIBDIR          search LIBDIR for required installed libraries\n  -lNAME            OUTPUT-FILE requires the installed library libNAME\n  -module           build a library that can dlopened\n  -no-fast-install  disable the fast-install mode\n  -no-install       link a not-installable executable\n  -no-undefined     declare that a library does not refer to external symbols\n  -o OUTPUT-FILE    create OUTPUT-FILE from the specified objects\n  -objectlist FILE  Use a list of object files found in FILE to specify objects\n  -precious-files-regex REGEX\n                    don't remove output files matching REGEX\n  -release RELEASE  specify package release information\n  -rpath LIBDIR     the created library will eventually be installed in LIBDIR\n  -R[ ]LIBDIR       add LIBDIR to the runtime path of programs and libraries\n  -shared           only do dynamic linking of libtool libraries\n  -shrext SUFFIX    override the standard shared library file extension\n  -static           do not do any dynamic linking of uninstalled libtool libraries\n  -static-libtool-libs\n                    do not do any dynamic linking of libtool libraries\n  -version-info CURRENT[:REVISION[:AGE]]\n                    specify library version info [each variable defaults to 0]\n  -weak LIBNAME     declare that the target provides the LIBNAME interface\n\nAll other options (arguments beginning with \\`-') are ignored.\n\nEvery other argument is treated as a filename.  Files ending in \\`.la' are\ntreated as uninstalled libtool libraries, other files are standard or library\nobject files.\n\nIf the OUTPUT-FILE ends in \\`.la', then a libtool library is created,\nonly library objects (\\`.lo' files) may be specified, and \\`-rpath' is\nrequired, except when creating a convenience library.\n\nIf OUTPUT-FILE ends in \\`.a' or \\`.lib', then a standard library is created\nusing \\`ar' and \\`ranlib', or on Windows using \\`lib'.\n\nIf OUTPUT-FILE ends in \\`.lo' or \\`.${objext}', then a reloadable object file\nis created, otherwise an executable program is created.\"\n        ;;\n\n      uninstall)\n        $ECHO \\\n\"Usage: $progname [OPTION]... --mode=uninstall RM [RM-OPTION]... FILE...\n\nRemove libraries from an installation directory.\n\nRM is the name of the program to use to delete files associated with each FILE\n(typically \\`/bin/rm').  RM-OPTIONS are options (such as \\`-f') to be passed\nto RM.\n\nIf FILE is a libtool library, all the files associated with it are deleted.\nOtherwise, only FILE itself is deleted using RM.\"\n        ;;\n\n      *)\n        func_fatal_help \"invalid operation mode \\`$mode'\"\n        ;;\n    esac\n\n    $ECHO\n    $ECHO \"Try \\`$progname --help' for more information about other modes.\"\n\n    exit $?\n}\n\n  # Now that we've collected a possible --mode arg, show help if necessary\n  $opt_help && func_mode_help\n\n\n# func_mode_execute arg...\nfunc_mode_execute ()\n{\n    $opt_debug\n    # The first argument is the command name.\n    cmd=\"$nonopt\"\n    test -z \"$cmd\" && \\\n      func_fatal_help \"you must specify a COMMAND\"\n\n    # Handle -dlopen flags immediately.\n    for file in $execute_dlfiles; do\n      test -f \"$file\" \\\n\t|| func_fatal_help \"\\`$file' is not a file\"\n\n      dir=\n      case $file in\n      *.la)\n\t# Check to see that this really is a libtool archive.\n\tfunc_lalib_unsafe_p \"$file\" \\\n\t  || func_fatal_help \"\\`$lib' is not a valid libtool archive\"\n\n\t# Read the libtool library.\n\tdlname=\n\tlibrary_names=\n\tfunc_source \"$file\"\n\n\t# Skip this library if it cannot be dlopened.\n\tif test -z \"$dlname\"; then\n\t  # Warn if it was a shared library.\n\t  test -n \"$library_names\" && \\\n\t    func_warning \"\\`$file' was not linked with \\`-export-dynamic'\"\n\t  continue\n\tfi\n\n\tfunc_dirname \"$file\" \"\" \".\"\n\tdir=\"$func_dirname_result\"\n\n\tif test -f \"$dir/$objdir/$dlname\"; then\n\t  dir=\"$dir/$objdir\"\n\telse\n\t  if test ! -f \"$dir/$dlname\"; then\n\t    func_fatal_error \"cannot find \\`$dlname' in \\`$dir' or \\`$dir/$objdir'\"\n\t  fi\n\tfi\n\t;;\n\n      *.lo)\n\t# Just add the directory containing the .lo file.\n\tfunc_dirname \"$file\" \"\" \".\"\n\tdir=\"$func_dirname_result\"\n\t;;\n\n      *)\n\tfunc_warning \"\\`-dlopen' is ignored for non-libtool libraries and objects\"\n\tcontinue\n\t;;\n      esac\n\n      # Get the absolute pathname.\n      absdir=`cd \"$dir\" && pwd`\n      test -n \"$absdir\" && dir=\"$absdir\"\n\n      # Now add the directory to shlibpath_var.\n      if eval \"test -z \\\"\\$$shlibpath_var\\\"\"; then\n\teval \"$shlibpath_var=\\\"\\$dir\\\"\"\n      else\n\teval \"$shlibpath_var=\\\"\\$dir:\\$$shlibpath_var\\\"\"\n      fi\n    done\n\n    # This variable tells wrapper scripts just to set shlibpath_var\n    # rather than running their programs.\n    libtool_execute_magic=\"$magic\"\n\n    # Check if any of the arguments is a wrapper script.\n    args=\n    for file\n    do\n      case $file in\n      -*) ;;\n      *)\n\t# Do a test to see if this is really a libtool program.\n\tif func_ltwrapper_script_p \"$file\"; then\n\t  func_source \"$file\"\n\t  # Transform arg to wrapped name.\n\t  file=\"$progdir/$program\"\n\telif func_ltwrapper_executable_p \"$file\"; then\n\t  func_ltwrapper_scriptname \"$file\"\n\t  func_source \"$func_ltwrapper_scriptname_result\"\n\t  # Transform arg to wrapped name.\n\t  file=\"$progdir/$program\"\n\tfi\n\t;;\n      esac\n      # Quote arguments (to preserve shell metacharacters).\n      func_quote_for_eval \"$file\"\n      args=\"$args $func_quote_for_eval_result\"\n    done\n\n    if test \"X$opt_dry_run\" = Xfalse; then\n      if test -n \"$shlibpath_var\"; then\n\t# Export the shlibpath_var.\n\teval \"export $shlibpath_var\"\n      fi\n\n      # Restore saved environment variables\n      for lt_var in LANG LANGUAGE LC_ALL LC_CTYPE LC_COLLATE LC_MESSAGES\n      do\n\teval \"if test \\\"\\${save_$lt_var+set}\\\" = set; then\n                $lt_var=\\$save_$lt_var; export $lt_var\n\t      else\n\t\t$lt_unset $lt_var\n\t      fi\"\n      done\n\n      # Now prepare to actually exec the command.\n      exec_cmd=\"\\$cmd$args\"\n    else\n      # Display what would be done.\n      if test -n \"$shlibpath_var\"; then\n\teval \"\\$ECHO \\\"\\$shlibpath_var=\\$$shlibpath_var\\\"\"\n\t$ECHO \"export $shlibpath_var\"\n      fi\n      $ECHO \"$cmd$args\"\n      exit $EXIT_SUCCESS\n    fi\n}\n\ntest \"$mode\" = execute && func_mode_execute ${1+\"$@\"}\n\n\n# func_mode_finish arg...\nfunc_mode_finish ()\n{\n    $opt_debug\n    libdirs=\"$nonopt\"\n    admincmds=\n\n    if test -n \"$finish_cmds$finish_eval\" && test -n \"$libdirs\"; then\n      for dir\n      do\n\tlibdirs=\"$libdirs $dir\"\n      done\n\n      for libdir in $libdirs; do\n\tif test -n \"$finish_cmds\"; then\n\t  # Do each command in the finish commands.\n\t  func_execute_cmds \"$finish_cmds\" 'admincmds=\"$admincmds\n'\"$cmd\"'\"'\n\tfi\n\tif test -n \"$finish_eval\"; then\n\t  # Do the single finish_eval.\n\t  eval cmds=\\\"$finish_eval\\\"\n\t  $opt_dry_run || eval \"$cmds\" || admincmds=\"$admincmds\n       $cmds\"\n\tfi\n      done\n    fi\n\n    # Exit here if they wanted silent mode.\n    $opt_silent && exit $EXIT_SUCCESS\n\n    $ECHO \"X----------------------------------------------------------------------\" | $Xsed\n    $ECHO \"Libraries have been installed in:\"\n    for libdir in $libdirs; do\n      $ECHO \"   $libdir\"\n    done\n    $ECHO\n    $ECHO \"If you ever happen to want to link against installed libraries\"\n    $ECHO \"in a given directory, LIBDIR, you must either use libtool, and\"\n    $ECHO \"specify the full pathname of the library, or use the \\`-LLIBDIR'\"\n    $ECHO \"flag during linking and do at least one of the following:\"\n    if test -n \"$shlibpath_var\"; then\n      $ECHO \"   - add LIBDIR to the \\`$shlibpath_var' environment variable\"\n      $ECHO \"     during execution\"\n    fi\n    if test -n \"$runpath_var\"; then\n      $ECHO \"   - add LIBDIR to the \\`$runpath_var' environment variable\"\n      $ECHO \"     during linking\"\n    fi\n    if test -n \"$hardcode_libdir_flag_spec\"; then\n      libdir=LIBDIR\n      eval flag=\\\"$hardcode_libdir_flag_spec\\\"\n\n      $ECHO \"   - use the \\`$flag' linker flag\"\n    fi\n    if test -n \"$admincmds\"; then\n      $ECHO \"   - have your system administrator run these commands:$admincmds\"\n    fi\n    if test -f /etc/ld.so.conf; then\n      $ECHO \"   - have your system administrator add LIBDIR to \\`/etc/ld.so.conf'\"\n    fi\n    $ECHO\n\n    $ECHO \"See any operating system documentation about shared libraries for\"\n    case $host in\n      solaris2.[6789]|solaris2.1[0-9])\n        $ECHO \"more information, such as the ld(1), crle(1) and ld.so(8) manual\"\n\t$ECHO \"pages.\"\n\t;;\n      *)\n        $ECHO \"more information, such as the ld(1) and ld.so(8) manual pages.\"\n        ;;\n    esac\n    $ECHO \"X----------------------------------------------------------------------\" | $Xsed\n    exit $EXIT_SUCCESS\n}\n\ntest \"$mode\" = finish && func_mode_finish ${1+\"$@\"}\n\n\n# func_mode_install arg...\nfunc_mode_install ()\n{\n    $opt_debug\n    # There may be an optional sh(1) argument at the beginning of\n    # install_prog (especially on Windows NT).\n    if test \"$nonopt\" = \"$SHELL\" || test \"$nonopt\" = /bin/sh ||\n       # Allow the use of GNU shtool's install command.\n       $ECHO \"X$nonopt\" | $GREP shtool >/dev/null; then\n      # Aesthetically quote it.\n      func_quote_for_eval \"$nonopt\"\n      install_prog=\"$func_quote_for_eval_result \"\n      arg=$1\n      shift\n    else\n      install_prog=\n      arg=$nonopt\n    fi\n\n    # The real first argument should be the name of the installation program.\n    # Aesthetically quote it.\n    func_quote_for_eval \"$arg\"\n    install_prog=\"$install_prog$func_quote_for_eval_result\"\n\n    # We need to accept at least all the BSD install flags.\n    dest=\n    files=\n    opts=\n    prev=\n    install_type=\n    isdir=no\n    stripme=\n    for arg\n    do\n      if test -n \"$dest\"; then\n\tfiles=\"$files $dest\"\n\tdest=$arg\n\tcontinue\n      fi\n\n      case $arg in\n      -d) isdir=yes ;;\n      -f)\n\tcase \" $install_prog \" in\n\t*[\\\\\\ /]cp\\ *) ;;\n\t*) prev=$arg ;;\n\tesac\n\t;;\n      -g | -m | -o)\n\tprev=$arg\n\t;;\n      -s)\n\tstripme=\" -s\"\n\tcontinue\n\t;;\n      -*)\n\t;;\n      *)\n\t# If the previous option needed an argument, then skip it.\n\tif test -n \"$prev\"; then\n\t  prev=\n\telse\n\t  dest=$arg\n\t  continue\n\tfi\n\t;;\n      esac\n\n      # Aesthetically quote the argument.\n      func_quote_for_eval \"$arg\"\n      install_prog=\"$install_prog $func_quote_for_eval_result\"\n    done\n\n    test -z \"$install_prog\" && \\\n      func_fatal_help \"you must specify an install program\"\n\n    test -n \"$prev\" && \\\n      func_fatal_help \"the \\`$prev' option requires an argument\"\n\n    if test -z \"$files\"; then\n      if test -z \"$dest\"; then\n\tfunc_fatal_help \"no file or destination specified\"\n      else\n\tfunc_fatal_help \"you must specify a destination\"\n      fi\n    fi\n\n    # Strip any trailing slash from the destination.\n    func_stripname '' '/' \"$dest\"\n    dest=$func_stripname_result\n\n    # Check to see that the destination is a directory.\n    test -d \"$dest\" && isdir=yes\n    if test \"$isdir\" = yes; then\n      destdir=\"$dest\"\n      destname=\n    else\n      func_dirname_and_basename \"$dest\" \"\" \".\"\n      destdir=\"$func_dirname_result\"\n      destname=\"$func_basename_result\"\n\n      # Not a directory, so check to see that there is only one file specified.\n      set dummy $files; shift\n      test \"$#\" -gt 1 && \\\n\tfunc_fatal_help \"\\`$dest' is not a directory\"\n    fi\n    case $destdir in\n    [\\\\/]* | [A-Za-z]:[\\\\/]*) ;;\n    *)\n      for file in $files; do\n\tcase $file in\n\t*.lo) ;;\n\t*)\n\t  func_fatal_help \"\\`$destdir' must be an absolute directory name\"\n\t  ;;\n\tesac\n      done\n      ;;\n    esac\n\n    # This variable tells wrapper scripts just to set variables rather\n    # than running their programs.\n    libtool_install_magic=\"$magic\"\n\n    staticlibs=\n    future_libdirs=\n    current_libdirs=\n    for file in $files; do\n\n      # Do each installation.\n      case $file in\n      *.$libext)\n\t# Do the static libraries later.\n\tstaticlibs=\"$staticlibs $file\"\n\t;;\n\n      *.la)\n\t# Check to see that this really is a libtool archive.\n\tfunc_lalib_unsafe_p \"$file\" \\\n\t  || func_fatal_help \"\\`$file' is not a valid libtool archive\"\n\n\tlibrary_names=\n\told_library=\n\trelink_command=\n\tfunc_source \"$file\"\n\n\t# Add the libdir to current_libdirs if it is the destination.\n\tif test \"X$destdir\" = \"X$libdir\"; then\n\t  case \"$current_libdirs \" in\n\t  *\" $libdir \"*) ;;\n\t  *) current_libdirs=\"$current_libdirs $libdir\" ;;\n\t  esac\n\telse\n\t  # Note the libdir as a future libdir.\n\t  case \"$future_libdirs \" in\n\t  *\" $libdir \"*) ;;\n\t  *) future_libdirs=\"$future_libdirs $libdir\" ;;\n\t  esac\n\tfi\n\n\tfunc_dirname \"$file\" \"/\" \"\"\n\tdir=\"$func_dirname_result\"\n\tdir=\"$dir$objdir\"\n\n\tif test -n \"$relink_command\"; then\n\t  # Determine the prefix the user has applied to our future dir.\n\t  inst_prefix_dir=`$ECHO \"X$destdir\" | $Xsed -e \"s%$libdir\\$%%\"`\n\n\t  # Don't allow the user to place us outside of our expected\n\t  # location b/c this prevents finding dependent libraries that\n\t  # are installed to the same prefix.\n\t  # At present, this check doesn't affect windows .dll's that\n\t  # are installed into $libdir/../bin (currently, that works fine)\n\t  # but it's something to keep an eye on.\n\t  test \"$inst_prefix_dir\" = \"$destdir\" && \\\n\t    func_fatal_error \"error: cannot install \\`$file' to a directory not ending in $libdir\"\n\n\t  if test -n \"$inst_prefix_dir\"; then\n\t    # Stick the inst_prefix_dir data into the link command.\n\t    relink_command=`$ECHO \"X$relink_command\" | $Xsed -e \"s%@inst_prefix_dir@%-inst-prefix-dir $inst_prefix_dir%\"`\n\t  else\n\t    relink_command=`$ECHO \"X$relink_command\" | $Xsed -e \"s%@inst_prefix_dir@%%\"`\n\t  fi\n\n\t  func_warning \"relinking \\`$file'\"\n\t  func_show_eval \"$relink_command\" \\\n\t    'func_fatal_error \"error: relink \\`$file'\\'' with the above command before installing it\"'\n\tfi\n\n\t# See the names of the shared library.\n\tset dummy $library_names; shift\n\tif test -n \"$1\"; then\n\t  realname=\"$1\"\n\t  shift\n\n\t  srcname=\"$realname\"\n\t  test -n \"$relink_command\" && srcname=\"$realname\"T\n\n\t  # Install the shared library and build the symlinks.\n\t  func_show_eval \"$install_prog $dir/$srcname $destdir/$realname\" \\\n\t      'exit $?'\n\t  tstripme=\"$stripme\"\n\t  case $host_os in\n\t  cygwin* | mingw* | pw32* | cegcc*)\n\t    case $realname in\n\t    *.dll.a)\n\t      tstripme=\"\"\n\t      ;;\n\t    esac\n\t    ;;\n\t  esac\n\t  if test -n \"$tstripme\" && test -n \"$striplib\"; then\n\t    func_show_eval \"$striplib $destdir/$realname\" 'exit $?'\n\t  fi\n\n\t  if test \"$#\" -gt 0; then\n\t    # Delete the old symlinks, and create new ones.\n\t    # Try `ln -sf' first, because the `ln' binary might depend on\n\t    # the symlink we replace!  Solaris /bin/ln does not understand -f,\n\t    # so we also need to try rm && ln -s.\n\t    for linkname\n\t    do\n\t      test \"$linkname\" != \"$realname\" \\\n\t\t&& func_show_eval \"(cd $destdir && { $LN_S -f $realname $linkname || { $RM $linkname && $LN_S $realname $linkname; }; })\"\n\t    done\n\t  fi\n\n\t  # Do each command in the postinstall commands.\n\t  lib=\"$destdir/$realname\"\n\t  func_execute_cmds \"$postinstall_cmds\" 'exit $?'\n\tfi\n\n\t# Install the pseudo-library for information purposes.\n\tfunc_basename \"$file\"\n\tname=\"$func_basename_result\"\n\tinstname=\"$dir/$name\"i\n\tfunc_show_eval \"$install_prog $instname $destdir/$name\" 'exit $?'\n\n\t# Maybe install the static library, too.\n\ttest -n \"$old_library\" && staticlibs=\"$staticlibs $dir/$old_library\"\n\t;;\n\n      *.lo)\n\t# Install (i.e. copy) a libtool object.\n\n\t# Figure out destination file name, if it wasn't already specified.\n\tif test -n \"$destname\"; then\n\t  destfile=\"$destdir/$destname\"\n\telse\n\t  func_basename \"$file\"\n\t  destfile=\"$func_basename_result\"\n\t  destfile=\"$destdir/$destfile\"\n\tfi\n\n\t# Deduce the name of the destination old-style object file.\n\tcase $destfile in\n\t*.lo)\n\t  func_lo2o \"$destfile\"\n\t  staticdest=$func_lo2o_result\n\t  ;;\n\t*.$objext)\n\t  staticdest=\"$destfile\"\n\t  destfile=\n\t  ;;\n\t*)\n\t  func_fatal_help \"cannot copy a libtool object to \\`$destfile'\"\n\t  ;;\n\tesac\n\n\t# Install the libtool object if requested.\n\ttest -n \"$destfile\" && \\\n\t  func_show_eval \"$install_prog $file $destfile\" 'exit $?'\n\n\t# Install the old object if enabled.\n\tif test \"$build_old_libs\" = yes; then\n\t  # Deduce the name of the old-style object file.\n\t  func_lo2o \"$file\"\n\t  staticobj=$func_lo2o_result\n\t  func_show_eval \"$install_prog \\$staticobj \\$staticdest\" 'exit $?'\n\tfi\n\texit $EXIT_SUCCESS\n\t;;\n\n      *)\n\t# Figure out destination file name, if it wasn't already specified.\n\tif test -n \"$destname\"; then\n\t  destfile=\"$destdir/$destname\"\n\telse\n\t  func_basename \"$file\"\n\t  destfile=\"$func_basename_result\"\n\t  destfile=\"$destdir/$destfile\"\n\tfi\n\n\t# If the file is missing, and there is a .exe on the end, strip it\n\t# because it is most likely a libtool script we actually want to\n\t# install\n\tstripped_ext=\"\"\n\tcase $file in\n\t  *.exe)\n\t    if test ! -f \"$file\"; then\n\t      func_stripname '' '.exe' \"$file\"\n\t      file=$func_stripname_result\n\t      stripped_ext=\".exe\"\n\t    fi\n\t    ;;\n\tesac\n\n\t# Do a test to see if this is really a libtool program.\n\tcase $host in\n\t*cygwin* | *mingw*)\n\t    if func_ltwrapper_executable_p \"$file\"; then\n\t      func_ltwrapper_scriptname \"$file\"\n\t      wrapper=$func_ltwrapper_scriptname_result\n\t    else\n\t      func_stripname '' '.exe' \"$file\"\n\t      wrapper=$func_stripname_result\n\t    fi\n\t    ;;\n\t*)\n\t    wrapper=$file\n\t    ;;\n\tesac\n\tif func_ltwrapper_script_p \"$wrapper\"; then\n\t  notinst_deplibs=\n\t  relink_command=\n\n\t  func_source \"$wrapper\"\n\n\t  # Check the variables that should have been set.\n\t  test -z \"$generated_by_libtool_version\" && \\\n\t    func_fatal_error \"invalid libtool wrapper script \\`$wrapper'\"\n\n\t  finalize=yes\n\t  for lib in $notinst_deplibs; do\n\t    # Check to see that each library is installed.\n\t    libdir=\n\t    if test -f \"$lib\"; then\n\t      func_source \"$lib\"\n\t    fi\n\t    libfile=\"$libdir/\"`$ECHO \"X$lib\" | $Xsed -e 's%^.*/%%g'` ### testsuite: skip nested quoting test\n\t    if test -n \"$libdir\" && test ! -f \"$libfile\"; then\n\t      func_warning \"\\`$lib' has not been installed in \\`$libdir'\"\n\t      finalize=no\n\t    fi\n\t  done\n\n\t  relink_command=\n\t  func_source \"$wrapper\"\n\n\t  outputname=\n\t  if test \"$fast_install\" = no && test -n \"$relink_command\"; then\n\t    $opt_dry_run || {\n\t      if test \"$finalize\" = yes; then\n\t        tmpdir=`func_mktempdir`\n\t\tfunc_basename \"$file$stripped_ext\"\n\t\tfile=\"$func_basename_result\"\n\t        outputname=\"$tmpdir/$file\"\n\t        # Replace the output file specification.\n\t        relink_command=`$ECHO \"X$relink_command\" | $Xsed -e 's%@OUTPUT@%'\"$outputname\"'%g'`\n\n\t        $opt_silent || {\n\t          func_quote_for_expand \"$relink_command\"\n\t\t  eval \"func_echo $func_quote_for_expand_result\"\n\t        }\n\t        if eval \"$relink_command\"; then :\n\t          else\n\t\t  func_error \"error: relink \\`$file' with the above command before installing it\"\n\t\t  $opt_dry_run || ${RM}r \"$tmpdir\"\n\t\t  continue\n\t        fi\n\t        file=\"$outputname\"\n\t      else\n\t        func_warning \"cannot relink \\`$file'\"\n\t      fi\n\t    }\n\t  else\n\t    # Install the binary that we compiled earlier.\n\t    file=`$ECHO \"X$file$stripped_ext\" | $Xsed -e \"s%\\([^/]*\\)$%$objdir/\\1%\"`\n\t  fi\n\tfi\n\n\t# remove .exe since cygwin /usr/bin/install will append another\n\t# one anyway\n\tcase $install_prog,$host in\n\t*/usr/bin/install*,*cygwin*)\n\t  case $file:$destfile in\n\t  *.exe:*.exe)\n\t    # this is ok\n\t    ;;\n\t  *.exe:*)\n\t    destfile=$destfile.exe\n\t    ;;\n\t  *:*.exe)\n\t    func_stripname '' '.exe' \"$destfile\"\n\t    destfile=$func_stripname_result\n\t    ;;\n\t  esac\n\t  ;;\n\tesac\n\tfunc_show_eval \"$install_prog\\$stripme \\$file \\$destfile\" 'exit $?'\n\t$opt_dry_run || if test -n \"$outputname\"; then\n\t  ${RM}r \"$tmpdir\"\n\tfi\n\t;;\n      esac\n    done\n\n    for file in $staticlibs; do\n      func_basename \"$file\"\n      name=\"$func_basename_result\"\n\n      # Set up the ranlib parameters.\n      oldlib=\"$destdir/$name\"\n\n      func_show_eval \"$install_prog \\$file \\$oldlib\" 'exit $?'\n\n      if test -n \"$stripme\" && test -n \"$old_striplib\"; then\n\tfunc_show_eval \"$old_striplib $oldlib\" 'exit $?'\n      fi\n\n      # Do each command in the postinstall commands.\n      func_execute_cmds \"$old_postinstall_cmds\" 'exit $?'\n    done\n\n    test -n \"$future_libdirs\" && \\\n      func_warning \"remember to run \\`$progname --finish$future_libdirs'\"\n\n    if test -n \"$current_libdirs\"; then\n      # Maybe just do a dry run.\n      $opt_dry_run && current_libdirs=\" -n$current_libdirs\"\n      exec_cmd='$SHELL $progpath $preserve_args --finish$current_libdirs'\n    else\n      exit $EXIT_SUCCESS\n    fi\n}\n\ntest \"$mode\" = install && func_mode_install ${1+\"$@\"}\n\n\n# func_generate_dlsyms outputname originator pic_p\n# Extract symbols from dlprefiles and create ${outputname}S.o with\n# a dlpreopen symbol table.\nfunc_generate_dlsyms ()\n{\n    $opt_debug\n    my_outputname=\"$1\"\n    my_originator=\"$2\"\n    my_pic_p=\"${3-no}\"\n    my_prefix=`$ECHO \"$my_originator\" | sed 's%[^a-zA-Z0-9]%_%g'`\n    my_dlsyms=\n\n    if test -n \"$dlfiles$dlprefiles\" || test \"$dlself\" != no; then\n      if test -n \"$NM\" && test -n \"$global_symbol_pipe\"; then\n\tmy_dlsyms=\"${my_outputname}S.c\"\n      else\n\tfunc_error \"not configured to extract global symbols from dlpreopened files\"\n      fi\n    fi\n\n    if test -n \"$my_dlsyms\"; then\n      case $my_dlsyms in\n      \"\") ;;\n      *.c)\n\t# Discover the nlist of each of the dlfiles.\n\tnlist=\"$output_objdir/${my_outputname}.nm\"\n\n\tfunc_show_eval \"$RM $nlist ${nlist}S ${nlist}T\"\n\n\t# Parse the name list into a source file.\n\tfunc_verbose \"creating $output_objdir/$my_dlsyms\"\n\n\t$opt_dry_run || $ECHO > \"$output_objdir/$my_dlsyms\" \"\\\n/* $my_dlsyms - symbol resolution table for \\`$my_outputname' dlsym emulation. */\n/* Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION */\n\n#ifdef __cplusplus\nextern \\\"C\\\" {\n#endif\n\n/* External symbol declarations for the compiler. */\\\n\"\n\n\tif test \"$dlself\" = yes; then\n\t  func_verbose \"generating symbol list for \\`$output'\"\n\n\t  $opt_dry_run || echo ': @PROGRAM@ ' > \"$nlist\"\n\n\t  # Add our own program objects to the symbol list.\n\t  progfiles=`$ECHO \"X$objs$old_deplibs\" | $SP2NL | $Xsed -e \"$lo2o\" | $NL2SP`\n\t  for progfile in $progfiles; do\n\t    func_verbose \"extracting global C symbols from \\`$progfile'\"\n\t    $opt_dry_run || eval \"$NM $progfile | $global_symbol_pipe >> '$nlist'\"\n\t  done\n\n\t  if test -n \"$exclude_expsyms\"; then\n\t    $opt_dry_run || {\n\t      eval '$EGREP -v \" ($exclude_expsyms)$\" \"$nlist\" > \"$nlist\"T'\n\t      eval '$MV \"$nlist\"T \"$nlist\"'\n\t    }\n\t  fi\n\n\t  if test -n \"$export_symbols_regex\"; then\n\t    $opt_dry_run || {\n\t      eval '$EGREP -e \"$export_symbols_regex\" \"$nlist\" > \"$nlist\"T'\n\t      eval '$MV \"$nlist\"T \"$nlist\"'\n\t    }\n\t  fi\n\n\t  # Prepare the list of exported symbols\n\t  if test -z \"$export_symbols\"; then\n\t    export_symbols=\"$output_objdir/$outputname.exp\"\n\t    $opt_dry_run || {\n\t      $RM $export_symbols\n\t      eval \"${SED} -n -e '/^: @PROGRAM@ $/d' -e 's/^.* \\(.*\\)$/\\1/p' \"'< \"$nlist\" > \"$export_symbols\"'\n\t      case $host in\n\t      *cygwin* | *mingw* | *cegcc* )\n                eval \"echo EXPORTS \"'> \"$output_objdir/$outputname.def\"'\n                eval 'cat \"$export_symbols\" >> \"$output_objdir/$outputname.def\"'\n\t        ;;\n\t      esac\n\t    }\n\t  else\n\t    $opt_dry_run || {\n\t      eval \"${SED} -e 's/\\([].[*^$]\\)/\\\\\\\\\\1/g' -e 's/^/ /' -e 's/$/$/'\"' < \"$export_symbols\" > \"$output_objdir/$outputname.exp\"'\n\t      eval '$GREP -f \"$output_objdir/$outputname.exp\" < \"$nlist\" > \"$nlist\"T'\n\t      eval '$MV \"$nlist\"T \"$nlist\"'\n\t      case $host in\n\t        *cygwin | *mingw* | *cegcc* )\n\t          eval \"echo EXPORTS \"'> \"$output_objdir/$outputname.def\"'\n\t          eval 'cat \"$nlist\" >> \"$output_objdir/$outputname.def\"'\n\t          ;;\n\t      esac\n\t    }\n\t  fi\n\tfi\n\n\tfor dlprefile in $dlprefiles; do\n\t  func_verbose \"extracting global C symbols from \\`$dlprefile'\"\n\t  func_basename \"$dlprefile\"\n\t  name=\"$func_basename_result\"\n\t  $opt_dry_run || {\n\t    eval '$ECHO \": $name \" >> \"$nlist\"'\n\t    eval \"$NM $dlprefile 2>/dev/null | $global_symbol_pipe >> '$nlist'\"\n\t  }\n\tdone\n\n\t$opt_dry_run || {\n\t  # Make sure we have at least an empty file.\n\t  test -f \"$nlist\" || : > \"$nlist\"\n\n\t  if test -n \"$exclude_expsyms\"; then\n\t    $EGREP -v \" ($exclude_expsyms)$\" \"$nlist\" > \"$nlist\"T\n\t    $MV \"$nlist\"T \"$nlist\"\n\t  fi\n\n\t  # Try sorting and uniquifying the output.\n\t  if $GREP -v \"^: \" < \"$nlist\" |\n\t      if sort -k 3 </dev/null >/dev/null 2>&1; then\n\t\tsort -k 3\n\t      else\n\t\tsort +2\n\t      fi |\n\t      uniq > \"$nlist\"S; then\n\t    :\n\t  else\n\t    $GREP -v \"^: \" < \"$nlist\" > \"$nlist\"S\n\t  fi\n\n\t  if test -f \"$nlist\"S; then\n\t    eval \"$global_symbol_to_cdecl\"' < \"$nlist\"S >> \"$output_objdir/$my_dlsyms\"'\n\t  else\n\t    $ECHO '/* NONE */' >> \"$output_objdir/$my_dlsyms\"\n\t  fi\n\n\t  $ECHO >> \"$output_objdir/$my_dlsyms\" \"\\\n\n/* The mapping between symbol names and symbols.  */\ntypedef struct {\n  const char *name;\n  void *address;\n} lt_dlsymlist;\n\"\n\t  case $host in\n\t  *cygwin* | *mingw* | *cegcc* )\n\t    $ECHO >> \"$output_objdir/$my_dlsyms\" \"\\\n/* DATA imports from DLLs on WIN32 con't be const, because\n   runtime relocations are performed -- see ld's documentation\n   on pseudo-relocs.  */\"\n\t    lt_dlsym_const= ;;\n\t  *osf5*)\n\t    echo >> \"$output_objdir/$my_dlsyms\" \"\\\n/* This system does not cope well with relocations in const data */\"\n\t    lt_dlsym_const= ;;\n\t  *)\n\t    lt_dlsym_const=const ;;\n\t  esac\n\n\t  $ECHO >> \"$output_objdir/$my_dlsyms\" \"\\\nextern $lt_dlsym_const lt_dlsymlist\nlt_${my_prefix}_LTX_preloaded_symbols[];\n$lt_dlsym_const lt_dlsymlist\nlt_${my_prefix}_LTX_preloaded_symbols[] =\n{\\\n  { \\\"$my_originator\\\", (void *) 0 },\"\n\n\t  case $need_lib_prefix in\n\t  no)\n\t    eval \"$global_symbol_to_c_name_address\" < \"$nlist\" >> \"$output_objdir/$my_dlsyms\"\n\t    ;;\n\t  *)\n\t    eval \"$global_symbol_to_c_name_address_lib_prefix\" < \"$nlist\" >> \"$output_objdir/$my_dlsyms\"\n\t    ;;\n\t  esac\n\t  $ECHO >> \"$output_objdir/$my_dlsyms\" \"\\\n  {0, (void *) 0}\n};\n\n/* This works around a problem in FreeBSD linker */\n#ifdef FREEBSD_WORKAROUND\nstatic const void *lt_preloaded_setup() {\n  return lt_${my_prefix}_LTX_preloaded_symbols;\n}\n#endif\n\n#ifdef __cplusplus\n}\n#endif\\\n\"\n\t} # !$opt_dry_run\n\n\tpic_flag_for_symtable=\n\tcase \"$compile_command \" in\n\t*\" -static \"*) ;;\n\t*)\n\t  case $host in\n\t  # compiling the symbol table file with pic_flag works around\n\t  # a FreeBSD bug that causes programs to crash when -lm is\n\t  # linked before any other PIC object.  But we must not use\n\t  # pic_flag when linking with -static.  The problem exists in\n\t  # FreeBSD 2.2.6 and is fixed in FreeBSD 3.1.\n\t  *-*-freebsd2*|*-*-freebsd3.0*|*-*-freebsdelf3.0*)\n\t    pic_flag_for_symtable=\" $pic_flag -DFREEBSD_WORKAROUND\" ;;\n\t  *-*-hpux*)\n\t    pic_flag_for_symtable=\" $pic_flag\"  ;;\n\t  *)\n\t    if test \"X$my_pic_p\" != Xno; then\n\t      pic_flag_for_symtable=\" $pic_flag\"\n\t    fi\n\t    ;;\n\t  esac\n\t  ;;\n\tesac\n\tsymtab_cflags=\n\tfor arg in $LTCFLAGS; do\n\t  case $arg in\n\t  -pie | -fpie | -fPIE) ;;\n\t  *) symtab_cflags=\"$symtab_cflags $arg\" ;;\n\t  esac\n\tdone\n\n\t# Now compile the dynamic symbol file.\n\tfunc_show_eval '(cd $output_objdir && $LTCC$symtab_cflags -c$no_builtin_flag$pic_flag_for_symtable \"$my_dlsyms\")' 'exit $?'\n\n\t# Clean up the generated files.\n\tfunc_show_eval '$RM \"$output_objdir/$my_dlsyms\" \"$nlist\" \"${nlist}S\" \"${nlist}T\"'\n\n\t# Transform the symbol file into the correct name.\n\tsymfileobj=\"$output_objdir/${my_outputname}S.$objext\"\n\tcase $host in\n\t*cygwin* | *mingw* | *cegcc* )\n\t  if test -f \"$output_objdir/$my_outputname.def\"; then\n\t    compile_command=`$ECHO \"X$compile_command\" | $Xsed -e \"s%@SYMFILE@%$output_objdir/$my_outputname.def $symfileobj%\"`\n\t    finalize_command=`$ECHO \"X$finalize_command\" | $Xsed -e \"s%@SYMFILE@%$output_objdir/$my_outputname.def $symfileobj%\"`\n\t  else\n\t    compile_command=`$ECHO \"X$compile_command\" | $Xsed -e \"s%@SYMFILE@%$symfileobj%\"`\n\t    finalize_command=`$ECHO \"X$finalize_command\" | $Xsed -e \"s%@SYMFILE@%$symfileobj%\"`\n\t  fi\n\t  ;;\n\t*)\n\t  compile_command=`$ECHO \"X$compile_command\" | $Xsed -e \"s%@SYMFILE@%$symfileobj%\"`\n\t  finalize_command=`$ECHO \"X$finalize_command\" | $Xsed -e \"s%@SYMFILE@%$symfileobj%\"`\n\t  ;;\n\tesac\n\t;;\n      *)\n\tfunc_fatal_error \"unknown suffix for \\`$my_dlsyms'\"\n\t;;\n      esac\n    else\n      # We keep going just in case the user didn't refer to\n      # lt_preloaded_symbols.  The linker will fail if global_symbol_pipe\n      # really was required.\n\n      # Nullify the symbol file.\n      compile_command=`$ECHO \"X$compile_command\" | $Xsed -e \"s% @SYMFILE@%%\"`\n      finalize_command=`$ECHO \"X$finalize_command\" | $Xsed -e \"s% @SYMFILE@%%\"`\n    fi\n}\n\n# func_win32_libid arg\n# return the library type of file 'arg'\n#\n# Need a lot of goo to handle *both* DLLs and import libs\n# Has to be a shell function in order to 'eat' the argument\n# that is supplied when $file_magic_command is called.\nfunc_win32_libid ()\n{\n  $opt_debug\n  win32_libid_type=\"unknown\"\n  win32_fileres=`file -L $1 2>/dev/null`\n  case $win32_fileres in\n  *ar\\ archive\\ import\\ library*) # definitely import\n    win32_libid_type=\"x86 archive import\"\n    ;;\n  *ar\\ archive*) # could be an import, or static\n    if eval $OBJDUMP -f $1 | $SED -e '10q' 2>/dev/null |\n       $EGREP 'file format pe-i386(.*architecture: i386)?' >/dev/null ; then\n      win32_nmres=`eval $NM -f posix -A $1 |\n\t$SED -n -e '\n\t    1,100{\n\t\t/ I /{\n\t\t    s,.*,import,\n\t\t    p\n\t\t    q\n\t\t}\n\t    }'`\n      case $win32_nmres in\n      import*)  win32_libid_type=\"x86 archive import\";;\n      *)        win32_libid_type=\"x86 archive static\";;\n      esac\n    fi\n    ;;\n  *DLL*)\n    win32_libid_type=\"x86 DLL\"\n    ;;\n  *executable*) # but shell scripts are \"executable\" too...\n    case $win32_fileres in\n    *MS\\ Windows\\ PE\\ Intel*)\n      win32_libid_type=\"x86 DLL\"\n      ;;\n    esac\n    ;;\n  esac\n  $ECHO \"$win32_libid_type\"\n}\n\n\n\n# func_extract_an_archive dir oldlib\nfunc_extract_an_archive ()\n{\n    $opt_debug\n    f_ex_an_ar_dir=\"$1\"; shift\n    f_ex_an_ar_oldlib=\"$1\"\n    func_show_eval \"(cd \\$f_ex_an_ar_dir && $AR x \\\"\\$f_ex_an_ar_oldlib\\\")\" 'exit $?'\n    if ($AR t \"$f_ex_an_ar_oldlib\" | sort | sort -uc >/dev/null 2>&1); then\n     :\n    else\n      func_fatal_error \"object name conflicts in archive: $f_ex_an_ar_dir/$f_ex_an_ar_oldlib\"\n    fi\n}\n\n\n# func_extract_archives gentop oldlib ...\nfunc_extract_archives ()\n{\n    $opt_debug\n    my_gentop=\"$1\"; shift\n    my_oldlibs=${1+\"$@\"}\n    my_oldobjs=\"\"\n    my_xlib=\"\"\n    my_xabs=\"\"\n    my_xdir=\"\"\n\n    for my_xlib in $my_oldlibs; do\n      # Extract the objects.\n      case $my_xlib in\n\t[\\\\/]* | [A-Za-z]:[\\\\/]*) my_xabs=\"$my_xlib\" ;;\n\t*) my_xabs=`pwd`\"/$my_xlib\" ;;\n      esac\n      func_basename \"$my_xlib\"\n      my_xlib=\"$func_basename_result\"\n      my_xlib_u=$my_xlib\n      while :; do\n        case \" $extracted_archives \" in\n\t*\" $my_xlib_u \"*)\n\t  func_arith $extracted_serial + 1\n\t  extracted_serial=$func_arith_result\n\t  my_xlib_u=lt$extracted_serial-$my_xlib ;;\n\t*) break ;;\n\tesac\n      done\n      extracted_archives=\"$extracted_archives $my_xlib_u\"\n      my_xdir=\"$my_gentop/$my_xlib_u\"\n\n      func_mkdir_p \"$my_xdir\"\n\n      case $host in\n      *-darwin*)\n\tfunc_verbose \"Extracting $my_xabs\"\n\t# Do not bother doing anything if just a dry run\n\t$opt_dry_run || {\n\t  darwin_orig_dir=`pwd`\n\t  cd $my_xdir || exit $?\n\t  darwin_archive=$my_xabs\n\t  darwin_curdir=`pwd`\n\t  darwin_base_archive=`basename \"$darwin_archive\"`\n\t  darwin_arches=`$LIPO -info \"$darwin_archive\" 2>/dev/null | $GREP Architectures 2>/dev/null || true`\n\t  if test -n \"$darwin_arches\"; then\n\t    darwin_arches=`$ECHO \"$darwin_arches\" | $SED -e 's/.*are://'`\n\t    darwin_arch=\n\t    func_verbose \"$darwin_base_archive has multiple architectures $darwin_arches\"\n\t    for darwin_arch in  $darwin_arches ; do\n\t      func_mkdir_p \"unfat-$$/${darwin_base_archive}-${darwin_arch}\"\n\t      $LIPO -thin $darwin_arch -output \"unfat-$$/${darwin_base_archive}-${darwin_arch}/${darwin_base_archive}\" \"${darwin_archive}\"\n\t      cd \"unfat-$$/${darwin_base_archive}-${darwin_arch}\"\n\t      func_extract_an_archive \"`pwd`\" \"${darwin_base_archive}\"\n\t      cd \"$darwin_curdir\"\n\t      $RM \"unfat-$$/${darwin_base_archive}-${darwin_arch}/${darwin_base_archive}\"\n\t    done # $darwin_arches\n            ## Okay now we've a bunch of thin objects, gotta fatten them up :)\n\t    darwin_filelist=`find unfat-$$ -type f -name \\*.o -print -o -name \\*.lo -print | $SED -e \"$basename\" | sort -u`\n\t    darwin_file=\n\t    darwin_files=\n\t    for darwin_file in $darwin_filelist; do\n\t      darwin_files=`find unfat-$$ -name $darwin_file -print | $NL2SP`\n\t      $LIPO -create -output \"$darwin_file\" $darwin_files\n\t    done # $darwin_filelist\n\t    $RM -rf unfat-$$\n\t    cd \"$darwin_orig_dir\"\n\t  else\n\t    cd $darwin_orig_dir\n\t    func_extract_an_archive \"$my_xdir\" \"$my_xabs\"\n\t  fi # $darwin_arches\n\t} # !$opt_dry_run\n\t;;\n      *)\n        func_extract_an_archive \"$my_xdir\" \"$my_xabs\"\n\t;;\n      esac\n      my_oldobjs=\"$my_oldobjs \"`find $my_xdir -name \\*.$objext -print -o -name \\*.lo -print | $NL2SP`\n    done\n\n    func_extract_archives_result=\"$my_oldobjs\"\n}\n\n\n\n# func_emit_wrapper_part1 [arg=no]\n#\n# Emit the first part of a libtool wrapper script on stdout.\n# For more information, see the description associated with\n# func_emit_wrapper(), below.\nfunc_emit_wrapper_part1 ()\n{\n\tfunc_emit_wrapper_part1_arg1=no\n\tif test -n \"$1\" ; then\n\t  func_emit_wrapper_part1_arg1=$1\n\tfi\n\n\t$ECHO \"\\\n#! $SHELL\n\n# $output - temporary wrapper script for $objdir/$outputname\n# Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION\n#\n# The $output program cannot be directly executed until all the libtool\n# libraries that it depends on are installed.\n#\n# This wrapper script should never be moved out of the build directory.\n# If it is, it will not operate correctly.\n\n# Sed substitution that helps us do robust quoting.  It backslashifies\n# metacharacters that are still active within double-quoted strings.\nXsed='${SED} -e 1s/^X//'\nsed_quote_subst='$sed_quote_subst'\n\n# Be Bourne compatible\nif test -n \\\"\\${ZSH_VERSION+set}\\\" && (emulate sh) >/dev/null 2>&1; then\n  emulate sh\n  NULLCMD=:\n  # Zsh 3.x and 4.x performs word splitting on \\${1+\\\"\\$@\\\"}, which\n  # is contrary to our usage.  Disable this feature.\n  alias -g '\\${1+\\\"\\$@\\\"}'='\\\"\\$@\\\"'\n  setopt NO_GLOB_SUBST\nelse\n  case \\`(set -o) 2>/dev/null\\` in *posix*) set -o posix;; esac\nfi\nBIN_SH=xpg4; export BIN_SH # for Tru64\nDUALCASE=1; export DUALCASE # for MKS sh\n\n# The HP-UX ksh and POSIX shell print the target directory to stdout\n# if CDPATH is set.\n(unset CDPATH) >/dev/null 2>&1 && unset CDPATH\n\nrelink_command=\\\"$relink_command\\\"\n\n# This environment variable determines our operation mode.\nif test \\\"\\$libtool_install_magic\\\" = \\\"$magic\\\"; then\n  # install mode needs the following variables:\n  generated_by_libtool_version='$macro_version'\n  notinst_deplibs='$notinst_deplibs'\nelse\n  # When we are sourced in execute mode, \\$file and \\$ECHO are already set.\n  if test \\\"\\$libtool_execute_magic\\\" != \\\"$magic\\\"; then\n    ECHO=\\\"$qecho\\\"\n    file=\\\"\\$0\\\"\n    # Make sure echo works.\n    if test \\\"X\\$1\\\" = X--no-reexec; then\n      # Discard the --no-reexec flag, and continue.\n      shift\n    elif test \\\"X\\`{ \\$ECHO '\\t'; } 2>/dev/null\\`\\\" = 'X\\t'; then\n      # Yippee, \\$ECHO works!\n      :\n    else\n      # Restart under the correct shell, and then maybe \\$ECHO will work.\n      exec $SHELL \\\"\\$0\\\" --no-reexec \\${1+\\\"\\$@\\\"}\n    fi\n  fi\\\n\"\n\t$ECHO \"\\\n\n  # Find the directory that this script lives in.\n  thisdir=\\`\\$ECHO \\\"X\\$file\\\" | \\$Xsed -e 's%/[^/]*$%%'\\`\n  test \\\"x\\$thisdir\\\" = \\\"x\\$file\\\" && thisdir=.\n\n  # Follow symbolic links until we get to the real thisdir.\n  file=\\`ls -ld \\\"\\$file\\\" | ${SED} -n 's/.*-> //p'\\`\n  while test -n \\\"\\$file\\\"; do\n    destdir=\\`\\$ECHO \\\"X\\$file\\\" | \\$Xsed -e 's%/[^/]*\\$%%'\\`\n\n    # If there was a directory component, then change thisdir.\n    if test \\\"x\\$destdir\\\" != \\\"x\\$file\\\"; then\n      case \\\"\\$destdir\\\" in\n      [\\\\\\\\/]* | [A-Za-z]:[\\\\\\\\/]*) thisdir=\\\"\\$destdir\\\" ;;\n      *) thisdir=\\\"\\$thisdir/\\$destdir\\\" ;;\n      esac\n    fi\n\n    file=\\`\\$ECHO \\\"X\\$file\\\" | \\$Xsed -e 's%^.*/%%'\\`\n    file=\\`ls -ld \\\"\\$thisdir/\\$file\\\" | ${SED} -n 's/.*-> //p'\\`\n  done\n\"\n}\n# end: func_emit_wrapper_part1\n\n# func_emit_wrapper_part2 [arg=no]\n#\n# Emit the second part of a libtool wrapper script on stdout.\n# For more information, see the description associated with\n# func_emit_wrapper(), below.\nfunc_emit_wrapper_part2 ()\n{\n\tfunc_emit_wrapper_part2_arg1=no\n\tif test -n \"$1\" ; then\n\t  func_emit_wrapper_part2_arg1=$1\n\tfi\n\n\t$ECHO \"\\\n\n  # Usually 'no', except on cygwin/mingw when embedded into\n  # the cwrapper.\n  WRAPPER_SCRIPT_BELONGS_IN_OBJDIR=$func_emit_wrapper_part2_arg1\n  if test \\\"\\$WRAPPER_SCRIPT_BELONGS_IN_OBJDIR\\\" = \\\"yes\\\"; then\n    # special case for '.'\n    if test \\\"\\$thisdir\\\" = \\\".\\\"; then\n      thisdir=\\`pwd\\`\n    fi\n    # remove .libs from thisdir\n    case \\\"\\$thisdir\\\" in\n    *[\\\\\\\\/]$objdir ) thisdir=\\`\\$ECHO \\\"X\\$thisdir\\\" | \\$Xsed -e 's%[\\\\\\\\/][^\\\\\\\\/]*$%%'\\` ;;\n    $objdir )   thisdir=. ;;\n    esac\n  fi\n\n  # Try to get the absolute directory name.\n  absdir=\\`cd \\\"\\$thisdir\\\" && pwd\\`\n  test -n \\\"\\$absdir\\\" && thisdir=\\\"\\$absdir\\\"\n\"\n\n\tif test \"$fast_install\" = yes; then\n\t  $ECHO \"\\\n  program=lt-'$outputname'$exeext\n  progdir=\\\"\\$thisdir/$objdir\\\"\n\n  if test ! -f \\\"\\$progdir/\\$program\\\" ||\n     { file=\\`ls -1dt \\\"\\$progdir/\\$program\\\" \\\"\\$progdir/../\\$program\\\" 2>/dev/null | ${SED} 1q\\`; \\\\\n       test \\\"X\\$file\\\" != \\\"X\\$progdir/\\$program\\\"; }; then\n\n    file=\\\"\\$\\$-\\$program\\\"\n\n    if test ! -d \\\"\\$progdir\\\"; then\n      $MKDIR \\\"\\$progdir\\\"\n    else\n      $RM \\\"\\$progdir/\\$file\\\"\n    fi\"\n\n\t  $ECHO \"\\\n\n    # relink executable if necessary\n    if test -n \\\"\\$relink_command\\\"; then\n      if relink_command_output=\\`eval \\$relink_command 2>&1\\`; then :\n      else\n\t$ECHO \\\"\\$relink_command_output\\\" >&2\n\t$RM \\\"\\$progdir/\\$file\\\"\n\texit 1\n      fi\n    fi\n\n    $MV \\\"\\$progdir/\\$file\\\" \\\"\\$progdir/\\$program\\\" 2>/dev/null ||\n    { $RM \\\"\\$progdir/\\$program\\\";\n      $MV \\\"\\$progdir/\\$file\\\" \\\"\\$progdir/\\$program\\\"; }\n    $RM \\\"\\$progdir/\\$file\\\"\n  fi\"\n\telse\n\t  $ECHO \"\\\n  program='$outputname'\n  progdir=\\\"\\$thisdir/$objdir\\\"\n\"\n\tfi\n\n\t$ECHO \"\\\n\n  if test -f \\\"\\$progdir/\\$program\\\"; then\"\n\n\t# Export our shlibpath_var if we have one.\n\tif test \"$shlibpath_overrides_runpath\" = yes && test -n \"$shlibpath_var\" && test -n \"$temp_rpath\"; then\n\t  $ECHO \"\\\n    # Add our own library path to $shlibpath_var\n    $shlibpath_var=\\\"$temp_rpath\\$$shlibpath_var\\\"\n\n    # Some systems cannot cope with colon-terminated $shlibpath_var\n    # The second colon is a workaround for a bug in BeOS R4 sed\n    $shlibpath_var=\\`\\$ECHO \\\"X\\$$shlibpath_var\\\" | \\$Xsed -e 's/::*\\$//'\\`\n\n    export $shlibpath_var\n\"\n\tfi\n\n\t# fixup the dll searchpath if we need to.\n\tif test -n \"$dllsearchpath\"; then\n\t  $ECHO \"\\\n    # Add the dll search path components to the executable PATH\n    PATH=$dllsearchpath:\\$PATH\n\"\n\tfi\n\n\t$ECHO \"\\\n    if test \\\"\\$libtool_execute_magic\\\" != \\\"$magic\\\"; then\n      # Run the actual program with our arguments.\n\"\n\tcase $host in\n\t# Backslashes separate directories on plain windows\n\t*-*-mingw | *-*-os2* | *-cegcc*)\n\t  $ECHO \"\\\n      exec \\\"\\$progdir\\\\\\\\\\$program\\\" \\${1+\\\"\\$@\\\"}\n\"\n\t  ;;\n\n\t*)\n\t  $ECHO \"\\\n      exec \\\"\\$progdir/\\$program\\\" \\${1+\\\"\\$@\\\"}\n\"\n\t  ;;\n\tesac\n\t$ECHO \"\\\n      \\$ECHO \\\"\\$0: cannot exec \\$program \\$*\\\" 1>&2\n      exit 1\n    fi\n  else\n    # The program doesn't exist.\n    \\$ECHO \\\"\\$0: error: \\\\\\`\\$progdir/\\$program' does not exist\\\" 1>&2\n    \\$ECHO \\\"This script is just a wrapper for \\$program.\\\" 1>&2\n    $ECHO \\\"See the $PACKAGE documentation for more information.\\\" 1>&2\n    exit 1\n  fi\nfi\\\n\"\n}\n# end: func_emit_wrapper_part2\n\n\n# func_emit_wrapper [arg=no]\n#\n# Emit a libtool wrapper script on stdout.\n# Don't directly open a file because we may want to\n# incorporate the script contents within a cygwin/mingw\n# wrapper executable.  Must ONLY be called from within\n# func_mode_link because it depends on a number of variables\n# set therein.\n#\n# ARG is the value that the WRAPPER_SCRIPT_BELONGS_IN_OBJDIR\n# variable will take.  If 'yes', then the emitted script\n# will assume that the directory in which it is stored is\n# the $objdir directory.  This is a cygwin/mingw-specific\n# behavior.\nfunc_emit_wrapper ()\n{\n\tfunc_emit_wrapper_arg1=no\n\tif test -n \"$1\" ; then\n\t  func_emit_wrapper_arg1=$1\n\tfi\n\n\t# split this up so that func_emit_cwrapperexe_src\n\t# can call each part independently.\n\tfunc_emit_wrapper_part1 \"${func_emit_wrapper_arg1}\"\n\tfunc_emit_wrapper_part2 \"${func_emit_wrapper_arg1}\"\n}\n\n\n# func_to_host_path arg\n#\n# Convert paths to host format when used with build tools.\n# Intended for use with \"native\" mingw (where libtool itself\n# is running under the msys shell), or in the following cross-\n# build environments:\n#    $build          $host\n#    mingw (msys)    mingw  [e.g. native]\n#    cygwin          mingw\n#    *nix + wine     mingw\n# where wine is equipped with the `winepath' executable.\n# In the native mingw case, the (msys) shell automatically\n# converts paths for any non-msys applications it launches,\n# but that facility isn't available from inside the cwrapper.\n# Similar accommodations are necessary for $host mingw and\n# $build cygwin.  Calling this function does no harm for other\n# $host/$build combinations not listed above.\n#\n# ARG is the path (on $build) that should be converted to\n# the proper representation for $host. The result is stored\n# in $func_to_host_path_result.\nfunc_to_host_path ()\n{\n  func_to_host_path_result=\"$1\"\n  if test -n \"$1\" ; then\n    case $host in\n      *mingw* )\n        lt_sed_naive_backslashify='s|\\\\\\\\*|\\\\|g;s|/|\\\\|g;s|\\\\|\\\\\\\\|g'\n        case $build in\n          *mingw* ) # actually, msys\n            # awkward: cmd appends spaces to result\n            lt_sed_strip_trailing_spaces=\"s/[ ]*\\$//\"\n            func_to_host_path_tmp1=`( cmd //c echo \"$1\" |\\\n              $SED -e \"$lt_sed_strip_trailing_spaces\" ) 2>/dev/null || echo \"\"`\n            func_to_host_path_result=`echo \"$func_to_host_path_tmp1\" |\\\n              $SED -e \"$lt_sed_naive_backslashify\"`\n            ;;\n          *cygwin* )\n            func_to_host_path_tmp1=`cygpath -w \"$1\"`\n            func_to_host_path_result=`echo \"$func_to_host_path_tmp1\" |\\\n              $SED -e \"$lt_sed_naive_backslashify\"`\n            ;;\n          * )\n            # Unfortunately, winepath does not exit with a non-zero\n            # error code, so we are forced to check the contents of\n            # stdout. On the other hand, if the command is not\n            # found, the shell will set an exit code of 127 and print\n            # *an error message* to stdout. So we must check for both\n            # error code of zero AND non-empty stdout, which explains\n            # the odd construction:\n            func_to_host_path_tmp1=`winepath -w \"$1\" 2>/dev/null`\n            if test \"$?\" -eq 0 && test -n \"${func_to_host_path_tmp1}\"; then\n              func_to_host_path_result=`echo \"$func_to_host_path_tmp1\" |\\\n                $SED -e \"$lt_sed_naive_backslashify\"`\n            else\n              # Allow warning below.\n              func_to_host_path_result=\"\"\n            fi\n            ;;\n        esac\n        if test -z \"$func_to_host_path_result\" ; then\n          func_error \"Could not determine host path corresponding to\"\n          func_error \"  '$1'\"\n          func_error \"Continuing, but uninstalled executables may not work.\"\n          # Fallback:\n          func_to_host_path_result=\"$1\"\n        fi\n        ;;\n    esac\n  fi\n}\n# end: func_to_host_path\n\n# func_to_host_pathlist arg\n#\n# Convert pathlists to host format when used with build tools.\n# See func_to_host_path(), above. This function supports the\n# following $build/$host combinations (but does no harm for\n# combinations not listed here):\n#    $build          $host\n#    mingw (msys)    mingw  [e.g. native]\n#    cygwin          mingw\n#    *nix + wine     mingw\n#\n# Path separators are also converted from $build format to\n# $host format. If ARG begins or ends with a path separator\n# character, it is preserved (but converted to $host format)\n# on output.\n#\n# ARG is a pathlist (on $build) that should be converted to\n# the proper representation on $host. The result is stored\n# in $func_to_host_pathlist_result.\nfunc_to_host_pathlist ()\n{\n  func_to_host_pathlist_result=\"$1\"\n  if test -n \"$1\" ; then\n    case $host in\n      *mingw* )\n        lt_sed_naive_backslashify='s|\\\\\\\\*|\\\\|g;s|/|\\\\|g;s|\\\\|\\\\\\\\|g'\n        # Remove leading and trailing path separator characters from\n        # ARG. msys behavior is inconsistent here, cygpath turns them\n        # into '.;' and ';.', and winepath ignores them completely.\n        func_to_host_pathlist_tmp2=\"$1\"\n        # Once set for this call, this variable should not be\n        # reassigned. It is used in tha fallback case.\n        func_to_host_pathlist_tmp1=`echo \"$func_to_host_pathlist_tmp2\" |\\\n          $SED -e 's|^:*||' -e 's|:*$||'`\n        case $build in\n          *mingw* ) # Actually, msys.\n            # Awkward: cmd appends spaces to result.\n            lt_sed_strip_trailing_spaces=\"s/[ ]*\\$//\"\n            func_to_host_pathlist_tmp2=`( cmd //c echo \"$func_to_host_pathlist_tmp1\" |\\\n              $SED -e \"$lt_sed_strip_trailing_spaces\" ) 2>/dev/null || echo \"\"`\n            func_to_host_pathlist_result=`echo \"$func_to_host_pathlist_tmp2\" |\\\n              $SED -e \"$lt_sed_naive_backslashify\"`\n            ;;\n          *cygwin* )\n            func_to_host_pathlist_tmp2=`cygpath -w -p \"$func_to_host_pathlist_tmp1\"`\n            func_to_host_pathlist_result=`echo \"$func_to_host_pathlist_tmp2\" |\\\n              $SED -e \"$lt_sed_naive_backslashify\"`\n            ;;\n          * )\n            # unfortunately, winepath doesn't convert pathlists\n            func_to_host_pathlist_result=\"\"\n            func_to_host_pathlist_oldIFS=$IFS\n            IFS=:\n            for func_to_host_pathlist_f in $func_to_host_pathlist_tmp1 ; do\n              IFS=$func_to_host_pathlist_oldIFS\n              if test -n \"$func_to_host_pathlist_f\" ; then\n                func_to_host_path \"$func_to_host_pathlist_f\"\n                if test -n \"$func_to_host_path_result\" ; then\n                  if test -z \"$func_to_host_pathlist_result\" ; then\n                    func_to_host_pathlist_result=\"$func_to_host_path_result\"\n                  else\n                    func_to_host_pathlist_result=\"$func_to_host_pathlist_result;$func_to_host_path_result\"\n                  fi\n                fi\n              fi\n              IFS=:\n            done\n            IFS=$func_to_host_pathlist_oldIFS\n            ;;\n        esac\n        if test -z \"$func_to_host_pathlist_result\" ; then\n          func_error \"Could not determine the host path(s) corresponding to\"\n          func_error \"  '$1'\"\n          func_error \"Continuing, but uninstalled executables may not work.\"\n          # Fallback. This may break if $1 contains DOS-style drive\n          # specifications. The fix is not to complicate the expression\n          # below, but for the user to provide a working wine installation\n          # with winepath so that path translation in the cross-to-mingw\n          # case works properly.\n          lt_replace_pathsep_nix_to_dos=\"s|:|;|g\"\n          func_to_host_pathlist_result=`echo \"$func_to_host_pathlist_tmp1\" |\\\n            $SED -e \"$lt_replace_pathsep_nix_to_dos\"`\n        fi\n        # Now, add the leading and trailing path separators back\n        case \"$1\" in\n          :* ) func_to_host_pathlist_result=\";$func_to_host_pathlist_result\"\n            ;;\n        esac\n        case \"$1\" in\n          *: ) func_to_host_pathlist_result=\"$func_to_host_pathlist_result;\"\n            ;;\n        esac\n        ;;\n    esac\n  fi\n}\n# end: func_to_host_pathlist\n\n# func_emit_cwrapperexe_src\n# emit the source code for a wrapper executable on stdout\n# Must ONLY be called from within func_mode_link because\n# it depends on a number of variable set therein.\nfunc_emit_cwrapperexe_src ()\n{\n\tcat <<EOF\n\n/* $cwrappersource - temporary wrapper executable for $objdir/$outputname\n   Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION\n\n   The $output program cannot be directly executed until all the libtool\n   libraries that it depends on are installed.\n\n   This wrapper executable should never be moved out of the build directory.\n   If it is, it will not operate correctly.\n\n   Currently, it simply execs the wrapper *script* \"$SHELL $output\",\n   but could eventually absorb all of the scripts functionality and\n   exec $objdir/$outputname directly.\n*/\nEOF\n\t    cat <<\"EOF\"\n#include <stdio.h>\n#include <stdlib.h>\n#ifdef _MSC_VER\n# include <direct.h>\n# include <process.h>\n# include <io.h>\n# define setmode _setmode\n#else\n# include <unistd.h>\n# include <stdint.h>\n# ifdef __CYGWIN__\n#  include <io.h>\n#  define HAVE_SETENV\n#  ifdef __STRICT_ANSI__\nchar *realpath (const char *, char *);\nint putenv (char *);\nint setenv (const char *, const char *, int);\n#  endif\n# endif\n#endif\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include <string.h>\n#include <ctype.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n\n#if defined(PATH_MAX)\n# define LT_PATHMAX PATH_MAX\n#elif defined(MAXPATHLEN)\n# define LT_PATHMAX MAXPATHLEN\n#else\n# define LT_PATHMAX 1024\n#endif\n\n#ifndef S_IXOTH\n# define S_IXOTH 0\n#endif\n#ifndef S_IXGRP\n# define S_IXGRP 0\n#endif\n\n#ifdef _MSC_VER\n# define S_IXUSR _S_IEXEC\n# define stat _stat\n# ifndef _INTPTR_T_DEFINED\n#  define intptr_t int\n# endif\n#endif\n\n#ifndef DIR_SEPARATOR\n# define DIR_SEPARATOR '/'\n# define PATH_SEPARATOR ':'\n#endif\n\n#if defined (_WIN32) || defined (__MSDOS__) || defined (__DJGPP__) || \\\n  defined (__OS2__)\n# define HAVE_DOS_BASED_FILE_SYSTEM\n# define FOPEN_WB \"wb\"\n# ifndef DIR_SEPARATOR_2\n#  define DIR_SEPARATOR_2 '\\\\'\n# endif\n# ifndef PATH_SEPARATOR_2\n#  define PATH_SEPARATOR_2 ';'\n# endif\n#endif\n\n#ifndef DIR_SEPARATOR_2\n# define IS_DIR_SEPARATOR(ch) ((ch) == DIR_SEPARATOR)\n#else /* DIR_SEPARATOR_2 */\n# define IS_DIR_SEPARATOR(ch) \\\n\t(((ch) == DIR_SEPARATOR) || ((ch) == DIR_SEPARATOR_2))\n#endif /* DIR_SEPARATOR_2 */\n\n#ifndef PATH_SEPARATOR_2\n# define IS_PATH_SEPARATOR(ch) ((ch) == PATH_SEPARATOR)\n#else /* PATH_SEPARATOR_2 */\n# define IS_PATH_SEPARATOR(ch) ((ch) == PATH_SEPARATOR_2)\n#endif /* PATH_SEPARATOR_2 */\n\n#ifdef __CYGWIN__\n# define FOPEN_WB \"wb\"\n#endif\n\n#ifndef FOPEN_WB\n# define FOPEN_WB \"w\"\n#endif\n#ifndef _O_BINARY\n# define _O_BINARY 0\n#endif\n\n#define XMALLOC(type, num)      ((type *) xmalloc ((num) * sizeof(type)))\n#define XFREE(stale) do { \\\n  if (stale) { free ((void *) stale); stale = 0; } \\\n} while (0)\n\n#undef LTWRAPPER_DEBUGPRINTF\n#if defined DEBUGWRAPPER\n# define LTWRAPPER_DEBUGPRINTF(args) ltwrapper_debugprintf args\nstatic void\nltwrapper_debugprintf (const char *fmt, ...)\n{\n    va_list args;\n    va_start (args, fmt);\n    (void) vfprintf (stderr, fmt, args);\n    va_end (args);\n}\n#else\n# define LTWRAPPER_DEBUGPRINTF(args)\n#endif\n\nconst char *program_name = NULL;\n\nvoid *xmalloc (size_t num);\nchar *xstrdup (const char *string);\nconst char *base_name (const char *name);\nchar *find_executable (const char *wrapper);\nchar *chase_symlinks (const char *pathspec);\nint make_executable (const char *path);\nint check_executable (const char *path);\nchar *strendzap (char *str, const char *pat);\nvoid lt_fatal (const char *message, ...);\nvoid lt_setenv (const char *name, const char *value);\nchar *lt_extend_str (const char *orig_value, const char *add, int to_end);\nvoid lt_opt_process_env_set (const char *arg);\nvoid lt_opt_process_env_prepend (const char *arg);\nvoid lt_opt_process_env_append (const char *arg);\nint lt_split_name_value (const char *arg, char** name, char** value);\nvoid lt_update_exe_path (const char *name, const char *value);\nvoid lt_update_lib_path (const char *name, const char *value);\n\nstatic const char *script_text_part1 =\nEOF\n\n\t    func_emit_wrapper_part1 yes |\n\t        $SED -e 's/\\([\\\\\"]\\)/\\\\\\1/g' \\\n\t             -e 's/^/  \"/' -e 's/$/\\\\n\"/'\n\t    echo \";\"\n\t    cat <<EOF\n\nstatic const char *script_text_part2 =\nEOF\n\t    func_emit_wrapper_part2 yes |\n\t        $SED -e 's/\\([\\\\\"]\\)/\\\\\\1/g' \\\n\t             -e 's/^/  \"/' -e 's/$/\\\\n\"/'\n\t    echo \";\"\n\n\t    cat <<EOF\nconst char * MAGIC_EXE = \"$magic_exe\";\nconst char * LIB_PATH_VARNAME = \"$shlibpath_var\";\nEOF\n\n\t    if test \"$shlibpath_overrides_runpath\" = yes && test -n \"$shlibpath_var\" && test -n \"$temp_rpath\"; then\n              func_to_host_pathlist \"$temp_rpath\"\n\t      cat <<EOF\nconst char * LIB_PATH_VALUE   = \"$func_to_host_pathlist_result\";\nEOF\n\t    else\n\t      cat <<\"EOF\"\nconst char * LIB_PATH_VALUE   = \"\";\nEOF\n\t    fi\n\n\t    if test -n \"$dllsearchpath\"; then\n              func_to_host_pathlist \"$dllsearchpath:\"\n\t      cat <<EOF\nconst char * EXE_PATH_VARNAME = \"PATH\";\nconst char * EXE_PATH_VALUE   = \"$func_to_host_pathlist_result\";\nEOF\n\t    else\n\t      cat <<\"EOF\"\nconst char * EXE_PATH_VARNAME = \"\";\nconst char * EXE_PATH_VALUE   = \"\";\nEOF\n\t    fi\n\n\t    if test \"$fast_install\" = yes; then\n\t      cat <<EOF\nconst char * TARGET_PROGRAM_NAME = \"lt-$outputname\"; /* hopefully, no .exe */\nEOF\n\t    else\n\t      cat <<EOF\nconst char * TARGET_PROGRAM_NAME = \"$outputname\"; /* hopefully, no .exe */\nEOF\n\t    fi\n\n\n\t    cat <<\"EOF\"\n\n#define LTWRAPPER_OPTION_PREFIX         \"--lt-\"\n#define LTWRAPPER_OPTION_PREFIX_LENGTH  5\n\nstatic const size_t opt_prefix_len         = LTWRAPPER_OPTION_PREFIX_LENGTH;\nstatic const char *ltwrapper_option_prefix = LTWRAPPER_OPTION_PREFIX;\n\nstatic const char *dumpscript_opt       = LTWRAPPER_OPTION_PREFIX \"dump-script\";\n\nstatic const size_t env_set_opt_len     = LTWRAPPER_OPTION_PREFIX_LENGTH + 7;\nstatic const char *env_set_opt          = LTWRAPPER_OPTION_PREFIX \"env-set\";\n  /* argument is putenv-style \"foo=bar\", value of foo is set to bar */\n\nstatic const size_t env_prepend_opt_len = LTWRAPPER_OPTION_PREFIX_LENGTH + 11;\nstatic const char *env_prepend_opt      = LTWRAPPER_OPTION_PREFIX \"env-prepend\";\n  /* argument is putenv-style \"foo=bar\", new value of foo is bar${foo} */\n\nstatic const size_t env_append_opt_len  = LTWRAPPER_OPTION_PREFIX_LENGTH + 10;\nstatic const char *env_append_opt       = LTWRAPPER_OPTION_PREFIX \"env-append\";\n  /* argument is putenv-style \"foo=bar\", new value of foo is ${foo}bar */\n\nint\nmain (int argc, char *argv[])\n{\n  char **newargz;\n  int  newargc;\n  char *tmp_pathspec;\n  char *actual_cwrapper_path;\n  char *actual_cwrapper_name;\n  char *target_name;\n  char *lt_argv_zero;\n  intptr_t rval = 127;\n\n  int i;\n\n  program_name = (char *) xstrdup (base_name (argv[0]));\n  LTWRAPPER_DEBUGPRINTF ((\"(main) argv[0]      : %s\\n\", argv[0]));\n  LTWRAPPER_DEBUGPRINTF ((\"(main) program_name : %s\\n\", program_name));\n\n  /* very simple arg parsing; don't want to rely on getopt */\n  for (i = 1; i < argc; i++)\n    {\n      if (strcmp (argv[i], dumpscript_opt) == 0)\n\t{\nEOF\n\t    case \"$host\" in\n\t      *mingw* | *cygwin* )\n\t\t# make stdout use \"unix\" line endings\n\t\techo \"          setmode(1,_O_BINARY);\"\n\t\t;;\n\t      esac\n\n\t    cat <<\"EOF\"\n\t  printf (\"%s\", script_text_part1);\n\t  printf (\"%s\", script_text_part2);\n\t  return 0;\n\t}\n    }\n\n  newargz = XMALLOC (char *, argc + 1);\n  tmp_pathspec = find_executable (argv[0]);\n  if (tmp_pathspec == NULL)\n    lt_fatal (\"Couldn't find %s\", argv[0]);\n  LTWRAPPER_DEBUGPRINTF ((\"(main) found exe (before symlink chase) at : %s\\n\",\n\t\t\t  tmp_pathspec));\n\n  actual_cwrapper_path = chase_symlinks (tmp_pathspec);\n  LTWRAPPER_DEBUGPRINTF ((\"(main) found exe (after symlink chase) at : %s\\n\",\n\t\t\t  actual_cwrapper_path));\n  XFREE (tmp_pathspec);\n\n  actual_cwrapper_name = xstrdup( base_name (actual_cwrapper_path));\n  strendzap (actual_cwrapper_path, actual_cwrapper_name);\n\n  /* wrapper name transforms */\n  strendzap (actual_cwrapper_name, \".exe\");\n  tmp_pathspec = lt_extend_str (actual_cwrapper_name, \".exe\", 1);\n  XFREE (actual_cwrapper_name);\n  actual_cwrapper_name = tmp_pathspec;\n  tmp_pathspec = 0;\n\n  /* target_name transforms -- use actual target program name; might have lt- prefix */\n  target_name = xstrdup (base_name (TARGET_PROGRAM_NAME));\n  strendzap (target_name, \".exe\");\n  tmp_pathspec = lt_extend_str (target_name, \".exe\", 1);\n  XFREE (target_name);\n  target_name = tmp_pathspec;\n  tmp_pathspec = 0;\n\n  LTWRAPPER_DEBUGPRINTF ((\"(main) libtool target name: %s\\n\",\n\t\t\t  target_name));\nEOF\n\n\t    cat <<EOF\n  newargz[0] =\n    XMALLOC (char, (strlen (actual_cwrapper_path) +\n\t\t    strlen (\"$objdir\") + 1 + strlen (actual_cwrapper_name) + 1));\n  strcpy (newargz[0], actual_cwrapper_path);\n  strcat (newargz[0], \"$objdir\");\n  strcat (newargz[0], \"/\");\nEOF\n\n\t    cat <<\"EOF\"\n  /* stop here, and copy so we don't have to do this twice */\n  tmp_pathspec = xstrdup (newargz[0]);\n\n  /* do NOT want the lt- prefix here, so use actual_cwrapper_name */\n  strcat (newargz[0], actual_cwrapper_name);\n\n  /* DO want the lt- prefix here if it exists, so use target_name */\n  lt_argv_zero = lt_extend_str (tmp_pathspec, target_name, 1);\n  XFREE (tmp_pathspec);\n  tmp_pathspec = NULL;\nEOF\n\n\t    case $host_os in\n\t      mingw*)\n\t    cat <<\"EOF\"\n  {\n    char* p;\n    while ((p = strchr (newargz[0], '\\\\')) != NULL)\n      {\n\t*p = '/';\n      }\n    while ((p = strchr (lt_argv_zero, '\\\\')) != NULL)\n      {\n\t*p = '/';\n      }\n  }\nEOF\n\t    ;;\n\t    esac\n\n\t    cat <<\"EOF\"\n  XFREE (target_name);\n  XFREE (actual_cwrapper_path);\n  XFREE (actual_cwrapper_name);\n\n  lt_setenv (\"BIN_SH\", \"xpg4\"); /* for Tru64 */\n  lt_setenv (\"DUALCASE\", \"1\");  /* for MSK sh */\n  lt_update_lib_path (LIB_PATH_VARNAME, LIB_PATH_VALUE);\n  lt_update_exe_path (EXE_PATH_VARNAME, EXE_PATH_VALUE);\n\n  newargc=0;\n  for (i = 1; i < argc; i++)\n    {\n      if (strncmp (argv[i], env_set_opt, env_set_opt_len) == 0)\n        {\n          if (argv[i][env_set_opt_len] == '=')\n            {\n              const char *p = argv[i] + env_set_opt_len + 1;\n              lt_opt_process_env_set (p);\n            }\n          else if (argv[i][env_set_opt_len] == '\\0' && i + 1 < argc)\n            {\n              lt_opt_process_env_set (argv[++i]); /* don't copy */\n            }\n          else\n            lt_fatal (\"%s missing required argument\", env_set_opt);\n          continue;\n        }\n      if (strncmp (argv[i], env_prepend_opt, env_prepend_opt_len) == 0)\n        {\n          if (argv[i][env_prepend_opt_len] == '=')\n            {\n              const char *p = argv[i] + env_prepend_opt_len + 1;\n              lt_opt_process_env_prepend (p);\n            }\n          else if (argv[i][env_prepend_opt_len] == '\\0' && i + 1 < argc)\n            {\n              lt_opt_process_env_prepend (argv[++i]); /* don't copy */\n            }\n          else\n            lt_fatal (\"%s missing required argument\", env_prepend_opt);\n          continue;\n        }\n      if (strncmp (argv[i], env_append_opt, env_append_opt_len) == 0)\n        {\n          if (argv[i][env_append_opt_len] == '=')\n            {\n              const char *p = argv[i] + env_append_opt_len + 1;\n              lt_opt_process_env_append (p);\n            }\n          else if (argv[i][env_append_opt_len] == '\\0' && i + 1 < argc)\n            {\n              lt_opt_process_env_append (argv[++i]); /* don't copy */\n            }\n          else\n            lt_fatal (\"%s missing required argument\", env_append_opt);\n          continue;\n        }\n      if (strncmp (argv[i], ltwrapper_option_prefix, opt_prefix_len) == 0)\n        {\n          /* however, if there is an option in the LTWRAPPER_OPTION_PREFIX\n             namespace, but it is not one of the ones we know about and\n             have already dealt with, above (inluding dump-script), then\n             report an error. Otherwise, targets might begin to believe\n             they are allowed to use options in the LTWRAPPER_OPTION_PREFIX\n             namespace. The first time any user complains about this, we'll\n             need to make LTWRAPPER_OPTION_PREFIX a configure-time option\n             or a configure.ac-settable value.\n           */\n          lt_fatal (\"Unrecognized option in %s namespace: '%s'\",\n                    ltwrapper_option_prefix, argv[i]);\n        }\n      /* otherwise ... */\n      newargz[++newargc] = xstrdup (argv[i]);\n    }\n  newargz[++newargc] = NULL;\n\n  LTWRAPPER_DEBUGPRINTF     ((\"(main) lt_argv_zero : %s\\n\", (lt_argv_zero ? lt_argv_zero : \"<NULL>\")));\n  for (i = 0; i < newargc; i++)\n    {\n      LTWRAPPER_DEBUGPRINTF ((\"(main) newargz[%d]   : %s\\n\", i, (newargz[i] ? newargz[i] : \"<NULL>\")));\n    }\n\nEOF\n\n\t    case $host_os in\n\t      mingw*)\n\t\tcat <<\"EOF\"\n  /* execv doesn't actually work on mingw as expected on unix */\n  rval = _spawnv (_P_WAIT, lt_argv_zero, (const char * const *) newargz);\n  if (rval == -1)\n    {\n      /* failed to start process */\n      LTWRAPPER_DEBUGPRINTF ((\"(main) failed to launch target \\\"%s\\\": errno = %d\\n\", lt_argv_zero, errno));\n      return 127;\n    }\n  return rval;\nEOF\n\t\t;;\n\t      *)\n\t\tcat <<\"EOF\"\n  execv (lt_argv_zero, newargz);\n  return rval; /* =127, but avoids unused variable warning */\nEOF\n\t\t;;\n\t    esac\n\n\t    cat <<\"EOF\"\n}\n\nvoid *\nxmalloc (size_t num)\n{\n  void *p = (void *) malloc (num);\n  if (!p)\n    lt_fatal (\"Memory exhausted\");\n\n  return p;\n}\n\nchar *\nxstrdup (const char *string)\n{\n  return string ? strcpy ((char *) xmalloc (strlen (string) + 1),\n\t\t\t  string) : NULL;\n}\n\nconst char *\nbase_name (const char *name)\n{\n  const char *base;\n\n#if defined (HAVE_DOS_BASED_FILE_SYSTEM)\n  /* Skip over the disk name in MSDOS pathnames. */\n  if (isalpha ((unsigned char) name[0]) && name[1] == ':')\n    name += 2;\n#endif\n\n  for (base = name; *name; name++)\n    if (IS_DIR_SEPARATOR (*name))\n      base = name + 1;\n  return base;\n}\n\nint\ncheck_executable (const char *path)\n{\n  struct stat st;\n\n  LTWRAPPER_DEBUGPRINTF ((\"(check_executable)  : %s\\n\",\n\t\t\t  path ? (*path ? path : \"EMPTY!\") : \"NULL!\"));\n  if ((!path) || (!*path))\n    return 0;\n\n  if ((stat (path, &st) >= 0)\n      && (st.st_mode & (S_IXUSR | S_IXGRP | S_IXOTH)))\n    return 1;\n  else\n    return 0;\n}\n\nint\nmake_executable (const char *path)\n{\n  int rval = 0;\n  struct stat st;\n\n  LTWRAPPER_DEBUGPRINTF ((\"(make_executable)   : %s\\n\",\n\t\t\t  path ? (*path ? path : \"EMPTY!\") : \"NULL!\"));\n  if ((!path) || (!*path))\n    return 0;\n\n  if (stat (path, &st) >= 0)\n    {\n      rval = chmod (path, st.st_mode | S_IXOTH | S_IXGRP | S_IXUSR);\n    }\n  return rval;\n}\n\n/* Searches for the full path of the wrapper.  Returns\n   newly allocated full path name if found, NULL otherwise\n   Does not chase symlinks, even on platforms that support them.\n*/\nchar *\nfind_executable (const char *wrapper)\n{\n  int has_slash = 0;\n  const char *p;\n  const char *p_next;\n  /* static buffer for getcwd */\n  char tmp[LT_PATHMAX + 1];\n  int tmp_len;\n  char *concat_name;\n\n  LTWRAPPER_DEBUGPRINTF ((\"(find_executable)   : %s\\n\",\n\t\t\t  wrapper ? (*wrapper ? wrapper : \"EMPTY!\") : \"NULL!\"));\n\n  if ((wrapper == NULL) || (*wrapper == '\\0'))\n    return NULL;\n\n  /* Absolute path? */\n#if defined (HAVE_DOS_BASED_FILE_SYSTEM)\n  if (isalpha ((unsigned char) wrapper[0]) && wrapper[1] == ':')\n    {\n      concat_name = xstrdup (wrapper);\n      if (check_executable (concat_name))\n\treturn concat_name;\n      XFREE (concat_name);\n    }\n  else\n    {\n#endif\n      if (IS_DIR_SEPARATOR (wrapper[0]))\n\t{\n\t  concat_name = xstrdup (wrapper);\n\t  if (check_executable (concat_name))\n\t    return concat_name;\n\t  XFREE (concat_name);\n\t}\n#if defined (HAVE_DOS_BASED_FILE_SYSTEM)\n    }\n#endif\n\n  for (p = wrapper; *p; p++)\n    if (*p == '/')\n      {\n\thas_slash = 1;\n\tbreak;\n      }\n  if (!has_slash)\n    {\n      /* no slashes; search PATH */\n      const char *path = getenv (\"PATH\");\n      if (path != NULL)\n\t{\n\t  for (p = path; *p; p = p_next)\n\t    {\n\t      const char *q;\n\t      size_t p_len;\n\t      for (q = p; *q; q++)\n\t\tif (IS_PATH_SEPARATOR (*q))\n\t\t  break;\n\t      p_len = q - p;\n\t      p_next = (*q == '\\0' ? q : q + 1);\n\t      if (p_len == 0)\n\t\t{\n\t\t  /* empty path: current directory */\n\t\t  if (getcwd (tmp, LT_PATHMAX) == NULL)\n\t\t    lt_fatal (\"getcwd failed\");\n\t\t  tmp_len = strlen (tmp);\n\t\t  concat_name =\n\t\t    XMALLOC (char, tmp_len + 1 + strlen (wrapper) + 1);\n\t\t  memcpy (concat_name, tmp, tmp_len);\n\t\t  concat_name[tmp_len] = '/';\n\t\t  strcpy (concat_name + tmp_len + 1, wrapper);\n\t\t}\n\t      else\n\t\t{\n\t\t  concat_name =\n\t\t    XMALLOC (char, p_len + 1 + strlen (wrapper) + 1);\n\t\t  memcpy (concat_name, p, p_len);\n\t\t  concat_name[p_len] = '/';\n\t\t  strcpy (concat_name + p_len + 1, wrapper);\n\t\t}\n\t      if (check_executable (concat_name))\n\t\treturn concat_name;\n\t      XFREE (concat_name);\n\t    }\n\t}\n      /* not found in PATH; assume curdir */\n    }\n  /* Relative path | not found in path: prepend cwd */\n  if (getcwd (tmp, LT_PATHMAX) == NULL)\n    lt_fatal (\"getcwd failed\");\n  tmp_len = strlen (tmp);\n  concat_name = XMALLOC (char, tmp_len + 1 + strlen (wrapper) + 1);\n  memcpy (concat_name, tmp, tmp_len);\n  concat_name[tmp_len] = '/';\n  strcpy (concat_name + tmp_len + 1, wrapper);\n\n  if (check_executable (concat_name))\n    return concat_name;\n  XFREE (concat_name);\n  return NULL;\n}\n\nchar *\nchase_symlinks (const char *pathspec)\n{\n#ifndef S_ISLNK\n  return xstrdup (pathspec);\n#else\n  char buf[LT_PATHMAX];\n  struct stat s;\n  char *tmp_pathspec = xstrdup (pathspec);\n  char *p;\n  int has_symlinks = 0;\n  while (strlen (tmp_pathspec) && !has_symlinks)\n    {\n      LTWRAPPER_DEBUGPRINTF ((\"checking path component for symlinks: %s\\n\",\n\t\t\t      tmp_pathspec));\n      if (lstat (tmp_pathspec, &s) == 0)\n\t{\n\t  if (S_ISLNK (s.st_mode) != 0)\n\t    {\n\t      has_symlinks = 1;\n\t      break;\n\t    }\n\n\t  /* search backwards for last DIR_SEPARATOR */\n\t  p = tmp_pathspec + strlen (tmp_pathspec) - 1;\n\t  while ((p > tmp_pathspec) && (!IS_DIR_SEPARATOR (*p)))\n\t    p--;\n\t  if ((p == tmp_pathspec) && (!IS_DIR_SEPARATOR (*p)))\n\t    {\n\t      /* no more DIR_SEPARATORS left */\n\t      break;\n\t    }\n\t  *p = '\\0';\n\t}\n      else\n\t{\n\t  char *errstr = strerror (errno);\n\t  lt_fatal (\"Error accessing file %s (%s)\", tmp_pathspec, errstr);\n\t}\n    }\n  XFREE (tmp_pathspec);\n\n  if (!has_symlinks)\n    {\n      return xstrdup (pathspec);\n    }\n\n  tmp_pathspec = realpath (pathspec, buf);\n  if (tmp_pathspec == 0)\n    {\n      lt_fatal (\"Could not follow symlinks for %s\", pathspec);\n    }\n  return xstrdup (tmp_pathspec);\n#endif\n}\n\nchar *\nstrendzap (char *str, const char *pat)\n{\n  size_t len, patlen;\n\n  assert (str != NULL);\n  assert (pat != NULL);\n\n  len = strlen (str);\n  patlen = strlen (pat);\n\n  if (patlen <= len)\n    {\n      str += len - patlen;\n      if (strcmp (str, pat) == 0)\n\t*str = '\\0';\n    }\n  return str;\n}\n\nstatic void\nlt_error_core (int exit_status, const char *mode,\n\t       const char *message, va_list ap)\n{\n  fprintf (stderr, \"%s: %s: \", program_name, mode);\n  vfprintf (stderr, message, ap);\n  fprintf (stderr, \".\\n\");\n\n  if (exit_status >= 0)\n    exit (exit_status);\n}\n\nvoid\nlt_fatal (const char *message, ...)\n{\n  va_list ap;\n  va_start (ap, message);\n  lt_error_core (EXIT_FAILURE, \"FATAL\", message, ap);\n  va_end (ap);\n}\n\nvoid\nlt_setenv (const char *name, const char *value)\n{\n  LTWRAPPER_DEBUGPRINTF ((\"(lt_setenv) setting '%s' to '%s'\\n\",\n                          (name ? name : \"<NULL>\"),\n                          (value ? value : \"<NULL>\")));\n  {\n#ifdef HAVE_SETENV\n    /* always make a copy, for consistency with !HAVE_SETENV */\n    char *str = xstrdup (value);\n    setenv (name, str, 1);\n#else\n    int len = strlen (name) + 1 + strlen (value) + 1;\n    char *str = XMALLOC (char, len);\n    sprintf (str, \"%s=%s\", name, value);\n    if (putenv (str) != EXIT_SUCCESS)\n      {\n        XFREE (str);\n      }\n#endif\n  }\n}\n\nchar *\nlt_extend_str (const char *orig_value, const char *add, int to_end)\n{\n  char *new_value;\n  if (orig_value && *orig_value)\n    {\n      int orig_value_len = strlen (orig_value);\n      int add_len = strlen (add);\n      new_value = XMALLOC (char, add_len + orig_value_len + 1);\n      if (to_end)\n        {\n          strcpy (new_value, orig_value);\n          strcpy (new_value + orig_value_len, add);\n        }\n      else\n        {\n          strcpy (new_value, add);\n          strcpy (new_value + add_len, orig_value);\n        }\n    }\n  else\n    {\n      new_value = xstrdup (add);\n    }\n  return new_value;\n}\n\nint\nlt_split_name_value (const char *arg, char** name, char** value)\n{\n  const char *p;\n  int len;\n  if (!arg || !*arg)\n    return 1;\n\n  p = strchr (arg, (int)'=');\n\n  if (!p)\n    return 1;\n\n  *value = xstrdup (++p);\n\n  len = strlen (arg) - strlen (*value);\n  *name = XMALLOC (char, len);\n  strncpy (*name, arg, len-1);\n  (*name)[len - 1] = '\\0';\n\n  return 0;\n}\n\nvoid\nlt_opt_process_env_set (const char *arg)\n{\n  char *name = NULL;\n  char *value = NULL;\n\n  if (lt_split_name_value (arg, &name, &value) != 0)\n    {\n      XFREE (name);\n      XFREE (value);\n      lt_fatal (\"bad argument for %s: '%s'\", env_set_opt, arg);\n    }\n\n  lt_setenv (name, value);\n  XFREE (name);\n  XFREE (value);\n}\n\nvoid\nlt_opt_process_env_prepend (const char *arg)\n{\n  char *name = NULL;\n  char *value = NULL;\n  char *new_value = NULL;\n\n  if (lt_split_name_value (arg, &name, &value) != 0)\n    {\n      XFREE (name);\n      XFREE (value);\n      lt_fatal (\"bad argument for %s: '%s'\", env_prepend_opt, arg);\n    }\n\n  new_value = lt_extend_str (getenv (name), value, 0);\n  lt_setenv (name, new_value);\n  XFREE (new_value);\n  XFREE (name);\n  XFREE (value);\n}\n\nvoid\nlt_opt_process_env_append (const char *arg)\n{\n  char *name = NULL;\n  char *value = NULL;\n  char *new_value = NULL;\n\n  if (lt_split_name_value (arg, &name, &value) != 0)\n    {\n      XFREE (name);\n      XFREE (value);\n      lt_fatal (\"bad argument for %s: '%s'\", env_append_opt, arg);\n    }\n\n  new_value = lt_extend_str (getenv (name), value, 1);\n  lt_setenv (name, new_value);\n  XFREE (new_value);\n  XFREE (name);\n  XFREE (value);\n}\n\nvoid\nlt_update_exe_path (const char *name, const char *value)\n{\n  LTWRAPPER_DEBUGPRINTF ((\"(lt_update_exe_path) modifying '%s' by prepending '%s'\\n\",\n                          (name ? name : \"<NULL>\"),\n                          (value ? value : \"<NULL>\")));\n\n  if (name && *name && value && *value)\n    {\n      char *new_value = lt_extend_str (getenv (name), value, 0);\n      /* some systems can't cope with a ':'-terminated path #' */\n      int len = strlen (new_value);\n      while (((len = strlen (new_value)) > 0) && IS_PATH_SEPARATOR (new_value[len-1]))\n        {\n          new_value[len-1] = '\\0';\n        }\n      lt_setenv (name, new_value);\n      XFREE (new_value);\n    }\n}\n\nvoid\nlt_update_lib_path (const char *name, const char *value)\n{\n  LTWRAPPER_DEBUGPRINTF ((\"(lt_update_lib_path) modifying '%s' by prepending '%s'\\n\",\n                          (name ? name : \"<NULL>\"),\n                          (value ? value : \"<NULL>\")));\n\n  if (name && *name && value && *value)\n    {\n      char *new_value = lt_extend_str (getenv (name), value, 0);\n      lt_setenv (name, new_value);\n      XFREE (new_value);\n    }\n}\n\n\nEOF\n}\n# end: func_emit_cwrapperexe_src\n\n# func_mode_link arg...\nfunc_mode_link ()\n{\n    $opt_debug\n    case $host in\n    *-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-cegcc*)\n      # It is impossible to link a dll without this setting, and\n      # we shouldn't force the makefile maintainer to figure out\n      # which system we are compiling for in order to pass an extra\n      # flag for every libtool invocation.\n      # allow_undefined=no\n\n      # FIXME: Unfortunately, there are problems with the above when trying\n      # to make a dll which has undefined symbols, in which case not\n      # even a static library is built.  For now, we need to specify\n      # -no-undefined on the libtool link line when we can be certain\n      # that all symbols are satisfied, otherwise we get a static library.\n      allow_undefined=yes\n      ;;\n    *)\n      allow_undefined=yes\n      ;;\n    esac\n    libtool_args=$nonopt\n    base_compile=\"$nonopt $@\"\n    compile_command=$nonopt\n    finalize_command=$nonopt\n\n    compile_rpath=\n    finalize_rpath=\n    compile_shlibpath=\n    finalize_shlibpath=\n    convenience=\n    old_convenience=\n    deplibs=\n    old_deplibs=\n    compiler_flags=\n    linker_flags=\n    dllsearchpath=\n    lib_search_path=`pwd`\n    inst_prefix_dir=\n    new_inherited_linker_flags=\n\n    avoid_version=no\n    dlfiles=\n    dlprefiles=\n    dlself=no\n    export_dynamic=no\n    export_symbols=\n    export_symbols_regex=\n    generated=\n    libobjs=\n    ltlibs=\n    module=no\n    no_install=no\n    objs=\n    non_pic_objects=\n    precious_files_regex=\n    prefer_static_libs=no\n    preload=no\n    prev=\n    prevarg=\n    release=\n    rpath=\n    xrpath=\n    perm_rpath=\n    temp_rpath=\n    thread_safe=no\n    vinfo=\n    vinfo_number=no\n    weak_libs=\n    single_module=\"${wl}-single_module\"\n    func_infer_tag $base_compile\n\n    # We need to know -static, to get the right output filenames.\n    for arg\n    do\n      case $arg in\n      -shared)\n\ttest \"$build_libtool_libs\" != yes && \\\n\t  func_fatal_configuration \"can not build a shared library\"\n\tbuild_old_libs=no\n\tbreak\n\t;;\n      -all-static | -static | -static-libtool-libs)\n\tcase $arg in\n\t-all-static)\n\t  if test \"$build_libtool_libs\" = yes && test -z \"$link_static_flag\"; then\n\t    func_warning \"complete static linking is impossible in this configuration\"\n\t  fi\n\t  if test -n \"$link_static_flag\"; then\n\t    dlopen_self=$dlopen_self_static\n\t  fi\n\t  prefer_static_libs=yes\n\t  ;;\n\t-static)\n\t  if test -z \"$pic_flag\" && test -n \"$link_static_flag\"; then\n\t    dlopen_self=$dlopen_self_static\n\t  fi\n\t  prefer_static_libs=built\n\t  ;;\n\t-static-libtool-libs)\n\t  if test -z \"$pic_flag\" && test -n \"$link_static_flag\"; then\n\t    dlopen_self=$dlopen_self_static\n\t  fi\n\t  prefer_static_libs=yes\n\t  ;;\n\tesac\n\tbuild_libtool_libs=no\n\tbuild_old_libs=yes\n\tbreak\n\t;;\n      esac\n    done\n\n    # See if our shared archives depend on static archives.\n    test -n \"$old_archive_from_new_cmds\" && build_old_libs=yes\n\n    # Go through the arguments, transforming them on the way.\n    while test \"$#\" -gt 0; do\n      arg=\"$1\"\n      shift\n      func_quote_for_eval \"$arg\"\n      qarg=$func_quote_for_eval_unquoted_result\n      func_append libtool_args \" $func_quote_for_eval_result\"\n\n      # If the previous option needs an argument, assign it.\n      if test -n \"$prev\"; then\n\tcase $prev in\n\toutput)\n\t  func_append compile_command \" @OUTPUT@\"\n\t  func_append finalize_command \" @OUTPUT@\"\n\t  ;;\n\tesac\n\n\tcase $prev in\n\tdlfiles|dlprefiles)\n\t  if test \"$preload\" = no; then\n\t    # Add the symbol object into the linking commands.\n\t    func_append compile_command \" @SYMFILE@\"\n\t    func_append finalize_command \" @SYMFILE@\"\n\t    preload=yes\n\t  fi\n\t  case $arg in\n\t  *.la | *.lo) ;;  # We handle these cases below.\n\t  force)\n\t    if test \"$dlself\" = no; then\n\t      dlself=needless\n\t      export_dynamic=yes\n\t    fi\n\t    prev=\n\t    continue\n\t    ;;\n\t  self)\n\t    if test \"$prev\" = dlprefiles; then\n\t      dlself=yes\n\t    elif test \"$prev\" = dlfiles && test \"$dlopen_self\" != yes; then\n\t      dlself=yes\n\t    else\n\t      dlself=needless\n\t      export_dynamic=yes\n\t    fi\n\t    prev=\n\t    continue\n\t    ;;\n\t  *)\n\t    if test \"$prev\" = dlfiles; then\n\t      dlfiles=\"$dlfiles $arg\"\n\t    else\n\t      dlprefiles=\"$dlprefiles $arg\"\n\t    fi\n\t    prev=\n\t    continue\n\t    ;;\n\t  esac\n\t  ;;\n\texpsyms)\n\t  export_symbols=\"$arg\"\n\t  test -f \"$arg\" \\\n\t    || func_fatal_error \"symbol file \\`$arg' does not exist\"\n\t  prev=\n\t  continue\n\t  ;;\n\texpsyms_regex)\n\t  export_symbols_regex=\"$arg\"\n\t  prev=\n\t  continue\n\t  ;;\n\tframework)\n\t  case $host in\n\t    *-*-darwin*)\n\t      case \"$deplibs \" in\n\t\t*\" $qarg.ltframework \"*) ;;\n\t\t*) deplibs=\"$deplibs $qarg.ltframework\" # this is fixed later\n\t\t   ;;\n\t      esac\n\t      ;;\n\t  esac\n\t  prev=\n\t  continue\n\t  ;;\n\tinst_prefix)\n\t  inst_prefix_dir=\"$arg\"\n\t  prev=\n\t  continue\n\t  ;;\n\tobjectlist)\n\t  if test -f \"$arg\"; then\n\t    save_arg=$arg\n\t    moreargs=\n\t    for fil in `cat \"$save_arg\"`\n\t    do\n#\t      moreargs=\"$moreargs $fil\"\n\t      arg=$fil\n\t      # A libtool-controlled object.\n\n\t      # Check to see that this really is a libtool object.\n\t      if func_lalib_unsafe_p \"$arg\"; then\n\t\tpic_object=\n\t\tnon_pic_object=\n\n\t\t# Read the .lo file\n\t\tfunc_source \"$arg\"\n\n\t\tif test -z \"$pic_object\" ||\n\t\t   test -z \"$non_pic_object\" ||\n\t\t   test \"$pic_object\" = none &&\n\t\t   test \"$non_pic_object\" = none; then\n\t\t  func_fatal_error \"cannot find name of object for \\`$arg'\"\n\t\tfi\n\n\t\t# Extract subdirectory from the argument.\n\t\tfunc_dirname \"$arg\" \"/\" \"\"\n\t\txdir=\"$func_dirname_result\"\n\n\t\tif test \"$pic_object\" != none; then\n\t\t  # Prepend the subdirectory the object is found in.\n\t\t  pic_object=\"$xdir$pic_object\"\n\n\t\t  if test \"$prev\" = dlfiles; then\n\t\t    if test \"$build_libtool_libs\" = yes && test \"$dlopen_support\" = yes; then\n\t\t      dlfiles=\"$dlfiles $pic_object\"\n\t\t      prev=\n\t\t      continue\n\t\t    else\n\t\t      # If libtool objects are unsupported, then we need to preload.\n\t\t      prev=dlprefiles\n\t\t    fi\n\t\t  fi\n\n\t\t  # CHECK ME:  I think I busted this.  -Ossama\n\t\t  if test \"$prev\" = dlprefiles; then\n\t\t    # Preload the old-style object.\n\t\t    dlprefiles=\"$dlprefiles $pic_object\"\n\t\t    prev=\n\t\t  fi\n\n\t\t  # A PIC object.\n\t\t  func_append libobjs \" $pic_object\"\n\t\t  arg=\"$pic_object\"\n\t\tfi\n\n\t\t# Non-PIC object.\n\t\tif test \"$non_pic_object\" != none; then\n\t\t  # Prepend the subdirectory the object is found in.\n\t\t  non_pic_object=\"$xdir$non_pic_object\"\n\n\t\t  # A standard non-PIC object\n\t\t  func_append non_pic_objects \" $non_pic_object\"\n\t\t  if test -z \"$pic_object\" || test \"$pic_object\" = none ; then\n\t\t    arg=\"$non_pic_object\"\n\t\t  fi\n\t\telse\n\t\t  # If the PIC object exists, use it instead.\n\t\t  # $xdir was prepended to $pic_object above.\n\t\t  non_pic_object=\"$pic_object\"\n\t\t  func_append non_pic_objects \" $non_pic_object\"\n\t\tfi\n\t      else\n\t\t# Only an error if not doing a dry-run.\n\t\tif $opt_dry_run; then\n\t\t  # Extract subdirectory from the argument.\n\t\t  func_dirname \"$arg\" \"/\" \"\"\n\t\t  xdir=\"$func_dirname_result\"\n\n\t\t  func_lo2o \"$arg\"\n\t\t  pic_object=$xdir$objdir/$func_lo2o_result\n\t\t  non_pic_object=$xdir$func_lo2o_result\n\t\t  func_append libobjs \" $pic_object\"\n\t\t  func_append non_pic_objects \" $non_pic_object\"\n\t        else\n\t\t  func_fatal_error \"\\`$arg' is not a valid libtool object\"\n\t\tfi\n\t      fi\n\t    done\n\t  else\n\t    func_fatal_error \"link input file \\`$arg' does not exist\"\n\t  fi\n\t  arg=$save_arg\n\t  prev=\n\t  continue\n\t  ;;\n\tprecious_regex)\n\t  precious_files_regex=\"$arg\"\n\t  prev=\n\t  continue\n\t  ;;\n\trelease)\n\t  release=\"-$arg\"\n\t  prev=\n\t  continue\n\t  ;;\n\trpath | xrpath)\n\t  # We need an absolute path.\n\t  case $arg in\n\t  [\\\\/]* | [A-Za-z]:[\\\\/]*) ;;\n\t  *)\n\t    func_fatal_error \"only absolute run-paths are allowed\"\n\t    ;;\n\t  esac\n\t  if test \"$prev\" = rpath; then\n\t    case \"$rpath \" in\n\t    *\" $arg \"*) ;;\n\t    *) rpath=\"$rpath $arg\" ;;\n\t    esac\n\t  else\n\t    case \"$xrpath \" in\n\t    *\" $arg \"*) ;;\n\t    *) xrpath=\"$xrpath $arg\" ;;\n\t    esac\n\t  fi\n\t  prev=\n\t  continue\n\t  ;;\n\tshrext)\n\t  shrext_cmds=\"$arg\"\n\t  prev=\n\t  continue\n\t  ;;\n\tweak)\n\t  weak_libs=\"$weak_libs $arg\"\n\t  prev=\n\t  continue\n\t  ;;\n\txcclinker)\n\t  linker_flags=\"$linker_flags $qarg\"\n\t  compiler_flags=\"$compiler_flags $qarg\"\n\t  prev=\n\t  func_append compile_command \" $qarg\"\n\t  func_append finalize_command \" $qarg\"\n\t  continue\n\t  ;;\n\txcompiler)\n\t  compiler_flags=\"$compiler_flags $qarg\"\n\t  prev=\n\t  func_append compile_command \" $qarg\"\n\t  func_append finalize_command \" $qarg\"\n\t  continue\n\t  ;;\n\txlinker)\n\t  linker_flags=\"$linker_flags $qarg\"\n\t  compiler_flags=\"$compiler_flags $wl$qarg\"\n\t  prev=\n\t  func_append compile_command \" $wl$qarg\"\n\t  func_append finalize_command \" $wl$qarg\"\n\t  continue\n\t  ;;\n\t*)\n\t  eval \"$prev=\\\"\\$arg\\\"\"\n\t  prev=\n\t  continue\n\t  ;;\n\tesac\n      fi # test -n \"$prev\"\n\n      prevarg=\"$arg\"\n\n      case $arg in\n      -all-static)\n\tif test -n \"$link_static_flag\"; then\n\t  # See comment for -static flag below, for more details.\n\t  func_append compile_command \" $link_static_flag\"\n\t  func_append finalize_command \" $link_static_flag\"\n\tfi\n\tcontinue\n\t;;\n\n      -allow-undefined)\n\t# FIXME: remove this flag sometime in the future.\n\tfunc_fatal_error \"\\`-allow-undefined' must not be used because it is the default\"\n\t;;\n\n      -avoid-version)\n\tavoid_version=yes\n\tcontinue\n\t;;\n\n      -dlopen)\n\tprev=dlfiles\n\tcontinue\n\t;;\n\n      -dlpreopen)\n\tprev=dlprefiles\n\tcontinue\n\t;;\n\n      -export-dynamic)\n\texport_dynamic=yes\n\tcontinue\n\t;;\n\n      -export-symbols | -export-symbols-regex)\n\tif test -n \"$export_symbols\" || test -n \"$export_symbols_regex\"; then\n\t  func_fatal_error \"more than one -exported-symbols argument is not allowed\"\n\tfi\n\tif test \"X$arg\" = \"X-export-symbols\"; then\n\t  prev=expsyms\n\telse\n\t  prev=expsyms_regex\n\tfi\n\tcontinue\n\t;;\n\n      -framework)\n\tprev=framework\n\tcontinue\n\t;;\n\n      -inst-prefix-dir)\n\tprev=inst_prefix\n\tcontinue\n\t;;\n\n      # The native IRIX linker understands -LANG:*, -LIST:* and -LNO:*\n      # so, if we see these flags be careful not to treat them like -L\n      -L[A-Z][A-Z]*:*)\n\tcase $with_gcc/$host in\n\tno/*-*-irix* | /*-*-irix*)\n\t  func_append compile_command \" $arg\"\n\t  func_append finalize_command \" $arg\"\n\t  ;;\n\tesac\n\tcontinue\n\t;;\n\n      -L*)\n\tfunc_stripname '-L' '' \"$arg\"\n\tdir=$func_stripname_result\n\tif test -z \"$dir\"; then\n\t  if test \"$#\" -gt 0; then\n\t    func_fatal_error \"require no space between \\`-L' and \\`$1'\"\n\t  else\n\t    func_fatal_error \"need path for \\`-L' option\"\n\t  fi\n\tfi\n\t# We need an absolute path.\n\tcase $dir in\n\t[\\\\/]* | [A-Za-z]:[\\\\/]*) ;;\n\t*)\n\t  absdir=`cd \"$dir\" && pwd`\n\t  test -z \"$absdir\" && \\\n\t    func_fatal_error \"cannot determine absolute directory name of \\`$dir'\"\n\t  dir=\"$absdir\"\n\t  ;;\n\tesac\n\tcase \"$deplibs \" in\n\t*\" -L$dir \"*) ;;\n\t*)\n\t  deplibs=\"$deplibs -L$dir\"\n\t  lib_search_path=\"$lib_search_path $dir\"\n\t  ;;\n\tesac\n\tcase $host in\n\t*-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-cegcc*)\n\t  testbindir=`$ECHO \"X$dir\" | $Xsed -e 's*/lib$*/bin*'`\n\t  case :$dllsearchpath: in\n\t  *\":$dir:\"*) ;;\n\t  ::) dllsearchpath=$dir;;\n\t  *) dllsearchpath=\"$dllsearchpath:$dir\";;\n\t  esac\n\t  case :$dllsearchpath: in\n\t  *\":$testbindir:\"*) ;;\n\t  ::) dllsearchpath=$testbindir;;\n\t  *) dllsearchpath=\"$dllsearchpath:$testbindir\";;\n\t  esac\n\t  ;;\n\tesac\n\tcontinue\n\t;;\n\n      -l*)\n\tif test \"X$arg\" = \"X-lc\" || test \"X$arg\" = \"X-lm\"; then\n\t  case $host in\n\t  *-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-beos* | *-cegcc*)\n\t    # These systems don't actually have a C or math library (as such)\n\t    continue\n\t    ;;\n\t  *-*-os2*)\n\t    # These systems don't actually have a C library (as such)\n\t    test \"X$arg\" = \"X-lc\" && continue\n\t    ;;\n\t  *-*-openbsd* | *-*-freebsd* | *-*-dragonfly*)\n\t    # Do not include libc due to us having libc/libc_r.\n\t    test \"X$arg\" = \"X-lc\" && continue\n\t    ;;\n\t  *-*-rhapsody* | *-*-darwin1.[012])\n\t    # Rhapsody C and math libraries are in the System framework\n\t    deplibs=\"$deplibs System.ltframework\"\n\t    continue\n\t    ;;\n\t  *-*-sco3.2v5* | *-*-sco5v6*)\n\t    # Causes problems with __ctype\n\t    test \"X$arg\" = \"X-lc\" && continue\n\t    ;;\n\t  *-*-sysv4.2uw2* | *-*-sysv5* | *-*-unixware* | *-*-OpenUNIX*)\n\t    # Compiler inserts libc in the correct place for threads to work\n\t    test \"X$arg\" = \"X-lc\" && continue\n\t    ;;\n\t  esac\n\telif test \"X$arg\" = \"X-lc_r\"; then\n\t case $host in\n\t *-*-openbsd* | *-*-freebsd* | *-*-dragonfly*)\n\t   # Do not include libc_r directly, use -pthread flag.\n\t   continue\n\t   ;;\n\t esac\n\tfi\n\tdeplibs=\"$deplibs $arg\"\n\tcontinue\n\t;;\n\n      -module)\n\tmodule=yes\n\tcontinue\n\t;;\n\n      # Tru64 UNIX uses -model [arg] to determine the layout of C++\n      # classes, name mangling, and exception handling.\n      # Darwin uses the -arch flag to determine output architecture.\n      -model|-arch|-isysroot)\n\tcompiler_flags=\"$compiler_flags $arg\"\n\tfunc_append compile_command \" $arg\"\n\tfunc_append finalize_command \" $arg\"\n\tprev=xcompiler\n\tcontinue\n\t;;\n\n      -mt|-mthreads|-kthread|-Kthread|-pthread|-pthreads|--thread-safe|-threads)\n\tcompiler_flags=\"$compiler_flags $arg\"\n\tfunc_append compile_command \" $arg\"\n\tfunc_append finalize_command \" $arg\"\n\tcase \"$new_inherited_linker_flags \" in\n\t    *\" $arg \"*) ;;\n\t    * ) new_inherited_linker_flags=\"$new_inherited_linker_flags $arg\" ;;\n\tesac\n\tcontinue\n\t;;\n\n      -multi_module)\n\tsingle_module=\"${wl}-multi_module\"\n\tcontinue\n\t;;\n\n      -no-fast-install)\n\tfast_install=no\n\tcontinue\n\t;;\n\n      -no-install)\n\tcase $host in\n\t*-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-*-darwin* | *-cegcc*)\n\t  # The PATH hackery in wrapper scripts is required on Windows\n\t  # and Darwin in order for the loader to find any dlls it needs.\n\t  func_warning \"\\`-no-install' is ignored for $host\"\n\t  func_warning \"assuming \\`-no-fast-install' instead\"\n\t  fast_install=no\n\t  ;;\n\t*) no_install=yes ;;\n\tesac\n\tcontinue\n\t;;\n\n      -no-undefined)\n\tallow_undefined=no\n\tcontinue\n\t;;\n\n      -objectlist)\n\tprev=objectlist\n\tcontinue\n\t;;\n\n      -o) prev=output ;;\n\n      -precious-files-regex)\n\tprev=precious_regex\n\tcontinue\n\t;;\n\n      -release)\n\tprev=release\n\tcontinue\n\t;;\n\n      -rpath)\n\tprev=rpath\n\tcontinue\n\t;;\n\n      -R)\n\tprev=xrpath\n\tcontinue\n\t;;\n\n      -R*)\n\tfunc_stripname '-R' '' \"$arg\"\n\tdir=$func_stripname_result\n\t# We need an absolute path.\n\tcase $dir in\n\t[\\\\/]* | [A-Za-z]:[\\\\/]*) ;;\n\t*)\n\t  func_fatal_error \"only absolute run-paths are allowed\"\n\t  ;;\n\tesac\n\tcase \"$xrpath \" in\n\t*\" $dir \"*) ;;\n\t*) xrpath=\"$xrpath $dir\" ;;\n\tesac\n\tcontinue\n\t;;\n\n      -shared)\n\t# The effects of -shared are defined in a previous loop.\n\tcontinue\n\t;;\n\n      -shrext)\n\tprev=shrext\n\tcontinue\n\t;;\n\n      -static | -static-libtool-libs)\n\t# The effects of -static are defined in a previous loop.\n\t# We used to do the same as -all-static on platforms that\n\t# didn't have a PIC flag, but the assumption that the effects\n\t# would be equivalent was wrong.  It would break on at least\n\t# Digital Unix and AIX.\n\tcontinue\n\t;;\n\n      -thread-safe)\n\tthread_safe=yes\n\tcontinue\n\t;;\n\n      -version-info)\n\tprev=vinfo\n\tcontinue\n\t;;\n\n      -version-number)\n\tprev=vinfo\n\tvinfo_number=yes\n\tcontinue\n\t;;\n\n      -weak)\n        prev=weak\n\tcontinue\n\t;;\n\n      -Wc,*)\n\tfunc_stripname '-Wc,' '' \"$arg\"\n\targs=$func_stripname_result\n\targ=\n\tsave_ifs=\"$IFS\"; IFS=','\n\tfor flag in $args; do\n\t  IFS=\"$save_ifs\"\n          func_quote_for_eval \"$flag\"\n\t  arg=\"$arg $wl$func_quote_for_eval_result\"\n\t  compiler_flags=\"$compiler_flags $func_quote_for_eval_result\"\n\tdone\n\tIFS=\"$save_ifs\"\n\tfunc_stripname ' ' '' \"$arg\"\n\targ=$func_stripname_result\n\t;;\n\n      -Wl,*)\n\tfunc_stripname '-Wl,' '' \"$arg\"\n\targs=$func_stripname_result\n\targ=\n\tsave_ifs=\"$IFS\"; IFS=','\n\tfor flag in $args; do\n\t  IFS=\"$save_ifs\"\n          func_quote_for_eval \"$flag\"\n\t  arg=\"$arg $wl$func_quote_for_eval_result\"\n\t  compiler_flags=\"$compiler_flags $wl$func_quote_for_eval_result\"\n\t  linker_flags=\"$linker_flags $func_quote_for_eval_result\"\n\tdone\n\tIFS=\"$save_ifs\"\n\tfunc_stripname ' ' '' \"$arg\"\n\targ=$func_stripname_result\n\t;;\n\n      -Xcompiler)\n\tprev=xcompiler\n\tcontinue\n\t;;\n\n      -Xlinker)\n\tprev=xlinker\n\tcontinue\n\t;;\n\n      -XCClinker)\n\tprev=xcclinker\n\tcontinue\n\t;;\n\n      # -msg_* for osf cc\n      -msg_*)\n\tfunc_quote_for_eval \"$arg\"\n\targ=\"$func_quote_for_eval_result\"\n\t;;\n\n      # -64, -mips[0-9] enable 64-bit mode on the SGI compiler\n      # -r[0-9][0-9]* specifies the processor on the SGI compiler\n      # -xarch=*, -xtarget=* enable 64-bit mode on the Sun compiler\n      # +DA*, +DD* enable 64-bit mode on the HP compiler\n      # -q* pass through compiler args for the IBM compiler\n      # -m*, -t[45]*, -txscale* pass through architecture-specific\n      # compiler args for GCC\n      # -F/path gives path to uninstalled frameworks, gcc on darwin\n      # -p, -pg, --coverage, -fprofile-* pass through profiling flag for GCC\n      # @file GCC response files\n      -64|-mips[0-9]|-r[0-9][0-9]*|-xarch=*|-xtarget=*|+DA*|+DD*|-q*|-m*| \\\n      -t[45]*|-txscale*|-p|-pg|--coverage|-fprofile-*|-F*|@*)\n        func_quote_for_eval \"$arg\"\n\targ=\"$func_quote_for_eval_result\"\n        func_append compile_command \" $arg\"\n        func_append finalize_command \" $arg\"\n        compiler_flags=\"$compiler_flags $arg\"\n        continue\n        ;;\n\n      # Some other compiler flag.\n      -* | +*)\n        func_quote_for_eval \"$arg\"\n\targ=\"$func_quote_for_eval_result\"\n\t;;\n\n      *.$objext)\n\t# A standard object.\n\tobjs=\"$objs $arg\"\n\t;;\n\n      *.lo)\n\t# A libtool-controlled object.\n\n\t# Check to see that this really is a libtool object.\n\tif func_lalib_unsafe_p \"$arg\"; then\n\t  pic_object=\n\t  non_pic_object=\n\n\t  # Read the .lo file\n\t  func_source \"$arg\"\n\n\t  if test -z \"$pic_object\" ||\n\t     test -z \"$non_pic_object\" ||\n\t     test \"$pic_object\" = none &&\n\t     test \"$non_pic_object\" = none; then\n\t    func_fatal_error \"cannot find name of object for \\`$arg'\"\n\t  fi\n\n\t  # Extract subdirectory from the argument.\n\t  func_dirname \"$arg\" \"/\" \"\"\n\t  xdir=\"$func_dirname_result\"\n\n\t  if test \"$pic_object\" != none; then\n\t    # Prepend the subdirectory the object is found in.\n\t    pic_object=\"$xdir$pic_object\"\n\n\t    if test \"$prev\" = dlfiles; then\n\t      if test \"$build_libtool_libs\" = yes && test \"$dlopen_support\" = yes; then\n\t\tdlfiles=\"$dlfiles $pic_object\"\n\t\tprev=\n\t\tcontinue\n\t      else\n\t\t# If libtool objects are unsupported, then we need to preload.\n\t\tprev=dlprefiles\n\t      fi\n\t    fi\n\n\t    # CHECK ME:  I think I busted this.  -Ossama\n\t    if test \"$prev\" = dlprefiles; then\n\t      # Preload the old-style object.\n\t      dlprefiles=\"$dlprefiles $pic_object\"\n\t      prev=\n\t    fi\n\n\t    # A PIC object.\n\t    func_append libobjs \" $pic_object\"\n\t    arg=\"$pic_object\"\n\t  fi\n\n\t  # Non-PIC object.\n\t  if test \"$non_pic_object\" != none; then\n\t    # Prepend the subdirectory the object is found in.\n\t    non_pic_object=\"$xdir$non_pic_object\"\n\n\t    # A standard non-PIC object\n\t    func_append non_pic_objects \" $non_pic_object\"\n\t    if test -z \"$pic_object\" || test \"$pic_object\" = none ; then\n\t      arg=\"$non_pic_object\"\n\t    fi\n\t  else\n\t    # If the PIC object exists, use it instead.\n\t    # $xdir was prepended to $pic_object above.\n\t    non_pic_object=\"$pic_object\"\n\t    func_append non_pic_objects \" $non_pic_object\"\n\t  fi\n\telse\n\t  # Only an error if not doing a dry-run.\n\t  if $opt_dry_run; then\n\t    # Extract subdirectory from the argument.\n\t    func_dirname \"$arg\" \"/\" \"\"\n\t    xdir=\"$func_dirname_result\"\n\n\t    func_lo2o \"$arg\"\n\t    pic_object=$xdir$objdir/$func_lo2o_result\n\t    non_pic_object=$xdir$func_lo2o_result\n\t    func_append libobjs \" $pic_object\"\n\t    func_append non_pic_objects \" $non_pic_object\"\n\t  else\n\t    func_fatal_error \"\\`$arg' is not a valid libtool object\"\n\t  fi\n\tfi\n\t;;\n\n      *.$libext)\n\t# An archive.\n\tdeplibs=\"$deplibs $arg\"\n\told_deplibs=\"$old_deplibs $arg\"\n\tcontinue\n\t;;\n\n      *.la)\n\t# A libtool-controlled library.\n\n\tif test \"$prev\" = dlfiles; then\n\t  # This library was specified with -dlopen.\n\t  dlfiles=\"$dlfiles $arg\"\n\t  prev=\n\telif test \"$prev\" = dlprefiles; then\n\t  # The library was specified with -dlpreopen.\n\t  dlprefiles=\"$dlprefiles $arg\"\n\t  prev=\n\telse\n\t  deplibs=\"$deplibs $arg\"\n\tfi\n\tcontinue\n\t;;\n\n      # Some other compiler argument.\n      *)\n\t# Unknown arguments in both finalize_command and compile_command need\n\t# to be aesthetically quoted because they are evaled later.\n\tfunc_quote_for_eval \"$arg\"\n\targ=\"$func_quote_for_eval_result\"\n\t;;\n      esac # arg\n\n      # Now actually substitute the argument into the commands.\n      if test -n \"$arg\"; then\n\tfunc_append compile_command \" $arg\"\n\tfunc_append finalize_command \" $arg\"\n      fi\n    done # argument parsing loop\n\n    test -n \"$prev\" && \\\n      func_fatal_help \"the \\`$prevarg' option requires an argument\"\n\n    if test \"$export_dynamic\" = yes && test -n \"$export_dynamic_flag_spec\"; then\n      eval arg=\\\"$export_dynamic_flag_spec\\\"\n      func_append compile_command \" $arg\"\n      func_append finalize_command \" $arg\"\n    fi\n\n    oldlibs=\n    # calculate the name of the file, without its directory\n    func_basename \"$output\"\n    outputname=\"$func_basename_result\"\n    libobjs_save=\"$libobjs\"\n\n    if test -n \"$shlibpath_var\"; then\n      # get the directories listed in $shlibpath_var\n      eval shlib_search_path=\\`\\$ECHO \\\"X\\${$shlibpath_var}\\\" \\| \\$Xsed -e \\'s/:/ /g\\'\\`\n    else\n      shlib_search_path=\n    fi\n    eval sys_lib_search_path=\\\"$sys_lib_search_path_spec\\\"\n    eval sys_lib_dlsearch_path=\\\"$sys_lib_dlsearch_path_spec\\\"\n\n    func_dirname \"$output\" \"/\" \"\"\n    output_objdir=\"$func_dirname_result$objdir\"\n    # Create the object directory.\n    func_mkdir_p \"$output_objdir\"\n\n    # Determine the type of output\n    case $output in\n    \"\")\n      func_fatal_help \"you must specify an output file\"\n      ;;\n    *.$libext) linkmode=oldlib ;;\n    *.lo | *.$objext) linkmode=obj ;;\n    *.la) linkmode=lib ;;\n    *) linkmode=prog ;; # Anything else should be a program.\n    esac\n\n    specialdeplibs=\n\n    libs=\n    # Find all interdependent deplibs by searching for libraries\n    # that are linked more than once (e.g. -la -lb -la)\n    for deplib in $deplibs; do\n      if $opt_duplicate_deps ; then\n\tcase \"$libs \" in\n\t*\" $deplib \"*) specialdeplibs=\"$specialdeplibs $deplib\" ;;\n\tesac\n      fi\n      libs=\"$libs $deplib\"\n    done\n\n    if test \"$linkmode\" = lib; then\n      libs=\"$predeps $libs $compiler_lib_search_path $postdeps\"\n\n      # Compute libraries that are listed more than once in $predeps\n      # $postdeps and mark them as special (i.e., whose duplicates are\n      # not to be eliminated).\n      pre_post_deps=\n      if $opt_duplicate_compiler_generated_deps; then\n\tfor pre_post_dep in $predeps $postdeps; do\n\t  case \"$pre_post_deps \" in\n\t  *\" $pre_post_dep \"*) specialdeplibs=\"$specialdeplibs $pre_post_deps\" ;;\n\t  esac\n\t  pre_post_deps=\"$pre_post_deps $pre_post_dep\"\n\tdone\n      fi\n      pre_post_deps=\n    fi\n\n    deplibs=\n    newdependency_libs=\n    newlib_search_path=\n    need_relink=no # whether we're linking any uninstalled libtool libraries\n    notinst_deplibs= # not-installed libtool libraries\n    notinst_path= # paths that contain not-installed libtool libraries\n\n    case $linkmode in\n    lib)\n\tpasses=\"conv dlpreopen link\"\n\tfor file in $dlfiles $dlprefiles; do\n\t  case $file in\n\t  *.la) ;;\n\t  *)\n\t    func_fatal_help \"libraries can \\`-dlopen' only libtool libraries: $file\"\n\t    ;;\n\t  esac\n\tdone\n\t;;\n    prog)\n\tcompile_deplibs=\n\tfinalize_deplibs=\n\talldeplibs=no\n\tnewdlfiles=\n\tnewdlprefiles=\n\tpasses=\"conv scan dlopen dlpreopen link\"\n\t;;\n    *)  passes=\"conv\"\n\t;;\n    esac\n\n    for pass in $passes; do\n      # The preopen pass in lib mode reverses $deplibs; put it back here\n      # so that -L comes before libs that need it for instance...\n      if test \"$linkmode,$pass\" = \"lib,link\"; then\n\t## FIXME: Find the place where the list is rebuilt in the wrong\n\t##        order, and fix it there properly\n        tmp_deplibs=\n\tfor deplib in $deplibs; do\n\t  tmp_deplibs=\"$deplib $tmp_deplibs\"\n\tdone\n\tdeplibs=\"$tmp_deplibs\"\n      fi\n\n      if test \"$linkmode,$pass\" = \"lib,link\" ||\n\t test \"$linkmode,$pass\" = \"prog,scan\"; then\n\tlibs=\"$deplibs\"\n\tdeplibs=\n      fi\n      if test \"$linkmode\" = prog; then\n\tcase $pass in\n\tdlopen) libs=\"$dlfiles\" ;;\n\tdlpreopen) libs=\"$dlprefiles\" ;;\n\tlink) libs=\"$deplibs %DEPLIBS% $dependency_libs\" ;;\n\tesac\n      fi\n      if test \"$linkmode,$pass\" = \"lib,dlpreopen\"; then\n\t# Collect and forward deplibs of preopened libtool libs\n\tfor lib in $dlprefiles; do\n\t  # Ignore non-libtool-libs\n\t  dependency_libs=\n\t  case $lib in\n\t  *.la)\tfunc_source \"$lib\" ;;\n\t  esac\n\n\t  # Collect preopened libtool deplibs, except any this library\n\t  # has declared as weak libs\n\t  for deplib in $dependency_libs; do\n            deplib_base=`$ECHO \"X$deplib\" | $Xsed -e \"$basename\"`\n\t    case \" $weak_libs \" in\n\t    *\" $deplib_base \"*) ;;\n\t    *) deplibs=\"$deplibs $deplib\" ;;\n\t    esac\n\t  done\n\tdone\n\tlibs=\"$dlprefiles\"\n      fi\n      if test \"$pass\" = dlopen; then\n\t# Collect dlpreopened libraries\n\tsave_deplibs=\"$deplibs\"\n\tdeplibs=\n      fi\n\n      for deplib in $libs; do\n\tlib=\n\tfound=no\n\tcase $deplib in\n\t-mt|-mthreads|-kthread|-Kthread|-pthread|-pthreads|--thread-safe|-threads)\n\t  if test \"$linkmode,$pass\" = \"prog,link\"; then\n\t    compile_deplibs=\"$deplib $compile_deplibs\"\n\t    finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t  else\n\t    compiler_flags=\"$compiler_flags $deplib\"\n\t    if test \"$linkmode\" = lib ; then\n\t\tcase \"$new_inherited_linker_flags \" in\n\t\t    *\" $deplib \"*) ;;\n\t\t    * ) new_inherited_linker_flags=\"$new_inherited_linker_flags $deplib\" ;;\n\t\tesac\n\t    fi\n\t  fi\n\t  continue\n\t  ;;\n\t-l*)\n\t  if test \"$linkmode\" != lib && test \"$linkmode\" != prog; then\n\t    func_warning \"\\`-l' is ignored for archives/objects\"\n\t    continue\n\t  fi\n\t  func_stripname '-l' '' \"$deplib\"\n\t  name=$func_stripname_result\n\t  if test \"$linkmode\" = lib; then\n\t    searchdirs=\"$newlib_search_path $lib_search_path $compiler_lib_search_dirs $sys_lib_search_path $shlib_search_path\"\n\t  else\n\t    searchdirs=\"$newlib_search_path $lib_search_path $sys_lib_search_path $shlib_search_path\"\n\t  fi\n\t  for searchdir in $searchdirs; do\n\t    for search_ext in .la $std_shrext .so .a; do\n\t      # Search the libtool library\n\t      lib=\"$searchdir/lib${name}${search_ext}\"\n\t      if test -f \"$lib\"; then\n\t\tif test \"$search_ext\" = \".la\"; then\n\t\t  found=yes\n\t\telse\n\t\t  found=no\n\t\tfi\n\t\tbreak 2\n\t      fi\n\t    done\n\t  done\n\t  if test \"$found\" != yes; then\n\t    # deplib doesn't seem to be a libtool library\n\t    if test \"$linkmode,$pass\" = \"prog,link\"; then\n\t      compile_deplibs=\"$deplib $compile_deplibs\"\n\t      finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t    else\n\t      deplibs=\"$deplib $deplibs\"\n\t      test \"$linkmode\" = lib && newdependency_libs=\"$deplib $newdependency_libs\"\n\t    fi\n\t    continue\n\t  else # deplib is a libtool library\n\t    # If $allow_libtool_libs_with_static_runtimes && $deplib is a stdlib,\n\t    # We need to do some special things here, and not later.\n\t    if test \"X$allow_libtool_libs_with_static_runtimes\" = \"Xyes\" ; then\n\t      case \" $predeps $postdeps \" in\n\t      *\" $deplib \"*)\n\t\tif func_lalib_p \"$lib\"; then\n\t\t  library_names=\n\t\t  old_library=\n\t\t  func_source \"$lib\"\n\t\t  for l in $old_library $library_names; do\n\t\t    ll=\"$l\"\n\t\t  done\n\t\t  if test \"X$ll\" = \"X$old_library\" ; then # only static version available\n\t\t    found=no\n\t\t    func_dirname \"$lib\" \"\" \".\"\n\t\t    ladir=\"$func_dirname_result\"\n\t\t    lib=$ladir/$old_library\n\t\t    if test \"$linkmode,$pass\" = \"prog,link\"; then\n\t\t      compile_deplibs=\"$deplib $compile_deplibs\"\n\t\t      finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t\t    else\n\t\t      deplibs=\"$deplib $deplibs\"\n\t\t      test \"$linkmode\" = lib && newdependency_libs=\"$deplib $newdependency_libs\"\n\t\t    fi\n\t\t    continue\n\t\t  fi\n\t\tfi\n\t\t;;\n\t      *) ;;\n\t      esac\n\t    fi\n\t  fi\n\t  ;; # -l\n\t*.ltframework)\n\t  if test \"$linkmode,$pass\" = \"prog,link\"; then\n\t    compile_deplibs=\"$deplib $compile_deplibs\"\n\t    finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t  else\n\t    deplibs=\"$deplib $deplibs\"\n\t    if test \"$linkmode\" = lib ; then\n\t\tcase \"$new_inherited_linker_flags \" in\n\t\t    *\" $deplib \"*) ;;\n\t\t    * ) new_inherited_linker_flags=\"$new_inherited_linker_flags $deplib\" ;;\n\t\tesac\n\t    fi\n\t  fi\n\t  continue\n\t  ;;\n\t-L*)\n\t  case $linkmode in\n\t  lib)\n\t    deplibs=\"$deplib $deplibs\"\n\t    test \"$pass\" = conv && continue\n\t    newdependency_libs=\"$deplib $newdependency_libs\"\n\t    func_stripname '-L' '' \"$deplib\"\n\t    newlib_search_path=\"$newlib_search_path $func_stripname_result\"\n\t    ;;\n\t  prog)\n\t    if test \"$pass\" = conv; then\n\t      deplibs=\"$deplib $deplibs\"\n\t      continue\n\t    fi\n\t    if test \"$pass\" = scan; then\n\t      deplibs=\"$deplib $deplibs\"\n\t    else\n\t      compile_deplibs=\"$deplib $compile_deplibs\"\n\t      finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t    fi\n\t    func_stripname '-L' '' \"$deplib\"\n\t    newlib_search_path=\"$newlib_search_path $func_stripname_result\"\n\t    ;;\n\t  *)\n\t    func_warning \"\\`-L' is ignored for archives/objects\"\n\t    ;;\n\t  esac # linkmode\n\t  continue\n\t  ;; # -L\n\t-R*)\n\t  if test \"$pass\" = link; then\n\t    func_stripname '-R' '' \"$deplib\"\n\t    dir=$func_stripname_result\n\t    # Make sure the xrpath contains only unique directories.\n\t    case \"$xrpath \" in\n\t    *\" $dir \"*) ;;\n\t    *) xrpath=\"$xrpath $dir\" ;;\n\t    esac\n\t  fi\n\t  deplibs=\"$deplib $deplibs\"\n\t  continue\n\t  ;;\n\t*.la) lib=\"$deplib\" ;;\n\t*.$libext)\n\t  if test \"$pass\" = conv; then\n\t    deplibs=\"$deplib $deplibs\"\n\t    continue\n\t  fi\n\t  case $linkmode in\n\t  lib)\n\t    # Linking convenience modules into shared libraries is allowed,\n\t    # but linking other static libraries is non-portable.\n\t    case \" $dlpreconveniencelibs \" in\n\t    *\" $deplib \"*) ;;\n\t    *)\n\t      valid_a_lib=no\n\t      case $deplibs_check_method in\n\t\tmatch_pattern*)\n\t\t  set dummy $deplibs_check_method; shift\n\t\t  match_pattern_regex=`expr \"$deplibs_check_method\" : \"$1 \\(.*\\)\"`\n\t\t  if eval \"\\$ECHO \\\"X$deplib\\\"\" 2>/dev/null | $Xsed -e 10q \\\n\t\t    | $EGREP \"$match_pattern_regex\" > /dev/null; then\n\t\t    valid_a_lib=yes\n\t\t  fi\n\t\t;;\n\t\tpass_all)\n\t\t  valid_a_lib=yes\n\t\t;;\n\t      esac\n\t      if test \"$valid_a_lib\" != yes; then\n\t\t$ECHO\n\t\t$ECHO \"*** Warning: Trying to link with static lib archive $deplib.\"\n\t\t$ECHO \"*** I have the capability to make that library automatically link in when\"\n\t\t$ECHO \"*** you link to this library.  But I can only do this if you have a\"\n\t\t$ECHO \"*** shared version of the library, which you do not appear to have\"\n\t\t$ECHO \"*** because the file extensions .$libext of this argument makes me believe\"\n\t\t$ECHO \"*** that it is just a static archive that I should not use here.\"\n\t      else\n\t\t$ECHO\n\t\t$ECHO \"*** Warning: Linking the shared library $output against the\"\n\t\t$ECHO \"*** static library $deplib is not portable!\"\n\t\tdeplibs=\"$deplib $deplibs\"\n\t      fi\n\t      ;;\n\t    esac\n\t    continue\n\t    ;;\n\t  prog)\n\t    if test \"$pass\" != link; then\n\t      deplibs=\"$deplib $deplibs\"\n\t    else\n\t      compile_deplibs=\"$deplib $compile_deplibs\"\n\t      finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t    fi\n\t    continue\n\t    ;;\n\t  esac # linkmode\n\t  ;; # *.$libext\n\t*.lo | *.$objext)\n\t  if test \"$pass\" = conv; then\n\t    deplibs=\"$deplib $deplibs\"\n\t  elif test \"$linkmode\" = prog; then\n\t    if test \"$pass\" = dlpreopen || test \"$dlopen_support\" != yes || test \"$build_libtool_libs\" = no; then\n\t      # If there is no dlopen support or we're linking statically,\n\t      # we need to preload.\n\t      newdlprefiles=\"$newdlprefiles $deplib\"\n\t      compile_deplibs=\"$deplib $compile_deplibs\"\n\t      finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t    else\n\t      newdlfiles=\"$newdlfiles $deplib\"\n\t    fi\n\t  fi\n\t  continue\n\t  ;;\n\t%DEPLIBS%)\n\t  alldeplibs=yes\n\t  continue\n\t  ;;\n\tesac # case $deplib\n\n\tif test \"$found\" = yes || test -f \"$lib\"; then :\n\telse\n\t  func_fatal_error \"cannot find the library \\`$lib' or unhandled argument \\`$deplib'\"\n\tfi\n\n\t# Check to see that this really is a libtool archive.\n\tfunc_lalib_unsafe_p \"$lib\" \\\n\t  || func_fatal_error \"\\`$lib' is not a valid libtool archive\"\n\n\tfunc_dirname \"$lib\" \"\" \".\"\n\tladir=\"$func_dirname_result\"\n\n\tdlname=\n\tdlopen=\n\tdlpreopen=\n\tlibdir=\n\tlibrary_names=\n\told_library=\n\tinherited_linker_flags=\n\t# If the library was installed with an old release of libtool,\n\t# it will not redefine variables installed, or shouldnotlink\n\tinstalled=yes\n\tshouldnotlink=no\n\tavoidtemprpath=\n\n\n\t# Read the .la file\n\tfunc_source \"$lib\"\n\n\t# Convert \"-framework foo\" to \"foo.ltframework\"\n\tif test -n \"$inherited_linker_flags\"; then\n\t  tmp_inherited_linker_flags=`$ECHO \"X$inherited_linker_flags\" | $Xsed -e 's/-framework \\([^ $]*\\)/\\1.ltframework/g'`\n\t  for tmp_inherited_linker_flag in $tmp_inherited_linker_flags; do\n\t    case \" $new_inherited_linker_flags \" in\n\t      *\" $tmp_inherited_linker_flag \"*) ;;\n\t      *) new_inherited_linker_flags=\"$new_inherited_linker_flags $tmp_inherited_linker_flag\";;\n\t    esac\n\t  done\n\tfi\n\tdependency_libs=`$ECHO \"X $dependency_libs\" | $Xsed -e 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\tif test \"$linkmode,$pass\" = \"lib,link\" ||\n\t   test \"$linkmode,$pass\" = \"prog,scan\" ||\n\t   { test \"$linkmode\" != prog && test \"$linkmode\" != lib; }; then\n\t  test -n \"$dlopen\" && dlfiles=\"$dlfiles $dlopen\"\n\t  test -n \"$dlpreopen\" && dlprefiles=\"$dlprefiles $dlpreopen\"\n\tfi\n\n\tif test \"$pass\" = conv; then\n\t  # Only check for convenience libraries\n\t  deplibs=\"$lib $deplibs\"\n\t  if test -z \"$libdir\"; then\n\t    if test -z \"$old_library\"; then\n\t      func_fatal_error \"cannot find name of link library for \\`$lib'\"\n\t    fi\n\t    # It is a libtool convenience library, so add in its objects.\n\t    convenience=\"$convenience $ladir/$objdir/$old_library\"\n\t    old_convenience=\"$old_convenience $ladir/$objdir/$old_library\"\n\t  elif test \"$linkmode\" != prog && test \"$linkmode\" != lib; then\n\t    func_fatal_error \"\\`$lib' is not a convenience library\"\n\t  fi\n\t  tmp_libs=\n\t  for deplib in $dependency_libs; do\n\t    deplibs=\"$deplib $deplibs\"\n\t    if $opt_duplicate_deps ; then\n\t      case \"$tmp_libs \" in\n\t      *\" $deplib \"*) specialdeplibs=\"$specialdeplibs $deplib\" ;;\n\t      esac\n\t    fi\n\t    tmp_libs=\"$tmp_libs $deplib\"\n\t  done\n\t  continue\n\tfi # $pass = conv\n\n\n\t# Get the name of the library we link against.\n\tlinklib=\n\tfor l in $old_library $library_names; do\n\t  linklib=\"$l\"\n\tdone\n\tif test -z \"$linklib\"; then\n\t  func_fatal_error \"cannot find name of link library for \\`$lib'\"\n\tfi\n\n\t# This library was specified with -dlopen.\n\tif test \"$pass\" = dlopen; then\n\t  if test -z \"$libdir\"; then\n\t    func_fatal_error \"cannot -dlopen a convenience library: \\`$lib'\"\n\t  fi\n\t  if test -z \"$dlname\" ||\n\t     test \"$dlopen_support\" != yes ||\n\t     test \"$build_libtool_libs\" = no; then\n\t    # If there is no dlname, no dlopen support or we're linking\n\t    # statically, we need to preload.  We also need to preload any\n\t    # dependent libraries so libltdl's deplib preloader doesn't\n\t    # bomb out in the load deplibs phase.\n\t    dlprefiles=\"$dlprefiles $lib $dependency_libs\"\n\t  else\n\t    newdlfiles=\"$newdlfiles $lib\"\n\t  fi\n\t  continue\n\tfi # $pass = dlopen\n\n\t# We need an absolute path.\n\tcase $ladir in\n\t[\\\\/]* | [A-Za-z]:[\\\\/]*) abs_ladir=\"$ladir\" ;;\n\t*)\n\t  abs_ladir=`cd \"$ladir\" && pwd`\n\t  if test -z \"$abs_ladir\"; then\n\t    func_warning \"cannot determine absolute directory name of \\`$ladir'\"\n\t    func_warning \"passing it literally to the linker, although it might fail\"\n\t    abs_ladir=\"$ladir\"\n\t  fi\n\t  ;;\n\tesac\n\tfunc_basename \"$lib\"\n\tlaname=\"$func_basename_result\"\n\n\t# Find the relevant object directory and library name.\n\tif test \"X$installed\" = Xyes; then\n\t  if test ! -f \"$libdir/$linklib\" && test -f \"$abs_ladir/$linklib\"; then\n\t    func_warning \"library \\`$lib' was moved.\"\n\t    dir=\"$ladir\"\n\t    absdir=\"$abs_ladir\"\n\t    libdir=\"$abs_ladir\"\n\t  else\n\t    dir=\"$libdir\"\n\t    absdir=\"$libdir\"\n\t  fi\n\t  test \"X$hardcode_automatic\" = Xyes && avoidtemprpath=yes\n\telse\n\t  if test ! -f \"$ladir/$objdir/$linklib\" && test -f \"$abs_ladir/$linklib\"; then\n\t    dir=\"$ladir\"\n\t    absdir=\"$abs_ladir\"\n\t    # Remove this search path later\n\t    notinst_path=\"$notinst_path $abs_ladir\"\n\t  else\n\t    dir=\"$ladir/$objdir\"\n\t    absdir=\"$abs_ladir/$objdir\"\n\t    # Remove this search path later\n\t    notinst_path=\"$notinst_path $abs_ladir\"\n\t  fi\n\tfi # $installed = yes\n\tfunc_stripname 'lib' '.la' \"$laname\"\n\tname=$func_stripname_result\n\n\t# This library was specified with -dlpreopen.\n\tif test \"$pass\" = dlpreopen; then\n\t  if test -z \"$libdir\" && test \"$linkmode\" = prog; then\n\t    func_fatal_error \"only libraries may -dlpreopen a convenience library: \\`$lib'\"\n\t  fi\n\t  # Prefer using a static library (so that no silly _DYNAMIC symbols\n\t  # are required to link).\n\t  if test -n \"$old_library\"; then\n\t    newdlprefiles=\"$newdlprefiles $dir/$old_library\"\n\t    # Keep a list of preopened convenience libraries to check\n\t    # that they are being used correctly in the link pass.\n\t    test -z \"$libdir\" && \\\n\t\tdlpreconveniencelibs=\"$dlpreconveniencelibs $dir/$old_library\"\n\t  # Otherwise, use the dlname, so that lt_dlopen finds it.\n\t  elif test -n \"$dlname\"; then\n\t    newdlprefiles=\"$newdlprefiles $dir/$dlname\"\n\t  else\n\t    newdlprefiles=\"$newdlprefiles $dir/$linklib\"\n\t  fi\n\tfi # $pass = dlpreopen\n\n\tif test -z \"$libdir\"; then\n\t  # Link the convenience library\n\t  if test \"$linkmode\" = lib; then\n\t    deplibs=\"$dir/$old_library $deplibs\"\n\t  elif test \"$linkmode,$pass\" = \"prog,link\"; then\n\t    compile_deplibs=\"$dir/$old_library $compile_deplibs\"\n\t    finalize_deplibs=\"$dir/$old_library $finalize_deplibs\"\n\t  else\n\t    deplibs=\"$lib $deplibs\" # used for prog,scan pass\n\t  fi\n\t  continue\n\tfi\n\n\n\tif test \"$linkmode\" = prog && test \"$pass\" != link; then\n\t  newlib_search_path=\"$newlib_search_path $ladir\"\n\t  deplibs=\"$lib $deplibs\"\n\n\t  linkalldeplibs=no\n\t  if test \"$link_all_deplibs\" != no || test -z \"$library_names\" ||\n\t     test \"$build_libtool_libs\" = no; then\n\t    linkalldeplibs=yes\n\t  fi\n\n\t  tmp_libs=\n\t  for deplib in $dependency_libs; do\n\t    case $deplib in\n\t    -L*) func_stripname '-L' '' \"$deplib\"\n\t         newlib_search_path=\"$newlib_search_path $func_stripname_result\"\n\t\t ;;\n\t    esac\n\t    # Need to link against all dependency_libs?\n\t    if test \"$linkalldeplibs\" = yes; then\n\t      deplibs=\"$deplib $deplibs\"\n\t    else\n\t      # Need to hardcode shared library paths\n\t      # or/and link against static libraries\n\t      newdependency_libs=\"$deplib $newdependency_libs\"\n\t    fi\n\t    if $opt_duplicate_deps ; then\n\t      case \"$tmp_libs \" in\n\t      *\" $deplib \"*) specialdeplibs=\"$specialdeplibs $deplib\" ;;\n\t      esac\n\t    fi\n\t    tmp_libs=\"$tmp_libs $deplib\"\n\t  done # for deplib\n\t  continue\n\tfi # $linkmode = prog...\n\n\tif test \"$linkmode,$pass\" = \"prog,link\"; then\n\t  if test -n \"$library_names\" &&\n\t     { { test \"$prefer_static_libs\" = no ||\n\t         test \"$prefer_static_libs,$installed\" = \"built,yes\"; } ||\n\t       test -z \"$old_library\"; }; then\n\t    # We need to hardcode the library path\n\t    if test -n \"$shlibpath_var\" && test -z \"$avoidtemprpath\" ; then\n\t      # Make sure the rpath contains only unique directories.\n\t      case \"$temp_rpath:\" in\n\t      *\"$absdir:\"*) ;;\n\t      *) temp_rpath=\"$temp_rpath$absdir:\" ;;\n\t      esac\n\t    fi\n\n\t    # Hardcode the library path.\n\t    # Skip directories that are in the system default run-time\n\t    # search path.\n\t    case \" $sys_lib_dlsearch_path \" in\n\t    *\" $absdir \"*) ;;\n\t    *)\n\t      case \"$compile_rpath \" in\n\t      *\" $absdir \"*) ;;\n\t      *) compile_rpath=\"$compile_rpath $absdir\"\n\t      esac\n\t      ;;\n\t    esac\n\t    case \" $sys_lib_dlsearch_path \" in\n\t    *\" $libdir \"*) ;;\n\t    *)\n\t      case \"$finalize_rpath \" in\n\t      *\" $libdir \"*) ;;\n\t      *) finalize_rpath=\"$finalize_rpath $libdir\"\n\t      esac\n\t      ;;\n\t    esac\n\t  fi # $linkmode,$pass = prog,link...\n\n\t  if test \"$alldeplibs\" = yes &&\n\t     { test \"$deplibs_check_method\" = pass_all ||\n\t       { test \"$build_libtool_libs\" = yes &&\n\t\t test -n \"$library_names\"; }; }; then\n\t    # We only need to search for static libraries\n\t    continue\n\t  fi\n\tfi\n\n\tlink_static=no # Whether the deplib will be linked statically\n\tuse_static_libs=$prefer_static_libs\n\tif test \"$use_static_libs\" = built && test \"$installed\" = yes; then\n\t  use_static_libs=no\n\tfi\n\tif test -n \"$library_names\" &&\n\t   { test \"$use_static_libs\" = no || test -z \"$old_library\"; }; then\n\t  case $host in\n\t  *cygwin* | *mingw* | *cegcc*)\n\t      # No point in relinking DLLs because paths are not encoded\n\t      notinst_deplibs=\"$notinst_deplibs $lib\"\n\t      need_relink=no\n\t    ;;\n\t  *)\n\t    if test \"$installed\" = no; then\n\t      notinst_deplibs=\"$notinst_deplibs $lib\"\n\t      need_relink=yes\n\t    fi\n\t    ;;\n\t  esac\n\t  # This is a shared library\n\n\t  # Warn about portability, can't link against -module's on some\n\t  # systems (darwin).  Don't bleat about dlopened modules though!\n\t  dlopenmodule=\"\"\n\t  for dlpremoduletest in $dlprefiles; do\n\t    if test \"X$dlpremoduletest\" = \"X$lib\"; then\n\t      dlopenmodule=\"$dlpremoduletest\"\n\t      break\n\t    fi\n\t  done\n\t  if test -z \"$dlopenmodule\" && test \"$shouldnotlink\" = yes && test \"$pass\" = link; then\n\t    $ECHO\n\t    if test \"$linkmode\" = prog; then\n\t      $ECHO \"*** Warning: Linking the executable $output against the loadable module\"\n\t    else\n\t      $ECHO \"*** Warning: Linking the shared library $output against the loadable module\"\n\t    fi\n\t    $ECHO \"*** $linklib is not portable!\"\n\t  fi\n\t  if test \"$linkmode\" = lib &&\n\t     test \"$hardcode_into_libs\" = yes; then\n\t    # Hardcode the library path.\n\t    # Skip directories that are in the system default run-time\n\t    # search path.\n\t    case \" $sys_lib_dlsearch_path \" in\n\t    *\" $absdir \"*) ;;\n\t    *)\n\t      case \"$compile_rpath \" in\n\t      *\" $absdir \"*) ;;\n\t      *) compile_rpath=\"$compile_rpath $absdir\"\n\t      esac\n\t      ;;\n\t    esac\n\t    case \" $sys_lib_dlsearch_path \" in\n\t    *\" $libdir \"*) ;;\n\t    *)\n\t      case \"$finalize_rpath \" in\n\t      *\" $libdir \"*) ;;\n\t      *) finalize_rpath=\"$finalize_rpath $libdir\"\n\t      esac\n\t      ;;\n\t    esac\n\t  fi\n\n\t  if test -n \"$old_archive_from_expsyms_cmds\"; then\n\t    # figure out the soname\n\t    set dummy $library_names\n\t    shift\n\t    realname=\"$1\"\n\t    shift\n\t    libname=`eval \"\\\\$ECHO \\\"$libname_spec\\\"\"`\n\t    # use dlname if we got it. it's perfectly good, no?\n\t    if test -n \"$dlname\"; then\n\t      soname=\"$dlname\"\n\t    elif test -n \"$soname_spec\"; then\n\t      # bleh windows\n\t      case $host in\n\t      *cygwin* | mingw* | *cegcc*)\n\t        func_arith $current - $age\n\t\tmajor=$func_arith_result\n\t\tversuffix=\"-$major\"\n\t\t;;\n\t      esac\n\t      eval soname=\\\"$soname_spec\\\"\n\t    else\n\t      soname=\"$realname\"\n\t    fi\n\n\t    # Make a new name for the extract_expsyms_cmds to use\n\t    soroot=\"$soname\"\n\t    func_basename \"$soroot\"\n\t    soname=\"$func_basename_result\"\n\t    func_stripname 'lib' '.dll' \"$soname\"\n\t    newlib=libimp-$func_stripname_result.a\n\n\t    # If the library has no export list, then create one now\n\t    if test -f \"$output_objdir/$soname-def\"; then :\n\t    else\n\t      func_verbose \"extracting exported symbol list from \\`$soname'\"\n\t      func_execute_cmds \"$extract_expsyms_cmds\" 'exit $?'\n\t    fi\n\n\t    # Create $newlib\n\t    if test -f \"$output_objdir/$newlib\"; then :; else\n\t      func_verbose \"generating import library for \\`$soname'\"\n\t      func_execute_cmds \"$old_archive_from_expsyms_cmds\" 'exit $?'\n\t    fi\n\t    # make sure the library variables are pointing to the new library\n\t    dir=$output_objdir\n\t    linklib=$newlib\n\t  fi # test -n \"$old_archive_from_expsyms_cmds\"\n\n\t  if test \"$linkmode\" = prog || test \"$mode\" != relink; then\n\t    add_shlibpath=\n\t    add_dir=\n\t    add=\n\t    lib_linked=yes\n\t    case $hardcode_action in\n\t    immediate | unsupported)\n\t      if test \"$hardcode_direct\" = no; then\n\t\tadd=\"$dir/$linklib\"\n\t\tcase $host in\n\t\t  *-*-sco3.2v5.0.[024]*) add_dir=\"-L$dir\" ;;\n\t\t  *-*-sysv4*uw2*) add_dir=\"-L$dir\" ;;\n\t\t  *-*-sysv5OpenUNIX* | *-*-sysv5UnixWare7.[01].[10]* | \\\n\t\t    *-*-unixware7*) add_dir=\"-L$dir\" ;;\n\t\t  *-*-darwin* )\n\t\t    # if the lib is a (non-dlopened) module then we can not\n\t\t    # link against it, someone is ignoring the earlier warnings\n\t\t    if /usr/bin/file -L $add 2> /dev/null |\n\t\t\t $GREP \": [^:]* bundle\" >/dev/null ; then\n\t\t      if test \"X$dlopenmodule\" != \"X$lib\"; then\n\t\t\t$ECHO \"*** Warning: lib $linklib is a module, not a shared library\"\n\t\t\tif test -z \"$old_library\" ; then\n\t\t\t  $ECHO\n\t\t\t  $ECHO \"*** And there doesn't seem to be a static archive available\"\n\t\t\t  $ECHO \"*** The link will probably fail, sorry\"\n\t\t\telse\n\t\t\t  add=\"$dir/$old_library\"\n\t\t\tfi\n\t\t      elif test -n \"$old_library\"; then\n\t\t\tadd=\"$dir/$old_library\"\n\t\t      fi\n\t\t    fi\n\t\tesac\n\t      elif test \"$hardcode_minus_L\" = no; then\n\t\tcase $host in\n\t\t*-*-sunos*) add_shlibpath=\"$dir\" ;;\n\t\tesac\n\t\tadd_dir=\"-L$dir\"\n\t\tadd=\"-l$name\"\n\t      elif test \"$hardcode_shlibpath_var\" = no; then\n\t\tadd_shlibpath=\"$dir\"\n\t\tadd=\"-l$name\"\n\t      else\n\t\tlib_linked=no\n\t      fi\n\t      ;;\n\t    relink)\n\t      if test \"$hardcode_direct\" = yes &&\n\t         test \"$hardcode_direct_absolute\" = no; then\n\t\tadd=\"$dir/$linklib\"\n\t      elif test \"$hardcode_minus_L\" = yes; then\n\t\tadd_dir=\"-L$dir\"\n\t\t# Try looking first in the location we're being installed to.\n\t\tif test -n \"$inst_prefix_dir\"; then\n\t\t  case $libdir in\n\t\t    [\\\\/]*)\n\t\t      add_dir=\"$add_dir -L$inst_prefix_dir$libdir\"\n\t\t      ;;\n\t\t  esac\n\t\tfi\n\t\tadd=\"-l$name\"\n\t      elif test \"$hardcode_shlibpath_var\" = yes; then\n\t\tadd_shlibpath=\"$dir\"\n\t\tadd=\"-l$name\"\n\t      else\n\t\tlib_linked=no\n\t      fi\n\t      ;;\n\t    *) lib_linked=no ;;\n\t    esac\n\n\t    if test \"$lib_linked\" != yes; then\n\t      func_fatal_configuration \"unsupported hardcode properties\"\n\t    fi\n\n\t    if test -n \"$add_shlibpath\"; then\n\t      case :$compile_shlibpath: in\n\t      *\":$add_shlibpath:\"*) ;;\n\t      *) compile_shlibpath=\"$compile_shlibpath$add_shlibpath:\" ;;\n\t      esac\n\t    fi\n\t    if test \"$linkmode\" = prog; then\n\t      test -n \"$add_dir\" && compile_deplibs=\"$add_dir $compile_deplibs\"\n\t      test -n \"$add\" && compile_deplibs=\"$add $compile_deplibs\"\n\t    else\n\t      test -n \"$add_dir\" && deplibs=\"$add_dir $deplibs\"\n\t      test -n \"$add\" && deplibs=\"$add $deplibs\"\n\t      if test \"$hardcode_direct\" != yes &&\n\t\t test \"$hardcode_minus_L\" != yes &&\n\t\t test \"$hardcode_shlibpath_var\" = yes; then\n\t\tcase :$finalize_shlibpath: in\n\t\t*\":$libdir:\"*) ;;\n\t\t*) finalize_shlibpath=\"$finalize_shlibpath$libdir:\" ;;\n\t\tesac\n\t      fi\n\t    fi\n\t  fi\n\n\t  if test \"$linkmode\" = prog || test \"$mode\" = relink; then\n\t    add_shlibpath=\n\t    add_dir=\n\t    add=\n\t    # Finalize command for both is simple: just hardcode it.\n\t    if test \"$hardcode_direct\" = yes &&\n\t       test \"$hardcode_direct_absolute\" = no; then\n\t      add=\"$libdir/$linklib\"\n\t    elif test \"$hardcode_minus_L\" = yes; then\n\t      add_dir=\"-L$libdir\"\n\t      add=\"-l$name\"\n\t    elif test \"$hardcode_shlibpath_var\" = yes; then\n\t      case :$finalize_shlibpath: in\n\t      *\":$libdir:\"*) ;;\n\t      *) finalize_shlibpath=\"$finalize_shlibpath$libdir:\" ;;\n\t      esac\n\t      add=\"-l$name\"\n\t    elif test \"$hardcode_automatic\" = yes; then\n\t      if test -n \"$inst_prefix_dir\" &&\n\t\t test -f \"$inst_prefix_dir$libdir/$linklib\" ; then\n\t\tadd=\"$inst_prefix_dir$libdir/$linklib\"\n\t      else\n\t\tadd=\"$libdir/$linklib\"\n\t      fi\n\t    else\n\t      # We cannot seem to hardcode it, guess we'll fake it.\n\t      add_dir=\"-L$libdir\"\n\t      # Try looking first in the location we're being installed to.\n\t      if test -n \"$inst_prefix_dir\"; then\n\t\tcase $libdir in\n\t\t  [\\\\/]*)\n\t\t    add_dir=\"$add_dir -L$inst_prefix_dir$libdir\"\n\t\t    ;;\n\t\tesac\n\t      fi\n\t      add=\"-l$name\"\n\t    fi\n\n\t    if test \"$linkmode\" = prog; then\n\t      test -n \"$add_dir\" && finalize_deplibs=\"$add_dir $finalize_deplibs\"\n\t      test -n \"$add\" && finalize_deplibs=\"$add $finalize_deplibs\"\n\t    else\n\t      test -n \"$add_dir\" && deplibs=\"$add_dir $deplibs\"\n\t      test -n \"$add\" && deplibs=\"$add $deplibs\"\n\t    fi\n\t  fi\n\telif test \"$linkmode\" = prog; then\n\t  # Here we assume that one of hardcode_direct or hardcode_minus_L\n\t  # is not unsupported.  This is valid on all known static and\n\t  # shared platforms.\n\t  if test \"$hardcode_direct\" != unsupported; then\n\t    test -n \"$old_library\" && linklib=\"$old_library\"\n\t    compile_deplibs=\"$dir/$linklib $compile_deplibs\"\n\t    finalize_deplibs=\"$dir/$linklib $finalize_deplibs\"\n\t  else\n\t    compile_deplibs=\"-l$name -L$dir $compile_deplibs\"\n\t    finalize_deplibs=\"-l$name -L$dir $finalize_deplibs\"\n\t  fi\n\telif test \"$build_libtool_libs\" = yes; then\n\t  # Not a shared library\n\t  if test \"$deplibs_check_method\" != pass_all; then\n\t    # We're trying link a shared library against a static one\n\t    # but the system doesn't support it.\n\n\t    # Just print a warning and add the library to dependency_libs so\n\t    # that the program can be linked against the static library.\n\t    $ECHO\n\t    $ECHO \"*** Warning: This system can not link to static lib archive $lib.\"\n\t    $ECHO \"*** I have the capability to make that library automatically link in when\"\n\t    $ECHO \"*** you link to this library.  But I can only do this if you have a\"\n\t    $ECHO \"*** shared version of the library, which you do not appear to have.\"\n\t    if test \"$module\" = yes; then\n\t      $ECHO \"*** But as you try to build a module library, libtool will still create \"\n\t      $ECHO \"*** a static module, that should work as long as the dlopening application\"\n\t      $ECHO \"*** is linked with the -dlopen flag to resolve symbols at runtime.\"\n\t      if test -z \"$global_symbol_pipe\"; then\n\t\t$ECHO\n\t\t$ECHO \"*** However, this would only work if libtool was able to extract symbol\"\n\t\t$ECHO \"*** lists from a program, using \\`nm' or equivalent, but libtool could\"\n\t\t$ECHO \"*** not find such a program.  So, this module is probably useless.\"\n\t\t$ECHO \"*** \\`nm' from GNU binutils and a full rebuild may help.\"\n\t      fi\n\t      if test \"$build_old_libs\" = no; then\n\t\tbuild_libtool_libs=module\n\t\tbuild_old_libs=yes\n\t      else\n\t\tbuild_libtool_libs=no\n\t      fi\n\t    fi\n\t  else\n\t    deplibs=\"$dir/$old_library $deplibs\"\n\t    link_static=yes\n\t  fi\n\tfi # link shared/static library?\n\n\tif test \"$linkmode\" = lib; then\n\t  if test -n \"$dependency_libs\" &&\n\t     { test \"$hardcode_into_libs\" != yes ||\n\t       test \"$build_old_libs\" = yes ||\n\t       test \"$link_static\" = yes; }; then\n\t    # Extract -R from dependency_libs\n\t    temp_deplibs=\n\t    for libdir in $dependency_libs; do\n\t      case $libdir in\n\t      -R*) func_stripname '-R' '' \"$libdir\"\n\t           temp_xrpath=$func_stripname_result\n\t\t   case \" $xrpath \" in\n\t\t   *\" $temp_xrpath \"*) ;;\n\t\t   *) xrpath=\"$xrpath $temp_xrpath\";;\n\t\t   esac;;\n\t      *) temp_deplibs=\"$temp_deplibs $libdir\";;\n\t      esac\n\t    done\n\t    dependency_libs=\"$temp_deplibs\"\n\t  fi\n\n\t  newlib_search_path=\"$newlib_search_path $absdir\"\n\t  # Link against this library\n\t  test \"$link_static\" = no && newdependency_libs=\"$abs_ladir/$laname $newdependency_libs\"\n\t  # ... and its dependency_libs\n\t  tmp_libs=\n\t  for deplib in $dependency_libs; do\n\t    newdependency_libs=\"$deplib $newdependency_libs\"\n\t    if $opt_duplicate_deps ; then\n\t      case \"$tmp_libs \" in\n\t      *\" $deplib \"*) specialdeplibs=\"$specialdeplibs $deplib\" ;;\n\t      esac\n\t    fi\n\t    tmp_libs=\"$tmp_libs $deplib\"\n\t  done\n\n\t  if test \"$link_all_deplibs\" != no; then\n\t    # Add the search paths of all dependency libraries\n\t    for deplib in $dependency_libs; do\n\t      case $deplib in\n\t      -L*) path=\"$deplib\" ;;\n\t      *.la)\n\t        func_dirname \"$deplib\" \"\" \".\"\n\t\tdir=\"$func_dirname_result\"\n\t\t# We need an absolute path.\n\t\tcase $dir in\n\t\t[\\\\/]* | [A-Za-z]:[\\\\/]*) absdir=\"$dir\" ;;\n\t\t*)\n\t\t  absdir=`cd \"$dir\" && pwd`\n\t\t  if test -z \"$absdir\"; then\n\t\t    func_warning \"cannot determine absolute directory name of \\`$dir'\"\n\t\t    absdir=\"$dir\"\n\t\t  fi\n\t\t  ;;\n\t\tesac\n\t\tif $GREP \"^installed=no\" $deplib > /dev/null; then\n\t\tcase $host in\n\t\t*-*-darwin*)\n\t\t  depdepl=\n\t\t  eval deplibrary_names=`${SED} -n -e 's/^library_names=\\(.*\\)$/\\1/p' $deplib`\n\t\t  if test -n \"$deplibrary_names\" ; then\n\t\t    for tmp in $deplibrary_names ; do\n\t\t      depdepl=$tmp\n\t\t    done\n\t\t    if test -f \"$absdir/$objdir/$depdepl\" ; then\n\t\t      depdepl=\"$absdir/$objdir/$depdepl\"\n\t\t      darwin_install_name=`${OTOOL} -L $depdepl | awk '{if (NR == 2) {print $1;exit}}'`\n                      if test -z \"$darwin_install_name\"; then\n                          darwin_install_name=`${OTOOL64} -L $depdepl  | awk '{if (NR == 2) {print $1;exit}}'`\n                      fi\n\t\t      compiler_flags=\"$compiler_flags ${wl}-dylib_file ${wl}${darwin_install_name}:${depdepl}\"\n\t\t      linker_flags=\"$linker_flags -dylib_file ${darwin_install_name}:${depdepl}\"\n\t\t      path=\n\t\t    fi\n\t\t  fi\n\t\t  ;;\n\t\t*)\n\t\t  path=\"-L$absdir/$objdir\"\n\t\t  ;;\n\t\tesac\n\t\telse\n\t\t  eval libdir=`${SED} -n -e 's/^libdir=\\(.*\\)$/\\1/p' $deplib`\n\t\t  test -z \"$libdir\" && \\\n\t\t    func_fatal_error \"\\`$deplib' is not a valid libtool archive\"\n\t\t  test \"$absdir\" != \"$libdir\" && \\\n\t\t    func_warning \"\\`$deplib' seems to be moved\"\n\n\t\t  path=\"-L$absdir\"\n\t\tfi\n\t\t;;\n\t      esac\n\t      case \" $deplibs \" in\n\t      *\" $path \"*) ;;\n\t      *) deplibs=\"$path $deplibs\" ;;\n\t      esac\n\t    done\n\t  fi # link_all_deplibs != no\n\tfi # linkmode = lib\n      done # for deplib in $libs\n      if test \"$pass\" = link; then\n\tif test \"$linkmode\" = \"prog\"; then\n\t  compile_deplibs=\"$new_inherited_linker_flags $compile_deplibs\"\n\t  finalize_deplibs=\"$new_inherited_linker_flags $finalize_deplibs\"\n\telse\n\t  compiler_flags=\"$compiler_flags \"`$ECHO \"X $new_inherited_linker_flags\" | $Xsed -e 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\tfi\n      fi\n      dependency_libs=\"$newdependency_libs\"\n      if test \"$pass\" = dlpreopen; then\n\t# Link the dlpreopened libraries before other libraries\n\tfor deplib in $save_deplibs; do\n\t  deplibs=\"$deplib $deplibs\"\n\tdone\n      fi\n      if test \"$pass\" != dlopen; then\n\tif test \"$pass\" != conv; then\n\t  # Make sure lib_search_path contains only unique directories.\n\t  lib_search_path=\n\t  for dir in $newlib_search_path; do\n\t    case \"$lib_search_path \" in\n\t    *\" $dir \"*) ;;\n\t    *) lib_search_path=\"$lib_search_path $dir\" ;;\n\t    esac\n\t  done\n\t  newlib_search_path=\n\tfi\n\n\tif test \"$linkmode,$pass\" != \"prog,link\"; then\n\t  vars=\"deplibs\"\n\telse\n\t  vars=\"compile_deplibs finalize_deplibs\"\n\tfi\n\tfor var in $vars dependency_libs; do\n\t  # Add libraries to $var in reverse order\n\t  eval tmp_libs=\\\"\\$$var\\\"\n\t  new_libs=\n\t  for deplib in $tmp_libs; do\n\t    # FIXME: Pedantically, this is the right thing to do, so\n\t    #        that some nasty dependency loop isn't accidentally\n\t    #        broken:\n\t    #new_libs=\"$deplib $new_libs\"\n\t    # Pragmatically, this seems to cause very few problems in\n\t    # practice:\n\t    case $deplib in\n\t    -L*) new_libs=\"$deplib $new_libs\" ;;\n\t    -R*) ;;\n\t    *)\n\t      # And here is the reason: when a library appears more\n\t      # than once as an explicit dependence of a library, or\n\t      # is implicitly linked in more than once by the\n\t      # compiler, it is considered special, and multiple\n\t      # occurrences thereof are not removed.  Compare this\n\t      # with having the same library being listed as a\n\t      # dependency of multiple other libraries: in this case,\n\t      # we know (pedantically, we assume) the library does not\n\t      # need to be listed more than once, so we keep only the\n\t      # last copy.  This is not always right, but it is rare\n\t      # enough that we require users that really mean to play\n\t      # such unportable linking tricks to link the library\n\t      # using -Wl,-lname, so that libtool does not consider it\n\t      # for duplicate removal.\n\t      case \" $specialdeplibs \" in\n\t      *\" $deplib \"*) new_libs=\"$deplib $new_libs\" ;;\n\t      *)\n\t\tcase \" $new_libs \" in\n\t\t*\" $deplib \"*) ;;\n\t\t*) new_libs=\"$deplib $new_libs\" ;;\n\t\tesac\n\t\t;;\n\t      esac\n\t      ;;\n\t    esac\n\t  done\n\t  tmp_libs=\n\t  for deplib in $new_libs; do\n\t    case $deplib in\n\t    -L*)\n\t      case \" $tmp_libs \" in\n\t      *\" $deplib \"*) ;;\n\t      *) tmp_libs=\"$tmp_libs $deplib\" ;;\n\t      esac\n\t      ;;\n\t    *) tmp_libs=\"$tmp_libs $deplib\" ;;\n\t    esac\n\t  done\n\t  eval $var=\\\"$tmp_libs\\\"\n\tdone # for var\n      fi\n      # Last step: remove runtime libs from dependency_libs\n      # (they stay in deplibs)\n      tmp_libs=\n      for i in $dependency_libs ; do\n\tcase \" $predeps $postdeps $compiler_lib_search_path \" in\n\t*\" $i \"*)\n\t  i=\"\"\n\t  ;;\n\tesac\n\tif test -n \"$i\" ; then\n\t  tmp_libs=\"$tmp_libs $i\"\n\tfi\n      done\n      dependency_libs=$tmp_libs\n    done # for pass\n    if test \"$linkmode\" = prog; then\n      dlfiles=\"$newdlfiles\"\n    fi\n    if test \"$linkmode\" = prog || test \"$linkmode\" = lib; then\n      dlprefiles=\"$newdlprefiles\"\n    fi\n\n    case $linkmode in\n    oldlib)\n      if test -n \"$dlfiles$dlprefiles\" || test \"$dlself\" != no; then\n\tfunc_warning \"\\`-dlopen' is ignored for archives\"\n      fi\n\n      case \" $deplibs\" in\n      *\\ -l* | *\\ -L*)\n\tfunc_warning \"\\`-l' and \\`-L' are ignored for archives\" ;;\n      esac\n\n      test -n \"$rpath\" && \\\n\tfunc_warning \"\\`-rpath' is ignored for archives\"\n\n      test -n \"$xrpath\" && \\\n\tfunc_warning \"\\`-R' is ignored for archives\"\n\n      test -n \"$vinfo\" && \\\n\tfunc_warning \"\\`-version-info/-version-number' is ignored for archives\"\n\n      test -n \"$release\" && \\\n\tfunc_warning \"\\`-release' is ignored for archives\"\n\n      test -n \"$export_symbols$export_symbols_regex\" && \\\n\tfunc_warning \"\\`-export-symbols' is ignored for archives\"\n\n      # Now set the variables for building old libraries.\n      build_libtool_libs=no\n      oldlibs=\"$output\"\n      objs=\"$objs$old_deplibs\"\n      ;;\n\n    lib)\n      # Make sure we only generate libraries of the form `libNAME.la'.\n      case $outputname in\n      lib*)\n\tfunc_stripname 'lib' '.la' \"$outputname\"\n\tname=$func_stripname_result\n\teval shared_ext=\\\"$shrext_cmds\\\"\n\teval libname=\\\"$libname_spec\\\"\n\t;;\n      *)\n\ttest \"$module\" = no && \\\n\t  func_fatal_help \"libtool library \\`$output' must begin with \\`lib'\"\n\n\tif test \"$need_lib_prefix\" != no; then\n\t  # Add the \"lib\" prefix for modules if required\n\t  func_stripname '' '.la' \"$outputname\"\n\t  name=$func_stripname_result\n\t  eval shared_ext=\\\"$shrext_cmds\\\"\n\t  eval libname=\\\"$libname_spec\\\"\n\telse\n\t  func_stripname '' '.la' \"$outputname\"\n\t  libname=$func_stripname_result\n\tfi\n\t;;\n      esac\n\n      if test -n \"$objs\"; then\n\tif test \"$deplibs_check_method\" != pass_all; then\n\t  func_fatal_error \"cannot build libtool library \\`$output' from non-libtool objects on this host:$objs\"\n\telse\n\t  $ECHO\n\t  $ECHO \"*** Warning: Linking the shared library $output against the non-libtool\"\n\t  $ECHO \"*** objects $objs is not portable!\"\n\t  libobjs=\"$libobjs $objs\"\n\tfi\n      fi\n\n      test \"$dlself\" != no && \\\n\tfunc_warning \"\\`-dlopen self' is ignored for libtool libraries\"\n\n      set dummy $rpath\n      shift\n      test \"$#\" -gt 1 && \\\n\tfunc_warning \"ignoring multiple \\`-rpath's for a libtool library\"\n\n      install_libdir=\"$1\"\n\n      oldlibs=\n      if test -z \"$rpath\"; then\n\tif test \"$build_libtool_libs\" = yes; then\n\t  # Building a libtool convenience library.\n\t  # Some compilers have problems with a `.al' extension so\n\t  # convenience libraries should have the same extension an\n\t  # archive normally would.\n\t  oldlibs=\"$output_objdir/$libname.$libext $oldlibs\"\n\t  build_libtool_libs=convenience\n\t  build_old_libs=yes\n\tfi\n\n\ttest -n \"$vinfo\" && \\\n\t  func_warning \"\\`-version-info/-version-number' is ignored for convenience libraries\"\n\n\ttest -n \"$release\" && \\\n\t  func_warning \"\\`-release' is ignored for convenience libraries\"\n      else\n\n\t# Parse the version information argument.\n\tsave_ifs=\"$IFS\"; IFS=':'\n\tset dummy $vinfo 0 0 0\n\tshift\n\tIFS=\"$save_ifs\"\n\n\ttest -n \"$7\" && \\\n\t  func_fatal_help \"too many parameters to \\`-version-info'\"\n\n\t# convert absolute version numbers to libtool ages\n\t# this retains compatibility with .la files and attempts\n\t# to make the code below a bit more comprehensible\n\n\tcase $vinfo_number in\n\tyes)\n\t  number_major=\"$1\"\n\t  number_minor=\"$2\"\n\t  number_revision=\"$3\"\n\t  #\n\t  # There are really only two kinds -- those that\n\t  # use the current revision as the major version\n\t  # and those that subtract age and use age as\n\t  # a minor version.  But, then there is irix\n\t  # which has an extra 1 added just for fun\n\t  #\n\t  case $version_type in\n\t  darwin|linux|osf|windows|none)\n\t    func_arith $number_major + $number_minor\n\t    current=$func_arith_result\n\t    age=\"$number_minor\"\n\t    revision=\"$number_revision\"\n\t    ;;\n\t  freebsd-aout|freebsd-elf|sunos)\n\t    current=\"$number_major\"\n\t    revision=\"$number_minor\"\n\t    age=\"0\"\n\t    ;;\n\t  irix|nonstopux)\n\t    func_arith $number_major + $number_minor\n\t    current=$func_arith_result\n\t    age=\"$number_minor\"\n\t    revision=\"$number_minor\"\n\t    lt_irix_increment=no\n\t    ;;\n\t  esac\n\t  ;;\n\tno)\n\t  current=\"$1\"\n\t  revision=\"$2\"\n\t  age=\"$3\"\n\t  ;;\n\tesac\n\n\t# Check that each of the things are valid numbers.\n\tcase $current in\n\t0|[1-9]|[1-9][0-9]|[1-9][0-9][0-9]|[1-9][0-9][0-9][0-9]|[1-9][0-9][0-9][0-9][0-9]) ;;\n\t*)\n\t  func_error \"CURRENT \\`$current' must be a nonnegative integer\"\n\t  func_fatal_error \"\\`$vinfo' is not valid version information\"\n\t  ;;\n\tesac\n\n\tcase $revision in\n\t0|[1-9]|[1-9][0-9]|[1-9][0-9][0-9]|[1-9][0-9][0-9][0-9]|[1-9][0-9][0-9][0-9][0-9]) ;;\n\t*)\n\t  func_error \"REVISION \\`$revision' must be a nonnegative integer\"\n\t  func_fatal_error \"\\`$vinfo' is not valid version information\"\n\t  ;;\n\tesac\n\n\tcase $age in\n\t0|[1-9]|[1-9][0-9]|[1-9][0-9][0-9]|[1-9][0-9][0-9][0-9]|[1-9][0-9][0-9][0-9][0-9]) ;;\n\t*)\n\t  func_error \"AGE \\`$age' must be a nonnegative integer\"\n\t  func_fatal_error \"\\`$vinfo' is not valid version information\"\n\t  ;;\n\tesac\n\n\tif test \"$age\" -gt \"$current\"; then\n\t  func_error \"AGE \\`$age' is greater than the current interface number \\`$current'\"\n\t  func_fatal_error \"\\`$vinfo' is not valid version information\"\n\tfi\n\n\t# Calculate the version variables.\n\tmajor=\n\tversuffix=\n\tverstring=\n\tcase $version_type in\n\tnone) ;;\n\n\tdarwin)\n\t  # Like Linux, but with the current version available in\n\t  # verstring for coding it into the library header\n\t  func_arith $current - $age\n\t  major=.$func_arith_result\n\t  versuffix=\"$major.$age.$revision\"\n\t  # Darwin ld doesn't like 0 for these options...\n\t  func_arith $current + 1\n\t  minor_current=$func_arith_result\n\t  xlcverstring=\"${wl}-compatibility_version ${wl}$minor_current ${wl}-current_version ${wl}$minor_current.$revision\"\n\t  verstring=\"-compatibility_version $minor_current -current_version $minor_current.$revision\"\n\t  ;;\n\n\tfreebsd-aout)\n\t  major=\".$current\"\n\t  versuffix=\".$current.$revision\";\n\t  ;;\n\n\tfreebsd-elf)\n\t  major=\".$current\"\n\t  versuffix=\".$current\"\n\t  ;;\n\n\tirix | nonstopux)\n\t  if test \"X$lt_irix_increment\" = \"Xno\"; then\n\t    func_arith $current - $age\n\t  else\n\t    func_arith $current - $age + 1\n\t  fi\n\t  major=$func_arith_result\n\n\t  case $version_type in\n\t    nonstopux) verstring_prefix=nonstopux ;;\n\t    *)         verstring_prefix=sgi ;;\n\t  esac\n\t  verstring=\"$verstring_prefix$major.$revision\"\n\n\t  # Add in all the interfaces that we are compatible with.\n\t  loop=$revision\n\t  while test \"$loop\" -ne 0; do\n\t    func_arith $revision - $loop\n\t    iface=$func_arith_result\n\t    func_arith $loop - 1\n\t    loop=$func_arith_result\n\t    verstring=\"$verstring_prefix$major.$iface:$verstring\"\n\t  done\n\n\t  # Before this point, $major must not contain `.'.\n\t  major=.$major\n\t  versuffix=\"$major.$revision\"\n\t  ;;\n\n\tlinux)\n\t  func_arith $current - $age\n\t  major=.$func_arith_result\n\t  versuffix=\"$major.$age.$revision\"\n\t  ;;\n\n\tosf)\n\t  func_arith $current - $age\n\t  major=.$func_arith_result\n\t  versuffix=\".$current.$age.$revision\"\n\t  verstring=\"$current.$age.$revision\"\n\n\t  # Add in all the interfaces that we are compatible with.\n\t  loop=$age\n\t  while test \"$loop\" -ne 0; do\n\t    func_arith $current - $loop\n\t    iface=$func_arith_result\n\t    func_arith $loop - 1\n\t    loop=$func_arith_result\n\t    verstring=\"$verstring:${iface}.0\"\n\t  done\n\n\t  # Make executables depend on our current version.\n\t  verstring=\"$verstring:${current}.0\"\n\t  ;;\n\n\tqnx)\n\t  major=\".$current\"\n\t  versuffix=\".$current\"\n\t  ;;\n\n\tsunos)\n\t  major=\".$current\"\n\t  versuffix=\".$current.$revision\"\n\t  ;;\n\n\twindows)\n\t  # Use '-' rather than '.', since we only want one\n\t  # extension on DOS 8.3 filesystems.\n\t  func_arith $current - $age\n\t  major=$func_arith_result\n\t  versuffix=\"-$major\"\n\t  ;;\n\n\t*)\n\t  func_fatal_configuration \"unknown library version type \\`$version_type'\"\n\t  ;;\n\tesac\n\n\t# Clear the version info if we defaulted, and they specified a release.\n\tif test -z \"$vinfo\" && test -n \"$release\"; then\n\t  major=\n\t  case $version_type in\n\t  darwin)\n\t    # we can't check for \"0.0\" in archive_cmds due to quoting\n\t    # problems, so we reset it completely\n\t    verstring=\n\t    ;;\n\t  *)\n\t    verstring=\"0.0\"\n\t    ;;\n\t  esac\n\t  if test \"$need_version\" = no; then\n\t    versuffix=\n\t  else\n\t    versuffix=\".0.0\"\n\t  fi\n\tfi\n\n\t# Remove version info from name if versioning should be avoided\n\tif test \"$avoid_version\" = yes && test \"$need_version\" = no; then\n\t  major=\n\t  versuffix=\n\t  verstring=\"\"\n\tfi\n\n\t# Check to see if the archive will have undefined symbols.\n\tif test \"$allow_undefined\" = yes; then\n\t  if test \"$allow_undefined_flag\" = unsupported; then\n\t    func_warning \"undefined symbols not allowed in $host shared libraries\"\n\t    build_libtool_libs=no\n\t    build_old_libs=yes\n\t  fi\n\telse\n\t  # Don't allow undefined symbols.\n\t  allow_undefined_flag=\"$no_undefined_flag\"\n\tfi\n\n      fi\n\n      func_generate_dlsyms \"$libname\" \"$libname\" \"yes\"\n      libobjs=\"$libobjs $symfileobj\"\n      test \"X$libobjs\" = \"X \" && libobjs=\n\n      if test \"$mode\" != relink; then\n\t# Remove our outputs, but don't remove object files since they\n\t# may have been created when compiling PIC objects.\n\tremovelist=\n\ttempremovelist=`$ECHO \"$output_objdir/*\"`\n\tfor p in $tempremovelist; do\n\t  case $p in\n\t    *.$objext | *.gcno)\n\t       ;;\n\t    $output_objdir/$outputname | $output_objdir/$libname.* | $output_objdir/${libname}${release}.*)\n\t       if test \"X$precious_files_regex\" != \"X\"; then\n\t\t if $ECHO \"$p\" | $EGREP -e \"$precious_files_regex\" >/dev/null 2>&1\n\t\t then\n\t\t   continue\n\t\t fi\n\t       fi\n\t       removelist=\"$removelist $p\"\n\t       ;;\n\t    *) ;;\n\t  esac\n\tdone\n\ttest -n \"$removelist\" && \\\n\t  func_show_eval \"${RM}r \\$removelist\"\n      fi\n\n      # Now set the variables for building old libraries.\n      if test \"$build_old_libs\" = yes && test \"$build_libtool_libs\" != convenience ; then\n\toldlibs=\"$oldlibs $output_objdir/$libname.$libext\"\n\n\t# Transform .lo files to .o files.\n\toldobjs=\"$objs \"`$ECHO \"X$libobjs\" | $SP2NL | $Xsed -e '/\\.'${libext}'$/d' -e \"$lo2o\" | $NL2SP`\n      fi\n\n      # Eliminate all temporary directories.\n      #for path in $notinst_path; do\n      #\tlib_search_path=`$ECHO \"X$lib_search_path \" | $Xsed -e \"s% $path % %g\"`\n      #\tdeplibs=`$ECHO \"X$deplibs \" | $Xsed -e \"s% -L$path % %g\"`\n      #\tdependency_libs=`$ECHO \"X$dependency_libs \" | $Xsed -e \"s% -L$path % %g\"`\n      #done\n\n      if test -n \"$xrpath\"; then\n\t# If the user specified any rpath flags, then add them.\n\ttemp_xrpath=\n\tfor libdir in $xrpath; do\n\t  temp_xrpath=\"$temp_xrpath -R$libdir\"\n\t  case \"$finalize_rpath \" in\n\t  *\" $libdir \"*) ;;\n\t  *) finalize_rpath=\"$finalize_rpath $libdir\" ;;\n\t  esac\n\tdone\n\tif test \"$hardcode_into_libs\" != yes || test \"$build_old_libs\" = yes; then\n\t  dependency_libs=\"$temp_xrpath $dependency_libs\"\n\tfi\n      fi\n\n      # Make sure dlfiles contains only unique files that won't be dlpreopened\n      old_dlfiles=\"$dlfiles\"\n      dlfiles=\n      for lib in $old_dlfiles; do\n\tcase \" $dlprefiles $dlfiles \" in\n\t*\" $lib \"*) ;;\n\t*) dlfiles=\"$dlfiles $lib\" ;;\n\tesac\n      done\n\n      # Make sure dlprefiles contains only unique files\n      old_dlprefiles=\"$dlprefiles\"\n      dlprefiles=\n      for lib in $old_dlprefiles; do\n\tcase \"$dlprefiles \" in\n\t*\" $lib \"*) ;;\n\t*) dlprefiles=\"$dlprefiles $lib\" ;;\n\tesac\n      done\n\n      if test \"$build_libtool_libs\" = yes; then\n\tif test -n \"$rpath\"; then\n\t  case $host in\n\t  *-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-*-beos* | *-cegcc*)\n\t    # these systems don't actually have a c library (as such)!\n\t    ;;\n\t  *-*-rhapsody* | *-*-darwin1.[012])\n\t    # Rhapsody C library is in the System framework\n\t    deplibs=\"$deplibs System.ltframework\"\n\t    ;;\n\t  *-*-netbsd*)\n\t    # Don't link with libc until the a.out ld.so is fixed.\n\t    ;;\n\t  *-*-openbsd* | *-*-freebsd* | *-*-dragonfly*)\n\t    # Do not include libc due to us having libc/libc_r.\n\t    ;;\n\t  *-*-sco3.2v5* | *-*-sco5v6*)\n\t    # Causes problems with __ctype\n\t    ;;\n\t  *-*-sysv4.2uw2* | *-*-sysv5* | *-*-unixware* | *-*-OpenUNIX*)\n\t    # Compiler inserts libc in the correct place for threads to work\n\t    ;;\n\t  *)\n\t    # Add libc to deplibs on all other systems if necessary.\n\t    if test \"$build_libtool_need_lc\" = \"yes\"; then\n\t      deplibs=\"$deplibs -lc\"\n\t    fi\n\t    ;;\n\t  esac\n\tfi\n\n\t# Transform deplibs into only deplibs that can be linked in shared.\n\tname_save=$name\n\tlibname_save=$libname\n\trelease_save=$release\n\tversuffix_save=$versuffix\n\tmajor_save=$major\n\t# I'm not sure if I'm treating the release correctly.  I think\n\t# release should show up in the -l (ie -lgmp5) so we don't want to\n\t# add it in twice.  Is that correct?\n\trelease=\"\"\n\tversuffix=\"\"\n\tmajor=\"\"\n\tnewdeplibs=\n\tdroppeddeps=no\n\tcase $deplibs_check_method in\n\tpass_all)\n\t  # Don't check for shared/static.  Everything works.\n\t  # This might be a little naive.  We might want to check\n\t  # whether the library exists or not.  But this is on\n\t  # osf3 & osf4 and I'm not really sure... Just\n\t  # implementing what was already the behavior.\n\t  newdeplibs=$deplibs\n\t  ;;\n\ttest_compile)\n\t  # This code stresses the \"libraries are programs\" paradigm to its\n\t  # limits. Maybe even breaks it.  We compile a program, linking it\n\t  # against the deplibs as a proxy for the library.  Then we can check\n\t  # whether they linked in statically or dynamically with ldd.\n\t  $opt_dry_run || $RM conftest.c\n\t  cat > conftest.c <<EOF\n\t  int main() { return 0; }\nEOF\n\t  $opt_dry_run || $RM conftest\n\t  if $LTCC $LTCFLAGS -o conftest conftest.c $deplibs; then\n\t    ldd_output=`ldd conftest`\n\t    for i in $deplibs; do\n\t      case $i in\n\t      -l*)\n\t\tfunc_stripname -l '' \"$i\"\n\t\tname=$func_stripname_result\n\t\tif test \"X$allow_libtool_libs_with_static_runtimes\" = \"Xyes\" ; then\n\t\t  case \" $predeps $postdeps \" in\n\t\t  *\" $i \"*)\n\t\t    newdeplibs=\"$newdeplibs $i\"\n\t\t    i=\"\"\n\t\t    ;;\n\t\t  esac\n\t\tfi\n\t\tif test -n \"$i\" ; then\n\t\t  libname=`eval \"\\\\$ECHO \\\"$libname_spec\\\"\"`\n\t\t  deplib_matches=`eval \"\\\\$ECHO \\\"$library_names_spec\\\"\"`\n\t\t  set dummy $deplib_matches; shift\n\t\t  deplib_match=$1\n\t\t  if test `expr \"$ldd_output\" : \".*$deplib_match\"` -ne 0 ; then\n\t\t    newdeplibs=\"$newdeplibs $i\"\n\t\t  else\n\t\t    droppeddeps=yes\n\t\t    $ECHO\n\t\t    $ECHO \"*** Warning: dynamic linker does not accept needed library $i.\"\n\t\t    $ECHO \"*** I have the capability to make that library automatically link in when\"\n\t\t    $ECHO \"*** you link to this library.  But I can only do this if you have a\"\n\t\t    $ECHO \"*** shared version of the library, which I believe you do not have\"\n\t\t    $ECHO \"*** because a test_compile did reveal that the linker did not use it for\"\n\t\t    $ECHO \"*** its dynamic dependency list that programs get resolved with at runtime.\"\n\t\t  fi\n\t\tfi\n\t\t;;\n\t      *)\n\t\tnewdeplibs=\"$newdeplibs $i\"\n\t\t;;\n\t      esac\n\t    done\n\t  else\n\t    # Error occurred in the first compile.  Let's try to salvage\n\t    # the situation: Compile a separate program for each library.\n\t    for i in $deplibs; do\n\t      case $i in\n\t      -l*)\n\t\tfunc_stripname -l '' \"$i\"\n\t\tname=$func_stripname_result\n\t\t$opt_dry_run || $RM conftest\n\t\tif $LTCC $LTCFLAGS -o conftest conftest.c $i; then\n\t\t  ldd_output=`ldd conftest`\n\t\t  if test \"X$allow_libtool_libs_with_static_runtimes\" = \"Xyes\" ; then\n\t\t    case \" $predeps $postdeps \" in\n\t\t    *\" $i \"*)\n\t\t      newdeplibs=\"$newdeplibs $i\"\n\t\t      i=\"\"\n\t\t      ;;\n\t\t    esac\n\t\t  fi\n\t\t  if test -n \"$i\" ; then\n\t\t    libname=`eval \"\\\\$ECHO \\\"$libname_spec\\\"\"`\n\t\t    deplib_matches=`eval \"\\\\$ECHO \\\"$library_names_spec\\\"\"`\n\t\t    set dummy $deplib_matches; shift\n\t\t    deplib_match=$1\n\t\t    if test `expr \"$ldd_output\" : \".*$deplib_match\"` -ne 0 ; then\n\t\t      newdeplibs=\"$newdeplibs $i\"\n\t\t    else\n\t\t      droppeddeps=yes\n\t\t      $ECHO\n\t\t      $ECHO \"*** Warning: dynamic linker does not accept needed library $i.\"\n\t\t      $ECHO \"*** I have the capability to make that library automatically link in when\"\n\t\t      $ECHO \"*** you link to this library.  But I can only do this if you have a\"\n\t\t      $ECHO \"*** shared version of the library, which you do not appear to have\"\n\t\t      $ECHO \"*** because a test_compile did reveal that the linker did not use this one\"\n\t\t      $ECHO \"*** as a dynamic dependency that programs can get resolved with at runtime.\"\n\t\t    fi\n\t\t  fi\n\t\telse\n\t\t  droppeddeps=yes\n\t\t  $ECHO\n\t\t  $ECHO \"*** Warning!  Library $i is needed by this library but I was not able to\"\n\t\t  $ECHO \"*** make it link in!  You will probably need to install it or some\"\n\t\t  $ECHO \"*** library that it depends on before this library will be fully\"\n\t\t  $ECHO \"*** functional.  Installing it before continuing would be even better.\"\n\t\tfi\n\t\t;;\n\t      *)\n\t\tnewdeplibs=\"$newdeplibs $i\"\n\t\t;;\n\t      esac\n\t    done\n\t  fi\n\t  ;;\n\tfile_magic*)\n\t  set dummy $deplibs_check_method; shift\n\t  file_magic_regex=`expr \"$deplibs_check_method\" : \"$1 \\(.*\\)\"`\n\t  for a_deplib in $deplibs; do\n\t    case $a_deplib in\n\t    -l*)\n\t      func_stripname -l '' \"$a_deplib\"\n\t      name=$func_stripname_result\n\t      if test \"X$allow_libtool_libs_with_static_runtimes\" = \"Xyes\" ; then\n\t\tcase \" $predeps $postdeps \" in\n\t\t*\" $a_deplib \"*)\n\t\t  newdeplibs=\"$newdeplibs $a_deplib\"\n\t\t  a_deplib=\"\"\n\t\t  ;;\n\t\tesac\n\t      fi\n\t      if test -n \"$a_deplib\" ; then\n\t\tlibname=`eval \"\\\\$ECHO \\\"$libname_spec\\\"\"`\n\t\tfor i in $lib_search_path $sys_lib_search_path $shlib_search_path; do\n\t\t  potential_libs=`ls $i/$libname[.-]* 2>/dev/null`\n\t\t  for potent_lib in $potential_libs; do\n\t\t      # Follow soft links.\n\t\t      if ls -lLd \"$potent_lib\" 2>/dev/null |\n\t\t\t $GREP \" -> \" >/dev/null; then\n\t\t\tcontinue\n\t\t      fi\n\t\t      # The statement above tries to avoid entering an\n\t\t      # endless loop below, in case of cyclic links.\n\t\t      # We might still enter an endless loop, since a link\n\t\t      # loop can be closed while we follow links,\n\t\t      # but so what?\n\t\t      potlib=\"$potent_lib\"\n\t\t      while test -h \"$potlib\" 2>/dev/null; do\n\t\t\tpotliblink=`ls -ld $potlib | ${SED} 's/.* -> //'`\n\t\t\tcase $potliblink in\n\t\t\t[\\\\/]* | [A-Za-z]:[\\\\/]*) potlib=\"$potliblink\";;\n\t\t\t*) potlib=`$ECHO \"X$potlib\" | $Xsed -e 's,[^/]*$,,'`\"$potliblink\";;\n\t\t\tesac\n\t\t      done\n\t\t      if eval $file_magic_cmd \\\"\\$potlib\\\" 2>/dev/null |\n\t\t\t $SED -e 10q |\n\t\t\t $EGREP \"$file_magic_regex\" > /dev/null; then\n\t\t\tnewdeplibs=\"$newdeplibs $a_deplib\"\n\t\t\ta_deplib=\"\"\n\t\t\tbreak 2\n\t\t      fi\n\t\t  done\n\t\tdone\n\t      fi\n\t      if test -n \"$a_deplib\" ; then\n\t\tdroppeddeps=yes\n\t\t$ECHO\n\t\t$ECHO \"*** Warning: linker path does not have real file for library $a_deplib.\"\n\t\t$ECHO \"*** I have the capability to make that library automatically link in when\"\n\t\t$ECHO \"*** you link to this library.  But I can only do this if you have a\"\n\t\t$ECHO \"*** shared version of the library, which you do not appear to have\"\n\t\t$ECHO \"*** because I did check the linker path looking for a file starting\"\n\t\tif test -z \"$potlib\" ; then\n\t\t  $ECHO \"*** with $libname but no candidates were found. (...for file magic test)\"\n\t\telse\n\t\t  $ECHO \"*** with $libname and none of the candidates passed a file format test\"\n\t\t  $ECHO \"*** using a file magic. Last file checked: $potlib\"\n\t\tfi\n\t      fi\n\t      ;;\n\t    *)\n\t      # Add a -L argument.\n\t      newdeplibs=\"$newdeplibs $a_deplib\"\n\t      ;;\n\t    esac\n\t  done # Gone through all deplibs.\n\t  ;;\n\tmatch_pattern*)\n\t  set dummy $deplibs_check_method; shift\n\t  match_pattern_regex=`expr \"$deplibs_check_method\" : \"$1 \\(.*\\)\"`\n\t  for a_deplib in $deplibs; do\n\t    case $a_deplib in\n\t    -l*)\n\t      func_stripname -l '' \"$a_deplib\"\n\t      name=$func_stripname_result\n\t      if test \"X$allow_libtool_libs_with_static_runtimes\" = \"Xyes\" ; then\n\t\tcase \" $predeps $postdeps \" in\n\t\t*\" $a_deplib \"*)\n\t\t  newdeplibs=\"$newdeplibs $a_deplib\"\n\t\t  a_deplib=\"\"\n\t\t  ;;\n\t\tesac\n\t      fi\n\t      if test -n \"$a_deplib\" ; then\n\t\tlibname=`eval \"\\\\$ECHO \\\"$libname_spec\\\"\"`\n\t\tfor i in $lib_search_path $sys_lib_search_path $shlib_search_path; do\n\t\t  potential_libs=`ls $i/$libname[.-]* 2>/dev/null`\n\t\t  for potent_lib in $potential_libs; do\n\t\t    potlib=\"$potent_lib\" # see symlink-check above in file_magic test\n\t\t    if eval \"\\$ECHO \\\"X$potent_lib\\\"\" 2>/dev/null | $Xsed -e 10q | \\\n\t\t       $EGREP \"$match_pattern_regex\" > /dev/null; then\n\t\t      newdeplibs=\"$newdeplibs $a_deplib\"\n\t\t      a_deplib=\"\"\n\t\t      break 2\n\t\t    fi\n\t\t  done\n\t\tdone\n\t      fi\n\t      if test -n \"$a_deplib\" ; then\n\t\tdroppeddeps=yes\n\t\t$ECHO\n\t\t$ECHO \"*** Warning: linker path does not have real file for library $a_deplib.\"\n\t\t$ECHO \"*** I have the capability to make that library automatically link in when\"\n\t\t$ECHO \"*** you link to this library.  But I can only do this if you have a\"\n\t\t$ECHO \"*** shared version of the library, which you do not appear to have\"\n\t\t$ECHO \"*** because I did check the linker path looking for a file starting\"\n\t\tif test -z \"$potlib\" ; then\n\t\t  $ECHO \"*** with $libname but no candidates were found. (...for regex pattern test)\"\n\t\telse\n\t\t  $ECHO \"*** with $libname and none of the candidates passed a file format test\"\n\t\t  $ECHO \"*** using a regex pattern. Last file checked: $potlib\"\n\t\tfi\n\t      fi\n\t      ;;\n\t    *)\n\t      # Add a -L argument.\n\t      newdeplibs=\"$newdeplibs $a_deplib\"\n\t      ;;\n\t    esac\n\t  done # Gone through all deplibs.\n\t  ;;\n\tnone | unknown | *)\n\t  newdeplibs=\"\"\n\t  tmp_deplibs=`$ECHO \"X $deplibs\" | $Xsed \\\n\t      -e 's/ -lc$//' -e 's/ -[LR][^ ]*//g'`\n\t  if test \"X$allow_libtool_libs_with_static_runtimes\" = \"Xyes\" ; then\n\t    for i in $predeps $postdeps ; do\n\t      # can't use Xsed below, because $i might contain '/'\n\t      tmp_deplibs=`$ECHO \"X $tmp_deplibs\" | $Xsed -e \"s,$i,,\"`\n\t    done\n\t  fi\n\t  if $ECHO \"X $tmp_deplibs\" | $Xsed -e 's/[\t ]//g' |\n\t     $GREP . >/dev/null; then\n\t    $ECHO\n\t    if test \"X$deplibs_check_method\" = \"Xnone\"; then\n\t      $ECHO \"*** Warning: inter-library dependencies are not supported in this platform.\"\n\t    else\n\t      $ECHO \"*** Warning: inter-library dependencies are not known to be supported.\"\n\t    fi\n\t    $ECHO \"*** All declared inter-library dependencies are being dropped.\"\n\t    droppeddeps=yes\n\t  fi\n\t  ;;\n\tesac\n\tversuffix=$versuffix_save\n\tmajor=$major_save\n\trelease=$release_save\n\tlibname=$libname_save\n\tname=$name_save\n\n\tcase $host in\n\t*-*-rhapsody* | *-*-darwin1.[012])\n\t  # On Rhapsody replace the C library with the System framework\n\t  newdeplibs=`$ECHO \"X $newdeplibs\" | $Xsed -e 's/ -lc / System.ltframework /'`\n\t  ;;\n\tesac\n\n\tif test \"$droppeddeps\" = yes; then\n\t  if test \"$module\" = yes; then\n\t    $ECHO\n\t    $ECHO \"*** Warning: libtool could not satisfy all declared inter-library\"\n\t    $ECHO \"*** dependencies of module $libname.  Therefore, libtool will create\"\n\t    $ECHO \"*** a static module, that should work as long as the dlopening\"\n\t    $ECHO \"*** application is linked with the -dlopen flag.\"\n\t    if test -z \"$global_symbol_pipe\"; then\n\t      $ECHO\n\t      $ECHO \"*** However, this would only work if libtool was able to extract symbol\"\n\t      $ECHO \"*** lists from a program, using \\`nm' or equivalent, but libtool could\"\n\t      $ECHO \"*** not find such a program.  So, this module is probably useless.\"\n\t      $ECHO \"*** \\`nm' from GNU binutils and a full rebuild may help.\"\n\t    fi\n\t    if test \"$build_old_libs\" = no; then\n\t      oldlibs=\"$output_objdir/$libname.$libext\"\n\t      build_libtool_libs=module\n\t      build_old_libs=yes\n\t    else\n\t      build_libtool_libs=no\n\t    fi\n\t  else\n\t    $ECHO \"*** The inter-library dependencies that have been dropped here will be\"\n\t    $ECHO \"*** automatically added whenever a program is linked with this library\"\n\t    $ECHO \"*** or is declared to -dlopen it.\"\n\n\t    if test \"$allow_undefined\" = no; then\n\t      $ECHO\n\t      $ECHO \"*** Since this library must not contain undefined symbols,\"\n\t      $ECHO \"*** because either the platform does not support them or\"\n\t      $ECHO \"*** it was explicitly requested with -no-undefined,\"\n\t      $ECHO \"*** libtool will only create a static version of it.\"\n\t      if test \"$build_old_libs\" = no; then\n\t\toldlibs=\"$output_objdir/$libname.$libext\"\n\t\tbuild_libtool_libs=module\n\t\tbuild_old_libs=yes\n\t      else\n\t\tbuild_libtool_libs=no\n\t      fi\n\t    fi\n\t  fi\n\tfi\n\t# Done checking deplibs!\n\tdeplibs=$newdeplibs\n      fi\n      # Time to change all our \"foo.ltframework\" stuff back to \"-framework foo\"\n      case $host in\n\t*-*-darwin*)\n\t  newdeplibs=`$ECHO \"X $newdeplibs\" | $Xsed -e 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\t  new_inherited_linker_flags=`$ECHO \"X $new_inherited_linker_flags\" | $Xsed -e 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\t  deplibs=`$ECHO \"X $deplibs\" | $Xsed -e 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\t  ;;\n      esac\n\n      # move library search paths that coincide with paths to not yet\n      # installed libraries to the beginning of the library search list\n      new_libs=\n      for path in $notinst_path; do\n\tcase \" $new_libs \" in\n\t*\" -L$path/$objdir \"*) ;;\n\t*)\n\t  case \" $deplibs \" in\n\t  *\" -L$path/$objdir \"*)\n\t    new_libs=\"$new_libs -L$path/$objdir\" ;;\n\t  esac\n\t  ;;\n\tesac\n      done\n      for deplib in $deplibs; do\n\tcase $deplib in\n\t-L*)\n\t  case \" $new_libs \" in\n\t  *\" $deplib \"*) ;;\n\t  *) new_libs=\"$new_libs $deplib\" ;;\n\t  esac\n\t  ;;\n\t*) new_libs=\"$new_libs $deplib\" ;;\n\tesac\n      done\n      deplibs=\"$new_libs\"\n\n      # All the library-specific variables (install_libdir is set above).\n      library_names=\n      old_library=\n      dlname=\n\n      # Test again, we may have decided not to build it any more\n      if test \"$build_libtool_libs\" = yes; then\n\tif test \"$hardcode_into_libs\" = yes; then\n\t  # Hardcode the library paths\n\t  hardcode_libdirs=\n\t  dep_rpath=\n\t  rpath=\"$finalize_rpath\"\n\t  test \"$mode\" != relink && rpath=\"$compile_rpath$rpath\"\n\t  for libdir in $rpath; do\n\t    if test -n \"$hardcode_libdir_flag_spec\"; then\n\t      if test -n \"$hardcode_libdir_separator\"; then\n\t\tif test -z \"$hardcode_libdirs\"; then\n\t\t  hardcode_libdirs=\"$libdir\"\n\t\telse\n\t\t  # Just accumulate the unique libdirs.\n\t\t  case $hardcode_libdir_separator$hardcode_libdirs$hardcode_libdir_separator in\n\t\t  *\"$hardcode_libdir_separator$libdir$hardcode_libdir_separator\"*)\n\t\t    ;;\n\t\t  *)\n\t\t    hardcode_libdirs=\"$hardcode_libdirs$hardcode_libdir_separator$libdir\"\n\t\t    ;;\n\t\t  esac\n\t\tfi\n\t      else\n\t\teval flag=\\\"$hardcode_libdir_flag_spec\\\"\n\t\tdep_rpath=\"$dep_rpath $flag\"\n\t      fi\n\t    elif test -n \"$runpath_var\"; then\n\t      case \"$perm_rpath \" in\n\t      *\" $libdir \"*) ;;\n\t      *) perm_rpath=\"$perm_rpath $libdir\" ;;\n\t      esac\n\t    fi\n\t  done\n\t  # Substitute the hardcoded libdirs into the rpath.\n\t  if test -n \"$hardcode_libdir_separator\" &&\n\t     test -n \"$hardcode_libdirs\"; then\n\t    libdir=\"$hardcode_libdirs\"\n\t    if test -n \"$hardcode_libdir_flag_spec_ld\"; then\n\t      eval dep_rpath=\\\"$hardcode_libdir_flag_spec_ld\\\"\n\t    else\n\t      eval dep_rpath=\\\"$hardcode_libdir_flag_spec\\\"\n\t    fi\n\t  fi\n\t  if test -n \"$runpath_var\" && test -n \"$perm_rpath\"; then\n\t    # We should set the runpath_var.\n\t    rpath=\n\t    for dir in $perm_rpath; do\n\t      rpath=\"$rpath$dir:\"\n\t    done\n\t    eval \"$runpath_var='$rpath\\$$runpath_var'; export $runpath_var\"\n\t  fi\n\t  test -n \"$dep_rpath\" && deplibs=\"$dep_rpath $deplibs\"\n\tfi\n\n\tshlibpath=\"$finalize_shlibpath\"\n\ttest \"$mode\" != relink && shlibpath=\"$compile_shlibpath$shlibpath\"\n\tif test -n \"$shlibpath\"; then\n\t  eval \"$shlibpath_var='$shlibpath\\$$shlibpath_var'; export $shlibpath_var\"\n\tfi\n\n\t# Get the real and link names of the library.\n\teval shared_ext=\\\"$shrext_cmds\\\"\n\teval library_names=\\\"$library_names_spec\\\"\n\tset dummy $library_names\n\tshift\n\trealname=\"$1\"\n\tshift\n\n\tif test -n \"$soname_spec\"; then\n\t  eval soname=\\\"$soname_spec\\\"\n\telse\n\t  soname=\"$realname\"\n\tfi\n\tif test -z \"$dlname\"; then\n\t  dlname=$soname\n\tfi\n\n\tlib=\"$output_objdir/$realname\"\n\tlinknames=\n\tfor link\n\tdo\n\t  linknames=\"$linknames $link\"\n\tdone\n\n\t# Use standard objects if they are pic\n\ttest -z \"$pic_flag\" && libobjs=`$ECHO \"X$libobjs\" | $SP2NL | $Xsed -e \"$lo2o\" | $NL2SP`\n\ttest \"X$libobjs\" = \"X \" && libobjs=\n\n\tdelfiles=\n\tif test -n \"$export_symbols\" && test -n \"$include_expsyms\"; then\n\t  $opt_dry_run || cp \"$export_symbols\" \"$output_objdir/$libname.uexp\"\n\t  export_symbols=\"$output_objdir/$libname.uexp\"\n\t  delfiles=\"$delfiles $export_symbols\"\n\tfi\n\n\torig_export_symbols=\n\tcase $host_os in\n\tcygwin* | mingw* | cegcc*)\n\t  if test -n \"$export_symbols\" && test -z \"$export_symbols_regex\"; then\n\t    # exporting using user supplied symfile\n\t    if test \"x`$SED 1q $export_symbols`\" != xEXPORTS; then\n\t      # and it's NOT already a .def file. Must figure out\n\t      # which of the given symbols are data symbols and tag\n\t      # them as such. So, trigger use of export_symbols_cmds.\n\t      # export_symbols gets reassigned inside the \"prepare\n\t      # the list of exported symbols\" if statement, so the\n\t      # include_expsyms logic still works.\n\t      orig_export_symbols=\"$export_symbols\"\n\t      export_symbols=\n\t      always_export_symbols=yes\n\t    fi\n\t  fi\n\t  ;;\n\tesac\n\n\t# Prepare the list of exported symbols\n\tif test -z \"$export_symbols\"; then\n\t  if test \"$always_export_symbols\" = yes || test -n \"$export_symbols_regex\"; then\n\t    func_verbose \"generating symbol list for \\`$libname.la'\"\n\t    export_symbols=\"$output_objdir/$libname.exp\"\n\t    $opt_dry_run || $RM $export_symbols\n\t    cmds=$export_symbols_cmds\n\t    save_ifs=\"$IFS\"; IFS='~'\n\t    for cmd in $cmds; do\n\t      IFS=\"$save_ifs\"\n\t      eval cmd=\\\"$cmd\\\"\n\t      func_len \" $cmd\"\n\t      len=$func_len_result\n\t      if test \"$len\" -lt \"$max_cmd_len\" || test \"$max_cmd_len\" -le -1; then\n\t\tfunc_show_eval \"$cmd\" 'exit $?'\n\t\tskipped_export=false\n\t      else\n\t\t# The command line is too long to execute in one step.\n\t\tfunc_verbose \"using reloadable object file for export list...\"\n\t\tskipped_export=:\n\t\t# Break out early, otherwise skipped_export may be\n\t\t# set to false by a later but shorter cmd.\n\t\tbreak\n\t      fi\n\t    done\n\t    IFS=\"$save_ifs\"\n\t    if test -n \"$export_symbols_regex\" && test \"X$skipped_export\" != \"X:\"; then\n\t      func_show_eval '$EGREP -e \"$export_symbols_regex\" \"$export_symbols\" > \"${export_symbols}T\"'\n\t      func_show_eval '$MV \"${export_symbols}T\" \"$export_symbols\"'\n\t    fi\n\t  fi\n\tfi\n\n\tif test -n \"$export_symbols\" && test -n \"$include_expsyms\"; then\n\t  tmp_export_symbols=\"$export_symbols\"\n\t  test -n \"$orig_export_symbols\" && tmp_export_symbols=\"$orig_export_symbols\"\n\t  $opt_dry_run || eval '$ECHO \"X$include_expsyms\" | $Xsed | $SP2NL >> \"$tmp_export_symbols\"'\n\tfi\n\n\tif test \"X$skipped_export\" != \"X:\" && test -n \"$orig_export_symbols\"; then\n\t  # The given exports_symbols file has to be filtered, so filter it.\n\t  func_verbose \"filter symbol list for \\`$libname.la' to tag DATA exports\"\n\t  # FIXME: $output_objdir/$libname.filter potentially contains lots of\n\t  # 's' commands which not all seds can handle. GNU sed should be fine\n\t  # though. Also, the filter scales superlinearly with the number of\n\t  # global variables. join(1) would be nice here, but unfortunately\n\t  # isn't a blessed tool.\n\t  $opt_dry_run || $SED -e '/[ ,]DATA/!d;s,\\(.*\\)\\([ \\,].*\\),s|^\\1$|\\1\\2|,' < $export_symbols > $output_objdir/$libname.filter\n\t  delfiles=\"$delfiles $export_symbols $output_objdir/$libname.filter\"\n\t  export_symbols=$output_objdir/$libname.def\n\t  $opt_dry_run || $SED -f $output_objdir/$libname.filter < $orig_export_symbols > $export_symbols\n\tfi\n\n\ttmp_deplibs=\n\tfor test_deplib in $deplibs; do\n\t  case \" $convenience \" in\n\t  *\" $test_deplib \"*) ;;\n\t  *)\n\t    tmp_deplibs=\"$tmp_deplibs $test_deplib\"\n\t    ;;\n\t  esac\n\tdone\n\tdeplibs=\"$tmp_deplibs\"\n\n\tif test -n \"$convenience\"; then\n\t  if test -n \"$whole_archive_flag_spec\" &&\n\t    test \"$compiler_needs_object\" = yes &&\n\t    test -z \"$libobjs\"; then\n\t    # extract the archives, so we have objects to list.\n\t    # TODO: could optimize this to just extract one archive.\n\t    whole_archive_flag_spec=\n\t  fi\n\t  if test -n \"$whole_archive_flag_spec\"; then\n\t    save_libobjs=$libobjs\n\t    eval libobjs=\\\"\\$libobjs $whole_archive_flag_spec\\\"\n\t    test \"X$libobjs\" = \"X \" && libobjs=\n\t  else\n\t    gentop=\"$output_objdir/${outputname}x\"\n\t    generated=\"$generated $gentop\"\n\n\t    func_extract_archives $gentop $convenience\n\t    libobjs=\"$libobjs $func_extract_archives_result\"\n\t    test \"X$libobjs\" = \"X \" && libobjs=\n\t  fi\n\tfi\n\n\tif test \"$thread_safe\" = yes && test -n \"$thread_safe_flag_spec\"; then\n\t  eval flag=\\\"$thread_safe_flag_spec\\\"\n\t  linker_flags=\"$linker_flags $flag\"\n\tfi\n\n\t# Make a backup of the uninstalled library when relinking\n\tif test \"$mode\" = relink; then\n\t  $opt_dry_run || eval '(cd $output_objdir && $RM ${realname}U && $MV $realname ${realname}U)' || exit $?\n\tfi\n\n\t# Do each of the archive commands.\n\tif test \"$module\" = yes && test -n \"$module_cmds\" ; then\n\t  if test -n \"$export_symbols\" && test -n \"$module_expsym_cmds\"; then\n\t    eval test_cmds=\\\"$module_expsym_cmds\\\"\n\t    cmds=$module_expsym_cmds\n\t  else\n\t    eval test_cmds=\\\"$module_cmds\\\"\n\t    cmds=$module_cmds\n\t  fi\n\telse\n\t  if test -n \"$export_symbols\" && test -n \"$archive_expsym_cmds\"; then\n\t    eval test_cmds=\\\"$archive_expsym_cmds\\\"\n\t    cmds=$archive_expsym_cmds\n\t  else\n\t    eval test_cmds=\\\"$archive_cmds\\\"\n\t    cmds=$archive_cmds\n\t  fi\n\tfi\n\n\tif test \"X$skipped_export\" != \"X:\" &&\n\t   func_len \" $test_cmds\" &&\n\t   len=$func_len_result &&\n\t   test \"$len\" -lt \"$max_cmd_len\" || test \"$max_cmd_len\" -le -1; then\n\t  :\n\telse\n\t  # The command line is too long to link in one step, link piecewise\n\t  # or, if using GNU ld and skipped_export is not :, use a linker\n\t  # script.\n\n\t  # Save the value of $output and $libobjs because we want to\n\t  # use them later.  If we have whole_archive_flag_spec, we\n\t  # want to use save_libobjs as it was before\n\t  # whole_archive_flag_spec was expanded, because we can't\n\t  # assume the linker understands whole_archive_flag_spec.\n\t  # This may have to be revisited, in case too many\n\t  # convenience libraries get linked in and end up exceeding\n\t  # the spec.\n\t  if test -z \"$convenience\" || test -z \"$whole_archive_flag_spec\"; then\n\t    save_libobjs=$libobjs\n\t  fi\n\t  save_output=$output\n\t  output_la=`$ECHO \"X$output\" | $Xsed -e \"$basename\"`\n\n\t  # Clear the reloadable object creation command queue and\n\t  # initialize k to one.\n\t  test_cmds=\n\t  concat_cmds=\n\t  objlist=\n\t  last_robj=\n\t  k=1\n\n\t  if test -n \"$save_libobjs\" && test \"X$skipped_export\" != \"X:\" && test \"$with_gnu_ld\" = yes; then\n\t    output=${output_objdir}/${output_la}.lnkscript\n\t    func_verbose \"creating GNU ld script: $output\"\n\t    $ECHO 'INPUT (' > $output\n\t    for obj in $save_libobjs\n\t    do\n\t      $ECHO \"$obj\" >> $output\n\t    done\n\t    $ECHO ')' >> $output\n\t    delfiles=\"$delfiles $output\"\n\t  elif test -n \"$save_libobjs\" && test \"X$skipped_export\" != \"X:\" && test \"X$file_list_spec\" != X; then\n\t    output=${output_objdir}/${output_la}.lnk\n\t    func_verbose \"creating linker input file list: $output\"\n\t    : > $output\n\t    set x $save_libobjs\n\t    shift\n\t    firstobj=\n\t    if test \"$compiler_needs_object\" = yes; then\n\t      firstobj=\"$1 \"\n\t      shift\n\t    fi\n\t    for obj\n\t    do\n\t      $ECHO \"$obj\" >> $output\n\t    done\n\t    delfiles=\"$delfiles $output\"\n\t    output=$firstobj\\\"$file_list_spec$output\\\"\n\t  else\n\t    if test -n \"$save_libobjs\"; then\n\t      func_verbose \"creating reloadable object files...\"\n\t      output=$output_objdir/$output_la-${k}.$objext\n\t      eval test_cmds=\\\"$reload_cmds\\\"\n\t      func_len \" $test_cmds\"\n\t      len0=$func_len_result\n\t      len=$len0\n\n\t      # Loop over the list of objects to be linked.\n\t      for obj in $save_libobjs\n\t      do\n\t\tfunc_len \" $obj\"\n\t\tfunc_arith $len + $func_len_result\n\t\tlen=$func_arith_result\n\t\tif test \"X$objlist\" = X ||\n\t\t   test \"$len\" -lt \"$max_cmd_len\"; then\n\t\t  func_append objlist \" $obj\"\n\t\telse\n\t\t  # The command $test_cmds is almost too long, add a\n\t\t  # command to the queue.\n\t\t  if test \"$k\" -eq 1 ; then\n\t\t    # The first file doesn't have a previous command to add.\n\t\t    eval concat_cmds=\\\"$reload_cmds $objlist $last_robj\\\"\n\t\t  else\n\t\t    # All subsequent reloadable object files will link in\n\t\t    # the last one created.\n\t\t    eval concat_cmds=\\\"\\$concat_cmds~$reload_cmds $objlist $last_robj~\\$RM $last_robj\\\"\n\t\t  fi\n\t\t  last_robj=$output_objdir/$output_la-${k}.$objext\n\t\t  func_arith $k + 1\n\t\t  k=$func_arith_result\n\t\t  output=$output_objdir/$output_la-${k}.$objext\n\t\t  objlist=$obj\n\t\t  func_len \" $last_robj\"\n\t\t  func_arith $len0 + $func_len_result\n\t\t  len=$func_arith_result\n\t\tfi\n\t      done\n\t      # Handle the remaining objects by creating one last\n\t      # reloadable object file.  All subsequent reloadable object\n\t      # files will link in the last one created.\n\t      test -z \"$concat_cmds\" || concat_cmds=$concat_cmds~\n\t      eval concat_cmds=\\\"\\${concat_cmds}$reload_cmds $objlist $last_robj\\\"\n\t      if test -n \"$last_robj\"; then\n\t        eval concat_cmds=\\\"\\${concat_cmds}~\\$RM $last_robj\\\"\n\t      fi\n\t      delfiles=\"$delfiles $output\"\n\n\t    else\n\t      output=\n\t    fi\n\n\t    if ${skipped_export-false}; then\n\t      func_verbose \"generating symbol list for \\`$libname.la'\"\n\t      export_symbols=\"$output_objdir/$libname.exp\"\n\t      $opt_dry_run || $RM $export_symbols\n\t      libobjs=$output\n\t      # Append the command to create the export file.\n\t      test -z \"$concat_cmds\" || concat_cmds=$concat_cmds~\n\t      eval concat_cmds=\\\"\\$concat_cmds$export_symbols_cmds\\\"\n\t      if test -n \"$last_robj\"; then\n\t\teval concat_cmds=\\\"\\$concat_cmds~\\$RM $last_robj\\\"\n\t      fi\n\t    fi\n\n\t    test -n \"$save_libobjs\" &&\n\t      func_verbose \"creating a temporary reloadable object file: $output\"\n\n\t    # Loop through the commands generated above and execute them.\n\t    save_ifs=\"$IFS\"; IFS='~'\n\t    for cmd in $concat_cmds; do\n\t      IFS=\"$save_ifs\"\n\t      $opt_silent || {\n\t\t  func_quote_for_expand \"$cmd\"\n\t\t  eval \"func_echo $func_quote_for_expand_result\"\n\t      }\n\t      $opt_dry_run || eval \"$cmd\" || {\n\t\tlt_exit=$?\n\n\t\t# Restore the uninstalled library and exit\n\t\tif test \"$mode\" = relink; then\n\t\t  ( cd \"$output_objdir\" && \\\n\t\t    $RM \"${realname}T\" && \\\n\t\t    $MV \"${realname}U\" \"$realname\" )\n\t\tfi\n\n\t\texit $lt_exit\n\t      }\n\t    done\n\t    IFS=\"$save_ifs\"\n\n\t    if test -n \"$export_symbols_regex\" && ${skipped_export-false}; then\n\t      func_show_eval '$EGREP -e \"$export_symbols_regex\" \"$export_symbols\" > \"${export_symbols}T\"'\n\t      func_show_eval '$MV \"${export_symbols}T\" \"$export_symbols\"'\n\t    fi\n\t  fi\n\n          if ${skipped_export-false}; then\n\t    if test -n \"$export_symbols\" && test -n \"$include_expsyms\"; then\n\t      tmp_export_symbols=\"$export_symbols\"\n\t      test -n \"$orig_export_symbols\" && tmp_export_symbols=\"$orig_export_symbols\"\n\t      $opt_dry_run || eval '$ECHO \"X$include_expsyms\" | $Xsed | $SP2NL >> \"$tmp_export_symbols\"'\n\t    fi\n\n\t    if test -n \"$orig_export_symbols\"; then\n\t      # The given exports_symbols file has to be filtered, so filter it.\n\t      func_verbose \"filter symbol list for \\`$libname.la' to tag DATA exports\"\n\t      # FIXME: $output_objdir/$libname.filter potentially contains lots of\n\t      # 's' commands which not all seds can handle. GNU sed should be fine\n\t      # though. Also, the filter scales superlinearly with the number of\n\t      # global variables. join(1) would be nice here, but unfortunately\n\t      # isn't a blessed tool.\n\t      $opt_dry_run || $SED -e '/[ ,]DATA/!d;s,\\(.*\\)\\([ \\,].*\\),s|^\\1$|\\1\\2|,' < $export_symbols > $output_objdir/$libname.filter\n\t      delfiles=\"$delfiles $export_symbols $output_objdir/$libname.filter\"\n\t      export_symbols=$output_objdir/$libname.def\n\t      $opt_dry_run || $SED -f $output_objdir/$libname.filter < $orig_export_symbols > $export_symbols\n\t    fi\n\t  fi\n\n\t  libobjs=$output\n\t  # Restore the value of output.\n\t  output=$save_output\n\n\t  if test -n \"$convenience\" && test -n \"$whole_archive_flag_spec\"; then\n\t    eval libobjs=\\\"\\$libobjs $whole_archive_flag_spec\\\"\n\t    test \"X$libobjs\" = \"X \" && libobjs=\n\t  fi\n\t  # Expand the library linking commands again to reset the\n\t  # value of $libobjs for piecewise linking.\n\n\t  # Do each of the archive commands.\n\t  if test \"$module\" = yes && test -n \"$module_cmds\" ; then\n\t    if test -n \"$export_symbols\" && test -n \"$module_expsym_cmds\"; then\n\t      cmds=$module_expsym_cmds\n\t    else\n\t      cmds=$module_cmds\n\t    fi\n\t  else\n\t    if test -n \"$export_symbols\" && test -n \"$archive_expsym_cmds\"; then\n\t      cmds=$archive_expsym_cmds\n\t    else\n\t      cmds=$archive_cmds\n\t    fi\n\t  fi\n\tfi\n\n\tif test -n \"$delfiles\"; then\n\t  # Append the command to remove temporary files to $cmds.\n\t  eval cmds=\\\"\\$cmds~\\$RM $delfiles\\\"\n\tfi\n\n\t# Add any objects from preloaded convenience libraries\n\tif test -n \"$dlprefiles\"; then\n\t  gentop=\"$output_objdir/${outputname}x\"\n\t  generated=\"$generated $gentop\"\n\n\t  func_extract_archives $gentop $dlprefiles\n\t  libobjs=\"$libobjs $func_extract_archives_result\"\n\t  test \"X$libobjs\" = \"X \" && libobjs=\n\tfi\n\n\tsave_ifs=\"$IFS\"; IFS='~'\n\tfor cmd in $cmds; do\n\t  IFS=\"$save_ifs\"\n\t  eval cmd=\\\"$cmd\\\"\n\t  $opt_silent || {\n\t    func_quote_for_expand \"$cmd\"\n\t    eval \"func_echo $func_quote_for_expand_result\"\n\t  }\n\t  $opt_dry_run || eval \"$cmd\" || {\n\t    lt_exit=$?\n\n\t    # Restore the uninstalled library and exit\n\t    if test \"$mode\" = relink; then\n\t      ( cd \"$output_objdir\" && \\\n\t        $RM \"${realname}T\" && \\\n\t\t$MV \"${realname}U\" \"$realname\" )\n\t    fi\n\n\t    exit $lt_exit\n\t  }\n\tdone\n\tIFS=\"$save_ifs\"\n\n\t# Restore the uninstalled library and exit\n\tif test \"$mode\" = relink; then\n\t  $opt_dry_run || eval '(cd $output_objdir && $RM ${realname}T && $MV $realname ${realname}T && $MV ${realname}U $realname)' || exit $?\n\n\t  if test -n \"$convenience\"; then\n\t    if test -z \"$whole_archive_flag_spec\"; then\n\t      func_show_eval '${RM}r \"$gentop\"'\n\t    fi\n\t  fi\n\n\t  exit $EXIT_SUCCESS\n\tfi\n\n\t# Create links to the real library.\n\tfor linkname in $linknames; do\n\t  if test \"$realname\" != \"$linkname\"; then\n\t    func_show_eval '(cd \"$output_objdir\" && $RM \"$linkname\" && $LN_S \"$realname\" \"$linkname\")' 'exit $?'\n\t  fi\n\tdone\n\n\t# If -module or -export-dynamic was specified, set the dlname.\n\tif test \"$module\" = yes || test \"$export_dynamic\" = yes; then\n\t  # On all known operating systems, these are identical.\n\t  dlname=\"$soname\"\n\tfi\n      fi\n      ;;\n\n    obj)\n      if test -n \"$dlfiles$dlprefiles\" || test \"$dlself\" != no; then\n\tfunc_warning \"\\`-dlopen' is ignored for objects\"\n      fi\n\n      case \" $deplibs\" in\n      *\\ -l* | *\\ -L*)\n\tfunc_warning \"\\`-l' and \\`-L' are ignored for objects\" ;;\n      esac\n\n      test -n \"$rpath\" && \\\n\tfunc_warning \"\\`-rpath' is ignored for objects\"\n\n      test -n \"$xrpath\" && \\\n\tfunc_warning \"\\`-R' is ignored for objects\"\n\n      test -n \"$vinfo\" && \\\n\tfunc_warning \"\\`-version-info' is ignored for objects\"\n\n      test -n \"$release\" && \\\n\tfunc_warning \"\\`-release' is ignored for objects\"\n\n      case $output in\n      *.lo)\n\ttest -n \"$objs$old_deplibs\" && \\\n\t  func_fatal_error \"cannot build library object \\`$output' from non-libtool objects\"\n\n\tlibobj=$output\n\tfunc_lo2o \"$libobj\"\n\tobj=$func_lo2o_result\n\t;;\n      *)\n\tlibobj=\n\tobj=\"$output\"\n\t;;\n      esac\n\n      # Delete the old objects.\n      $opt_dry_run || $RM $obj $libobj\n\n      # Objects from convenience libraries.  This assumes\n      # single-version convenience libraries.  Whenever we create\n      # different ones for PIC/non-PIC, this we'll have to duplicate\n      # the extraction.\n      reload_conv_objs=\n      gentop=\n      # reload_cmds runs $LD directly, so let us get rid of\n      # -Wl from whole_archive_flag_spec and hope we can get by with\n      # turning comma into space..\n      wl=\n\n      if test -n \"$convenience\"; then\n\tif test -n \"$whole_archive_flag_spec\"; then\n\t  eval tmp_whole_archive_flags=\\\"$whole_archive_flag_spec\\\"\n\t  reload_conv_objs=$reload_objs\\ `$ECHO \"X$tmp_whole_archive_flags\" | $Xsed -e 's|,| |g'`\n\telse\n\t  gentop=\"$output_objdir/${obj}x\"\n\t  generated=\"$generated $gentop\"\n\n\t  func_extract_archives $gentop $convenience\n\t  reload_conv_objs=\"$reload_objs $func_extract_archives_result\"\n\tfi\n      fi\n\n      # Create the old-style object.\n      reload_objs=\"$objs$old_deplibs \"`$ECHO \"X$libobjs\" | $SP2NL | $Xsed -e '/\\.'${libext}$'/d' -e '/\\.lib$/d' -e \"$lo2o\" | $NL2SP`\" $reload_conv_objs\" ### testsuite: skip nested quoting test\n\n      output=\"$obj\"\n      func_execute_cmds \"$reload_cmds\" 'exit $?'\n\n      # Exit if we aren't doing a library object file.\n      if test -z \"$libobj\"; then\n\tif test -n \"$gentop\"; then\n\t  func_show_eval '${RM}r \"$gentop\"'\n\tfi\n\n\texit $EXIT_SUCCESS\n      fi\n\n      if test \"$build_libtool_libs\" != yes; then\n\tif test -n \"$gentop\"; then\n\t  func_show_eval '${RM}r \"$gentop\"'\n\tfi\n\n\t# Create an invalid libtool object if no PIC, so that we don't\n\t# accidentally link it into a program.\n\t# $show \"echo timestamp > $libobj\"\n\t# $opt_dry_run || eval \"echo timestamp > $libobj\" || exit $?\n\texit $EXIT_SUCCESS\n      fi\n\n      if test -n \"$pic_flag\" || test \"$pic_mode\" != default; then\n\t# Only do commands if we really have different PIC objects.\n\treload_objs=\"$libobjs $reload_conv_objs\"\n\toutput=\"$libobj\"\n\tfunc_execute_cmds \"$reload_cmds\" 'exit $?'\n      fi\n\n      if test -n \"$gentop\"; then\n\tfunc_show_eval '${RM}r \"$gentop\"'\n      fi\n\n      exit $EXIT_SUCCESS\n      ;;\n\n    prog)\n      case $host in\n\t*cygwin*) func_stripname '' '.exe' \"$output\"\n\t          output=$func_stripname_result.exe;;\n      esac\n      test -n \"$vinfo\" && \\\n\tfunc_warning \"\\`-version-info' is ignored for programs\"\n\n      test -n \"$release\" && \\\n\tfunc_warning \"\\`-release' is ignored for programs\"\n\n      test \"$preload\" = yes \\\n        && test \"$dlopen_support\" = unknown \\\n\t&& test \"$dlopen_self\" = unknown \\\n\t&& test \"$dlopen_self_static\" = unknown && \\\n\t  func_warning \"\\`LT_INIT([dlopen])' not used. Assuming no dlopen support.\"\n\n      case $host in\n      *-*-rhapsody* | *-*-darwin1.[012])\n\t# On Rhapsody replace the C library is the System framework\n\tcompile_deplibs=`$ECHO \"X $compile_deplibs\" | $Xsed -e 's/ -lc / System.ltframework /'`\n\tfinalize_deplibs=`$ECHO \"X $finalize_deplibs\" | $Xsed -e 's/ -lc / System.ltframework /'`\n\t;;\n      esac\n\n      case $host in\n      *-*-darwin*)\n\t# Don't allow lazy linking, it breaks C++ global constructors\n\t# But is supposedly fixed on 10.4 or later (yay!).\n\tif test \"$tagname\" = CXX ; then\n\t  case ${MACOSX_DEPLOYMENT_TARGET-10.0} in\n\t    10.[0123])\n\t      compile_command=\"$compile_command ${wl}-bind_at_load\"\n\t      finalize_command=\"$finalize_command ${wl}-bind_at_load\"\n\t    ;;\n\t  esac\n\tfi\n\t# Time to change all our \"foo.ltframework\" stuff back to \"-framework foo\"\n\tcompile_deplibs=`$ECHO \"X $compile_deplibs\" | $Xsed -e 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\tfinalize_deplibs=`$ECHO \"X $finalize_deplibs\" | $Xsed -e 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\t;;\n      esac\n\n\n      # move library search paths that coincide with paths to not yet\n      # installed libraries to the beginning of the library search list\n      new_libs=\n      for path in $notinst_path; do\n\tcase \" $new_libs \" in\n\t*\" -L$path/$objdir \"*) ;;\n\t*)\n\t  case \" $compile_deplibs \" in\n\t  *\" -L$path/$objdir \"*)\n\t    new_libs=\"$new_libs -L$path/$objdir\" ;;\n\t  esac\n\t  ;;\n\tesac\n      done\n      for deplib in $compile_deplibs; do\n\tcase $deplib in\n\t-L*)\n\t  case \" $new_libs \" in\n\t  *\" $deplib \"*) ;;\n\t  *) new_libs=\"$new_libs $deplib\" ;;\n\t  esac\n\t  ;;\n\t*) new_libs=\"$new_libs $deplib\" ;;\n\tesac\n      done\n      compile_deplibs=\"$new_libs\"\n\n\n      compile_command=\"$compile_command $compile_deplibs\"\n      finalize_command=\"$finalize_command $finalize_deplibs\"\n\n      if test -n \"$rpath$xrpath\"; then\n\t# If the user specified any rpath flags, then add them.\n\tfor libdir in $rpath $xrpath; do\n\t  # This is the magic to use -rpath.\n\t  case \"$finalize_rpath \" in\n\t  *\" $libdir \"*) ;;\n\t  *) finalize_rpath=\"$finalize_rpath $libdir\" ;;\n\t  esac\n\tdone\n      fi\n\n      # Now hardcode the library paths\n      rpath=\n      hardcode_libdirs=\n      for libdir in $compile_rpath $finalize_rpath; do\n\tif test -n \"$hardcode_libdir_flag_spec\"; then\n\t  if test -n \"$hardcode_libdir_separator\"; then\n\t    if test -z \"$hardcode_libdirs\"; then\n\t      hardcode_libdirs=\"$libdir\"\n\t    else\n\t      # Just accumulate the unique libdirs.\n\t      case $hardcode_libdir_separator$hardcode_libdirs$hardcode_libdir_separator in\n\t      *\"$hardcode_libdir_separator$libdir$hardcode_libdir_separator\"*)\n\t\t;;\n\t      *)\n\t\thardcode_libdirs=\"$hardcode_libdirs$hardcode_libdir_separator$libdir\"\n\t\t;;\n\t      esac\n\t    fi\n\t  else\n\t    eval flag=\\\"$hardcode_libdir_flag_spec\\\"\n\t    rpath=\"$rpath $flag\"\n\t  fi\n\telif test -n \"$runpath_var\"; then\n\t  case \"$perm_rpath \" in\n\t  *\" $libdir \"*) ;;\n\t  *) perm_rpath=\"$perm_rpath $libdir\" ;;\n\t  esac\n\tfi\n\tcase $host in\n\t*-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-cegcc*)\n\t  testbindir=`${ECHO} \"$libdir\" | ${SED} -e 's*/lib$*/bin*'`\n\t  case :$dllsearchpath: in\n\t  *\":$libdir:\"*) ;;\n\t  ::) dllsearchpath=$libdir;;\n\t  *) dllsearchpath=\"$dllsearchpath:$libdir\";;\n\t  esac\n\t  case :$dllsearchpath: in\n\t  *\":$testbindir:\"*) ;;\n\t  ::) dllsearchpath=$testbindir;;\n\t  *) dllsearchpath=\"$dllsearchpath:$testbindir\";;\n\t  esac\n\t  ;;\n\tesac\n      done\n      # Substitute the hardcoded libdirs into the rpath.\n      if test -n \"$hardcode_libdir_separator\" &&\n\t test -n \"$hardcode_libdirs\"; then\n\tlibdir=\"$hardcode_libdirs\"\n\teval rpath=\\\" $hardcode_libdir_flag_spec\\\"\n      fi\n      compile_rpath=\"$rpath\"\n\n      rpath=\n      hardcode_libdirs=\n      for libdir in $finalize_rpath; do\n\tif test -n \"$hardcode_libdir_flag_spec\"; then\n\t  if test -n \"$hardcode_libdir_separator\"; then\n\t    if test -z \"$hardcode_libdirs\"; then\n\t      hardcode_libdirs=\"$libdir\"\n\t    else\n\t      # Just accumulate the unique libdirs.\n\t      case $hardcode_libdir_separator$hardcode_libdirs$hardcode_libdir_separator in\n\t      *\"$hardcode_libdir_separator$libdir$hardcode_libdir_separator\"*)\n\t\t;;\n\t      *)\n\t\thardcode_libdirs=\"$hardcode_libdirs$hardcode_libdir_separator$libdir\"\n\t\t;;\n\t      esac\n\t    fi\n\t  else\n\t    eval flag=\\\"$hardcode_libdir_flag_spec\\\"\n\t    rpath=\"$rpath $flag\"\n\t  fi\n\telif test -n \"$runpath_var\"; then\n\t  case \"$finalize_perm_rpath \" in\n\t  *\" $libdir \"*) ;;\n\t  *) finalize_perm_rpath=\"$finalize_perm_rpath $libdir\" ;;\n\t  esac\n\tfi\n      done\n      # Substitute the hardcoded libdirs into the rpath.\n      if test -n \"$hardcode_libdir_separator\" &&\n\t test -n \"$hardcode_libdirs\"; then\n\tlibdir=\"$hardcode_libdirs\"\n\teval rpath=\\\" $hardcode_libdir_flag_spec\\\"\n      fi\n      finalize_rpath=\"$rpath\"\n\n      if test -n \"$libobjs\" && test \"$build_old_libs\" = yes; then\n\t# Transform all the library objects into standard objects.\n\tcompile_command=`$ECHO \"X$compile_command\" | $SP2NL | $Xsed -e \"$lo2o\" | $NL2SP`\n\tfinalize_command=`$ECHO \"X$finalize_command\" | $SP2NL | $Xsed -e \"$lo2o\" | $NL2SP`\n      fi\n\n      func_generate_dlsyms \"$outputname\" \"@PROGRAM@\" \"no\"\n\n      # template prelinking step\n      if test -n \"$prelink_cmds\"; then\n\tfunc_execute_cmds \"$prelink_cmds\" 'exit $?'\n      fi\n\n      wrappers_required=yes\n      case $host in\n      *cygwin* | *mingw* )\n        if test \"$build_libtool_libs\" != yes; then\n          wrappers_required=no\n        fi\n        ;;\n      *cegcc)\n        # Disable wrappers for cegcc, we are cross compiling anyway.\n        wrappers_required=no\n        ;;\n      *)\n        if test \"$need_relink\" = no || test \"$build_libtool_libs\" != yes; then\n          wrappers_required=no\n        fi\n        ;;\n      esac\n      if test \"$wrappers_required\" = no; then\n\t# Replace the output file specification.\n\tcompile_command=`$ECHO \"X$compile_command\" | $Xsed -e 's%@OUTPUT@%'\"$output\"'%g'`\n\tlink_command=\"$compile_command$compile_rpath\"\n\n\t# We have no uninstalled library dependencies, so finalize right now.\n\texit_status=0\n\tfunc_show_eval \"$link_command\" 'exit_status=$?'\n\n\t# Delete the generated files.\n\tif test -f \"$output_objdir/${outputname}S.${objext}\"; then\n\t  func_show_eval '$RM \"$output_objdir/${outputname}S.${objext}\"'\n\tfi\n\n\texit $exit_status\n      fi\n\n      if test -n \"$compile_shlibpath$finalize_shlibpath\"; then\n\tcompile_command=\"$shlibpath_var=\\\"$compile_shlibpath$finalize_shlibpath\\$$shlibpath_var\\\" $compile_command\"\n      fi\n      if test -n \"$finalize_shlibpath\"; then\n\tfinalize_command=\"$shlibpath_var=\\\"$finalize_shlibpath\\$$shlibpath_var\\\" $finalize_command\"\n      fi\n\n      compile_var=\n      finalize_var=\n      if test -n \"$runpath_var\"; then\n\tif test -n \"$perm_rpath\"; then\n\t  # We should set the runpath_var.\n\t  rpath=\n\t  for dir in $perm_rpath; do\n\t    rpath=\"$rpath$dir:\"\n\t  done\n\t  compile_var=\"$runpath_var=\\\"$rpath\\$$runpath_var\\\" \"\n\tfi\n\tif test -n \"$finalize_perm_rpath\"; then\n\t  # We should set the runpath_var.\n\t  rpath=\n\t  for dir in $finalize_perm_rpath; do\n\t    rpath=\"$rpath$dir:\"\n\t  done\n\t  finalize_var=\"$runpath_var=\\\"$rpath\\$$runpath_var\\\" \"\n\tfi\n      fi\n\n      if test \"$no_install\" = yes; then\n\t# We don't need to create a wrapper script.\n\tlink_command=\"$compile_var$compile_command$compile_rpath\"\n\t# Replace the output file specification.\n\tlink_command=`$ECHO \"X$link_command\" | $Xsed -e 's%@OUTPUT@%'\"$output\"'%g'`\n\t# Delete the old output file.\n\t$opt_dry_run || $RM $output\n\t# Link the executable and exit\n\tfunc_show_eval \"$link_command\" 'exit $?'\n\texit $EXIT_SUCCESS\n      fi\n\n      if test \"$hardcode_action\" = relink; then\n\t# Fast installation is not supported\n\tlink_command=\"$compile_var$compile_command$compile_rpath\"\n\trelink_command=\"$finalize_var$finalize_command$finalize_rpath\"\n\n\tfunc_warning \"this platform does not like uninstalled shared libraries\"\n\tfunc_warning \"\\`$output' will be relinked during installation\"\n      else\n\tif test \"$fast_install\" != no; then\n\t  link_command=\"$finalize_var$compile_command$finalize_rpath\"\n\t  if test \"$fast_install\" = yes; then\n\t    relink_command=`$ECHO \"X$compile_var$compile_command$compile_rpath\" | $Xsed -e 's%@OUTPUT@%\\$progdir/\\$file%g'`\n\t  else\n\t    # fast_install is set to needless\n\t    relink_command=\n\t  fi\n\telse\n\t  link_command=\"$compile_var$compile_command$compile_rpath\"\n\t  relink_command=\"$finalize_var$finalize_command$finalize_rpath\"\n\tfi\n      fi\n\n      # Replace the output file specification.\n      link_command=`$ECHO \"X$link_command\" | $Xsed -e 's%@OUTPUT@%'\"$output_objdir/$outputname\"'%g'`\n\n      # Delete the old output files.\n      $opt_dry_run || $RM $output $output_objdir/$outputname $output_objdir/lt-$outputname\n\n      func_show_eval \"$link_command\" 'exit $?'\n\n      # Now create the wrapper script.\n      func_verbose \"creating $output\"\n\n      # Quote the relink command for shipping.\n      if test -n \"$relink_command\"; then\n\t# Preserve any variables that may affect compiler behavior\n\tfor var in $variables_saved_for_relink; do\n\t  if eval test -z \\\"\\${$var+set}\\\"; then\n\t    relink_command=\"{ test -z \\\"\\${$var+set}\\\" || $lt_unset $var || { $var=; export $var; }; }; $relink_command\"\n\t  elif eval var_value=\\$$var; test -z \"$var_value\"; then\n\t    relink_command=\"$var=; export $var; $relink_command\"\n\t  else\n\t    func_quote_for_eval \"$var_value\"\n\t    relink_command=\"$var=$func_quote_for_eval_result; export $var; $relink_command\"\n\t  fi\n\tdone\n\trelink_command=\"(cd `pwd`; $relink_command)\"\n\trelink_command=`$ECHO \"X$relink_command\" | $Xsed -e \"$sed_quote_subst\"`\n      fi\n\n      # Quote $ECHO for shipping.\n      if test \"X$ECHO\" = \"X$SHELL $progpath --fallback-echo\"; then\n\tcase $progpath in\n\t[\\\\/]* | [A-Za-z]:[\\\\/]*) qecho=\"$SHELL $progpath --fallback-echo\";;\n\t*) qecho=\"$SHELL `pwd`/$progpath --fallback-echo\";;\n\tesac\n\tqecho=`$ECHO \"X$qecho\" | $Xsed -e \"$sed_quote_subst\"`\n      else\n\tqecho=`$ECHO \"X$ECHO\" | $Xsed -e \"$sed_quote_subst\"`\n      fi\n\n      # Only actually do things if not in dry run mode.\n      $opt_dry_run || {\n\t# win32 will think the script is a binary if it has\n\t# a .exe suffix, so we strip it off here.\n\tcase $output in\n\t  *.exe) func_stripname '' '.exe' \"$output\"\n\t         output=$func_stripname_result ;;\n\tesac\n\t# test for cygwin because mv fails w/o .exe extensions\n\tcase $host in\n\t  *cygwin*)\n\t    exeext=.exe\n\t    func_stripname '' '.exe' \"$outputname\"\n\t    outputname=$func_stripname_result ;;\n\t  *) exeext= ;;\n\tesac\n\tcase $host in\n\t  *cygwin* | *mingw* )\n\t    func_dirname_and_basename \"$output\" \"\" \".\"\n\t    output_name=$func_basename_result\n\t    output_path=$func_dirname_result\n\t    cwrappersource=\"$output_path/$objdir/lt-$output_name.c\"\n\t    cwrapper=\"$output_path/$output_name.exe\"\n\t    $RM $cwrappersource $cwrapper\n\t    trap \"$RM $cwrappersource $cwrapper; exit $EXIT_FAILURE\" 1 2 15\n\n\t    func_emit_cwrapperexe_src > $cwrappersource\n\n\t    # The wrapper executable is built using the $host compiler,\n\t    # because it contains $host paths and files. If cross-\n\t    # compiling, it, like the target executable, must be\n\t    # executed on the $host or under an emulation environment.\n\t    $opt_dry_run || {\n\t      $LTCC $LTCFLAGS -o $cwrapper $cwrappersource\n\t      $STRIP $cwrapper\n\t    }\n\n\t    # Now, create the wrapper script for func_source use:\n\t    func_ltwrapper_scriptname $cwrapper\n\t    $RM $func_ltwrapper_scriptname_result\n\t    trap \"$RM $func_ltwrapper_scriptname_result; exit $EXIT_FAILURE\" 1 2 15\n\t    $opt_dry_run || {\n\t      # note: this script will not be executed, so do not chmod.\n\t      if test \"x$build\" = \"x$host\" ; then\n\t\t$cwrapper --lt-dump-script > $func_ltwrapper_scriptname_result\n\t      else\n\t\tfunc_emit_wrapper no > $func_ltwrapper_scriptname_result\n\t      fi\n\t    }\n\t  ;;\n\t  * )\n\t    $RM $output\n\t    trap \"$RM $output; exit $EXIT_FAILURE\" 1 2 15\n\n\t    func_emit_wrapper no > $output\n\t    chmod +x $output\n\t  ;;\n\tesac\n      }\n      exit $EXIT_SUCCESS\n      ;;\n    esac\n\n    # See if we need to build an old-fashioned archive.\n    for oldlib in $oldlibs; do\n\n      if test \"$build_libtool_libs\" = convenience; then\n\toldobjs=\"$libobjs_save $symfileobj\"\n\taddlibs=\"$convenience\"\n\tbuild_libtool_libs=no\n      else\n\tif test \"$build_libtool_libs\" = module; then\n\t  oldobjs=\"$libobjs_save\"\n\t  build_libtool_libs=no\n\telse\n\t  oldobjs=\"$old_deplibs $non_pic_objects\"\n\t  if test \"$preload\" = yes && test -f \"$symfileobj\"; then\n\t    oldobjs=\"$oldobjs $symfileobj\"\n\t  fi\n\tfi\n\taddlibs=\"$old_convenience\"\n      fi\n\n      if test -n \"$addlibs\"; then\n\tgentop=\"$output_objdir/${outputname}x\"\n\tgenerated=\"$generated $gentop\"\n\n\tfunc_extract_archives $gentop $addlibs\n\toldobjs=\"$oldobjs $func_extract_archives_result\"\n      fi\n\n      # Do each command in the archive commands.\n      if test -n \"$old_archive_from_new_cmds\" && test \"$build_libtool_libs\" = yes; then\n\tcmds=$old_archive_from_new_cmds\n      else\n\n\t# Add any objects from preloaded convenience libraries\n\tif test -n \"$dlprefiles\"; then\n\t  gentop=\"$output_objdir/${outputname}x\"\n\t  generated=\"$generated $gentop\"\n\n\t  func_extract_archives $gentop $dlprefiles\n\t  oldobjs=\"$oldobjs $func_extract_archives_result\"\n\tfi\n\n\t# POSIX demands no paths to be encoded in archives.  We have\n\t# to avoid creating archives with duplicate basenames if we\n\t# might have to extract them afterwards, e.g., when creating a\n\t# static archive out of a convenience library, or when linking\n\t# the entirety of a libtool archive into another (currently\n\t# not supported by libtool).\n\tif (for obj in $oldobjs\n\t    do\n\t      func_basename \"$obj\"\n\t      $ECHO \"$func_basename_result\"\n\t    done | sort | sort -uc >/dev/null 2>&1); then\n\t  :\n\telse\n\t  $ECHO \"copying selected object files to avoid basename conflicts...\"\n\t  gentop=\"$output_objdir/${outputname}x\"\n\t  generated=\"$generated $gentop\"\n\t  func_mkdir_p \"$gentop\"\n\t  save_oldobjs=$oldobjs\n\t  oldobjs=\n\t  counter=1\n\t  for obj in $save_oldobjs\n\t  do\n\t    func_basename \"$obj\"\n\t    objbase=\"$func_basename_result\"\n\t    case \" $oldobjs \" in\n\t    \" \") oldobjs=$obj ;;\n\t    *[\\ /]\"$objbase \"*)\n\t      while :; do\n\t\t# Make sure we don't pick an alternate name that also\n\t\t# overlaps.\n\t\tnewobj=lt$counter-$objbase\n\t\tfunc_arith $counter + 1\n\t\tcounter=$func_arith_result\n\t\tcase \" $oldobjs \" in\n\t\t*[\\ /]\"$newobj \"*) ;;\n\t\t*) if test ! -f \"$gentop/$newobj\"; then break; fi ;;\n\t\tesac\n\t      done\n\t      func_show_eval \"ln $obj $gentop/$newobj || cp $obj $gentop/$newobj\"\n\t      oldobjs=\"$oldobjs $gentop/$newobj\"\n\t      ;;\n\t    *) oldobjs=\"$oldobjs $obj\" ;;\n\t    esac\n\t  done\n\tfi\n\teval cmds=\\\"$old_archive_cmds\\\"\n\n\tfunc_len \" $cmds\"\n\tlen=$func_len_result\n\tif test \"$len\" -lt \"$max_cmd_len\" || test \"$max_cmd_len\" -le -1; then\n\t  cmds=$old_archive_cmds\n\telse\n\t  # the command line is too long to link in one step, link in parts\n\t  func_verbose \"using piecewise archive linking...\"\n\t  save_RANLIB=$RANLIB\n\t  RANLIB=:\n\t  objlist=\n\t  concat_cmds=\n\t  save_oldobjs=$oldobjs\n\t  oldobjs=\n\t  # Is there a better way of finding the last object in the list?\n\t  for obj in $save_oldobjs\n\t  do\n\t    last_oldobj=$obj\n\t  done\n\t  eval test_cmds=\\\"$old_archive_cmds\\\"\n\t  func_len \" $test_cmds\"\n\t  len0=$func_len_result\n\t  len=$len0\n\t  for obj in $save_oldobjs\n\t  do\n\t    func_len \" $obj\"\n\t    func_arith $len + $func_len_result\n\t    len=$func_arith_result\n\t    func_append objlist \" $obj\"\n\t    if test \"$len\" -lt \"$max_cmd_len\"; then\n\t      :\n\t    else\n\t      # the above command should be used before it gets too long\n\t      oldobjs=$objlist\n\t      if test \"$obj\" = \"$last_oldobj\" ; then\n\t\tRANLIB=$save_RANLIB\n\t      fi\n\t      test -z \"$concat_cmds\" || concat_cmds=$concat_cmds~\n\t      eval concat_cmds=\\\"\\${concat_cmds}$old_archive_cmds\\\"\n\t      objlist=\n\t      len=$len0\n\t    fi\n\t  done\n\t  RANLIB=$save_RANLIB\n\t  oldobjs=$objlist\n\t  if test \"X$oldobjs\" = \"X\" ; then\n\t    eval cmds=\\\"\\$concat_cmds\\\"\n\t  else\n\t    eval cmds=\\\"\\$concat_cmds~\\$old_archive_cmds\\\"\n\t  fi\n\tfi\n      fi\n      func_execute_cmds \"$cmds\" 'exit $?'\n    done\n\n    test -n \"$generated\" && \\\n      func_show_eval \"${RM}r$generated\"\n\n    # Now create the libtool archive.\n    case $output in\n    *.la)\n      old_library=\n      test \"$build_old_libs\" = yes && old_library=\"$libname.$libext\"\n      func_verbose \"creating $output\"\n\n      # Preserve any variables that may affect compiler behavior\n      for var in $variables_saved_for_relink; do\n\tif eval test -z \\\"\\${$var+set}\\\"; then\n\t  relink_command=\"{ test -z \\\"\\${$var+set}\\\" || $lt_unset $var || { $var=; export $var; }; }; $relink_command\"\n\telif eval var_value=\\$$var; test -z \"$var_value\"; then\n\t  relink_command=\"$var=; export $var; $relink_command\"\n\telse\n\t  func_quote_for_eval \"$var_value\"\n\t  relink_command=\"$var=$func_quote_for_eval_result; export $var; $relink_command\"\n\tfi\n      done\n      # Quote the link command for shipping.\n      relink_command=\"(cd `pwd`; $SHELL $progpath $preserve_args --mode=relink $libtool_args @inst_prefix_dir@)\"\n      relink_command=`$ECHO \"X$relink_command\" | $Xsed -e \"$sed_quote_subst\"`\n      if test \"$hardcode_automatic\" = yes ; then\n\trelink_command=\n      fi\n\n      # Only create the output if not a dry run.\n      $opt_dry_run || {\n\tfor installed in no yes; do\n\t  if test \"$installed\" = yes; then\n\t    if test -z \"$install_libdir\"; then\n\t      break\n\t    fi\n\t    output=\"$output_objdir/$outputname\"i\n\t    # Replace all uninstalled libtool libraries with the installed ones\n\t    newdependency_libs=\n\t    for deplib in $dependency_libs; do\n\t      case $deplib in\n\t      *.la)\n\t\tfunc_basename \"$deplib\"\n\t\tname=\"$func_basename_result\"\n\t\teval libdir=`${SED} -n -e 's/^libdir=\\(.*\\)$/\\1/p' $deplib`\n\t\ttest -z \"$libdir\" && \\\n\t\t  func_fatal_error \"\\`$deplib' is not a valid libtool archive\"\n\t\tnewdependency_libs=\"$newdependency_libs $libdir/$name\"\n\t\t;;\n\t      *) newdependency_libs=\"$newdependency_libs $deplib\" ;;\n\t      esac\n\t    done\n\t    dependency_libs=\"$newdependency_libs\"\n\t    newdlfiles=\n\n\t    for lib in $dlfiles; do\n\t      case $lib in\n\t      *.la)\n\t        func_basename \"$lib\"\n\t\tname=\"$func_basename_result\"\n\t\teval libdir=`${SED} -n -e 's/^libdir=\\(.*\\)$/\\1/p' $lib`\n\t\ttest -z \"$libdir\" && \\\n\t\t  func_fatal_error \"\\`$lib' is not a valid libtool archive\"\n\t\tnewdlfiles=\"$newdlfiles $libdir/$name\"\n\t\t;;\n\t      *) newdlfiles=\"$newdlfiles $lib\" ;;\n\t      esac\n\t    done\n\t    dlfiles=\"$newdlfiles\"\n\t    newdlprefiles=\n\t    for lib in $dlprefiles; do\n\t      case $lib in\n\t      *.la)\n\t\t# Only pass preopened files to the pseudo-archive (for\n\t\t# eventual linking with the app. that links it) if we\n\t\t# didn't already link the preopened objects directly into\n\t\t# the library:\n\t\tfunc_basename \"$lib\"\n\t\tname=\"$func_basename_result\"\n\t\teval libdir=`${SED} -n -e 's/^libdir=\\(.*\\)$/\\1/p' $lib`\n\t\ttest -z \"$libdir\" && \\\n\t\t  func_fatal_error \"\\`$lib' is not a valid libtool archive\"\n\t\tnewdlprefiles=\"$newdlprefiles $libdir/$name\"\n\t\t;;\n\t      esac\n\t    done\n\t    dlprefiles=\"$newdlprefiles\"\n\t  else\n\t    newdlfiles=\n\t    for lib in $dlfiles; do\n\t      case $lib in\n\t\t[\\\\/]* | [A-Za-z]:[\\\\/]*) abs=\"$lib\" ;;\n\t\t*) abs=`pwd`\"/$lib\" ;;\n\t      esac\n\t      newdlfiles=\"$newdlfiles $abs\"\n\t    done\n\t    dlfiles=\"$newdlfiles\"\n\t    newdlprefiles=\n\t    for lib in $dlprefiles; do\n\t      case $lib in\n\t\t[\\\\/]* | [A-Za-z]:[\\\\/]*) abs=\"$lib\" ;;\n\t\t*) abs=`pwd`\"/$lib\" ;;\n\t      esac\n\t      newdlprefiles=\"$newdlprefiles $abs\"\n\t    done\n\t    dlprefiles=\"$newdlprefiles\"\n\t  fi\n\t  $RM $output\n\t  # place dlname in correct position for cygwin\n\t  tdlname=$dlname\n\t  case $host,$output,$installed,$module,$dlname in\n\t    *cygwin*,*lai,yes,no,*.dll | *mingw*,*lai,yes,no,*.dll | *cegcc*,*lai,yes,no,*.dll) tdlname=../bin/$dlname ;;\n\t  esac\n\t  $ECHO > $output \"\\\n# $outputname - a libtool library file\n# Generated by $PROGRAM (GNU $PACKAGE$TIMESTAMP) $VERSION\n#\n# Please DO NOT delete this file!\n# It is necessary for linking the library.\n\n# The name that we can dlopen(3).\ndlname='$tdlname'\n\n# Names of this library.\nlibrary_names='$library_names'\n\n# The name of the static archive.\nold_library='$old_library'\n\n# Linker flags that can not go in dependency_libs.\ninherited_linker_flags='$new_inherited_linker_flags'\n\n# Libraries that this one depends upon.\ndependency_libs='$dependency_libs'\n\n# Names of additional weak libraries provided by this library\nweak_library_names='$weak_libs'\n\n# Version information for $libname.\ncurrent=$current\nage=$age\nrevision=$revision\n\n# Is this an already installed library?\ninstalled=$installed\n\n# Should we warn about portability when linking against -modules?\nshouldnotlink=$module\n\n# Files to dlopen/dlpreopen\ndlopen='$dlfiles'\ndlpreopen='$dlprefiles'\n\n# Directory that this library needs to be installed in:\nlibdir='$install_libdir'\"\n\t  if test \"$installed\" = no && test \"$need_relink\" = yes; then\n\t    $ECHO >> $output \"\\\nrelink_command=\\\"$relink_command\\\"\"\n\t  fi\n\tdone\n      }\n\n      # Do a symbolic link so that the libtool archive can be found in\n      # LD_LIBRARY_PATH before the program is installed.\n      func_show_eval '( cd \"$output_objdir\" && $RM \"$outputname\" && $LN_S \"../$outputname\" \"$outputname\" )' 'exit $?'\n      ;;\n    esac\n    exit $EXIT_SUCCESS\n}\n\n{ test \"$mode\" = link || test \"$mode\" = relink; } &&\n    func_mode_link ${1+\"$@\"}\n\n\n# func_mode_uninstall arg...\nfunc_mode_uninstall ()\n{\n    $opt_debug\n    RM=\"$nonopt\"\n    files=\n    rmforce=\n    exit_status=0\n\n    # This variable tells wrapper scripts just to set variables rather\n    # than running their programs.\n    libtool_install_magic=\"$magic\"\n\n    for arg\n    do\n      case $arg in\n      -f) RM=\"$RM $arg\"; rmforce=yes ;;\n      -*) RM=\"$RM $arg\" ;;\n      *) files=\"$files $arg\" ;;\n      esac\n    done\n\n    test -z \"$RM\" && \\\n      func_fatal_help \"you must specify an RM program\"\n\n    rmdirs=\n\n    origobjdir=\"$objdir\"\n    for file in $files; do\n      func_dirname \"$file\" \"\" \".\"\n      dir=\"$func_dirname_result\"\n      if test \"X$dir\" = X.; then\n\tobjdir=\"$origobjdir\"\n      else\n\tobjdir=\"$dir/$origobjdir\"\n      fi\n      func_basename \"$file\"\n      name=\"$func_basename_result\"\n      test \"$mode\" = uninstall && objdir=\"$dir\"\n\n      # Remember objdir for removal later, being careful to avoid duplicates\n      if test \"$mode\" = clean; then\n\tcase \" $rmdirs \" in\n\t  *\" $objdir \"*) ;;\n\t  *) rmdirs=\"$rmdirs $objdir\" ;;\n\tesac\n      fi\n\n      # Don't error if the file doesn't exist and rm -f was used.\n      if { test -L \"$file\"; } >/dev/null 2>&1 ||\n\t { test -h \"$file\"; } >/dev/null 2>&1 ||\n\t test -f \"$file\"; then\n\t:\n      elif test -d \"$file\"; then\n\texit_status=1\n\tcontinue\n      elif test \"$rmforce\" = yes; then\n\tcontinue\n      fi\n\n      rmfiles=\"$file\"\n\n      case $name in\n      *.la)\n\t# Possibly a libtool archive, so verify it.\n\tif func_lalib_p \"$file\"; then\n\t  func_source $dir/$name\n\n\t  # Delete the libtool libraries and symlinks.\n\t  for n in $library_names; do\n\t    rmfiles=\"$rmfiles $objdir/$n\"\n\t  done\n\t  test -n \"$old_library\" && rmfiles=\"$rmfiles $objdir/$old_library\"\n\n\t  case \"$mode\" in\n\t  clean)\n\t    case \"  $library_names \" in\n\t    # \"  \" in the beginning catches empty $dlname\n\t    *\" $dlname \"*) ;;\n\t    *) rmfiles=\"$rmfiles $objdir/$dlname\" ;;\n\t    esac\n\t    test -n \"$libdir\" && rmfiles=\"$rmfiles $objdir/$name $objdir/${name}i\"\n\t    ;;\n\t  uninstall)\n\t    if test -n \"$library_names\"; then\n\t      # Do each command in the postuninstall commands.\n\t      func_execute_cmds \"$postuninstall_cmds\" 'test \"$rmforce\" = yes || exit_status=1'\n\t    fi\n\n\t    if test -n \"$old_library\"; then\n\t      # Do each command in the old_postuninstall commands.\n\t      func_execute_cmds \"$old_postuninstall_cmds\" 'test \"$rmforce\" = yes || exit_status=1'\n\t    fi\n\t    # FIXME: should reinstall the best remaining shared library.\n\t    ;;\n\t  esac\n\tfi\n\t;;\n\n      *.lo)\n\t# Possibly a libtool object, so verify it.\n\tif func_lalib_p \"$file\"; then\n\n\t  # Read the .lo file\n\t  func_source $dir/$name\n\n\t  # Add PIC object to the list of files to remove.\n\t  if test -n \"$pic_object\" &&\n\t     test \"$pic_object\" != none; then\n\t    rmfiles=\"$rmfiles $dir/$pic_object\"\n\t  fi\n\n\t  # Add non-PIC object to the list of files to remove.\n\t  if test -n \"$non_pic_object\" &&\n\t     test \"$non_pic_object\" != none; then\n\t    rmfiles=\"$rmfiles $dir/$non_pic_object\"\n\t  fi\n\tfi\n\t;;\n\n      *)\n\tif test \"$mode\" = clean ; then\n\t  noexename=$name\n\t  case $file in\n\t  *.exe)\n\t    func_stripname '' '.exe' \"$file\"\n\t    file=$func_stripname_result\n\t    func_stripname '' '.exe' \"$name\"\n\t    noexename=$func_stripname_result\n\t    # $file with .exe has already been added to rmfiles,\n\t    # add $file without .exe\n\t    rmfiles=\"$rmfiles $file\"\n\t    ;;\n\t  esac\n\t  # Do a test to see if this is a libtool program.\n\t  if func_ltwrapper_p \"$file\"; then\n\t    if func_ltwrapper_executable_p \"$file\"; then\n\t      func_ltwrapper_scriptname \"$file\"\n\t      relink_command=\n\t      func_source $func_ltwrapper_scriptname_result\n\t      rmfiles=\"$rmfiles $func_ltwrapper_scriptname_result\"\n\t    else\n\t      relink_command=\n\t      func_source $dir/$noexename\n\t    fi\n\n\t    # note $name still contains .exe if it was in $file originally\n\t    # as does the version of $file that was added into $rmfiles\n\t    rmfiles=\"$rmfiles $objdir/$name $objdir/${name}S.${objext}\"\n\t    if test \"$fast_install\" = yes && test -n \"$relink_command\"; then\n\t      rmfiles=\"$rmfiles $objdir/lt-$name\"\n\t    fi\n\t    if test \"X$noexename\" != \"X$name\" ; then\n\t      rmfiles=\"$rmfiles $objdir/lt-${noexename}.c\"\n\t    fi\n\t  fi\n\tfi\n\t;;\n      esac\n      func_show_eval \"$RM $rmfiles\" 'exit_status=1'\n    done\n    objdir=\"$origobjdir\"\n\n    # Try to remove the ${objdir}s in the directories where we deleted files\n    for dir in $rmdirs; do\n      if test -d \"$dir\"; then\n\tfunc_show_eval \"rmdir $dir >/dev/null 2>&1\"\n      fi\n    done\n\n    exit $exit_status\n}\n\n{ test \"$mode\" = uninstall || test \"$mode\" = clean; } &&\n    func_mode_uninstall ${1+\"$@\"}\n\ntest -z \"$mode\" && {\n  help=\"$generic_help\"\n  func_fatal_help \"you must specify a MODE\"\n}\n\ntest -z \"$exec_cmd\" && \\\n  func_fatal_help \"invalid operation mode \\`$mode'\"\n\nif test -n \"$exec_cmd\"; then\n  eval exec \"$exec_cmd\"\n  exit $EXIT_FAILURE\nfi\n\nexit $exit_status\n\n\n# The TAGs below are defined such that we never get into a situation\n# in which we disable both kinds of libraries.  Given conflicting\n# choices, we go for a static library, that is the most portable,\n# since we can't tell whether shared libraries were disabled because\n# the user asked for that or because the platform doesn't support\n# them.  This is particularly important on AIX, because we don't\n# support having both static and shared libraries enabled at the same\n# time on that platform, so we default to a shared-only configuration.\n# If a disable-shared tag is given, we'll fallback to a static-only\n# configuration.  But we'll never go from static-only to shared-only.\n\n# ### BEGIN LIBTOOL TAG CONFIG: disable-shared\nbuild_libtool_libs=no\nbuild_old_libs=yes\n# ### END LIBTOOL TAG CONFIG: disable-shared\n\n# ### BEGIN LIBTOOL TAG CONFIG: disable-static\nbuild_old_libs=`case $build_libtool_libs in yes) echo no;; *) echo yes;; esac`\n# ### END LIBTOOL TAG CONFIG: disable-static\n\n# Local Variables:\n# mode:shell-script\n# sh-indentation:2\n# End:\n# vi:sw=2\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/tokudb/PerconaFT/ftcxx/malloc_utils.hpp": "/* -*- mode: C++; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n#ident \"$Id$\"\n/*======\nThis file is part of PerconaFT.\n\n\nCopyright (c) 2006, 2015, Percona and/or its affiliates. All rights reserved.\n\n    PerconaFT is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License, version 2,\n    as published by the Free Software Foundation.\n\n    PerconaFT is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with PerconaFT.  If not, see <http://www.gnu.org/licenses/>.\n\n----------------------------------------\n\n    PerconaFT is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Affero General Public License, version 3,\n    as published by the Free Software Foundation.\n\n    PerconaFT is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Affero General Public License for more details.\n\n    You should have received a copy of the GNU Affero General Public License\n    along with PerconaFT.  If not, see <http://www.gnu.org/licenses/>.\n======= */\n\n#ident \"Copyright (c) 2006, 2015, Percona and/or its affiliates. All rights reserved.\"\n\n#pragma once\n\n/**\n * These functions are extracted from Facebook's folly library, which\n * integrates well with jemalloc.  See\n * https://github.com/facebook/folly/blob/master/folly/Malloc.h\n */\n\n#include <algorithm>\n#include <cassert>\n#include <cstdlib>\n\n#if defined(HAVE_BITS_FUNCTEXCEPT_H) && HAVE_BITS_FUNCTEXCEPT_H\n\n# include <bits/functexcept.h>\n\n#else\n\n# include <stdexcept>\n\nnamespace std {\n\n    void __throw_bad_alloc();\n\n}\n\n#endif\n\n/**\n * Declare *allocx() and mallctl() as weak symbols. These will be provided by\n * jemalloc if we are using jemalloc, or will be NULL if we are using another\n * malloc implementation.\n */\nextern \"C\" void* mallocx(size_t, int)\n    __attribute__((__weak__));\nextern \"C\" void* rallocx(void*, size_t, int)\n    __attribute__((__weak__));\nextern \"C\" size_t xallocx(void*, size_t, size_t, int)\n    __attribute__((__weak__));\nextern \"C\" size_t sallocx(const void*, int)\n    __attribute__((__weak__));\nextern \"C\" void dallocx(void*, int)\n    __attribute__((__weak__));\nextern \"C\" size_t nallocx(size_t, int)\n    __attribute__((__weak__));\nextern \"C\" int mallctl(const char*, void*, size_t*, void*, size_t)\n    __attribute__((__weak__));\n\nnamespace malloc_utils {\n\n    bool usingJEMallocSlow();\n\n    /**\n     * Determine if we are using jemalloc or not.\n     */\n    inline bool usingJEMalloc() {\n        // Checking for rallocx != NULL is not sufficient; we may be in a\n        // dlopen()ed module that depends on libjemalloc, so rallocx is\n        // resolved, but the main program might be using a different\n        // memory allocator. Look at the implementation of\n        // usingJEMallocSlow() for the (hacky) details.\n        static const bool result = usingJEMallocSlow();\n        return result;\n    }\n\n    /**\n     * For jemalloc's size classes, see\n     * http://www.canonware.com/download/jemalloc/jemalloc-latest/doc/jemalloc.html\n     */\n    inline size_t goodMallocSize(size_t minSize) noexcept {\n        if (!usingJEMalloc()) {\n            // Not using jemalloc - no smarts\n            return minSize;\n        }\n        size_t goodSize;\n        if (minSize <= 64) {\n            // Choose smallest allocation to be 64 bytes - no tripping\n            // over cache line boundaries, and small string optimization\n            // takes care of short strings anyway.\n            goodSize = 64;\n        } else if (minSize <= 512) {\n            // Round up to the next multiple of 64; we don't want to trip\n            // over cache line boundaries.\n            goodSize = (minSize + 63) & ~size_t(63);\n        } else if (minSize <= 3584) {\n            // Round up to the next multiple of 256.  For some size\n            // classes jemalloc will additionally round up to the nearest\n            // multiple of 512, hence the nallocx() call.\n            goodSize = nallocx((minSize + 255) & ~size_t(255), 0);\n        } else if (minSize <= 4072 * 1024) {\n            // Round up to the next multiple of 4KB\n            goodSize = (minSize + 4095) & ~size_t(4095);\n        } else {\n            // Holy Moly\n            // Round up to the next multiple of 4MB\n            goodSize = (minSize + 4194303) & ~size_t(4194303);\n        }\n        assert(nallocx(goodSize, 0) == goodSize);\n        return goodSize;\n    }\n\n    static const size_t jemallocMinInPlaceExpandable = 4096;\n\n    /**\n     * Trivial wrappers around malloc, calloc, realloc that check for\n     * allocation failure and throw std::bad_alloc in that case.\n     */\n    inline void* checkedMalloc(size_t size) {\n        void* p = malloc(size);\n        if (!p) std::__throw_bad_alloc();\n        return p;\n    }\n\n    inline void* checkedCalloc(size_t n, size_t size) {\n        void* p = calloc(n, size);\n        if (!p) std::__throw_bad_alloc();\n        return p;\n    }\n\n    inline void* checkedRealloc(void* ptr, size_t size) {\n        void* p = realloc(ptr, size);\n        if (!p) std::__throw_bad_alloc();\n        return p;\n    }\n\n    /**\n     * This function tries to reallocate a buffer of which only the first\n     * currentSize bytes are used. The problem with using realloc is that\n     * if currentSize is relatively small _and_ if realloc decides it\n     * needs to move the memory chunk to a new buffer, then realloc ends\n     * up copying data that is not used. It's impossible to hook into\n     * GNU's malloc to figure whether expansion will occur in-place or as\n     * a malloc-copy-free troika. (If an expand_in_place primitive would\n     * be available, smartRealloc would use it.) As things stand, this\n     * routine just tries to call realloc() (thus benefitting of potential\n     * copy-free coalescing) unless there's too much slack memory.\n     */\n    inline void* smartRealloc(void* p,\n                              const size_t currentSize,\n                              const size_t currentCapacity,\n                              const size_t newCapacity,\n                              size_t &realNewCapacity) {\n        assert(p);\n        assert(currentSize <= currentCapacity &&\n               currentCapacity < newCapacity);\n\n        if (usingJEMalloc()) {\n            // using jemalloc's API. Don't forget that jemalloc can never\n            // grow in place blocks smaller than 4096 bytes.\n            //\n            // NB: newCapacity may not be precisely equal to a jemalloc\n            // size class, i.e. newCapacity is not guaranteed to be the\n            // result of a goodMallocSize() call, therefore xallocx() may\n            // return more than newCapacity bytes of space.  Use >= rather\n            // than == to check whether xallocx() successfully expanded in\n            // place.\n            size_t realNewCapacity_;\n            if (currentCapacity >= jemallocMinInPlaceExpandable &&\n                (realNewCapacity_ = xallocx(p, newCapacity, 0, 0)) >= newCapacity) {\n                // Managed to expand in place\n                realNewCapacity = realNewCapacity_;\n                return p;\n            }\n            // Cannot expand; must move\n            char * const result = static_cast<char *>(checkedMalloc(newCapacity));\n            char *cp = static_cast<char *>(p);\n            std::copy(cp, cp + currentSize, result);\n            free(p);\n            realNewCapacity = newCapacity;\n            return result;\n        }\n\n        // No jemalloc no honey\n        auto const slack = currentCapacity - currentSize;\n        if (slack * 2 > currentSize) {\n            // Too much slack, malloc-copy-free cycle:\n            char * const result = static_cast<char *>(checkedMalloc(newCapacity));\n            char *cp = static_cast<char *>(p);\n            std::copy(cp, cp + currentSize, result);\n            free(p);\n            realNewCapacity = newCapacity;\n            return result;\n        }\n        // If there's not too much slack, we realloc in hope of coalescing\n        realNewCapacity = newCapacity;\n        return checkedRealloc(p, newCapacity);\n    }\n\n} // namespace malloc_utils\n",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/include/my_global.h": "/*\n   Copyright (c) 2001, 2013, Oracle and/or its affiliates.\n   Copyright (c) 2009, 2019, MariaDB Corporation.\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; version 2 of the License.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1335  USA */\n\n/* This is the include file that should be included 'first' in every C file. */\n\n#ifndef MY_GLOBAL_INCLUDED\n#define MY_GLOBAL_INCLUDED\n\n/* Client library users on Windows need this macro defined here. */\n#if !defined(__WIN__) && defined(_WIN32)\n#define __WIN__\n#endif\n\n/*\n  InnoDB depends on some MySQL internals which other plugins should not\n  need.  This is because of InnoDB's foreign key support, \"safe\" binlog\n  truncation, and other similar legacy features.\n\n  We define accessors for these internals unconditionally, but do not\n  expose them in mysql/plugin.h.  They are declared in ha_innodb.h for\n  InnoDB's use.\n*/\n#define INNODB_COMPATIBILITY_HOOKS\n\n#ifdef __CYGWIN__\n/* We use a Unix API, so pretend it's not Windows */\n#undef WIN\n#undef WIN32\n#undef _WIN\n#undef _WIN32\n#undef _WIN64\n#undef __WIN__\n#undef __WIN32__\n#define HAVE_ERRNO_AS_DEFINE\n#define _POSIX_MONOTONIC_CLOCK\n#define _POSIX_THREAD_CPUTIME\n#endif /* __CYGWIN__ */\n\n#if defined(__OpenBSD__) && (OpenBSD >= 200411)\n#define HAVE_ERRNO_AS_DEFINE\n#endif\n\n#if defined(i386) && !defined(__i386__)\n#define __i386__\n#endif\n\n/* Macros to make switching between C and C++ mode easier */\n#ifdef __cplusplus\n#define C_MODE_START    extern \"C\" {\n#define C_MODE_END\t}\n#else\n#define C_MODE_START\n#define C_MODE_END\n#endif\n\n#ifdef __cplusplus\n#define CPP_UNNAMED_NS_START  namespace {\n#define CPP_UNNAMED_NS_END    }\n#endif\n\n#include <my_config.h>\n\n#ifdef WITH_PERFSCHEMA_STORAGE_ENGINE\n#define HAVE_PSI_INTERFACE\n#endif /* WITH_PERFSCHEMA_STORAGE_ENGINE */\n\n/* Make it easier to add conditional code in _expressions_ */\n#ifdef __WIN__\n#define IF_WIN(A,B) A\n#else\n#define IF_WIN(A,B) B\n#endif\n\n#ifdef EMBEDDED_LIBRARY\n#define IF_EMBEDDED(A,B) A\n#else\n#define IF_EMBEDDED(A,B) B\n#endif\n\n#ifdef WITH_PARTITION_STORAGE_ENGINE\n#define IF_PARTITIONING(A,B) A\n#else\n#define IF_PARTITIONING(A,B) B\n#endif\n\n#if defined (_WIN32)\n/*\n off_t is 32 bit long. We do not use C runtime functions\n with off_t but native Win32 file IO APIs, that work with\n 64 bit offsets.\n*/\n#undef SIZEOF_OFF_T\n#define SIZEOF_OFF_T 8\n\n/*\n Prevent inclusion of  Windows GDI headers - they define symbol\n ERROR that conflicts with mysql headers.\n*/\n#ifndef NOGDI\n#define NOGDI\n#endif\n\n/* Include common headers.*/\n#include <winsock2.h>\n#include <ws2tcpip.h> /* SOCKET */\n#include <io.h>       /* access(), chmod() */\n#include <process.h>  /* getpid() */\n\n#define sleep(a) Sleep((a)*1000)\n\n/* Define missing access() modes. */\n#define F_OK 0\n#define W_OK 2\n#define R_OK 4                        /* Test for read permission.  */\n\n/* Define missing file locking constants. */\n#define F_RDLCK 1\n#define F_WRLCK 2\n#define F_UNLCK 3\n#define F_TO_EOF 0x3FFFFFFF\n\n#endif /* _WIN32*/\n\n\n/* Workaround for _LARGE_FILES and _LARGE_FILE_API incompatibility on AIX */\n#if defined(_AIX) && defined(_LARGE_FILE_API)\n#undef _LARGE_FILE_API\n#undef __GNUG__\n#endif\n\n/*\n  The macros below are used to allow build of Universal/fat binaries of\n  MySQL and MySQL applications under darwin. \n*/\n#if defined(__APPLE__) && defined(__MACH__)\n#  undef SIZEOF_CHARP \n#  undef SIZEOF_INT \n#  undef SIZEOF_LONG \n#  undef SIZEOF_LONG_LONG \n#  undef SIZEOF_OFF_T \n#  undef WORDS_BIGENDIAN\n#  define SIZEOF_INT 4\n#  define SIZEOF_LONG_LONG 8\n#  define SIZEOF_OFF_T 8\n#  if defined(__i386__) || defined(__ppc__)\n#    define SIZEOF_CHARP 4\n#    define SIZEOF_LONG 4\n#  elif defined(__x86_64__) || defined(__ppc64__)\n#    define SIZEOF_CHARP 8\n#    define SIZEOF_LONG 8\n#  else\n#    error Building FAT binary for an unknown architecture.\n#  endif\n#  if defined(__ppc__) || defined(__ppc64__)\n#    define WORDS_BIGENDIAN\n#  endif\n#endif /* defined(__APPLE__) && defined(__MACH__) */\n\n\n/*\n  The macros below are borrowed from include/linux/compiler.h in the\n  Linux kernel. Use them to indicate the likelihood of the truthfulness\n  of a condition. This serves two purposes - newer versions of gcc will be\n  able to optimize for branch predication, which could yield siginficant\n  performance gains in frequently executed sections of the code, and the\n  other reason to use them is for documentation\n*/\n\n#if !defined(__GNUC__) || (__GNUC__ == 2 && __GNUC_MINOR__ < 96)\n#define __builtin_expect(x, expected_value) (x)\n#endif\n\n/* Fix problem with S_ISLNK() on Linux */\n#if defined(TARGET_OS_LINUX) || defined(__GLIBC__)\n#undef  _GNU_SOURCE\n#define _GNU_SOURCE 1\n#endif\n\n/*\n  Temporary solution to solve bug#7156. Include \"sys/types.h\" before\n  the thread headers, else the function madvise() will not be defined\n*/\n#if defined(HAVE_SYS_TYPES_H) && ( defined(sun) || defined(__sun) )\n#include <sys/types.h>\n#endif\n\n#define __EXTENSIONS__ 1\t/* We want some extension */\n#ifndef __STDC_EXT__\n#define __STDC_EXT__ 1          /* To get large file support on hpux */\n#endif\n\n/*\n  Solaris 9 include file <sys/feature_tests.h> refers to X/Open document\n\n    System Interfaces and Headers, Issue 5\n\n  saying we should define _XOPEN_SOURCE=500 to get POSIX.1c prototypes,\n  but apparently other systems (namely FreeBSD) don't agree.\n\n  On a newer Solaris 10, the above file recognizes also _XOPEN_SOURCE=600.\n  Furthermore, it tests that if a program requires older standard\n  (_XOPEN_SOURCE<600 or _POSIX_C_SOURCE<200112L) it cannot be\n  run on a new compiler (that defines _STDC_C99) and issues an #error.\n  It's also an #error if a program requires new standard (_XOPEN_SOURCE=600\n  or _POSIX_C_SOURCE=200112L) and a compiler does not define _STDC_C99.\n\n  To add more to this mess, Sun Studio C compiler defines _STDC_C99 while\n  C++ compiler does not!\n\n  So, in a desperate attempt to get correct prototypes for both\n  C and C++ code, we define either _XOPEN_SOURCE=600 or _XOPEN_SOURCE=500\n  depending on the compiler's announced C standard support.\n\n  Cleaner solutions are welcome.\n*/\n#ifdef __sun\n#if __STDC_VERSION__ - 0 >= 199901L\n#define _XOPEN_SOURCE 600\n#else\n#define _XOPEN_SOURCE 500\n#endif\n#endif\n\n\n#ifdef _AIX\n/*\n  AIX includes inttypes.h from sys/types.h\n  Explicitly request format macros before the first inclusion of inttypes.h\n*/\n#if !defined(__STDC_FORMAT_MACROS)\n#define __STDC_FORMAT_MACROS\n#endif  // !defined(__STDC_FORMAT_MACROS)\n#endif\n\n\n#if !defined(__WIN__)\n#ifndef _POSIX_PTHREAD_SEMANTICS\n#define _POSIX_PTHREAD_SEMANTICS /* We want posix threads */\n#endif\n\n#if !defined(SCO)\n#define _REENTRANT\t1\t/* Some thread libraries require this */\n#endif\n#if !defined(_THREAD_SAFE) && !defined(_AIX)\n#define _THREAD_SAFE            /* Required for OSF1 */\n#endif\n#if defined(HPUX10) || defined(HPUX11)\nC_MODE_START\t\t\t/* HPUX needs this, signal.h bug */\n#include <pthread.h>\nC_MODE_END\n#else\n#include <pthread.h>\t\t/* AIX must have this included first */\n#endif\n#if !defined(SCO) && !defined(_REENTRANT)\n#define _REENTRANT\t1\t/* Threads requires reentrant code */\n#endif\n#endif /* !defined(__WIN__) */\n\n/* Go around some bugs in different OS and compilers */\n#ifdef _AIX\t\t\t/* By soren@t.dk */\n#define _H_STRINGS\n#define _SYS_STREAM_H\n/* #define _AIX32_CURSES */\t/* XXX: this breaks AIX 4.3.3 (others?). */\n#define ulonglong2double(A) my_ulonglong2double(A)\n#define my_off_t2double(A)  my_ulonglong2double(A)\nC_MODE_START\ninline double my_ulonglong2double(unsigned long long A) { return (double)A; }\nC_MODE_END\n#endif /* _AIX */\n\n#ifdef UNDEF_HAVE_INITGROUPS\t\t\t/* For AIX 4.3 */\n#undef HAVE_INITGROUPS\n#endif\n\n/* gcc/egcs issues */\n\n#if defined(__GNUC) && defined(__EXCEPTIONS)\n#error \"Please add -fno-exceptions to CXXFLAGS and reconfigure/recompile\"\n#endif\n\n#if defined(_lint) && !defined(lint)\n#define lint\n#endif\n#if SIZEOF_LONG_LONG > 4 && !defined(_LONG_LONG)\n#define _LONG_LONG 1\t\t/* For AIX string library */\n#endif\n\n/* Workaround for _LARGE_FILES and _LARGE_FILE_API incompatibility on AIX */\n#if defined(_AIX) && defined(_LARGE_FILE_API)\n#undef _LARGE_FILE_API\n#undef __GNUG__\n#endif\n\n\n#ifndef stdin\n#include <stdio.h>\n#endif\n#include <stdarg.h>\n#ifdef HAVE_STDLIB_H\n#include <stdlib.h>\n#endif\n#ifdef HAVE_STDDEF_H\n#include <stddef.h>\n#endif\n\n#include <math.h>\n#ifdef HAVE_LIMITS_H\n#include <limits.h>\n#endif\n#ifdef HAVE_FLOAT_H\n#include <float.h>\n#endif\n#ifdef HAVE_FENV_H\n#include <fenv.h> /* For fesetround() */\n#endif\n\n#ifdef HAVE_SYS_TYPES_H\n#include <sys/types.h>\n#endif\n\n/* Workaround for _LARGE_FILES and _LARGE_FILE_API incompatibility on AIX */\n#if defined(_AIX) && defined(_LARGE_FILE_API)\n#undef _LARGE_FILE_API\n#undef __GNUG__\n#endif\n\n\n#ifdef HAVE_FCNTL_H\n#include <fcntl.h>\n#endif\n#ifdef HAVE_SYS_STAT_H\n#include <sys/stat.h>\n#endif\n#if TIME_WITH_SYS_TIME\n# include <sys/time.h>\n# include <time.h>\n#else\n# if HAVE_SYS_TIME_H\n#  include <sys/time.h>\n# else\n#  include <time.h>\n# endif\n#endif /* TIME_WITH_SYS_TIME */\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n#if defined(__cplusplus) && defined(NO_CPLUSPLUS_ALLOCA)\n#undef HAVE_ALLOCA\n#undef HAVE_ALLOCA_H\n#endif\n#ifdef HAVE_ALLOCA_H\n#include <alloca.h>\n#endif\n\n#include <errno.h>\t\t\t\t/* Recommended by debian */\n/* We need the following to go around a problem with openssl on solaris */\n#if defined(HAVE_CRYPT_H)\n#include <crypt.h>\n#endif\n\n/* Add checking if we are using likely/unlikely wrong */\n#ifdef CHECK_UNLIKELY\nC_MODE_START\nextern void init_my_likely(), end_my_likely(FILE *);\nextern int my_likely_ok(const char *file_name, uint line);\nextern int my_likely_fail(const char *file_name, uint line);\nC_MODE_END\n\n#define likely(A) ((A) ? (my_likely_ok(__FILE__, __LINE__),1) : (my_likely_fail(__FILE__, __LINE__), 0))\n#define unlikely(A) ((A) ? (my_likely_fail(__FILE__, __LINE__),1) : (my_likely_ok(__FILE__, __LINE__), 0))\n/*\n  These macros should be used when the check fails often when running benchmarks but\n  we know for sure that the check is correct in a production environment\n*/\n#define checked_likely(A) (A)\n#define checked_unlikely(A) (A)\n#else\n/**\n  The semantics of builtin_expect() are that\n  1) its two arguments are long\n  2) it's likely that they are ==\n  Those of our likely(x) are that x can be bool/int/longlong/pointer.\n*/\n\n#define likely(x)\t__builtin_expect(((x) != 0),1)\n#define unlikely(x)\t__builtin_expect(((x) != 0),0)\n#define checked_likely(x) likely(x)\n#define checked_unlikely(x) unlikely(x)\n#endif /* CHECK_UNLIKELY */\n\n/*\n  A lot of our programs uses asserts, so better to always include it\n  This also fixes a problem when people uses DBUG_ASSERT without including\n  assert.h\n*/\n#include <assert.h>\n\n/* an assert that works at compile-time. only for constant expression */\n#ifdef _some_old_compiler_that_does_not_understand_the_construct_below_\n#define compile_time_assert(X)  do { } while(0)\n#else\n#define compile_time_assert(X)                                  \\\n  do                                                            \\\n  {                                                             \\\n    typedef char compile_time_assert[(X) ? 1 : -1] __attribute__((unused)); \\\n  } while(0)\n#endif\n\n/* Go around some bugs in different OS and compilers */\n#if defined (HPUX11) && defined(_LARGEFILE_SOURCE)\n#ifndef _LARGEFILE64_SOURCE\n#define _LARGEFILE64_SOURCE\n#endif\n#endif\n\n#if defined(_HPUX_SOURCE) && defined(HAVE_SYS_STREAM_H)\n#include <sys/stream.h>\t\t/* HPUX 10.20 defines ulong here. UGLY !!! */\n#define HAVE_ULONG\n#endif\n#if defined(HPUX10) && defined(_LARGEFILE64_SOURCE)\n/* Fix bug in setrlimit */\n#undef setrlimit\n#define setrlimit cma_setrlimit64\n#endif\n/* Declare madvise where it is not declared for C++, like Solaris */\n#if HAVE_MADVISE && !HAVE_DECL_MADVISE && defined(__cplusplus)\nextern \"C\" int madvise(void *addr, size_t len, int behav);\n#endif\n#ifdef HAVE_SYS_MMAN_H\n#include <sys/mman.h>\n#endif\n/** FreeBSD equivalent */\n#if defined(MADV_CORE) && !defined(MADV_DODUMP)\n#define MADV_DODUMP MADV_CORE\n#define MADV_DONTDUMP MADV_NOCORE\n#define DODUMP_STR \"MADV_CORE\"\n#define DONTDUMP_STR \"MADV_NOCORE\"\n#else\n#define DODUMP_STR \"MADV_DODUMP\"\n#define DONTDUMP_STR \"MADV_DONTDUMP\"\n#endif\n\n\n#define QUOTE_ARG(x)\t\t#x\t/* Quote argument (before cpp) */\n#define STRINGIFY_ARG(x) QUOTE_ARG(x)\t/* Quote argument, after cpp */\n\n/* Paranoid settings. Define I_AM_PARANOID if you are paranoid */\n#ifdef I_AM_PARANOID\n#define DONT_ALLOW_USER_CHANGE 1\n#define DONT_USE_MYSQL_PWD 1\n#endif\n\n/* Does the system remember a signal handler after a signal ? */\n#if !defined(HAVE_BSD_SIGNALS) && !defined(HAVE_SIGACTION)\n#define SIGNAL_HANDLER_RESET_ON_DELIVERY\n#endif\n\n/* don't assume that STDERR_FILENO is 2, mysqld can freopen */\n#undef STDERR_FILENO\n\n#ifndef SO_EXT\n#ifdef _WIN32\n#define SO_EXT \".dll\"\n#else\n#define SO_EXT \".so\"\n#endif\n#endif\n\n/*\n   Suppress uninitialized variable warning without generating code.\n*/\n#if defined(__GNUC__)\n/* GCC specific self-initialization which inhibits the warning. */\n#define UNINIT_VAR(x) x= x\n#elif defined(_lint) || defined(FORCE_INIT_OF_VARS)\n#define UNINIT_VAR(x) x= 0\n#else\n#define UNINIT_VAR(x) x\n#endif\n\n/* This is only to be used when resetting variables in a class constructor */\n#if defined(_lint) || defined(FORCE_INIT_OF_VARS)\n#define LINT_INIT(x) x= 0\n#else\n#define LINT_INIT(x)\n#endif\n\n#if !defined(HAVE_UINT)\n#undef HAVE_UINT\n#define HAVE_UINT\ntypedef unsigned int uint;\ntypedef unsigned short ushort;\n#endif\n\n#define swap_variables(t, a, b) do { t dummy; dummy= a; a= b; b= dummy; } while(0)\n#define MY_TEST(a) ((a) ? 1 : 0)\n#define set_if_bigger(a,b)  do { if ((a) < (b)) (a)=(b); } while(0)\n#define set_if_smaller(a,b) do { if ((a) > (b)) (a)=(b); } while(0)\n#define set_bits(type, bit_count) (sizeof(type)*8 <= (bit_count) ? ~(type) 0 : ((((type) 1) << (bit_count)) - (type) 1))\n#define test_all_bits(a,b) (((a) & (b)) == (b))\n#define array_elements(A) ((uint) (sizeof(A)/sizeof(A[0])))\n\n/* Define some general constants */\n#ifndef TRUE\n#define TRUE\t\t(1)\t/* Logical true */\n#define FALSE\t\t(0)\t/* Logical false */\n#endif\n\n#include <my_compiler.h>\n\n/*\n  Wen using the embedded library, users might run into link problems,\n  duplicate declaration of __cxa_pure_virtual, solved by declaring it a\n  weak symbol.\n*/\n#if defined(USE_MYSYS_NEW) && ! defined(DONT_DECLARE_CXA_PURE_VIRTUAL)\nC_MODE_START\nint __cxa_pure_virtual () __attribute__ ((weak));\nC_MODE_END\n#endif\n\n/* The DBUG_ON flag always takes precedence over default DBUG_OFF */\n#if defined(DBUG_ON) && defined(DBUG_OFF)\n#undef DBUG_OFF\n#endif\n\n/* We might be forced to turn debug off, if not turned off already */\n#if (defined(FORCE_DBUG_OFF) || defined(_lint)) && !defined(DBUG_OFF)\n#  define DBUG_OFF\n#  ifdef DBUG_ON\n#    undef DBUG_ON\n#  endif\n#endif\n\n#ifdef DBUG_OFF\n#undef EXTRA_DEBUG\n#endif\n\n/* Some types that is different between systems */\n\ntypedef int\tFile;\t\t/* File descriptor */\n#ifdef _WIN32\ntypedef SOCKET my_socket;\n#else\ntypedef int\tmy_socket;\t/* File descriptor for sockets */\n#define INVALID_SOCKET -1\n#endif\n/* Type for functions that handles signals */\n#define sig_handler RETSIGTYPE\nC_MODE_START\n#ifdef HAVE_SIGHANDLER_T\n#define sig_return sighandler_t\n#else\ntypedef void (*sig_return)(void); /* Returns type from signal */\n#endif\nC_MODE_END\n#if defined(__GNUC__) && !defined(_lint)\ntypedef char\tpchar;\t\t/* Mixed prototypes can take char */\ntypedef char\tpuchar;\t\t/* Mixed prototypes can take char */\ntypedef char\tpbool;\t\t/* Mixed prototypes can take char */\ntypedef short\tpshort;\t\t/* Mixed prototypes can take short int */\ntypedef float\tpfloat;\t\t/* Mixed prototypes can take float */\n#else\ntypedef int\tpchar;\t\t/* Mixed prototypes can't take char */\ntypedef uint\tpuchar;\t\t/* Mixed prototypes can't take char */\ntypedef int\tpbool;\t\t/* Mixed prototypes can't take char */\ntypedef int\tpshort;\t\t/* Mixed prototypes can't take short int */\ntypedef double\tpfloat;\t\t/* Mixed prototypes can't take float */\n#endif\nC_MODE_START\ntypedef int\t(*qsort_cmp)(const void *,const void *);\ntypedef int\t(*qsort_cmp2)(void*, const void *,const void *);\nC_MODE_END\n#define qsort_t RETQSORTTYPE\t/* Broken GCC can't handle typedef !!!! */\n#ifdef HAVE_SYS_SOCKET_H\n#include <sys/socket.h>\n#endif\ntypedef SOCKET_SIZE_TYPE size_socket;\n\n#ifndef SOCKOPT_OPTLEN_TYPE\n#define SOCKOPT_OPTLEN_TYPE size_socket\n#endif\n\n/* file create flags */\n\n#ifndef O_SHARE\t\t\t/* Probably not windows */\n#define O_SHARE\t\t0\t/* Flag to my_open for shared files */\n#ifndef O_BINARY\n#define O_BINARY\t0\t/* Flag to my_open for binary files */\n#endif\n#ifndef FILE_BINARY\n#define FILE_BINARY\tO_BINARY /* Flag to my_fopen for binary streams */\n#endif\n#ifdef HAVE_FCNTL\n#define HAVE_FCNTL_LOCK\n#define F_TO_EOF\t0L\t/* Param to lockf() to lock rest of file */\n#endif\n#endif /* O_SHARE */\n\n#ifndef O_SEQUENTIAL\n#define O_SEQUENTIAL\t0\n#endif\n#ifndef O_SHORT_LIVED\n#define O_SHORT_LIVED\t0\n#endif\n#ifndef O_NOFOLLOW\n#define O_NOFOLLOW      0\n#endif\n#ifndef O_CLOEXEC\n#define O_CLOEXEC       0\n#endif\n#ifdef __GLIBC__\n#define STR_O_CLOEXEC \"e\"\n#else\n#define STR_O_CLOEXEC \"\"\n#endif\n#ifndef SOCK_CLOEXEC\n#define SOCK_CLOEXEC    0\n#else\n#define HAVE_SOCK_CLOEXEC\n#endif\n\n/* additional file share flags for win32 */\n#ifdef __WIN__\n#define _SH_DENYRWD     0x110    /* deny read/write mode & delete */\n#define _SH_DENYWRD     0x120    /* deny write mode & delete      */\n#define _SH_DENYRDD     0x130    /* deny read mode & delete       */\n#define _SH_DENYDEL     0x140    /* deny delete only              */\n#endif /* __WIN__ */\n\n\n/* General constants */\n#define FN_LEN\t\t256\t/* Max file name len */\n#define FN_HEADLEN\t253\t/* Max length of filepart of file name */\n#define FN_EXTLEN\t20\t/* Max length of extension (part of FN_LEN) */\n#define FN_REFLEN\t512\t/* Max length of full path-name */\n#define FN_EXTCHAR\t'.'\n#define FN_HOMELIB\t'~'\t/* ~/ is used as abbrev for home dir */\n#define FN_CURLIB\t'.'\t/* ./ is used as abbrev for current dir */\n#define FN_PARENTDIR\t\"..\"\t/* Parent directory; Must be a string */\n\n#ifdef _WIN32\n#define FN_LIBCHAR\t'\\\\'\n#define FN_LIBCHAR2\t'/'\n#define FN_DIRSEP       \"/\\\\\"               /* Valid directory separators */\n#define FN_EXEEXT   \".exe\"\n#define FN_SOEXT    \".dll\"\n#define FN_ROOTDIR\t\"\\\\\"\n#define FN_DEVCHAR\t':'\n#define FN_NETWORK_DRIVES\t/* Uses \\\\ to indicate network drives */\n#define FN_NO_CASE_SENCE\t/* Files are not case-sensitive */\n#else\n#define FN_LIBCHAR\t'/'\n#define FN_LIBCHAR2\t'/'\n#define FN_DIRSEP       \"/\"     /* Valid directory separators */\n#define FN_EXEEXT   \"\"\n#define FN_SOEXT    \".so\"\n#define FN_ROOTDIR\t\"/\"\n#endif\n\n/* \n  MY_FILE_MIN is  Windows speciality and is used to quickly detect\n  the mismatch of CRT and mysys file IO usage on Windows at runtime.\n  CRT file descriptors can be in the range 0-2047, whereas descriptors returned\n  by my_open() will start with 2048. If a file descriptor with value less then\n  MY_FILE_MIN is passed to mysys IO function, chances are it stemms from\n  open()/fileno() and not my_open()/my_fileno.\n\n  For Posix,  mysys functions are light wrappers around libc, and MY_FILE_MIN\n  is logically 0.\n*/\n\n#ifdef _WIN32\n#define MY_FILE_MIN  2048\n#else\n#define MY_FILE_MIN  0\n#endif\n\n/* \n  MY_NFILE is the default size of my_file_info array.\n\n  It is larger on Windows, because it all file handles are stored in my_file_info\n  Default size is 16384 and this should be enough for most cases.If it is not \n  enough, --max-open-files with larger value can be used.\n\n  For Posix , my_file_info array is only used to store filenames for\n  error reporting and its size is not a limitation for number of open files.\n*/ \n#ifdef _WIN32\n#define MY_NFILE (16384 + MY_FILE_MIN)\n#else\n#define MY_NFILE 64\n#endif\n\n#ifndef OS_FILE_LIMIT\n#define OS_FILE_LIMIT\tUINT_MAX\n#endif\n\n/*\n  Io buffer size; Must be a power of 2 and a multiple of 512. May be\n  smaller what the disk page size. This influences the speed of the\n  isam btree library. eg to big to slow.\n*/\n#define IO_SIZE\t\t\t4096U\n/*\n  How much overhead does malloc have. The code often allocates\n  something like 1024-MALLOC_OVERHEAD bytes\n*/\n#define MALLOC_OVERHEAD 8\n\n\t/* get memory in huncs */\n#define ONCE_ALLOC_INIT\t\t(uint) 4096\n\t/* Typical record cache */\n#define RECORD_CACHE_SIZE\t(uint) (128*1024)\n\t/* Typical key cache */\n#define KEY_CACHE_SIZE\t\t(uint) (128L*1024L*1024L)\n\t/* Default size of a key cache block  */\n#define KEY_CACHE_BLOCK_SIZE\t(uint) 1024\n\n\t/* Some things that this system doesn't have */\n\n#ifdef _WIN32\n#define NO_DIR_LIBRARY\t\t/* Not standard dir-library */\n#endif\n\n/* Some defines of functions for portability */\n\n#undef remove\t\t/* Crashes MySQL on SCO 5.0.0 */\n#ifndef __WIN__\n#define closesocket(A)\tclose(A)\n#endif\n\n#if defined(_MSC_VER)\n#if !defined(_WIN64)\ninline double my_ulonglong2double(unsigned long long value)\n{\n  long long nr=(long long) value;\n  if (nr >= 0)\n    return (double) nr;\n  return (18446744073709551616.0 + (double) nr);\n}\n#define ulonglong2double my_ulonglong2double\n#define my_off_t2double  my_ulonglong2double\n#endif /* _WIN64 */\ninline unsigned long long my_double2ulonglong(double d)\n{\n  double t= d - (double) 0x8000000000000000ULL;\n\n  if (t >= 0)\n    return  ((unsigned long long) t) + 0x8000000000000000ULL;\n  return (unsigned long long) d;\n}\n#define double2ulonglong my_double2ulonglong\n#endif\n\n#ifndef ulonglong2double\n#define ulonglong2double(A) ((double) (ulonglong) (A))\n#define my_off_t2double(A)  ((double) (my_off_t) (A))\n#endif\n#ifndef double2ulonglong\n#define double2ulonglong(A) ((ulonglong) (double) (A))\n#endif\n\n#ifndef offsetof\n#define offsetof(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)\n#endif\n#define ulong_to_double(X) ((double) (ulong) (X))\n\n#ifndef STACK_DIRECTION\n#error \"please add -DSTACK_DIRECTION=1 or -1 to your CPPFLAGS\"\n#endif\n\n#if !defined(HAVE_STRTOK_R)\n#define strtok_r(A,B,C) strtok((A),(B))\n#endif\n\n#if SIZEOF_LONG_LONG >= 8\n#define HAVE_LONG_LONG 1\n#else\n#error WHAT? sizeof(long long) < 8 ???\n#endif\n\n/*\n  Some pre-ANSI-C99 systems like AIX 5.1 and Linux/GCC 2.95 define\n  ULONGLONG_MAX, LONGLONG_MIN, LONGLONG_MAX; we use them if they're defined.\n*/\n\n#if defined(HAVE_LONG_LONG) && !defined(LONGLONG_MIN)\n#define LONGLONG_MIN\t((long long) 0x8000000000000000LL)\n#define LONGLONG_MAX\t((long long) 0x7FFFFFFFFFFFFFFFLL)\n#endif\n\n#if defined(HAVE_LONG_LONG) && !defined(ULONGLONG_MAX)\n/* First check for ANSI C99 definition: */\n#ifdef ULLONG_MAX\n#define ULONGLONG_MAX  ULLONG_MAX\n#else\n#define ULONGLONG_MAX ((unsigned long long)(~0ULL))\n#endif\n#endif /* defined (HAVE_LONG_LONG) && !defined(ULONGLONG_MAX)*/\n\n#define INT_MIN64       (~0x7FFFFFFFFFFFFFFFLL)\n#define INT_MAX64       0x7FFFFFFFFFFFFFFFLL\n#define INT_MIN32       (~0x7FFFFFFFL)\n#define INT_MAX32       0x7FFFFFFFL\n#define UINT_MAX32      0xFFFFFFFFL\n#define INT_MIN24       (~0x007FFFFF)\n#define INT_MAX24       0x007FFFFF\n#define UINT_MAX24      0x00FFFFFF\n#define INT_MIN16       (~0x7FFF)\n#define INT_MAX16       0x7FFF\n#define UINT_MAX16      0xFFFF\n#define INT_MIN8        (~0x7F)\n#define INT_MAX8        0x7F\n#define UINT_MAX8       0xFF\n\n/* From limits.h instead */\n#ifndef DBL_MIN\n#define DBL_MIN\t\t4.94065645841246544e-324\n#define FLT_MIN\t\t((float)1.40129846432481707e-45)\n#endif\n#ifndef DBL_MAX\n#define DBL_MAX\t\t1.79769313486231470e+308\n#define FLT_MAX\t\t((float)3.40282346638528860e+38)\n#endif\n#ifndef SIZE_T_MAX\n#define SIZE_T_MAX      (~((size_t) 0))\n#endif\n\n/* Define missing math constants. */\n#ifndef M_PI\n#define M_PI 3.14159265358979323846\n#endif\n#ifndef M_E\n#define M_E 2.7182818284590452354\n#endif\n#ifndef M_LN2\n#define M_LN2 0.69314718055994530942\n#endif\n\n/*\n  Max size that must be added to a so that we know Size to make\n  addressable obj.\n*/\n#if SIZEOF_CHARP == 4\ntypedef long\t\tmy_ptrdiff_t;\n#else\ntypedef long long\tmy_ptrdiff_t;\n#endif\n\n#define MY_ALIGN(A,L)\t   (((A) + (L) - 1) & ~((L) - 1))\n#define MY_ALIGN_DOWN(A,L) ((A) & ~((L) - 1))\n#define ALIGN_SIZE(A)\tMY_ALIGN((A),sizeof(double))\n#define ALIGN_MAX_UNIT  (sizeof(double))\n/* Size to make addressable obj. */\n#define ALIGN_PTR(A, t) ((t*) MY_ALIGN((A), sizeof(double)))\n#define ADD_TO_PTR(ptr,size,type) (type) ((uchar*) (ptr)+size)\n#define PTR_BYTE_DIFF(A,B) (my_ptrdiff_t) ((uchar*) (A) - (uchar*) (B))\n#define PREV_BITS(type,A)\t((type) (((type) 1 << (A)) -1))\n\n/*\n  Custom version of standard offsetof() macro which can be used to get\n  offsets of members in class for non-POD types (according to the current\n  version of C++ standard offsetof() macro can't be used in such cases and\n  attempt to do so causes warnings to be emitted, OTOH in many cases it is\n  still OK to assume that all instances of the class has the same offsets\n  for the same members).\n\n  This is temporary solution which should be removed once File_parser class\n  and related routines are refactored.\n*/\n\n#define my_offsetof(TYPE, MEMBER) PTR_BYTE_DIFF(&((TYPE *)0x10)->MEMBER, 0x10)\n\n#define NullS\t\t(char *) 0\n\n#ifdef STDCALL\n#undef STDCALL\n#endif\n\n#ifdef _WIN32\n#define STDCALL __stdcall\n#else\n#define STDCALL\n#endif\n\n/* Typdefs for easyier portability */\n\n#ifndef HAVE_UCHAR\ntypedef unsigned char\tuchar;\t/* Short for unsigned char */\n#endif\n\n#ifndef HAVE_INT8\ntypedef signed char int8;       /* Signed integer >= 8  bits */\n#endif\n#ifndef HAVE_UINT8\ntypedef unsigned char uint8;    /* Unsigned integer >= 8  bits */\n#endif\n#ifndef HAVE_INT16\ntypedef short int16;\n#endif\n#ifndef HAVE_UINT16\ntypedef unsigned short uint16;\n#endif\n#if SIZEOF_INT == 4\n#ifndef HAVE_INT32\ntypedef int int32;\n#endif\n#ifndef HAVE_UINT32\ntypedef unsigned int uint32;\n#endif\n#elif SIZEOF_LONG == 4\n#ifndef HAVE_INT32\ntypedef long int32;\n#endif\n#ifndef HAVE_UINT32\ntypedef unsigned long uint32;\n#endif\n#else\n#error Neither int or long is of 4 bytes width\n#endif\n\n#if !defined(HAVE_ULONG) && !defined(__USE_MISC)\ntypedef unsigned long\tulong;\t\t  /* Short for unsigned long */\n#endif\n#ifndef longlong_defined\n/* \n  Using [unsigned] long long is preferable as [u]longlong because we use \n  [unsigned] long long unconditionally in many places, \n  for example in constants with [U]LL suffix.\n*/\n#if defined(HAVE_LONG_LONG) && SIZEOF_LONG_LONG == 8\ntypedef unsigned long long int ulonglong; /* ulong or unsigned long long */\ntypedef long long int\tlonglong;\n#else\ntypedef unsigned long\tulonglong;\t  /* ulong or unsigned long long */\ntypedef long\t\tlonglong;\n#endif\n#endif\n#ifndef HAVE_INT64\ntypedef longlong int64;\n#endif\n#ifndef HAVE_UINT64\ntypedef ulonglong uint64;\n#endif\n\n#if defined(NO_CLIENT_LONG_LONG)\ntypedef unsigned long my_ulonglong;\n#elif defined (__WIN__)\ntypedef unsigned __int64 my_ulonglong;\n#else\ntypedef unsigned long long my_ulonglong;\n#endif\n\n#if SIZEOF_CHARP == SIZEOF_INT\ntypedef unsigned int intptr;\n#elif SIZEOF_CHARP == SIZEOF_LONG\ntypedef unsigned long intptr;\n#elif SIZEOF_CHARP == SIZEOF_LONG_LONG\ntypedef unsigned long long intptr;\n#else\n#error sizeof(void *) is neither sizeof(int) nor sizeof(long) nor sizeof(long long)\n#endif\n\n#define MY_ERRPTR ((void*)(intptr)1)\n\n#if defined(_WIN32)\ntypedef unsigned long long my_off_t;\ntypedef unsigned long long os_off_t;\n#else\ntypedef off_t os_off_t;\n#if SIZEOF_OFF_T > 4\ntypedef ulonglong my_off_t;\n#else\ntypedef unsigned long my_off_t;\n#endif\n#endif /*_WIN32*/\n#define MY_FILEPOS_ERROR\t(~(my_off_t) 0)\n\n/*\n  TODO Convert these to use Bitmap class.\n */\ntypedef ulonglong table_map;          /* Used for table bits in join */\n\n/* often used type names - opaque declarations */\ntypedef const struct charset_info_st CHARSET_INFO;\ntypedef struct st_mysql_lex_string LEX_STRING;\n\n#if defined(__WIN__)\n#define socket_errno\tWSAGetLastError()\n#define SOCKET_EINTR\tWSAEINTR\n#define SOCKET_ETIMEDOUT WSAETIMEDOUT\n#define SOCKET_EWOULDBLOCK WSAEWOULDBLOCK\n#define SOCKET_EADDRINUSE WSAEADDRINUSE\n#define SOCKET_ECONNRESET WSAECONNRESET\n#define SOCKET_ENFILE\tENFILE\n#define SOCKET_EMFILE\tEMFILE\n#else /* Unix */\n#define socket_errno\terrno\n#define closesocket(A)\tclose(A)\n#define SOCKET_EINTR\tEINTR\n#define SOCKET_EAGAIN\tEAGAIN\n#define SOCKET_EWOULDBLOCK EWOULDBLOCK\n#define SOCKET_EADDRINUSE EADDRINUSE\n#define SOCKET_ETIMEDOUT ETIMEDOUT\n#define SOCKET_ECONNRESET ECONNRESET\n#define SOCKET_ENFILE\tENFILE\n#define SOCKET_EMFILE\tEMFILE\n#endif\n\n#include <mysql/plugin.h>  /* my_bool */\n\ntypedef ulong\t\tmyf;\t/* Type of MyFlags in my_funcs */\n\n#define MYF(v)\t\t(myf) (v)\n\n/*\n  Defines to make it possible to prioritize register assignments. No\n  longer that important with modern compilers.\n*/\n#ifndef USING_X\n#define reg1 register\n#define reg2 register\n#define reg3 register\n#define reg4 register\n#define reg5 register\n#define reg6 register\n#define reg7 register\n#define reg8 register\n#define reg9 register\n#define reg10 register\n#define reg11 register\n#define reg12 register\n#define reg13 register\n#define reg14 register\n#define reg15 register\n#define reg16 register\n#endif\n\n/*\n  MYSQL_PLUGIN_IMPORT macro is used to export mysqld data\n  (i.e variables) for usage in storage engine loadable plugins.\n  Outside of Windows, it is dummy.\n*/\n#ifndef MYSQL_PLUGIN_IMPORT\n#if (defined(_WIN32) && defined(MYSQL_DYNAMIC_PLUGIN))\n#define MYSQL_PLUGIN_IMPORT __declspec(dllimport)\n#else\n#define MYSQL_PLUGIN_IMPORT\n#endif\n#endif\n\n#include <my_dbug.h>\n\n/* Some helper macros */\n#define YESNO(X) ((X) ? \"yes\" : \"no\")\n\n#define MY_HOW_OFTEN_TO_ALARM\t2\t/* How often we want info on screen */\n#define MY_HOW_OFTEN_TO_WRITE\t10000\t/* How often we want info on screen */\n\n#include <my_byteorder.h>\n\n#ifdef HAVE_CHARSET_utf8mb4\n#define MYSQL_UNIVERSAL_CLIENT_CHARSET \"utf8mb4\"\n#elif defined(HAVE_CHARSET_utf8)\n#define MYSQL_UNIVERSAL_CLIENT_CHARSET \"utf8\"\n#else\n#define MYSQL_UNIVERSAL_CLIENT_CHARSET MYSQL_DEFAULT_CHARSET_NAME\n#endif\n\n#if defined(EMBEDDED_LIBRARY) && !defined(HAVE_EMBEDDED_PRIVILEGE_CONTROL)\n#define NO_EMBEDDED_ACCESS_CHECKS\n#endif\n\n#ifdef _WIN32\n#define dlsym(lib, name) (void*)GetProcAddress((HMODULE)lib, name)\n#define dlopen(libname, unused) LoadLibraryEx(libname, NULL, 0)\n#define RTLD_DEFAULT GetModuleHandle(NULL)\n#define dlclose(lib) FreeLibrary((HMODULE)lib)\nstatic inline char *dlerror(void)\n{\n  static char win_errormsg[2048];\n  FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM,\n    0, GetLastError(), 0, win_errormsg, 2048, NULL);\n  return win_errormsg;\n}\n#define HAVE_DLOPEN 1\n#define HAVE_DLERROR 1\n#endif\n\n#ifdef HAVE_DLFCN_H\n#include <dlfcn.h>\n#endif\n\n#ifdef HAVE_DLOPEN\n#ifndef HAVE_DLERROR\n#define dlerror() \"\"\n#endif\n#ifndef HAVE_DLADDR\n#define dladdr(A, B) 0\n/* Dummy definition in case we're missing dladdr() */\ntypedef struct { const char *dli_fname, dli_fbase; } Dl_info;\n#endif\n#else\n#define dlerror() \"No support for dynamic loading (static build?)\"\n#define dlopen(A,B) 0\n#define dlsym(A,B) 0\n#define dlclose(A) 0\n#define dladdr(A, B) 0\n/* Dummy definition in case we're missing dladdr() */\ntypedef struct { const char *dli_fname, dli_fbase; } Dl_info;\n#endif\n\n/*\n *  Include standard definitions of operator new and delete.\n */\n#ifdef __cplusplus\n#include <new>\n#endif\n\n/* Length of decimal number represented by INT32. */\n#define MY_INT32_NUM_DECIMAL_DIGITS 11\n\n/* Length of decimal number represented by INT64. */\n#define MY_INT64_NUM_DECIMAL_DIGITS 21\n\n#ifdef __cplusplus\n#include <limits> /* should be included before min/max macros */\n#endif\n\n/* Define some useful general macros (should be done after all headers). */\n#define MY_MAX(a, b)\t((a) > (b) ? (a) : (b))\n#define MY_MIN(a, b)\t((a) < (b) ? (a) : (b))\n\n#define CMP_NUM(a,b)    (((a) < (b)) ? -1 : ((a) == (b)) ? 0 : 1)\n\n/*\n  Only Linux is known to need an explicit sync of the directory to make sure a\n  file creation/deletion/renaming in(from,to) this directory durable.\n*/\n#ifdef TARGET_OS_LINUX\n#define NEED_EXPLICIT_SYNC_DIR 1\n#else\n/*\n  On linux default rwlock scheduling policy is good enough for\n  waiting_threads.c, on other systems use our special implementation\n  (which is slower).\n\n  QQ perhaps this should be tested in configure ? how ?\n*/\n#define WT_RWLOCKS_USE_MUTEXES 1\n#endif\n\n#if !defined(__cplusplus) && !defined(bool)\n#define bool In_C_you_should_use_my_bool_instead()\n#endif\n\n/* Provide __func__ macro definition for platforms that miss it. */\n#if !defined (__func__)\n#if defined(__STDC_VERSION__) && __STDC_VERSION__ < 199901L\n#  if __GNUC__ >= 2\n#    define __func__ __FUNCTION__\n#  else\n#    define __func__ \"<unknown>\"\n#  endif\n#elif defined(_MSC_VER)\n#  if _MSC_VER < 1300\n#    define __func__ \"<unknown>\"\n#  else\n#    define __func__ __FUNCTION__\n#  endif\n#elif defined(__BORLANDC__)\n#  define __func__ __FUNC__\n#else\n#  define __func__ \"<unknown>\"\n#endif\n#endif /* !defined(__func__) */\n\n/* Defines that are unique to the embedded version of MySQL */\n\n#ifdef EMBEDDED_LIBRARY\n\n/* Things we don't need in the embedded version of MySQL */\n/* TODO HF add #undef HAVE_VIO if we don't want client in embedded library */\n\n#else\n#define HAVE_REPLICATION\n#define HAVE_EXTERNAL_CLIENT\n#endif /* EMBEDDED_LIBRARY */\n\n/* Workaround for _LARGE_FILES and _LARGE_FILE_API incompatibility on AIX */\n#if defined(_AIX) && defined(_LARGE_FILE_API)\n#undef _LARGE_FILE_API\n#undef __GNUG__\n#endif\n\n/*\n  Provide defaults for the CPU cache line size, if it has not been detected by\n  CMake using getconf\n*/\n#if !defined(CPU_LEVEL1_DCACHE_LINESIZE) || CPU_LEVEL1_DCACHE_LINESIZE == 0\n  #if defined(CPU_LEVEL1_DCACHE_LINESIZE) && CPU_LEVEL1_DCACHE_LINESIZE == 0\n    #undef CPU_LEVEL1_DCACHE_LINESIZE\n  #endif\n\n  #if defined(__s390__)\n    #define CPU_LEVEL1_DCACHE_LINESIZE 256\n  #elif defined(__powerpc__) || defined(__aarch64__)\n    #define CPU_LEVEL1_DCACHE_LINESIZE 128\n  #else\n    #define CPU_LEVEL1_DCACHE_LINESIZE 64\n  #endif\n#endif\n\n#define FLOATING_POINT_DECIMALS 31\n\n/* Keep client compatible with earlier versions */\n#ifdef MYSQL_SERVER\n#define NOT_FIXED_DEC           DECIMAL_NOT_SPECIFIED\n#else\n#define NOT_FIXED_DEC           FLOATING_POINT_DECIMALS\n#endif\n#endif /* my_global_h */\n",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/wolfcrypt/src/wc_pkcs11.c": "/* wc_pkcs11.c\n *\n * Copyright (C) 2006-2019 wolfSSL Inc.\n *\n * This file is part of wolfSSL.\n *\n * wolfSSL is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * wolfSSL is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1335, USA\n */\n\n#ifdef HAVE_CONFIG_H\n    #include <config.h>\n#endif\n\n#include <wolfssl/wolfcrypt/settings.h>\n\n#ifdef HAVE_PKCS11\n\n#include <dlfcn.h>\n\n#include <wolfssl/wolfcrypt/wc_pkcs11.h>\n#include <wolfssl/wolfcrypt/error-crypt.h>\n#include <wolfssl/wolfcrypt/asn.h>\n#include <wolfssl/wolfcrypt/logging.h>\n#ifndef NO_RSA\n    #include <wolfssl/wolfcrypt/rsa.h>\n#endif\n#ifdef NO_INLINE\n    #include <wolfssl/wolfcrypt/misc.h>\n#else\n    #define WOLFSSL_MISC_INCLUDED\n    #include <wolfcrypt/src/misc.c>\n#endif\n\n#define MAX_EC_PARAM_LEN   16\n\n#if defined(NO_PKCS11_RSA) && !defined(NO_RSA)\n    #define NO_RSA\n#endif\n#if defined(NO_PKCS11_ECC) && defined(HAVE_ECC)\n    #undef HAVE_ECC\n#endif\n#if defined(NO_PKCS11_AES) && !defined(NO_AES)\n    #define NO_AES\n#endif\n#if defined(NO_PKCS11_AESGCM) && defined(HAVE_AESGCM)\n    #undef HAVE_AESGCM\n#endif\n#if defined(NO_PKCS11_AESCBC) && defined(HAVE_AES_CBC)\n    #undef HAVE_AES_CBC\n#endif\n#if defined(NO_PKCS11_HMAC) && !defined(NO_HMAC)\n    #define NO_HMAC\n#endif\n#if defined(NO_PKCS11_RNG) && !defined(WC_NO_RNG)\n    #define WC_NO_RNG\n#endif\n\n\n#if defined(HAVE_ECC) && !defined(NO_PKCS11_ECDH)\nstatic CK_BBOOL ckFalse = CK_FALSE;\n#endif\n#if !defined(NO_RSA) || defined(HAVE_ECC) || (!defined(NO_AES) && \\\n           (defined(HAVE_AESGCM) || defined(HAVE_AES_CBC))) || !defined(NO_HMAC)\nstatic CK_BBOOL ckTrue  = CK_TRUE;\n#endif\n\n#ifndef NO_RSA\nstatic CK_KEY_TYPE rsaKeyType  = CKK_RSA;\n#endif\n#ifdef HAVE_ECC\nstatic CK_KEY_TYPE ecKeyType   = CKK_EC;\n#endif\n#if !defined(NO_RSA) || defined(HAVE_ECC)\nstatic CK_OBJECT_CLASS pubKeyClass     = CKO_PUBLIC_KEY;\nstatic CK_OBJECT_CLASS privKeyClass    = CKO_PRIVATE_KEY;\n#endif\n#if (!defined(NO_AES) && (defined(HAVE_AESGCM) || defined(HAVE_AES_CBC))) || \\\n            !defined(NO_HMAC) || (defined(HAVE_ECC) && !defined(NO_PKCS11_ECDH))\nstatic CK_OBJECT_CLASS secretKeyClass  = CKO_SECRET_KEY;\n#endif\n\n/**\n * Load library, get function list and initialize PKCS#11.\n *\n * @param  dev     [in]  Device object.\n * @param  library [in]  Library name including path.\n * @return  BAD_FUNC_ARG when dev or library are NULL pointers.\n *          BAD_PATH_ERROR when dynamic library cannot be opened.\n *          WC_INIT_E when the initialization PKCS#11 fails.\n *          WC_HW_E when unable to get PKCS#11 function list.\n *          0 on success.\n */\nint wc_Pkcs11_Initialize(Pkcs11Dev* dev, const char* library, void* heap)\n{\n    int                  ret = 0;\n    void*                func;\n    CK_C_INITIALIZE_ARGS args;\n\n    if (dev == NULL || library == NULL)\n        ret = BAD_FUNC_ARG;\n\n    if (ret == 0) {\n        dev->heap = heap;\n        dev->dlHandle = dlopen(library, RTLD_NOW | RTLD_LOCAL);\n        if (dev->dlHandle == NULL) {\n            WOLFSSL_MSG(dlerror());\n            ret = BAD_PATH_ERROR;\n        }\n    }\n\n    if (ret == 0) {\n        dev->func = NULL;\n        func = dlsym(dev->dlHandle, \"C_GetFunctionList\");\n        if (func == NULL)\n            ret = WC_HW_E;\n    }\n    if (ret == 0) {\n        if (((CK_C_GetFunctionList)func)(&dev->func) != CKR_OK)\n            ret = WC_HW_E;\n    }\n\n    if (ret == 0) {\n        XMEMSET(&args, 0x00, sizeof(args));\n        args.flags = CKF_OS_LOCKING_OK;\n        if (dev->func->C_Initialize(&args) != CKR_OK)\n            ret = WC_INIT_E;\n    }\n\n    if (ret != 0)\n        wc_Pkcs11_Finalize(dev);\n\n    return ret;\n}\n\n/**\n * Close the Pkcs#11 library.\n *\n * @param  dev  [in]  Device object.\n */\nvoid wc_Pkcs11_Finalize(Pkcs11Dev* dev)\n{\n    if (dev != NULL && dev->dlHandle != NULL) {\n        if (dev->func != NULL) {\n            dev->func->C_Finalize(NULL);\n            dev->func = NULL;\n        }\n        dlclose(dev->dlHandle);\n        dev->dlHandle = NULL;\n    }\n}\n\n/**\n * Set up a token for use.\n *\n * @param  token      [in]  Token object.\n * @param  dev        [in]  PKCS#11 device object.\n * @param  slotId     [in]  Slot number of the token.<br>\n *                          Passing -1 uses the first available slot.\n * @param  tokenName  [in]  Name of token to initialize.\n * @param  userPin    [in]  PIN to use to login as user.\n * @param  userPinSz  [in]  Number of bytes in PIN.\n * @return  BAD_FUNC_ARG when token, dev and/or tokenName is NULL.\n *          WC_INIT_E when initializing token fails.\n *          WC_HW_E when another PKCS#11 library call fails.\n *          -1 when no slot available.\n *          0 on success.\n */\nint wc_Pkcs11Token_Init(Pkcs11Token* token, Pkcs11Dev* dev, int slotId,\n    const char* tokenName, const unsigned char* userPin, int userPinSz)\n{\n    int         ret = 0;\n    CK_RV       rv;\n    CK_SLOT_ID* slot = NULL;\n    CK_ULONG    slotCnt = 0;\n\n    if (token == NULL || dev == NULL || tokenName == NULL)\n        ret = BAD_FUNC_ARG;\n\n    if (ret == 0) {\n        if (slotId < 0) {\n            /* Use first available slot with a token. */\n            rv = dev->func->C_GetSlotList(CK_TRUE, NULL, &slotCnt);\n            if (rv != CKR_OK)\n                ret = WC_HW_E;\n            if (ret == 0) {\n                slot = (CK_SLOT_ID*)XMALLOC(slotCnt * sizeof(*slot), dev->heap,\n                                                       DYNAMIC_TYPE_TMP_BUFFER);\n                if (slot == NULL)\n                    ret = MEMORY_E;\n            }\n            if (ret == 0) {\n                rv = dev->func->C_GetSlotList(CK_TRUE, slot, &slotCnt);\n                if (rv != CKR_OK)\n                    ret = WC_HW_E;\n            }\n            if (ret == 0) {\n                if (slotCnt > 0)\n                    slotId = (int)slot[0];\n                else\n                    ret = WC_HW_E;\n            }\n        }\n    }\n    if (ret == 0) {\n        token->func = dev->func;\n        token->slotId = (CK_SLOT_ID)slotId;\n        token->handle = NULL_PTR;\n        token->userPin = (CK_UTF8CHAR_PTR)userPin;\n        token->userPinSz = (CK_ULONG)userPinSz;\n    }\n\n    if (slot != NULL)\n        XFREE(slot, dev->heap, DYNAMIC_TYPE_TMP_BUFFER);\n\n    return ret;\n}\n\n/**\n * Finalize token.\n * Closes all sessions on token.\n *\n * @param  token  [in]  Token object.\n */\nvoid wc_Pkcs11Token_Final(Pkcs11Token* token)\n{\n    if (token != NULL && token->func != NULL) {\n        token->func->C_CloseAllSessions(token->slotId);\n        token->handle = NULL_PTR;\n        ForceZero(token->userPin, (word32)token->userPinSz);\n    }\n}\n\n/**\n * Open a session on a token.\n *\n * @param  token      [in]  Token object.\n * @param  session    [in]  Session object.\n * @param  readWrite  [in]  Boolean indicating to open session for Read/Write.\n * @return  BAD_FUNC_ARG when token or session is NULL.\n *          WC_HW_E when opening the session fails.\n *          0 on success.\n */\nstatic int Pkcs11OpenSession(Pkcs11Token* token, Pkcs11Session* session,\n                             int readWrite)\n{\n    int   ret = 0;\n    CK_RV rv;\n\n    if (token == NULL || session == NULL)\n        ret = BAD_FUNC_ARG;\n\n    if (ret == 0) {\n        if (token->handle != NULL_PTR)\n            session->handle = token->handle;\n        else {\n            /* Create a new session. */\n            CK_FLAGS flags = CKF_SERIAL_SESSION;\n\n            if (readWrite)\n                flags |= CKF_RW_SESSION;\n\n            rv = token->func->C_OpenSession(token->slotId, flags,\n                                            (CK_VOID_PTR)NULL, (CK_NOTIFY)NULL,\n                                            &session->handle);\n            if (rv != CKR_OK)\n                ret = WC_HW_E;\n            if (ret == 0 && token->userPin != NULL) {\n                rv = token->func->C_Login(session->handle, CKU_USER,\n                                              token->userPin, token->userPinSz);\n                if (rv != CKR_OK)\n                    ret = WC_HW_E;\n            }\n        }\n    }\n    if (ret == 0) {\n        session->func = token->func;\n        session->slotId = token->slotId;\n    }\n\n    return ret;\n}\n\n/**\n * Close a session on a token.\n * Won't close a session created externally.\n *\n * @param  token    [in]  Token object.\n * @param  session  [in]  Session object.\n */\nstatic void Pkcs11CloseSession(Pkcs11Token* token, Pkcs11Session* session)\n{\n    if (token != NULL && session != NULL && token->handle != session->handle) {\n        if (token->userPin != NULL)\n            session->func->C_Logout(session->handle);\n        session->func->C_CloseSession(session->handle);\n    }\n}\n\n/**\n * Open a session on the token to be used for all operations.\n *\n * @param  token      [in]  Token object.\n * @param  readWrite  [in]  Boolean indicating to open session for Read/Write.\n * @return  BAD_FUNC_ARG when token is NULL.\n *          WC_HW_E when opening the session fails.\n *          0 on success.\n */\nint wc_Pkcs11Token_Open(Pkcs11Token* token, int readWrite)\n{\n    int ret = 0;\n    Pkcs11Session session;\n\n    if (token == NULL)\n        ret = BAD_FUNC_ARG;\n\n    if (ret == 0) {\n        ret = Pkcs11OpenSession(token, &session, readWrite);\n        token->handle = session.handle;\n    }\n\n    return ret;\n}\n\n/**\n * Close the token's session.\n * All object, like keys, will be destoyed.\n *\n * @param  token    [in]  Token object.\n */\nvoid wc_Pkcs11Token_Close(Pkcs11Token* token)\n{\n    Pkcs11Session session;\n\n    if (token != NULL) {\n        session.func = token->func;\n        session.handle = token->handle;\n        token->handle = NULL_PTR;\n        Pkcs11CloseSession(token, &session);\n    }\n}\n\n\n#if (!defined(NO_AES) && (defined(HAVE_AESGCM) || defined(HAVE_AES_CBC))) || \\\n                                                               !defined(NO_HMAC)\nstatic int Pkcs11CreateSecretKey(CK_OBJECT_HANDLE* key, Pkcs11Session* session,\n                                 CK_KEY_TYPE keyType, unsigned char* data,\n                                 int len, unsigned char* id, int idLen)\n{\n    int              ret = 0;\n    CK_RV            rv;\n    CK_ATTRIBUTE     keyTemplate[] = {\n        { CKA_CLASS,    &secretKeyClass, sizeof(secretKeyClass) },\n        { CKA_KEY_TYPE, &keyType,        sizeof(keyType)        },\n        { CKA_ENCRYPT,  &ckTrue,         sizeof(ckTrue)         },\n        { CKA_VALUE,    NULL,            0                      },\n        { CKA_ID,       id,              (CK_ULONG)idLen        }\n    };\n    int              keyTmplCnt = 4;\n\n    WOLFSSL_MSG(\"PKCS#11: Create Secret Key\");\n\n    /* Set the modulus and public exponent data. */\n    keyTemplate[3].pValue     = data;\n    keyTemplate[3].ulValueLen = (CK_ULONG)len;\n\n    if (idLen > 0)\n        keyTmplCnt++;\n\n    /* Create an object containing key data for device to use. */\n    rv = session->func->C_CreateObject(session->handle, keyTemplate, keyTmplCnt,\n                                                                           key);\n    if (rv != CKR_OK)\n        ret = WC_HW_E;\n\n    return ret;\n}\n#endif\n\n#ifndef NO_RSA\n/**\n * Create a PKCS#11 object containing the RSA private key data.\n *\n * @param  privateKey [out]  Henadle to private key object.\n * @param  session    [in]   Session object.\n * @param  rsaKey     [in]   RSA key with private key data.\n * @return  WC_HW_E when a PKCS#11 library call fails.\n *          0 on success.\n */\nstatic int Pkcs11CreateRsaPrivateKey(CK_OBJECT_HANDLE* privateKey,\n                                     Pkcs11Session* session,\n                                     RsaKey* rsaKey)\n{\n    int             ret = 0;\n    CK_RV           rv;\n    CK_ATTRIBUTE    keyTemplate[] = {\n        { CKA_CLASS,            &privKeyClass, sizeof(privKeyClass) },\n        { CKA_KEY_TYPE,         &rsaKeyType,   sizeof(rsaKeyType)   },\n        { CKA_DECRYPT,          &ckTrue,       sizeof(ckTrue)       },\n        { CKA_MODULUS,          NULL,          0                    },\n        { CKA_PRIVATE_EXPONENT, NULL,          0                    },\n        { CKA_PRIME_1,          NULL,          0                    },\n        { CKA_PRIME_2,          NULL,          0                    },\n        { CKA_EXPONENT_1,       NULL,          0                    },\n        { CKA_EXPONENT_2,       NULL,          0                    },\n        { CKA_COEFFICIENT,      NULL,          0                    },\n        { CKA_PUBLIC_EXPONENT,  NULL,          0                    }\n    };\n    CK_ULONG        keyTmplCnt = sizeof(keyTemplate) / sizeof(*keyTemplate);\n\n    /* Set the modulus and private key data. */\n    keyTemplate[ 3].pValue     = rsaKey->n.raw.buf;\n    keyTemplate[ 3].ulValueLen = rsaKey->n.raw.len;\n    keyTemplate[ 4].pValue     = rsaKey->d.raw.buf;\n    keyTemplate[ 4].ulValueLen = rsaKey->d.raw.len;\n    keyTemplate[ 5].pValue     = rsaKey->p.raw.buf;\n    keyTemplate[ 5].ulValueLen = rsaKey->p.raw.len;\n    keyTemplate[ 6].pValue     = rsaKey->q.raw.buf;\n    keyTemplate[ 6].ulValueLen = rsaKey->q.raw.len;\n    keyTemplate[ 7].pValue     = rsaKey->dP.raw.buf;\n    keyTemplate[ 7].ulValueLen = rsaKey->dP.raw.len;\n    keyTemplate[ 8].pValue     = rsaKey->dQ.raw.buf;\n    keyTemplate[ 8].ulValueLen = rsaKey->dQ.raw.len;\n    keyTemplate[ 9].pValue     = rsaKey->u.raw.buf;\n    keyTemplate[ 9].ulValueLen = rsaKey->u.raw.len;\n    keyTemplate[10].pValue     = rsaKey->e.raw.buf;\n    keyTemplate[10].ulValueLen = rsaKey->e.raw.len;\n\n    rv = session->func->C_CreateObject(session->handle, keyTemplate, keyTmplCnt,\n                                                                    privateKey);\n    if (rv != CKR_OK)\n        ret = WC_HW_E;\n\n    return ret;\n}\n#endif\n\n#ifdef HAVE_ECC\n/**\n * Set the ECC parameters into the template.\n *\n * @param  key   [in]  ECC key.\n * @param  tmpl  [in]  PKCS#11 template.\n * @param  idx   [in]  Index of template to put parameters into.\n * @return NOT_COMPILE_IN when the EC parameters are not known.\n *         0 on success.\n */\nstatic int Pkcs11EccSetParams(ecc_key* key, CK_ATTRIBUTE* tmpl, int idx)\n{\n    int ret = 0;\n\n    if (key->dp != NULL && key->dp->oid != NULL) {\n        unsigned char* derParams = tmpl[idx].pValue;\n        /* ASN.1 encoding: OBJ + ecc parameters OID */\n        tmpl[idx].ulValueLen = key->dp->oidSz + 2;\n        derParams[0] = ASN_OBJECT_ID;\n        derParams[1] = key->dp->oidSz;\n        XMEMCPY(derParams + 2, key->dp->oid, key->dp->oidSz);\n    }\n    else\n        ret = NOT_COMPILED_IN;\n\n    return ret;\n}\n\n/**\n * Create a PKCS#11 object containing the ECC private key data.\n *\n * @param  privateKey   [out]  Henadle to private key object.\n * @param  session      [in]   Session object.\n * @param  private_key  [in]   ECC private key.\n * @param  operation    [in]   Cryptographic operation key is to be used for.\n * @return  WC_HW_E when a PKCS#11 library call fails.\n *          0 on success.\n */\nstatic int Pkcs11CreateEccPrivateKey(CK_OBJECT_HANDLE* privateKey,\n                                     Pkcs11Session* session,\n                                     ecc_key* private_key,\n                                     CK_ATTRIBUTE_TYPE operation)\n{\n    int             ret = 0;\n    CK_RV           rv;\n    CK_UTF8CHAR     params[MAX_EC_PARAM_LEN];\n    CK_ATTRIBUTE    keyTemplate[] = {\n        { CKA_CLASS,     &privKeyClass, sizeof(privKeyClass) },\n        { CKA_KEY_TYPE,  &ecKeyType,    sizeof(ecKeyType)    },\n        { operation,     &ckTrue,       sizeof(ckTrue)       },\n        { CKA_EC_PARAMS, params,        0                    },\n        { CKA_VALUE,     NULL,          0                    }\n    };\n    CK_ULONG        keyTmplCnt = sizeof(keyTemplate) / sizeof(*keyTemplate);\n\n    ret = Pkcs11EccSetParams(private_key, keyTemplate, 3);\n    if (ret == 0) {\n        keyTemplate[4].pValue     = private_key->k.raw.buf;\n        keyTemplate[4].ulValueLen = private_key->k.raw.len;\n\n        rv = session->func->C_CreateObject(session->handle, keyTemplate,\n                                                        keyTmplCnt, privateKey);\n        if (rv != CKR_OK)\n            ret = WC_HW_E;\n    }\n\n    return ret;\n}\n#endif\n\n#if !defined(NO_RSA) || defined(HAVE_ECC) || (!defined(NO_AES) && \\\n           (defined(HAVE_AESGCM) || defined(HAVE_AES_CBC))) || !defined(NO_HMAC)\n/**\n * Check if mechanism is available in session on token.\n *\n * @param  session  [in]  Session object.\n * @param  mech     [in]  Mechanism to look for.\n * @return  NOT_COMPILED_IN when mechanism not avaialble.\n *          0 when mechanism is available.\n */\nstatic int Pkcs11MechAvail(Pkcs11Session* session, CK_MECHANISM_TYPE mech)\n{\n    int               ret = 0;\n    CK_RV             rv;\n    CK_MECHANISM_INFO mechInfo;\n\n    rv = session->func->C_GetMechanismInfo(session->slotId, mech, &mechInfo);\n    if (rv != CKR_OK)\n        ret = NOT_COMPILED_IN;\n\n    return ret;\n}\n#endif\n\n#ifndef NO_HMAC\n/**\n * Return the mechanism type and key type for the digest type when using HMAC.\n *\n * @param  macType   [in]  Digest type - e.g. WC_SHA256.\n * @param  mechType  [in]  Mechanism type - e.g. CKM_SHA256_HMAC.\n * @param  keyType   [in]  Key type - e.g. CKK_SHA256_HMAC.\n * @return  NOT_COMPILED_IN if the digest algorithm isn't recognised.\n *          0 otherwise.\n */\nstatic int Pkcs11HmacTypes(int macType, int* mechType, int* keyType)\n{\n    int ret = 0;\n\n    switch (macType)\n    {\n    #ifndef NO_MD5\n        case WC_MD5:\n            *mechType = CKM_MD5_HMAC;\n            *keyType = CKK_MD5_HMAC;\n            break;\n    #endif\n    #ifndef NO_SHA\n        case WC_SHA:\n            *mechType = CKM_SHA_1_HMAC;\n            *keyType = CKK_SHA_1_HMAC;\n            break;\n    #endif\n    #ifdef WOLFSSL_SHA224\n        case WC_SHA224:\n            *mechType = CKM_SHA224_HMAC;\n            *keyType = CKK_SHA224_HMAC;\n            break;\n    #endif\n    #ifndef NO_SHA256\n        case WC_SHA256:\n            *mechType = CKM_SHA256_HMAC;\n            *keyType = CKK_SHA256_HMAC;\n            break;\n    #endif\n    #ifdef WOLFSSL_SHA384\n        case WC_SHA384:\n            *mechType = CKM_SHA384_HMAC;\n            *keyType = CKK_SHA384_HMAC;\n            break;\n    #endif\n    #ifdef WOLFSSL_SHA512\n        case WC_SHA512:\n            *mechType = CKM_SHA512_HMAC;\n            *keyType = CKK_SHA512_HMAC;\n            break;\n    #endif\n        default:\n            ret = NOT_COMPILED_IN;\n            break;\n    }\n\n    return ret;\n}\n#endif\n\n/**\n * Store the private key on the token in the session.\n *\n * @param  token  [in]  Token to store private key on.\n * @param  type   [in]  Key type.\n * @param  clear  [in]  Clear out the private data from software key.\n * @param  key    [in]  Key type specific object.\n * @return  NOT_COMPILED_IN when mechanism not available.\n *          0 on success.\n */\nint wc_Pkcs11StoreKey(Pkcs11Token* token, int type, int clear, void* key)\n{\n    int               ret = 0;\n    Pkcs11Session     session;\n    CK_OBJECT_HANDLE  privKey = NULL_PTR;\n\n    ret = Pkcs11OpenSession(token, &session, 1);\n    if (ret == 0) {\n        switch (type) {\n    #if !defined(NO_AES) && defined(HAVE_AESGCM)\n            case PKCS11_KEY_TYPE_AES_GCM: {\n                Aes* aes = (Aes*)key;\n\n                ret = Pkcs11MechAvail(&session, CKM_AES_GCM);\n                if (ret == 0) {\n                    ret = Pkcs11CreateSecretKey(&privKey, &session, CKK_AES,\n                                                (unsigned char*)aes->devKey,\n                                                aes->keylen,\n                                                (unsigned char*)aes->id,\n                                                aes->idLen);\n                }\n                if (ret == 0 && clear)\n                    ForceZero(aes->devKey, aes->keylen);\n                break;\n            }\n    #endif\n    #if !defined(NO_AES) && defined(HAVE_AES_CBC)\n            case PKCS11_KEY_TYPE_AES_CBC: {\n                Aes* aes = (Aes*)key;\n\n                ret = Pkcs11MechAvail(&session, CKM_AES_CBC);\n                if (ret == 0) {\n                    ret = Pkcs11CreateSecretKey(&privKey, &session, CKK_AES,\n                                                (unsigned char*)aes->devKey,\n                                                aes->keylen,\n                                                (unsigned char*)aes->id,\n                                                aes->idLen);\n                }\n                if (ret == 0 && clear)\n                    ForceZero(aes->devKey, aes->keylen);\n                break;\n            }\n    #endif\n    #ifndef NO_HMAC\n            case PKCS11_KEY_TYPE_HMAC: {\n                Hmac* hmac = (Hmac*)key;\n                int mechType;\n                int keyType;\n\n                ret = Pkcs11HmacTypes(hmac->macType, &mechType, &keyType);\n                if (ret == NOT_COMPILED_IN)\n                    break;\n\n                if (ret == 0)\n                    ret = Pkcs11MechAvail(&session, mechType);\n                if (ret == 0) {\n                    ret = Pkcs11CreateSecretKey(&privKey, &session, keyType,\n                                                (unsigned char*)hmac->keyRaw,\n                                                hmac->keyLen,\n                                                (unsigned char*)hmac->id,\n                                                hmac->idLen);\n                    if (ret == WC_HW_E) {\n                        ret = Pkcs11CreateSecretKey(&privKey, &session,\n                                                   CKK_GENERIC_SECRET,\n                                                   (unsigned char*)hmac->keyRaw,\n                                                   hmac->keyLen,\n                                                   (unsigned char*)hmac->id,\n                                                   hmac->idLen);\n                    }\n                }\n                break;\n            }\n    #endif\n    #ifndef NO_RSA\n            case PKCS11_KEY_TYPE_RSA: {\n                RsaKey* rsaKey = (RsaKey*)key;\n\n                ret = Pkcs11MechAvail(&session, CKM_RSA_X_509);\n                if (ret == 0)\n                    ret = Pkcs11CreateRsaPrivateKey(&privKey, &session, rsaKey);\n                if (ret == 0 && clear) {\n                    mp_forcezero(&rsaKey->u);\n                    mp_forcezero(&rsaKey->dQ);\n                    mp_forcezero(&rsaKey->dP);\n                    mp_forcezero(&rsaKey->q);\n                    mp_forcezero(&rsaKey->p);\n                    mp_forcezero(&rsaKey->d);\n                }\n                break;\n            }\n    #endif\n    #ifdef HAVE_ECC\n            case PKCS11_KEY_TYPE_EC: {\n                ecc_key* eccKey = (ecc_key*)key;\n                int      ret2 = NOT_COMPILED_IN;\n\n        #ifndef NO_PKCS11_ECDH\n                /* Try ECDH mechanism first. */\n                ret = Pkcs11MechAvail(&session, CKM_ECDH1_DERIVE);\n                if (ret == 0) {\n                    ret = Pkcs11CreateEccPrivateKey(&privKey, &session, eccKey,\n                                                                    CKA_DERIVE);\n                }\n         #endif\n                if (ret == 0 || ret == NOT_COMPILED_IN) {\n                    /* Try ECDSA mechanism next. */\n                    ret2 = Pkcs11MechAvail(&session, CKM_ECDSA);\n                    if (ret2 == 0) {\n                        ret2 = Pkcs11CreateEccPrivateKey(&privKey, &session,\n                                                              eccKey, CKA_SIGN);\n                    }\n                    /* OK for this to fail if set for ECDH. */\n                    if (ret == NOT_COMPILED_IN)\n                        ret = ret2;\n                }\n                if (ret == 0 && clear)\n                    mp_forcezero(&eccKey->k);\n                break;\n            }\n    #endif\n            default:\n                ret = NOT_COMPILED_IN;\n                break;\n        }\n\n        Pkcs11CloseSession(token, &session);\n    }\n\n    (void)privKey;\n    (void)clear;\n    (void)key;\n\n    return ret;\n}\n\n#if !defined(NO_RSA) || defined(HAVE_ECC) || (!defined(NO_AES) && \\\n           (defined(HAVE_AESGCM) || defined(HAVE_AES_CBC))) || !defined(NO_HMAC)\n/**\n * Find the PKCS#11 object containing the RSA public or private key data with\n * the modulus specified.\n *\n * @param  key       [out]  Henadle to key object.\n * @param  keyClass  [in]   Public or private key class.\n * @param  keyType   [in]   Type of key.\n * @param  session   [in]   Session object.\n * @param  id        [in]   Identifier set against a key.\n * @param  idLen     [in]   Length of identifier.\n * @return  WC_HW_E when a PKCS#11 library call fails.\n *          0 on success.\n */\nstatic int Pkcs11FindKeyById(CK_OBJECT_HANDLE* key, CK_OBJECT_CLASS keyClass,\n                             CK_KEY_TYPE keyType, Pkcs11Session* session,\n                             byte* id, int idLen)\n{\n    int             ret = 0;\n    CK_RV           rv;\n    CK_ULONG        count;\n    CK_ATTRIBUTE    keyTemplate[] = {\n        { CKA_CLASS,           &keyClass, sizeof(keyClass) },\n        { CKA_KEY_TYPE,        &keyType,  sizeof(keyType)  },\n        { CKA_ID,              id,        (CK_ULONG)idLen  }\n    };\n    CK_ULONG        keyTmplCnt = sizeof(keyTemplate) / sizeof(*keyTemplate);\n\n    WOLFSSL_MSG(\"PKCS#11: Find Key By Id\");\n\n    rv = session->func->C_FindObjectsInit(session->handle, keyTemplate,\n                                                                    keyTmplCnt);\n    if (rv != CKR_OK)\n        ret = WC_HW_E;\n    if (ret == 0) {\n        rv = session->func->C_FindObjects(session->handle, key, 1, &count);\n        if (rv != CKR_OK)\n            ret = WC_HW_E;\n        rv = session->func->C_FindObjectsFinal(session->handle);\n        if (rv != CKR_OK)\n            ret = WC_HW_E;\n    }\n    if (ret == 0 && count == 0)\n        ret = WC_HW_E;\n\n    return ret;\n}\n#endif\n\n#ifndef NO_RSA\n/**\n * Find the PKCS#11 object containing the RSA public or private key data with\n * the modulus specified.\n *\n * @param  key       [out]  Henadle to key object.\n * @param  keyClass  [in]   Public or private key class.\n * @param  session   [in]   Session object.\n * @param  rsaKey    [in]   RSA key with modulus to search on.\n * @return  WC_HW_E when a PKCS#11 library call fails.\n *          0 on success.\n */\nstatic int Pkcs11FindRsaKey(CK_OBJECT_HANDLE* key, CK_OBJECT_CLASS keyClass,\n                            Pkcs11Session* session, RsaKey* rsaKey)\n{\n    int             ret = 0;\n    CK_RV           rv;\n    CK_ULONG        count;\n    CK_ATTRIBUTE    keyTemplate[] = {\n        { CKA_CLASS,           &keyClass,   sizeof(keyClass)   },\n        { CKA_KEY_TYPE,        &rsaKeyType, sizeof(rsaKeyType) },\n        { CKA_MODULUS,         NULL,        0                  },\n    };\n    CK_ULONG        keyTmplCnt = sizeof(keyTemplate) / sizeof(*keyTemplate);\n\n    /* Set the modulus. */\n    keyTemplate[2].pValue     = rsaKey->n.raw.buf;\n    keyTemplate[2].ulValueLen = rsaKey->n.raw.len;\n\n    rv = session->func->C_FindObjectsInit(session->handle, keyTemplate,\n                                                                    keyTmplCnt);\n    if (rv != CKR_OK)\n        ret = WC_HW_E;\n    if (ret == 0) {\n        rv = session->func->C_FindObjects(session->handle, key, 1, &count);\n        if (rv != CKR_OK)\n            ret = WC_HW_E;\n        rv = session->func->C_FindObjectsFinal(session->handle);\n        if (rv != CKR_OK)\n            ret = WC_HW_E;\n    }\n\n    return ret;\n}\n\n/**\n * Exponentiate the input with the public part of the RSA key.\n * Used in public encrypt and decrypt.\n *\n * @param  session  [in]  Session object.\n * @param  info     [in]  Cryptographic operation data.\n * @return  WC_HW_E when a PKCS#11 library call fails.\n *          0 on success.\n */\nstatic int Pkcs11RsaPublic(Pkcs11Session* session, wc_CryptoInfo* info)\n{\n    int              ret = 0;\n    CK_RV            rv;\n    CK_MECHANISM     mech;\n    CK_ULONG         outLen;\n    CK_OBJECT_HANDLE publicKey = NULL_PTR;\n    int              sessionKey = 0;\n    CK_ATTRIBUTE     keyTemplate[] = {\n        { CKA_CLASS,           &pubKeyClass, sizeof(pubKeyClass) },\n        { CKA_KEY_TYPE,        &rsaKeyType,  sizeof(rsaKeyType)  },\n        { CKA_ENCRYPT,         &ckTrue,      sizeof(ckTrue)      },\n        { CKA_MODULUS,         NULL,         0                   },\n        { CKA_PUBLIC_EXPONENT, NULL,         0                   }\n    };\n    CK_ULONG        keyTmplCnt = sizeof(keyTemplate) / sizeof(*keyTemplate);\n\n    WOLFSSL_MSG(\"PKCS#11: RSA Public Key Operation\");\n\n    if (ret == 0 && info->pk.rsa.outLen == NULL) {\n        ret = BAD_FUNC_ARG;\n    }\n\n    if (ret == 0) {\n        if ((sessionKey = !mp_iszero(&info->pk.rsa.key->e))) {\n            /* Set the modulus and public exponent data. */\n            keyTemplate[3].pValue     = info->pk.rsa.key->n.raw.buf;\n            keyTemplate[3].ulValueLen = info->pk.rsa.key->n.raw.len;\n            keyTemplate[4].pValue     = info->pk.rsa.key->e.raw.buf;\n            keyTemplate[4].ulValueLen = info->pk.rsa.key->e.raw.len;\n\n            /* Create an object containing public key data for device to use. */\n            rv = session->func->C_CreateObject(session->handle, keyTemplate,\n                                                        keyTmplCnt, &publicKey);\n            if (rv != CKR_OK)\n                ret = WC_HW_E;\n        }\n        else {\n            ret = Pkcs11FindKeyById(&publicKey, CKO_PUBLIC_KEY, CKK_RSA,\n                                    session, info->pk.rsa.key->id,\n                                    info->pk.rsa.key->idLen);\n        }\n    }\n\n    if (ret == 0) {\n        /* Raw RSA encrypt/decrypt operation. */\n        mech.mechanism      = CKM_RSA_X_509;\n        mech.ulParameterLen = 0;\n        mech.pParameter     = NULL;\n\n        rv = session->func->C_EncryptInit(session->handle, &mech, publicKey);\n        if (rv != CKR_OK)\n            ret = WC_HW_E;\n    }\n    if (ret == 0) {\n        outLen = (CK_ULONG)*info->pk.rsa.outLen;\n        rv = session->func->C_Encrypt(session->handle,\n                (CK_BYTE_PTR)info->pk.rsa.in, info->pk.rsa.inLen,\n                info->pk.rsa.out, &outLen);\n        if (rv != CKR_OK)\n            ret = WC_HW_E;\n    }\n    if (ret == 0)\n        *info->pk.rsa.outLen = (word32)outLen;\n\n    if (sessionKey)\n        session->func->C_DestroyObject(session->handle, publicKey);\n\n    return ret;\n}\n\n/**\n * Exponentiate the input with the private part of the RSA key.\n * Used in private encrypt and decrypt.\n *\n * @param  session  [in]  Session object.\n * @param  info     [in]  Cryptographic operation data.\n * @return  WC_HW_E when a PKCS#11 library call fails.\n *          0 on success.\n */\nstatic int Pkcs11RsaPrivate(Pkcs11Session* session, wc_CryptoInfo* info)\n{\n    int              ret = 0;\n    CK_RV            rv;\n    CK_MECHANISM     mech;\n    CK_ULONG         outLen;\n    CK_OBJECT_HANDLE privateKey = NULL_PTR;\n    int              sessionKey = 0;\n\n    WOLFSSL_MSG(\"PKCS#11: RSA Private Key Operation\");\n\n    if (ret == 0 && info->pk.rsa.outLen == NULL) {\n        ret = BAD_FUNC_ARG;\n    }\n\n    if (ret == 0) {\n        if ((sessionKey = !mp_iszero(&info->pk.rsa.key->d))) {\n            ret = Pkcs11CreateRsaPrivateKey(&privateKey, session,\n                                                              info->pk.rsa.key);\n        }\n        else if (info->pk.rsa.key->idLen > 0) {\n            ret = Pkcs11FindKeyById(&privateKey, CKO_PRIVATE_KEY, CKK_RSA,\n                                    session, info->pk.rsa.key->id,\n                                    info->pk.rsa.key->idLen);\n        }\n        else {\n            ret = Pkcs11FindRsaKey(&privateKey, CKO_PRIVATE_KEY, session,\n                                                              info->pk.rsa.key);\n        }\n    }\n\n    if (ret == 0) {\n        /* Raw RSA encrypt/decrypt operation. */\n        mech.mechanism      = CKM_RSA_X_509;\n        mech.ulParameterLen = 0;\n        mech.pParameter     = NULL;\n\n        rv = session->func->C_DecryptInit(session->handle, &mech, privateKey);\n        if (rv != CKR_OK)\n            ret = WC_HW_E;\n    }\n    if (ret == 0) {\n        outLen = (CK_ULONG)*info->pk.rsa.outLen;\n        rv = session->func->C_Decrypt(session->handle,\n                (CK_BYTE_PTR)info->pk.rsa.in, info->pk.rsa.inLen,\n                info->pk.rsa.out, &outLen);\n        if (rv != CKR_OK)\n            ret = WC_HW_E;\n    }\n    if (ret == 0)\n        *info->pk.rsa.outLen = (word32)outLen;\n\n    if (sessionKey)\n        session->func->C_DestroyObject(session->handle, privateKey);\n\n    return ret;\n}\n\n/**\n * Perform an RSA operation.\n *\n * @param  session  [in]  Session object.\n * @param  info     [in]  Cryptographic operation data.\n * @return  WC_HW_E when a PKCS#11 library call fails.\n *          0 on success.\n */\nstatic int Pkcs11Rsa(Pkcs11Session* session, wc_CryptoInfo* info)\n{\n    int               ret = 0;\n    CK_RV             rv;\n    CK_MECHANISM_INFO mechInfo;\n\n    /* Check operation is supported. */\n    rv = session->func->C_GetMechanismInfo(session->slotId, CKM_RSA_X_509,\n                                                                     &mechInfo);\n    if (rv != CKR_OK)\n        ret = NOT_COMPILED_IN;\n\n    if (ret == 0) {\n        if (info->pk.rsa.type == RSA_PUBLIC_ENCRYPT ||\n                                      info->pk.rsa.type == RSA_PUBLIC_DECRYPT) {\n            if ((mechInfo.flags & CKF_ENCRYPT) == 0)\n                ret = NOT_COMPILED_IN;\n            else\n                ret = Pkcs11RsaPublic(session, info);\n        }\n        else if (info->pk.rsa.type == RSA_PRIVATE_ENCRYPT ||\n                                     info->pk.rsa.type == RSA_PRIVATE_DECRYPT) {\n            if ((mechInfo.flags & CKF_DECRYPT) == 0)\n                ret = NOT_COMPILED_IN;\n            else\n                ret = Pkcs11RsaPrivate(session, info);\n        }\n        else\n            ret = NOT_COMPILED_IN;\n    }\n\n    return ret;\n}\n\n#ifdef WOLFSSL_KEY_GEN\n/**\n * Get the RSA public key data from the PKCS#11 object.\n *\n * @param  key      [in]  RSA key to put the data into.\n * @param  session  [in]  Session object.\n * @param  pubkey   [in]  Public key object.\n * @return  WC_HW_E when a PKCS#11 library call fails.\n *          MEMORY_E when a memory allocation fails.\n *          0 on success.\n */\nstatic int Pkcs11GetRsaPublicKey(RsaKey* key, Pkcs11Session* session,\n                                 CK_OBJECT_HANDLE pubKey)\n{\n    int            ret = 0;\n    unsigned char* mod = NULL;\n    unsigned char* exp = NULL;\n    int            modSz, expSz;\n    CK_ATTRIBUTE   tmpl[] = {\n        { CKA_MODULUS,         NULL_PTR, 0 },\n        { CKA_PUBLIC_EXPONENT, NULL_PTR, 0 }\n    };\n    CK_ULONG       tmplCnt = sizeof(tmpl) / sizeof(*tmpl);\n    CK_RV rv;\n\n    rv = session->func->C_GetAttributeValue(session->handle, pubKey, tmpl,\n                                                                       tmplCnt);\n    if (rv != CKR_OK)\n        ret = WC_HW_E;\n\n    if (ret == 0) {\n        modSz = tmpl[0].ulValueLen;\n        expSz = tmpl[1].ulValueLen;\n        mod = (unsigned char*)XMALLOC(modSz, key->heap,\n                                                       DYNAMIC_TYPE_TMP_BUFFER);\n        if (mod == NULL)\n            ret = MEMORY_E;\n    }\n    if (ret == 0) {\n        exp = (unsigned char*)XMALLOC(expSz, key->heap,\n                                                       DYNAMIC_TYPE_TMP_BUFFER);\n        if (exp == NULL)\n            ret = MEMORY_E;\n    }\n    if (ret == 0) {\n        tmpl[0].pValue = mod;\n        tmpl[1].pValue = exp;\n\n        rv = session->func->C_GetAttributeValue(session->handle, pubKey,\n                                                                 tmpl, tmplCnt);\n        if (rv != CKR_OK)\n            ret = WC_HW_E;\n    }\n    if (ret == 0)\n        ret = wc_RsaPublicKeyDecodeRaw(mod, modSz, exp, expSz, key);\n\n    if (exp != NULL)\n        XFREE(exp, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n    if (mod != NULL)\n        XFREE(mod, key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n\n    return ret;\n}\n\n/**\n * Perform an RSA key generation operation.\n * The private key data stays on the device.\n *\n * @param  session  [in]  Session object.\n * @param  info     [in]  Cryptographic operation data.\n * @return  WC_HW_E when a PKCS#11 library call fails.\n *          0 on success.\n */\nstatic int Pkcs11RsaKeyGen(Pkcs11Session* session, wc_CryptoInfo* info)\n{\n    int               ret = 0;\n    RsaKey*           key = info->pk.rsakg.key;\n    CK_RV             rv;\n    CK_ULONG          bits = info->pk.rsakg.size;\n    CK_OBJECT_HANDLE  pubKey = NULL_PTR, privKey = NULL_PTR;\n    CK_MECHANISM      mech;\n    static CK_BYTE    pub_exp[] = { 0x01, 0x00, 0x01, 0x00 };\n    CK_ATTRIBUTE      pubKeyTmpl[] = {\n        { CKA_MODULUS_BITS,    &bits,    sizeof(bits)    },\n        { CKA_ENCRYPT,         &ckTrue,  sizeof(ckTrue)  },\n        { CKA_VERIFY,          &ckTrue,  sizeof(ckTrue)  },\n        { CKA_PUBLIC_EXPONENT, &pub_exp, sizeof(pub_exp) }\n    };\n    CK_ULONG          pubTmplCnt = sizeof(pubKeyTmpl)/sizeof(*pubKeyTmpl);\n    CK_ATTRIBUTE      privKeyTmpl[] = {\n        {CKA_DECRYPT,  &ckTrue, sizeof(ckTrue) },\n        {CKA_SIGN,     &ckTrue, sizeof(ckTrue) },\n        {CKA_ID,       NULL,    0              }\n    };\n    int               privTmplCnt = 2;\n    int               i;\n\n    ret = Pkcs11MechAvail(session, CKM_RSA_PKCS_KEY_PAIR_GEN);\n    if (ret == 0) {\n        WOLFSSL_MSG(\"PKCS#11: RSA Key Generation Operation\");\n\n        /* Most commonly used public exponent value (array initialized). */\n        if (info->pk.rsakg.e != WC_RSA_EXPONENT) {\n            for (i = 0; i < (int)sizeof(pub_exp); i++)\n                pub_exp[i] = (info->pk.rsakg.e >> (8 * i)) & 0xff;\n        }\n        for (i = (int)sizeof(pub_exp) - 1; pub_exp[i] == 0; i--) {\n        }\n        pubKeyTmpl[3].ulValueLen = i + 1;\n\n        if (key->idLen != 0) {\n            privKeyTmpl[privTmplCnt].pValue     = key->id;\n            privKeyTmpl[privTmplCnt].ulValueLen = key->idLen;\n            privTmplCnt++;\n        }\n\n        mech.mechanism      = CKM_RSA_PKCS_KEY_PAIR_GEN;\n        mech.ulParameterLen = 0;\n        mech.pParameter     = NULL;\n\n        rv = session->func->C_GenerateKeyPair(session->handle, &mech,\n                                                       pubKeyTmpl, pubTmplCnt,\n                                                       privKeyTmpl, privTmplCnt,\n                                                       &pubKey, &privKey);\n        if (rv != CKR_OK)\n            ret = -1;\n    }\n\n    if (ret == 0)\n        ret = Pkcs11GetRsaPublicKey(key, session, pubKey);\n\n    if (pubKey != NULL_PTR)\n        ret = session->func->C_DestroyObject(session->handle, pubKey);\n    if (ret != 0 && privKey != NULL_PTR)\n        ret = session->func->C_DestroyObject(session->handle, privKey);\n\n    return ret;\n}\n#endif /* WOLFSSL_KEY_GEN */\n#endif /* !NO_RSA */\n\n#ifdef HAVE_ECC\n/**\n * Find the PKCS#11 object containing the ECC public or private key data with\n * the modulus specified.\n *\n * @param  key       [out]  Henadle to key object.\n * @param  keyClass  [in]   Public or private key class.\n * @param  session   [in]   Session object.\n * @param  eccKey    [in]   ECC key with parameters.\n * @return  WC_HW_E when a PKCS#11 library call fails.\n *          MEMORY_E when a memory allocation fails.\n *          0 on success.\n */\nstatic int Pkcs11FindEccKey(CK_OBJECT_HANDLE* key, CK_OBJECT_CLASS keyClass,\n                            Pkcs11Session* session, ecc_key* eccKey)\n{\n    int             ret = 0;\n    int             i;\n    unsigned char*  ecPoint = NULL;\n    word32          len = 0;\n    CK_RV           rv;\n    CK_ULONG        count;\n    CK_UTF8CHAR     params[MAX_EC_PARAM_LEN];\n    CK_ATTRIBUTE    keyTemplate[] = {\n        { CKA_CLASS,           &keyClass,  sizeof(keyClass)  },\n        { CKA_KEY_TYPE,        &ecKeyType, sizeof(ecKeyType) },\n        { CKA_EC_PARAMS,       params,     0                 },\n        { CKA_EC_POINT,        NULL,       0                 },\n    };\n    CK_ULONG        attrCnt = 3;\n\n    ret = Pkcs11EccSetParams(eccKey, keyTemplate, 2);\n    if (ret == 0 && keyClass == CKO_PUBLIC_KEY) {\n        /* ASN1 encoded: OCT + uncompressed point */\n        len = 3 + 1 + 2 * eccKey->dp->size;\n        ecPoint = (unsigned char*)XMALLOC(len, eccKey->heap, DYNAMIC_TYPE_ECC);\n        if (ecPoint == NULL)\n            ret = MEMORY_E;\n    }\n    if (ret == 0 && keyClass == CKO_PUBLIC_KEY) {\n        len -= 3;\n        i = 0;\n        ecPoint[i++] = ASN_OCTET_STRING;\n        if (len >= ASN_LONG_LENGTH)\n            ecPoint[i++] = (ASN_LONG_LENGTH | 1);\n        ecPoint[i++] = len;\n        ret = wc_ecc_export_x963(eccKey, ecPoint + i, &len);\n    }\n    if (ret == 0 && keyClass == CKO_PUBLIC_KEY) {\n        keyTemplate[3].pValue     = ecPoint;\n        keyTemplate[3].ulValueLen = len + i;\n        attrCnt++;\n    }\n    if (ret == 0) {\n        rv = session->func->C_FindObjectsInit(session->handle, keyTemplate,\n                                                                       attrCnt);\n        if (rv != CKR_OK)\n            ret = WC_HW_E;\n    }\n    if (ret == 0) {\n        rv = session->func->C_FindObjects(session->handle, key, 1, &count);\n        if (rv != CKR_OK)\n            ret = WC_HW_E;\n        rv = session->func->C_FindObjectsFinal(session->handle);\n        if (rv != CKR_OK)\n            ret = WC_HW_E;\n    }\n\n    if (ecPoint != NULL)\n        XFREE(ecPoint, eccKey->heap, DYNAMIC_TYPE_ECC);\n\n    return ret;\n}\n\n/**\n * Create a PKCS#11 object containing the ECC public key data.\n * Encode the public key as an OCTET_STRING of the encoded point.\n *\n * @param  publicKey    [out]  Henadle to public key object.\n * @param  session      [in]   Session object.\n * @param  public_key   [in]   ECC public key.\n * @param  operation    [in]   Cryptographic operation key is to be used for.\n * @return  WC_HW_E when a PKCS#11 library call fails.\n *          MEMORY_E when a memory allocation fails.\n *          0 on success.\n */\nstatic int Pkcs11CreateEccPublicKey(CK_OBJECT_HANDLE* publicKey,\n                                    Pkcs11Session* session,\n                                    ecc_key* public_key,\n                                    CK_ATTRIBUTE_TYPE operation)\n{\n    int             ret = 0;\n    int             i;\n    unsigned char*  ecPoint = NULL;\n    word32          len;\n    CK_RV           rv;\n    CK_UTF8CHAR     params[MAX_EC_PARAM_LEN];\n    CK_ATTRIBUTE    keyTemplate[] = {\n        { CKA_CLASS,     &pubKeyClass, sizeof(pubKeyClass) },\n        { CKA_KEY_TYPE,  &ecKeyType,   sizeof(ecKeyType)   },\n        { operation,     &ckTrue,      sizeof(ckTrue)      },\n        { CKA_EC_PARAMS, params,       0                   },\n        { CKA_EC_POINT,  NULL,         0                   }\n    };\n    CK_ULONG        keyTmplCnt = sizeof(keyTemplate) / sizeof(*keyTemplate);\n\n    ret = Pkcs11EccSetParams(public_key, keyTemplate, 3);\n    if (ret == 0) {\n        /* ASN1 encoded: OCT + uncompressed point */\n        len = 3 + 1 + 2 * public_key->dp->size;\n        ecPoint = (unsigned char*)XMALLOC(len, public_key->heap,\n                                                              DYNAMIC_TYPE_ECC);\n        if (ecPoint == NULL)\n            ret = MEMORY_E;\n    }\n    if (ret == 0) {\n        len -= 3;\n        i = 0;\n        ecPoint[i++] = ASN_OCTET_STRING;\n        if (len >= ASN_LONG_LENGTH)\n            ecPoint[i++] = ASN_LONG_LENGTH | 1;\n        ecPoint[i++] = len;\n        ret = wc_ecc_export_x963(public_key, ecPoint + i, &len);\n    }\n    if (ret == 0) {\n        keyTemplate[4].pValue     = ecPoint;\n        keyTemplate[4].ulValueLen = len + i;\n\n        rv = session->func->C_CreateObject(session->handle, keyTemplate,\n                                                         keyTmplCnt, publicKey);\n        if (rv != CKR_OK)\n            ret = WC_HW_E;\n    }\n\n    if (ecPoint != NULL)\n        XFREE(ecPoint, public_key->heap, DYNAMIC_TYPE_ECC);\n\n    return ret;\n}\n\n#ifndef NO_PKCS11_EC_KEYGEN\n/**\n * Gets the public key data from the PKCS#11 object and puts into the ECC key.\n *\n * @param  key      [in]  ECC public key.\n * @param  session  [in]  Session object.\n * @param  pubKey   [in]  ECC public key PKCS#11 object.\n * @return  WC_HW_E when a PKCS#11 library call fails.\n *          MEMORY_E when a memory allocation fails.\n *          0 on success.\n */\nstatic int Pkcs11GetEccPublicKey(ecc_key* key, Pkcs11Session* session,\n                                 CK_OBJECT_HANDLE pubKey)\n{\n    int            ret = 0;\n    word32         i = 0;\n    int            curveIdx;\n    unsigned char* point = NULL;\n    int            pointSz;\n    byte           tag;\n    CK_RV          rv;\n    CK_ATTRIBUTE   tmpl[] = {\n        { CKA_EC_POINT,  NULL_PTR, 0 },\n    };\n    CK_ULONG       tmplCnt = sizeof(tmpl) / sizeof(*tmpl);\n\n    rv = session->func->C_GetAttributeValue(session->handle, pubKey, tmpl,\n                                                                       tmplCnt);\n    if (rv != CKR_OK)\n        ret = WC_HW_E;\n\n    if (ret == 0) {\n        pointSz = (int)tmpl[0].ulValueLen;\n        point = (unsigned char*)XMALLOC(pointSz, key->heap, DYNAMIC_TYPE_ECC);\n        if (point == NULL)\n            ret = MEMORY_E;\n    }\n    if (ret == 0) {\n        tmpl[0].pValue = point;\n\n        rv = session->func->C_GetAttributeValue(session->handle, pubKey,\n                                                                 tmpl, tmplCnt);\n        if (rv != CKR_OK)\n            ret = WC_HW_E;\n    }\n\n    /* Make sure the data is big enough for ASN.1: OCT + uncompressed point */\n    if (ret == 0 && pointSz < key->dp->size * 2 + 1 + 2)\n        ret = ASN_PARSE_E;\n    /* Step over the OCTET_STRING wrapper. */\n    if (ret == 0 && GetASNTag(point, &i, &tag, pointSz) != 0)\n        ret = ASN_PARSE_E;\n    if (ret == 0 && tag != ASN_OCTET_STRING)\n        ret = ASN_PARSE_E;\n    if (ret == 0 && point[i] >= ASN_LONG_LENGTH) {\n        if (point[i++] != (ASN_LONG_LENGTH | 1))\n            ret = ASN_PARSE_E;\n        else if (pointSz < key->dp->size * 2 + 1 + 3)\n            ret = ASN_PARSE_E;\n    }\n    if (ret == 0 && point[i++] != key->dp->size * 2 + 1)\n        ret = ASN_PARSE_E;\n\n    if (ret == 0) {\n        curveIdx = wc_ecc_get_curve_idx(key->dp->id);\n        ret = wc_ecc_import_point_der(point + i, pointSz - i, curveIdx,\n                                                                  &key->pubkey);\n    }\n\n    if (point != NULL)\n        XFREE(point, key->heap, DYNAMIC_TYPE_ECC);\n\n    return ret;\n}\n\n/**\n * Perform an ECC key generation operation.\n * The private key data stays on the device.\n *\n * @param  session  [in]  Session object.\n * @param  info     [in]  Cryptographic operation data.\n * @return  WC_HW_E when a PKCS#11 library call fails.\n *          0 on success.\n */\nstatic int Pkcs11EcKeyGen(Pkcs11Session* session, wc_CryptoInfo* info)\n{\n    int               ret = 0;\n    ecc_key*          key = info->pk.eckg.key;\n    CK_RV             rv;\n    CK_OBJECT_HANDLE  pubKey = NULL_PTR, privKey = NULL_PTR;\n    CK_MECHANISM      mech;\n    CK_UTF8CHAR       params[MAX_EC_PARAM_LEN];\n    CK_ATTRIBUTE      pubKeyTmpl[] = {\n        { CKA_EC_PARAMS,       params,   0               },\n        { CKA_ENCRYPT,         &ckTrue,  sizeof(ckTrue)  },\n        { CKA_VERIFY,          &ckTrue,  sizeof(ckTrue)  },\n    };\n    int               pubTmplCnt = sizeof(pubKeyTmpl)/sizeof(*pubKeyTmpl);\n    CK_ATTRIBUTE      privKeyTmpl[] = {\n        { CKA_DECRYPT,  &ckTrue, sizeof(ckTrue) },\n        { CKA_SIGN,     &ckTrue, sizeof(ckTrue) },\n        { CKA_DERIVE,   &ckTrue, sizeof(ckTrue) },\n        { CKA_ID,       NULL,    0              },\n    };\n    int               privTmplCnt = 3;\n\n    ret = Pkcs11MechAvail(session, CKM_EC_KEY_PAIR_GEN);\n    if (ret == 0) {\n        WOLFSSL_MSG(\"PKCS#11: EC Key Generation Operation\");\n\n        ret = Pkcs11EccSetParams(key, pubKeyTmpl, 0);\n    }\n    if (ret == 0) {\n        if (key->idLen != 0) {\n            privKeyTmpl[privTmplCnt].pValue     = key->id;\n            privKeyTmpl[privTmplCnt].ulValueLen = key->idLen;\n            privTmplCnt++;\n        }\n\n        mech.mechanism      = CKM_EC_KEY_PAIR_GEN;\n        mech.ulParameterLen = 0;\n        mech.pParameter     = NULL;\n\n        rv = session->func->C_GenerateKeyPair(session->handle, &mech,\n                                                       pubKeyTmpl, pubTmplCnt,\n                                                       privKeyTmpl, privTmplCnt,\n                                                       &pubKey, &privKey);\n        if (rv != CKR_OK)\n            ret = -1;\n    }\n\n    if (ret == 0)\n        ret = Pkcs11GetEccPublicKey(key, session, pubKey);\n\n    if (pubKey != NULL_PTR)\n        session->func->C_DestroyObject(session->handle, pubKey);\n    if (ret != 0 && privKey != NULL_PTR)\n        session->func->C_DestroyObject(session->handle, privKey);\n\n    return ret;\n}\n#endif\n\n#ifndef NO_PKCS11_ECDH\n/**\n * Extracts the secret key data from the PKCS#11 object.\n *\n * @param  session  [in]      Session object.\n * @param  secret   [in]      PKCS#11 object with the secret key data.\n * @param  out      [in]      Buffer to hold secret data.\n * @param  outLen   [in,out]  On in, length of buffer.\n *                            On out, the length of data in buffer.\n * @return  WC_HW_E when a PKCS#11 library call fails.\n *          0 on success.\n */\nstatic int Pkcs11ExtractSecret(Pkcs11Session* session, CK_OBJECT_HANDLE secret,\n    byte* out, word32* outLen)\n{\n    int ret = 0;\n    CK_ATTRIBUTE tmpl[] = {\n      {CKA_VALUE, NULL_PTR, 0}\n    };\n    CK_ULONG     tmplCnt = sizeof(tmpl) / sizeof(*tmpl);\n    CK_RV rv;\n\n    rv = session->func->C_GetAttributeValue(session->handle, secret, tmpl,\n                                                                       tmplCnt);\n    if (rv != CKR_OK)\n        ret = WC_HW_E;\n    if (ret == 0) {\n        if (tmpl[0].ulValueLen > *outLen)\n            ret = BUFFER_E;\n    }\n    if (ret == 0) {\n        tmpl[0].pValue = out;\n        rv = session->func->C_GetAttributeValue(session->handle, secret,\n                                                                 tmpl, tmplCnt);\n        if (rv != CKR_OK)\n            ret = WC_HW_E;\n        *outLen = (word32)tmpl[0].ulValueLen;\n    }\n\n    return ret;\n}\n\n/**\n * Performs the ECDH secret generation operation.\n *\n * @param  session  [in]  Session object.\n * @param  info     [in]  Cryptographic operation data.\n * @return  WC_HW_E when a PKCS#11 library call fails.\n *          0 on success.\n */\nstatic int Pkcs11ECDH(Pkcs11Session* session, wc_CryptoInfo* info)\n{\n    int                    ret = 0;\n    int                    sessionKey = 0;\n    unsigned char*         point = NULL;\n    word32                 pointLen;\n    CK_RV                  rv;\n    CK_KEY_TYPE            keyType = CKK_GENERIC_SECRET;\n    CK_MECHANISM           mech;\n    CK_ECDH1_DERIVE_PARAMS params;\n    CK_OBJECT_HANDLE       privateKey = NULL_PTR;\n    CK_OBJECT_HANDLE       secret = CK_INVALID_HANDLE;\n    CK_ULONG               secSz;\n    CK_ATTRIBUTE           tmpl[] = {\n        { CKA_CLASS,       &secretKeyClass, sizeof(secretKeyClass) },\n        { CKA_KEY_TYPE,    &keyType,        sizeof(keyType)        },\n        { CKA_PRIVATE,     &ckFalse,        sizeof(ckFalse)        },\n        { CKA_SENSITIVE,   &ckFalse,        sizeof(ckFalse)        },\n        { CKA_EXTRACTABLE, &ckTrue,         sizeof(ckTrue)         },\n        { CKA_VALUE_LEN,   &secSz,          sizeof(secSz)          }\n    };\n    CK_ULONG               tmplCnt = sizeof(tmpl) / sizeof(*tmpl);\n\n    ret = Pkcs11MechAvail(session, CKM_ECDH1_DERIVE);\n    if (ret == 0 && info->pk.ecdh.outlen == NULL) {\n        ret = BAD_FUNC_ARG;\n    }\n    if (ret == 0) {\n        WOLFSSL_MSG(\"PKCS#11: EC Key Derivation Operation\");\n\n\n        if ((sessionKey = !mp_iszero(&info->pk.ecdh.private_key->k)))\n            ret = Pkcs11CreateEccPrivateKey(&privateKey, session,\n                                         info->pk.ecdh.private_key, CKA_DERIVE);\n        else if (info->pk.ecdh.private_key->idLen > 0) {\n            ret = Pkcs11FindKeyById(&privateKey, CKO_PRIVATE_KEY, CKK_EC,\n                                    session, info->pk.ecdh.private_key->id,\n                                    info->pk.ecdh.private_key->idLen);\n        }\n        else {\n            ret = Pkcs11FindEccKey(&privateKey, CKO_PRIVATE_KEY, session,\n                                                      info->pk.ecdh.public_key);\n        }\n    }\n    if (ret == 0) {\n        ret = wc_ecc_export_x963(info->pk.ecdh.public_key, NULL, &pointLen);\n        if (ret == LENGTH_ONLY_E) {\n            point = (unsigned char*)XMALLOC(pointLen,\n                                                 info->pk.ecdh.public_key->heap,\n                                                       DYNAMIC_TYPE_ECC_BUFFER);\n            ret = wc_ecc_export_x963(info->pk.ecdh.public_key, point,\n                                                                     &pointLen);\n        }\n    }\n\n    if (ret == 0) {\n        secSz = *info->pk.ecdh.outlen;\n        if (secSz > (CK_ULONG)info->pk.ecdh.private_key->dp->size)\n            secSz = info->pk.ecdh.private_key->dp->size;\n\n        params.kdf             = CKD_NULL;\n        params.pSharedData     = NULL;\n        params.ulSharedDataLen = 0;\n        params.pPublicData     = point;\n        params.ulPublicDataLen = pointLen;\n\n        mech.mechanism      = CKM_ECDH1_DERIVE;\n        mech.ulParameterLen = sizeof(params);\n        mech.pParameter     = &params;\n\n        rv = session->func->C_DeriveKey(session->handle, &mech, privateKey,\n                                                        tmpl, tmplCnt, &secret);\n        if (rv != CKR_OK)\n            ret = WC_HW_E;\n    }\n\n    if (ret == 0) {\n        ret = Pkcs11ExtractSecret(session, secret, info->pk.ecdh.out,\n                                                          info->pk.ecdh.outlen);\n    }\n\n    if (sessionKey)\n        session->func->C_DestroyObject(session->handle, privateKey);\n\n    if (point != NULL)\n        XFREE(point, info->pk.ecdh.public_key->heap, DYNAMIC_TYPE_ECC_BUFFER);\n\n    return ret;\n}\n#endif\n\n/**\n * Encode, in place, the ECDSA signature.\n * Two fixed width values into ASN.1 DER encoded SEQ { INT, INT }\n *\n * @param  sig  [in,out]  Signature data.\n * @param  sz   [in]      Size of original signature data.\n * @return  Length of the ASN.1 DER enencoded signature.\n */\nstatic word32 Pkcs11ECDSASig_Encode(byte* sig, word32 sz)\n{\n    word32 rHigh, sHigh, seqLen;\n    word32 rStart = 0, sStart = 0;\n    word32 sigSz, rSz, rLen, sSz, sLen;\n    word32 i;\n\n    /* Find first byte of data in r and s. */\n    while (sig[rStart] == 0x00 && rStart < sz - 1)\n        rStart++;\n    while (sig[sz + sStart] == 0x00 && sStart < sz - 1)\n        sStart++;\n    /* Check if 0 needs to be prepended to make integer a positive number. */\n    rHigh = sig[rStart] >> 7;\n    sHigh = sig[sz + sStart] >> 7;\n    /* Calculate length of integer to put into ASN.1 encoding. */\n    rLen = sz - rStart;\n    sLen = sz - sStart;\n    /* r and s: INT (2 bytes) + [ 0x00 ] + integer */\n    rSz = 2 + rHigh + rLen;\n    sSz = 2 + sHigh + sLen;\n    /* Calculate the complete ASN.1 DER encoded size. */\n    sigSz = rSz + sSz;\n    if (sigSz >= ASN_LONG_LENGTH)\n        seqLen = 3;\n    else\n        seqLen = 2;\n\n    /* Move s and then r integers into their final places. */\n    XMEMMOVE(sig + seqLen + rSz + (sSz - sLen), sig + sz + sStart, sLen);\n    XMEMMOVE(sig + seqLen       + (rSz - rLen), sig      + rStart, rLen);\n\n    /* Put the ASN.1 DER encoding around data. */\n    i = 0;\n    sig[i++] = ASN_CONSTRUCTED | ASN_SEQUENCE;\n    if (seqLen == 3)\n        sig[i++] = ASN_LONG_LENGTH | 0x01;\n    sig[i++] = sigSz;\n    sig[i++] = ASN_INTEGER;\n    sig[i++] = rHigh + (sz - rStart);\n    if (rHigh)\n        sig[i++] = 0x00;\n    i += sz - rStart;\n    sig[i++] = ASN_INTEGER;\n    sig[i++] = sHigh + (sz - sStart);\n    if (sHigh)\n        sig[i] = 0x00;\n\n    return seqLen + sigSz;\n}\n\n/**\n * Decode the ECDSA signature.\n * ASN.1 DER encode SEQ { INT, INT } converted to two fixed with values.\n *\n * @param  in    [in]  ASN.1 DER encoded signature.\n * @param  inSz  [in]  Size of ASN.1 signature.\n * @param  sig   [in]  Output buffer.\n * @param  sz    [in]  Size of output buffer.\n * @return  ASN_PARSE_E when the ASN.1 encoding is invalid.\n *          0 on success.\n */\nstatic int Pkcs11ECDSASig_Decode(const byte* in, word32 inSz, byte* sig,\n                                 word32 sz)\n{\n    int ret = 0;\n    word32 i = 0;\n    byte   tag;\n    int len, seqLen = 2;\n\n    /* Make sure zeros in place when decoding short integers. */\n    XMEMSET(sig, 0, sz * 2);\n\n    /* Check min data for: SEQ + INT. */\n    if (inSz < 5)\n        ret = ASN_PARSE_E;\n    /* Check SEQ */\n    if (ret == 0 && in[i++] != (ASN_CONSTRUCTED | ASN_SEQUENCE))\n        ret = ASN_PARSE_E;\n    if (ret == 0 && in[i] >= ASN_LONG_LENGTH) {\n        if (in[i] != (ASN_LONG_LENGTH | 0x01))\n            ret = ASN_PARSE_E;\n        else {\n            i++;\n            seqLen++;\n        }\n    }\n    if (ret == 0 && in[i++] != inSz - seqLen)\n        ret = ASN_PARSE_E;\n\n    /* Check INT */\n    if (ret == 0 && GetASNTag(in, &i, &tag, inSz) != 0)\n        ret = ASN_PARSE_E;\n    if (ret == 0 && tag != ASN_INTEGER)\n        ret = ASN_PARSE_E;\n    if (ret == 0 && (len = in[i++]) > sz + 1)\n        ret = ASN_PARSE_E;\n    /* Check there is space for INT data */\n    if (ret == 0 && i + len > inSz)\n        ret = ASN_PARSE_E;\n    if (ret == 0) {\n        /* Skip leading zero */\n        if (in[i] == 0x00) {\n            i++;\n            len--;\n        }\n        /* Copy r into sig. */\n        XMEMCPY(sig + sz - len, in + i, len);\n        i += len;\n    }\n\n    /* Check min data for: INT. */\n    if (ret == 0 && i + 2 > inSz)\n        ret = ASN_PARSE_E;\n    /* Check INT */\n    if (ret == 0 && GetASNTag(in, &i, &tag, inSz) != 0)\n        ret = ASN_PARSE_E;\n    if (ret == 0 && tag != ASN_INTEGER)\n        ret = ASN_PARSE_E;\n    if (ret == 0 && (len = in[i++]) > sz + 1)\n        ret = ASN_PARSE_E;\n    /* Check there is space for INT data */\n    if (ret == 0 && i + len > inSz)\n        ret = ASN_PARSE_E;\n    if (ret == 0) {\n        /* Skip leading zero */\n        if (in[i] == 0x00) {\n            i++;\n            len--;\n        }\n        /* Copy s into sig. */\n        XMEMCPY(sig + sz + sz - len, in + i, len);\n    }\n\n    return ret;\n}\n\n/**\n * Get the parameters from the private key on the device.\n *\n * @param  session  [in]  Session object.\n * @param  privKey  [in]  PKCS #11 object handle of private key..\n * @param  key      [in]  Ecc key to set parameters against.\n * @return  WC_HW_E when a PKCS#11 library call fails.\n *          0 on success.\n */\nstatic int Pkcs11GetEccParams(Pkcs11Session* session, CK_OBJECT_HANDLE privKey,\n                              ecc_key* key)\n{\n    int          ret = 0;\n    int          curveId;\n    CK_RV        rv;\n    byte         oid[16];\n    CK_ATTRIBUTE template[] = {\n        { CKA_EC_PARAMS, (CK_VOID_PTR)oid, sizeof(oid) }\n    };\n\n    rv = session->func->C_GetAttributeValue(session->handle, privKey, template,\n                                                                             1);\n    if (rv != CKR_OK)\n        ret = WC_HW_E;\n    if (ret == 0) {\n        /* PKCS #11 wraps the OID in ASN.1 */\n        curveId = wc_ecc_get_curve_id_from_oid(oid + 2,\n                                            (word32)template[0].ulValueLen - 2);\n        if (curveId == ECC_CURVE_INVALID)\n            ret = WC_HW_E;\n    }\n    if (ret == 0)\n        ret = wc_ecc_set_curve(key, 0, curveId);\n\n    return ret;\n}\n\n/**\n * Performs the ECDSA signing operation.\n *\n * @param  session  [in]  Session object.\n * @param  info     [in]  Cryptographic operation data.\n * @return  WC_HW_E when a PKCS#11 library call fails.\n *          0 on success.\n */\nstatic int Pkcs11ECDSA_Sign(Pkcs11Session* session, wc_CryptoInfo* info)\n{\n    int                    ret = 0;\n    int                    sessionKey = 0;\n    word32                 sz;\n    CK_RV                  rv;\n    CK_ULONG               outLen;\n    CK_MECHANISM           mech;\n    CK_MECHANISM_INFO      mechInfo;\n    CK_OBJECT_HANDLE       privateKey = NULL_PTR;\n\n    /* Check operation is supported. */\n    rv = session->func->C_GetMechanismInfo(session->slotId, CKM_ECDSA,\n                                                                     &mechInfo);\n    if (rv != CKR_OK || (mechInfo.flags & CKF_SIGN) == 0)\n        ret = NOT_COMPILED_IN;\n\n    if (ret == 0 && info->pk.eccsign.outlen == NULL) {\n        ret = BAD_FUNC_ARG;\n    }\n    if (ret == 0) {\n        WOLFSSL_MSG(\"PKCS#11: EC Signing Operation\");\n\n        if ((sessionKey = !mp_iszero(&info->pk.eccsign.key->k)))\n            ret = Pkcs11CreateEccPrivateKey(&privateKey, session,\n                                                info->pk.eccsign.key, CKA_SIGN);\n        else if (info->pk.eccsign.key->idLen > 0) {\n            ret = Pkcs11FindKeyById(&privateKey, CKO_PRIVATE_KEY, CKK_EC,\n                                    session, info->pk.eccsign.key->id,\n                                    info->pk.eccsign.key->idLen);\n            if (ret == 0 && info->pk.eccsign.key->dp == NULL) {\n                ret = Pkcs11GetEccParams(session, privateKey,\n                                                          info->pk.eccsign.key);\n            }\n        }\n        else {\n            ret = Pkcs11FindEccKey(&privateKey, CKO_PRIVATE_KEY, session,\n                                                          info->pk.eccsign.key);\n        }\n    }\n\n    if (ret == 0) {\n        sz = info->pk.eccsign.key->dp->size;\n        /* Maximum encoded size is two ordinates + 8 bytes of ASN.1. */\n        if (*info->pk.eccsign.outlen < (word32)wc_ecc_sig_size_calc(sz))\n            ret = BUFFER_E;\n    }\n\n    if (ret == 0) {\n        mech.mechanism      = CKM_ECDSA;\n        mech.ulParameterLen = 0;\n        mech.pParameter     = NULL;\n\n        rv = session->func->C_SignInit(session->handle, &mech, privateKey);\n        if (rv != CKR_OK)\n            ret = WC_HW_E;\n    }\n\n    if (ret == 0) {\n        outLen = *info->pk.eccsign.outlen;\n        rv = session->func->C_Sign(session->handle,\n                                   (CK_BYTE_PTR)info->pk.eccsign.in,\n                                   info->pk.eccsign.inlen, info->pk.eccsign.out,\n                                   &outLen);\n        if (rv != CKR_OK)\n            ret = WC_HW_E;\n    }\n\n    if (ret == 0) {\n        *info->pk.eccsign.outlen = Pkcs11ECDSASig_Encode(info->pk.eccsign.out,\n                                                         sz);\n    }\n\n    if (sessionKey)\n        session->func->C_DestroyObject(session->handle, privateKey);\n\n    return ret;\n}\n\n/**\n * Performs the ECDSA verification operation.\n *\n * @param  session  [in]  Session object.\n * @param  info     [in]  Cryptographic operation data.\n * @return  WC_HW_E when a PKCS#11 library call fails.\n *          MEMORY_E when a memory allocation fails.\n *          0 on success.\n */\nstatic int Pkcs11ECDSA_Verify(Pkcs11Session* session, wc_CryptoInfo* info)\n{\n    int                    ret = 0;\n    CK_RV                  rv;\n    CK_MECHANISM           mech;\n    CK_MECHANISM_INFO      mechInfo;\n    CK_OBJECT_HANDLE       publicKey = NULL_PTR;\n    unsigned char*         sig = NULL;\n    word32                 sz = info->pk.eccverify.key->dp->size;\n\n    /* Check operation is supported. */\n    rv = session->func->C_GetMechanismInfo(session->slotId, CKM_ECDSA,\n                                                                     &mechInfo);\n    if (rv != CKR_OK || (mechInfo.flags & CKF_VERIFY) == 0)\n        ret = NOT_COMPILED_IN;\n\n    if (ret == 0 && info->pk.eccverify.res == NULL) {\n        ret = BAD_FUNC_ARG;\n    }\n\n    if (ret == 0) {\n        WOLFSSL_MSG(\"PKCS#11: EC Verification Operation\");\n\n        ret = Pkcs11CreateEccPublicKey(&publicKey, session,\n                                            info->pk.eccverify.key, CKA_VERIFY);\n    }\n\n    if (ret == 0) {\n        sig = XMALLOC(sz * 2, info->pk.eccverify.key->heap,\n                                                       DYNAMIC_TYPE_TMP_BUFFER);\n        if (sig == NULL)\n            ret = MEMORY_E;\n    }\n\n    if (ret == 0) {\n        ret = Pkcs11ECDSASig_Decode(info->pk.eccverify.sig,\n                                    info->pk.eccverify.siglen, sig, sz);\n    }\n    if (ret == 0) {\n        mech.mechanism      = CKM_ECDSA;\n        mech.ulParameterLen = 0;\n        mech.pParameter     = NULL;\n\n        rv = session->func->C_VerifyInit(session->handle, &mech, publicKey);\n        if (rv != CKR_OK)\n            ret = WC_HW_E;\n    }\n\n    if (ret == 0) {\n        *info->pk.eccverify.res = 0;\n        rv = session->func->C_Verify(session->handle,\n                                     (CK_BYTE_PTR)info->pk.eccverify.hash,\n                                     info->pk.eccverify.hashlen,\n                                     (CK_BYTE_PTR)sig, sz * 2);\n        if (rv == CKR_SIGNATURE_INVALID) {\n        }\n        else if (rv != CKR_OK)\n            ret = WC_HW_E;\n        else\n            *info->pk.eccverify.res = 1;\n    }\n\n    if (publicKey != NULL_PTR)\n        session->func->C_DestroyObject(session->handle, publicKey);\n\n    if (sig != NULL)\n        XFREE(sig, info->pk.eccverify.key->heap, DYNAMIC_TYPE_TMP_BUFFER);\n\n    return ret;\n}\n#endif\n\n#if !defined(NO_AES) && defined(HAVE_AESGCM)\n/**\n * Performs the AES-GCM encryption operation.\n *\n * @param  session  [in]  Session object.\n * @param  info     [in]  Cryptographic operation data.\n * @return  WC_HW_E when a PKCS#11 library call fails.\n *          MEMORY_E when a memory allocation fails.\n *          0 on success.\n */\nstatic int Pkcs11AesGcmEncrypt(Pkcs11Session* session, wc_CryptoInfo* info)\n{\n    int                ret = 0;\n    CK_RV              rv;\n    Aes*               aes = info->cipher.aesgcm_enc.aes;\n    CK_GCM_PARAMS      params;\n    CK_MECHANISM_INFO  mechInfo;\n    CK_OBJECT_HANDLE   key = NULL_PTR;\n    CK_MECHANISM       mech;\n    CK_ULONG           outLen;\n\n    /* Check operation is supported. */\n    rv = session->func->C_GetMechanismInfo(session->slotId, CKM_AES_GCM,\n                                                                     &mechInfo);\n    if (rv != CKR_OK || (mechInfo.flags & CKF_ENCRYPT) == 0)\n        ret = NOT_COMPILED_IN;\n\n    if (ret == 0) {\n        WOLFSSL_MSG(\"PKCS#11: AES-GCM Encryption Operation\");\n    }\n\n    /* Create a private key object or find by id. */\n    if (ret == 0 && aes->idLen == 0) {\n        ret = Pkcs11CreateSecretKey(&key, session, CKK_AES,\n                                    (unsigned char*)aes->devKey, aes->keylen,\n                                    NULL, 0);\n\n    }\n    else if (ret == 0) {\n        ret = Pkcs11FindKeyById(&key, CKO_SECRET_KEY, CKK_AES, session, aes->id,\n                                                                    aes->idLen);\n    }\n\n    if (ret == 0) {\n        params.pIv       = (CK_BYTE_PTR)info->cipher.aesgcm_enc.iv;\n        params.ulIvLen   = info->cipher.aesgcm_enc.ivSz;\n        params.pAAD      = (CK_BYTE_PTR)info->cipher.aesgcm_enc.authIn;\n        params.ulAADLen  = info->cipher.aesgcm_enc.authInSz;\n        params.ulTagBits = info->cipher.aesgcm_enc.authTagSz * 8;\n\n        mech.mechanism      = CKM_AES_GCM;\n        mech.ulParameterLen = sizeof(params);\n        mech.pParameter     = &params;\n\n        rv = session->func->C_EncryptInit(session->handle, &mech, key);\n        if (rv != CKR_OK)\n            ret = WC_HW_E;\n    }\n    if (ret == 0) {\n        outLen = info->cipher.aesgcm_enc.sz;\n        rv = session->func->C_EncryptUpdate(session->handle,\n                                        (CK_BYTE_PTR)info->cipher.aesgcm_enc.in,\n                                        info->cipher.aesgcm_enc.sz,\n                                        info->cipher.aesgcm_enc.out,\n                                        &outLen);\n        if (rv != CKR_OK)\n            ret = WC_HW_E;\n    }\n    if (ret == 0) {\n        /* Authentication tag comes out in final block. */\n        outLen = info->cipher.aesgcm_enc.authTagSz;\n        rv = session->func->C_EncryptFinal(session->handle,\n                                           info->cipher.aesgcm_enc.authTag,\n                                           &outLen);\n        if (rv != CKR_OK)\n            ret = WC_HW_E;\n    }\n\n    if (aes->idLen == 0 && key != NULL_PTR)\n        session->func->C_DestroyObject(session->handle, key);\n\n    return ret;\n}\n\n/**\n * Performs the AES-GCM decryption operation.\n *\n * @param  session  [in]  Session object.\n * @param  info     [in]  Cryptographic operation data.\n * @return  WC_HW_E when a PKCS#11 library call fails.\n *          MEMORY_E when a memory allocation fails.\n *          0 on success.\n */\nstatic int Pkcs11AesGcmDecrypt(Pkcs11Session* session, wc_CryptoInfo* info)\n{\n    int                ret = 0;\n    CK_RV              rv;\n    Aes*               aes = info->cipher.aesgcm_enc.aes;\n    CK_GCM_PARAMS      params;\n    CK_MECHANISM_INFO  mechInfo;\n    CK_OBJECT_HANDLE   key = NULL_PTR;\n    CK_MECHANISM       mech;\n    CK_ULONG           outLen;\n    word32             len;\n\n    /* Check operation is supported. */\n    rv = session->func->C_GetMechanismInfo(session->slotId, CKM_AES_GCM,\n                                                                     &mechInfo);\n    if (rv != CKR_OK || (mechInfo.flags & CKF_DECRYPT) == 0)\n        ret = NOT_COMPILED_IN;\n\n    if (ret == 0) {\n        WOLFSSL_MSG(\"PKCS#11: AES-GCM Decryption Operation\");\n    }\n\n    /* Create a private key object or find by id. */\n    if (ret == 0 && aes->idLen == 0) {\n        ret = Pkcs11CreateSecretKey(&key, session, CKK_AES,\n                                    (unsigned char*)aes->devKey, aes->keylen,\n                                    NULL, 0);\n    }\n    else if (ret == 0) {\n        ret = Pkcs11FindKeyById(&key, CKO_SECRET_KEY, CKK_AES, session, aes->id,\n                                                                    aes->idLen);\n    }\n\n    if (ret == 0) {\n        params.pIv       = (CK_BYTE_PTR)info->cipher.aesgcm_dec.iv;\n        params.ulIvLen   = info->cipher.aesgcm_dec.ivSz;\n        params.pAAD      = (CK_BYTE_PTR)info->cipher.aesgcm_dec.authIn;\n        params.ulAADLen  = info->cipher.aesgcm_dec.authInSz;\n        params.ulTagBits = info->cipher.aesgcm_dec.authTagSz * 8;\n\n        mech.mechanism      = CKM_AES_GCM;\n        mech.ulParameterLen = sizeof(params);\n        mech.pParameter     = &params;\n\n        rv = session->func->C_DecryptInit(session->handle, &mech, key);\n        if (rv != CKR_OK)\n            ret = WC_HW_E;\n    }\n    if (ret == 0) {\n        outLen = len = info->cipher.aesgcm_dec.sz;\n        rv = session->func->C_DecryptUpdate(session->handle,\n                                        (CK_BYTE_PTR)info->cipher.aesgcm_dec.in,\n                                        info->cipher.aesgcm_dec.sz,\n                                        info->cipher.aesgcm_dec.out,\n                                        &outLen);\n        if (rv != CKR_OK)\n            ret = WC_HW_E;\n    }\n    if (ret == 0) {\n        /* Put authentication tag in as encrypted data. */\n        outLen = len = (len + info->cipher.aesgcm_dec.authTagSz -\n                                                                (word32)outLen);\n        rv = session->func->C_DecryptUpdate(session->handle,\n                                   (CK_BYTE_PTR)info->cipher.aesgcm_dec.authTag,\n                                   info->cipher.aesgcm_dec.authTagSz,\n                                   info->cipher.aesgcm_dec.out,\n                                   &outLen);\n        if (rv != CKR_OK)\n            ret = WC_HW_E;\n    }\n    if (ret == 0) {\n        outLen = len = (len - (word32)outLen);\n        /* Decrypted data comes out now. */\n        rv = session->func->C_DecryptFinal(session->handle,\n                                           info->cipher.aesgcm_dec.out,\n                                           &outLen);\n        if (rv != CKR_OK)\n            ret = WC_HW_E;\n    }\n\n    if (aes->idLen == 0 && key != NULL_PTR)\n        session->func->C_DestroyObject(session->handle, key);\n\n    return ret;\n}\n#endif\n\n#if !defined(NO_AES) && defined(HAVE_AES_CBC)\n/**\n * Performs the AES-CBC encryption operation.\n *\n * @param  session  [in]  Session object.\n * @param  info     [in]  Cryptographic operation data.\n * @return  WC_HW_E when a PKCS#11 library call fails.\n *          MEMORY_E when a memory allocation fails.\n *          0 on success.\n */\nstatic int Pkcs11AesCbcEncrypt(Pkcs11Session* session, wc_CryptoInfo* info)\n{\n    int                ret = 0;\n    CK_RV              rv;\n    Aes*               aes = info->cipher.aescbc.aes;\n    CK_MECHANISM_INFO  mechInfo;\n    CK_OBJECT_HANDLE   key = NULL_PTR;\n    CK_MECHANISM       mech;\n    CK_ULONG           outLen;\n\n    /* Check operation is supported. */\n    rv = session->func->C_GetMechanismInfo(session->slotId, CKM_AES_CBC,\n                                                                     &mechInfo);\n    if (rv != CKR_OK || (mechInfo.flags & CKF_ENCRYPT) == 0)\n        ret = NOT_COMPILED_IN;\n\n    if (ret == 0) {\n        WOLFSSL_MSG(\"PKCS#11: AES-CBC Encryption Operation\");\n    }\n\n    /* Create a private key object or find by id. */\n    if (ret == 0 && aes->idLen == 0) {\n        ret = Pkcs11CreateSecretKey(&key, session, CKK_AES,\n                                    (unsigned char*)aes->devKey, aes->keylen,\n                                    NULL, 0);\n\n    }\n    else if (ret == 0) {\n        ret = Pkcs11FindKeyById(&key, CKO_SECRET_KEY, CKK_AES, session, aes->id,\n                                                                    aes->idLen);\n    }\n\n    if (ret == 0) {\n        mech.mechanism      = CKM_AES_CBC;\n        mech.ulParameterLen = AES_BLOCK_SIZE;\n        mech.pParameter     = (CK_BYTE_PTR)info->cipher.aescbc.aes->reg;\n\n        rv = session->func->C_EncryptInit(session->handle, &mech, key);\n        if (rv != CKR_OK)\n            ret = WC_HW_E;\n    }\n    if (ret == 0) {\n        outLen = info->cipher.aescbc.sz;\n        rv = session->func->C_Encrypt(session->handle,\n                                      (CK_BYTE_PTR)info->cipher.aescbc.in,\n                                      info->cipher.aescbc.sz,\n                                      info->cipher.aescbc.out,\n                                      &outLen);\n        if (rv != CKR_OK)\n            ret = WC_HW_E;\n    }\n\n    if (aes->idLen == 0 && key != NULL_PTR)\n        session->func->C_DestroyObject(session->handle, key);\n\n    return ret;\n}\n\n/**\n * Performs the AES-CBC decryption operation.\n *\n * @param  session  [in]  Session object.\n * @param  info     [in]  Cryptographic operation data.\n * @return  WC_HW_E when a PKCS#11 library call fails.\n *          MEMORY_E when a memory allocation fails.\n *          0 on success.\n */\nstatic int Pkcs11AesCbcDecrypt(Pkcs11Session* session, wc_CryptoInfo* info)\n{\n    int                ret = 0;\n    CK_RV              rv;\n    Aes*               aes = info->cipher.aescbc.aes;\n    CK_MECHANISM_INFO  mechInfo;\n    CK_OBJECT_HANDLE   key = NULL_PTR;\n    CK_MECHANISM       mech;\n    CK_ULONG           outLen;\n\n    /* Check operation is supported. */\n    rv = session->func->C_GetMechanismInfo(session->slotId, CKM_AES_CBC,\n                                                                     &mechInfo);\n    if (rv != CKR_OK || (mechInfo.flags & CKF_DECRYPT) == 0)\n        ret = NOT_COMPILED_IN;\n\n    if (ret == 0) {\n        WOLFSSL_MSG(\"PKCS#11: AES-CBC Decryption Operation\");\n    }\n\n    /* Create a private key object or find by id. */\n    if (ret == 0 && aes->idLen == 0) {\n        ret = Pkcs11CreateSecretKey(&key, session, CKK_AES,\n                                    (unsigned char*)aes->devKey, aes->keylen,\n                                    NULL, 0);\n    }\n    else if (ret == 0) {\n        ret = Pkcs11FindKeyById(&key, CKO_SECRET_KEY, CKK_AES, session, aes->id,\n                                                                    aes->idLen);\n    }\n\n    if (ret == 0) {\n        mech.mechanism      = CKM_AES_CBC;\n        mech.ulParameterLen = AES_BLOCK_SIZE;\n        mech.pParameter     = (CK_BYTE_PTR)info->cipher.aescbc.aes->reg;\n\n        rv = session->func->C_DecryptInit(session->handle, &mech, key);\n        if (rv != CKR_OK)\n            ret = WC_HW_E;\n    }\n    if (ret == 0) {\n        outLen = info->cipher.aescbc.sz;\n        rv = session->func->C_DecryptUpdate(session->handle,\n                                        (CK_BYTE_PTR)info->cipher.aescbc.in,\n                                        info->cipher.aescbc.sz,\n                                        info->cipher.aescbc.out,\n                                        &outLen);\n        if (rv != CKR_OK)\n            ret = WC_HW_E;\n    }\n\n    if (aes->idLen == 0 && key != NULL_PTR)\n        session->func->C_DestroyObject(session->handle, key);\n\n    return ret;\n}\n#endif\n\n#ifndef NO_HMAC\n/**\n * Updates or calculates the HMAC of the data.\n *\n * @param  session  [in]  Session object.\n * @param  info     [in]  Cryptographic operation data.\n * @return  WC_HW_E when a PKCS#11 library call fails.\n *          0 on success.\n */\nstatic int Pkcs11Hmac(Pkcs11Session* session, wc_CryptoInfo* info)\n{\n    int                ret = 0;\n    CK_RV              rv;\n    Hmac*              hmac = info->hmac.hmac;\n    CK_MECHANISM_INFO  mechInfo;\n    CK_OBJECT_HANDLE   key = NULL_PTR;\n    CK_MECHANISM       mech;\n    CK_ULONG           outLen;\n    int                mechType;\n    int                keyType;\n\n    if (hmac->innerHashKeyed == WC_HMAC_INNER_HASH_KEYED_SW)\n        ret = NOT_COMPILED_IN;\n\n    if (ret == 0)\n        ret = Pkcs11HmacTypes(info->hmac.macType, &mechType, &keyType);\n    if (ret == 0) {\n        /* Check operation is supported. */\n        rv = session->func->C_GetMechanismInfo(session->slotId, mechType,\n                                                                     &mechInfo);\n        if (rv != CKR_OK || (mechInfo.flags & CKF_SIGN) == 0)\n            ret = NOT_COMPILED_IN;\n    }\n\n    /* Check whether key been used to initialized. */\n    if (ret == 0 && !hmac->innerHashKeyed) {\n        WOLFSSL_MSG(\"PKCS#11: HMAC Init\");\n\n        /* Check device supports key length. */\n        if (mechInfo.ulMaxKeySize > 0 &&\n                                       (hmac->keyLen < mechInfo.ulMinKeySize ||\n                                        hmac->keyLen > mechInfo.ulMaxKeySize)) {\n            WOLFSSL_MSG(\"PKCS#11: Key Length not supported\");\n            ret = NOT_COMPILED_IN;\n        }\n\n        /* Create a private key object or find by id. */\n        if (ret == 0 && hmac->idLen == 0) {\n            ret = Pkcs11CreateSecretKey(&key, session, keyType,\n                                    (unsigned char*)hmac->keyRaw, hmac->keyLen,\n                                    NULL, 0);\n            if (ret == WC_HW_E) {\n                ret = Pkcs11CreateSecretKey(&key, session, CKK_GENERIC_SECRET,\n                                    (unsigned char*)hmac->keyRaw, hmac->keyLen,\n                                    NULL, 0);\n            }\n\n        }\n        else if (ret == 0) {\n            ret = Pkcs11FindKeyById(&key, CKO_SECRET_KEY, keyType, session,\n                                                         hmac->id, hmac->idLen);\n            if (ret == WC_HW_E) {\n                ret = Pkcs11FindKeyById(&key, CKO_SECRET_KEY,\n                                          CKK_GENERIC_SECRET, session, hmac->id,\n                                          hmac->idLen);\n            }\n        }\n\n        /* Initialize HMAC operation */\n        if (ret == 0) {\n            mech.mechanism      = mechType;\n            mech.ulParameterLen = 0;\n            mech.pParameter     = NULL;\n\n            rv = session->func->C_SignInit(session->handle, &mech, key);\n            if (rv != CKR_OK)\n                ret = WC_HW_E;\n        }\n\n        /* Don't imitialize HMAC again if this succeeded */\n        if (ret == 0)\n            hmac->innerHashKeyed = WC_HMAC_INNER_HASH_KEYED_DEV;\n    }\n    /* Update the HMAC if input data passed in. */\n    if (ret == 0 && info->hmac.inSz > 0) {\n        WOLFSSL_MSG(\"PKCS#11: HMAC Update\");\n\n        rv = session->func->C_SignUpdate(session->handle,\n                                         (CK_BYTE_PTR)info->hmac.in,\n                                         info->hmac.inSz);\n        /* Some algorithm implementations only support C_Sign. */\n        if (rv == CKR_MECHANISM_INVALID) {\n            WOLFSSL_MSG(\"PKCS#11: HMAC Update/Final not supported\");\n            ret = NOT_COMPILED_IN;\n            /* Allow software implementation to set key. */\n            hmac->innerHashKeyed = 0;\n        }\n        else if (rv != CKR_OK)\n            ret = WC_HW_E;\n    }\n    /* Calculate the HMAC result if output buffer specified. */\n    if (ret == 0 && info->hmac.digest != NULL) {\n        WOLFSSL_MSG(\"PKCS#11: HMAC Final\");\n\n        outLen = WC_MAX_DIGEST_SIZE;\n        rv = session->func->C_SignFinal(session->handle,\n                                        (CK_BYTE_PTR)info->hmac.digest,\n                                        &outLen);\n        /* Some algorithm implementations only support C_Sign. */\n        if (rv != CKR_OK)\n            ret = WC_HW_E;\n        else\n            hmac->innerHashKeyed = 0;\n    }\n\n    if (hmac->idLen == 0 && key != NULL_PTR)\n        session->func->C_DestroyObject(session->handle, key);\n\n    return ret;\n}\n#endif\n\n#ifndef WC_NO_RNG\n#ifndef HAVE_HASHDRBG\n/**\n * Performs random number generation.\n *\n * @param  session  [in]  Session object.\n * @param  info     [in]  Cryptographic operation data.\n * @return  WC_HW_E when a PKCS#11 library call fails.\n *          0 on success.\n */\nstatic int Pkcs11RandomBlock(Pkcs11Session* session, wc_CryptoInfo* info)\n{\n    int                ret = 0;\n    CK_RV              rv;\n\n    rv = session->func->C_GenerateRandom(session->handle, info->rng.out,\n                                                                  info->rng.sz);\n    if (rv != CKR_OK)\n        ret = WC_HW_E;\n    return ret;\n}\n#endif\n\n/**\n * Generates entropy (seed) data.\n *\n * @param  session  [in]  Session object.\n * @param  info     [in]  Cryptographic operation data.\n * @return  WC_HW_E when a PKCS#11 library call fails.\n *          0 on success.\n */\nstatic int Pkcs11RandomSeed(Pkcs11Session* session, wc_CryptoInfo* info)\n{\n    int                ret = 0;\n    CK_RV              rv;\n\n    rv = session->func->C_GenerateRandom(session->handle, info->seed.seed,\n                                                                 info->seed.sz);\n    if (rv != CKR_OK)\n        ret = WC_HW_E;\n    return ret;\n}\n#endif\n\n/**\n * Perform a cryptographic operation using PKCS#11 device.\n *\n * @param  devId  [in]  Device identifier.\n * @param  info   [in]  Cryptographic operation data.\n * @param  ctx    [in]  Context data for device - the token object.\n * @return  WC_HW_E when a PKCS#11 library call fails.\n *          0 on success.\n */\nint wc_Pkcs11_CryptoDevCb(int devId, wc_CryptoInfo* info, void* ctx)\n{\n    int ret = 0;\n    Pkcs11Token* token = (Pkcs11Token*)ctx;\n    Pkcs11Session session;\n    int readWrite = 0;\n\n    if (devId <= INVALID_DEVID || info == NULL || ctx == NULL)\n        ret = BAD_FUNC_ARG;\n\n    if (ret == 0) {\n        ret = Pkcs11OpenSession(token, &session, readWrite);\n        if (ret == 0) {\n            if (info->algo_type == WC_ALGO_TYPE_PK) {\n#if !defined(NO_RSA) || defined(HAVE_ECC)\n                switch (info->pk.type) {\n    #ifndef NO_RSA\n                    case WC_PK_TYPE_RSA:\n                        ret = Pkcs11Rsa(&session, info);\n                        break;\n        #ifdef WOLFSSL_KEY_GEN\n                    case WC_PK_TYPE_RSA_KEYGEN:\n                        ret = Pkcs11RsaKeyGen(&session, info);\n                        break;\n        #endif\n    #endif\n    #ifdef HAVE_ECC\n        #ifndef NO_PKCS11_EC_KEYGEN\n                    case WC_PK_TYPE_EC_KEYGEN:\n                        ret = Pkcs11EcKeyGen(&session, info);\n                        break;\n        #endif\n        #ifndef NO_PKCS11_ECDH\n                    case WC_PK_TYPE_ECDH:\n                        ret = Pkcs11ECDH(&session, info);\n                        break;\n        #endif\n                    case WC_PK_TYPE_ECDSA_SIGN:\n                        ret = Pkcs11ECDSA_Sign(&session, info);\n                        break;\n                    case WC_PK_TYPE_ECDSA_VERIFY:\n                        ret = Pkcs11ECDSA_Verify(&session, info);\n                        break;\n    #endif\n                    default:\n                        ret = NOT_COMPILED_IN;\n                        break;\n                }\n#else\n                ret = NOT_COMPILED_IN;\n#endif /* !NO_RSA || HAVE_ECC */\n            }\n            else if (info->algo_type == WC_ALGO_TYPE_CIPHER) {\n    #ifndef NO_AES\n                switch (info->cipher.type) {\n        #ifdef HAVE_AESGCM\n                    case WC_CIPHER_AES_GCM:\n                        if (info->cipher.enc)\n                            ret = Pkcs11AesGcmEncrypt(&session, info);\n                        else\n                            ret = Pkcs11AesGcmDecrypt(&session, info);\n                        break;\n        #endif\n        #ifdef HAVE_AES_CBC\n                    case WC_CIPHER_AES_CBC:\n                        if (info->cipher.enc)\n                            ret = Pkcs11AesCbcEncrypt(&session, info);\n                        else\n                            ret = Pkcs11AesCbcDecrypt(&session, info);\n                        break;\n        #endif\n                }\n    #else\n                ret = NOT_COMPILED_IN;\n    #endif\n            }\n            else if (info->algo_type == WC_ALGO_TYPE_HMAC) {\n    #ifndef NO_HMAC\n                ret = Pkcs11Hmac(&session, info);\n    #else\n                ret = NOT_COMPILED_IN;\n    #endif\n            }\n            else if (info->algo_type == WC_ALGO_TYPE_RNG) {\n    #if !defined(WC_NO_RNG) && !defined(HAVE_HASHDRBG)\n                ret = Pkcs11RandomBlock(&session, info);\n    #else\n                ret = NOT_COMPILED_IN;\n    #endif\n            }\n            else if (info->algo_type == WC_ALGO_TYPE_SEED) {\n    #ifndef WC_NO_RNG\n                ret = Pkcs11RandomSeed(&session, info);\n    #else\n                ret = NOT_COMPILED_IN;\n    #endif\n            }\n            else\n                ret = NOT_COMPILED_IN;\n\n            Pkcs11CloseSession(token, &session);\n        }\n    }\n\n    return ret;\n}\n\n#endif /* HAVE_PKCS11 */\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/sql-common/client_plugin.c": "/* Copyright (C) 2010 Sergei Golubchik and Monty Program Ab\n   Copyright (c) 2010, 2011, Oracle and/or its affiliates.\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; version 2 of the License.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1335  USA */\n\n/**\n  @file\n  \n  Support code for the client side (libmysql) plugins\n\n  Client plugins are somewhat different from server plugins, they are simpler.\n\n  They do not need to be installed or in any way explicitly loaded on the\n  client, they are loaded automatically on demand.\n  One client plugin per shared object, soname *must* match the plugin name.\n\n  There is no reference counting and no unloading either.\n*/\n\n#include <my_global.h>\n#include \"mysql.h\"\n#include <my_sys.h>\n#include <m_string.h>\n#include <my_pthread.h>\n\n#include <sql_common.h>\n#include \"errmsg.h\"\n#include <mysql/client_plugin.h>\n\nstruct st_client_plugin_int {\n  struct st_client_plugin_int *next;\n  void   *dlhandle;\n  struct st_mysql_client_plugin *plugin;\n};\n\nstatic my_bool initialized= 0;\nstatic MEM_ROOT mem_root;\n\n#define plugin_declarations_sym \"_mysql_client_plugin_declaration_\"\n\nstatic uint plugin_version[MYSQL_CLIENT_MAX_PLUGINS]=\n{\n  0, /* these two are taken by Connector/C */\n  0, /* these two are taken by Connector/C */\n  MYSQL_CLIENT_AUTHENTICATION_PLUGIN_INTERFACE_VERSION\n};\n\n/*\n  Loaded plugins are stored in a linked list.\n  The list is append-only, the elements are added to the head (like in a stack).\n  The elements are added under a mutex, but the list can be read and traversed\n  without any mutex because once an element is added to the list, it stays\n  there. The main purpose of a mutex is to prevent two threads from\n  loading the same plugin twice in parallel.\n*/\nstruct st_client_plugin_int *plugin_list[MYSQL_CLIENT_MAX_PLUGINS];\nstatic mysql_mutex_t LOCK_load_client_plugin;\n\nstatic int is_not_initialized(MYSQL *mysql, const char *name)\n{\n  DBUG_ENTER(\"is_not_initialized\");\n\n  if (initialized)\n    DBUG_RETURN(0);\n\n  set_mysql_extended_error(mysql, CR_AUTH_PLUGIN_CANNOT_LOAD,\n                           unknown_sqlstate, ER(CR_AUTH_PLUGIN_CANNOT_LOAD),\n                           name, \"not initialized\");\n  DBUG_RETURN(1);\n}\n\n/**\n  finds a plugin in the list\n\n  @param name   plugin name to search for\n  @param type   plugin type\n\n  @note this does NOT necessarily need a mutex, take care!\n  \n  @retval a pointer to a found plugin or 0\n*/\nstatic struct st_mysql_client_plugin *\nfind_plugin(const char *name, int type)\n{\n  struct st_client_plugin_int *p;\n  DBUG_ENTER(\"find_plugin\");\n\n  DBUG_ASSERT(initialized);\n  DBUG_ASSERT(type >= 0 && type < MYSQL_CLIENT_MAX_PLUGINS);\n  if (type < 0 || type >= MYSQL_CLIENT_MAX_PLUGINS)\n    DBUG_RETURN(0);\n\n  for (p= plugin_list[type]; p; p= p->next)\n  {\n    if (strcmp(p->plugin->name, name) == 0)\n      DBUG_RETURN(p->plugin);\n  }\n  DBUG_RETURN(NULL);\n}\n\n/**\n  verifies the plugin and adds it to the list\n\n  @param mysql          MYSQL structure (for error reporting)\n  @param plugin         plugin to install\n  @param dlhandle       a handle to the shared object (returned by dlopen)\n                        or 0 if the plugin was not dynamically loaded\n  @param argc           number of arguments in the 'va_list args'\n  @param args           arguments passed to the plugin initialization function\n\n  @retval a pointer to an installed plugin or 0\n*/\nstatic struct st_mysql_client_plugin *\nadd_plugin(MYSQL *mysql, struct st_mysql_client_plugin *plugin, void *dlhandle,\n           int argc, va_list args)\n{\n  const char *errmsg;\n  struct st_client_plugin_int plugin_int, *p;\n  char errbuf[1024];\n  DBUG_ENTER(\"add_plugin\");\n\n  DBUG_ASSERT(initialized);\n\n  plugin_int.plugin= plugin;\n  plugin_int.dlhandle= dlhandle;\n\n  if (plugin->type >= MYSQL_CLIENT_MAX_PLUGINS)\n  {\n    errmsg= \"Unknown client plugin type\";\n    goto err1;\n  }\n\n  if (plugin->interface_version < plugin_version[plugin->type] ||\n      (plugin->interface_version >> 8) >\n       (plugin_version[plugin->type] >> 8))\n  {\n    errmsg= \"Incompatible client plugin interface\";\n    goto err1;\n  }\n\n  /* Call the plugin initialization function, if any */\n  if (plugin->init && plugin->init(errbuf, sizeof(errbuf), argc, args))\n  {\n    errmsg= errbuf;\n    goto err1;\n  }\n\n  p= (struct st_client_plugin_int *)\n    memdup_root(&mem_root, &plugin_int, sizeof(plugin_int));\n\n  if (!p)\n  {\n    errmsg= \"Out of memory\";\n    goto err2;\n  }\n\n  mysql_mutex_assert_owner(&LOCK_load_client_plugin);\n\n  p->next= plugin_list[plugin->type];\n  plugin_list[plugin->type]= p;\n  net_clear_error(&mysql->net);\n\n  DBUG_RETURN(plugin);\n\nerr2:\n  if (plugin->deinit)\n    plugin->deinit();\nerr1:\n  set_mysql_extended_error(mysql, CR_AUTH_PLUGIN_CANNOT_LOAD, unknown_sqlstate,\n                           ER(CR_AUTH_PLUGIN_CANNOT_LOAD), plugin->name,\n                           errmsg);\n  if (dlhandle)\n    (void)dlclose(dlhandle);\n  DBUG_RETURN(NULL);\n}\n\n/**\n  Loads plugins which are specified in the environment variable\n  LIBMYSQL_PLUGINS.\n  \n  Multiple plugins must be separated by semicolon. This function doesn't\n  return or log an error.\n\n  The function is be called by mysql_client_plugin_init\n\n  @todo\n  Support extended syntax, passing parameters to plugins, for example\n  LIBMYSQL_PLUGINS=\"plugin1(param1,param2);plugin2;...\"\n  or\n  LIBMYSQL_PLUGINS=\"plugin1=int:param1,str:param2;plugin2;...\"\n*/\nstatic void load_env_plugins(MYSQL *mysql)\n{\n  char *plugs, *free_env, *s= getenv(\"LIBMYSQL_PLUGINS\");\n  DBUG_ENTER(\"load_env_plugins\");\n\n  /* no plugins to load */\n  if (!s)\n    DBUG_VOID_RETURN;\n\n  free_env= plugs= my_strdup(s, MYF(MY_WME));\n\n  do {\n    if ((s= strchr(plugs, ';')))\n      *s= '\\0';\n    mysql_load_plugin(mysql, plugs, -1, 0);\n    plugs= s + 1;\n  } while (s);\n\n  my_free(free_env);\n  DBUG_VOID_RETURN;\n}\n\n/********** extern functions to be used by libmysql *********************/\n\n/**\n  Initializes the client plugin layer.\n\n  This function must be called before any other client plugin function.\n\n  @retval 0    successful\n  @retval != 0 error occurred\n*/\nint mysql_client_plugin_init()\n{\n  MYSQL mysql;\n  struct st_mysql_client_plugin **builtin;\n  va_list unused;\n  DBUG_ENTER(\"mysql_client_plugin_init\");\n\n  if (initialized)\n    DBUG_RETURN(0);\n\n  bzero(&mysql, sizeof(mysql)); /* dummy mysql for set_mysql_extended_error */\n  bzero(&unused, sizeof unused);\n\n  mysql_mutex_init(0, &LOCK_load_client_plugin, MY_MUTEX_INIT_SLOW);\n  init_alloc_root(&mem_root, \"client_plugin\", 128, 128, MYF(0));\n\n  bzero(&plugin_list, sizeof(plugin_list));\n\n  initialized= 1;\n\n  mysql_mutex_lock(&LOCK_load_client_plugin);\n\n  for (builtin= mysql_client_builtins; *builtin; builtin++)\n    add_plugin(&mysql, *builtin, 0, 0, unused);\n\n  mysql_mutex_unlock(&LOCK_load_client_plugin);\n\n  load_env_plugins(&mysql);\n\n  DBUG_RETURN(0);\n}\n\n/**\n  Deinitializes the client plugin layer.\n\n  Unloades all client plugins and frees any associated resources.\n*/\nvoid mysql_client_plugin_deinit()\n{\n  int i;\n  struct st_client_plugin_int *p;\n  DBUG_ENTER(\"mysql_client_plugin_deinit\");\n\n  if (!initialized)\n    DBUG_VOID_RETURN;\n\n  for (i=0; i < MYSQL_CLIENT_MAX_PLUGINS; i++)\n    for (p= plugin_list[i]; p; p= p->next)\n    {\n      if (p->plugin->deinit)\n        p->plugin->deinit();\n      if (p->dlhandle)\n        (void)dlclose(p->dlhandle);\n    }\n\n  bzero(&plugin_list, sizeof(plugin_list));\n  initialized= 0;\n  free_root(&mem_root, MYF(0));\n  mysql_mutex_destroy(&LOCK_load_client_plugin);\n  DBUG_VOID_RETURN;\n}\n\n/************* public facing functions, for client consumption *********/\n\n/* see <mysql/client_plugin.h> for a full description */\nstruct st_mysql_client_plugin *\nmysql_client_register_plugin(MYSQL *mysql,\n                             struct st_mysql_client_plugin *plugin)\n{\n  DBUG_ENTER(\"mysql_client_register_plugin\");\n\n  if (is_not_initialized(mysql, plugin->name))\n    DBUG_RETURN(NULL);\n\n  mysql_mutex_lock(&LOCK_load_client_plugin);\n\n  /* make sure the plugin wasn't loaded meanwhile */\n  if (find_plugin(plugin->name, plugin->type))\n  {\n    set_mysql_extended_error(mysql, CR_AUTH_PLUGIN_CANNOT_LOAD,\n                             unknown_sqlstate, ER(CR_AUTH_PLUGIN_CANNOT_LOAD),\n                             plugin->name, \"it is already loaded\");\n    plugin= NULL;\n  }\n  else\n  {\n    va_list unused;\n    bzero(&unused, sizeof unused);\n    plugin= add_plugin(mysql, plugin, 0, 0, unused);\n  }\n\n  mysql_mutex_unlock(&LOCK_load_client_plugin);\n  DBUG_RETURN(plugin);\n}\n\n/* see <mysql/client_plugin.h> for a full description */\nstruct st_mysql_client_plugin *\nmysql_load_plugin_v(MYSQL *mysql, const char *name, int type,\n                    int argc, va_list args)\n{\n  const char *errmsg;\n  char dlpath[FN_REFLEN+1];\n  void *sym, *dlhandle;\n  struct st_mysql_client_plugin *plugin;\n  DBUG_ENTER(\"mysql_load_plugin_v\");\n\n  DBUG_PRINT (\"entry\", (\"name=%s type=%d int argc=%d\", name, type, argc));\n  if (is_not_initialized(mysql, name))\n  {\n    DBUG_PRINT (\"leave\", (\"mysql not initialized\"));\n    DBUG_RETURN (NULL);\n  }\n\n  mysql_mutex_lock(&LOCK_load_client_plugin);\n\n  /* make sure the plugin wasn't loaded meanwhile */\n  if (type >= 0 && find_plugin(name, type))\n  {\n    errmsg= \"it is already loaded\";\n    goto err;\n  }\n\n  /* Compile dll path */\n  strxnmov(dlpath, sizeof(dlpath) - 1,\n           mysql->options.extension && mysql->options.extension->plugin_dir ?\n           mysql->options.extension->plugin_dir : PLUGINDIR, \"/\",\n           name, SO_EXT, NullS);\n\n  if (strpbrk(name, \"()[]!@#$%^&/*;.,'?\\\\\"))\n  {\n    errmsg= \"invalid plugin name\";\n    goto err;\n  }\n\n  DBUG_PRINT (\"info\", (\"dlopeninig %s\", dlpath));\n  /* Open new dll handle */\n  if (!(dlhandle= dlopen(dlpath, RTLD_NOW)))\n  {\n    DBUG_PRINT (\"info\", (\"failed to dlopen\"));\n    errmsg= dlerror();\n    goto err;\n  }\n\n  if (!(sym= dlsym(dlhandle, plugin_declarations_sym)))\n  {\n    errmsg= \"not a plugin\";\n    goto errc;\n  }\n\n  plugin= (struct st_mysql_client_plugin*)sym;\n\n  if (type >=0 && type != plugin->type)\n  {\n    errmsg= \"type mismatch\";\n    goto errc;\n  }\n\n  if (strcmp(name, plugin->name))\n  {\n    errmsg= \"name mismatch\";\n    goto errc;\n  }\n\n  if (type < 0 && find_plugin(name, plugin->type))\n  {\n    errmsg= \"it is already loaded\";\n    goto errc;\n  }\n\n  plugin= add_plugin(mysql, plugin, dlhandle, argc, args);\n\n  mysql_mutex_unlock(&LOCK_load_client_plugin);\n\n  DBUG_PRINT (\"leave\", (\"plugin loaded ok\"));\n  DBUG_RETURN (plugin);\n\nerrc:\n  dlclose(dlhandle);\nerr:\n  mysql_mutex_unlock(&LOCK_load_client_plugin);\n  DBUG_PRINT (\"leave\", (\"plugin load error : %s\", errmsg));\n  set_mysql_extended_error(mysql, CR_AUTH_PLUGIN_CANNOT_LOAD, unknown_sqlstate,\n                           ER(CR_AUTH_PLUGIN_CANNOT_LOAD), name, errmsg);\n  DBUG_RETURN (NULL);\n}\n\n/* see <mysql/client_plugin.h> for a full description */\nstruct st_mysql_client_plugin *\nmysql_load_plugin(MYSQL *mysql, const char *name, int type, int argc, ...)\n{\n  struct st_mysql_client_plugin *p;\n  va_list args;\n  DBUG_ENTER(\"mysql_load_plugin\");\n\n  va_start(args, argc);\n  p= mysql_load_plugin_v(mysql, name, type, argc, args);\n  va_end(args);\n  DBUG_RETURN(p);\n}\n\n/* see <mysql/client_plugin.h> for a full description */\nstruct st_mysql_client_plugin *\nmysql_client_find_plugin(MYSQL *mysql, const char *name, int type)\n{\n  struct st_mysql_client_plugin *p;\n  DBUG_ENTER(\"mysql_client_find_plugin\");\n\n  DBUG_PRINT (\"entry\", (\"name=%s, type=%d\", name, type));\n  if (is_not_initialized(mysql, name))\n    DBUG_RETURN (NULL);\n\n  if (type < 0 || type >= MYSQL_CLIENT_MAX_PLUGINS)\n  {\n    set_mysql_extended_error(mysql, CR_AUTH_PLUGIN_CANNOT_LOAD, unknown_sqlstate,\n                             ER(CR_AUTH_PLUGIN_CANNOT_LOAD), name,\n                             \"invalid type\");\n  }\n\n  if ((p= find_plugin(name, type)))\n  {\n    DBUG_PRINT (\"leave\", (\"found %p\", p));\n    DBUG_RETURN (p);\n  }\n\n  /* not found, load it */\n  p= mysql_load_plugin(mysql, name, type, 0);\n  DBUG_PRINT (\"leave\", (\"loaded %p\", p));\n  DBUG_RETURN (p);\n}\n\n\n/* see <mysql/client_plugin.h> for a full description */\nint mysql_plugin_options(struct st_mysql_client_plugin *plugin,\n                                 const char *option,\n                                 const void *value)\n{\n  DBUG_ENTER(\"mysql_plugin_options\");\n  /* does the plugin support options call? */\n  if (!plugin || !plugin->options)\n    DBUG_RETURN(1);\n  DBUG_RETURN(plugin->options(option, value));\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/valgrind.supp": "# Copyright (c) 2005, 2015, Oracle and/or its affiliates.\n# Copyright (c) 2008, 2019, MariaDB\n#\n# This program is free software; you can redistribute it and/or\n# modify it under the terms of the GNU Library General Public\n# License as published by the Free Software Foundation; version 2\n# of the License.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# Library General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1335  USA\n\n#\n# Suppress some common (not fatal) errors in system libraries found by valgrind\n#\n\n{\n   pthead_exit memory loss 1\n   Memcheck:Leak\n   fun:malloc\n   fun:_dl_new_object\n   fun:_dl_map_object_from_fd\n}\n\n{\n   pthread_exit memory loss 2\n   Memcheck:Leak\n   fun:malloc\n   fun:_dl_map_object\n   fun:dl_open_worker\n}\n\n{\n   pthread_exit memory loss 3\n   Memcheck:Leak\n   fun:malloc\n   fun:_dl_map_object_deps\n   fun:dl_open_worker\n}\n\n{\n   pthread_exit memory loss 4\n   Memcheck:Leak\n   fun:calloc\n   fun:_dl_check_map_versions\n   fun:dl_open_worker\n}\n\n{\n   pthread_exit memory loss 5\n   Memcheck:Leak\n   fun:calloc\n   fun:_dl_new_object\n   fun:_dl_map_object_from_fd\n}\n\n{\n   pthread pthread_key_create\n   Memcheck:Leak\n   fun:malloc\n   fun:*\n   fun:*\n   fun:pthread_key_create\n   fun:my_thread_global_init\n}\n\n{\n   pthread strstr uninit\n   Memcheck:Cond\n   fun:strstr\n   obj:/lib/tls/libpthread.so.*\n   obj:/lib/tls/libpthread.so.*\n   fun:call_init\n   fun:_dl_init\n   obj:/lib/ld-*.so\n}\n\n{\n   pthread strstr uninit\n   Memcheck:Cond\n   fun:strstr\n   obj:/lib/tls/libpthread.so.*\n   obj:/lib/tls/libpthread.so.*\n   fun:call_init\n   fun:_dl_init\n   obj:/lib/ld-*.so\n}\n\n{  \n   somewhere in ld.so, when loading mysqld\n   Memcheck:Cond\n   ...\n   fun:dl_main\n   fun:_dl_sysdep_start\n   fun:_dl_start\n}\n\n#\n# Warnings in libz becasue it works with aligned memory(?)\n#\n\n{\n   libz tr_flush_block\n   Memcheck:Cond\n   fun:_tr_flush_block\n   fun:deflate_slow\n   fun:deflate\n   fun:do_flush\n   fun:gzclose\n}\n\n{\n   libz tr_flush_block2\n   Memcheck:Cond\n   fun:_tr_flush_block\n   fun:deflate_slow\n   fun:deflate\n   fun:compress2\n}\n\n{\n   libz longest_match\n   Memcheck:Cond\n   fun:longest_match\n   fun:deflate_slow\n   fun:deflate\n   fun:do_flush\n}\n\n{\n   libz longest_match called from btr_store_big_rec_extern_fields\n   Memcheck:Cond\n   fun:longest_match\n   fun:deflate_slow\n   fun:deflate\n   fun:btr_store_big_rec_extern_fields\n}\n\n{\n   libz longest_match called from page_zip_compress\n   Memcheck:Cond\n   fun:longest_match\n   fun:deflate_slow\n   fun:deflate\n   fun:page_zip_compress\n}\n\n{\n   libz longest_match2\n   Memcheck:Cond\n   fun:longest_match\n   fun:deflate_slow\n   fun:deflate\n   fun:compress2\n}\n\n{\n   libz longest_match 3\n   Memcheck:Cond\n   fun:longest_match\n   fun:deflate_slow\n   fun:deflate\n   fun:gzclose\n}\n\n{\n   libz longest_match 4 \n   Memcheck:Cond\n   fun:longest_match\n   fun:deflate_slow\n   fun:deflate\n   fun:gzflush\n}\n\n{\n   libz longest_match3\n   Memcheck:Cond\n   fun:longest_match\n   fun:deflate_slow\n   fun:deflate\n   fun:azflush\n}\n\n{\n   libz longest_match3\n   Memcheck:Cond\n   fun:longest_match\n   fun:deflate_slow\n   fun:deflate\n   fun:azclose\n}\n\n{\n   libz deflate\n   Memcheck:Cond\n   obj:*/libz.so.*\n   obj:*/libz.so.*\n   fun:deflate\n   fun:compress2\n}\n\n{\n   libz deflate2\n   Memcheck:Cond\n   obj:*/libz.so.*\n   obj:*/libz.so.*\n   fun:deflate\n   obj:*/libz.so.*\n   fun:gzflush\n}\n\n{\n   libz deflate3\n   Memcheck:Cond\n   obj:*/libz.so.*\n   obj:*/libz.so.*\n   fun:deflate\n   fun:do_flush\n}\n\n{\n   libz inflatereset2\n   Memcheck:Cond\n   fun:inflateReset2\n   fun:inflateInit2_\n   fun:uncompress\n}\n\n\n#\n# Warning from my_thread_init becasue mysqld dies before kill thread exists\n#\n\n{\n   my_thread_init kill thread memory loss second\n   Memcheck:Leak\n   fun:calloc\n   fun:my_thread_init\n   fun:kill_server_thread\n}\n\n\n# Red Hat AS 4 32 bit\n{\n   dl_relocate_object\n   Memcheck:Cond\n   fun:_dl_relocate_object\n}\n\n#\n# Leaks reported in _dl_* internal functions on Linux amd64 / glibc2.3.2.\n#\n\n{\n   _dl_start invalid write8\n   Memcheck:Addr8\n   fun:_dl_start\n}\n\n{\n   _dl_start invalid write4\n   Memcheck:Addr4\n   fun:_dl_start\n}\n\n{\n   _dl_start/_dl_setup_hash invalid read8\n   Memcheck:Addr8\n   fun:_dl_setup_hash\n   fun:_dl_start\n}\n\n{\n   _dl_sysdep_start invalid write8\n   Memcheck:Addr8\n   fun:_dl_sysdep_start\n}\n\n{\n   _dl_init invalid write8\n   Memcheck:Addr8\n   fun:_dl_init\n}\n\n{\n   _dl_init invalid write4\n   Memcheck:Addr4\n   fun:_dl_init\n}\n\n{\n   _dl_init/_dl_init invalid read8\n   Memcheck:Addr8\n   fun:_dl_debug_initialize\n   fun:_dl_init\n}\n\n{\n   _dl_init/_dl_debug_state invalid read8\n   Memcheck:Addr8\n   fun:_dl_debug_state\n   fun:_dl_init\n}\n\n{\n   init invalid write8\n   Memcheck:Addr8\n   fun:init\n}\n\n{\n   fixup invalid write8\n   Memcheck:Addr8\n   fun:fixup\n}\n\n{\n   fixup/_dl_lookup_versioned_symbol invalid read8\n   Memcheck:Addr8\n   fun:_dl_lookup_versioned_symbol\n   fun:fixup\n}\n\n{\n   _dl_runtime_resolve invalid read8\n   Memcheck:Addr8\n   fun:_dl_runtime_resolve\n}\n\n{\n   __libc_start_main invalid write8\n   Memcheck:Addr8\n   fun:__libc_start_main\n}\n\n{\n   __libc_start_main/__sigjmp_save invalid write4\n   Memcheck:Addr4\n   fun:__sigjmp_save\n   fun:__libc_start_main\n}\n\n#\n# dl_init reports leaked memory in memalign on OpenSuse 12.3\n\n{\n   memory \"loss\" from _dl_init\n   Memcheck:Leak\n   fun:memalign\n   ...\n   fun:call_init*\n   fun:_dl_init\n}\n\n# This one is on OpenSuse 10.3 with gcc 5.4\n{\n   memory \"loss\" from _dl_init 2\n   Memcheck:Leak\n   fun:malloc\n   ...\n   fun:call_init*\n   fun:_dl_init\n}\n\n#\n#  dlclose can allocate memory for error message, the memory will be\n#  freed by dlerror or other dl* function.\n#\n{\n   memory \"loss\" from dlclose error messages\n   Memcheck:Leak\n   fun:*alloc\n   ...\n   fun:dlclose\n}\n\n\n#\n#  dlsym can allocate memory for error message, the memory will be\n#  freed by dlerror or other dl* function.\n#\n{\n   memory \"loss\" from dlclose error messages\n   Memcheck:Leak\n   fun:*alloc\n   ...\n   fun:dlsym\n}\n\n\n{\n   dlopen / ptread_cancel_init memory loss on Suse Linux 10.3 32/64 bit ver 1\n   Memcheck:Leak\n   fun:*alloc\n   obj:/lib*/ld-*.so\n   obj:/lib*/ld-*.so\n   obj:/lib*/ld-*.so\n   obj:/lib*/ld-*.so\n   obj:/lib*/ld-*.so\n   obj:/lib*/ld-*.so\n   obj:/lib*/libc-*.so\n   obj:/lib*/ld-*.so\n   obj:/lib*/libc-*.so\n   fun:__libc_dlopen_mode\n   fun:pthread_cancel_init\n   fun:_Unwind_ForcedUnwind\n}\n\n{\n   dlopen / ptread_cancel_init memory loss on Suse Linux 10.3 32/64 bit ver 2\n   Memcheck:Leak\n   fun:*alloc\n   obj:/lib*/ld-*.so\n   obj:/lib*/ld-*.so\n   obj:/lib*/ld-*.so\n   obj:/lib*/ld-*.so\n   obj:/lib*/ld-*.so\n   obj:/lib*/libc-*.so\n   obj:/lib*/ld-*.so\n   obj:/lib*/libc-*.so\n   fun:__libc_dlopen_mode\n   fun:pthread_cancel_init\n   fun:_Unwind_ForcedUnwind\n}\n\n{\n   dlopen / ptread_cancel_init memory loss on Suse Linux 10.3 32/64 bit\n   Memcheck:Leak\n   fun:*alloc\n   obj:/lib*/ld-*.so\n   obj:/lib*/ld-*.so\n   obj:/lib*/ld-*.so\n   obj:/lib*/ld-*.so\n   obj:/lib*/libc-*.so\n   obj:/lib*/ld-*.so\n   obj:/lib*/libc-*.so\n   fun:__libc_dlopen_mode\n   fun:pthread_cancel_init\n   fun:_Unwind_ForcedUnwind\n}\n\n\n#\n# Reading wrong addresses on SuSe Linux 10.3 32 bit\n#\n\n{\n   Reading wrong data in libc_dlopen\n   Memcheck:Addr4\n   obj:/lib*/ld-*.so\n   obj:/lib*/ld-*.so\n   obj:/lib*/ld-*.so\n   obj:/lib*/ld-*.so\n   obj:/lib*/ld-*.so\n   obj:/lib*/ld-*.so\n   obj:/lib*/libc-*.so\n   obj:/lib*/ld-*.so\n   obj:/lib*/libc-*.so\n   fun:__libc_dlopen_mode\n   fun:pthread_cancel_init\n}\n\n#\n# These seem to be libc threading stuff, not related to MySQL code (allocations\n# during pthread_exit()). Googling shows other projects also using these\n# suppressions.\n#\n# Note that these all stem from pthread_exit() deeper in the call stack, but\n# Valgrind only allows the top four calls in the suppressions.\n#\n\n{\n   libc pthread_exit 1\n   Memcheck:Leak\n   fun:malloc\n   fun:_dl_new_object\n   fun:_dl_map_object_from_fd\n   fun:_dl_map_object\n}\n\n{\n   libc pthread_exit 2\n   Memcheck:Leak\n   fun:malloc\n   fun:_dl_map_object\n   fun:dl_open_worker\n   fun:_dl_catch_error\n}\n\n{\n   libc pthread_exit 3\n   Memcheck:Leak\n   fun:malloc\n   fun:_dl_map_object_deps\n   fun:dl_open_worker\n   fun:_dl_catch_error\n}\n\n{\n   libc pthread_exit 4\n   Memcheck:Leak\n   fun:calloc\n   fun:_dl_check_map_versions\n   fun:dl_open_worker\n   fun:_dl_catch_error\n}\n\n{\n   libc pthread_exit 5\n   Memcheck:Leak\n   fun:calloc\n   fun:_dl_new_object\n   fun:_dl_map_object_from_fd\n   fun:_dl_map_object\n}\n\n{\n   libc pthread_exit 6\n   Memcheck:Leak\n   fun:malloc\n   fun:_dl_map_object\n   fun:openaux\n   fun:_dl_catch_error \n}\n\n{\n   libc pthread_exit 7\n   Memcheck:Leak\n   fun:malloc\n   fun:dl_open_worker\n   fun:_dl_catch_error\n   fun:_dl_open\n}\n\n{\n   libc pthread_exit 8\n   Memcheck:Leak\n   fun:malloc\n   fun:local_strdup\n   fun:_dl_map_object\n   fun:dl_open_worker\n}\n\n{\n   libc pthread_exit 9\n   Memcheck:Leak\n   fun:malloc\n   fun:local_strdup\n   fun:_dl_map_object\n   fun:openaux\n   fun:_dl_catch_error \n}\n\n{\n   libc do_lookup_x\n   Memcheck:Leak\n   fun:calloc\n   fun:do_lookup_x\n   fun:_dl_lookup_symbol_x\n   ...\n   fun:_dl_catch_error \n}\n\n#\n# This is seen internally in the system libraries on 64-bit RHAS3.\n#\n\n{\n   __lll_mutex_unlock_wake uninitialized\n   Memcheck:Param\n   futex(utime)\n   fun:__lll_mutex_unlock_wake\n}\n\n#\n# Warning when printing stack trace (to suppress some not needed warnings)\n#\n\n{\n   vprintf on stacktrace\n   Memcheck:Cond\n   fun:vfprintf\n   fun:uffered_vfprintf\n   fun:vfprintf\n   fun:fprintf\n   fun:print_stacktrace\n}\n\n#\n# Safe warnings, that may happen because of thread scheduling\n#\n\n{\n   dbug initialization by kill_server\n   Memcheck:Leak\n   fun:malloc\n   fun:DbugMalloc\n   fun:code_state\n   fun:_db_enter_\n   fun:kill_server\n}\n\n{\n   Aria checkpoint background thread not dying fast enough\n   Memcheck:Leak\n   fun:calloc\n   fun:my_thread_init\n   fun:ma_checkpoint_background\n}\n\n#\n# Warning caused by small memory leak in threaded dlopen\n#\n\n{\n   dlopen threaded memory leak\n   Memcheck:Leak\n   fun:calloc\n   obj:*/libdl-*.so\n   fun:dlopen*\n}\n\n#\n# Warning caused by small memory leak in _dl_init\n#\n\n{\n   dl_init memory leak\n   Memcheck:Leak\n   fun:malloc\n   obj:*/libstdc++.so*\n   fun:call_init.part*\n   fun:_dl_init\n}\n\n#\n# In glibc (checked version 2.7), inet_ntoa allocates an 18-byte\n# per-thread static buffer for the return value. That memory is freed\n# at thread exit, however if called from the main thread, Valgrind\n# does not see the free (test main.no-threads).\n#\n# Since inet_ntoa() does not allocate memory dynamically per-call, this\n# suppression is safe.\n#\n\n{\n   inet_ntoa thread local storage\n   Memcheck:Leak\n   fun:malloc\n   fun:inet_ntoa\n}\n\n\n#\n# Some problem inside glibc on Ubuntu 9.04, x86 (but not amd64):\n# \n# ==5985== 19 bytes in 1 blocks are still reachable in loss record 1 of 6\n# ==5985==    at 0x7AF3FDE: malloc (vg_replace_malloc.c:207) \n#               ... 11,12, or 13 functions w/o symbols ...\n# ==5985==    by 0x8717185: nptl_pthread_exit_hack_handler (my_thr_init.c:55)\n#\n# Since valgrind 3.3.0 doesn't support '...' multi-function pattern, using\n# multiple suppressions:\n#\n{\n   Mem loss inside nptl_pthread_exit_hack_handler\n   Memcheck:Leak\n   fun:*\n   fun:*\n   fun:*\n   fun:*\n   fun:*\n   fun:*\n   fun:*\n   fun:*\n   fun:*\n   fun:*\n   fun:*\n   fun:*\n   fun:nptl_pthread_exit_hack_handler \n}\n\n{\n   Mem loss inside nptl_pthread_exit_hack_handler\n   Memcheck:Leak\n   fun:*\n   fun:*\n   fun:*\n   fun:*\n   fun:*\n   fun:*\n   fun:*\n   fun:*\n   fun:*\n   fun:*\n   fun:*\n   fun:*\n   fun:*\n   fun:nptl_pthread_exit_hack_handler \n}\n\n{\n   Mem loss inside nptl_pthread_exit_hack_handler\n   Memcheck:Leak\n   fun:*\n   fun:*\n   fun:*\n   fun:*\n   fun:*\n   fun:*\n   fun:*\n   fun:*\n   fun:*\n   fun:*\n   fun:*\n   fun:*\n   fun:*\n   fun:*\n   fun:nptl_pthread_exit_hack_handler \n}\n\n#\n# BUG#45630\n# Suppress valgrind failures within nptl_pthread_exit_hack_handler on Ubuntu 9.04, x86 (but not amd64)\n#\n\n{\n   Mem loss within nptl_pthread_exit_hack_handler 1\n   Memcheck:Leak\n   fun:malloc\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/libc-*.so\n   obj:*/ld-*.so\n   fun:__libc_dlopen_mode\n   fun:pthread_cancel_init\n   fun:_Unwind_ForcedUnwind\n   fun:__pthread_unwind\n   fun:pthread_exit\n   fun:nptl_pthread_exit_hack_handler\n   fun:start_thread\n   fun:clone\n}\n\n{\n   Mem loss within nptl_pthread_exit_hack_handler 2\n   Memcheck:Leak\n   fun:malloc\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/libc-*.so\n   obj:*/ld-*.so\n   fun:__libc_dlopen_mode\n   fun:pthread_cancel_init\n   fun:_Unwind_ForcedUnwind\n   fun:__pthread_unwind\n   fun:pthread_exit\n   fun:nptl_pthread_exit_hack_handler\n   fun:start_thread\n   fun:clone\n}\n\n{\n   Mem loss within nptl_pthread_exit_hack_handler 3\n   Memcheck:Leak\n   fun:calloc\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/libc-*.so\n   obj:*/ld-*.so\n   fun:__libc_dlopen_mode\n   fun:pthread_cancel_init\n   fun:_Unwind_ForcedUnwind\n   fun:__pthread_unwind\n   fun:pthread_exit\n   fun:nptl_pthread_exit_hack_handler\n   fun:start_thread\n   fun:clone\n}\n\n{\n   Mem loss within nptl_pthread_exit_hack_handler 4\n   Memcheck:Leak\n   fun:malloc\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/libc-*.so\n   obj:*/ld-*.so\n   fun:__libc_dlopen_mode\n   fun:pthread_cancel_init\n   fun:_Unwind_ForcedUnwind\n   fun:__pthread_unwind\n   fun:pthread_exit\n   fun:nptl_pthread_exit_hack_handler\n   fun:start_thread\n}\n\n{\n   Mem loss within nptl_pthread_exit_hack_handler 5\n   Memcheck:Leak\n   fun:calloc\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/libc-*.so\n   obj:*/ld-*.so\n   fun:__libc_dlopen_mode\n   fun:pthread_cancel_init\n   fun:_Unwind_ForcedUnwind\n   fun:__pthread_unwind\n   fun:pthread_exit\n   fun:nptl_pthread_exit_hack_handler\n   fun:start_thread\n}\n\n#\n# Problem with glibc and gethostbyaddr_r\n#\n\n{\n   libc_res_nsend: Conditional jump or move depends on uninitialised value\n   Memcheck:Cond\n   fun: __libc_res_nsend\n   fun: __libc_res_nquery\n   obj: /lib64/libnss_dns-*so)\n   obj: /lib64/libnss_dns-*so)\n   fun: gethostbyaddr_r\n}\n\n# suppressions for glibc 2.6.1 64 bit\n\n{\n   Mem loss within nptl_pthread_exit_hack_handler 6\n   Memcheck:Leak\n   fun:malloc\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/libc-*.so\n   obj:*/ld-*.so\n   obj:*/libc-*.so\n   fun:__libc_dlopen_mode\n   fun:pthread_cancel_init\n   fun:_Unwind_ForcedUnwind\n   fun:__pthread_unwind\n   fun:pthread_exit\n   fun:nptl_pthread_exit_hack_handler\n}\n\n{\n   Mem loss within nptl_pthread_exit_hack_handler 7\n   Memcheck:Leak\n   fun:malloc\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/libc-*.so\n   obj:*/ld-*.so\n   obj:*/libc-*.so\n   fun:__libc_dlopen_mode\n   fun:pthread_cancel_init\n   fun:_Unwind_ForcedUnwind\n   fun:__pthread_unwind\n   fun:pthread_exit\n   fun:nptl_pthread_exit_hack_handler\n   fun:start_thread\n   fun:clone\n}\n\n{\n   Mem loss within nptl_pthread_exit_hack_handler 8\n   Memcheck:Leak\n   fun:calloc\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/libc-*.so\n   obj:*/ld-*.so\n   obj:*/libc-*.so\n   fun:__libc_dlopen_mode\n   fun:pthread_cancel_init\n   fun:_Unwind_ForcedUnwind\n   fun:__pthread_unwind\n   fun:pthread_exit\n   fun:nptl_pthread_exit_hack_handler\n   fun:start_thread\n   fun:clone\n}\n\n{\n   Mem loss within nptl_pthread_exit_hack_handler 8\n   Memcheck:Leak\n   fun:calloc\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/libc-*.so\n   obj:*/ld-*.so\n   obj:*/libc-*.so\n   fun:__libc_dlopen_mode\n   fun:pthread_cancel_init\n   fun:_Unwind_ForcedUnwind\n   fun:__pthread_unwind\n   fun:pthread_exit\n   fun:nptl_pthread_exit_hack_handler\n}\n\n{\n   Invalid read within nptl_pthread_exit_hack_handler\n   Memcheck:Addr8\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/ld-*.so\n   obj:*/libc-*.so\n   obj:*/ld-*.so\n   obj:*/libc-*.so\n   fun:__libc_dlopen_mode\n   fun:pthread_cancel_init\n   fun:_Unwind_ForcedUnwind\n   fun:__pthread_unwind\n   fun:pthread_exit\n   fun:nptl_pthread_exit_hack_handler\n}\n\n{\n   memory \"leak\" in backtrace() of glibc 2.9 (not present in 2.13)\n   Memcheck:Leak\n   fun:malloc\n   ...\n   fun:pthread_once\n   fun:backtrace\n}\n\n{\n   memory leak in mysqld_exit\n   Memcheck:Leak\n   fun:malloc\n   fun:_dl_close_worker\n   fun:_dl_close\n}\n\n#\n# Bug in Glibc 2.9: http://sourceware.org/bugzilla/show_bug.cgi?id=10391\n# Fixed in latest Glibc, but suppressed here for running tests on hosts\n# with older Glibc version.\n#\n{\n   Glibc bug in __libc_res_nsend\n   Memcheck:Cond\n   fun:__libc_res_nsend\n   fun:__libc_res_nquery\n}\n\n{\n   buf_buddy_relocate peeking (space,page) in potentially free blocks\n   Memcheck:Addr1\n   fun:buf_buddy_relocate\n}\n\n{\n   Bug 59874 Valgrind warning in InnoDB compression code\n   Memcheck:Cond\n   fun:*\n   fun:*\n   fun:deflate\n   fun:btr_store_big_rec_extern_fields_func\n   fun:row_ins_index_entry_low\n   fun:row_ins_index_entry\n   fun:row_ins_index_entry_step\n   fun:row_ins\n   fun:row_ins_step\n   fun:row_insert_for_mysql\n}\n\n{\n   In page0zip.c we have already checked that the memory is initialized before calling deflate()\n   Memcheck:Cond\n   fun:*\n   fun:*\n   fun:deflate\n   fun:page_zip_compress\n}\n\n{\n   In page0zip.c we have already checked that the memory is initialized before calling deflate()\n   Memcheck:Cond\n   fun:*\n   fun:*\n   fun:deflate\n   fun:page_zip_compress_deflate\n}\n\n{\n   Bug 59875 Valgrind warning in buf0buddy.c\n   Memcheck:Addr1\n   fun:mach_read_from_4\n   fun:buf_buddy_relocate\n   fun:buf_buddy_free_low\n   fun:buf_buddy_free\n}\n\n# Note the wildcard in the (mangled) function signatures of\n# write_keys() and find_all_keys().\n# They both return ha_rows, which is platform dependent.\n#\n# The '...' wildcards are for 'fun:inline_mysql_file_write' and\n# 'fun:find_all_keys' which *may* be inlined.\n{\n   Bug#12856915 VALGRIND FAILURE IN FILESORT/CREATE_SORT_INDEX / one\n   Memcheck:Param\n   write(buf)\n   obj:*/libpthread*.so\n   fun:my_write\n   ...\n   fun:my_b_flush_io_cache\n   fun:_my_b_write\n   fun:_Z*10write_keysP13st_sort_paramPPhjP11st_io_cacheS4_\n   ...\n   fun:_Z8filesortP3THDP5TABLEP13st_sort_fieldjP10SQL_SELECTybPy\n}\n\n{\n   Bug#12856915 VALGRIND FAILURE IN FILESORT/CREATE_SORT_INDEX / two\n   Memcheck:Param\n   write(buf)\n   obj:*/libpthread*.so\n   fun:my_write\n   ...\n   fun:my_b_flush_io_cache\n   fun:_Z15merge_many_buffP13st_sort_paramPhP10st_buffpekPjP11st_io_cache\n   fun:_Z8filesortP3THDP5TABLEP13st_sort_fieldjP10SQL_SELECTybPy\n}\n\n{\n   Bug#12856915 VALGRIND FAILURE IN FILESORT/CREATE_SORT_INDEX / three\n   Memcheck:Param\n   write(buf)\n   obj:*/libpthread*.so\n   fun:my_write\n   ...\n   fun:my_b_flush_io_cache\n   fun:_Z8filesortP3THDP5TABLEP13st_sort_fieldjP10SQL_SELECTybPy\n}\n\n{\n   OpenSSL still reachable.\n   Memcheck:Leak\n   fun:*alloc\n   fun:CRYPTO_malloc\n   fun:sk_new\n   obj:*libssl*\n   fun:SSL_COMP_get_compression_methods\n   fun:SSL_library_init\n}\n\n{\n   OpenSSL still reachable.\n   Memcheck:Leak\n   fun:*alloc\n   fun:CRYPTO_malloc\n   fun:sk_new\n   fun:SSL_COMP_get_compression_methods\n   fun:SSL_library_init\n}\n\n{\n   OpenSSL still reachable.\n   Memcheck:Leak\n   fun:*alloc\n   fun:CRYPTO_malloc\n   obj:*libssl*\n   fun:SSL_COMP_get_compression_methods\n   fun:SSL_library_init\n}\n\n{\n   OpenSSL still reachable.\n   Memcheck:Leak\n   fun:*alloc\n   fun:CRYPTO_malloc\n   fun:sk_new\n   fun:SSL_COMP_get_compression_methods\n   fun:SSL_library_init\n}\n\n{\n   libcrypto 2.2.1 leak\n   Memcheck:Leak\n   fun:malloc\n   ...\n   fun:ERR_get_state\n}\n\n{\n  Problem with udf and libresolve\n  Memcheck:Cond\n   obj:*/libresolv*.so\n   fun:__libc_res_nquery\n   fun:_nss_dns_gethostbyaddr2_r\n   fun:_nss_dns_gethostbyaddr_r\n   fun:gethostbyaddr_r\n}\n\n#\n# Detached threads may not complete deiniitialization by the time shutdown\n# thread calls exit. This is unfortunate property of detached threads, which\n# we currently can only ignore. Unfortunately there is no way to distinguish\n# between false positives generated by detached threads and real memory leaks\n# generated by not joined joinable threads. So we hide both cases.\n#\n# To avoid enumeration of the whole variety of possible traces we ignore all\n# \"possibly lost\" blocks allocated by pthread_create (and it's callees).\n#\n{\n   Detached threads memory loss\n   Memcheck:Leak\n   match-leak-kinds:possible\n   ...\n   fun:pthread_create*\n}\n\n{\n   Memory Leak in loader and valgrind malloc\n   Memcheck:Leak\n   match-leak-kinds:reachable\n   obj:*/vgpreload_memcheck*.so\n   ...\n   obj:*/ld-*.so\n   ...\n}\n\n{\n  ConnectSE: unixODBC SQLAllocEnv leaves some \"still reachable\" pointers\n  Memcheck:Leak\n   fun:malloc\n   fun:strdup\n   ...\n   obj:*/libodbc.so*\n   fun:_ZN7ODBConn10GetDriversEP7_qryres\n}\n\n{\n  ConnectSE: unixODBC SQLAllocEnv leaves some \"still reachable\" pointers\n  Memcheck:Leak\n   fun:calloc\n   ...\n   obj:*/libodbc.so*\n   fun:_ZN7ODBConn10GetDriversEP7_qryres\n}\n\n{\n  ConnectSE: unixODBC SQLAllocEnv leavs some \"still reachable\" pointers\n  Memcheck:Leak\n  fun:malloc\n  fun:strdup\n  ...\n  obj:*/libodbc.so*\n  fun:_ZN7ODBConn14GetDataSourcesEP7_qryres\n}\n\n\n{\n  ConnectSE: unixODBC SQLAllocEnv leavs some \"still reachable\" pointers\n  Memcheck:Leak\n  fun:calloc\n  ...\n  obj:*/libodbc.so*\n  fun:_ZN7ODBConn14GetDataSourcesEP7_qryres\n}\n\n\n{\n  ConnectSE: unixODBC SQLDriverConnect leaves some \"still reachable\" pointers\n  Memcheck:Leak\n   fun:malloc\n   fun:strdup\n   ...\n   obj:*/libodbc.so*\n   fun:SQLDriverConnect\n   fun:_ZN7ODBConn7ConnectEj\n   fun:_ZN7ODBConn4OpenEPcj\n   fun:_Z11ODBCColumnsP7_globalPcS1_S1_b\n   fun:_ZL26connect_assisted_discoveryP10handlertonP3THDP11TABLE_SHAREP14HA_CREATE_INFO\n}\n\n{\n  ConnectSE: unixODBC SQLDriverConnect leaves some \"still reachable\" pointers\n  Memcheck:Leak\n   fun:calloc\n   ...\n   obj:*/libodbc.so*\n   fun:SQLDriverConnect\n   fun:_ZN7ODBConn7ConnectEj\n   fun:_ZN7ODBConn4OpenEPcj\n   fun:_Z11ODBCColumnsP7_globalPcS1_S1_b\n   fun:_ZL26connect_assisted_discoveryP10handlertonP3THDP11TABLE_SHAREP14HA_CREATE_INFO\n}\n\n{\n  ConnectSE: unixODBC SQLDriverConnect leaves some \"still reachable\" pointers\n  Memcheck:Leak\n   fun:malloc\n   ...\n   obj:*/libodbc.so*\n   fun:SQLDriverConnect\n   fun:_ZN7ODBConn7ConnectEj\n   fun:_ZN7ODBConn4OpenEPcj\n   fun:_Z11ODBCColumnsP7_globalPcS1_S1_b\n   fun:_ZL26connect_assisted_discoveryP10handlertonP3THDP11TABLE_SHAREP14HA_CREATE_INFO\n}\n\n{\n  ConnectSE: unixODBC dlopen leaves some \"still reachable\"\n  Memcheck:Leak\n  fun:malloc\n  fun:expand_dynamic_string_token\n  ...\n  obj:*/libltdl.so*\n  ...\n  obj:*/libodbc.so*\n}\n\n{\n  TokuDB uses gcc __thread variables\n  Memcheck:Leak\n  fun:memalign\n  fun:*\n  fun:__tls_get_addr\n}\n\n{\n  Galera uses gcc __thread variables\n  Memcheck:Leak\n  fun:memalign\n  fun:__tls_get_addr\n}\n\n{\n  Mroonga: dlopen leaves some \"still reachable\"\n  Memcheck:Leak\n  fun:malloc\n  ...\n  fun:dl_open_worker\n  fun:_dl_catch_error\n  fun:_dl_open\n  fun:dlopen_doit\n  fun:_dl_catch_error\n  fun:_dlerror_run\n  fun:dlopen@@GLIBC_2.2.5\n}\n\n# \n# MDEV-11061: OpenSSL 0.9.8 problems\n#\n\n{\n   MDEV-11061: OpenSSL 0.9.8\n   Memcheck:Cond\n   obj:*/libz.so*\n   ...\n   obj:*/libcrypto.so.0.9.8\n   ...\n   obj:*/libssl.so.0.9.8\n   ...\n}\n\n{\n   MDEV-11061: OpenSSL 0.9.8\n   Memcheck:Value8\n   obj:*/libz.so*\n   ...\n   obj:*/libcrypto.so.0.9.8\n   ...\n   obj:*/libssl.so.0.9.8\n   ...\n}\n\n{\n   MDEV-11061: OpenSSL 0.9.8\n   Memcheck:Cond\n   obj:*/libcrypto.so.0.9.8\n   ...\n   obj:*/libssl.so.0.9.8\n   ...\n}\n\n{\n   MDEV-11061: OpenSSL 0.9.8\n   Memcheck:Value8\n   obj:*/libcrypto.so.0.9.8\n   ...\n   obj:*/libssl.so.0.9.8\n   ...\n}\n\n{\n   MDEV-11061: OpenSSL 0.9.8\n   Memcheck:Cond\n   obj:*/libssl.so.0.9.8\n   obj:*/libssl.so.0.9.8\n   ...\n}\n\n{\n   MDEV-11061: OpenSSL 0.9.8\n   Memcheck:Value8\n   obj:*/libssl.so.0.9.8\n   obj:*/libssl.so.0.9.8\n   ...\n}\n\n{\n   MDEV-11061: OpenSSL 0.9.8\n   Memcheck:Cond\n   fun:memcpy\n   obj:*/libcrypto.so.0.9.8\n   obj:*/libssl.so.0.9.8\n   ...\n}\n\n{\n   MDEV-11061: OpenSSL 0.9.8\n   Memcheck:Value8\n   fun:memcpy\n   obj:*/libcrypto.so.0.9.8\n   obj:*/libssl.so.0.9.8\n   ...\n}\n\n{\n   MDEV-11061: OpenSSL 0.9.8\n   Memcheck:Cond\n   fun:is_overlap\n   fun:memcpy\n   obj:*/libcrypto.so.0.9.8\n   obj:*/libssl.so.0.9.8\n   ...\n}\n\n{\n   MDEV-11061: OpenSSL 0.9.8\n   Memcheck:Cond\n   fun:memset\n   obj:*/libcrypto.so.0.9.8\n   ...\n   obj:*/libssl.so.0.9.8\n   ...\n}\n\n{\n   MDEV-11061: OpenSSL 0.9.8\n   Memcheck:Value8\n   fun:memset\n   obj:*/libcrypto.so.0.9.8\n   ...\n   obj:*/libssl.so.0.9.8\n   ...\n}\n\n{\n   MDEV-11061: OpenSSL 0.9.8\n   Memcheck:Param\n   write(buf)\n   obj:*/libpthread-2.9.so*\n   obj:*/libcrypto.so.0.9.8\n   ...\n   obj:*/libssl.so.0.9.8\n   ...\n}\n\n{\n  vasprintf in OpenSuse 12.3\n  Memcheck:Leak\n  fun:malloc\n  fun:vasprintf\n  fun:asprintf\n  fun:dlerror\n}\n\n{\n   GitHub codership/galera#330\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   fun:CRYPTO_malloc\n   fun:sk_new\n   obj:/usr/lib64/libssl.so.1.0.1e\n   fun:SSL_COMP_get_compression_methods\n   fun:SSL_library_init\n   fun:_ZN4asio3ssl6detail12openssl_initILb1EE7do_initC1Ev\n   fun:_ZN4asio3ssl6detail12openssl_initILb1EE7do_init8instanceEv\n   fun:_ZN4asio3ssl6detail12openssl_initILb1EEC1Ev\n   fun:_Z41__static_initialization_and_destruction_0ii.constprop.120\n   fun:call_init.part.0\n   fun:_dl_init\n   fun:dl_open_worker\n   fun:_dl_catch_error\n   fun:_dl_open\n   fun:dlopen_doit\n}\n{\n   GitHub codership/galera#330\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   fun:CRYPTO_malloc\n   fun:sk_new\n   obj:/usr/lib64/libssl.so.1.0.1e\n   fun:SSL_COMP_get_compression_methods\n   fun:SSL_library_init\n   fun:_ZN4asio3ssl6detail12openssl_initILb1EE7do_initC1Ev\n   fun:_ZN4asio3ssl6detail12openssl_initILb1EE7do_init8instanceEv\n   fun:_ZN4asio3ssl6detail12openssl_initILb1EEC1Ev\n   fun:_Z41__static_initialization_and_destruction_0ii.constprop.120\n   fun:call_init.part.0\n   fun:_dl_init\n   fun:dl_open_worker\n   fun:_dl_catch_error\n   fun:_dl_open\n   fun:dlopen_doit\n}\n\n{\n   GitHub codership/mysql-wsrep#175\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:calloc\n   fun:do_lookup_x\n   fun:_dl_lookup_symbol_x\n   fun:_dl_relocate_object\n   fun:dl_open_worker\n   fun:_dl_catch_error\n   fun:_dl_open\n   fun:dlopen_doit\n   fun:_dl_catch_error\n   fun:_dlerror_run\n   fun:dlopen@@GLIBC_2.2.5\n   fun:wsrep_load\n   fun:_Z10wsrep_initv\n   fun:_Z18wsrep_init_startupb\n   fun:_ZL22init_server_componentsv\n   fun:_Z11mysqld_mainiPPc\n}\n\n{\n   galera/mysql-wsrep#147\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:malloc\n   fun:_ZNK6galera13ReplicatorSMM9stats_getEv\n   fun:_ZL28export_wsrep_status_to_mysqlP3THD\n   fun:_Z17wsrep_show_statusP3THDP17st_mysql_show_varPc\n   fun:_ZL17show_status_arrayP3THDPKcP17st_mysql_show_var13enum_var_typeP17system_status_varS2_P5TABLEbP4Item\n   fun:_Z11fill_statusP3THDP10TABLE_LISTP4Item\n   fun:_ZL13do_fill_tableP3THDP10TABLE_LISTP13st_join_table\n   fun:_Z24get_schema_tables_resultP4JOIN23enum_schema_table_state\n   fun:_ZN4JOIN14prepare_resultEPP4ListI4ItemE\n   fun:_ZN4JOIN4execEv\n   fun:_ZL20mysql_execute_selectP3THDP13st_select_lexb\n   fun:_Z12mysql_selectP3THDP10TABLE_LISTjR4ListI4ItemEPS4_P10SQL_I_ListI8st_orderESB_S7_yP13select_resultP18st_select_lex_unitP13st_select_lex\n   fun:_Z13handle_selectP3THDP13select_resultm\n   fun:_ZL21execute_sqlcom_selectP3THDP10TABLE_LIST\n   fun:_Z21mysql_execute_commandP3THD\n   fun:_Z11mysql_parseP3THDPcjP12Parser_state\n}\n\n{\n   codership/mysql-wsrep/issues#176\n   Memcheck:Leak\n   fun:_Z16wsrep_set_paramsRN6galera10ReplicatorEPKc\n}\n\n{\n   codership/mysql-wsrep/issues#176\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   fun:DbugMalloc\n   fun:ListParse\n   fun:_gu_db_push_\n   fun:_Z16wsrep_set_paramsRN6galera10ReplicatorEPKc\n   fun:galera_parameters_set\n   fun:_Z29wsrep_provider_options_updateP7sys_varP3THD13enum_var_type\n   fun:_ZN7sys_var6updateEP3THDP7set_var\n   fun:_ZN7set_var6updateEP3THD\n   fun:_Z17sql_set_variablesP3THDP4ListI12set_var_baseE\n   fun:_Z21mysql_execute_commandP3THD\n   fun:_Z11mysql_parseP3THDPcjP12Parser_state\n   fun:_ZL17wsrep_mysql_parseP3THDPcjP12Parser_state\n   fun:_Z16dispatch_command19enum_server_commandP3THDPcj\n   fun:_Z10do_commandP3THD\n   fun:_Z24do_handle_one_connectionP3THD\n}\n\n{\n   codership/mysql-wsrep/issues#176\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   fun:state_map_insert\n   fun:code_state\n   fun:_gu_db_push_\n   fun:_Z16wsrep_set_paramsRN6galera10ReplicatorEPKc\n   fun:galera_parameters_set\n   fun:_Z29wsrep_provider_options_updateP7sys_varP3THD13enum_var_type\n   fun:_ZN7sys_var6updateEP3THDP7set_var\n   fun:_ZN7set_var6updateEP3THD\n   fun:_Z17sql_set_variablesP3THDP4ListI12set_var_baseE\n   fun:_Z21mysql_execute_commandP3THD\n   fun:_Z11mysql_parseP3THDPcjP12Parser_state\n   fun:_ZL17wsrep_mysql_parseP3THDPcjP12Parser_state\n   fun:_Z16dispatch_command19enum_server_commandP3THDPcj\n   fun:_Z10do_commandP3THD\n   fun:_Z24do_handle_one_connectionP3THD\n}\n\n{\n   codership/mysql-wsrep/issues#176\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   fun:DbugMalloc\n   fun:StrDup\n   fun:ListParse\n   fun:_gu_db_push_\n   fun:_Z16wsrep_set_paramsRN6galera10ReplicatorEPKc\n   fun:galera_parameters_set\n   fun:_Z29wsrep_provider_options_updateP7sys_varP3THD13enum_var_type\n   fun:_ZN7sys_var6updateEP3THDP7set_var\n   fun:_ZN7set_var6updateEP3THD\n   fun:_Z17sql_set_variablesP3THDP4ListI12set_var_baseE\n   fun:_Z21mysql_execute_commandP3THD\n   fun:_Z11mysql_parseP3THDPcjP12Parser_state\n   fun:_ZL17wsrep_mysql_parseP3THDPcjP12Parser_state\n   fun:_Z16dispatch_command19enum_server_commandP3THDPcj\n   fun:_Z10do_commandP3THD\n}\n\n{\n   codership/mysql-wsrep/issues#176\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   fun:code_state\n   fun:_gu_db_push_\n   fun:_Z16wsrep_set_paramsRN6galera10ReplicatorEPKc\n   fun:galera_parameters_set\n   fun:_Z29wsrep_provider_options_updateP7sys_varP3THD13enum_var_type\n   fun:_ZN7sys_var6updateEP3THDP7set_var\n   fun:_ZN7set_var6updateEP3THD\n   fun:_Z17sql_set_variablesP3THDP4ListI12set_var_baseE\n   fun:_Z21mysql_execute_commandP3THD\n   fun:_Z11mysql_parseP3THDPcjP12Parser_state\n   fun:_ZL17wsrep_mysql_parseP3THDPcjP12Parser_state\n   fun:_Z16dispatch_command19enum_server_commandP3THDPcj\n   fun:_Z10do_commandP3THD\n   fun:_Z24do_handle_one_connectionP3THD\n   fun:handle_one_connection\n}\n\n{\n   codership/mysql-wsrep/issues#176\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   fun:DbugMalloc\n   fun:PushState\n   fun:_gu_db_push_\n   fun:_Z16wsrep_set_paramsRN6galera10ReplicatorEPKc\n   fun:galera_parameters_set\n   fun:_Z29wsrep_provider_options_updateP7sys_varP3THD13enum_var_type\n   fun:_ZN7sys_var6updateEP3THDP7set_var\n   fun:_ZN7set_var6updateEP3THD\n   fun:_Z17sql_set_variablesP3THDP4ListI12set_var_baseE\n   fun:_Z21mysql_execute_commandP3THD\n   fun:_Z11mysql_parseP3THDPcjP12Parser_state\n   fun:_ZL17wsrep_mysql_parseP3THDPcjP12Parser_state\n   fun:_Z16dispatch_command19enum_server_commandP3THDPcj\n   fun:_Z10do_commandP3THD\n   fun:_Z24do_handle_one_connectionP3THD\n}\n\n{\n   codership/galera#331\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   fun:state_map_insert\n   fun:code_state\n   fun:_gu_db_keyword_\n   fun:_ZN6galera3ist6Sender4sendEll\n   fun:run_async_sender\n   fun:start_thread\n   fun:clone\n}\n\n{\n   codership/galera#331\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   fun:code_state\n   fun:_gu_db_keyword_\n   fun:_ZN6galera3ist6Sender4sendEll\n   fun:run_async_sender\n   fun:start_thread\n   fun:clone\n}\n\n# \n# MDEV-11061: OpenSSL 0.9.8 problems\n#\n\n{\n   MDEV-11061: OpenSSL 0.9.8\n   Memcheck:Cond\n   obj:*/libz.so*\n   ...\n   obj:*/libcrypto.so.0.9.8\n   ...\n   obj:*/libssl.so.0.9.8\n   ...\n}\n\n{\n   MDEV-11061: OpenSSL 0.9.8\n   Memcheck:Value8\n   obj:*/libz.so*\n   ...\n   obj:*/libcrypto.so.0.9.8\n   ...\n   obj:*/libssl.so.0.9.8\n   ...\n}\n\n{\n   MDEV-11061: OpenSSL 0.9.8\n   Memcheck:Cond\n   obj:*/libcrypto.so.0.9.8\n   ...\n   obj:*/libssl.so.0.9.8\n   ...\n}\n\n{\n   MDEV-11061: OpenSSL 0.9.8\n   Memcheck:Value8\n   obj:*/libcrypto.so.0.9.8\n   ...\n   obj:*/libssl.so.0.9.8\n   ...\n}\n\n{\n   MDEV-11061: OpenSSL 0.9.8\n   Memcheck:Cond\n   obj:*/libssl.so.0.9.8\n   obj:*/libssl.so.0.9.8\n   ...\n}\n\n{\n   MDEV-11061: OpenSSL 0.9.8\n   Memcheck:Value8\n   obj:*/libssl.so.0.9.8\n   obj:*/libssl.so.0.9.8\n   ...\n}\n\n{\n   MDEV-11061: OpenSSL 0.9.8\n   Memcheck:Cond\n   fun:memcpy\n   obj:*/libcrypto.so.0.9.8\n   obj:*/libssl.so.0.9.8\n   ...\n}\n\n{\n   MDEV-11061: OpenSSL 0.9.8\n   Memcheck:Value8\n   fun:memcpy\n   obj:*/libcrypto.so.0.9.8\n   obj:*/libssl.so.0.9.8\n   ...\n}\n\n{\n   MDEV-11061: OpenSSL 0.9.8\n   Memcheck:Cond\n   fun:is_overlap\n   fun:memcpy\n   obj:*/libcrypto.so.0.9.8\n   obj:*/libssl.so.0.9.8\n   ...\n}\n\n{\n   MDEV-11061: OpenSSL 0.9.8\n   Memcheck:Cond\n   fun:memset\n   obj:*/libcrypto.so.0.9.8\n   ...\n   obj:*/libssl.so.0.9.8\n   ...\n}\n\n{\n   MDEV-11061: OpenSSL 0.9.8\n   Memcheck:Value8\n   fun:memset\n   obj:*/libcrypto.so.0.9.8\n   ...\n   obj:*/libssl.so.0.9.8\n   ...\n}\n\n{\n   MDEV-11061: OpenSSL 0.9.8\n   Memcheck:Param\n   write(buf)\n   obj:*/libpthread-2.9.so*\n   obj:*/libcrypto.so.0.9.8\n   ...\n   obj:*/libssl.so.0.9.8\n   ...\n}\n\n#\n# OpenSSL 1.0.1k problems\n#\n\n{\n   OPENSSL 1.0.1k crypto leak\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   fun:CRYPTO_malloc\n   ...\n   fun:ENGINE_add\n}\n\n{\n   OPENSSL 1.0.1k crypto leak\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   fun:CRYPTO_malloc\n   fun:ENGINE_new\n}\n\n#\n# OpenSSL 1.0.1l problems\n#\n\n{\n   OpenSSL 1.0.1l wrong jump\n   Memcheck:Cond\n   fun:bcmp\n   obj:/usr/lib64/libcrypto.so*\n   fun:FIPS_selftest\n}\n\n{\n   OpenSSL 1.0.1l wrong jump 2\n   Memcheck:Cond\n   obj:/usr/lib64/libcrypto.so*\n   fun:FIPS_mode_set\n   obj:/usr/lib64/libcrypto.so*\n}\n\n\n\n##\n## The following is a copy of facebook/mysql-5.6 suppressions:\n##\n\n#\n# RocksDB Storage Engine suppressions start\n#\n\n{\n   Still reachable for once-per-process initializations\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   ...\n   fun:_ZN7rocksdb16ThreadStatusUtil19NewColumnFamilyInfoEPKNS_2DBEPKNS_16ColumnFamilyDataERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEPKNS_3EnvE\n   fun:_ZNK7rocksdb6DBImpl21NewThreadStatusCfInfoEPNS_16ColumnFamilyDataE\n   fun:_ZN7rocksdb2DB4OpenERKNS_9DBOptionsERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKSt6vectorINS_22ColumnFamilyDescriptorESaISD_EEPSC_IPNS_18ColumnFamilyHandleESaISJ_EEPPS0_\n   fun:_ZN7rocksdb13TransactionDB4OpenERKNS_9DBOptionsERKNS_20TransactionDBOptionsERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKSt6vectorINS_22ColumnFamilyDescriptorESaISG_EEPSF_IPNS_18ColumnFamilyHandleESaISM_EEPPS0_\n   fun:_ZN7myrocksL17rocksdb_init_funcEPv\n}\n\n\n{\n   Still reachable for once-per-process initializations 2\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   ...\n   fun:_ZN7rocksdb16ThreadStatusUtil19NewColumnFamilyInfoEPKNS_2DBEPKNS_16ColumnFamilyDataERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEPKNS_3EnvE\n   fun:_ZNK7rocksdb6DBImpl21NewThreadStatusCfInfoEPNS_16ColumnFamilyDataE\n   fun:_ZN7rocksdb6DBImpl4OpenERKNS_9DBOptionsERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKSt6vectorINS_22ColumnFamilyDescriptorESaISD_EEPSC_IPNS_18ColumnFamilyHandleESaISJ_EEPPNS_2DBEbb\n   fun:_ZN7rocksdb13TransactionDB4OpenERKNS_9DBOptionsERKNS_20TransactionDBOptionsERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKSt6vectorINS_22ColumnFamilyDescriptorESaISG_EEPSF_IPNS_18ColumnFamilyHandleESaISM_EEPPS0_\n#   fun:_ZN7myrocksL17rocksdb_init_funcEPv\n#  ^ commenting the above out because we are hitting the --num-callers=16\n#    limitation that MTR sets for valgrind\n}\n\n{\n   Still reachable for once-per-process initializations 3\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   ...\n   fun:_ZN7rocksdb16ThreadStatusUtil19NewColumnFamilyInfoEPKNS_2DBEPKNS_16ColumnFamilyDataERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEPKNS_3EnvE\n   fun:_ZNK7rocksdb6DBImpl21NewThreadStatusCfInfoEPNS_16ColumnFamilyDataE\n   fun:_ZN7rocksdb6DBImpl22CreateColumnFamilyImplERKNS_19ColumnFamilyOptionsERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEPPNS_18ColumnFamilyHandleE\n}\n\n{\n   Still reachable for once-per-process initializations\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   ...\n   fun:_ZN7rocksdb19ThreadStatusUpdater14RegisterThreadENS_12ThreadStatus10ThreadTypeEm\n   fun:_ZN7rocksdb16ThreadStatusUtil14RegisterThreadEPKNS_3EnvENS_12ThreadStatus10ThreadTypeE\n   fun:_ZN7rocksdb14ThreadPoolImpl4Impl15BGThreadWrapperEPv\n   ...\n}\n\n{\n   Still reachable for once-per-process initializations\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   ...\n   fun:_ZN7rocksdb14ThreadLocalPtr14InitSingletonsEv\n   fun:_ZN7rocksdb3Env7DefaultEv\n   fun:_ZN7rocksdb9DBOptionsC1Ev\n   ...\n   fun:_ZN7myrocksL27rdb_init_rocksdb_db_optionsEv\n}\n\n{\n   Still reachable for once-per-process initializations\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   ...\n   fun:_ZN7rocksdb12_GLOBAL__N_18PosixEnv*\n   fun:_ZN7rocksdb3Env7DefaultEv\n   fun:_ZN7rocksdb9DBOptionsC1Ev\n   ...\n   fun:_ZN7myrocksL27rdb_init_rocksdb_db_optionsEv\n}\n\n{\n   Still reachable for thread local storage initialization (SetHandle)\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   ...\n   fun:_ZNSt13unordered_mapIjPFvPvESt4hashIjESt8equal_toIjESaISt4pairIKjS2_EEEixERS8_\n   fun:_ZN7rocksdb14ThreadLocalPtr10StaticMeta10SetHandlerEjPFvPvE\n   fun:_ZN7rocksdb14ThreadLocalPtrC1EPFvPvE\n   ...\n}\n\n{\n   Still reachable for thread local storage initialization (ReclaimId)\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   ...\n   fun:_ZN7rocksdb10autovectorIjLm8EE9push_backERKj\n   fun:_ZN7rocksdb14ThreadLocalPtr10StaticMeta9ReclaimIdEj\n   fun:_ZN7rocksdb14ThreadLocalPtrD1Ev\n   ...\n}\n\n{\n   Static initialization\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   ...\n   fun:_Z41__static_initialization_and_destruction_0ii\n   ...\n}\n\n##\n## RocksDB Storage Engine suppressions end\n##\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/sp-error.test": "#\n# Stored PROCEDURE error tests\n#\n\n--source include/default_charset.inc\n\n--disable_warnings\ndrop table if exists t1, t2;\n--enable_warnings\n\n# Backup the mysql.proc table\n--replace_result $MYSQLTEST_VARDIR MYSQLTEST_VARDIR\neval SELECT * FROM mysql.proc INTO OUTFILE '$MYSQLTEST_VARDIR/tmp/proc.txt';\n\n# Make sure we don't have any procedures left.\ndelete from mysql.proc;\n\ndelimiter |;\n\n# This should give three syntax errors (sometimes crashed; bug #643)\n# (Unfortunately, this is not a 100% test, on some platforms this\n#  passed despite the bug.)\n--error 1064\ncreate procedure syntaxerror(t int)|\n--error 1064\ncreate procedure syntaxerror(t int)|\n--error 1064\ncreate procedure syntaxerror(t int)|\n\n# Check that we get the right error, i.e. UDF declaration parses correctly,\n# but foo.so doesn't exist.\n#    This generates an error message containing a misleading errno which\n#    might vary between systems (it usually doesn't have anything to do with\n#    the actual failing dlopen()).\n#--error 1126\n#create function foo returns real soname \"foo.so\"|\n\n\n--disable_warnings\ndrop table if exists t3|\n--enable_warnings\ncreate table t3 ( x int )|\ninsert into t3 values (2), (3)|\n\ncreate procedure bad_into(out param int)\n  select x from t3 into param|\n\n--error 1172\ncall bad_into(@x)|\n\ndrop procedure bad_into|\ndrop table t3|\n\n\ncreate procedure proc1()\n  set @x = 42|\n\ncreate function func1() returns int\n  return 42|\n\n# Can't create recursively\n--error 1303\ncreate procedure foo()\n  create procedure bar() set @x=3|\n--error 1303\ncreate procedure foo()\n  create function bar() returns double return 2.3|\n\n# Already exists\n--error 1304\ncreate procedure proc1()\n  set @x = 42|\n--error 1304\ncreate function func1() returns int\n  return 42|\n\ndrop procedure proc1|\ndrop function func1|\n\n# Does not exist\n--error 1305\nalter procedure foo|\n--error 1305\nalter function foo|\n--error 1305\ndrop procedure foo|\n--error 1305\ndrop function foo|\n--error 1305\ncall foo()|\ndrop procedure if exists foo|\n--error 1305\nshow create procedure foo|\n--error 1305\nshow create function foo|\n\n# LEAVE/ITERATE with no match\n--error 1308\ncreate procedure foo()\nfoo: loop\n  leave bar;\nend loop|\n--error 1308\ncreate procedure foo()\nfoo: loop\n  iterate bar;\nend loop|\n--error 1308\ncreate procedure foo()\nfoo: begin\n  iterate foo;\nend|\n\n# Redefining label\n--error 1309\ncreate procedure foo()\nfoo: loop\n  foo: loop\n    set @x=2;\n  end loop foo;\nend loop foo|\n\n# End label mismatch\n--error 1310\ncreate procedure foo()\nfoo: loop\n  set @x=2;\nend loop bar|\n\n# RETURN in FUNCTION only\n--error 1313\ncreate procedure foo()\n  return 42|\n\n# Wrong number of arguments\ncreate procedure p(x int)\n  set @x = x|\ncreate function f(x int) returns int\n  return x+42|\n\n--error 1318\ncall p()|\n--error 1318\ncall p(1, 2)|\n--error 1318\nselect f()|\n--error 1318\nselect f(1, 2)|\n\ndrop procedure p|\ndrop function f|\n\n--error 1319 \ncreate procedure p(val int, out res int)\nbegin\n  declare x int default 0;\n  declare continue handler for foo set x = 1;\n\n  insert into test.t1 values (val);\n  if (x) then\n    set res = 0;\n  else\n    set res = 1;\n  end if;\nend|\n\n--error 1319 \ncreate procedure p(val int, out res int)\nbegin\n  declare x int default 0;\n  declare foo condition for 1146;\n  declare continue handler for bar set x = 1;\n\n  insert into test.t1 values (val);\n  if (x) then\n    set res = 0;\n  else\n    set res = 1;\n  end if;\nend|\n\n--error 1320\ncreate function f(val int) returns int\nbegin\n  declare x int;\n\n  set x = val+3;\nend|\n\ncreate function f(val int) returns int\nbegin\n  declare x int;\n\n  set x = val+3;\n  if x < 4 then\n    return x;\n  end if;\nend|\n\n--error 1321\nselect f(10)|\n\ndrop function f|\n\n--error ER_PARSE_ERROR\ncreate procedure p()\nbegin\n  declare c cursor for insert into test.t1 values (\"foo\", 42);\n\n  open c;\n  close c;\nend|\n\n--error 1323\ncreate procedure p()\nbegin\n  declare x int;\n  declare c cursor for select * into x from test.t limit 1;\n\n  open c;\n  close c;\nend|\n\n--error 1324\ncreate procedure p()\nbegin\n  declare c cursor for select * from test.t;\n\n  open cc;\n  close c;\nend|\n\n--disable_warnings\ndrop table if exists t1|\n--enable_warnings\ncreate table t1 (val int)|\n\ncreate procedure p()\nbegin\n  declare c cursor for select * from test.t1;\n\n  open c;\n  open c;\n  close c;\nend|\n--error 1325\ncall p()|\ndrop procedure p|\n\ncreate procedure p()\nbegin\n  declare c cursor for select * from test.t1;\n\n  open c;\n  close c;\n  close c;\nend|\n--error 1326\ncall p()|\ndrop procedure p|\n\n--error 1305\nalter procedure bar3 sql security invoker|\n\ndrop table t1|\n\n--disable_warnings\ndrop table if exists t1|\n--enable_warnings\ncreate table t1 (val int, x float)|\ninsert into t1 values (42, 3.1), (19, 1.2)|\n\n--error 1327\ncreate procedure p()\nbegin\n  declare x int;\n  declare c cursor for select * from t1;\n\n  open c;\n  fetch c into x, y;\n  close c;\nend|\n\ncreate procedure p()\nbegin\n  declare x int;\n  declare c cursor for select * from t1;\n\n  open c;\n  fetch c into x;\n  close c;\nend|\n--error 1328\ncall p()|\ndrop procedure p|\n\ncreate procedure p()\nbegin\n  declare x int;\n  declare y float;\n  declare z int;\n  declare c cursor for select * from t1;\n\n  open c;\n  fetch c into x, y, z;\n  close c;\nend|\n--error 1328\ncall p()|\ndrop procedure p|\n\n--error 1330\ncreate procedure p(in x int, x char(10))\nbegin\nend|\n--error 1330\ncreate function p(x int, x char(10))\nbegin\nend|\n\n--error 1331\ncreate procedure p()\nbegin\n  declare x float;\n  declare x int;\nend|\n\n--error 1332\ncreate procedure p()\nbegin\n  declare c condition for 1064;\n  declare c condition for 1065;\nend|\n\n--error 1333\ncreate procedure p()\nbegin\n  declare c cursor for select * from t1;\n  declare c cursor for select field from t1;\nend|\n\n# USE is not allowed\n--error ER_SP_BADSTATEMENT \ncreate procedure u()\n  use sptmp|\n\n# Enforced standard order of declarations\n--error 1337\ncreate procedure p()\nbegin\n  declare c cursor for select * from t1;\n  declare x int;\nend|\n--error 1337\ncreate procedure p()\nbegin\n  declare x int;\n  declare continue handler for sqlstate '42S99' set x = 1;\n  declare foo condition for sqlstate '42S99';\nend|\n\n--error 1338\ncreate procedure p()\nbegin\n  declare x int;\n  declare continue handler for sqlstate '42S99' set x = 1;\n  declare c cursor for select * from t1;\nend|\n\n# Check in and inout arguments.\n--disable_warnings\ndrop procedure if exists p|\n--enable_warnings\ncreate procedure p(in x int, inout y int, out z int)\nbegin\n  set y = x+y;\n  set z = x+y;\nend|\n\nset @tmp_x = 42|\nset @tmp_y = 3|\nset @tmp_z = 0|\n# For reference: this is ok\ncall p(@tmp_x, @tmp_y, @tmp_z)|\nselect @tmp_x, @tmp_y, @tmp_z|\n\n--error ER_SP_NOT_VAR_ARG\ncall p(42, 43, @tmp_z)|\n--error ER_SP_NOT_VAR_ARG\ncall p(42, @tmp_y, 43)|\n\ndrop procedure p|\n\n\n#\n# Let us test that we can access mysql.proc table for routines\n# definitions lookup without locking it explicitly.\n#\ncreate procedure p() begin end|\nlock table t1 read|\n# This should succeed\ncall p()|\nunlock tables|\ndrop procedure p|\n# Let us check restrictions which this ability puts on mysql.proc locking.\n--error ER_WRONG_LOCK_OF_SYSTEM_TABLE\nlock tables t1 read, mysql.proc write|\n--error ER_WRONG_LOCK_OF_SYSTEM_TABLE\nlock tables mysql.proc write, mysql.user write|\n# Locking for read should be OK\nlock tables t1 read, mysql.proc read|\nunlock tables|\n# You also should be able lock only mysql.proc for write\nlock tables mysql.proc write|\nunlock tables|\n\n\n#\n# Check that in functions we don't allow to update tables which\n# are used by statements which invoke these functions.\n#\n--disable_warnings\ndrop function if exists f1|\n--enable_warnings\ncreate function f1(i int) returns int\nbegin\n  insert into t1 (val) values (i);\n  return 0;\nend|\n--error ER_CANT_UPDATE_USED_TABLE_IN_SF_OR_TRG\nselect val, f1(val) from t1|\n# Table alias should not matter\n--error ER_CANT_UPDATE_USED_TABLE_IN_SF_OR_TRG\nselect val, f1(val) from t1 as tab|\nselect * from t1|\n--error ER_CANT_UPDATE_USED_TABLE_IN_SF_OR_TRG\nupdate t1 set val= f1(val)|\nselect * from t1|\n# But this should be OK\nselect f1(17)|\nselect * from t1|\n# Cleanup\ndelete from t1 where val= 17|\ndrop function f1|\n\n\n#\n# BUG#1965\n#\ncreate procedure bug1965()\nbegin\n  declare c cursor for select val from t1 order by valname;\n  open c;\n  close c;\nend|\n\n--error 1054\ncall bug1965()|\ndrop procedure bug1965|\n\n#\n# BUG#1966\n#\n--error 1327\nselect 1 into a|\n\n#\n# BUG#1653\n#\n--disable_warnings\ndrop table if exists t3|\n--enable_warnings\ncreate table t3 (column_1_0 int)|\n\ncreate procedure bug1653()\n  update t3 set column_1 = 0|\n\n--error 1054\ncall bug1653()|\ndrop table t3|\ncreate table t3 (column_1 int)|\ncall bug1653()|\n\ndrop procedure bug1653|\ndrop table t3|\n\n#\n# BUG#2259\n#\n# Note: When this bug existed, it did not necessarily cause a crash\n#       in all builds, but valgrind did give warnings.\ncreate procedure bug2259()\nbegin\n  declare v1 int;\n  declare c1 cursor for select s1 from t1;\n\n  fetch c1 into v1;\nend|\n\n--error 1326\ncall bug2259()|\ndrop procedure bug2259|\n\n#\n# BUG#2272\n#\ncreate procedure bug2272()\nbegin\n  declare v int;\n\n  update t1 set v = 42;\nend|\n\ninsert into t1 values (666, 51.3)|\n--error 1054\ncall bug2272()|\ntruncate table t1|\ndrop procedure bug2272|\n\n#\n# BUG#2329\n#\ncreate procedure bug2329_1()\nbegin\n  declare v int;\n\n  insert into t1 (v) values (5);\nend|\n\ncreate procedure bug2329_2()\nbegin\n  declare v int;\n\n  replace t1 set v = 5;\nend|\n\n--error 1054\ncall bug2329_1()|\n--error 1054\ncall bug2329_2()|\ndrop procedure bug2329_1|\ndrop procedure bug2329_2|\n\n#\n# BUG#3287\n#\ncreate function bug3287() returns int\nbegin\n  declare v int default null;\n\n  case\n    when v is not null then return 1;\n  end case;\n  return 2;\nend|\n--error 1339\nselect bug3287()|\ndrop function bug3287|\n\ncreate procedure bug3287(x int)\ncase x\nwhen 0 then\n  insert into test.t1 values (x, 0.1);\nwhen 1 then\n  insert into test.t1 values (x, 1.1);\nend case|\n--error 1339\ncall bug3287(2)|\ndrop procedure bug3287|\n\n#\n# BUG#3297\n#\n--disable_warnings\ndrop table if exists t3|\n--enable_warnings\ncreate table t3 (s1 int, primary key (s1))|\ninsert into t3 values (5),(6)|\n\ncreate procedure bug3279(out y int) \nbegin\n  declare x int default 0;\n  begin\n    declare exit handler for sqlexception set x = x+1;\n    insert into t3 values (5);\n  end;\n  if x < 2 then\n    set x = x+1;\n    insert into t3 values (6);\n  end if;\n  set y = x;\nend|\n\nset @x = 0|\n--error ER_DUP_ENTRY\ncall bug3279(@x)|\nselect @x|\ndrop procedure bug3279|\ndrop table t3|\n\n#\n# BUG#3339\n#\n--error 1049\ncreate procedure nodb.bug3339() begin end|\n\n#\n# BUG#2653\n#\ncreate procedure bug2653_1(a int, out b int)\n  set b = aa|\n\n--error ER_BAD_FIELD_ERROR\ncall bug2653_1(1, @b)|\n\ndrop procedure bug2653_1|\n\n--error ER_BAD_FIELD_ERROR\ncreate procedure bug2653_2(a int, out b int)\nbegin\n  if aa < 0 then\n    set b = - a;\n  else\n    set b = a;\n  end if;\nend|\n\n\n#\n# BUG#4344\n#\n--error 1357\ncreate procedure bug4344() drop procedure bug4344|\n--error 1357\ncreate procedure bug4344() drop function bug4344|\n\n#\n# BUG#3294: Stored procedure crash if table dropped before use\n# (Actually, when an error occurs within an error handler.)\n--disable_warnings\ndrop procedure if exists bug3294|\n--enable_warnings\ncreate procedure bug3294()\nbegin\n  declare continue handler for sqlexception drop table t5;\n  drop table t5;\n  drop table t5;\nend|\n\ncreate table t5 (x int)|\n--error 1051\ncall bug3294()|\ndrop procedure bug3294|\n\n#\n# BUG#876: Stored Procedures: Invalid SQLSTATE is allowed in \n#          a DECLARE ? HANDLER FOR stmt.\n#\n--disable_warnings\ndrop procedure if exists bug8776_1|\ndrop procedure if exists bug8776_2|\ndrop procedure if exists bug8776_3|\ndrop procedure if exists bug8776_4|\n--enable_warnings\n--error ER_SP_BAD_SQLSTATE\ncreate procedure bug8776_1()\nbegin\n  declare continue handler for sqlstate '42S0200test' begin end;\n  begin end;\nend|\n\n--error ER_SP_BAD_SQLSTATE\ncreate procedure bug8776_2()\nbegin\n  declare continue handler for sqlstate '4200' begin end;\n  begin end;\nend|\n\n--error ER_SP_BAD_SQLSTATE\ncreate procedure bug8776_3()\nbegin\n  declare continue handler for sqlstate '420000' begin end;\n  begin end;\nend|\n\n--error ER_SP_BAD_SQLSTATE\ncreate procedure bug8776_4()\nbegin\n  declare continue handler for sqlstate '42x00' begin end;\n  begin end;\nend|\n\n\n#\n# BUG#6600: Stored procedure crash after repeated calls with check table\n#\n--error ER_SP_BADSTATEMENT\ncreate procedure bug6600()\n  check table t1|\n\n# Check these two as well, while we're at it. (Although it isn't really\n# related to the bug report, but to the fix.)\n--error ER_SP_BADSTATEMENT\ncreate procedure bug6600()\n  lock table t1 read|\n--error ER_SP_BADSTATEMENT\ncreate procedure bug6600()\n  unlock table t1|\n\n#\n# BUG#9566: explicit LOCK TABLE and store procedures result in illegal state\n#\n# We should not think that mysql.proc table does not exist if we are unable\n# to open it under LOCK TABLE or in prelocked mode.\n#\n--disable_warnings\ndrop procedure if exists bug9566|\n--enable_warnings\ncreate procedure bug9566()\nbegin\n  select * from t1;\nend|\nlock table t1 read|\n# This should fail since we forgot to lock mysql.proc for writing\n# explicitly, and we can't open mysql.proc for _writing_ if there\n# are locked tables.\n--error ER_LOCK_OR_ACTIVE_TRANSACTION\nalter procedure bug9566 comment 'Some comment'|\nunlock tables|\n# This should succeed\ndrop procedure bug9566|\n\n\n#\n# BUG#7299: Stored procedures: exception handler catches not-found conditions\n#\n--disable_warnings\ndrop procedure if exists bug7299|\n--enable_warnings\ncreate procedure bug7299()\nbegin\n  declare v int;\n  declare c cursor for select val from t1;\n  declare exit handler for sqlexception select 'Error!'; \n\n  open c;\n  fetch c into v;\nend|\n\ntruncate table t1|\n--error ER_SP_FETCH_NO_DATA\ncall bug7299()|\ndrop procedure bug7299|\n\n\n#\n# BUG#9073: Able to declare two handlers for same condition in same scope\n#\n--error ER_SP_DUP_HANDLER\ncreate procedure bug9073()\nbegin\n  declare continue handler for sqlexception select 1;\n  declare continue handler for sqlexception select 2;\nend|\n--error ER_SP_DUP_HANDLER\ncreate procedure bug9073()\nbegin\n  declare condname1 condition for 1234;\n  declare continue handler for condname1 select 1;\n  declare exit handler for condname1 select 2;\nend|\n--error ER_SP_DUP_HANDLER\ncreate procedure bug9073()\nbegin\n  declare condname1 condition for sqlstate '42000';\n  declare condname2 condition for sqlstate '42000';\n  declare exit handler for condname1 select 1;\n  declare continue handler for condname2 select 2;\nend|\n--error ER_SP_DUP_HANDLER\ncreate procedure bug9073()\nbegin\n  declare condname1 condition for sqlstate '42000';\n  declare exit handler for condname1 select 1;\n  declare exit handler for sqlstate '42000' select 2;\nend|\n\n# This should still work.\n--disable_warnings\ndrop procedure if exists bug9073|\n--enable_warnings\ncreate procedure bug9073()\nbegin\n  declare condname1 condition for sqlstate '42000';\n  declare continue handler for condname1 select 1;\n  begin\n    declare exit handler for sqlstate '42000' select 2;\n    begin\n      declare continue handler for sqlstate '42000' select 3;\n    end;\n  end;\nend|\ndrop procedure bug9073|\n\n\n#\n# BUG#7047: Stored procedure crash if alter procedure\n#\n--error ER_SP_NO_DROP_SP\ncreate procedure bug7047()\n  alter procedure bug7047|\n--error ER_SP_NO_DROP_SP\ncreate function bug7047() returns int\nbegin\n  alter function bug7047;\n  return 0;\nend|\n\n\n#\n# BUG#8408: Stored procedure crash if function contains SHOW\n# BUG#9058: Stored Procedures: Crash if function included SELECT\n#\n\n# Some things are caught when parsing\n--error ER_SP_NO_RETSET\ncreate function bug8408() returns int\nbegin\n  select * from t1;\n  return 0;\nend|\n--error ER_SP_NO_RETSET\ncreate function bug8408() returns int\nbegin\n  show warnings;\n  return 0;\nend|\n--error ER_SP_NO_RETSET\ncreate function bug8408(a int) returns int\nbegin\n  declare b int;\n  select b;\n  return b;\nend|\n\n--disable_warnings\ndrop function if exists bug8408_f|\ndrop procedure if exists bug8408_p|\n--enable_warnings\n\n# Some things must be caught at invokation time\ncreate function bug8408_f() returns int\nbegin\n  call bug8408_p();\n  return 0;\nend|\ncreate procedure bug8408_p()\n  select * from t1|\n\ncall bug8408_p()|\n--error ER_SP_NO_RETSET\nselect bug8408_f()|\n\ndrop procedure bug8408_p|\ndrop function bug8408_f|\n\n# But this is ok\ncreate function bug8408() returns int\nbegin\n  declare n int default 0;\n  select count(*) into n from t1;\n  return n;\nend|\n\ninsert into t1 value (2, 2.7), (3, 3.14), (7, 7.0)|\nselect *,bug8408() from t1|\n\ndrop function bug8408|\ntruncate table t1|\n\n\n#\n# BUG#10537: Server crashes while loading data file into table through\n#            procedure.\n# Disable load until it's PS and SP safe\n--disable_warnings\ndrop procedure if exists bug10537|\n--enable_warnings\n--error ER_SP_BADSTATEMENT\ncreate procedure bug10537()\n  load data local infile '/tmp/somefile' into table t1|\n\n\n#\n# BUG#8409: Stored procedure crash if function contains FLUSH\n#\n--disable_warnings\ndrop function if exists bug8409|\n--enable_warnings\n--error ER_STMT_NOT_ALLOWED_IN_SF_OR_TRG\ncreate function bug8409()\n  returns int\nbegin\n  flush tables;\n  return 5;\nend|\n--error ER_STMT_NOT_ALLOWED_IN_SF_OR_TRG\ncreate function bug8409() returns int begin reset query cache;\nreturn 1; end|\n--error ER_STMT_NOT_ALLOWED_IN_SF_OR_TRG\ncreate function bug8409() returns int begin reset master;\nreturn 1; end|\n--error ER_STMT_NOT_ALLOWED_IN_SF_OR_TRG\ncreate function bug8409() returns int begin reset slave;\nreturn 1; end|\n--error ER_STMT_NOT_ALLOWED_IN_SF_OR_TRG\ncreate function bug8409() returns int begin flush hosts;\nreturn 1; end|\n--error ER_STMT_NOT_ALLOWED_IN_SF_OR_TRG\ncreate function bug8409() returns int begin flush privileges;\nreturn 1; end|\n--error ER_STMT_NOT_ALLOWED_IN_SF_OR_TRG\ncreate function bug8409() returns int begin flush tables with read lock;\nreturn 1; end|\n--error ER_STMT_NOT_ALLOWED_IN_SF_OR_TRG\ncreate function bug8409() returns int begin flush tables;\nreturn 1; end|\n--error ER_STMT_NOT_ALLOWED_IN_SF_OR_TRG\ncreate function bug8409() returns int begin flush logs;\nreturn 1; end|\n--error ER_STMT_NOT_ALLOWED_IN_SF_OR_TRG\ncreate function bug8409() returns int begin flush status;\nreturn 1; end|\n--error ER_STMT_NOT_ALLOWED_IN_SF_OR_TRG\ncreate function bug8409() returns int begin flush slave;\nreturn 1; end|\n--error ER_STMT_NOT_ALLOWED_IN_SF_OR_TRG\ncreate function bug8409() returns int begin flush master;\nreturn 1; end|\n--error ER_STMT_NOT_ALLOWED_IN_SF_OR_TRG\ncreate function bug8409() returns int begin flush des_key_file;\nreturn 1; end|\n--error ER_STMT_NOT_ALLOWED_IN_SF_OR_TRG\ncreate function bug8409() returns int begin flush user_resources;\nreturn 1; end|\n\n\n#\n# BUG#9529: Stored Procedures: No Warning on truncation of procedure name\n#           during creation.\n# BUG#17015: Routine name truncation not an error\n#            When we started using utf8 for mysql.proc, this limit appeared\n#            to be higher, but in reality the names were truncated.\n--error ER_TOO_LONG_IDENT\ncreate procedure bug9529_901234567890123456789012345678901234567890123456789012345()\nbegin\nend|\n\n--disable_warnings\ndrop procedure if exists bug17015_0123456789012345678901234567890123456789012345678901234|\n--enable_warnings\n# Check the upper limit, just to make sure.\ncreate procedure bug17015_0123456789012345678901234567890123456789012345678901234()\nbegin\nend|\n\n--replace_column 5 '0000-00-00 00:00:00' 6 '0000-00-00 00:00:00'\nshow procedure status like 'bug17015%'|\ndrop procedure bug17015_0123456789012345678901234567890123456789012345678901234|\n\n\n#\n# BUG#10969: Stored procedures: crash if default() function\n#\n--disable_warnings\ndrop procedure if exists bug10969|\n--enable_warnings\n--error ER_WRONG_COLUMN_NAME\ncreate procedure bug10969()\nbegin\n  declare s1 int default 0;\n  select default(s1) from t30;\nend|\n\n# This should work\ncreate procedure bug10969()\nbegin\n  declare s1 int default 0;\n  select default(t30.s1) from t30;\nend|\n\ndrop procedure bug10969|\n\n\ndrop table t1|\n\ndelimiter ;|\n\n# BUG#9814: Closing a cursor that is not open \ncreate table t1(f1 int);\ncreate table t2(f1 int);\n \ndelimiter |;\nCREATE PROCEDURE SP001()\nP1: BEGIN\n  DECLARE ENDTABLE INT DEFAULT 0;\n  DECLARE TEMP_NUM INT;\n  DECLARE TEMP_SUM INT;\n  DECLARE C1 CURSOR FOR SELECT F1 FROM t1;\n  DECLARE C2 CURSOR FOR SELECT F1 FROM t2;\n  DECLARE CONTINUE HANDLER FOR NOT FOUND SET ENDTABLE = 1;\n\n  SET ENDTABLE=0;\n  SET TEMP_SUM=0;\n  SET TEMP_NUM=0;\n  \n  OPEN C1;\n\n  FETCH C1 INTO TEMP_NUM;\n  WHILE ENDTABLE = 0 DO\n          SET TEMP_SUM=TEMP_NUM+TEMP_SUM;\n          FETCH C1 INTO TEMP_NUM;\n  END WHILE;\n  SELECT TEMP_SUM;\n  CLOSE C1;\n  CLOSE C1;\n  SELECT 'end of proc';\nEND P1|\ndelimiter ;|\n--error 1326\ncall SP001();\ndrop procedure SP001;\ndrop table t1, t2;\n\n# Bug #11394 \"Recursion in SP crash server\" and bug #11600 \"Stored\n# procedures: crash with function calling itself\".\n# We have to disable recursion since in many cases LEX and many\n# Item's can't be used in reentrant way nowdays.\ndelimiter |;\n--disable_warnings\ndrop function if exists bug11394|\ndrop function if exists bug11394_1|\ndrop function if exists bug11394_2|\ndrop procedure if exists bug11394|\n--enable_warnings\ncreate function bug11394(i int) returns int\nbegin\n  if i <= 0 then\n    return 0;\n  else\n    return (i in (100, 200, bug11394(i-1), 400));\n  end if;\nend|\n# If we allow recursive functions without additional modifications\n# this will crash server since Item for \"IN\" is not reenterable.\n--error 1424\nselect bug11394(2)|\ndrop function bug11394|\ncreate function bug11394_1(i int) returns int\nbegin\n  if i <= 0 then\n    return 0;\n  else\n    return (select bug11394_1(i-1));\n  end if;\nend|\n# The following statement will crash because some LEX members responsible\n# for selects cannot be used in reentrant fashion.\n--error 1424\nselect bug11394_1(2)|\ndrop function bug11394_1|\n# Note that the following should be allowed since it does not contains\n# recursion\ncreate function bug11394_2(i int) returns int return i|\nselect bug11394_2(bug11394_2(10))|\ndrop function bug11394_2|\ncreate procedure bug11394(i int, j int)\nbegin\n  if i > 0 then\n    call bug11394(i - 1,(select 1));\n  end if;\nend|\n--error ER_SP_RECURSION_LIMIT\ncall bug11394(2, 1)|\nset @@max_sp_recursion_depth=10|\ncall bug11394(2, 1)|\nset @@max_sp_recursion_depth=default|\ndrop procedure bug11394|\ndelimiter ;|\n\n\n#\n# BUG 12490 (Packets out of order if calling HELP CONTENTS from Stored Procedure)\n#\n--error ER_SP_BADSTATEMENT\nCREATE PROCEDURE BUG_12490() HELP CONTENTS;\n--error ER_PARSE_ERROR\nCREATE FUNCTION BUG_12490() RETURNS INT HELP CONTENTS;\nCREATE TABLE t_bug_12490(a int);\n--error ER_SP_BADSTATEMENT\nCREATE TRIGGER BUG_12490 BEFORE UPDATE ON t_bug_12490 FOR EACH ROW HELP CONTENTS;\nDROP TABLE t_bug_12490;\n\n#\n# Bug#11834 \"Re-execution of prepared statement with dropped function\n# crashes server\". Also tests handling of prepared stmts which use\n# stored functions but does not require prelocking.\n#\n--disable_warnings\ndrop function if exists bug11834_1;\ndrop function if exists bug11834_2;\n--enable_warnings\ncreate function bug11834_1() returns int return 10;\ncreate function bug11834_2() returns int return bug11834_1();\nprepare stmt from \"select bug11834_2()\";\nexecute stmt;\n# Re-execution of statement should not crash server.\nexecute stmt;\ndrop function bug11834_1;\n# Attempt to execute statement should return proper error and \n# should not crash server.\n\n# NOTE! The error we get from the below query indicates that the sp bug11834_2\n# does not exist(this is wrong but can be accepted)\n# This behaviour has been reported as bug#21294\n--error ER_SP_DOES_NOT_EXIST\nexecute stmt;\ndeallocate prepare stmt;\ndrop function bug11834_2;\n\n#\n# Bug#12953 \"Stored procedures: crash if OPTIMIZE TABLE in function\"\n#\ndelimiter |;\n--disable_warnings\nDROP FUNCTION IF EXISTS bug12953|\n--enable_warnings\n--error ER_SP_NO_RETSET\nCREATE FUNCTION bug12953() RETURNS INT\nBEGIN\n  OPTIMIZE TABLE t1;\n  RETURN 1;\nEND|\ndelimiter ;|\n\n#\n# Bug##12995 \"Inside function \"Table 't4' was not locked with LOCK TABLES\"\n#\ndelimiter |;\n--disable_warnings\nDROP FUNCTION IF EXISTS bug12995|\n--enable_warnings\n--error ER_SP_BADSTATEMENT\nCREATE FUNCTION bug12995() RETURNS INT\nBEGIN\n  HANDLER t1 OPEN;\n  RETURN 1;\nEND|\n--error ER_SP_BADSTATEMENT\nCREATE FUNCTION bug12995() RETURNS INT\nBEGIN\n  HANDLER t1 READ FIRST;\n  RETURN 1;\nEND|\n--error ER_SP_BADSTATEMENT\nCREATE FUNCTION bug12995() RETURNS INT\nBEGIN\n  HANDLER t1 CLOSE;\n  RETURN 1;\nEND|\n--error 1305\nSELECT bug12995()|\ndelimiter ;|\n\n\n#\n# BUG#12712: SET AUTOCOMMIT should fail within SP/functions/triggers\n#\n--disable_warnings\ndrop procedure if exists bug12712;\ndrop function if exists bug12712;\n--enable_warnings\n# Can...\ncreate procedure bug12712()\n  set session autocommit = 0;\n\nselect @@autocommit;\nset @au = @@autocommit;\ncall bug12712();\nselect @@autocommit;\nset session autocommit = @au;\n\ndelimiter |;\ncreate function bug12712()\n  returns int\nbegin\n  call bug12712();\n  return 0;\nend|\n\n# Can't...\n--error ER_SP_CANT_SET_AUTOCOMMIT\nset @x = bug12712()|\ndrop procedure bug12712|\ndrop function bug12712|\n--error ER_SP_CANT_SET_AUTOCOMMIT\ncreate function bug12712()\n    returns int\nbegin\n  set session autocommit = 0;\n  return 0;\nend|\n--error ER_SP_CANT_SET_AUTOCOMMIT\ncreate function bug12712()\n    returns int\nbegin\n  set @@autocommit = 0;\n  return 0;\nend|\n--error ER_SP_CANT_SET_AUTOCOMMIT\ncreate function bug12712()\n    returns int\nbegin\n  set local autocommit = 0;\n  return 0;\nend|\ndelimiter ;|\n--error ER_SP_CANT_SET_AUTOCOMMIT\ncreate trigger bug12712\n  before insert on t1 for each row set session autocommit = 0;\n\n#\n# BUG#9367: Stored procedures: client hang after \"show warnings\"\n#\n--disable_parsing\n--disable_warnings\ndrop procedure if exists bug9367;\n--enable_warnings\ncreate table t1 (s1 int);\nselect s1 from t1;\ndelimiter |;\ncreate procedure bug9367()\nbegin\n  declare v int;\n  declare c cursor for select s1 from t1;\n  open c;\n  show warnings;\n  fetch c into v;\n  select v;\nend|\ndelimiter ;|\ncall bug9367();\ndrop procedure bug9367;\ndrop table t1;\n--enable_parsing\n\n#\n# BUG#13510: Setting password local variable changes current password\n#\ndelimiter |;\n--disable_warnings\ndrop procedure if exists bug13510_1|\ndrop procedure if exists bug13510_2|\ndrop procedure if exists bug13510_3|\ndrop procedure if exists bug13510_4|\n--enable_warnings\n\n--error ER_SP_BAD_VAR_SHADOW\ncreate procedure bug13510_1()\nbegin\n  declare password varchar(10);\n\n  set password = 'foo1';\n  select password;\nend|\n\n# Check that an error message is sent\n--error ER_PARSE_ERROR\nset names='foo2'|\n\n--error ER_SP_BAD_VAR_SHADOW\ncreate procedure bug13510_2()\nbegin\n  declare names varchar(10);\n\n  set names = 'foo2';\n  select names;\nend|\n\ncreate procedure bug13510_3()\nbegin\n  declare password varchar(10);\n\n  set `password` = 'foo3';\n  select password;\nend|\n\ncreate procedure bug13510_4()\nbegin\n  declare names varchar(10);\n\n  set `names` = 'foo4';\n  select names;\nend|\n\ncall bug13510_3()|\ncall bug13510_4()|\n\ndrop procedure bug13510_3|\ndrop procedure bug13510_4|\n\n\n#\n# Test that statements which implicitly commit transaction are prohibited\n# in stored function and triggers. Attempt to create function or trigger\n# containing such statement should produce error (includes test for\n# bug #13627).\n#\n--disable_warnings\ndrop function if exists bug_13627_f|\n--enable_warnings\n\nCREATE TABLE t1 (a int)|\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN DROP TRIGGER test1; END |\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE FUNCTION bug_13627_f() returns int BEGIN DROP TRIGGER test1; return 1; END |\n\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN create table t2 (a int); END |\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE FUNCTION bug_13627_f() returns int BEGIN create table t2 (a int); return 1; END |\n\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN create index t1_i on t1 (a); END |\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE FUNCTION bug_13627_f() returns int BEGIN create index t1_i on t1 (a); return 1; END |\n\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN alter table t1 add column  b int; END |\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE FUNCTION bug_13627_f() returns int BEGIN alter table t1 add column  b int; return 1; END |\n\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN rename table t1 to t2; END |\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE FUNCTION bug_13627_f() returns int BEGIN rename table t1 to t2; return 1; END |\n\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN truncate table t1; END |\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE FUNCTION bug_13627_f() returns int BEGIN truncate table t1; return 1; END |\n\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN drop table t1; END |\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE FUNCTION bug_13627_f() returns int BEGIN drop table t1; return 1; END |\n\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN drop index t1_i on t1; END |\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE FUNCTION bug_13627_f() returns int BEGIN drop index t1_i on t1; return 1; END |\n\n-- error ER_SP_BADSTATEMENT\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN unlock tables; END |\n-- error ER_SP_BADSTATEMENT\nCREATE FUNCTION bug_13627_f() returns int BEGIN unlock tables; return 1; END |\n\n-- error ER_SP_BADSTATEMENT\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN LOCK TABLE t1 READ; END |\n-- error ER_SP_BADSTATEMENT\nCREATE FUNCTION bug_13627_f() returns int BEGIN LOCK TABLE t1 READ; return 1; END |\n\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN create database mysqltest; END |\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE FUNCTION bug_13627_f() returns int BEGIN create database mysqltest; return 1; END |\n\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN drop database mysqltest; END |\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE FUNCTION bug_13627_f() returns int BEGIN drop database mysqltest; return 1; END |\n\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN create user 'mysqltest_1'; END |\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE FUNCTION bug_13627_f() returns int BEGIN create user 'mysqltest_1'; return 1; END |\n\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE TRIGGER bug21975 BEFORE INSERT ON t1 FOR EACH ROW BEGIN grant select on t1 to 'mysqltest_1'; END |\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE FUNCTION bug21975() returns int BEGIN grant select on t1 to 'mysqltest_1'; return 1; END |\n\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE TRIGGER bug21975 BEFORE INSERT ON t1 FOR EACH ROW BEGIN revoke select on t1 from 'mysqltest_1'; END |\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE FUNCTION bug21975() returns int BEGIN revoke select on t1 from 'mysqltest_1'; return 1; END |\n\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE TRIGGER bug21975 BEFORE INSERT ON t1 FOR EACH ROW BEGIN revoke all privileges on *.* from 'mysqltest_1'; END |\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE FUNCTION bug21975() returns int BEGIN revoke all privileges on *.* from 'mysqltest_1'; return 1; END |\n\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN drop user 'mysqltest_1'; END |\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE FUNCTION bug_13627_f() returns int BEGIN drop user 'mysqltest_1'; return 1; END |\n\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN rename user 'mysqltest_2' to 'mysqltest_1'; END |\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE FUNCTION bug_13627_f() returns int BEGIN rename user 'mysqltest_2' to 'mysqltest_1'; return 1; END |\n\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN create view v1 as select 1; END |\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE FUNCTION bug_13627_f() returns int BEGIN create view v1 as select 1; return 1; END |\n\n-- error ER_SP_BADSTATEMENT\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN alter view v1 as select 1; END |\n-- error ER_SP_BADSTATEMENT\nCREATE FUNCTION bug_13627_f() returns int BEGIN alter view v1 as select 1; return 1; END |\n\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN drop view v1; END |\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE FUNCTION bug_13627_f() returns int BEGIN drop view v1; return 1; END |\n\n-- error ER_SP_NO_RECURSIVE_CREATE\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN create trigger tr2 before insert on t1 for each row do select 1; END |\n-- error ER_SP_NO_RECURSIVE_CREATE\nCREATE FUNCTION bug_13627_f() returns int BEGIN create trigger tr2 before insert on t1 for each row do select 1; return 1; END |\n\n-- error ER_SP_NO_DROP_SP\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN drop function bug_13627_f; END |\n-- error ER_SP_NO_DROP_SP\nCREATE FUNCTION bug_13627_f() returns int BEGIN drop function bug_13627_f; return 1; END |\n\n-- error ER_SP_NO_RECURSIVE_CREATE\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN create function f2 () returns int return 1; END |\n-- error ER_SP_NO_RECURSIVE_CREATE\nCREATE FUNCTION bug_13627_f() returns int BEGIN create function f2 () returns int return 1; return 1; END |\n\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW\n  BEGIN\n    CREATE TEMPORARY TABLE t2 (a int);\n    DROP TEMPORARY TABLE t2;\n  END |\nCREATE FUNCTION bug_13627_f() returns int\n  BEGIN\n    CREATE TEMPORARY TABLE t2 (a int);\n    DROP TEMPORARY TABLE t2;\n    return 1;\n  END |\n\ndrop table t1|\ndrop function bug_13627_f|\n\ndelimiter ;|\n\n# BUG#12329: \"Bogus error msg when executing PS with stored procedure after\n# SP was re-created\". See also test for related bug#13399 in trigger.test\ndrop function if exists bug12329;\n--enable_warnings\ncreate table t1 as select 1 a;\ncreate table t2 as select 1 a;\ncreate function bug12329() returns int return (select a from t1);\nprepare stmt1 from 'select bug12329()';\nexecute stmt1;\ndrop function bug12329;\ncreate function bug12329() returns int return (select a+100 from t2);\nselect bug12329();\nexecute stmt1;\ndeallocate prepare stmt1;\ndrop function bug12329; \ndrop table t1, t2;\n\n#\n# Bug#13514 \"server crash when create a stored procedure before choose a\n# database\" and\n# Bug#13587 \"Server crash when SP is created without database\n# selected\"\n#\ncreate database mysqltest1;\nuse mysqltest1;\ndrop database mysqltest1;\n--error ER_NO_DB_ERROR \ncreate function f1() returns int return 1;\ndelimiter |;\n--error ER_NO_DB_ERROR \ncreate procedure p1(out param1 int)\nbegin\n  select count(*) into param1 from t3;\nend|\ndelimiter ;|\nuse test;\n\n\n#\n# BUG#13037: undefined variable in IF cause erroneous error-message\n#\n\n--disable_warnings\nDROP PROCEDURE IF EXISTS bug13037_p1;\nDROP PROCEDURE IF EXISTS bug13037_p2;\nDROP PROCEDURE IF EXISTS bug13037_p3;\n--enable_warnings\n\ndelimiter |;\n\n--error ER_BAD_FIELD_ERROR\nCREATE PROCEDURE bug13037_p1()\nBEGIN\n  IF bug13037_foo THEN\n    SELECT 1;\n  END IF;\nEND|\n\nCREATE PROCEDURE bug13037_p2()\nBEGIN\n  SET @bug13037_foo = bug13037_bar;\nEND|\n\nCREATE PROCEDURE bug13037_p3()\nBEGIN\n  SELECT bug13037_foo;\nEND|\n\ndelimiter ;|\n\n--echo\n\n--error 1054\nCALL bug13037_p2();\n--error 1054\nCALL bug13037_p3();\n\n--error 1054\nCALL bug13037_p2();\n--error 1054\nCALL bug13037_p3();\n\nDROP PROCEDURE bug13037_p2;\nDROP PROCEDURE bug13037_p3;\n\n#\n# Bug#14569 \"editing a stored procedure kills mysqld-nt\"\n#\ncreate database mysqltest1;\ncreate database mysqltest2;\nuse mysqltest1;\ndrop database mysqltest1;\ncreate procedure mysqltest2.p1() select version();\n--error ER_NO_DB_ERROR \ncreate procedure p2() select version();\nuse mysqltest2;\n--replace_column 5 '0000-00-00 00:00:00' 6 '0000-00-00 00:00:00'\nshow procedure status;\ndrop database mysqltest2;\nuse test;\n\n#\n# Bug#13012 \"SP: REPAIR/BACKUP/RESTORE TABLE crashes the server\"\n#\ndelimiter |;\n--disable_warnings\nDROP FUNCTION IF EXISTS bug13012|\n--enable_warnings\n--error ER_SP_NO_RETSET\nCREATE FUNCTION bug13012() RETURNS INT\nBEGIN\n  REPAIR TABLE t1;\n  RETURN 1;\nEND|\ncreate table t1 (a int)|\nCREATE PROCEDURE bug13012_1() REPAIR TABLE t1|\nCREATE FUNCTION bug13012_2() RETURNS INT\nBEGIN\n  CALL bug13012_1();\n  RETURN 1;\nEND|\n--error ER_SP_NO_RETSET\nSELECT bug13012_2()|\ndrop table t1|\ndrop procedure bug13012_1|\ndrop function bug13012_2|\ndelimiter ;|\n\n#\n# BUG#11555 \"Stored procedures: current SP tables locking make \n# impossible view security\". We should not expose names of tables\n# which are implicitly used by view (via stored routines/triggers).\n#\n# Note that SQL standard assumes that you simply won't be able drop table\n# and leave some objects (routines/views/triggers) which were depending on\n# it. Such objects should be dropped in advance (by default) or will be\n# dropped simultaneously with table (DROP TABLE with CASCADE clause).\n# So these tests probably should go away once we will implement standard\n# behavior.\n--disable_warnings\ndrop function if exists bug11555_1;\ndrop function if exists bug11555_2;\ndrop view if exists v1, v2, v3, v4;\n--enable_warnings\ncreate function bug11555_1() returns int return (select max(i) from t1);\ncreate function bug11555_2() returns int return bug11555_1();\n# It is OK to report name of implicitly used table which is missing\n# when we create view.\n# For stored functions however, because of exceptions handlers, there is\n# no easy way to find out if a missing table makes the view invalid.\ncreate view v1 as select bug11555_1();\ndrop view v1;\ncreate view v2 as select bug11555_2();\ndrop view v2;\n# But we should hide name of missing implicitly used table when we use view\ncreate table t1 (i int);\ncreate view v1 as select bug11555_1();\ncreate view v2 as select bug11555_2();\ncreate view v3 as select * from v1;\ndrop table t1;\n--error ER_VIEW_INVALID\nselect * from v1;\n--error ER_VIEW_INVALID\nselect * from v2;\n--error ER_VIEW_INVALID\nselect * from v3;\n# Note that creation of view which depends on broken view is yet \n# another form of view usage.\ncreate view v4 as select * from v1;\ndrop view v1, v2, v3, v4;\n# We also should hide details about broken triggers which are\n# invoked for view.\ndrop function bug11555_1;\ndrop function bug11555_2;\ncreate table t1 (i int);\ncreate table t2 (i int);\ncreate trigger t1_ai after insert on t1 for each row insert into t2 values (new.i);\ncreate view v1 as select * from t1;\ndrop table t2;\n# Limitation, the desired error is ER_VIEW_INVALID\n--error ER_NO_SUCH_TABLE\ninsert into v1 values (1);\ndrop trigger t1_ai;\ncreate function bug11555_1() returns int return (select max(i) from t2);\ncreate trigger t1_ai after insert on t1 for each row set @a:=bug11555_1();\n# Limitation, the desired error is ER_VIEW_INVALID\n--error ER_NO_SUCH_TABLE \ninsert into v1 values (2);\ndrop function bug11555_1;\ndrop table t1;\ndrop view v1;\n\n#\n# BUG#15658: Server crashes after creating function as empty string\n#\n--disable_warnings\ndrop procedure if exists ` bug15658`;\n--enable_warnings\n\n--error ER_SP_WRONG_NAME\ncreate procedure ``() select 1;\n--error ER_SP_WRONG_NAME\ncreate procedure ` `() select 1;\n--error ER_SP_WRONG_NAME\ncreate procedure `bug15658 `() select 1;\n--error ER_WRONG_DB_NAME\ncreate procedure ``.bug15658() select 1;\n--error ER_WRONG_DB_NAME\ncreate procedure `x `.bug15658() select 1;\n\n# This should work\ncreate procedure ` bug15658`() select 1;\ncall ` bug15658`();\n--replace_column 5 '0000-00-00 00:00:00' 6 '0000-00-00 00:00:00'\nshow procedure status;\ndrop procedure ` bug15658`;\n\n\n#\n# BUG#14270: Stored procedures: crash if load index\n#\n--disable_warnings\ndrop function if exists bug14270;\ndrop table if exists t1;\n--enable_warnings\n\ncreate table t1 (s1 int primary key);\n\ndelimiter |;\n--error ER_SP_NO_RETSET\ncreate function bug14270() returns int\nbegin\n  load index into cache t1;\n  return 1;\nend|\n\n--error ER_SP_NO_RETSET\ncreate function bug14270() returns int\nbegin\n  cache index t1 key (`primary`) in keycache1;\n  return 1;\nend|\ndelimiter ;|\n\ndrop table t1;\n\n\n#\n# BUG#15091: Sp Returns Unknown error in order clause....and \n#            there is no order by clause\n#\n--disable_warnings\ndrop procedure if exists bug15091;\n--enable_warnings\n\ndelimiter |;\ncreate procedure bug15091()\nbegin\n  declare selectstr varchar(6000) default ' ';\n  declare conditionstr varchar(5000)  default '';\n\n  set selectstr = concat(selectstr,\n                         ' and ',\n                         c.operatorid,\n                         'in (',conditionstr, ')');\nend|\ndelimiter ;|\n\n# The error message used to be:\n#   ERROR 1109 (42S02): Unknown table 'c' in order clause\n# but is now rephrased to something less misleading:\n#   ERROR 1109 (42S02): Unknown table 'c' in field list\n--error ER_UNKNOWN_TABLE\ncall bug15091();\n\ndrop procedure bug15091;\n\n\n#\n# BUG#16896: Stored function: unused AGGREGATE-clause in CREATE FUNCTION\n#\n--disable_warnings\ndrop function if exists bug16896;\n--enable_warnings\n\n--error ER_INVALID_AGGREGATE_FUNCTION\ncreate aggregate function bug16896() returns int return 1;\n\n#\n#\n# BUG#14702: misleading error message when syntax error in CREATE\n# PROCEDURE\n#\n# Misleading error message was given when IF NOT EXISTS was used in\n# CREATE PROCEDURE.\n#\n--disable_warnings\nDROP PROCEDURE IF EXISTS bug14702;\n--enable_warnings\n\n--error ER_PARSE_ERROR\nCREATE IF NOT EXISTS PROCEDURE bug14702()\nBEGIN\nEND;\n\nCREATE PROCEDURE IF NOT EXISTS bug14702()\nBEGIN\nEND;\nDROP PROCEDURE IF EXISTS bug14702;\n\n#\n# BUG#20953: create proc with a create view that uses local\n# vars/params should fail to create\n#\n# See test case for what syntax is forbidden in a view.\n#\n--disable_warnings\nDROP TABLE IF EXISTS t1;\n--enable_warnings\n\nCREATE TABLE t1 (i INT);\n\n# We do not have to drop this procedure and view because they won't be\n# created.\n--error ER_PARSE_ERROR\nCREATE PROCEDURE bug20953() CREATE VIEW v AS SELECT 1 INTO @a;\n--error ER_PARSE_ERROR\nCREATE PROCEDURE bug20953() CREATE VIEW v AS SELECT 1 INTO DUMPFILE \"file\";\n--error ER_PARSE_ERROR\nCREATE PROCEDURE bug20953() CREATE VIEW v AS SELECT 1 INTO OUTFILE \"file\";\n--error ER_PARSE_ERROR\nCREATE PROCEDURE bug20953()\n  CREATE VIEW v AS SELECT i FROM t1 PROCEDURE ANALYSE();\n--error ER_PARSE_ERROR\nCREATE PROCEDURE bug20953() CREATE VIEW v AS SELECT 1 FROM (SELECT 1) AS d1 into @w;\n--error ER_VIEW_SELECT_VARIABLE\nCREATE PROCEDURE bug20953(i INT) CREATE VIEW v AS SELECT i;\ndelimiter |;\n--error ER_VIEW_SELECT_VARIABLE\nCREATE PROCEDURE bug20953()\nBEGIN\n  DECLARE i INT;\n  CREATE VIEW v AS SELECT i;\nEND |\ndelimiter ;|\n--error ER_VIEW_SELECT_VARIABLE\nPREPARE stmt FROM \"CREATE VIEW v AS SELECT ?\";\n\nDROP TABLE t1;\n\n\n#\n# BUG#24491 \"using alias from source table in insert ... on duplicate key\"\n#\n--disable_warnings\ndrop tables if exists t1;\ndrop procedure if exists bug24491;\n--enable_warnings\ncreate table t1 (id int primary key auto_increment, value varchar(10));\ninsert into t1 (id, value) values (1, 'FIRST'), (2, 'SECOND'), (3, 'THIRD');\n# Let us create routine with INSERT ... SELECT ... ON DUPLICATE KEY UPDATE \n# statement which in its ON DUPLICATE KEY clause erroneously tries to assign\n# value to a column which is mentioned only in SELECT part.\ncreate procedure bug24491()\n  insert into t1 (id, value) select * from (select 4 as i, 'FOURTH' as v) as y on duplicate key update v = 'DUP';\n# Both first and second calls to it should fail\n--error ER_BAD_FIELD_ERROR \ncall bug24491();\n--error ER_BAD_FIELD_ERROR\ncall bug24491();\ndrop procedure bug24491;\n# And now the same test for more complex case which is more close\n# to the one that was reported originally.\ncreate procedure bug24491()\n  insert into t1 (id, value) select * from (select 4 as id, 'FOURTH' as value) as y on duplicate key update y.value = 'DUP';\n--error ER_BAD_FIELD_ERROR \ncall bug24491();\n--error ER_BAD_FIELD_ERROR\ncall bug24491();\ndrop procedure bug24491;\ndrop tables t1;\n\n#\n# BUG#18914: Calling certain SPs from triggers fail\n#\n# Failing to call a procedure that does implicit commit from a trigger\n# is a correct behaviour, however the error message was misleading.\n#\n# DROP TABLE IF EXISTS is also fixed to give correct error instead of\n# \"Table doesn't exist\". \n#\n--disable_warnings\nDROP FUNCTION IF EXISTS bug18914_f1;\nDROP FUNCTION IF EXISTS bug18914_f2;\nDROP PROCEDURE IF EXISTS bug18914_p1;\nDROP PROCEDURE IF EXISTS bug18914_p2;\nDROP TABLE IF EXISTS t1, t2;\n--enable_warnings\n\nCREATE TABLE t1 (i INT);\n\nCREATE PROCEDURE bug18914_p1() CREATE TABLE t2 (i INT);\nCREATE PROCEDURE bug18914_p2() DROP TABLE IF EXISTS no_such_table;\n\ndelimiter |;\nCREATE FUNCTION bug18914_f1() RETURNS INT\nBEGIN\n  CALL bug18914_p1();\n  RETURN 1;\nEND |\n\nCREATE FUNCTION bug18914_f2() RETURNS INT\nBEGIN\n  CALL bug18914_p2();\n  RETURN 1;\nEND |\ndelimiter ;|\n\nCREATE TRIGGER t1_bi BEFORE INSERT ON t1 FOR EACH ROW\n  CALL bug18914_p1();\n\n--error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nINSERT INTO t1 VALUES (1);\n\n--error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nSELECT bug18914_f1();\n\n--error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nSELECT bug18914_f2();\n\n--error ER_NO_SUCH_TABLE\nSELECT * FROM t2;\n\nDROP FUNCTION bug18914_f1;\nDROP FUNCTION bug18914_f2;\nDROP PROCEDURE bug18914_p1;\nDROP PROCEDURE bug18914_p2;\nDROP TABLE t1;\n\n#\n# Bug#20713 (Functions will not not continue for SQLSTATE VALUE '42S02')\n#\n\n--disable_warnings\ndrop table if exists bogus_table_20713;\ndrop function if exists func_20713_a;\ndrop function if exists func_20713_b;\n--enable_warnings\n\ncreate table bogus_table_20713( id int(10) not null primary key);\ninsert into bogus_table_20713 values (1), (2), (3);\n\ndelimiter //;\n\ncreate function func_20713_a() returns int(11)\nbegin\n  declare id int;\n\n  declare continue handler for sqlexception set id=null;\n\n  set @in_func := 1;\n  set id = (select id from bogus_table_20713 where id = 3);\n  set @in_func := 2;\n\n  return id;\nend//\n\ncreate function func_20713_b() returns int(11)\nbegin\n  declare id int;\n\n  declare continue handler for sqlstate value '42S02' set id=null;\n\n  set @in_func := 1;\n  set id = (select id from bogus_table_20713 where id = 3);\n  set @in_func := 2;\n\n  return id;\nend//\n\ndelimiter ;//\n\nset @in_func := 0;\nselect func_20713_a();\nselect @in_func;\n\nset @in_func := 0;\nselect func_20713_b();\nselect @in_func;\n\ndrop table bogus_table_20713;\n\nset @in_func := 0;\nselect func_20713_a();\nselect @in_func;\n\nset @in_func := 0;\nselect func_20713_b();\nselect @in_func;\n\ndrop function if exists func_20713_a;\ndrop function if exists func_20713_b;\n\n#\n# Bug#25345 (Cursors from Functions)\n#\n\n--disable_warnings\ndrop table if exists table_25345_a;\ndrop table if exists table_25345_b;\ndrop procedure if exists proc_25345;\ndrop function if exists func_25345;\ndrop function if exists func_25345_b;\n--enable_warnings\n\ncreate table table_25345_a (a int);\ncreate table table_25345_b (b int);\n\ndelimiter ||;\n\ncreate procedure proc_25345()\nbegin\n  declare c1 cursor for select a from table_25345_a;\n  declare c2 cursor for select b from table_25345_b;\n\n  select 1 as result;\nend ||\n\ncreate function func_25345() returns int(11)\nbegin\n  call proc_25345();\n  return 1;\nend ||\n\ncreate function func_25345_b() returns int(11)\nbegin\n  declare c1 cursor for select a from table_25345_a;\n  declare c2 cursor for select b from table_25345_b;\n\n  return 1;\nend ||\n\ndelimiter ;||\n\ncall proc_25345();\n--error ER_SP_NO_RETSET\nselect func_25345();\nselect func_25345_b();\n\ndrop table table_25345_a;\n\ncall proc_25345();\n--error ER_SP_NO_RETSET\nselect func_25345();\nselect func_25345_b();\n\ndrop table table_25345_b;\ndrop procedure proc_25345;\ndrop function func_25345;\ndrop function func_25345_b;\n\n#\n# End of 5.0 tests\n#\n--echo End of 5.0 tests\n\n#\n# Bug#16164 \"Easter egg\": check that SHOW AUTHORS is disabled in\n# stored functions/triggers\n#\n--disable_warnings\ndrop function if exists bug16164;\n--enable_warnings\ndelimiter |;\n--error ER_SP_NO_RETSET\ncreate function bug16164() returns int\nbegin\n  show authors;\n  return 42;\nend|\ndelimiter ;|\n\n\n#\n# BUG#20701: BINARY keyword should be forbidden in stored routines\n#\n--disable_warnings\ndrop function if exists bug20701;\n--enable_warnings\ncreate function bug20701() returns varchar(25) binary return \"test\";\ndrop function bug20701;\ncreate function bug20701() returns varchar(25) return \"test\";\ndrop function bug20701;\n\n#\n# Bug#26503 (Illegal SQL exception handler code causes the server to crash)\n#\n\ndelimiter //;\n\n--error ER_SP_LILABEL_MISMATCH\ncreate procedure proc_26503_error_1()\nbegin\nretry:\n  repeat\n    begin\n      declare continue handler for sqlexception\n      begin\n        iterate retry;\n      end\n\n      select \"do something\";\n    end\n  until true end repeat retry;\nend//\n\n--error ER_SP_LILABEL_MISMATCH\ncreate procedure proc_26503_error_2()\nbegin\nretry:\n  repeat\n    begin\n      declare continue handler for sqlexception\n        iterate retry;\n\n      select \"do something\";\n    end\n  until true end repeat retry;\nend//\n\n--error ER_SP_LILABEL_MISMATCH\ncreate procedure proc_26503_error_3()\nbegin\nretry:\n  repeat\n    begin\n      declare continue handler for sqlexception\n      begin\n        leave retry;\n      end\n\n      select \"do something\";\n    end\n  until true end repeat retry;\nend//\n\n--error ER_SP_LILABEL_MISMATCH\ncreate procedure proc_26503_error_4()\nbegin\nretry:\n  repeat\n    begin\n      declare continue handler for sqlexception\n        leave retry;\n\n      select \"do something\";\n    end\n  until true end repeat retry;\nend//\n\ndelimiter ;//\n\n\n#\n# Bug#28360 (RENAME DATABASE destroys routines)\n#\n\n--disable_warnings\ndrop procedure if exists proc_28360;\ndrop function if exists func_28360;\n--enable_warnings\n\ndelimiter //;\n\n--error ER_SP_NO_DROP_SP\nCREATE PROCEDURE proc_28360()\nBEGIN\n  ALTER DATABASE `#mysql50#upgrade-me` UPGRADE DATA DIRECTORY NAME;\nEND//\n\n--error ER_SP_NO_DROP_SP\nCREATE FUNCTION func_28360() RETURNS int\nBEGIN\n  ALTER DATABASE `#mysql50#upgrade-me` UPGRADE DATA DIRECTORY NAME;\n  RETURN 0;\nEND//\n\ndelimiter ;//\n\n\n#\n# Bug#29223 declare cursor c for SHOW .....\n#\n\n--disable_warnings\nDROP PROCEDURE IF EXISTS p1;\n--enable_warnings\n--delimiter |\n--error ER_PARSE_ERROR\nCREATE PROCEDURE p1()\nBEGIN\n  DECLARE c char(100);\n  DECLARE cur1 CURSOR FOR SHOW TABLES;\n\n  OPEN cur1;\n  FETCH cur1 INTO c;\n  select c;\n  CLOSE cur1;\nEND|\n--delimiter ;\n\n#\n# Bug#29816 Syntactically wrong query fails with misleading error message\n#\n\n--disable_warnings\nDROP DATABASE IF EXISTS mysqltest;\n--enable_warnings\nCREATE DATABASE mysqltest;\nUSE mysqltest;\nDROP DATABASE mysqltest;\n# Both ER_SP_DOES_NOT_EXIST and ER_PARSE_ERROR are valid here,\n# the result is implementation dependent:\n# See Bug#29816 for details\n--error ER_SP_DOES_NOT_EXIST\nSELECT inexistent(), 1 + ,;\n--error ER_SP_DOES_NOT_EXIST\nSELECT inexistent();\n--error ER_PARSE_ERROR\nSELECT .inexistent();\n--error ER_PARSE_ERROR\nSELECT ..inexistent();\nUSE test;\n\n#\n# Bug#30904 SET PASSWORD statement is non-transactional\n#\n\ndelimiter |;\n\n--error ER_SP_CANT_SET_AUTOCOMMIT\ncreate function f1() returns int\nbegin\n  set @test = 1, password = password('foo');\n  return 1;\nend|\n\n--error ER_SP_CANT_SET_AUTOCOMMIT\ncreate trigger t1\n  before insert on t2 for each row set password = password('foo');|\n\ndelimiter ;|\n\n#\n# Bug#30882 Dropping a temporary table inside a stored function may cause a server crash\n#\n\n--disable_warnings\ndrop function if exists f1;\ndrop function if exists f2;\ndrop table if exists t1, t2;\n--enable_warnings\n\ndelimiter |;\ncreate function f1() returns int\nbegin\n drop temporary table t1;\n return 1;\nend|\ndelimiter ;|\n--error ER_BAD_TABLE_ERROR\ncreate temporary table t1 as select f1();\n\ndelimiter |;\ncreate function f2() returns int\nbegin\n create temporary table t2 as select f1();\n return 1;\nend|\ndelimiter ;|\n--error ER_BAD_TABLE_ERROR\ncreate temporary table t1 as select f2();\n\ndrop function f1;\ndrop function f2;\n\ndelimiter |;\ncreate function f1() returns int\nbegin\n drop temporary table t2,t1;\n return 1;\nend|\ncreate function f2() returns int\nbegin\n create temporary table t2 as select f1();\n return 1;\nend|\ndelimiter ;|\n--error ER_BAD_TABLE_ERROR\ncreate temporary table t1 as select f2();\n\ndrop function f1;\ndrop function f2;\n\ncreate temporary table t2(a int);\nselect * from t2;\ndelimiter |;\ncreate function f2() returns int\nbegin\n drop temporary table t2;\n return 1;\nend|\ndelimiter ;|\nselect f2();\n\ndrop function f2;\n--error ER_BAD_TABLE_ERROR\ndrop table t2;\n\n--echo End of 5.1 tests\n\n#\n# Bug#33983 (Stored Procedures: wrong end <label> syntax is accepted)\n#\n\n--disable_warnings\ndrop procedure if exists proc_33983_a;\ndrop procedure if exists proc_33983_b;\ndrop procedure if exists proc_33983_c;\ndrop procedure if exists proc_33983_d;\n--enable_warnings\n\ndelimiter |;\n\n--error ER_SP_LABEL_MISMATCH\ncreate procedure proc_33983_a()\nbegin\n  label1:\n    begin\n      label2:\n      begin\n        select 1;\n      end label1;\n    end;\nend|\n\n--error ER_SP_LABEL_MISMATCH\ncreate procedure proc_33983_b()\nbegin\n  label1:\n    repeat\n      label2:\n      repeat\n        select 1;\n      until FALSE end repeat label1;\n    until FALSE end repeat;\nend|\n\n--error ER_SP_LABEL_MISMATCH\ncreate procedure proc_33983_c()\nbegin\n  label1:\n    while TRUE do\n      label2:\n      while TRUE do\n        select 1;\n      end while label1;\n    end while;\nend|\n\n--error ER_SP_LABEL_MISMATCH\ncreate procedure proc_33983_d()\nbegin\n  label1:\n    loop\n      label2:\n      loop\n        select 1;\n      end loop label1;\n    end loop;\nend|\n\nCREATE TABLE t1 (a INT)|\nINSERT INTO t1 VALUES (1),(2)|\nCREATE PROCEDURE p1(a INT) BEGIN END|\n--error ER_SUBQUERY_NO_1_ROW\nCALL p1((SELECT * FROM t1))|\nDROP PROCEDURE IF EXISTS p1|\nDROP TABLE t1|\n\ndelimiter ;|\n\n#\n# Bug#21801: SQL exception handlers and warnings\n#\n\n--disable_warnings\ndrop procedure if exists p1;\n--enable_warnings\ndelimiter |;\ncreate procedure p1()\nbegin\n  create table t1 (a int) engine=MyISAM;\n  drop table t1;\nend|\ndelimiter ;|\ncall p1();\ncall p1();\ndrop procedure p1;\n\n#\n# Bug#8759 (Stored Procedures: SQLSTATE '00000' should be illegal)\n#\n\n--disable_warnings\ndrop procedure if exists proc_8759;\n--enable_warnings\n\ndelimiter $$;\n\n--error ER_SP_BAD_SQLSTATE\ncreate procedure proc_8759()\nbegin\n  declare should_be_illegal condition for sqlstate '00000';\n  declare continue handler for should_be_illegal set @x=0;\nend$$\n\n--error ER_SP_BAD_SQLSTATE\ncreate procedure proc_8759()\nbegin\n  declare continue handler for sqlstate '00000' set @x=0;\nend$$\n\ndelimiter ;$$\n\n#\n# Bug#36510 (Stored Procedures: mysql_error_code 0 should be illegal)\n#\n\n--disable_warnings\ndrop procedure if exists proc_36510;\n--enable_warnings\n\ndelimiter $$;\n\n--error ER_SP_BAD_SQLSTATE\ncreate procedure proc_36510()\nbegin\n  declare should_be_illegal condition for sqlstate '00123';\n  declare continue handler for should_be_illegal set @x=0;\nend$$\n\n--error ER_SP_BAD_SQLSTATE\ncreate procedure proc_36510()\nbegin\n  declare continue handler for sqlstate '00123' set @x=0;\nend$$\n\n--error ER_WRONG_VALUE\ncreate procedure proc_36510()\nbegin\n  declare should_be_illegal condition for 0;\n  declare continue handler for should_be_illegal set @x=0;\nend$$\n\n--error ER_WRONG_VALUE\ncreate procedure proc_36510()\nbegin\n  declare continue handler for 0 set @x=0;\nend$$\ndelimiter ;$$\n\n#\n# Bug#15192: \"fatal errors\" are caught by handlers in stored procedures\n#\n\n--disable_warnings\ndrop procedure if exists p1;\n--enable_warnings\nset @old_recursion_depth = @@max_sp_recursion_depth;\nset @@max_sp_recursion_depth = 255;\ndelimiter |;\ncreate procedure p1(a int)\nbegin\n  declare continue handler for 1436 -- ER_STACK_OVERRUN_NEED_MORE\n    select 'exception';\n  call p1(a+1);\nend|\ndelimiter ;|\n--error 0,ER_STACK_OVERRUN_NEED_MORE,ER_SP_RECURSION_LIMIT\ncall p1(1);\nset @@max_sp_recursion_depth = @old_recursion_depth;\ndrop procedure p1;\n\n#\n# BUG#NNNN: New bug synopsis\n#\n#--disable_warnings\n#drop procedure if exists bugNNNN;\n#drop function if exists bugNNNN;\n#--enable_warnings\n#create procedure bugNNNN...\n#create function bugNNNN...\n\n#\n# CLEANUP and RESTORE\n#\nLOAD DATA INFILE '../../tmp/proc.txt' INTO TABLE mysql.proc;\nremove_file $MYSQLTEST_VARDIR/tmp/proc.txt;\n\n#\n# Bug #38159: Function parsing problem generates misleading error message\n#\n\nCREATE TABLE t1 (a INT, b INT);\nINSERT INTO t1 VALUES (1,1), (2,2);\n--error ER_FUNC_INEXISTENT_NAME_COLLISION\nSELECT MAX (a) FROM t1 WHERE b = 999999;\nSELECT AVG (a) FROM t1 WHERE b = 999999;\n--error ER_SP_DOES_NOT_EXIST\nSELECT non_existent (a) FROM t1 WHERE b = 999999;\nDROP TABLE t1;\n\n\n#\n# Bug #46374 crash, INSERT INTO t1 uses function, function modifies t1\n#\nCREATE TABLE t1 ( f2 INTEGER, f3 INTEGER );\nINSERT INTO t1 VALUES  ( 1, 1 );\n\ndelimiter |;\n\nCREATE FUNCTION func_1 () RETURNS INTEGER\nBEGIN\n  INSERT INTO t1 SELECT * FROM t1 ;\n  RETURN 1 ;\nEND|\n\ndelimiter ;|\n\n# The bug caused the following INSERT statement to trigger\n# an assertion.   Error 1442 is the correct response\n#\n--error 1442\nINSERT INTO t1 SELECT * FROM (SELECT 2 AS f1, 2 AS f2) AS A WHERE func_1() = 5;\n\n# Cleanup\nDROP FUNCTION func_1;\nDROP TABLE t1;\n\n\n\n--echo #\n--echo # Bug #47788: Crash in TABLE_LIST::hide_view_error on UPDATE + VIEW + \n--echo #   SP + MERGE + ALTER\n--echo #\n\nCREATE TABLE t1 (pk INT, b INT, KEY (b));\nCREATE ALGORITHM = TEMPTABLE VIEW v1 AS SELECT * FROM t1;\n\nCREATE PROCEDURE p1 (a int) UPDATE IGNORE v1 SET b = a; \n\n--error ER_NON_UPDATABLE_TABLE\nCALL p1(5);\n\nALTER TABLE t1 CHANGE COLUMN b b2 INT;\n\n--error ER_VIEW_INVALID\nCALL p1(7);\n\nDROP PROCEDURE p1;\nDROP VIEW v1;\nDROP TABLE t1;\n\n--echo #\n--echo # Bug#12428824 - PARSER STACK OVERFLOW AND CRASH IN SP_ADD_USED_ROUTINE\n--echo #                WITH OBSCURE QUERY\n--echo #\n\n--error ER_TOO_LONG_IDENT\nSELECT very_long_fn_name_1111111111111111111111111111111111111111111111111111111111111111111111111222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222225555555555555555555555555577777777777777777777777777777777777777777777777777777777777777777777777788888888999999999999999999999();\n\n--error ER_TOO_LONG_IDENT\nCALL very_long_pr_name_1111111111111111111111111111111111111111111111111111111111111111111111111222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222225555555555555555555555555577777777777777777777777777777777777777777777777777777777777777777777777788888888999999999999999999999();\n\n--error ER_WRONG_DB_NAME\nSELECT very_long_db_name_1111111111111111111111111111111111111111111111111111111111111111111111111222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222225555555555555555555555555577777777777777777777777777777777777777777777777777777777777777777777777788888888999999999999999999999.simple_func();\n\n--error ER_WRONG_DB_NAME\nCALL very_long_db_name_1111111111111111111111111111111111111111111111111111111111111111111111111222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222225555555555555555555555555577777777777777777777777777777777777777777777777777777777777777777777777788888888999999999999999999999.simple_proc();\n\n--error ER_TOO_LONG_IDENT\nSELECT db_name.very_long_fn_name_111111111111111111111111111111111111111111111111111111111111111111111111122222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999999999999999999();\n\n--error ER_TOO_LONG_IDENT\nCALL db_name.very_long_pr_name_111111111111111111111111111111111111111111111111111111111111111111111111122222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999999999999999999();\n--echo End of 5.1 tests\n\n--echo #\n--echo # Bug#23032: Handlers declared in a SP do not handle warnings generated in sub-SP\n--echo #\n\n--echo\n--echo # - Case 1\n--echo\n\n--disable_warnings\nDROP PROCEDURE IF EXISTS p1;\nDROP PROCEDURE IF EXISTS p2;\nDROP PROCEDURE IF EXISTS p3;\nDROP PROCEDURE IF EXISTS p4;\nDROP PROCEDURE IF EXISTS p5;\nDROP PROCEDURE IF EXISTS p6;\n--enable_warnings\n\ndelimiter |;\n\nCREATE PROCEDURE p1()\n  BEGIN\n    SELECT CAST('10 ' as unsigned integer);\n    SELECT 1;\n    CALL p2();\n  END|\n\nCREATE PROCEDURE p2()\n  BEGIN\n    SELECT CAST('10 ' as unsigned integer);\n  END|\n\ndelimiter ;|\n\nCALL p1();\n\nDROP PROCEDURE p1;\nDROP PROCEDURE p2;\n\n--echo\n--echo # - Case 2\n--echo\n\ndelimiter |;\n\nCREATE PROCEDURE p1()\n  BEGIN\n    DECLARE c INT DEFAULT 0;\n    DECLARE CONTINUE HANDLER FOR SQLSTATE '22007' SET c = c + 1;\n    CALL p2();\n    CALL p3();\n    CALL p4();\n    SELECT c;\n    SELECT @@warning_count;\n    SHOW WARNINGS;\n  END|\n\nCREATE PROCEDURE p2()\n  BEGIN\n    SELECT CAST('10 ' as unsigned integer);\n  END|\n\nCREATE PROCEDURE p3()\n  BEGIN\n    SELECT CAST('10 ' as unsigned integer);\n    SELECT 1;\n  END|\n\nCREATE PROCEDURE p4()\n  BEGIN\n    SELECT CAST('10 ' as unsigned integer);\n    CALL p2();\n  END|\n\nCREATE PROCEDURE p5()\n  BEGIN\n    SELECT CAST('10 ' as unsigned integer);\n    SHOW WARNINGS;\n  END|\n\nCREATE PROCEDURE P6()\n  BEGIN\n    DECLARE c INT DEFAULT 0;\n    DECLARE CONTINUE HANDLER FOR SQLSTATE '22007' SET c = c + 1;\n    CALL p5();\n    SELECT c;\n  END|\n\ndelimiter ;|\n\nCALL p1();\nCALL p6();\n\nDROP PROCEDURE p1;\nDROP PROCEDURE p2;\nDROP PROCEDURE p3;\nDROP PROCEDURE p4;\nDROP PROCEDURE p5;\nDROP PROCEDURE p6;\n\n--echo\n--echo # - Case 3: check that \"Exception trumps No Data\".\n--echo\n\n--disable_warnings\nDROP TABLE IF EXISTS t1;\n--enable_warnings\n\nCREATE TABLE t1(a INT);\nINSERT INTO t1 VALUES (1), (2), (3);\n\ndelimiter |;\n\nCREATE PROCEDURE p1()\nBEGIN\n  DECLARE c CURSOR FOR SELECT a FROM t1;\n\n  OPEN c;\n  \n  BEGIN\n    DECLARE v1 INT;\n    DECLARE v2 INT;\n\n    DECLARE EXIT HANDLER FOR SQLEXCEPTION\n      SELECT \"Error caught (expected)\";\n\n    DECLARE EXIT HANDLER FOR NOT FOUND\n      SELECT \"End of Result Set found!\";\n\n    WHILE TRUE DO\n      FETCH c INTO v1, v2;\n    END WHILE;\n  END;\n\n  CLOSE c;\n\n  SELECT a INTO @foo FROM t1 LIMIT 1; # Clear warning stack\nEND|\n\ndelimiter ;|\n\nCALL p1();\n\nDROP PROCEDURE p1;\nDROP TABLE t1;\n\n--echo #\n--echo # Bug#36185: Incorrect precedence for warning and exception handlers\n--echo #\n\n--disable_warnings\nDROP TABLE IF EXISTS t1;\nDROP PROCEDURE IF EXISTS p1;\n--enable_warnings\n\nCREATE TABLE t1 (a INT, b INT NOT NULL);\n\ndelimiter |;\n\nCREATE PROCEDURE p1()\nBEGIN\n  DECLARE CONTINUE HANDLER FOR SQLWARNING SELECT 'warning';\n  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SELECT 'exception';\n  INSERT INTO t1 VALUES (CAST('10 ' AS SIGNED), NULL);\nEND|\n\ndelimiter ;|\n\nCALL p1();\n\nDROP TABLE t1;\nDROP PROCEDURE p1;\n\n--echo #\n--echo # Bug#5889: Exit handler for a warning doesn't hide the warning in trigger\n--echo #\nSET sql_mode = 'NO_ENGINE_SUBSTITUTION';\nCREATE TABLE t1(a INT, b INT);\nINSERT INTO t1 VALUES (1, 2);\n\ndelimiter |;\n\nCREATE TRIGGER t1_bu BEFORE UPDATE ON t1 FOR EACH ROW\nBEGIN\n  DECLARE EXIT HANDLER FOR SQLWARNING\n    SET NEW.a = 10;\n\n  SET NEW.a = 99999999999;\nEND|\n\ndelimiter ;|\n\nUPDATE t1 SET b = 20;\n\nSHOW WARNINGS;\n\nSELECT * FROM t1;\n\nDROP TRIGGER t1_bu;\nDROP TABLE t1;\nSET sql_mode = DEFAULT;\n\n--echo #\n--echo # Bug#9857: Stored procedures: handler for sqlwarning ignored\n--echo #\n\nSET @sql_mode_saved = @@sql_mode;\nSET sql_mode = traditional;\n\ndelimiter |;\n\nCREATE PROCEDURE p1()\nBEGIN\n  DECLARE CONTINUE HANDLER FOR SQLWARNING\n    SELECT 'warning caught (expected)';\n  \n  SELECT 5 / 0;\nEND|\n\nCREATE PROCEDURE p2()\nBEGIN\n  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION\n    SELECT 'error caught (unexpected)';\n  \n  SELECT 5 / 0;\nEND|\n\ndelimiter ;|\n\nCALL p1();\nSHOW WARNINGS;\n\nCALL p2();\nSHOW WARNINGS;\n\nDROP PROCEDURE p1;\nDROP PROCEDURE p2;\nSET sql_mode = @sql_mode_saved;\n\n--echo #\n--echo # Bug#55850: Trigger warnings not cleared.\n--echo #\n\n--disable_warnings\nDROP TABLE IF EXISTS t1;\nDROP TABLE IF EXISTS t2;\nDROP PROCEDURE IF EXISTS p1;\n--enable_warnings\n\nCREATE TABLE t1(x SMALLINT, y SMALLINT, z SMALLINT);\nCREATE TABLE t2(a SMALLINT, b SMALLINT, c SMALLINT,\n                d SMALLINT, e SMALLINT, f SMALLINT);\n\nCREATE TRIGGER t1_bi BEFORE INSERT ON t1 FOR EACH ROW\n  INSERT IGNORE INTO t2(a, b, c) VALUES(99999, 99999, 99999);\n\nCREATE TRIGGER t1_ai AFTER INSERT ON t1 FOR EACH ROW\n  INSERT IGNORE INTO t2(d, e, f) VALUES(99999, 99999, 99999);\n\nCREATE PROCEDURE p1()\n  INSERT IGNORE INTO t1 VALUES(99999, 99999, 99999);\n\n# What happened before the patch was:\n#  - INSERT INTO t1 added 3 warnings about overflow in 'x', 'y' and 'z' columns;\n#  - t1_bi run and added 3 warnings about overflow in 'a', 'b' and 'c' columns;\n#  - t1_ai run and added 3 warnings about overflow in 'd', 'e' and 'f' columns;\n# => we had 9 warnings.\n#\n# Now what happens is:\n#  - INSERT INTO t1 adds 3 warnings about overflow in 'x', 'y' and 'z' columns;\n#  - t1_bi adds 3 warnings about overflow in 'a', 'b' and 'c' columns;\n#  - The warnings added by triggers are cleared;\n#  - t1_ai run and added 3 warnings about overflow in 'd', 'e' and 'f' columns;\n#  - The warnings added by triggers are cleared;\n# => we have 3 warnings.\n\n--echo\nCALL p1();\n\n--echo\nSHOW WARNINGS;\n\n--echo\nDROP TABLE t1;\nDROP TABLE t2;\nDROP PROCEDURE p1;\n\n--echo # ----------------------------------------------------------------------\nSET sql_mode = 'NO_ENGINE_SUBSTITUTION';\nCREATE TABLE t1(x SMALLINT, y SMALLINT, z SMALLINT);\nCREATE TABLE t2(a SMALLINT, b SMALLINT, c SMALLINT NOT NULL);\n\ndelimiter |;\n\nCREATE TRIGGER t1_bi BEFORE INSERT ON t1 FOR EACH ROW\nBEGIN\n  INSERT INTO t2 VALUES(\n    CAST('111111 ' AS SIGNED),\n    CAST('222222 ' AS SIGNED),\n    NULL);\nEND|\n\ndelimiter ;|\n\nCREATE PROCEDURE p1()\n  INSERT INTO t1 VALUES(99999, 99999, 99999);\n\n--echo\n--error ER_BAD_NULL_ERROR\nCALL p1();\n\n--echo\nSHOW WARNINGS;\n\n--echo\nDROP TABLE t1;\nDROP TABLE t2;\nDROP PROCEDURE p1;\nSET sql_mode = DEFAULT;\n\n--echo\n--echo ###################################################################\n--echo # Tests for the following bugs:\n--echo #   - Bug#11763171: 55852 - Possibly inappropriate handler activation.\n--echo #   - Bug#11749343: 38806 - Wrong scope for SQL HANDLERS in SP.\n--echo ###################################################################\n--echo\n\n#\n# Structure of SQL-block:\n# BEGIN\n#   <Handler declaration block>\n#   <Statement block>\n# END\n#\n# Scope of Handler-decl-block is Statement-block.\n# I.e. SQL-conditions thrown in the Handler-decl-block can not be handled by\n# the same block, only by outer SQL-blocks.\n#\n# This rule is recursive, i.e. if a Handler-decl-block has nested SQL-blocks,\n# the SQL-conditions from those nested blocks can not be handled by the this\n# Handler-decl-block, only by outer SQL-blocks.\n#\n\ndelimiter |;\n\n--echo\n--echo # -- Check that SQL-conditions thrown by Statement-blocks are\n--echo # -- handled by Handler-decl blocks properly.\n--echo\n\nCREATE PROCEDURE p1()\nBEGIN\n  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION\n    SELECT 'H1' AS HandlerId;\n\n  DECLARE CONTINUE HANDLER FOR SQLWARNING\n    SELECT 'H2' AS HandlerId;\n\n  SIGNAL SQLSTATE '01000'; # Should be handled by H2.\nEND|\n\n--echo\nCALL p1()|\n\n--echo\n--echo # -- Check that SQL-conditions thrown by Statement-blocks are\n--echo # -- handled by Handler-decl blocks properly in case of nested\n--echo # -- SQL-blocks.\n--echo\n\nCREATE PROCEDURE p2()\nBEGIN\n  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION\n    SELECT 'H1' AS HandlerId;\n\n  DECLARE CONTINUE HANDLER FOR SQLWARNING\n    SELECT 'H2' AS HandlerId;\n\n  BEGIN\n\n    SELECT 'B1' AS BlockId;\n    BEGIN\n\n      SELECT 'B2' AS BlockId;\n      BEGIN\n        SELECT 'B3' AS BlockId;\n        SIGNAL SQLSTATE '01000'; # Should be handled by H2.\n      END;\n\n    END;\n\n  END;\n\nEND|\n\n--echo\nCALL p2()|\n\n--echo\n--echo # -- Check SQL-handler resolution rules.\n--echo\n\nCREATE PROCEDURE p3()\nBEGIN\n  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION\n    SELECT 'H1' AS HandlerId;\n\n  DECLARE CONTINUE HANDLER FOR SQLWARNING\n    SELECT 'H2' AS HandlerId;\n\n  DECLARE CONTINUE HANDLER FOR SQLSTATE '01000'\n    SELECT 'H3' AS HandlerId;\n\n  SIGNAL SQLSTATE '01000'; # Should be handled by H3.\nEND|\n\n--echo\nCALL p3()|\n--echo\n\nCREATE PROCEDURE p4()\nBEGIN\n  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION\n    SELECT 'H1' AS HandlerId;\n\n  DECLARE CONTINUE HANDLER FOR SQLSTATE '01000'\n    SELECT 'H2' AS HandlerId;\n\n  DECLARE CONTINUE HANDLER FOR SQLWARNING\n    SELECT 'H3' AS HandlerId;\n\n  SIGNAL SQLSTATE '01000'; # Should be handled by H2.\nEND|\n\n--echo\nCALL p4()|\n--echo\n\nCREATE PROCEDURE p5()\nBEGIN\n  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION\n    SELECT 'H1' AS HandlerId;\n\n  DECLARE CONTINUE HANDLER FOR SQLSTATE '01000'\n    SELECT 'H2' AS HandlerId;\n\n  BEGIN\n    DECLARE CONTINUE HANDLER FOR SQLWARNING\n      SELECT 'H3' AS HandlerId;\n\n    SIGNAL SQLSTATE '01000'; # Should be handled by H3.\n  END;\nEND|\n\n--echo\nCALL p5()|\n\n--echo\n--echo # -- Check that handlers don't handle its own exceptions.\n--echo\n\nCREATE PROCEDURE p6()\nBEGIN\n  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION\n  BEGIN\n    SELECT 'H1' AS HandlerId;\n    SIGNAL SQLSTATE 'HY000'; # Should *not* be handled by H1.\n  END;\n\n  SELECT 'S1' AS SignalId;\n  SIGNAL SQLSTATE 'HY000'; # Should be handled by H1.\nEND|\n\n--echo\n--error ER_SIGNAL_EXCEPTION\nCALL p6()|\n\n--echo\n--echo # -- Check that handlers don't handle its own warnings.\n--echo\n\nCREATE PROCEDURE p7()\nBEGIN\n  DECLARE CONTINUE HANDLER FOR SQLWARNING\n  BEGIN\n    SELECT 'H1' AS HandlerId;\n    SIGNAL SQLSTATE '01000'; # Should *not* be handled by H1.\n  END;\n\n  SELECT 'S1' AS SignalId;\n  SIGNAL SQLSTATE '01000'; # Should be handled by H1.\nEND|\n\n--echo\nCALL p7()|\n\n--echo\n--echo # -- Check that conditions for handlers are not handled by the handlers\n--echo # -- from the same block.\n--echo\n\nCREATE PROCEDURE p8()\nBEGIN\n  DECLARE CONTINUE HANDLER FOR SQLWARNING\n    SELECT 'H1' AS HandlerId;\n\n  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION\n  BEGIN\n    SELECT 'H2' AS HandlerId;\n    SIGNAL SQLSTATE '01000'; # Should *not* be handled by H1.\n  END;\n\n  SELECT 'S1' AS SignalId;\n  SIGNAL SQLSTATE 'HY000'; # Should be handled by H2.\nEND|\n\n--echo\nCALL p8()|\n\n--echo\n--echo # -- Check that conditions for handlers are not handled by the handlers\n--echo # -- from the same block even if they are thrown deep down the stack.\n--echo\n\nCREATE PROCEDURE p9()\nBEGIN\n\n  DECLARE CONTINUE HANDLER FOR SQLSTATE '01000'\n    SELECT 'Wrong:H1:1' AS HandlerId;\n\n  DECLARE CONTINUE HANDLER FOR SQLWARNING\n    SELECT 'Wrong:H1:2' AS HandlerId;\n\n  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION\n  BEGIN\n\n    DECLARE CONTINUE HANDLER FOR SQLSTATE '01000'\n      SELECT 'Wrong:H2:1' AS HandlerId;\n\n    DECLARE CONTINUE HANDLER FOR SQLWARNING\n      SELECT 'Wrong:H2:2' AS HandlerId;\n\n    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION\n    BEGIN\n\n      DECLARE CONTINUE HANDLER FOR SQLSTATE '01000'\n        SELECT 'Wrong:H3:1' AS HandlerId;\n\n      DECLARE CONTINUE HANDLER FOR SQLWARNING\n        SELECT 'Wrong:H3:2' AS HandlerId;\n\n      DECLARE CONTINUE HANDLER FOR SQLEXCEPTION\n      BEGIN\n\n        DECLARE CONTINUE HANDLER FOR SQLSTATE '01000'\n          SELECT 'Wrong:H4:1' AS HandlerId;\n\n        DECLARE CONTINUE HANDLER FOR SQLWARNING\n          SELECT 'Wrong:H4:2' AS HandlerId;\n\n        DECLARE CONTINUE HANDLER FOR SQLEXCEPTION\n        BEGIN\n\n          DECLARE CONTINUE HANDLER FOR SQLSTATE '01000'\n            SELECT 'Wrong:H5:1' AS HandlerId;\n\n          DECLARE CONTINUE HANDLER FOR SQLWARNING\n            SELECT 'Wrong:H5:2' AS HandlerId;\n\n          DECLARE CONTINUE HANDLER FOR SQLEXCEPTION\n          BEGIN\n\n            DECLARE CONTINUE HANDLER FOR SQLSTATE '01000'\n              SELECT 'Wrong:H6:1' AS HandlerId;\n\n            DECLARE CONTINUE HANDLER FOR SQLWARNING\n              SELECT 'Wrong:H6:2' AS HandlerId;\n\n            DECLARE CONTINUE HANDLER FOR SQLEXCEPTION\n            BEGIN\n              SELECT 'H2' AS HandlerId;\n              SIGNAL SQLSTATE '01000'; # Should *not* be handled by H1.\n            END;\n\n            SELECT 'S6' AS SignalId;\n            SIGNAL SQLSTATE 'HY000';\n          END;\n\n          SELECT 'S5' AS SignalId;\n          SIGNAL SQLSTATE 'HY000';\n\n        END;\n\n        SELECT 'S4' AS SignalId;\n        SIGNAL SQLSTATE 'HY000';\n\n      END;\n\n      SELECT 'S3' AS SignalId;\n      SIGNAL SQLSTATE 'HY000';\n\n    END;\n\n    SELECT 'S2' AS SignalId;\n    SIGNAL SQLSTATE 'HY000';\n\n  END;\n\n  SELECT 'S1' AS SignalId;\n  SIGNAL SQLSTATE 'HY000'; # Should be handled by H2.\n\nEND|\n\n--echo\nCALL p9()|\n\n--echo\n--echo # -- Check that handlers are choosen properly in case of deep stack and\n--echo # -- nested SQL-blocks.\n--echo\n\nCREATE PROCEDURE p10()\nBEGIN\n  DECLARE CONTINUE HANDLER FOR SQLSTATE '01000'\n    SELECT 'H1' AS HandlerId;\n\n  DECLARE CONTINUE HANDLER FOR SQLWARNING\n    SELECT 'H2' AS HandlerId;\n\n  BEGIN\n    BEGIN\n      BEGIN\n\n        DECLARE CONTINUE HANDLER FOR SQLSTATE '01000'\n          SELECT 'Wrong:H1:1' AS HandlerId;\n\n        DECLARE CONTINUE HANDLER FOR SQLWARNING\n          SELECT 'Wrong:H1:2' AS HandlerId;\n\n        DECLARE CONTINUE HANDLER FOR SQLEXCEPTION\n        BEGIN\n\n          DECLARE CONTINUE HANDLER FOR SQLSTATE '01000'\n            SELECT 'Wrong:H2:1' AS HandlerId;\n\n          DECLARE CONTINUE HANDLER FOR SQLWARNING\n            SELECT 'Wrong:H2:2' AS HandlerId;\n\n          DECLARE CONTINUE HANDLER FOR SQLEXCEPTION\n          BEGIN\n\n            DECLARE CONTINUE HANDLER FOR SQLSTATE '01000'\n              SELECT 'Wrong:H3:1' AS HandlerId;\n\n            DECLARE CONTINUE HANDLER FOR SQLWARNING\n              SELECT 'Wrong:H3:2' AS HandlerId;\n\n            DECLARE CONTINUE HANDLER FOR SQLEXCEPTION\n            BEGIN\n\n              DECLARE CONTINUE HANDLER FOR SQLSTATE '01000'\n                SELECT 'Wrong:H4:1' AS HandlerId;\n\n              DECLARE CONTINUE HANDLER FOR SQLWARNING\n                SELECT 'Wrong:H4:2' AS HandlerId;\n\n              DECLARE CONTINUE HANDLER FOR SQLEXCEPTION\n              BEGIN\n\n                DECLARE CONTINUE HANDLER FOR SQLSTATE '01000'\n                  SELECT 'Wrong:H5:1' AS HandlerId;\n\n                DECLARE CONTINUE HANDLER FOR SQLWARNING\n                  SELECT 'Wrong:H5:2' AS HandlerId;\n\n                DECLARE CONTINUE HANDLER FOR SQLEXCEPTION\n                BEGIN\n\n                  DECLARE CONTINUE HANDLER FOR SQLSTATE '01000'\n                    SELECT 'Wrong:H6:1' AS HandlerId;\n\n                  DECLARE CONTINUE HANDLER FOR SQLWARNING\n                    SELECT 'Wrong:H6:2' AS HandlerId;\n\n                  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION\n                  BEGIN\n                    SELECT 'H2' AS HandlerId;\n                    SIGNAL SQLSTATE '01000'; # Should be handled by H1.\n                  END;\n\n                  SELECT 'S6' AS SignalId;\n                  SIGNAL SQLSTATE 'HY000';\n                END;\n\n                SELECT 'S5' AS SignalId;\n                SIGNAL SQLSTATE 'HY000';\n\n              END;\n\n              SELECT 'S4' AS SignalId;\n              SIGNAL SQLSTATE 'HY000';\n\n            END;\n\n            SELECT 'S3' AS SignalId;\n            SIGNAL SQLSTATE 'HY000';\n\n          END;\n\n          SELECT 'S2' AS SignalId;\n          SIGNAL SQLSTATE 'HY000';\n\n        END;\n\n        SELECT 'S1' AS SignalId;\n        SIGNAL SQLSTATE 'HY000'; # Should be handled by H2.\n\n      END;\n    END;\n  END;\nEND|\n\n--echo\nCALL p10()|\n\n--echo\n--echo # -- Test stored procedure from Peter's mail.\n--echo\n\nCREATE PROCEDURE p11()\nBEGIN\n  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION\n    SELECT 'H1' AS HandlerId;\n\n  DECLARE CONTINUE HANDLER FOR SQLWARNING\n    SELECT 'H2' AS HandlerId;\n\n  BEGIN\n    DECLARE CONTINUE HANDLER FOR SQLSTATE '01000', 1249\n    BEGIN\n      DECLARE CONTINUE HANDLER FOR SQLEXCEPTION\n        SELECT 'H3' AS HandlerId;\n\n      DECLARE CONTINUE HANDLER FOR SQLWARNING\n        SELECT 'H4' AS HandlerId;\n\n      BEGIN\n        SELECT 'H5' AS HandlerId;\n\n        SELECT 'S3' AS SignalId;\n        SIGNAL SQLSTATE 'HY000'; # H3\n\n        SELECT 'S4' AS SignalId;\n        SIGNAL SQLSTATE '22003'; # H3\n\n        SELECT 'S5' AS SignalId;\n        SIGNAL SQLSTATE '01000' SET MYSQL_ERRNO = 1249; # H4\n      END;\n    END;\n\n    SELECT 'S6' AS SignalId;\n    SIGNAL SQLSTATE 'HY000'; # H1\n\n    SELECT 'S7' AS SignalId;\n    SIGNAL SQLSTATE '22003'; # H1\n\n    SELECT 'S8' AS SignalId;\n    SIGNAL SQLSTATE '01000' SET MYSQL_ERRNO = 1249; # H5\n  END;\n\n  SELECT 'S1' AS SignalId;\n  SIGNAL SQLSTATE 'HY000'; # H1\n\n  SELECT 'S2' AS SignalId;\n  SIGNAL SQLSTATE '01000' SET MYSQL_ERRNO = 1249; # H2\nEND|\n\n--echo\nCALL p11()|\n\n--echo\n--echo # -- Check that runtime stack-trace can be deeper than parsing-time one.\n--echo\n\nCREATE PROCEDURE p12()\nBEGIN\n  DECLARE CONTINUE HANDLER FOR SQLSTATE '01001'\n  BEGIN\n    DECLARE CONTINUE HANDLER FOR SQLSTATE '01001'\n    BEGIN\n      DECLARE CONTINUE HANDLER FOR SQLSTATE '01001'\n      BEGIN\n        DECLARE CONTINUE HANDLER FOR SQLSTATE '01001'\n        BEGIN\n          DECLARE CONTINUE HANDLER FOR SQLSTATE '01001'\n          BEGIN\n            SELECT 'H1:5' AS HandlerId;\n            SIGNAL SQLSTATE '01002';\n          END;\n          SELECT 'H1:4' AS HandlerId;\n          SIGNAL SQLSTATE '01001';\n        END;\n        SELECT 'H1:3' AS HandlerId;\n        SIGNAL SQLSTATE '01001';\n      END;\n      SELECT 'H1:2' AS HandlerId;\n      SIGNAL SQLSTATE '01001';\n    END;\n    SELECT 'H1:1' AS HandlerId;\n    SIGNAL SQLSTATE '01001';\n  END;\n\n  #########################################################\n\n  DECLARE CONTINUE HANDLER FOR SQLSTATE '01002'\n    SELECT 'OK' AS Msg;\n\n  #########################################################\n\n  BEGIN\n\n    DECLARE CONTINUE HANDLER FOR SQLWARNING\n    BEGIN\n      DECLARE CONTINUE HANDLER FOR SQLWARNING\n      BEGIN\n        DECLARE CONTINUE HANDLER FOR SQLWARNING\n        BEGIN\n          DECLARE CONTINUE HANDLER FOR SQLWARNING\n          BEGIN\n            DECLARE CONTINUE HANDLER FOR SQLWARNING\n            BEGIN\n              SELECT 'H2:5' AS HandlerId;\n              SIGNAL SQLSTATE '01001';\n            END;\n            SELECT 'H2:4' AS HandlerId;\n            SIGNAL SQLSTATE '01000';\n          END;\n          SELECT 'H2:3' AS HandlerId;\n          SIGNAL SQLSTATE '01000';\n        END;\n        SELECT 'H2:2' AS HandlerId;\n        SIGNAL SQLSTATE '01000';\n      END;\n      SELECT 'H2:1' AS HandlerId;\n      SIGNAL SQLSTATE '01000';\n    END;\n\n    #######################################################\n\n    SELECT 'Throw 01000' AS Msg;\n    SIGNAL SQLSTATE '01000';\n  END;\n\nEND|\n\n--echo\nCALL p12()|\n\n--echo\n--echo # -- Check that handler-call-frames are removed properly for EXIT\n--echo # -- handlers.\n--echo\n\nCREATE PROCEDURE p13()\nBEGIN\n  \n  DECLARE CONTINUE HANDLER FOR SQLWARNING\n  BEGIN\n    DECLARE CONTINUE HANDLER FOR SQLWARNING\n    BEGIN\n      DECLARE EXIT HANDLER FOR SQLWARNING\n      BEGIN\n        SELECT 'EXIT handler 3' AS Msg;\n      END;\n\n      SELECT 'CONTINUE handler 2: 1' AS Msg;\n      SIGNAL SQLSTATE '01000';\n      SELECT 'CONTINUE handler 2: 2' AS Msg;\n    END;\n\n    SELECT 'CONTINUE handler 1: 1' AS Msg;\n    SIGNAL SQLSTATE '01000';\n    SELECT 'CONTINUE handler 1: 2' AS Msg;\n  END;\n\n  SELECT 'Throw 01000' AS Msg;\n  SIGNAL SQLSTATE '01000';\nEND|\n\n--echo\nCALL p13()|\n\ndelimiter ;|\n\n--echo\n--echo # That's it. Cleanup.\n--echo\n\nDROP PROCEDURE p1;\nDROP PROCEDURE p2;\nDROP PROCEDURE p3;\nDROP PROCEDURE p4;\nDROP PROCEDURE p5;\nDROP PROCEDURE p6;\nDROP PROCEDURE p7;\nDROP PROCEDURE p8;\nDROP PROCEDURE p9;\nDROP PROCEDURE p10;\nDROP PROCEDURE p11;\nDROP PROCEDURE p12;\nDROP PROCEDURE p13;\n\n--echo\n--echo # Bug#12731619: NESTED SP HANDLERS CAN TRIGGER ASSERTION\n--echo\n\n--disable_warnings\nDROP FUNCTION IF EXISTS f1;\nDROP TABLE IF EXISTS t1;\n--enable_warnings\n\nCREATE TABLE t1(msg VARCHAR(255));\n\ndelimiter |;\nCREATE FUNCTION f1() RETURNS INT\nBEGIN\n\n  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION               # handler 1\n  BEGIN\n    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION             # handler 2\n    BEGIN\n      INSERT INTO t1 VALUE('WRONG: Inside H2');\n      RETURN 2;\n    END;\n\n    INSERT INTO t1 VALUE('CORRECT: Inside H1');\n    RETURN 1;\n  END;\n\n  BEGIN\n    DECLARE CONTINUE HANDLER FOR SQLWARNING               # handler 3\n    BEGIN\n      INSERT INTO t1 VALUE('WRONG: Inside H3');\n      RETURN 3;\n    END;\n\n    INSERT INTO t1 VALUE('CORRECT: Calling f1()');\n    RETURN f1(); # -- exception here\n  END;\n\n  INSERT INTO t1 VALUE('WRONG: Returning 10');\n  RETURN 10;\n\nEND|\n\ndelimiter ;|\n\n--echo\nSELECT f1();\n--echo\nSELECT * FROM t1;\n--echo\n\nDROP FUNCTION f1;\nDROP TABLE t1;\n\n\n--echo\n--echo # Check that handled SQL-conditions are properly cleared from DA.\n--echo\n\n--disable_warnings\nDROP TABLE IF EXISTS t1;\nDROP TABLE IF EXISTS t2;\nDROP PROCEDURE IF EXISTS p1;\nDROP PROCEDURE IF EXISTS p2;\nDROP PROCEDURE IF EXISTS p3;\nDROP PROCEDURE IF EXISTS p4;\nDROP PROCEDURE IF EXISTS p5;\n--enable_warnings\n\nCREATE TABLE t1(a CHAR, b CHAR, c CHAR);\nCREATE TABLE t2(a SMALLINT, b SMALLINT, c SMALLINT);\n\ndelimiter |;\n\n--echo\n--echo # Check that SQL-conditions for which SQL-handler has been invoked,\n--echo # are cleared from the Diagnostics Area. Note, there might be several\n--echo # SQL-conditions, but SQL-handler must be invoked only once.\n--echo\n\nCREATE PROCEDURE p1()\nBEGIN\n  DECLARE EXIT HANDLER FOR SQLWARNING\n    SELECT 'Warning caught' AS msg;\n\n  # The INSERT below raises 3 SQL-conditions (warnings). The EXIT HANDLER\n  # above must be invoked once (for one condition), but all three conditions\n  # must be cleared from the Diagnostics Area.\n\n  INSERT IGNORE INTO t1 VALUES('qqqq', 'ww', 'eee');\n\n  # The following INSERT will not be executed, because of the EXIT HANDLER.\n\n  INSERT INTO t1 VALUES('zzz', 'xx', 'yyyy');\nEND|\n\n--echo\nCALL p1()|\n--echo\nSELECT * FROM t1|\n\n--echo\n--echo # Check that SQL-conditions for which SQL-handler has *not* been\n--echo # invoked, are *still* cleared from the Diagnostics Area.\n--echo\n\nCREATE PROCEDURE p2()\nBEGIN\n  DECLARE CONTINUE HANDLER FOR 1292\n    SELECT 'Warning 1292 caught' AS msg;\n\n  # The following INSERT raises 6 SQL-warnings with code 1292,\n  # and 3 SQL-warnings with code 1264. The CONTINUE HANDLER above must be\n  # invoked once, and all nine SQL-warnings must be cleared from\n  # the Diagnostics Area.\n\n  INSERT IGNORE INTO t2\n  SELECT\n    CAST(CONCAT(CAST('1 ' AS UNSIGNED INTEGER), '999999  ') AS SIGNED INTEGER),\n    CAST(CONCAT(CAST('2 ' AS UNSIGNED INTEGER), '999999  ') AS SIGNED INTEGER),\n    CAST(CONCAT(CAST('3 ' AS UNSIGNED INTEGER), '999999  ') AS SIGNED INTEGER);\nEND|\n\n--echo\nCALL p2()|\n\n--echo\n--echo # Check that if there are two equally ranked SQL-handlers to handle\n--echo # SQL-conditions from SQL-statement, only one of them will be invoked.\n--echo\n\nCREATE PROCEDURE p3()\nBEGIN\n  DECLARE CONTINUE HANDLER FOR 1292\n    SELECT 'Warning 1292 caught' AS msg;\n\n  DECLARE CONTINUE HANDLER FOR 1264\n    SELECT 'Warning 1264 caught' AS msg;\n\n  # The following INSERT raises 6 SQL-warnings with code 1292,\n  # and 3 SQL-warnings with code 1264. Only one of the CONTINUE HANDLERs above\n  # must be called, and only once. The SQL Standard does not define, which one\n  # should be invoked.\n\n  INSERT INTO t2\n  SELECT\n    CAST(CONCAT(CAST('1 ' AS UNSIGNED INTEGER), '999999  ') AS SIGNED INTEGER),\n    CAST(CONCAT(CAST('2 ' AS UNSIGNED INTEGER), '999999  ') AS SIGNED INTEGER),\n    CAST(CONCAT(CAST('3 ' AS UNSIGNED INTEGER), '999999  ') AS SIGNED INTEGER);\nEND|\n\n--echo\nCALL p3()|\n\n--echo\n--echo # The same as p3, but 1264 comes first.\n--echo\n\nCREATE PROCEDURE p4()\nBEGIN\n  DECLARE CONTINUE HANDLER FOR 1292\n    SELECT 'Warning 1292 caught' AS msg;\n\n  DECLARE CONTINUE HANDLER FOR 1264\n    SELECT 'Warning 1264 caught' AS msg;\n\n  # The following INSERT raises 4 SQL-warnings with code 1292,\n  # and 3 SQL-warnings with code 1264. Only one of the CONTINUE HANDLERs above\n  # must be called, and only once. The SQL Standard does not define, which one\n  # should be invoked.\n\n  INSERT INTO t2\n  SELECT\n    CAST(999999 AS SIGNED INTEGER),\n    CAST(CONCAT(CAST('2 ' AS UNSIGNED INTEGER), '999999  ') AS SIGNED INTEGER),\n    CAST(CONCAT(CAST('3 ' AS UNSIGNED INTEGER), '999999  ') AS SIGNED INTEGER);\nEND|\n\n--echo\nCALL p4()|\n\n--echo\n--echo # Check that if a SQL-handler raised its own SQL-conditions, there are\n--echo # preserved after handler exit.\n--echo\n\nCREATE PROCEDURE p5()\nBEGIN\n  DECLARE EXIT HANDLER FOR 1292\n  BEGIN\n    SELECT 'Handler for 1292 (1)' AS Msg;\n    SIGNAL SQLSTATE '01000' SET MYSQL_ERRNO = 1234;\n    SHOW WARNINGS;\n    SELECT 'Handler for 1292 (2)' AS Msg;\n  END;\n\n  INSERT IGNORE INTO t2\n  SELECT\n    CAST(999999 AS SIGNED INTEGER),\n    CAST(CONCAT(CAST('2 ' AS UNSIGNED INTEGER), '999999  ') AS SIGNED INTEGER),\n    CAST(CONCAT(CAST('3 ' AS UNSIGNED INTEGER), '999999  ') AS SIGNED INTEGER);\nEND|\n\n--echo\nCALL p5()|\n\n--echo\n--echo # Check that SQL-conditions are available inside the handler, but\n--echo # cleared after the handler exits.\n--echo\n\nCREATE PROCEDURE p6()\nBEGIN\n  DECLARE CONTINUE HANDLER FOR 1292\n  BEGIN\n    SHOW WARNINGS;\n    SELECT 'Handler for 1292' Msg;\n  END;\n\n  INSERT IGNORE INTO t2\n  SELECT\n    CAST(CONCAT(CAST('1 ' AS UNSIGNED INTEGER), '999999  ') AS SIGNED INTEGER),\n    CAST(CONCAT(CAST('2 ' AS UNSIGNED INTEGER), '999999  ') AS SIGNED INTEGER),\n    CAST(CONCAT(CAST('3 ' AS UNSIGNED INTEGER), '999999  ') AS SIGNED INTEGER);\nEND|\n\n--echo\nCALL p6()|\n\ndelimiter ;|\n\n--echo\nDROP PROCEDURE p1;\nDROP PROCEDURE p2;\nDROP PROCEDURE p3;\nDROP PROCEDURE p4;\nDROP PROCEDURE p5;\nDROP PROCEDURE p6;\nDROP TABLE t1;\nDROP TABLE t2;\n\n--echo\n--echo # Bug#13059316: ASSERTION FAILURE IN SP_RCONTEXT.CC \n--echo # Check DECLARE statements that raise conditions before handlers\n--echo # are declared.\n--echo\n\n--disable_warnings\nDROP PROCEDURE IF EXISTS p1;\nDROP PROCEDURE IF EXISTS p2;\n--enable_warnings\n\ndelimiter |;\n\nSET sql_mode = '';\nCREATE PROCEDURE p1()\nBEGIN\n  DECLARE var1 INTEGER DEFAULT 'string';\n  DECLARE EXIT HANDLER FOR SQLWARNING SELECT 'H1';\nEND|\n\n--echo\nCALL p1()|\n--echo\nSET sql_mode = DEFAULT;\n\nCREATE PROCEDURE p2()\nBEGIN\n  DECLARE EXIT HANDLER FOR SQLWARNING SELECT 'H2';\n  CALL p1();\nEND|\n\n--echo\nCALL p2()|\n\ndelimiter ;|\n\n--echo\nDROP PROCEDURE p1;\nDROP PROCEDURE p2;\n\n\n--echo #\n--echo # Bug#13113222 RQG_SIGNAL_RESIGNAL FAILED WITH ASSERTION.\n--echo #\n\n--disable_warnings\nDROP PROCEDURE IF EXISTS p1;\nDROP PROCEDURE IF EXISTS p2;\n--enable_warnings\n\ndelimiter |;\nCREATE PROCEDURE p1()\nBEGIN\n  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SELECT 'triggered p1';\n  # This will trigger an error.\n  SIGNAL SQLSTATE 'HY000';\nEND|\n\nCREATE PROCEDURE p2()\nBEGIN\n  DECLARE CONTINUE HANDLER FOR SQLWARNING SELECT 'triggered p2';\n  # This will trigger a warning.\n  SIGNAL SQLSTATE '01000';\nEND|\ndelimiter ;|\n\nSET @old_max_error_count=  @@session.max_error_count;\nSET SESSION max_error_count= 0;\nCALL p1();\nCALL p2();\nSET SESSION max_error_count= @old_max_error_count;\n\nDROP PROCEDURE p1;\nDROP PROCEDURE p2;\n\n--echo\n--echo # Bug#12652873: 61392: Continue handler for NOT FOUND being triggered\n--echo # from internal stored function.\n--echo\n\n--disable_warnings\nDROP FUNCTION IF EXISTS f1;\nDROP FUNCTION IF EXISTS f2;\nDROP TABLE IF EXISTS t1;\n--enable_warnings\n\n--echo\n\nCREATE TABLE t1 (a INT, b INT);\nINSERT INTO t1 VALUES (1, 2);\n\ndelimiter |;\n\n--echo\n--echo # f1() raises NOT_FOUND condition.\n--echo # Raising NOT_FOUND can not be simulated by SIGNAL,\n--echo # because SIGNAL would raise SQL-error in that case.\n--echo\n\nCREATE FUNCTION f1() RETURNS INTEGER\nBEGIN\n  DECLARE v VARCHAR(5) DEFAULT -1;\n  SELECT b FROM t1 WHERE a = 2 INTO v;\n  RETURN v;\nEND|\n\n--echo\n--echo # Here we check that the NOT_FOUND condition raised in f1()\n--echo # is not visible in the outer function (f2), i.e. the continue\n--echo # handler in f2() will not be called.\n--echo\n\nCREATE FUNCTION f2() RETURNS INTEGER\nBEGIN\n  DECLARE v INTEGER;\n\n  DECLARE CONTINUE HANDLER FOR NOT FOUND\n    SET @msg = 'Handler activated.';\n\n  SELECT f1() INTO v;\n\n  RETURN v;\nEND|\n\ndelimiter ;|\n\nSET @msg = '';\n\n--echo\nSELECT f2();\n--echo\nSELECT @msg;\n--echo\n\nDROP FUNCTION f1;\nDROP FUNCTION f2;\nDROP TABLE t1;\n",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/lib/My/SafeProcess/wsrep_check_version.c": "/* Copyright (c) 2009, 2019, MariaDB\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; version 2 of the License.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02111-1301 USA\n */\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#ifdef _WIN32\n#include <windows.h>\n#define dlsym(lib, name) GetProcAddress((HMODULE)lib, name)\n#define dlopen(libname, unused) LoadLibraryEx(libname, NULL, 0)\n#define dlclose(lib) FreeLibrary((HMODULE)lib)\n#elif defined(HAVE_DLFCN_H)\n#include <dlfcn.h>\n#else\n#define NO_DLL\n#endif\n\n#ifndef NO_DLL\n\n#include \"../../../../wsrep-lib/wsrep-API/v26/wsrep_api.h\"\n\n/**************************************************************************\n * Library loader\n **************************************************************************/\n\nstatic int wsrep_check_iface_version(const char *found, const char *iface_ver)\n{\n    if (strcmp(found, iface_ver)) {\n        return ERANGE;\n    }\n    return 0;\n}\n\ntypedef int (*wsrep_loader_fun)(wsrep_t*);\n\nstatic wsrep_loader_fun wsrep_dlf(void *dlh, const char *sym)\n{\n    union {\n        wsrep_loader_fun dlfun;\n        void *obj;\n    } alias;\n    alias.obj = dlsym(dlh, sym);\n    return alias.dlfun;\n}\n\nstatic int wsrep_check_version_symbol(void *dlh)\n{\n    char** dlversion = NULL;\n    dlversion = (char**) dlsym(dlh, \"wsrep_interface_version\");\n    if (dlversion == NULL)\n        return EINVAL;\n    return wsrep_check_iface_version(*dlversion, WSREP_INTERFACE_VERSION);\n}\n\nstatic int wsrep_print_version(void *dlh)\n{\n    char** dlversion = NULL;\n    dlversion = (char**) dlsym(dlh, \"wsrep_interface_version\");\n    if (dlversion == NULL)\n        return EINVAL;\n    printf(\"found: %s, need: %s\\n\", *dlversion, WSREP_INTERFACE_VERSION);\n    return 0;\n}\n\nint main(int argc, char **argv)\n{\n    int rc = EINVAL;\n    void *dlh;\n    wsrep_loader_fun dlfun;\n\n    if (!(dlh = dlopen(getenv(\"WSREP_PROVIDER\"), RTLD_NOW | RTLD_LOCAL))) {\n       goto err;\n    }\n\n    if (!(dlfun = wsrep_dlf(dlh, \"wsrep_loader\"))) {\n       goto err;\n    }\n\n    if (argc < 2 || strcmp(argv[1], \"-p\")) {\n        rc = wsrep_check_version_symbol(dlh);\n    }\n    else {\n        rc = wsrep_print_version(dlh);\n    }\n\nerr:\n    if (dlh) dlclose(dlh);\n\n    if (rc == 0)\n        return 0;\n    else if (rc == ERANGE)\n        return 2;\n    else\n        return 1;\n}\n\n#else\n\nint main(void)\n{\n    return 1;\n}\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/libmariadb/CMakeLists.txt": "# CMakeLists.txt\n\n# This is the LGPL libmariadb project.\n\nCMAKE_MINIMUM_REQUIRED(VERSION 2.8 FATAL_ERROR)\nINCLUDE(CheckFunctionExists)\nIF(COMMAND CMAKE_POLICY)\n  SET(NEW_POLICIES CMP0003 CMP0022 CMP0023 CMP0077)\n  FOREACH(TYPE OLD NEW)\n    FOREACH(P ${${TYPE}_POLICIES})\n      IF(POLICY ${P})\n        CMAKE_POLICY(SET ${P} ${TYPE})\n      ENDIF()\n    ENDFOREACH()\n  ENDFOREACH()\nENDIF()\n\n\nPROJECT(mariadb-connector-c C)\n\n# Is C/C built as subproject?\nget_directory_property(IS_SUBPROJECT PARENT_DIRECTORY)\n\n# do not inherit include directories from the parent project\nSET_PROPERTY(DIRECTORY PROPERTY INCLUDE_DIRECTORIES)\nFOREACH(V WITH_MYSQLCOMPAT WITH_MSI WITH_SIGNCODE WITH_RTC WITH_UNIT_TESTS\n    WITH_DYNCOL WITH_EXTERNAL_ZLIB WITH_CURL WITH_SQLITE WITH_SSL\n    INSTALL_LAYOUT WITH_TEST_SRCPKG)\n  SET(${V} ${${OPT}${V}})\nENDFOREACH()\n\n#SET(PACKAGE_STATUS_SUFFIX \"beta\")\n\nSET(CC_SOURCE_DIR ${CMAKE_CURRENT_SOURCE_DIR})\nSET(CC_BINARY_DIR ${CMAKE_CURRENT_BINARY_DIR})\n\nSET(CPACK_PACKAGE_VERSION_MAJOR 3)\nSET(CPACK_PACKAGE_VERSION_MINOR 1)\nSET(CPACK_PACKAGE_VERSION_PATCH 7)\nSET(CPACK_PACKAGE_VERSION \"${CPACK_PACKAGE_VERSION_MAJOR}.${CPACK_PACKAGE_VERSION_MINOR}.${CPACK_PACKAGE_VERSION_PATCH}\")\nMATH(EXPR MARIADB_PACKAGE_VERSION_ID \"${CPACK_PACKAGE_VERSION_MAJOR} * 10000 +\n                            ${CPACK_PACKAGE_VERSION_MINOR} * 100   +\n                            ${CPACK_PACKAGE_VERSION_PATCH}\")\n\nMACRO(ADD_OPTION _name _text _default)\n  IF(NOT DEFINED ${_name})\n    OPTION(${OPT}${_name} \"${_text}\" \"${_default}\")\n  ELSE()\n    OPTION(${OPT}${_name} \"${_text}\" \"${${_name}}\")\n  ENDIF()\nENDMACRO()\n\n### Options ###\nIF(NOT WIN32)\n  ADD_OPTION(WITH_MYSQLCOMPAT \"creates libmysql* symbolic links\" OFF)\nELSE()\n  ADD_OPTION(WITH_MSI \"Build MSI installation package\" OFF)\n  ADD_OPTION(WITH_SIGNCODE \"digitally sign files\" OFF)\n  ADD_OPTION(WITH_RTC \"enables run time checks for debug builds\" OFF)\nENDIF()\n\nADD_OPTION(WITH_UNIT_TESTS \"build test suite\" ON)\nADD_OPTION(WITH_DYNCOL \"Enables support of dynamic coluumns\" ON)\nADD_OPTION(WITH_EXTERNAL_ZLIB \"Enables use of external zlib\" OFF)\nADD_OPTION(WITH_CURL \"Enables use of curl\" ON)\nADD_OPTION(WITH_SSL \"Enables use of TLS/SSL library\" ON)\n###############\n\nINCLUDE(${CC_SOURCE_DIR}/cmake/misc.cmake)\nINCLUDE(FindCURL)\n\nIF(WITH_SIGNCODE)\n  IF(WIN32 AND NOT SIGN_OPTIONS)\n    SET(SIGN_OPTIONS /a /t http://timestamp.verisign.com/scripts/timstamp.dll)\n  ELSE()\n    SEPARATE_ARGUMENTS(SIGN_OPTIONS)\n  ENDIF()\n  MARK_AS_ADVANCED(SIGN_OPTIONS)\nENDIF()\n\nSET(MARIADB_CONNECTOR_C_COPYRIGHT \"2013-2017 MariaDB Corporation Ab\")\n\nIF(WITH_RTC)\n  SET(RTC_OPTIONS \"/RTC1 /RTCc\")\nENDIF()\n\nIF(NOT WIN32)\n  INCLUDE(${CC_SOURCE_DIR}/cmake/FindGSSAPI.cmake)\n  IF(GSSAPI_FOUND)\n    INCLUDE_DIRECTORIES(${GSSAPI_INCS})\n  ENDIF()\nENDIF()\n\nINCLUDE(${CC_SOURCE_DIR}/cmake/plugins.cmake)\n\nIF(AUTH_GSSAPI_PLUGIN_TYPE MATCHES \"STATIC\")\n  SET(SYSTEM_LIBS ${SYSTEM_LIBS} ${GSSAPI_LIBS})\nENDIF()\n\n\nIF(WIN32)\n  FILE(REMOVE ${CC_BINARY_DIR}/win/packaging/plugin.conf)\n  INCLUDE(${CC_SOURCE_DIR}/cmake/version_info.cmake)\nENDIF()\n\nIF(NOT IS_SUBPROJECT)\nIF(MSVC)\n  # Speedup system tests\n  INCLUDE(${CC_SOURCE_DIR}/cmake/WindowsCache.cmake)\n  ADD_DEFINITIONS(-DWIN32_LEAN_AND_MEAN)\n  IF (MSVC)\n    SET(CONFIG_TYPES \"DEBUG\" \"RELEASE\" \"RELWITHDEBINFO\")\n    FOREACH(BUILD_TYPE ${CONFIG_TYPES})\n      FOREACH(COMPILER CXX C)\n        SET(COMPILER_FLAGS \"${CMAKE_${COMPILER}_FLAGS_${BUILD_TYPE}}\")\n        IF (NOT COMPILER_FLAGS STREQUAL \"\")\n          STRING(REPLACE \"/MD\" \"/MT\" COMPILER_FLAGS ${COMPILER_FLAGS})\n          IF (CMAKE_BUILD_TYPE STREQUAL \"Debug\")\n            SET(COMPILER_FLAGS \"${COMPILER_FLAGS} ${RTC_OPTIONS}\")\n            STRING(REPLACE \"/Zi\" \"/ZI\" COMPILER_FLAGS ${COMPILER_FLAGS})\n          ELSE()\n            STRING(REPLACE \"/Zi\" \"/Z7\" COMPILER_FLAGS ${COMPILER_FLAGS})\n          ENDIF()\n          MESSAGE (STATUS \"CMAKE_${COMPILER}_FLAGS_${BUILD_TYPE}= ${COMPILER_FLAGS}\")\n          SET(CMAKE_${COMPILER}_FLAGS_${BUILD_TYPE} ${COMPILER_FLAGS})\n        ENDIF()\n      ENDFOREACH()\n    ENDFOREACH()\n  ENDIF()\nENDIF()\nENDIF(NOT IS_SUBPROJECT)\n\n# Disable dbug information for release builds\nSET(CMAKE_C_FLAGS_RELEASE \"${CMAKE_C_FLAGS_RELEASE} -DDBUG_OFF\")\nSET(CMAKE_CXX_FLAGS_RELEASE \"${CMAKE_CXX_FLAGS_RELEASE} -DDBUG_OFF\")\nSET(CMAKE_C_FLAGS_RELWITHDEBINFO \"${CMAKE_C_FLAGS_RELWITHDEBINFO} -DDBUG_OFF\")\nSET(CMAKE_CXX_FLAGS_RELWITHDEBINFO \"${CMAKE_CXX_FLAGS_RELWITHDEBINFO} -DDBUG_OFF\")\n\nIF(CMAKE_COMPILER_IS_GNUCC)\n  INCLUDE(CheckCCompilerFlag)\n  SET(GCC_FLAGS -Wunused -Wlogical-op -Wno-uninitialized  -Wall -Wextra -Wformat-security -Wno-init-self -Wwrite-strings -Wshift-count-overflow -Wdeclaration-after-statement -Wno-undef -Wno-unknown-pragmas)\n  FOREACH(GCC_FLAG ${GCC_FLAGS})\n    CHECK_C_COMPILER_FLAG(\"${GCC_FLAG}\" HAS_${GCC_FLAG}_FLAG)\n    IF(${HAS_${GCC_FLAG}_FLAG})\n      SET(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} ${GCC_FLAG}\")\n    ENDIF()\n  ENDFOREACH()\nENDIF()\n\n# If the build type isn't specified, set to Relwithdebinfo as default.\nIF(NOT CMAKE_BUILD_TYPE)\n  SET(CMAKE_BUILD_TYPE \"RelWithDebInfo\")\nENDIF()\n\n# various defines for generating include/mysql_version.h\nINCLUDE(FindGit)\nIF(GIT_EXECUTABLE AND EXISTS ${CC_SOURCE_DIR}/.git)\n  EXECUTE_PROCESS(\n    COMMAND ${GIT_EXECUTABLE} rev-parse HEAD\n      WORKING_DIRECTORY ${CC_SOURCE_DIR}\n       OUTPUT_VARIABLE OUT RESULT_VARIABLE RES)\n   IF(RES EQUAL 0)\n    STRING(REGEX REPLACE \"\\n$\" \"\" CC_SOURCE_REVISION \"${OUT}\")\n  ENDIF()\nENDIF()\nSET(PROTOCOL_VERSION 10) # we adapted new password option from PHP's mysqlnd !\n\n# if C/C is build as subproject inside MariaDB server tree we will\n# use the version defined by server\nIF(MAJOR_VERSION)\n  SET(MARIADB_CLIENT_VERSION_MAJOR ${MAJOR_VERSION})\n  SET(MARIADB_CLIENT_VERSION_MINOR ${MINOR_VERSION})\n  SET(MARIADB_CLIENT_VERSION_PATCH ${PATCH_VERSION})\n  SET(MARIADB_CLIENT_VERSION_EXTRA ${EXTRA_VERSION})\nELSE()\n  SET(MARIADB_CLIENT_VERSION_MAJOR \"10\")\n  SET(MARIADB_CLIENT_VERSION_MINOR \"4\")\n  SET(MARIADB_CLIENT_VERSION_PATCH \"3\")\n  SET(MARIADB_CLIENT_VERSION_EXTRA \"\")\nENDIF()\nSET(MARIADB_CLIENT_VERSION \"${MARIADB_CLIENT_VERSION_MAJOR}.${MARIADB_CLIENT_VERSION_MINOR}.${MARIADB_CLIENT_VERSION_PATCH}${MARIADB_CLIENT_VERSION_EXTRA}\")\nSET(MARIADB_BASE_VERSION \"mariadb-${MARIADB_CLIENT_VERSION_MAJOR}.${MARIADB_CLIENT_VERSION_MINOR}\")\nMATH(EXPR MARIADB_VERSION_ID \"${MARIADB_CLIENT_VERSION_MAJOR} * 10000 +\n                              ${MARIADB_CLIENT_VERSION_MINOR} * 100   +\n                              ${MARIADB_CLIENT_VERSION_PATCH}\")\n\nIF (NOT MARIADB_PORT)\n  SET(MARIADB_PORT 3306)\nENDIF ()\nIF(NOT MARIADB_UNIX_ADDR)\n  SET(MARIADB_UNIX_ADDR \"/tmp/mysql.sock\")\nENDIF()\n\nINCLUDE(\"${CC_SOURCE_DIR}/cmake/install.cmake\")\nIF(NOT PLUGINDIR)\n  SET(PLUGINDIR \"${CMAKE_INSTALL_PREFIX}/${INSTALL_PLUGINDIR}\")\nENDIF()\n\n# todo: we don't character sets in share - all is compiled in\nSET(SHAREDIR \"share\")\nSET(DEFAULT_CHARSET_HOME \"${CMAKE_INSTALL_PREFIX}\")\n\nINCLUDE(${CC_SOURCE_DIR}/cmake/SearchLibrary.cmake)\n\nIF(WITH_EXTERNAL_ZLIB)\n  IF(NOT ZLIB_FOUND)\n    FIND_PACKAGE(ZLIB)\n  ENDIF()\n  IF(ZLIB_FOUND)\n    INCLUDE_DIRECTORIES(${ZLIB_INCLUDE_DIR})\n    SET(LIBZ ${ZLIB_LIBRARY})\n  ENDIF()\nENDIF()\n\nIF(NOT WIN32)\n  INCLUDE(TestBigEndian)\n  TEST_BIG_ENDIAN(HAVE_BIGENDIAN)\nENDIF()\n\n# check for various include files\nINCLUDE(${CC_SOURCE_DIR}/cmake/CheckIncludeFiles.cmake)\n# check for various functions\nINCLUDE(${CC_SOURCE_DIR}/cmake/CheckFunctions.cmake)\n# check for various types\nINCLUDE(${CC_SOURCE_DIR}/cmake/CheckTypes.cmake)\n\nIF(UNIX)\n  SEARCH_LIBRARY(LIBDL dlopen \"dl\")\n  IF(NOT ${LIBDL})\n    SEARCH_LIBRARY(LIBDL dlsym \"dl\")\n  ENDIF()\n  SEARCH_LIBRARY(LIBM floor m)\n  SEARCH_LIBRARY(LIBPTHREAD pthread_getspecific \"pthread;pthreads\")\n  SEARCH_LIBRARY(LIBNSL gethostbyname_r \"nsl_r;nsl\")\n  SEARCH_LIBRARY(LIBSOCKET setsockopt socket)\n  FIND_PACKAGE(Threads)\n  SET(CMAKE_REQUIRED_LIBRARIES ${CMAKE_REQUIRED_LIBRARIES} ${LIBNSL} ${LIBBIND} ${LIBICONV} ${LIBZ}\n    ${LIBSOCKET} ${LIBDL} ${LIBM} ${LIBPTHREAD})\n  SET(SYSTEM_LIBS ${SYSTEM_LIBS} ${LIBNSL} ${LIBBIND} ${LIBICONV} ${LIBZ}\n    ${LIBSOCKET} ${LIBDL} ${LIBM} ${LIBPTHREAD})\n  #remove possible dups from required libraries\n  LIST(LENGTH CMAKE_REQUIRED_LIBRARIES rllength)\n  IF(${rllength} GREATER 0)\n    LIST(REMOVE_DUPLICATES CMAKE_REQUIRED_LIBRARIES)\n  ENDIF()\nENDIF()\n\n\nIF(CMAKE_HAVE_PTHREAD_H)\n  SET(CMAKE_REQUIRED_INCLUDES pthread.h)\nENDIF()\n\nIF(DBUG_OFF)\n  ADD_DEFINITIONS(-DDBUG_OFF=1)\nENDIF()\n\nADD_DEFINITIONS(-DMARIADB_SYSTEM_TYPE=\"${CMAKE_SYSTEM_NAME}\")\nADD_DEFINITIONS(-DMARIADB_MACHINE_TYPE=\"${CMAKE_SYSTEM_PROCESSOR}\")\n\nIF(WIN32)\n  SET(HAVE_THREADS 1)\n  ADD_DEFINITIONS(-DHAVE_DLOPEN)\n  ADD_DEFINITIONS(-D_CRT_SECURE_NO_WARNINGS)\n  IF(MSVC)\n     SET(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} /wd4996\" )\n  ENDIF()\nELSEIF()\n  SET(HAVE_THREADS ${CMAKE_USE_PTHREADS})\nENDIF()\n\nIF(NOT DEFAULT_CHARSET)\n  SET(DEFAULT_CHARSET \"latin1\")\nENDIF()\n\n\n# convert SSL options to uppercase\nIF(WITH_SSL)\n  STRING(TOUPPER ${WITH_SSL} WITH_SSL)\nENDIF()\nIF(WITH_SSL STREQUAL \"ON\")\n  IF(WIN32)\n    SET(WITH_SSL \"SCHANNEL\")\n  ELSE()\n    SET(WITH_SSL \"OPENSSL\")\n  ENDIF()\nENDIF()\n\nIF(NOT WITH_SSL STREQUAL \"OFF\")\n  IF(WITH_SSL STREQUAL \"OPENSSL\")\n    IF (NOT OPENSSL_FOUND)\n      FIND_PACKAGE(OpenSSL)\n    ENDIF()\n    IF(OPENSSL_FOUND)\n      ADD_DEFINITIONS(-DHAVE_OPENSSL -DHAVE_TLS)\n      SET(SSL_SOURCES \"${CC_SOURCE_DIR}/libmariadb/secure/openssl.c\")\n      SET(SSL_LIBRARIES ${OPENSSL_SSL_LIBRARY} ${OPENSSL_CRYPTO_LIBRARY})\n      IF(WIN32)\n        CHECK_INCLUDE_FILES (${OPENSSL_INCLUDE_DIR}/openssl/applink.c HAVE_OPENSSL_APPLINK_C)\n      ENDIF()\n      INCLUDE_DIRECTORIES(BEFORE ${OPENSSL_INCLUDE_DIR})\n\n\n      TRY_RUN(LIBRESSL_RESULT HAVE_LIBRESSL\n              ${CMAKE_BINARY_DIR}\n              ${CC_SOURCE_DIR}/cmake/libressl_version.c\n              COMPILE_DEFINITIONS \"-I${OPENSSL_INCLUDE_DIR}\"\n              RUN_OUTPUT_VARIABLE LIBRESSL_VERSION)\n      IF(HAVE_LIBRESSL)\n        ADD_DEFINITIONS(-DHAVE_LIBRESSL)\n        SET(TLS_LIBRARY_VERSION ${LIBRESSL_VERSION})\n      ELSE()\n        SET(TLS_LIBRARY_VERSION \"OpenSSL ${OPENSSL_VERSION}\")\n      ENDIF()\n    ELSE()\n      MESSAGE1(TLS_LIBRARY_VERSION \"OpenSSL/LibreSSL not found\")\n    ENDIF()\n  ENDIF()\n  IF(WITH_SSL STREQUAL \"GNUTLS\")\n    FIND_PACKAGE(GnuTLS \"3.3.24\" REQUIRED)\n    IF(GNUTLS_FOUND)\n      ADD_DEFINITIONS(-DHAVE_GNUTLS -DHAVE_TLS)\n      SET(SSL_SOURCES \"${CC_SOURCE_DIR}/libmariadb/secure/gnutls.c\")\n      SET(SSL_LIBRARIES ${GNUTLS_LIBRARY})\n      SET(TLS_LIBRARY_VERSION \"GnuTLS ${GNUTLS_VERSION_STRING}\")\n      INCLUDE_DIRECTORIES(${GNUTLS_INCLUDE_DIR})\n    ELSE()\n      MESSAGE(FATAL_ERROR \"GnuTLS not found\")\n    ENDIF()\n  ENDIF()\n  IF(WIN32)\n    IF(WITH_SSL STREQUAL \"SCHANNEL\")\n      ADD_DEFINITIONS(-DHAVE_SCHANNEL -DHAVE_TLS)\n      SET(SSL_SOURCES \"${CC_SOURCE_DIR}/libmariadb/secure/schannel.c\"\n                      \"${CC_SOURCE_DIR}/libmariadb/secure/ma_schannel.c\"\n                      \"${CC_SOURCE_DIR}/libmariadb/secure/schannel_certs.c\")\n      INCLUDE_DIRECTORIES(\"${CC_SOURCE_DIR}/plugins/pvio/\")\n      SET(SSL_LIBRARIES secur32)\n      SET(TLS_LIBRARY_VERSION \"Schannel ${CMAKE_SYSTEM_VERSION}\")\n    ENDIF()\n  ENDIF()\n  MESSAGE1(TLS_LIBRARY_VERSION \"TLS library/version: ${TLS_LIBRARY_VERSION}\")\n\n  MARK_AS_ADVANCED(SSL_SOURCES)\nENDIF()\n\nSET(ENABLED_LOCAL_INFILE \"AUTO\" CACHE STRING \"If we should should enable LOAD DATA LOCAL by default (OFF/ON/AUTO)\")\nMARK_AS_ADVANCED(ENABLED_LOCAL_INFILE)\nIF (ENABLED_LOCAL_INFILE MATCHES \"^(0|FALSE)$\")\n  SET(ENABLED_LOCAL_INFILE OFF)\nELSEIF(ENABLED_LOCAL_INFILE MATCHES \"^(1|TRUE)$\")\n  SET(ENABLED_LOCAL_INFILE ON)\nELSEIF (NOT ENABLED_LOCAL_INFILE MATCHES \"^(ON|OFF|AUTO)$\")\n  MESSAGE(FATAL_ERROR \"ENABLED_LOCAL_INFILE must be one of OFF, ON, AUTO\")\nENDIF()\n\nIF(NOT WIN32)\n  INCLUDE(${CC_SOURCE_DIR}/cmake/FindIconv.cmake)\nENDIF()\n\nCONFIGURE_FILE(${CC_SOURCE_DIR}/include/ma_config.h.in\n               ${CC_BINARY_DIR}/include/ma_config.h)\nCONFIGURE_FILE(${CC_SOURCE_DIR}/include/ma_config.h.in\n               ${CC_BINARY_DIR}/include/config.h)\nCONFIGURE_FILE(${CC_SOURCE_DIR}/include/mariadb_version.h.in\n               ${CC_BINARY_DIR}/include/mariadb_version.h)\n\nINCLUDE_DIRECTORIES(${CC_BINARY_DIR}/include)\n\nIF(WIN32)\n  SET(SYSTEM_LIBS ws2_32 advapi32 kernel32 shlwapi crypt32 ${LIBZ})\nELSE()\n  SET(SYSTEM_LIBS ${SYSTEM_LIBS} ${LIBPTHREAD} ${LIBDL} ${LIBM})\n  IF(ICONV_EXTERNAL)\n    SET(SYSTEM_LIBS ${SYSTEM_LIBS} ${ICONV_LIBRARIES})\n  ENDIF()\nENDIF()\nIF(WITH_SSL)\n  SET(SYSTEM_LIBS ${SYSTEM_LIBS} ${SSL_LIBRARIES})\nENDIF()\nMESSAGE1(SYSTEM_LIBS \"SYSTEM_LIBS ${SYSTEM_LIBS}\")\nMARK_AS_ADVANCED(SYSTEM_LIBS)\n\nIF(NOT REMOTEIO_PLUGIN_TYPE MATCHES \"OFF\")\n  IF(CURL_FOUND)\n    INCLUDE_DIRECTORIES(${CURL_INCLUDE_DIRS})\n    IF(REMOTEIO_PLUGIN_TYPE MATCHES \"STATIC\")\n      SET(SYSTEM_LIBS ${SYSTEM_LIBS} ${CURL_LIBRARIES})\n    ENDIF()\n    ADD_DEFINITIONS(\"-DHAVE_REMOTEIO=1\")\n  ENDIF()\nENDIF()\nIF(NOT WIN32)\n  IF(NOT AUTH_GSSAPI_PLUGIN_TYPE MATCHES \"OFF\")\n    INCLUDE(${CC_SOURCE_DIR}/cmake/FindGSSAPI.cmake)\n    IF(GSSAPI_FOUND)\n      INCLUDE_DIRECTORIES(${GSSAPI_INCS})\n      IF(AUTH_GSSAPI_PLUGIN_TYPE MATCHES \"STATIC\")\n        SET(SYSTEM_LIBS ${SYSTEM_LIBS} ${GSSAPI_LIBS})\n      ENDIF()\n    ENDIF()\n  ENDIF()\nENDIF()\nINCLUDE(${CC_SOURCE_DIR}/plugins/CMakeLists.txt)\nADD_SUBDIRECTORY(include)\nADD_SUBDIRECTORY(libmariadb)\nIF(NOT WIN32)\n  ADD_SUBDIRECTORY(mariadb_config)\nENDIF()\n\nIF(IS_DIRECTORY ${CC_SOURCE_DIR}/unittest)\n  IF(WITH_UNIT_TESTS)\n    ADD_SUBDIRECTORY(unittest/mytap)\n    ADD_SUBDIRECTORY(unittest/libmariadb)\n  ENDIF()\nENDIF()\n\nIF(CLIENT_DOCS)\n  INSTALL(DIRECTORY ${CLIENT_DOCS}\n          DESTINATION ${DOCS_INSTALL_DIR_${INSTALL_LAYOUT}}\n          COMPONENT SharedLibraries)\nENDIF()\n\n\nIF(WIN32 AND WITH_MSI AND CMAKE_BUILD_TYPE STREQUAL \"RelWithDebInfo\")\n  ADD_SUBDIRECTORY(win/packaging)\nENDIF()\nMESSAGE1(SYSTEM_PROCESSOR \"SYSTEM processor: ${CMAKE_SYSTEM_PROCESSOR}\")\nSET(CPACK_PACKAGE_VENDOR \"MariaDB Corporation Ab\")\nSET(CPACK_PACKAGE_DESCRIPTION \"MariaDB Connector/C. A library for connecting to MariaDB and MySQL servers\")\nSET(CPACK_PACKAGE_NAME \"mariadb_connector_c\")\nSTRING(TOLOWER ${CMAKE_SYSTEM_NAME} system_name)\nSET(CPACK_RESOURCE_FILE_LICENSE \"${CC_SOURCE_DIR}/COPYING.LIB\")\nSET(CPACK_PACKAGE_DESCRIPTION_FILE \"${CC_SOURCE_DIR}/README\")\nINCLUDE(cmake/ConnectorName.cmake)\nIF(NOT PACKAGE_STATUS_SUFFIX)\n  SET(CPACK_SOURCE_PACKAGE_FILE_NAME \"mariadb-connector-c-${CPACK_PACKAGE_VERSION}-src\")\n  SET(CPACK_PACKAGE_FILE_NAME \"mariadb-connector-c-${CPACK_PACKAGE_VERSION}-${system_name}-${CMAKE_SYSTEM_PROCESSOR}\")\nELSE()\n  SET(CPACK_SOURCE_PACKAGE_FILE_NAME \"mariadb-connector-c-${CPACK_PACKAGE_VERSION}-${PACKAGE_STATUS_SUFFIX}-src\")\n  SET(CPACK_PACKAGE_FILE_NAME \"mariadb-connector-c-${CPACK_PACKAGE_VERSION}-${PACKAGE_STATUS_SUFFIX}-${system_name}-${CMAKE_SYSTEM_PROCESSOR}\")\nENDIF()\n# Build source packages\nIF(GIT_BUILD_SRCPKG)\n  # get branch name\n  EXECUTE_PROCESS(COMMAND ${GIT_EXECUTABLE} show-branch OUTPUT_VARIABLE git_branch)\n  STRING(REGEX MATCH \"\\\\[([^]]+)\\\\]\" git_branch ${git_branch})\n  STRING(REGEX REPLACE \"\\\\[|\\\\]\" \"\" GIT_BRANCH ${git_branch})\n  MESSAGE1(GIT_BRANCH \"${GIT_BRANCH}\")\n  IF(WIN32)\n    EXECUTE_PROCESS(COMMAND ${GIT_EXECUTABLE} archive ${GIT_BRANCH} --format=zip --prefix=${CPACK_SOURCE_PACKAGE_FILE_NAME}/ --output=${CPACK_SOURCE_PACKAGE_FILE_NAME}.zip)\n  ELSE()\n    EXECUTE_PROCESS(COMMAND ${GIT_EXECUTABLE} archive ${GIT_BRANCH} --format=zip --prefix=${CPACK_SOURCE_PACKAGE_FILE_NAME}/ --output=${CPACK_SOURCE_PACKAGE_FILE_NAME}.zip)\n    EXECUTE_PROCESS(COMMAND ${GIT_EXECUTABLE} archive ${GIT_BRANCH} --format=tar --prefix=${CPACK_SOURCE_PACKAGE_FILE_NAME}/ --output=${CPACK_SOURCE_PACKAGE_FILE_NAME}.tar)\n    EXECUTE_PROCESS(COMMAND gzip -9 -f ${CPACK_SOURCE_PACKAGE_FILE_NAME}.tar)\n  ENDIF()\nENDIF()\n\nSET(CPACK_SOURCE_IGNORE_FILES\n\\\\\\\\.git/\n\\\\\\\\.gitignore\n\\\\\\\\.gitattributes\nCMakeCache\\\\\\\\.txt\ncmake_dist\\\\\\\\.cmake\nCPackConfig\\\\\\\\.cmake\nmariadb_config\\\\\\\\.c$\n\\\\\\\\.build/\nhtml/\nunittest\n/cmake_install.cmake\n/CTestTestfile.cmake\n/CPackSourceConfig.cmake\n/CMakeFiles/\n/version_resources/\n/_CPack_Packages/\n\\\\\\\\.gz$\n\\\\\\\\.zip$\nmariadb_config/mariadb_config$\n/CMakeFiles/\n/version_resources/\n/_CPack_Packages/\nMakefile$\ninclude/my_config\\\\\\\\.h$\n)\n\nIF(WITH_TEST_SRCPKG)\n  SET(PACKAGE_FILE ${CC_SOURCE_DIR}/package.name)\n  FILE(REMOVE ${PACKAGE_FILE})\n  FILE(WRITE ${PACKAGE_FILE} ${CPACK_SOURCE_PACKAGE_FILE_NAME})\nENDIF()\n\nIF(WIN32)\n  SET(CPACK_GENERATOR \"ZIP\")\n  SET(CPACK_SOURCE_GENERATOR \"ZIP\")\nELSE()\n  SET(CPACK_GENERATOR \"TGZ\")\n  SET(CPACK_SOURCE_GENERATOR \"TGZ\")\nENDIF()\nINCLUDE(CPack)\n\nIF(WITH_EXTERNAL_ZLIB)\n  SET(zlib_status ${WITH_EXTERNAL_ZLIB})\nELSE()\n  SET(zlib_status \"yes (using bundled zlib)\")\nENDIF()\n\nMESSAGE1(STATUS \"MariaDB Connector/c configuration:\n-- Static PLUGINS ${PLUGINS_STATIC}\n-- Dynamic PLUGINS ${PLUGINS_DYNAMIC}\n-- CPack generation: ${CPACK_GENERATOR}\n-- SSL support: ${WITH_SSL} Libs: ${SSL_LIBRARIES}\n-- Zlib support: ${zlib_status}\n-- Installation layout: ${INSTALL_LAYOUT}\n-- Include files will be installed in ${INSTALL_INCLUDEDIR}\n-- Libraries will be installed in ${INSTALL_LIBDIR}\n-- Binaries will be installed in ${INSTALL_BINDIR}\n-- Documentation included from ${CLIENT_DOCS}\n-- Required: ${CMAKE_REQUIRED_LIBRARIES}\")\n",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/libmariadb/include/ma_global.h": "/* Copyright (C) 2000 MySQL AB & MySQL Finland AB & TCX DataKonsult AB\n   \n   This library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Library General Public\n   License as published by the Free Software Foundation; either\n   version 2 of the License, or (at your option) any later version.\n   \n   This library is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Library General Public License for more details.\n   \n   You should have received a copy of the GNU Library General Public\n   License along with this library; if not, write to the Free\n   Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n   MA 02111-1301, USA */\n\n/* This is the main include file that should included 'first' in every\n   C file. */\n\n#ifndef _global_h\n#define _global_h\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <windows.h>\n#include <stdlib.h>\n#define strcasecmp _stricmp\n#define sleep(x) Sleep(1000*(x))\n#ifdef _MSC_VER\n#define inline __inline\n#if _MSC_VER < 1900\n#define snprintf _snprintf\n#endif\n#endif\n#define STDCALL __stdcall \n#endif\n\n#include <ma_config.h>\n#include <assert.h>\n#ifndef __GNUC__\n#define  __attribute(A)\n#endif\n\n/* Fix problem with S_ISLNK() on Linux */\n#if defined(HAVE_LINUXTHREADS)\n#undef  _GNU_SOURCE\n#define _GNU_SOURCE 1\n#endif\n\n/* The client defines this to avoid all thread code */\n#if defined(UNDEF_THREADS_HACK)\n#undef THREAD\n#undef HAVE_mit_thread\n#undef HAVE_LINUXTHREADS\n#undef HAVE_UNIXWARE7_THREADS\n#endif\n\n#ifdef HAVE_THREADS_WITHOUT_SOCKETS\n/* MIT pthreads does not work with unix sockets */\n#undef HAVE_SYS_UN_H\n#endif\n\n#define __EXTENSIONS__ 1\t/* We want some extension */\n#ifndef __STDC_EXT__\n#define __STDC_EXT__ 1          /* To get large file support on hpux */\n#endif\n\n#if defined(THREAD) && !defined(_WIN32)\n#ifndef _POSIX_PTHREAD_SEMANTICS\n#define _POSIX_PTHREAD_SEMANTICS /* We want posix threads */\n#endif\n/* was #if defined(HAVE_LINUXTHREADS) || defined(HAVE_DEC_THREADS) || defined(HPUX) */\n#if !defined(SCO)\n#define _REENTRANT\t1\t/* Some thread libraries require this */\n#endif\n#if !defined(_THREAD_SAFE) && !defined(_AIX)\n#define _THREAD_SAFE            /* Required for OSF1 */\n#endif\n#ifndef HAVE_mit_thread\n#ifdef HAVE_UNIXWARE7_THREADS\n#include <thread.h>\n#else\n#include <pthread.h>\t\t/* AIX must have this included first */\n#endif /* HAVE_UNIXWARE7_THREADS */\n#endif /* HAVE_mit_thread */\n#if !defined(SCO) && !defined(_REENTRANT)\n#define _REENTRANT\t1\t/* Threads requires reentrant code */\n#endif\n#endif /* THREAD */\n\n/* Go around some bugs in different OS and compilers */\n#ifdef _AIX\t\t\t/* By soren@t.dk */\n#define _H_STRINGS\n#define _SYS_STREAM_H\n#define _AIX32_CURSES\n#define ulonglong2double(A) my_ulonglong2double(A)\n#define my_off_t2double(A)  my_ulonglong2double(A)\n#ifdef\t__cplusplus\nextern \"C\" {\n#endif\ndouble my_ulonglong2double(unsigned long long A);\n#ifdef\t__cplusplus\n}\n#endif\n#endif /* _AIX */\n\n#ifdef HAVE_BROKEN_SNPRINTF\t/* HPUX 10.20 don't have this defined */\n#undef HAVE_SNPRINTF\n#endif\n#if defined(HAVE_BROKEN_INLINE) && !defined(__cplusplus)\n#undef inline\n#define inline\n#endif\n\n#ifdef UNDEF_HAVE_GETHOSTBYNAME_R\t\t/* For OSF4.x */\n#undef HAVE_GETHOSTBYNAME_R\n#endif\n#ifdef UNDEF_HAVE_INITGROUPS\t\t\t/* For AIX 4.3 */\n#undef HAVE_INITGROUPS\n#endif\n\n/* Fix a bug in gcc 2.8.0 on IRIX 6.2 */\n#if SIZEOF_LONG == 4 && defined(__LONG_MAX__)\n#undef __LONG_MAX__             /* Is a longlong value in gcc 2.8.0 ??? */\n#define __LONG_MAX__ 2147483647\n#endif\n\n/* Fix problem when linking c++ programs with gcc 3.x */\n#ifdef DEFINE_CXA_PURE_VIRTUAL\n#define FIX_GCC_LINKING_PROBLEM extern \"C\" { int __cxa_pure_virtual() {return 0;} }\n#else\n#define FIX_GCC_LINKING_PROBLEM\n#endif\n\n/* egcs 1.1.2 has a problem with memcpy on Alpha */\n#if defined(__GNUC__) && defined(__alpha__) && ! (__GNUC__ > 2 || (__GNUC__ == 2 &&  __GNUC_MINOR__ >= 95))\n#define BAD_MEMCPY\n#endif\n\n/* In Linux-alpha we have atomic.h if we are using gcc */\n#if defined(HAVE_LINUXTHREADS) && defined(__GNUC__) && defined(__alpha__) && (__GNUC__ > 2 || ( __GNUC__ == 2 &&  __GNUC_MINOR__ >= 95)) && !defined(HAVE_ATOMIC_ADD)\n#define HAVE_ATOMIC_ADD\n#define HAVE_ATOMIC_SUB\n#endif\n\n/* In Linux-ia64 including atomic.h will give us an error */\n#if (defined(HAVE_LINUXTHREADS) && defined(__GNUC__) && (defined(__ia64__) || defined(__powerpc64__))) || !defined(THREAD)\n#undef HAVE_ATOMIC_ADD\n#undef HAVE_ATOMIC_SUB\n#endif\n\n#if defined(_lint) && !defined(lint)\n#define lint\n#endif\n#if SIZEOF_LONG_LONG > 4 && !defined(_LONG_LONG)\n#define _LONG_LONG 1\t\t/* For AIX string library */\n#endif\n\n#ifndef stdin\n#include <stdio.h>\n#endif\n#ifdef HAVE_STDLIB_H\n#include <stdlib.h>\n#endif\n#ifdef HAVE_STDDEF_H\n#include <stddef.h>\n#endif\n\n#include <math.h>\n#ifdef HAVE_LIMITS_H\n#include <limits.h>\n#endif\n#ifdef HAVE_FLOAT_H\n#include <float.h>\n#endif\n\n#ifdef HAVE_SYS_TYPES_H\n#include <sys/types.h>\n#endif\n#ifdef HAVE_FCNTL_H\n#include <fcntl.h>\n#endif\n#if defined(TIME_WITH_SYS_TIME)\n# include <sys/time.h>\n# include <time.h>\n#else\n# if defined(HAVE_SYS_TIME_H)\n#  include <sys/time.h>\n# else\n#  include <time.h>\n# endif\n#endif /* TIME_WITH_SYS_TIME */\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n#if defined(__cplusplus) && defined(NO_CPLUSPLUS_ALLOCA)\n#undef HAVE_ALLOCA\n#undef HAVE_ALLOCA_H\n#endif\n#ifdef HAVE_ALLOCA_H\n#include <alloca.h>\n#endif\n#ifdef HAVE_ATOMIC_ADD\n#define __SMP__\n#define CONFIG_SMP\n#include <asm/atomic.h>\n#endif\n#include <errno.h>\t\t\t\t/* Recommended by debian */\n#include <assert.h>\n\n/* Go around some bugs in different OS and compilers */\n#if defined(_HPUX_SOURCE) && defined(HAVE_SYS_STREAM_H)\n#include <sys/stream.h>\t\t/* HPUX 10.20 defines ulong here. UGLY !!! */\n#define HAVE_ULONG\n#endif\n#ifdef DONT_USE_FINITE\t\t/* HPUX 11.x has is_finite() */\n#undef HAVE_FINITE\n#endif\n#if defined(HPUX) && defined(_LARGEFILE64_SOURCE) && defined(THREAD)\n/* Fix bug in setrlimit */\n#undef setrlimit\n#define setrlimit cma_setrlimit64\n#endif\n\n/* We can not live without these */\n\n#define USE_MYFUNC 1\t\t/* Must use syscall indirection */\n#define MASTER 1\t\t/* Compile without unireg */\n#define ENGLISH 1\t\t/* Messages in English */\n#define POSIX_MISTAKE 1\t\t/* regexp: Fix stupid spec error */\n#define USE_REGEX 1\t\t/* We want the use the regex library */\n/* Do not define for ultra sparcs */\n#define USE_BMOVE512 1\t\t/* Use this unless the system bmove is faster */\n\n/* Paranoid settings. Define I_AM_PARANOID if you are paranoid */\n#ifdef I_AM_PARANOID\n#define DONT_ALLOW_USER_CHANGE 1\n#define DONT_USE_MYSQL_PWD 1\n#endif\n\n/* #define USE_some_charset 1 was deprecated by changes to configure */\n/* my_ctype my_to_upper, my_to_lower, my_sort_order gain theit right value */\n/* automagically during configuration */\n\n/* Does the system remember a signal handler after a signal ? */\n#ifndef HAVE_BSD_SIGNALS\n#define DONT_REMEMBER_SIGNAL\n#endif\n\n\n#if defined(_lint) || defined(FORCE_INIT_OF_VARS)\n#define LINT_INIT(var)\tvar=0\t\t\t/* No uninitialize-warning */\n#define LINT_INIT_STRUCT(var) memset(&var, 0, sizeof(var)) /* No uninitialize-warning */\n#else\n#define LINT_INIT(var)\n#define LINT_INIT_STRUCT(var)\n#endif\n\n/* Define some useful general macros */\n#if defined(__cplusplus) && defined(__GNUC__)\n#define max(a, b)\t((a) >? (b))\n#define min(a, b)\t((a) <? (b))\n#elif !defined(max)\n#define max(a, b)\t((a) > (b) ? (a) : (b))\n#define min(a, b)\t((a) < (b) ? (a) : (b))\n#endif\n\n#if defined(__EMX__) || !defined(HAVE_UINT)\ntypedef unsigned int uint;\ntypedef unsigned short ushort;\n#endif\n\n#define sgn(a)\t\t(((a) < 0) ? -1 : ((a) > 0) ? 1 : 0)\n#define swap(t,a,b)\t{ register t dummy; dummy = a; a = b; b = dummy; }\n#define test(a)\t\t((a) ? 1 : 0)\n#define set_if_bigger(a,b)  { if ((a) < (b)) (a)=(b); }\n#define set_if_smaller(a,b) { if ((a) > (b)) (a)=(b); }\n#define test_all_bits(a,b) (((a) & (b)) == (b))\n#define set_bits(type, bit_count) (sizeof(type)*8 <= (bit_count) ? ~(type) 0 : ((((type) 1) << (bit_count)) - (type) 1))\n#define array_elements(A) ((uint) (sizeof(A)/sizeof(A[0])))\n#ifndef HAVE_RINT\n#define rint(A) floor((A)+0.5)\n#endif\n\n/* Define some general constants */\n#ifndef TRUE\n#define TRUE\t\t(1)\t/* Logical true */\n#define FALSE\t\t(0)\t/* Logical false */\n#endif\n\n#if defined(__GNUC__)\n#define function_volatile\tvolatile\n#ifndef my_reinterpret_cast\n#define my_reinterpret_cast(A) reinterpret_cast<A>\n#endif\n#define my_const_cast(A) const_cast<A>\n#elif !defined(my_reinterpret_cast)\n#define my_reinterpret_cast(A) (A)\n#define my_const_cast(A) (A)\n#endif\n#if !defined(__GNUC__) && !defined(__clang__)\n#define __attribute__(A)\n#endif\n\n/* From old s-system.h */\n\n/*\n  Support macros for non ansi & other old compilers. Since such\n  things are no longer supported we do nothing. We keep then since\n  some of our code may still be needed to upgrade old customers.\n*/\n#define _VARARGS(X) X\n#define _STATIC_VARARGS(X) X\n\n#if defined(DBUG_ON) && defined(DBUG_OFF)\n#undef DBUG_OFF\n#endif\n\n#if defined(_lint) && !defined(DBUG_OFF)\n#define DBUG_OFF\n#endif\n\n#define MIN_ARRAY_SIZE\t0\t/* Zero or One. Gcc allows zero*/\n#define ASCII_BITS_USED 8\t/* Bit char used */\n#define NEAR_F\t\t\t/* No near function handling */\n\n/* Some types that is different between systems */\n\ntypedef int\tFile;\t\t/* File descriptor */\n#ifndef my_socket_defined\n#define my_socket_defined\n#if defined(_WIN64)\n#define my_socket unsigned long long\n#elif defined(_WIN32)\n#define my_socket unsigned int\n#else\ntypedef int my_socket;\n#endif\n#define my_socket_defined\n#endif\n#ifndef INVALID_SOCKET\n#define INVALID_SOCKET -1\n#endif\n\n#if defined(__GNUC__) && !defined(_lint)\ntypedef char\tpchar;\t\t/* Mixed prototypes can take char */\ntypedef char\tpuchar;\t\t/* Mixed prototypes can take char */\ntypedef char\tpbool;\t\t/* Mixed prototypes can take char */\ntypedef short\tpshort;\t\t/* Mixed prototypes can take short int */\ntypedef float\tpfloat;\t\t/* Mixed prototypes can take float */\n#else\ntypedef int\tpchar;\t\t/* Mixed prototypes can't take char */\ntypedef uint\tpuchar;\t\t/* Mixed prototypes can't take char */\ntypedef int\tpbool;\t\t/* Mixed prototypes can't take char */\ntypedef int\tpshort;\t\t/* Mixed prototypes can't take short int */\ntypedef double\tpfloat;\t\t/* Mixed prototypes can't take float */\n#endif\ntypedef int\t(*qsort_cmp)(const void *,const void *);\n#ifdef HAVE_mit_thread\n#define qsort_t void\n#undef QSORT_TYPE_IS_VOID\n#define QSORT_TYPE_IS_VOID\n#else\n#define qsort_t RETQSORTTYPE\t/* Broken GCC can't handle typedef !!!! */\n#endif\n\n#ifdef HAVE_SYS_SOCKET_H\n#include <sys/socket.h>\n#endif\ntypedef SOCKET_SIZE_TYPE size_socket;\n\n#ifndef SOCKOPT_OPTLEN_TYPE\n#define SOCKOPT_OPTLEN_TYPE size_socket\n#endif\n\n/* file create flags */\n\n#ifndef O_SHARE\n#define O_SHARE\t\t0\t/* Flag to my_open for shared files */\n#ifndef O_BINARY\n#define O_BINARY\t0\t/* Flag to my_open for binary files */\n#endif\n#define FILE_BINARY\t0\t/* Flag to my_fopen for binary streams */\n#ifdef HAVE_FCNTL\n#define HAVE_FCNTL_LOCK\n#define F_TO_EOF\t0L\t/* Param to lockf() to lock rest of file */\n#endif\n#endif /* O_SHARE */\n#ifndef O_TEMPORARY\n#define O_TEMPORARY\t0\n#endif\n#ifndef O_SHORT_LIVED\n#define O_SHORT_LIVED\t0\n#endif\n\n/* #define USE_RECORD_LOCK\t*/\n\n\t/* Unsigned types supported by the compiler */\n#define UNSINT8\t\t\t/* unsigned int8 (char) */\n#define UNSINT16\t\t/* unsigned int16 */\n#define UNSINT32\t\t/* unsigned int32 */\n\n\t/* General constants */\n#define SC_MAXWIDTH\t256\t/* Max width of screen (for error messages) */\n#define FN_LEN\t\t256\t/* Max file name len */\n#define FN_HEADLEN\t253\t/* Max length of filepart of file name */\n#define FN_EXTLEN\t20\t/* Max length of extension (part of FN_LEN) */\n#define FN_REFLEN\t512\t/* Max length of full path-name */\n#define FN_EXTCHAR\t'.'\n#define FN_HOMELIB\t'~'\t/* ~/ is used as abbrev for home dir */\n#define FN_CURLIB\t'.'\t/* ./ is used as abbrev for current dir */\n#define FN_PARENTDIR\t\"..\"\t/* Parentdirectory; Must be a string */\n#define FN_DEVCHAR\t':'\n\n#ifndef FN_LIBCHAR\n#ifdef _WIN32\n#define FN_LIBCHAR\t'\\\\'\n#define FN_ROOTDIR\t\"\\\\\"\n#else\n#define FN_LIBCHAR\t'/'\n#define FN_ROOTDIR\t\"/\"\n#endif\n#define MY_NFILE\t1024\t/* This is only used to save filenames */\n#endif\n\n/* #define EXT_IN_LIBNAME     */\n/* #define FN_NO_CASE_SENCE   */\n/* #define FN_UPPER_CASE TRUE */\n\n/*\n  Io buffer size; Must be a power of 2 and a multiple of 512. May be\n  smaller what the disk page size. This influences the speed of the\n  isam btree library. eg to big to slow.\n*/\n#define IO_SIZE\t\t\t4096\n/*\n  How much overhead does malloc have. The code often allocates\n  something like 1024-MALLOC_OVERHEAD bytes\n*/\n#define MALLOC_OVERHEAD 8\n\t/* get memory in huncs */\n#define ONCE_ALLOC_INIT\t\t(uint) (4096-MALLOC_OVERHEAD)\n\t/* Typical record cash */\n#define RECORD_CACHE_SIZE\t(uint) (64*1024-MALLOC_OVERHEAD)\n\t/* Typical key cash */\n#define KEY_CACHE_SIZE\t\t(uint) (8*1024*1024-MALLOC_OVERHEAD)\n\n\t/* Some things that this system doesn't have */\n\n#define ONLY_OWN_DATABASES\t/* We are using only databases by monty */\n#define NO_PISAM\t\t/* Not needed anymore */\n#define NO_MISAM\t\t/* Not needed anymore */\n#define NO_HASH\t\t\t/* Not needed anymore */\n#ifdef _WIN32\n#define NO_DIR_LIBRARY\t\t/* Not standard dir-library */\n#define USE_MY_STAT_STRUCT\t/* For my_lib */\n#ifdef _MSC_VER\ntypedef SSIZE_T ssize_t;\n#endif\n#endif\n\n/* Some things that this system does have */\n\n#ifndef HAVE_ITOA\n#define USE_MY_ITOA\t\t/* There is no itoa */\n#endif\n\n/* Some defines of functions for portability */\n\n#ifndef HAVE_ATOD\n#define atod\t\tatof\n#endif\n#ifdef USE_MY_ATOF\n#define atof\t\tmy_atof\nextern void\t\tinit_my_atof(void);\nextern double\t\tmy_atof(const char*);\n#endif\n#undef remove\t\t/* Crashes MySQL on SCO 5.0.0 */\n#ifndef _WIN32\n#define closesocket(A)\tclose(A)\n#endif\n#ifndef ulonglong2double\n#define ulonglong2double(A) ((double) (A))\n#define my_off_t2double(A)  ((double) (A))\n#endif\n\n\n#ifndef offsetof\n#define offsetof(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)\n#endif\n#define ulong_to_double(X) ((double) (ulong) (X))\n#define SET_STACK_SIZE(X)\t/* Not needed on real machines */\n\n\n#ifdef HAVE_LINUXTHREADS\n/* #define pthread_sigmask(A,B,C) sigprocmask((A),(B),(C)) */\n/* #define sigset(A,B) signal((A),(B)) */\n#endif\n\n#if defined(_lint) || defined(FORCE_INIT_OF_VARS) || \\\n    defined(__cplusplus) || !defined(__GNUC__)\n#define UNINIT_VAR(x) x= 0\n#else\n/* GCC specific self-initialization which inhibits the warning. */\n#define UNINIT_VAR(x) x= x\n#endif\n\n\n/* This is from the old m-machine.h file */\n\n#if SIZEOF_LONG_LONG > 4\n#define HAVE_LONG_LONG 1\n#endif\n\n#if defined(HAVE_LONG_LONG) && !defined(LONGLONG_MIN)\n#define LONGLONG_MIN\t((long long) 0x8000000000000000LL)\n#define LONGLONG_MAX\t((long long) 0x7FFFFFFFFFFFFFFFLL)\n#endif\n\n\n#define INT_MIN64       (~0x7FFFFFFFFFFFFFFFLL)\n#define INT_MAX64       0x7FFFFFFFFFFFFFFFLL\n#define INT_MIN32       (~0x7FFFFFFFL)\n#define INT_MAX32       0x7FFFFFFFL\n#define UINT_MAX32      0xFFFFFFFFL\n#define INT_MIN24       (~0x007FFFFF)\n#define INT_MAX24       0x007FFFFF\n#define UINT_MAX24      0x00FFFFFF\n#define INT_MIN16       (~0x7FFF)\n#define INT_MAX16       0x7FFF\n#define UINT_MAX16      0xFFFF\n#define INT_MIN8        (~0x7F)\n#define INT_MAX8        0x7F\n#define UINT_MAX8       0xFF\n\n#ifndef ULL\n#ifdef HAVE_LONG_LONG\n#define ULL(A) A ## ULL\n#else\n#define ULL(A) A ## UL\n#endif\n#endif\n\n#if defined(HAVE_LONG_LONG) && !defined(ULONGLONG_MAX)\n/* First check for ANSI C99 definition: */\n#ifdef ULLONG_MAX\n#define ULONGLONG_MAX  ULLONG_MAX\n#else\n#define ULONGLONG_MAX ((unsigned long long)(~0ULL))\n#endif\n#endif /* defined (HAVE_LONG_LONG) && !defined(ULONGLONG_MAX)*/\n\n/* From limits.h instead */\n#ifndef DBL_MIN\n#define DBL_MIN\t\t4.94065645841246544e-324\n#define FLT_MIN\t\t((float)1.40129846432481707e-45)\n#endif\n#ifndef DBL_MAX\n#define DBL_MAX\t\t1.79769313486231470e+308\n#define FLT_MAX\t\t((float)3.40282346638528860e+38)\n#endif\n\n/*\n  Max size that must be added to a so that we know Size to make\n  addressable obj.\n*/\ntypedef long my_ptrdiff_t;\n#define MY_ALIGN(A,L)\t(((A) + (L) - 1) & ~((L) - 1))\n#define ALIGN_SIZE(A)\tMY_ALIGN((A),sizeof(double))\n/* Size to make addressable obj. */\n#define ALIGN_PTR(A, t) ((t*) MY_ALIGN((A),sizeof(t)))\n\t\t\t /* Offset of filed f in structure t */\n#define OFFSET(t, f)\t((size_t)(char *)&((t *)0)->f)\n#define ADD_TO_PTR(ptr,size,type) (type) ((unsigned char*) (ptr)+size)\n#define PTR_BYTE_DIFF(A,B) (my_ptrdiff_t) ((unsigned char*) (A) - (unsigned char*) (B))\n\n#define NullS\t\t(char *) 0\n/* Nowadays we do not support MessyDos */\n#ifndef NEAR\n#define NEAR\t\t\t\t/* Who needs segments ? */\n#define FAR\t\t\t\t/* On a good machine */\n#ifndef HUGE_PTR\n#define HUGE_PTR\n#endif\n#endif\n#if defined(__IBMC__) || defined(__IBMCPP__)\n#define STDCALL _System _Export\n#elif !defined( STDCALL)\n#define STDCALL\n#endif\n\n/* Typdefs for easyier portability */\n\n#if defined(VOIDTYPE)\ntypedef void\t*gptr;\t\t/* Generic pointer */\n#else\ntypedef char\t*gptr;\t\t/* Generic pointer */\n#endif\n#ifndef HAVE_INT_8_16_32\ntypedef char\tint8;\t\t/* Signed integer >= 8\tbits */\ntypedef short\tint16;\t\t/* Signed integer >= 16 bits */\n#endif\n#ifndef HAVE_UCHAR\ntypedef unsigned char\tuchar;\t/* Short for unsigned char */\n#endif\ntypedef unsigned char\tuint8;\t/* Short for unsigned integer >= 8  bits */\ntypedef unsigned short\tuint16; /* Short for unsigned integer >= 16 bits */\n\n#if SIZEOF_INT == 4\n#ifndef HAVE_INT_8_16_32\ntypedef int\t\tint32;\n#endif\ntypedef unsigned int\tuint32; /* Short for unsigned integer >= 32 bits */\n#elif SIZEOF_LONG == 4\n#ifndef HAVE_INT_8_16_32\ntypedef long\t\tint32;\n#endif\ntypedef unsigned long\tuint32; /* Short for unsigned integer >= 32 bits */\n#else\n#error \"Neither int or long is of 4 bytes width\"\n#endif\n\n#if !defined(HAVE_ULONG) && !defined(HAVE_LINUXTHREADS) && !defined(__USE_MISC)\ntypedef unsigned long\tulong;\t/* Short for unsigned long */\n#endif\n#ifndef longlong_defined\n#if defined(HAVE_LONG_LONG) && SIZEOF_LONG != 8\ntypedef unsigned long long int ulonglong; /* ulong or unsigned long long */\ntypedef long long int longlong;\n#else\ntypedef unsigned long\tulonglong;\t/* ulong or unsigned long long */\ntypedef long\t\tlonglong;\n#endif\n#define longlong_defined\n#endif\n\n#ifndef HAVE_INT64\ntypedef longlong int64;\n#endif\n#ifndef HAVE_UINT64\ntypedef ulonglong uint64;\n#endif\n\n#ifndef MIN\n#define MIN(a,b) (((a) < (b)) ? (a) : (b))\n#endif\n#ifndef MAX\n#define MAX(a,b) (((a) > (b)) ? (a) : (b))\n#endif\n#define CMP_NUM(a,b)    (((a) < (b)) ? -1 : ((a) == (b)) ? 0 : 1)\n#ifdef USE_RAID\n/*\n  The following is done with a if to not get problems with pre-processors\n  with late define evaluation\n*/\n#if defined(SIZEOF_OFF_T) && SIZEOF_OFF_T == 4\n#define SYSTEM_SIZEOF_OFF_T 4\n#else\n#define SYSTEM_SIZEOF_OFF_T 8\n#endif\n#undef  SIZEOF_OFF_T\n#define SIZEOF_OFF_T\t    8\n#else\n#define SYSTEM_SIZEOF_OFF_T SIZEOF_OFF_T\n#endif /* USE_RAID */\n\n#if defined(SIZEOF_OFF_T) && SIZEOF_OFF_T > 4\ntypedef ulonglong my_off_t;\n#else\ntypedef unsigned long my_off_t;\n#endif\n#define MY_FILEPOS_ERROR\t(~(my_off_t) 0)\n#ifndef _WIN32\ntypedef off_t os_off_t;\n#endif\n\n#if defined(_WIN32)\n#define socket_errno\tWSAGetLastError()\n#define SOCKET_EINTR\tWSAEINTR \n#define SOCKET_EAGAIN\tWSAEWOULDBLOCK\n#define SOCKET_ENFILE\tENFILE\n#define SOCKET_EMFILE\tEMFILE\n#define SOCKET_EWOULDBLOCK WSAEWOULDBLOCK\n#else /* Unix */\n#define socket_errno\terrno\n#define closesocket(A)\tclose(A)\n#define SOCKET_EINTR\tEINTR\n#define SOCKET_EAGAIN\tEAGAIN\n#define SOCKET_EWOULDBLOCK EWOULDBLOCK\n#define SOCKET_ENFILE\tENFILE\n#define SOCKET_EMFILE\tEMFILE\n#endif\n\ntypedef uint8\t\tint7;\t/* Most effective integer 0 <= x <= 127 */\ntypedef short\t\tint15;\t/* Most effective integer 0 <= x <= 32767 */\ntypedef char\t\t*my_string; /* String of characters */\ntypedef unsigned long\tsize_s; /* Size of strings (In string-funcs) */\ntypedef int\t\tmyf;\t/* Type of MyFlags in my_funcs */\ntypedef char\t\tmy_bool; /* Small bool */\ntypedef unsigned long long my_ulonglong;\n#if !defined(bool) && !defined(bool_defined) && (!defined(HAVE_BOOL) || !defined(__cplusplus))\ntypedef char\t\tbool;\t/* Ordinary boolean values 0 1 */\n#endif\n\t/* Macros for converting *constants* to the right type */\n#define INT8(v)\t\t(int8) (v)\n#define INT16(v)\t(int16) (v)\n#define INT32(v)\t(int32) (v)\n#define MYF(v)\t\t(myf) (v)\n\n/*\n  Defines to make it possible to prioritize register assignments. No\n  longer that important with modern compilers.\n*/\n#ifndef USING_X\n#define reg1 register\n#define reg2 register\n#define reg3 register\n#define reg4 register\n#define reg5 register\n#define reg6 register\n#define reg7 register\n#define reg8 register\n#define reg9 register\n#define reg10 register\n#define reg11 register\n#define reg12 register\n#define reg13 register\n#define reg14 register\n#define reg15 register\n#define reg16 register\n#endif\n\n/* Defines for time function */\n#define SCALE_SEC\t100\n#define SCALE_USEC\t10000\n#define MY_HOW_OFTEN_TO_ALARM\t2\t/* How often we want info on screen */\n#define MY_HOW_OFTEN_TO_WRITE\t1000\t/* How often we want info on screen */\n\n#define NOT_FIXED_DEC 31\n\n#if defined(_WIN32) && defined(_MSVC)\n#define MYSQLND_LLU_SPEC \"%I64u\"\n#define MYSQLND_LL_SPEC \"%I64d\"\n#ifndef L64\n#define L64(x) x##i64\n#endif\n#else\n#define MYSQLND_LLU_SPEC \"%llu\"\n#define MYSQLND_LL_SPEC \"%lld\"\n#ifndef L64\n#define L64(x) x##LL\n#endif /* L64 */\n#endif /* _WIN32 */\n/*\n** Define-funktions for reading and storing in machine independent format\n**  (low byte first)\n*/\n\n/* Optimized store functions for Intel x86 */\n#define int1store(T,A) *((int8*) (T)) = (A)\n#define uint1korr(A)   (*(((uint8*)(A))))\n#if defined(__i386__) || defined(_WIN32)\n#define sint2korr(A)\t(*((int16 *) (A)))\n#define sint3korr(A)\t((int32) ((((uchar) (A)[2]) & 128) ? \\\n\t\t\t\t  (((uint32) 255L << 24) | \\\n\t\t\t\t   (((uint32) (uchar) (A)[2]) << 16) |\\\n\t\t\t\t   (((uint32) (uchar) (A)[1]) << 8) | \\\n\t\t\t\t   ((uint32) (uchar) (A)[0])) : \\\n\t\t\t\t  (((uint32) (uchar) (A)[2]) << 16) |\\\n\t\t\t\t  (((uint32) (uchar) (A)[1]) << 8) | \\\n\t\t\t\t  ((uint32) (uchar) (A)[0])))\n#define sint4korr(A)\t(*((long *) (A)))\n#define uint2korr(A)\t(*((uint16 *) (A)))\n#if defined(HAVE_purify) && !defined(_WIN32)\n#define uint3korr(A)\t(uint32) (((uint32) ((uchar) (A)[0])) +\\\n\t\t\t\t  (((uint32) ((uchar) (A)[1])) << 8) +\\\n\t\t\t\t  (((uint32) ((uchar) (A)[2])) << 16))\n#else\n/*\n   ATTENTION !\n   \n    Please, note, uint3korr reads 4 bytes (not 3) !\n    It means, that you have to provide enough allocated space !\n*/\n#define uint3korr(A)\t(long) (*((unsigned int *) (A)) & 0xFFFFFF)\n#endif /* HAVE_purify && !_WIN32 */\n#define uint4korr(A)\t(*((uint32 *) (A)))\n#define uint5korr(A)\t((ulonglong)(((uint32) ((uchar) (A)[0])) +\\\n\t\t\t\t    (((uint32) ((uchar) (A)[1])) << 8) +\\\n\t\t\t\t    (((uint32) ((uchar) (A)[2])) << 16) +\\\n\t\t\t\t    (((uint32) ((uchar) (A)[3])) << 24)) +\\\n\t\t\t\t    (((ulonglong) ((uchar) (A)[4])) << 32))\n#define uint6korr(A)\t((ulonglong)(((uint32)    ((uchar) (A)[0]))          + \\\n                                     (((uint32)    ((uchar) (A)[1])) << 8)   + \\\n                                     (((uint32)    ((uchar) (A)[2])) << 16)  + \\\n                                     (((uint32)    ((uchar) (A)[3])) << 24)) + \\\n                         (((ulonglong) ((uchar) (A)[4])) << 32) +       \\\n                         (((ulonglong) ((uchar) (A)[5])) << 40))\n#define uint8korr(A)\t(*((ulonglong *) (A)))\n#define sint8korr(A)\t(*((longlong *) (A)))\n#define int2store(T,A)\t*((uint16*) (T))= (uint16) (A)\n#define int3store(T,A)  do { *(T)=  (uchar) ((A));\\\n                            *(T+1)=(uchar) (((uint) (A) >> 8));\\\n                            *(T+2)=(uchar) (((A) >> 16)); } while (0)\n#define int4store(T,A)\t*((long *) (T))= (long) (A)\n#define int5store(T,A)  do { *(T)= (uchar)((A));\\\n                             *((T)+1)=(uchar) (((A) >> 8));\\\n                             *((T)+2)=(uchar) (((A) >> 16));\\\n                             *((T)+3)=(uchar) (((A) >> 24)); \\\n                             *((T)+4)=(uchar) (((A) >> 32)); } while(0)\n#define int6store(T,A)  do { *(T)=    (uchar)((A));          \\\n                             *((T)+1)=(uchar) (((A) >> 8));  \\\n                             *((T)+2)=(uchar) (((A) >> 16)); \\\n                             *((T)+3)=(uchar) (((A) >> 24)); \\\n                             *((T)+4)=(uchar) (((A) >> 32)); \\\n                             *((T)+5)=(uchar) (((A) >> 40)); } while(0)\n#define int8store(T,A)\t*((ulonglong *) (T))= (ulonglong) (A)\n\ntypedef union {\n  double v;\n  long m[2];\n} doubleget_union;\n#define doubleget(V,M)\t\\\ndo { doubleget_union _tmp; \\\n     _tmp.m[0] = *((long*)(M)); \\\n     _tmp.m[1] = *(((long*) (M))+1); \\\n     (V) = _tmp.v; } while(0)\n#define doublestore(T,V) do { *((long *) T) = ((doubleget_union *)&V)->m[0]; \\\n\t\t\t     *(((long *) T)+1) = ((doubleget_union *)&V)->m[1]; \\\n                         } while (0)\n#define float4get(V,M)   do { *((float *) &(V)) = *((float*) (M)); } while(0)\n#define float8get(V,M)   doubleget((V),(M))\n#define float4store(V,M) memcpy((uchar*) V,(uchar*) (&M),sizeof(float))\n#define floatstore(T,V)  memcpy((uchar*)(T), (uchar*)(&V),sizeof(float))\n#define floatget(V,M)    memcpy((uchar*) &V,(uchar*) (M),sizeof(float))\n#define float8store(V,M) doublestore((V),(M))\n#else\n\n/*\n  We're here if it's not a IA-32 architecture (Win32 and UNIX IA-32 defines\n  were done before)\n*/\n#define sint2korr(A)\t(int16) (((int16) ((uchar) (A)[0])) +\\\n\t\t\t\t ((int16) ((int16) (A)[1]) << 8))\n#define sint3korr(A)\t((int32) ((((uchar) (A)[2]) & 128) ? \\\n\t\t\t\t  (((uint32) 255L << 24) | \\\n\t\t\t\t   (((uint32) (uchar) (A)[2]) << 16) |\\\n\t\t\t\t   (((uint32) (uchar) (A)[1]) << 8) | \\\n\t\t\t\t   ((uint32) (uchar) (A)[0])) : \\\n\t\t\t\t  (((uint32) (uchar) (A)[2]) << 16) |\\\n\t\t\t\t  (((uint32) (uchar) (A)[1]) << 8) | \\\n\t\t\t\t  ((uint32) (uchar) (A)[0])))\n#define sint4korr(A)\t(int32) (((int32) ((uchar) (A)[0])) +\\\n\t\t\t\t(((int32) ((uchar) (A)[1]) << 8)) +\\\n\t\t\t\t(((int32) ((uchar) (A)[2]) << 16)) +\\\n\t\t\t\t(((int32) ((int16) (A)[3]) << 24)))\n#define sint8korr(A)\t(longlong) uint8korr(A)\n#define uint2korr(A)\t(uint16) (((uint16) ((uchar) (A)[0])) +\\\n\t\t\t\t  ((uint16) ((uchar) (A)[1]) << 8))\n#define uint3korr(A)\t(uint32) (((uint32) ((uchar) (A)[0])) +\\\n\t\t\t\t  (((uint32) ((uchar) (A)[1])) << 8) +\\\n\t\t\t\t  (((uint32) ((uchar) (A)[2])) << 16))\n#define uint4korr(A)\t(uint32) (((uint32) ((uchar) (A)[0])) +\\\n\t\t\t\t  (((uint32) ((uchar) (A)[1])) << 8) +\\\n\t\t\t\t  (((uint32) ((uchar) (A)[2])) << 16) +\\\n\t\t\t\t  (((uint32) ((uchar) (A)[3])) << 24))\n#define uint5korr(A)\t((ulonglong)(((uint32) ((uchar) (A)[0])) +\\\n\t\t\t\t    (((uint32) ((uchar) (A)[1])) << 8) +\\\n\t\t\t\t    (((uint32) ((uchar) (A)[2])) << 16) +\\\n\t\t\t\t    (((uint32) ((uchar) (A)[3])) << 24)) +\\\n\t\t\t\t    (((ulonglong) ((uchar) (A)[4])) << 32))\n#define uint6korr(A)\t((ulonglong)(((uint32)    ((uchar) (A)[0]))          + \\\n                                     (((uint32)    ((uchar) (A)[1])) << 8)   + \\\n                                     (((uint32)    ((uchar) (A)[2])) << 16)  + \\\n                                     (((uint32)    ((uchar) (A)[3])) << 24)) + \\\n                         (((ulonglong) ((uchar) (A)[4])) << 32) +       \\\n                         (((ulonglong) ((uchar) (A)[5])) << 40))\n#define uint8korr(A)\t((ulonglong)(((uint32) ((uchar) (A)[0])) +\\\n\t\t\t\t    (((uint32) ((uchar) (A)[1])) << 8) +\\\n\t\t\t\t    (((uint32) ((uchar) (A)[2])) << 16) +\\\n\t\t\t\t    (((uint32) ((uchar) (A)[3])) << 24)) +\\\n\t\t\t(((ulonglong) (((uint32) ((uchar) (A)[4])) +\\\n\t\t\t\t    (((uint32) ((uchar) (A)[5])) << 8) +\\\n\t\t\t\t    (((uint32) ((uchar) (A)[6])) << 16) +\\\n\t\t\t\t    (((uint32) ((uchar) (A)[7])) << 24))) <<\\\n\t\t\t\t    32))\n#define int2store(T,A)       do { uint def_temp= (uint) (A) ;\\\n                                  *((uchar*) (T))=  (uchar)(def_temp); \\\n                                   *((uchar*) (T)+1)=(uchar)((def_temp >> 8)); \\\n                             } while(0)\n#define int3store(T,A)       do { /*lint -save -e734 */\\\n                                  *((uchar*)(T))=(uchar) ((A));\\\n                                  *((uchar*) (T)+1)=(uchar) (((A) >> 8));\\\n                                  *((uchar*)(T)+2)=(uchar) (((A) >> 16)); \\\n                                  /*lint -restore */} while(0)\n#define int4store(T,A)       do { *((char *)(T))=(char) ((A));\\\n                                  *(((char *)(T))+1)=(char) (((A) >> 8));\\\n                                  *(((char *)(T))+2)=(char) (((A) >> 16));\\\n                                  *(((char *)(T))+3)=(char) (((A) >> 24)); } while(0)\n#define int5store(T,A)       do { *((char *)(T))=     (char)((A));  \\\n                                  *(((char *)(T))+1)= (char)(((A) >> 8)); \\\n                                  *(((char *)(T))+2)= (char)(((A) >> 16)); \\\n                                  *(((char *)(T))+3)= (char)(((A) >> 24)); \\\n                                  *(((char *)(T))+4)= (char)(((A) >> 32)); \\\n\t\t                } while(0)\n#define int6store(T,A)       do { *((char *)(T))=     (char)((A)); \\\n                                  *(((char *)(T))+1)= (char)(((A) >> 8)); \\\n                                  *(((char *)(T))+2)= (char)(((A) >> 16)); \\\n                                  *(((char *)(T))+3)= (char)(((A) >> 24)); \\\n                                  *(((char *)(T))+4)= (char)(((A) >> 32)); \\\n                                  *(((char *)(T))+5)= (char)(((A) >> 40)); \\\n                                } while(0)\n#define int8store(T,A)       do { uint def_temp= (uint) (A), def_temp2= (uint) ((A) >> 32); \\\n                                  int4store((T),def_temp); \\\n                                  int4store((T+4),def_temp2); } while(0)\n#ifdef HAVE_BIGENDIAN\n#define float4store(T,A) do { *(T)= ((uchar *) &A)[3];\\\n                              *((T)+1)=(char) ((uchar *) &A)[2];\\\n                              *((T)+2)=(char) ((uchar *) &A)[1];\\\n                              *((T)+3)=(char) ((uchar *) &A)[0]; } while(0)\n\n#define float4get(V,M)   do { float def_temp;\\\n                              ((uchar*) &def_temp)[0]=(M)[3];\\\n                              ((uchar*) &def_temp)[1]=(M)[2];\\\n                              ((uchar*) &def_temp)[2]=(M)[1];\\\n                              ((uchar*) &def_temp)[3]=(M)[0];\\\n                              (V)=def_temp; } while(0)\n#define float8store(T,V) do { *(T)= ((uchar *) &V)[7];\\\n                              *((T)+1)=(char) ((uchar *) &V)[6];\\\n                              *((T)+2)=(char) ((uchar *) &V)[5];\\\n                              *((T)+3)=(char) ((uchar *) &V)[4];\\\n                              *((T)+4)=(char) ((uchar *) &V)[3];\\\n                              *((T)+5)=(char) ((uchar *) &V)[2];\\\n                              *((T)+6)=(char) ((uchar *) &V)[1];\\\n                              *((T)+7)=(char) ((uchar *) &V)[0]; } while(0)\n\n#define float8get(V,M)   do { double def_temp;\\\n                              ((uchar*) &def_temp)[0]=(M)[7];\\\n                              ((uchar*) &def_temp)[1]=(M)[6];\\\n                              ((uchar*) &def_temp)[2]=(M)[5];\\\n                              ((uchar*) &def_temp)[3]=(M)[4];\\\n                              ((uchar*) &def_temp)[4]=(M)[3];\\\n                              ((uchar*) &def_temp)[5]=(M)[2];\\\n                              ((uchar*) &def_temp)[6]=(M)[1];\\\n                              ((uchar*) &def_temp)[7]=(M)[0];\\\n                              (V) = def_temp; } while(0)\n#else\n#define float4get(V,M)   memcpy(&V, (M), sizeof(float))\n#define float4store(V,M) memcpy(V, (&M), sizeof(float))\n\n#if defined(__FLOAT_WORD_ORDER) && (__FLOAT_WORD_ORDER == __BIG_ENDIAN)\n#define doublestore(T,V) do { *(((char*)T)+0)=(char) ((uchar *) &V)[4];\\\n                              *(((char*)T)+1)=(char) ((uchar *) &V)[5];\\\n                              *(((char*)T)+2)=(char) ((uchar *) &V)[6];\\\n                              *(((char*)T)+3)=(char) ((uchar *) &V)[7];\\\n                              *(((char*)T)+4)=(char) ((uchar *) &V)[0];\\\n                              *(((char*)T)+5)=(char) ((uchar *) &V)[1];\\\n                              *(((char*)T)+6)=(char) ((uchar *) &V)[2];\\\n                              *(((char*)T)+7)=(char) ((uchar *) &V)[3]; }\\\n                         while(0)\n#define doubleget(V,M)   do { double def_temp;\\\n                              ((uchar*) &def_temp)[0]=(M)[4];\\\n                              ((uchar*) &def_temp)[1]=(M)[5];\\\n                              ((uchar*) &def_temp)[2]=(M)[6];\\\n                              ((uchar*) &def_temp)[3]=(M)[7];\\\n                              ((uchar*) &def_temp)[4]=(M)[0];\\\n                              ((uchar*) &def_temp)[5]=(M)[1];\\\n                              ((uchar*) &def_temp)[6]=(M)[2];\\\n                              ((uchar*) &def_temp)[7]=(M)[3];\\\n                              (V) = def_temp; } while(0)\n#endif /* __FLOAT_WORD_ORDER */\n\n#define float8get(V,M)   doubleget((V),(M))\n#define float8store(V,M) doublestore((V),(M))\n#endif /* WORDS_BIGENDIAN */\n\n#endif /* __i386__ OR _WIN32 */\n\n/*\n  Macro for reading 32-bit integer from network byte order (big-endian)\n  from unaligned memory location.\n*/\n#define int4net(A)        (int32) (((uint32) ((uchar) (A)[3]))        |\\\n\t\t\t\t  (((uint32) ((uchar) (A)[2])) << 8)  |\\\n\t\t\t\t  (((uint32) ((uchar) (A)[1])) << 16) |\\\n\t\t\t\t  (((uint32) ((uchar) (A)[0])) << 24))\n/*\n  Define-funktions for reading and storing in machine format from/to\n  short/long to/from some place in memory V should be a (not\n  register) variable, M is a pointer to byte\n*/\n\n#ifdef HAVE_BIGENDIAN\n\n#define ushortget(V,M)  do { V = (uint16) (((uint16) ((uchar) (M)[1]))+\\\n                                 ((uint16) ((uint16) (M)[0]) << 8)); } while(0)\n#define shortget(V,M)   do { V = (short) (((short) ((uchar) (M)[1]))+\\\n                                 ((short) ((short) (M)[0]) << 8)); } while(0)\n#define longget(V,M)    do { int32 def_temp;\\\n                             ((uchar*) &def_temp)[0]=(M)[0];\\\n                             ((uchar*) &def_temp)[1]=(M)[1];\\\n                             ((uchar*) &def_temp)[2]=(M)[2];\\\n                             ((uchar*) &def_temp)[3]=(M)[3];\\\n                             (V)=def_temp; } while(0)\n#define ulongget(V,M)   do { uint32 def_temp;\\\n                            ((uchar*) &def_temp)[0]=(M)[0];\\\n                            ((uchar*) &def_temp)[1]=(M)[1];\\\n                            ((uchar*) &def_temp)[2]=(M)[2];\\\n                            ((uchar*) &def_temp)[3]=(M)[3];\\\n                            (V)=def_temp; } while(0)\n#define shortstore(T,A) do { uint def_temp=(uint) (A) ;\\\n                             *(((char*)T)+1)=(char)(def_temp); \\\n                             *(((char*)T)+0)=(char)(def_temp >> 8); } while(0)\n#define longstore(T,A)  do { *(((char*)T)+3)=((A));\\\n                             *(((char*)T)+2)=(((A) >> 8));\\\n                             *(((char*)T)+1)=(((A) >> 16));\\\n                             *(((char*)T)+0)=(((A) >> 24)); } while(0)\n\n#define floatget(V,M)    memcpy(&V, (M), sizeof(float))\n#define floatstore(T,V)  memcpy((T), (void*) (&V), sizeof(float))\n#define doubleget(V,M)\t memcpy(&V, (M), sizeof(double))\n#define doublestore(T,V) memcpy((T), (void *) &V, sizeof(double))\n#define longlongget(V,M) memcpy(&V, (M), sizeof(ulonglong))\n#define longlongstore(T,V) memcpy((T), &V, sizeof(ulonglong))\n\n#else\n\n#define ushortget(V,M)\tdo { V = uint2korr(M); } while(0)\n#define shortget(V,M)\tdo { V = sint2korr(M); } while(0)\n#define longget(V,M)\tdo { V = sint4korr(M); } while(0)\n#define ulongget(V,M)   do { V = uint4korr(M); } while(0)\n#define shortstore(T,V) int2store(T,V)\n#define longstore(T,V)\tint4store(T,V)\n#ifndef floatstore\n#define floatstore(T,V)  memcpy((T), (void *) (&V), sizeof(float))\n#define floatget(V,M)    memcpy(&V, (M), sizeof(float))\n#endif\n#ifndef doubleget\n#define doubleget(V,M)\t memcpy(&V, (M), sizeof(double))\n#define doublestore(T,V) memcpy((T), (void *) &V, sizeof(double))\n#endif /* doubleget */\n#define longlongget(V,M) memcpy(&V, (M), sizeof(ulonglong))\n#define longlongstore(T,V) memcpy((T), &V, sizeof(ulonglong))\n\n#endif /* WORDS_BIGENDIAN */\n\n#ifndef THREAD\n#define thread_safe_increment(V,L) (V)++\n#define thread_safe_add(V,C,L)     (V)+=(C)\n#define thread_safe_sub(V,C,L)     (V)-=(C)\n#define statistic_increment(V,L)   (V)++\n#define statistic_add(V,C,L)       (V)+=(C)\n#endif\n\n#ifdef _WIN32\n#define SO_EXT \".dll\"\n#else\n#define SO_EXT \".so\"\n#endif\n\n#ifndef DBUG_OFF\n#define dbug_assert(A) assert(A)\n#define DBUG_ASSERT(A) assert(A)\n#else\n#define dbug_assert(A)\n#define DBUG_ASSERT(A)\n#endif\n\n#ifdef HAVE_DLOPEN\n#ifdef _WIN32\n#define dlsym(lib, name) GetProcAddress((HMODULE)lib, name)\n#define dlopen(libname, unused) LoadLibraryEx(libname, NULL, 0)\n#define dlclose(lib) FreeLibrary((HMODULE)lib)\n#elif defined(HAVE_DLFCN_H)\n#include <dlfcn.h>\n#endif\n#ifndef HAVE_DLERROR\n#define dlerror() \"\"\n#endif\n#endif\n\n#if SIZEOF_CHARP == SIZEOF_INT\ntypedef unsigned int intptr;\n#elif SIZEOF_CHARP == SIZEOF_LONG\ntypedef unsigned long intptr;\n#elif SIZEOF_CHARP == SIZEOF_LONG_LONG\ntypedef unsigned long long intptr;\n#else\n#error sizeof(void *) is not sizeof(int, long or long long)\n#endif\n\n#ifdef _WIN32\n#define IF_WIN(A,B) A \n#else\n#define IF_WIN(A,B) B \n#endif\n\n#ifndef RTLD_NOW\n#define RTLD_NOW 1\n#endif\n\n#endif /* _global_h */\n",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/libmariadb/libmariadb/ma_client_plugin.c.in": "/* Copyright (C) 2010 - 2012 Sergei Golubchik and Monty Program Ab\n                 2015-2016 MariaDB Corporation AB\n\n   This library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Library General Public\n   License as published by the Free Software Foundation; either\n   version 2 of the License, or (at your option) any later version.\n   \n   This library is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Library General Public License for more details.\n   \n   You should have received a copy of the GNU Library General Public\n   License along with this library; if not see <http://www.gnu.org/licenses>\n   or write to the Free Software Foundation, Inc., \n   51 Franklin St., Fifth Floor, Boston, MA 02110, USA */\n\n/**\n  @file\n  \n  Support code for the client side (libmariadb) plugins\n\n  Client plugins are somewhat different from server plugins, they are simpler.\n\n  They do not need to be installed or in any way explicitly loaded on the\n  client, they are loaded automatically on demand.\n  One client plugin per shared object, soname *must* match the plugin name.\n\n  There is no reference counting and no unloading either.\n*/\n\n/* Silence warnings about variable 'unused' being used. */\n#define FORCE_INIT_OF_VARS 1\n\n#include <ma_global.h>\n#include <ma_sys.h>\n#include <ma_common.h> \n#include <ma_string.h>\n#include <ma_pthread.h>\n\n#include \"errmsg.h\"\n#include <mysql/client_plugin.h>\n\n#ifndef WIN32\n#include <dlfcn.h>\n#endif\n\nstruct st_client_plugin_int {\n  struct st_client_plugin_int *next;\n  void   *dlhandle;\n  struct st_mysql_client_plugin *plugin;\n};\n\nstatic my_bool initialized= 0;\nstatic MA_MEM_ROOT mem_root;\n\nstatic uint valid_plugins[][2]= {\n  {MYSQL_CLIENT_AUTHENTICATION_PLUGIN, MYSQL_CLIENT_AUTHENTICATION_PLUGIN_INTERFACE_VERSION},\n  {MARIADB_CLIENT_PVIO_PLUGIN, MARIADB_CLIENT_PVIO_PLUGIN_INTERFACE_VERSION},\n  {MARIADB_CLIENT_TRACE_PLUGIN, MARIADB_CLIENT_TRACE_PLUGIN_INTERFACE_VERSION},\n  {MARIADB_CLIENT_REMOTEIO_PLUGIN, MARIADB_CLIENT_REMOTEIO_PLUGIN_INTERFACE_VERSION},\n  {MARIADB_CLIENT_CONNECTION_PLUGIN, MARIADB_CLIENT_CONNECTION_PLUGIN_INTERFACE_VERSION},\n  {0, 0}\n};\n\n/*\n  Loaded plugins are stored in a linked list.\n  The list is append-only, the elements are added to the head (like in a stack).\n  The elements are added under a mutex, but the list can be read and traversed\n  without any mutex because once an element is added to the list, it stays\n  there. The main purpose of a mutex is to prevent two threads from\n  loading the same plugin twice in parallel.\n*/\n\n\nstruct st_client_plugin_int *plugin_list[MYSQL_CLIENT_MAX_PLUGINS + MARIADB_CLIENT_MAX_PLUGINS];\n#ifdef THREAD\nstatic pthread_mutex_t LOCK_load_client_plugin;\n#endif\n\n@EXTERNAL_PLUGINS@\n\nstruct st_mysql_client_plugin *mysql_client_builtins[]=\n{\n  @BUILTIN_PLUGINS@\n  0\n};\n\n\nstatic int is_not_initialized(MYSQL *mysql, const char *name)\n{\n  if (initialized)\n    return 0;\n\n  my_set_error(mysql, CR_AUTH_PLUGIN_CANNOT_LOAD,\n               SQLSTATE_UNKNOWN, ER(CR_AUTH_PLUGIN_CANNOT_LOAD),\n               name, \"not initialized\");\n  return 1;\n}\n\nstatic int get_plugin_nr(uint type)\n{\n  uint i= 0;\n  for(; valid_plugins[i][1]; i++)\n    if (valid_plugins[i][0] == type)\n      return i;\n  return -1;\n}\n\nstatic const char *check_plugin_version(struct st_mysql_client_plugin *plugin, unsigned int version)\n{\n  if (plugin->interface_version < version ||\n      (plugin->interface_version >> 8) > (version >> 8))\n    return \"Incompatible client plugin interface\";\n  return 0;\n}\n\n/**\n  finds a plugin in the list\n\n  @param name   plugin name to search for\n  @param type   plugin type\n\n  @note this does NOT necessarily need a mutex, take care!\n  \n  @retval a pointer to a found plugin or 0\n*/\nstatic struct st_mysql_client_plugin *find_plugin(const char *name, int type)\n{\n  struct st_client_plugin_int *p;\n  int plugin_nr= get_plugin_nr(type);\n\n  DBUG_ASSERT(initialized);\n  if (plugin_nr == -1)\n    return 0;\n\n  if (!name)\n    return plugin_list[plugin_nr]->plugin;\n\n  for (p= plugin_list[plugin_nr]; p; p= p->next)\n  {\n    if (strcmp(p->plugin->name, name) == 0)\n      return p->plugin;\n  }\n  return NULL;\n}\n\n\n/**\n  verifies the plugin and adds it to the list\n\n  @param mysql          MYSQL structure (for error reporting)\n  @param plugin         plugin to install\n  @param dlhandle       a handle to the shared object (returned by dlopen)\n                        or 0 if the plugin was not dynamically loaded\n  @param argc           number of arguments in the 'va_list args'\n  @param args           arguments passed to the plugin initialization function\n\n  @retval a pointer to an installed plugin or 0\n*/\n\nstatic struct st_mysql_client_plugin *\nadd_plugin(MYSQL *mysql, struct st_mysql_client_plugin *plugin, void *dlhandle,\n           int argc, va_list args)\n{\n  const char *errmsg;\n  struct st_client_plugin_int plugin_int, *p;\n  char errbuf[1024];\n  int plugin_nr;\n\n  DBUG_ASSERT(initialized);\n\n  plugin_int.plugin= plugin;\n  plugin_int.dlhandle= dlhandle;\n\n  if ((plugin_nr= get_plugin_nr(plugin->type)) == -1)\n  {\n    errmsg= \"Unknown client plugin type\";\n    goto err1;\n  }\n  if ((errmsg= check_plugin_version(plugin, valid_plugins[plugin_nr][1])))\n    goto err1;\n\n  /* Call the plugin initialization function, if any */\n  if (plugin->init && plugin->init(errbuf, sizeof(errbuf), argc, args))\n  {\n    errmsg= errbuf;\n    goto err1;\n  }\n\n  p= (struct st_client_plugin_int *)\n    ma_memdup_root(&mem_root, (char *)&plugin_int, sizeof(plugin_int));\n\n  if (!p)\n  {\n    errmsg= \"Out of memory\";\n    goto err2;\n  }\n\n\n  p->next= plugin_list[plugin_nr];\n  plugin_list[plugin_nr]= p;\n\n  return plugin;\n\nerr2:\n  if (plugin->deinit)\n    plugin->deinit();\nerr1:\n  my_set_error(mysql, CR_AUTH_PLUGIN_CANNOT_LOAD, SQLSTATE_UNKNOWN,\n               ER(CR_AUTH_PLUGIN_CANNOT_LOAD), plugin->name, errmsg);\n  if (dlhandle)\n    (void)dlclose(dlhandle);\n  return NULL;\n}\n\n\n/**\n  Loads plugins which are specified in the environment variable\n  LIBMYSQL_PLUGINS.\n  \n  Multiple plugins must be separated by semicolon. This function doesn't\n  return or log an error.\n\n  The function is be called by mysql_client_plugin_init\n\n  @todo\n  Support extended syntax, passing parameters to plugins, for example\n  LIBMYSQL_PLUGINS=\"plugin1(param1,param2);plugin2;...\"\n  or\n  LIBMYSQL_PLUGINS=\"plugin1=int:param1,str:param2;plugin2;...\"\n*/\n\nstatic void load_env_plugins(MYSQL *mysql)\n{\n  char *plugs, *free_env, *s= getenv(\"LIBMYSQL_PLUGINS\");\n\n  if (ma_check_env_str(s))\n    return;\n\n  free_env= strdup(s);\n  plugs= s= free_env;\n\n  do {\n    if ((s= strchr(plugs, ';')))\n      *s= '\\0';\n    mysql_load_plugin(mysql, plugs, -1, 0);\n    plugs= s + 1;\n  } while (s);\n\n  free(free_env);\n}\n\n/********** extern functions to be used by libmariadb *********************/\n\n/**\n  Initializes the client plugin layer.\n\n  This function must be called before any other client plugin function.\n\n  @retval 0    successful\n  @retval != 0 error occurred\n*/\n\nint mysql_client_plugin_init()\n{\n  MYSQL mysql;\n  struct st_mysql_client_plugin **builtin;\n  va_list unused;\n  LINT_INIT_STRUCT(unused);\n\n  if (initialized)\n    return 0;\n\n  memset(&mysql, 0, sizeof(mysql)); /* dummy mysql for set_mysql_extended_error */\n\n  pthread_mutex_init(&LOCK_load_client_plugin, NULL);\n  ma_init_alloc_root(&mem_root, 128, 128);\n\n  memset(&plugin_list, 0, sizeof(plugin_list));\n\n  initialized= 1;\n\n  pthread_mutex_lock(&LOCK_load_client_plugin);\n  for (builtin= mysql_client_builtins; *builtin; builtin++)\n    add_plugin(&mysql, *builtin, 0, 0, unused);\n\n  pthread_mutex_unlock(&LOCK_load_client_plugin);\n\n  load_env_plugins(&mysql);\n\n  return 0;\n}\n\n\n/**\n  Deinitializes the client plugin layer.\n\n  Unloades all client plugins and frees any associated resources.\n*/\n\nvoid mysql_client_plugin_deinit()\n{\n  int i;\n  struct st_client_plugin_int *p;\n\n  if (!initialized)\n    return;\n\n  for (i=0; i < MYSQL_CLIENT_MAX_PLUGINS; i++)\n    for (p= plugin_list[i]; p; p= p->next)\n    {\n      if (p->plugin->deinit)\n        p->plugin->deinit();\n      if (p->dlhandle)\n        (void)dlclose(p->dlhandle);\n    }\n\n  memset(&plugin_list, 0, sizeof(plugin_list));\n  initialized= 0;\n  ma_free_root(&mem_root, MYF(0));\n  pthread_mutex_destroy(&LOCK_load_client_plugin);\n}\n\n/************* public facing functions, for client consumption *********/\n\n/* see <mysql/client_plugin.h> for a full description */\nstruct st_mysql_client_plugin * STDCALL\nmysql_client_register_plugin(MYSQL *mysql,\n                             struct st_mysql_client_plugin *plugin)\n{\n  va_list unused;\n  LINT_INIT_STRUCT(unused);\n\n  if (is_not_initialized(mysql, plugin->name))\n    return NULL;\n\n  pthread_mutex_lock(&LOCK_load_client_plugin);\n\n  /* make sure the plugin wasn't loaded meanwhile */\n  if (find_plugin(plugin->name, plugin->type))\n  {\n    my_set_error(mysql, CR_AUTH_PLUGIN_CANNOT_LOAD,\n                 SQLSTATE_UNKNOWN, ER(CR_AUTH_PLUGIN_CANNOT_LOAD),\n                 plugin->name, \"it is already loaded\");\n    plugin= NULL;\n  }\n  else\n    plugin= add_plugin(mysql, plugin, 0, 0, unused);\n\n  pthread_mutex_unlock(&LOCK_load_client_plugin);\n  return plugin;\n}\n\n\n/* see <mysql/client_plugin.h> for a full description */\nstruct st_mysql_client_plugin * STDCALL\nmysql_load_plugin_v(MYSQL *mysql, const char *name, int type,\n                    int argc, va_list args)\n{\n  const char *errmsg;\n#ifdef _WIN32\n  char errbuf[1024];\n#endif\n  char dlpath[FN_REFLEN+1];\n  void *sym, *dlhandle = NULL;\n  struct st_mysql_client_plugin *plugin;\n  char *env_plugin_dir= getenv(\"MARIADB_PLUGIN_DIR\");\n\n  CLEAR_CLIENT_ERROR(mysql);\n  if (is_not_initialized(mysql, name))\n    return NULL;\n\n  pthread_mutex_lock(&LOCK_load_client_plugin);\n\n  /* make sure the plugin wasn't loaded meanwhile */\n  if (type >= 0 && find_plugin(name, type))\n  {\n    errmsg= \"it is already loaded\";\n    goto err;\n  }\n\n  /* Compile dll path */\n  snprintf(dlpath, sizeof(dlpath) - 1, \"%s/%s%s\",\n           mysql->options.extension && mysql->options.extension->plugin_dir ?\n           mysql->options.extension->plugin_dir : (env_plugin_dir) ? env_plugin_dir :\n           MARIADB_PLUGINDIR, name, SO_EXT);\n\n  if (strpbrk(name, \"()[]!@#$%^&/*;.,'?\\\\\"))\n  {\n    errmsg= \"invalid plugin name\";\n    goto err;\n  }\n\n\n  /* Open new dll handle */\n  if (!(dlhandle= dlopen((const char *)dlpath, RTLD_NOW)))\n  {\n#ifdef _WIN32\n   char winmsg[255];\n   size_t len;\n   winmsg[0] = 0;\n   FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,\n                 NULL,\n                 GetLastError(),\n                 MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),\n                 winmsg, 255, NULL);\n   len= strlen(winmsg);\n   while (len > 0 && (winmsg[len - 1] == '\\n' || winmsg[len - 1] == '\\r'))\n     len--;\n   if (len)\n     winmsg[len] = 0;\n   snprintf(errbuf, sizeof(errbuf), \"%s Library path is '%s'\", winmsg, dlpath);\n   errmsg= errbuf;\n#else\n    errmsg= dlerror();\n#endif\n    goto err;\n  }\n\n\n  if (!(sym= dlsym(dlhandle, plugin_declarations_sym)))\n  {\n    errmsg= \"not a plugin\";\n    (void)dlclose(dlhandle);\n    goto err;\n  }\n\n  plugin= (struct st_mysql_client_plugin*)sym;\n\n  if (type >=0 && type != plugin->type)\n  {\n    errmsg= \"type mismatch\";\n    goto err;\n  }\n\n  if (strcmp(name, plugin->name))\n  {\n    errmsg= \"name mismatch\";\n    goto err;\n  }\n\n  if (type < 0 && find_plugin(name, plugin->type))\n  {\n    errmsg= \"it is already loaded\";\n    goto err;\n  }\n\n  plugin= add_plugin(mysql, plugin, dlhandle, argc, args);\n\n  pthread_mutex_unlock(&LOCK_load_client_plugin);\n\n  return plugin;\n\nerr:\n  if (dlhandle)\n    dlclose(dlhandle);\n  pthread_mutex_unlock(&LOCK_load_client_plugin);\n  my_set_error(mysql, CR_AUTH_PLUGIN_CANNOT_LOAD, SQLSTATE_UNKNOWN,\n               ER(CR_AUTH_PLUGIN_CANNOT_LOAD), name, errmsg);\n  return NULL;\n}\n\n\n/* see <mysql/client_plugin.h> for a full description */\nstruct st_mysql_client_plugin * STDCALL\nmysql_load_plugin(MYSQL *mysql, const char *name, int type, int argc, ...)\n{\n  struct st_mysql_client_plugin *p;\n  va_list args;\n  va_start(args, argc);\n  p= mysql_load_plugin_v(mysql, name, type, argc, args);\n  va_end(args);\n  return p;\n}\n\n/* see <mysql/client_plugin.h> for a full description */\nstruct st_mysql_client_plugin * STDCALL\nmysql_client_find_plugin(MYSQL *mysql, const char *name, int type)\n{\n  struct st_mysql_client_plugin *p;\n  int plugin_nr= get_plugin_nr(type);\n\n  if (is_not_initialized(mysql, name))\n    return NULL;\n\n  if (plugin_nr == -1)\n  {\n    my_set_error(mysql, CR_AUTH_PLUGIN_CANNOT_LOAD, SQLSTATE_UNKNOWN,\n                 ER(CR_AUTH_PLUGIN_CANNOT_LOAD), name, \"invalid type\");\n  }\n\n  if ((p= find_plugin(name, type)))\n    return p;\n\n  /* not found, load it */\n  return mysql_load_plugin(mysql, name, type, 0);\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/libmariadb/cmake/CheckFunctions.cmake": "#\n#  Copyright (C) 2013-2016 MariaDB Corporation AB\n#\n#  Redistribution and use is allowed according to the terms of the New\n#  BSD license.\n#  For details see the COPYING-CMAKE-SCRIPTS file.\n#\n\n# This file is included by CMakeLists.txt and\n# checks for various functions.\n# You will find the appropriate defines in \n# include/my_config.h.in\n\nINCLUDE(CheckFunctionExists)\n\nCHECK_FUNCTION_EXISTS (alloca HAVE_ALLOCA)\nCHECK_FUNCTION_EXISTS (dlerror HAVE_DLERROR)\nCHECK_FUNCTION_EXISTS (dlopen HAVE_DLOPEN)\nCHECK_FUNCTION_EXISTS (fcntl HAVE_FCNTL)\nCHECK_FUNCTION_EXISTS (memcpy HAVE_MEMCPY)\nCHECK_FUNCTION_EXISTS (nl_langinfo HAVE_NL_LANGINFO)\nCHECK_FUNCTION_EXISTS (setlocale HAVE_SETLOCALE)\nCHECK_FUNCTION_EXISTS (poll HAVE_POLL)\nCHECK_FUNCTION_EXISTS (getpwuid HAVE_GETPWUID)\n",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/libmariadb/client/ma_plugin_info.c": "\n#include <my_global.h>\n#include <my_sys.h>\n#include <mysql.h>\n#include <mysql/client_plugin.h>\n#include <getopt.h>\n#include <stdio.h>\n#include <my_dir.h>\n#include <ma_string.h>\n\n#define CLIENT_PLUGIN_INFO_VERSION \"1.0.0\"\n\nstatic struct option long_options[]=\n{\n  {\"all\", no_argument, 0, 'a'},\n  {\"builtin\", no_argument, 0, 'b'},\n  {\"dynamic\", no_argument, 0, 'd'},\n  {\"directory\", 1, 0, 'p'},\n  {\"plugin_name\", 1, 0, 'n'},\n  {\"version\", no_argument, 0, 'v'},\n  {\"help\", no_argument, 0, '?'},\n  {NULL, 0, 0, 0}\n};\n\nstatic char *values[] =\n{\n  \"show information for all plugins\",\n  \"show information for builtin plugins\",\n  \"show information for dynamic plugins\",\n  \"show information for dynamic plugins in specified directory\",\n  \"show information for specified plugin\",\n  \"show version information\",\n  \"display this help and exit\",\n  NULL\n};\n\nstruct st_plugin_type\n{\n  int type;\n  char *typename;\n};\n\n#ifndef _WIN32\nint my_errno=0;\n#endif\n\nstatic struct st_plugin_type plugin_types[]=\n{\n  {MYSQL_CLIENT_AUTHENTICATION_PLUGIN, \"authentication\"},\n  {MARIADB_CLIENT_PVIO_PLUGIN, \"virtual IO\"},\n  {MARIADB_CLIENT_TRACE_PLUGIN, \"trace\"},\n  {MARIADB_CLIENT_REMOTEIO_PLUGIN, \"remote file access\"},\n  {MARIADB_CLIENT_CONNECTION_PLUGIN, \"connection handler\"},\n  {0, \"unknown\"}\n};\n\nstatic void version()\n{\n  printf(\"%s Version %s\\n\", ma_progname, CLIENT_PLUGIN_INFO_VERSION);\n}\n\nstatic void usage(void)\n{\n  int i=0;\n  printf(\"%s Version %s\\n\", ma_progname, CLIENT_PLUGIN_INFO_VERSION);\n  puts(\"Copyright 2015 MariaDB Corporation AB\");\n  puts(\"Show client plugin information for MariaDB Connector/C.\");\n  printf(\"Usage: %s [OPTIONS] [plugin_name]\\n\", ma_progname);\n  while (long_options[i].name)\n  {\n    printf(\"  --%-12s -%s\\n\", long_options[i].name, values[i]);\n    i++;\n  }\n}\n\nstatic char *ma_get_type_name(int type)\n{\n  int i=0;\n  while (plugin_types[i].type)\n  {\n    if (type== plugin_types[i].type)\n      return plugin_types[i].typename;\n    i++;\n  }\n  return plugin_types[i].typename;\n}\n\nstatic void show_plugin_info(struct st_mysql_client_plugin *plugin, my_bool builtin)\n{\n  printf(\"Name: %s\\n\", plugin->name);\n  printf(\"Type: %s\\n\", ma_get_type_name(plugin->type));\n  printf(\"Desc: %s\\n\", plugin->desc);\n  printf(\"Author: %s\\n\", plugin->author);\n  printf(\"License: %s\\n\", plugin->license);\n  printf(\"Version: %d.%d.%d\\n\", plugin->version[0], plugin->version[1], plugin->version[2]);\n  printf(\"API Version: 0x%04X\\n\", plugin->interface_version);\n  printf(\"Build type: %s\\n\", builtin ? \"builtin\" : \"dynamic\");\n  printf(\"\\n\");\n}\n\nstatic void show_builtin()\n{\n  struct st_mysql_client_plugin **builtin;\n\n  for (builtin= mysql_client_builtins; *builtin; builtin++)\n    show_plugin_info(*builtin, TRUE);\n}\n\nstatic void show_file(char *filename)\n{\n  char dlpath[FN_REFLEN+1];\n  void *sym, *dlhandle;\n  struct st_mysql_client_plugin *plugin;\n  char *env_plugin_dir= getenv(\"MARIADB_PLUGIN_DIR\");\n  char *has_so_ext= strstr(filename, SO_EXT);\n\n  if (!strchr(filename, FN_LIBCHAR))\n    snprintf(dlpath, sizeof(dlpath) - 1, \"%s/%s%s\",\n             (env_plugin_dir) ? env_plugin_dir : PLUGINDIR, \n             filename, \n             has_so_ext ? \"\" : SO_EXT);\n  else\n    strcpy(dlpath, filename);\n  if ((dlhandle= dlopen((const char *)dlpath, RTLD_NOW)))\n  {\n    if (sym= dlsym(dlhandle, plugin_declarations_sym))\n    {\n      plugin= (struct st_mysql_client_plugin *)sym;\n      show_plugin_info(plugin, 0);\n    }\n    dlclose(dlhandle);\n  }\n}\n\nstatic void show_dynamic(const char *directory)\n{\n  MY_DIR *dir= NULL;\n  unsigned int i;\n  char *plugin_dir= directory ? (char *)directory : getenv(\"MARIADB_PLUGIN_DIR\");\n\n  if (!plugin_dir)\n    plugin_dir= PLUGINDIR;\n\n  printf(\"plugin_dir %s\\n\", plugin_dir);\n\n  dir= my_dir(plugin_dir, 0);\n\n  if (!dir || !dir->number_off_files)\n  {\n    printf(\"No plugins found in %s\\n\", plugin_dir);\n    goto end;\n  }\n\n  for (i=0; i < dir->number_off_files; i++)\n  {\n    char *p= strstr(dir->dir_entry[i].name, SO_EXT);\n    if (p)\n      show_file(dir->dir_entry[i].name);\n  }\nend:\n  if (dir)\n    my_dirend(dir);\n}\n\nint main(int argc, char *argv[])\n{\n  int option_index= 0;\n  int c;\n  ma_progname= argv[0];\n\n  mysql_server_init(0, NULL, NULL);\n\n  if (argc <= 1)\n  {\n    usage();\n    exit(1);\n  }\n\n  c= getopt_long(argc, argv, \"bdapnvh?\", long_options, &option_index);\n\n  switch(c) {\n  case 'a': /* all */\n    show_builtin();\n    show_dynamic(NULL);\n    break;\n  case 'b': /* builtin */\n    show_builtin();\n    break;\n  case 'd': /* dynamic */\n    show_dynamic(NULL);\n    break;\n  case 'v':\n    version();\n    break;\n  case 'n':\n    if (argc > 2)\n      show_file(argv[2]);\n    break;\n  case 'p':\n    if (argc > 2)\n      show_dynamic(argv[2]);\n    break;\n  case '?':\n    usage();\n    break;\n  default:\n    printf(\"unrecocognized option: %s\", argv[1]);\n    exit(1);\n  }\n  exit(0);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/sql/mysqld.cc": "/* Copyright (c) 2000, 2015, Oracle and/or its affiliates.\n   Copyright (c) 2008, 2019, MariaDB Corporation.\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; version 2 of the License.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1335  USA */\n\n#include \"sql_plugin.h\"                         // Includes mariadb.h\n#include \"sql_priv.h\"\n#include \"unireg.h\"\n#include <signal.h>\n#ifndef __WIN__\n#include <netdb.h>        // getservbyname, servent\n#endif\n#include \"sql_parse.h\"    // path_starts_from_data_home_dir\n#include \"sql_cache.h\"    // query_cache, query_cache_*\n#include \"sql_locale.h\"   // MY_LOCALES, my_locales, my_locale_by_name\n#include \"sql_show.h\"     // free_status_vars, add_status_vars,\n                          // reset_status_vars\n#include \"strfunc.h\"      // find_set_from_flags\n#include \"parse_file.h\"   // File_parser_dummy_hook\n#include \"sql_db.h\"       // my_dboptions_cache_free\n                          // my_dboptions_cache_init\n#include \"sql_table.h\"    // release_ddl_log, execute_ddl_log_recovery\n#include \"sql_connect.h\"  // free_max_user_conn, init_max_user_conn,\n                          // handle_one_connection\n#include \"sql_time.h\"     // known_date_time_formats,\n                          // get_date_time_format_str,\n                          // date_time_format_make\n#include \"tztime.h\"       // my_tz_free, my_tz_init, my_tz_SYSTEM\n#include \"hostname.h\"     // hostname_cache_free, hostname_cache_init\n#include \"sql_acl.h\"      // acl_free, grant_free, acl_init,\n                          // grant_init\n#include \"sql_base.h\"\n#include \"sql_test.h\"     // mysql_print_status\n#include \"item_create.h\"  // item_create_cleanup, item_create_init\n#include \"sql_servers.h\"  // servers_free, servers_init\n#include \"init.h\"         // unireg_init\n#include \"derror.h\"       // init_errmessage\n#include \"des_key_file.h\" // load_des_key_file\n#include \"sql_manager.h\"  // stop_handle_manager, start_handle_manager\n#include \"sql_expression_cache.h\" // subquery_cache_miss, subquery_cache_hit\n#include \"sys_vars_shared.h\"\n\n#include <m_ctype.h>\n#include <my_dir.h>\n#include <my_bit.h>\n#include \"slave.h\"\n#include \"rpl_mi.h\"\n#include \"sql_repl.h\"\n#include \"rpl_filter.h\"\n#include \"client_settings.h\"\n#include \"repl_failsafe.h\"\n#include <sql_common.h>\n#include <my_stacktrace.h>\n#include \"mysqld_suffix.h\"\n#include \"mysys_err.h\"\n#include \"events.h\"\n#include \"sql_audit.h\"\n#include \"probes_mysql.h\"\n#include \"scheduler.h\"\n#include <waiting_threads.h>\n#include \"debug_sync.h\"\n#include \"wsrep_mysqld.h\"\n#include \"wsrep_var.h\"\n#ifdef WITH_WSREP\n#include \"wsrep_thd.h\"\n#include \"wsrep_sst.h\"\n#endif /* WITH_WSREP */\n#include \"proxy_protocol.h\"\n\n#include \"sql_callback.h\"\n#include \"threadpool.h\"\n\n#ifdef HAVE_OPENSSL\n#include <ssl_compat.h>\n#endif\n\n#ifdef WITH_PERFSCHEMA_STORAGE_ENGINE\n#include \"../storage/perfschema/pfs_server.h\"\n#endif /* WITH_PERFSCHEMA_STORAGE_ENGINE */\n#include <mysql/psi/mysql_idle.h>\n#include <mysql/psi/mysql_socket.h>\n#include <mysql/psi/mysql_statement.h>\n#include \"mysql_com_server.h\"\n\n#include \"keycaches.h\"\n#include \"../storage/myisam/ha_myisam.h\"\n#include \"set_var.h\"\n\n#include \"rpl_injector.h\"\n#include \"semisync_master.h\"\n#include \"semisync_slave.h\"\n\n#include \"transaction.h\"\n\n#ifdef HAVE_SYS_PRCTL_H\n#include <sys/prctl.h>\n#endif\n\n#include <thr_alarm.h>\n#include <ft_global.h>\n#include <errmsg.h>\n#include \"sp_rcontext.h\"\n#include \"sp_cache.h\"\n#include \"sql_reload.h\"  // reload_acl_and_cache\n#include \"pcre.h\"\n\n#ifdef HAVE_POLL_H\n#include <poll.h>\n#endif\n\n#ifdef _WIN32\n#include <handle_connections_win.h>\n#endif\n\n#include <my_service_manager.h>\n\n#define mysqld_charset &my_charset_latin1\n\n/* We have HAVE_valgrind below as this speeds up the shutdown of MySQL */\n\n#if defined(HAVE_valgrind) && defined(__linux__)\n#define HAVE_CLOSE_SERVER_SOCK 1\n#endif\n\nextern \"C\" {\t\t\t\t\t// Because of SCO 3.2V4.2\n#include <sys/stat.h>\n#ifndef __GNU_LIBRARY__\n#define __GNU_LIBRARY__\t\t\t\t// Skip warnings in getopt.h\n#endif\n#include <my_getopt.h>\n#ifdef HAVE_SYSENT_H\n#include <sysent.h>\n#endif\n#ifdef HAVE_PWD_H\n#include <pwd.h>\t\t\t\t// For struct passwd\n#endif\n#include <my_net.h>\n\n#if !defined(__WIN__)\n#include <sys/resource.h>\n#ifdef HAVE_SYS_UN_H\n#include <sys/un.h>\n#endif\n#ifdef HAVE_SELECT_H\n#include <select.h>\n#endif\n#ifdef HAVE_SYS_SELECT_H\n#include <sys/select.h>\n#endif\n#include <sys/utsname.h>\n#endif /* __WIN__ */\n\n#include <my_libwrap.h>\n\n#ifdef __WIN__ \n#include <crtdbg.h>\n#endif\n\n#ifdef HAVE_SOLARIS_LARGE_PAGES\n#if defined(__sun__) && defined(__GNUC__) && defined(__cplusplus) \\\n    && defined(_XOPEN_SOURCE)\nextern int getpagesizes(size_t *, int);\nextern int getpagesizes2(size_t *, int);\nextern int memcntl(caddr_t, size_t, int, caddr_t, int, int);\n#endif /* __sun__ ... */\n#endif /* HAVE_SOLARIS_LARGE_PAGES */\n\n#ifdef _AIX41\nint initgroups(const char *,unsigned int);\n#endif\n\n#if defined(__FreeBSD__) && defined(HAVE_IEEEFP_H) && !defined(HAVE_FEDISABLEEXCEPT)\n#include <ieeefp.h>\n#ifdef HAVE_FP_EXCEPT\t\t\t\t// Fix type conflict\ntypedef fp_except fp_except_t;\n#endif\n#endif /* __FreeBSD__ && HAVE_IEEEFP_H && !HAVE_FEDISABLEEXCEPT */\n#ifdef HAVE_SYS_FPU_H\n/* for IRIX to use set_fpc_csr() */\n#include <sys/fpu.h>\n#endif\n#ifdef HAVE_FPU_CONTROL_H\n#include <fpu_control.h>\n#endif\n#if defined(__i386__) && !defined(HAVE_FPU_CONTROL_H)\n# define fpu_control_t unsigned int\n# define _FPU_EXTENDED 0x300\n# define _FPU_DOUBLE 0x200\n# if defined(__GNUC__) || (defined(__SUNPRO_CC) && __SUNPRO_CC >= 0x590)\n#  define _FPU_GETCW(cw) asm volatile (\"fnstcw %0\" : \"=m\" (*&cw))\n#  define _FPU_SETCW(cw) asm volatile (\"fldcw %0\" : : \"m\" (*&cw))\n# else\n#  define _FPU_GETCW(cw) (cw= 0)\n#  define _FPU_SETCW(cw)\n# endif\n#endif\n\n#ifndef HAVE_FCNTL\n#define fcntl(X,Y,Z) 0\n#endif\n\ninline void setup_fpu()\n{\n#if defined(__FreeBSD__) && defined(HAVE_IEEEFP_H) && !defined(HAVE_FEDISABLEEXCEPT)\n  /* We can't handle floating point exceptions with threads, so disable\n     this on freebsd\n     Don't fall for overflow, underflow,divide-by-zero or loss of precision.\n     fpsetmask() is deprecated in favor of fedisableexcept() in C99.\n  */\n#if defined(FP_X_DNML)\n  fpsetmask(~(FP_X_INV | FP_X_DNML | FP_X_OFL | FP_X_UFL | FP_X_DZ |\n\t      FP_X_IMP));\n#else\n  fpsetmask(~(FP_X_INV |             FP_X_OFL | FP_X_UFL | FP_X_DZ |\n              FP_X_IMP));\n#endif /* FP_X_DNML */\n#endif /* __FreeBSD__ && HAVE_IEEEFP_H && !HAVE_FEDISABLEEXCEPT */\n\n#ifdef HAVE_FEDISABLEEXCEPT\n  fedisableexcept(FE_ALL_EXCEPT);\n#endif\n\n#ifdef HAVE_FESETROUND\n    /* Set FPU rounding mode to \"round-to-nearest\" */\n  fesetround(FE_TONEAREST);\n#endif /* HAVE_FESETROUND */\n\n  /*\n    x86 (32-bit) requires FPU precision to be explicitly set to 64 bit\n    (double precision) for portable results of floating point operations.\n    However, there is no need to do so if compiler is using SSE2 for floating\n    point, double values will be stored and processed in 64 bits anyway.\n  */\n#if defined(__i386__) && !defined(__SSE2_MATH__)\n#if defined(_WIN32)\n#if !defined(_WIN64)\n  _control87(_PC_53, MCW_PC);\n#endif /* !_WIN64 */\n#else /* !_WIN32 */\n  fpu_control_t cw;\n  _FPU_GETCW(cw);\n  cw= (cw & ~_FPU_EXTENDED) | _FPU_DOUBLE;\n  _FPU_SETCW(cw);\n#endif /* _WIN32 && */\n#endif /* __i386__ */\n\n#if defined(__sgi) && defined(HAVE_SYS_FPU_H)\n  /* Enable denormalized DOUBLE values support for IRIX */\n  union fpc_csr n;\n  n.fc_word = get_fpc_csr();\n  n.fc_struct.flush = 0;\n  set_fpc_csr(n.fc_word);\n#endif\n}\n\n} /* cplusplus */\n\n#define MYSQL_KILL_SIGNAL SIGTERM\n\n#include <my_pthread.h>\t\t\t// For thr_setconcurency()\n\n#ifdef SOLARIS\nextern \"C\" int gethostname(char *name, int namelen);\n#endif\n\nextern \"C\" sig_handler handle_fatal_signal(int sig);\n\n#if defined(__linux__)\n#define ENABLE_TEMP_POOL 1\n#else\n#define ENABLE_TEMP_POOL 0\n#endif\n\nint init_io_cache_encryption();\n\n/* Constants */\n\n#include <welcome_copyright_notice.h> // ORACLE_WELCOME_COPYRIGHT_NOTICE\n\nconst char *show_comp_option_name[]= {\"YES\", \"NO\", \"DISABLED\"};\n\nstatic const char *tc_heuristic_recover_names[]=\n{\n  \"OFF\", \"COMMIT\", \"ROLLBACK\", NullS\n};\nstatic TYPELIB tc_heuristic_recover_typelib=\n{\n  array_elements(tc_heuristic_recover_names)-1,\"\",\n  tc_heuristic_recover_names, NULL\n};\n\nconst char *first_keyword= \"first\";\nconst char *my_localhost= \"localhost\", *delayed_user= \"DELAYED\";\n\nbool opt_large_files= sizeof(my_off_t) > 4;\nstatic my_bool opt_autocommit; ///< for --autocommit command-line option\n\n/*\n  Used with --help for detailed option\n*/\nstatic my_bool opt_verbose= 0;\n\n/* Timer info to be used by the SQL layer */\nMY_TIMER_INFO sys_timer_info;\n\n/* static variables */\n\n#ifdef HAVE_PSI_INTERFACE\n#ifdef HAVE_OPENSSL10\nstatic PSI_rwlock_key key_rwlock_openssl;\n#endif\n#endif /* HAVE_PSI_INTERFACE */\n\n#ifdef HAVE_NPTL\nvolatile sig_atomic_t ld_assume_kernel_is_set= 0;\n#endif\n\n/**\n  Statement instrumentation key for replication.\n*/\n#ifdef HAVE_PSI_STATEMENT_INTERFACE\nPSI_statement_info stmt_info_rpl;\n#endif\n\n/* the default log output is log tables */\nstatic bool lower_case_table_names_used= 0;\nstatic bool max_long_data_size_used= false;\nstatic bool volatile select_thread_in_use, signal_thread_in_use;\nstatic my_bool opt_debugging= 0, opt_external_locking= 0, opt_console= 0;\nstatic my_bool opt_short_log_format= 0, opt_silent_startup= 0;\nbool my_disable_leak_check= false;\n\nuint kill_cached_threads;\nstatic uint wake_thread;\nulong max_used_connections;\nvolatile ulong cached_thread_count= 0;\nstatic char *mysqld_user, *mysqld_chroot;\nstatic char *default_character_set_name;\nstatic char *character_set_filesystem_name;\nstatic char *lc_messages;\nstatic char *lc_time_names_name;\nchar *my_bind_addr_str;\nint server_socket_ai_family;\nstatic char *default_collation_name;\nchar *default_storage_engine, *default_tmp_storage_engine;\nchar *enforced_storage_engine=NULL;\nchar *gtid_pos_auto_engines;\nplugin_ref *opt_gtid_pos_auto_plugins;\nstatic char compiled_default_collation_name[]= MYSQL_DEFAULT_COLLATION_NAME;\nstatic I_List<CONNECT> thread_cache;\nstatic bool binlog_format_used= false;\nLEX_STRING opt_init_connect, opt_init_slave;\nmysql_cond_t COND_thread_cache;\nstatic mysql_cond_t COND_flush_thread_cache;\nmysql_cond_t COND_slave_background;\nstatic DYNAMIC_ARRAY all_options;\nstatic longlong start_memory_used;\n\n/* Global variables */\n\nbool opt_bin_log, opt_bin_log_used=0, opt_ignore_builtin_innodb= 0;\nbool opt_bin_log_compress;\nuint opt_bin_log_compress_min_len;\nmy_bool opt_log, debug_assert_if_crashed_table= 0, opt_help= 0;\nmy_bool debug_assert_on_not_freed_memory= 0;\nmy_bool disable_log_notes, opt_support_flashback= 0;\nstatic my_bool opt_abort;\nulonglong log_output_options;\nmy_bool opt_userstat_running;\nbool opt_error_log= IF_WIN(1,0);\nbool opt_disable_networking=0, opt_skip_show_db=0;\nbool opt_skip_name_resolve=0;\nmy_bool opt_character_set_client_handshake= 1;\nbool opt_endinfo, using_udf_functions;\nmy_bool locked_in_memory;\nbool opt_using_transactions;\nbool volatile abort_loop;\nuint volatile global_disable_checkpoint;\n#if defined(_WIN32) && !defined(EMBEDDED_LIBRARY)\nulong slow_start_timeout;\n#endif\n/**\n   @brief 'grant_option' is used to indicate if privileges needs\n   to be checked, in which case the lock, LOCK_grant, is used\n   to protect access to the grant table.\n   @note This flag is dropped in 5.1\n   @see grant_init()\n */\nbool volatile grant_option;\n\nmy_bool opt_skip_slave_start = 0; ///< If set, slave is not autostarted\nmy_bool opt_reckless_slave = 0;\nmy_bool opt_enable_named_pipe= 0;\nmy_bool opt_local_infile, opt_slave_compressed_protocol;\nmy_bool opt_safe_user_create = 0;\nmy_bool opt_show_slave_auth_info;\nmy_bool opt_log_slave_updates= 0;\nmy_bool opt_replicate_annotate_row_events= 0;\nmy_bool opt_mysql56_temporal_format=0, strict_password_validation= 1;\nmy_bool opt_explicit_defaults_for_timestamp= 0;\nchar *opt_slave_skip_errors;\nchar *opt_slave_transaction_retry_errors;\n\n/*\n  Legacy global handlerton. These will be removed (please do not add more).\n*/\nhandlerton *heap_hton;\nhandlerton *myisam_hton;\nhandlerton *partition_hton;\n\nmy_bool read_only= 0, opt_readonly= 0;\nmy_bool use_temp_pool, relay_log_purge;\nmy_bool relay_log_recovery;\nmy_bool opt_sync_frm, opt_allow_suspicious_udfs;\nmy_bool opt_secure_auth= 0;\nchar* opt_secure_file_priv;\nmy_bool lower_case_file_system= 0;\nmy_bool opt_large_pages= 0;\nmy_bool opt_super_large_pages= 0;\nmy_bool opt_myisam_use_mmap= 0;\nuint   opt_large_page_size= 0;\n#if defined(ENABLED_DEBUG_SYNC)\nMYSQL_PLUGIN_IMPORT uint    opt_debug_sync_timeout= 0;\n#endif /* defined(ENABLED_DEBUG_SYNC) */\nmy_bool opt_old_style_user_limits= 0, trust_function_creators= 0;\nulong opt_replicate_events_marked_for_skip;\n\n/*\n  True if there is at least one per-hour limit for some user, so we should\n  check them before each query (and possibly reset counters when hour is\n  changed). False otherwise.\n*/\nvolatile bool mqh_used = 0;\nmy_bool opt_noacl;\nmy_bool sp_automatic_privileges= 1;\n\nulong opt_binlog_rows_event_max_size;\nmy_bool opt_master_verify_checksum= 0;\nmy_bool opt_slave_sql_verify_checksum= 1;\nconst char *binlog_format_names[]= {\"MIXED\", \"STATEMENT\", \"ROW\", NullS};\nvolatile sig_atomic_t calling_initgroups= 0; /**< Used in SIGSEGV handler. */\nuint mysqld_port, select_errors, dropping_tables, ha_open_options;\nuint mysqld_extra_port;\nuint mysqld_port_timeout;\nulong delay_key_write_options;\nuint protocol_version;\nuint lower_case_table_names;\nulong tc_heuristic_recover= 0;\nAtomic_counter<uint32_t> thread_count;\nbool shutdown_wait_for_slaves;\nint32 slave_open_temp_tables;\nulong thread_created;\nulong back_log, connect_timeout, concurrency, server_id;\nulong what_to_log;\nulong slow_launch_time;\nulong open_files_limit, max_binlog_size;\nulong slave_trans_retries;\nulong slave_trans_retry_interval;\nuint  slave_net_timeout;\nulong slave_exec_mode_options;\nulong slave_run_triggers_for_rbr= 0;\nulong slave_ddl_exec_mode_options= SLAVE_EXEC_MODE_IDEMPOTENT;\nulonglong slave_type_conversions_options;\nulong thread_cache_size=0;\nulonglong binlog_cache_size=0;\nulonglong binlog_file_cache_size=0;\nulonglong max_binlog_cache_size=0;\nulong slave_max_allowed_packet= 0;\nulonglong binlog_stmt_cache_size=0;\nulonglong  max_binlog_stmt_cache_size=0;\nulonglong test_flags;\nulonglong query_cache_size=0;\nulong query_cache_limit=0;\nulong executed_events=0;\nquery_id_t global_query_id;\nulong aborted_threads, aborted_connects, aborted_connects_preauth;\nulong delayed_insert_timeout, delayed_insert_limit, delayed_queue_size;\nulong delayed_insert_threads, delayed_insert_writes, delayed_rows_in_use;\nulong delayed_insert_errors,flush_time;\nulong specialflag=0;\nulong binlog_cache_use= 0, binlog_cache_disk_use= 0;\nulong binlog_stmt_cache_use= 0, binlog_stmt_cache_disk_use= 0;\nulong max_connections, max_connect_errors;\nuint max_password_errors;\nulong extra_max_connections;\nuint max_digest_length= 0;\nulong slave_retried_transactions;\nulong transactions_multi_engine;\nulong rpl_transactions_multi_engine;\nulong transactions_gtid_foreign_engine;\nulonglong slave_skipped_errors;\nulong feature_files_opened_with_delayed_keys= 0, feature_check_constraint= 0;\nulonglong denied_connections;\nmy_decimal decimal_zero;\nlong opt_secure_timestamp;\nuint default_password_lifetime;\nmy_bool disconnect_on_expired_password;\n\n/*\n  Maximum length of parameter value which can be set through\n  mysql_send_long_data() call.\n*/\nulong max_long_data_size;\n\nbool max_user_connections_checking=0;\n/**\n  Limit of the total number of prepared statements in the server.\n  Is necessary to protect the server against out-of-memory attacks.\n*/\nuint max_prepared_stmt_count;\n/**\n  Current total number of prepared statements in the server. This number\n  is exact, and therefore may not be equal to the difference between\n  `com_stmt_prepare' and `com_stmt_close' (global status variables), as\n  the latter ones account for all registered attempts to prepare\n  a statement (including unsuccessful ones).  Prepared statements are\n  currently connection-local: if the same SQL query text is prepared in\n  two different connections, this counts as two distinct prepared\n  statements.\n*/\nuint prepared_stmt_count=0;\nmy_thread_id global_thread_id= 0;\nulong current_pid;\nulong slow_launch_threads = 0;\nuint sync_binlog_period= 0, sync_relaylog_period= 0,\n     sync_relayloginfo_period= 0, sync_masterinfo_period= 0;\nulong expire_logs_days = 0;\n/**\n  Soft upper limit for number of sp_head objects that can be stored\n  in the sp_cache for one connection.\n*/\nulong stored_program_cache_size= 0;\n\nulong opt_slave_parallel_threads= 0;\nulong opt_slave_domain_parallel_threads= 0;\nulong opt_slave_parallel_mode= SLAVE_PARALLEL_CONSERVATIVE;\nulong opt_binlog_commit_wait_count= 0;\nulong opt_binlog_commit_wait_usec= 0;\nulong opt_slave_parallel_max_queued= 131072;\nmy_bool opt_gtid_ignore_duplicates= FALSE;\nuint opt_gtid_cleanup_batch_size= 64;\n\nconst double log_10[] = {\n  1e000, 1e001, 1e002, 1e003, 1e004, 1e005, 1e006, 1e007, 1e008, 1e009,\n  1e010, 1e011, 1e012, 1e013, 1e014, 1e015, 1e016, 1e017, 1e018, 1e019,\n  1e020, 1e021, 1e022, 1e023, 1e024, 1e025, 1e026, 1e027, 1e028, 1e029,\n  1e030, 1e031, 1e032, 1e033, 1e034, 1e035, 1e036, 1e037, 1e038, 1e039,\n  1e040, 1e041, 1e042, 1e043, 1e044, 1e045, 1e046, 1e047, 1e048, 1e049,\n  1e050, 1e051, 1e052, 1e053, 1e054, 1e055, 1e056, 1e057, 1e058, 1e059,\n  1e060, 1e061, 1e062, 1e063, 1e064, 1e065, 1e066, 1e067, 1e068, 1e069,\n  1e070, 1e071, 1e072, 1e073, 1e074, 1e075, 1e076, 1e077, 1e078, 1e079,\n  1e080, 1e081, 1e082, 1e083, 1e084, 1e085, 1e086, 1e087, 1e088, 1e089,\n  1e090, 1e091, 1e092, 1e093, 1e094, 1e095, 1e096, 1e097, 1e098, 1e099,\n  1e100, 1e101, 1e102, 1e103, 1e104, 1e105, 1e106, 1e107, 1e108, 1e109,\n  1e110, 1e111, 1e112, 1e113, 1e114, 1e115, 1e116, 1e117, 1e118, 1e119,\n  1e120, 1e121, 1e122, 1e123, 1e124, 1e125, 1e126, 1e127, 1e128, 1e129,\n  1e130, 1e131, 1e132, 1e133, 1e134, 1e135, 1e136, 1e137, 1e138, 1e139,\n  1e140, 1e141, 1e142, 1e143, 1e144, 1e145, 1e146, 1e147, 1e148, 1e149,\n  1e150, 1e151, 1e152, 1e153, 1e154, 1e155, 1e156, 1e157, 1e158, 1e159,\n  1e160, 1e161, 1e162, 1e163, 1e164, 1e165, 1e166, 1e167, 1e168, 1e169,\n  1e170, 1e171, 1e172, 1e173, 1e174, 1e175, 1e176, 1e177, 1e178, 1e179,\n  1e180, 1e181, 1e182, 1e183, 1e184, 1e185, 1e186, 1e187, 1e188, 1e189,\n  1e190, 1e191, 1e192, 1e193, 1e194, 1e195, 1e196, 1e197, 1e198, 1e199,\n  1e200, 1e201, 1e202, 1e203, 1e204, 1e205, 1e206, 1e207, 1e208, 1e209,\n  1e210, 1e211, 1e212, 1e213, 1e214, 1e215, 1e216, 1e217, 1e218, 1e219,\n  1e220, 1e221, 1e222, 1e223, 1e224, 1e225, 1e226, 1e227, 1e228, 1e229,\n  1e230, 1e231, 1e232, 1e233, 1e234, 1e235, 1e236, 1e237, 1e238, 1e239,\n  1e240, 1e241, 1e242, 1e243, 1e244, 1e245, 1e246, 1e247, 1e248, 1e249,\n  1e250, 1e251, 1e252, 1e253, 1e254, 1e255, 1e256, 1e257, 1e258, 1e259,\n  1e260, 1e261, 1e262, 1e263, 1e264, 1e265, 1e266, 1e267, 1e268, 1e269,\n  1e270, 1e271, 1e272, 1e273, 1e274, 1e275, 1e276, 1e277, 1e278, 1e279,\n  1e280, 1e281, 1e282, 1e283, 1e284, 1e285, 1e286, 1e287, 1e288, 1e289,\n  1e290, 1e291, 1e292, 1e293, 1e294, 1e295, 1e296, 1e297, 1e298, 1e299,\n  1e300, 1e301, 1e302, 1e303, 1e304, 1e305, 1e306, 1e307, 1e308\n};\n\ntime_t server_start_time, flush_status_time;\n\nchar mysql_home[FN_REFLEN], pidfile_name[FN_REFLEN], system_time_zone[30];\nchar *default_tz_name;\nchar log_error_file[FN_REFLEN], glob_hostname[FN_REFLEN], *opt_log_basename;\nchar mysql_real_data_home[FN_REFLEN],\n     lc_messages_dir[FN_REFLEN], reg_ext[FN_EXTLEN],\n     mysql_charsets_dir[FN_REFLEN],\n     *opt_init_file, *opt_tc_log_file;\nchar *lc_messages_dir_ptr= lc_messages_dir, *log_error_file_ptr;\nchar mysql_unpacked_real_data_home[FN_REFLEN];\nsize_t mysql_unpacked_real_data_home_len;\nuint mysql_real_data_home_len, mysql_data_home_len= 1;\nuint reg_ext_length;\nconst key_map key_map_empty(0);\nkey_map key_map_full(0);                        // Will be initialized later\n\nDATE_TIME_FORMAT global_date_format, global_datetime_format, global_time_format;\nTime_zone *default_tz;\n\nconst char *mysql_real_data_home_ptr= mysql_real_data_home;\nchar server_version[SERVER_VERSION_LENGTH], *server_version_ptr;\nbool using_custom_server_version= false;\nchar *mysqld_unix_port, *opt_mysql_tmpdir;\nulong thread_handling;\n\nmy_bool encrypt_binlog;\nmy_bool encrypt_tmp_disk_tables, encrypt_tmp_files;\n\n/** name of reference on left expression in rewritten IN subquery */\nconst LEX_CSTRING in_left_expr_name= {STRING_WITH_LEN(\"<left expr>\") };\n/** name of additional condition */\nconst LEX_CSTRING in_having_cond= {STRING_WITH_LEN(\"<IN HAVING>\") };\nconst LEX_CSTRING in_additional_cond= {STRING_WITH_LEN(\"<IN COND>\") };\n\n/** Number of connection errors when selecting on the listening port */\nulong connection_errors_select= 0;\n/** Number of connection errors when accepting sockets in the listening port. */\nulong connection_errors_accept= 0;\n/** Number of connection errors from TCP wrappers. */\nulong connection_errors_tcpwrap= 0;\n/** Number of connection errors from internal server errors. */\nulong connection_errors_internal= 0;\n/** Number of connection errors from the server max_connection limit. */\nulong connection_errors_max_connection= 0;\n/** Number of errors when reading the peer address. */\nulong connection_errors_peer_addr= 0;\n\n/* classes for comparation parsing/processing */\nEq_creator eq_creator;\nNe_creator ne_creator;\nGt_creator gt_creator;\nLt_creator lt_creator;\nGe_creator ge_creator;\nLe_creator le_creator;\n\nTHD_list server_threads;\nRpl_filter* cur_rpl_filter;\nRpl_filter* global_rpl_filter;\nRpl_filter* binlog_filter;\n\nstruct system_variables global_system_variables;\n/**\n  Following is just for options parsing, used with a difference against\n  global_system_variables.\n\n  TODO: something should be done to get rid of following variables\n*/\nconst char *current_dbug_option=\"\";\n\nstruct system_variables max_system_variables;\nstruct system_status_var global_status_var;\n\nMY_TMPDIR mysql_tmpdir_list;\nMY_BITMAP temp_pool;\n\nCHARSET_INFO *system_charset_info, *files_charset_info ;\nCHARSET_INFO *national_charset_info, *table_alias_charset;\nCHARSET_INFO *character_set_filesystem;\nCHARSET_INFO *error_message_charset_info;\n\nMY_LOCALE *my_default_lc_messages;\nMY_LOCALE *my_default_lc_time_names;\n\nSHOW_COMP_OPTION have_ssl, have_symlink, have_dlopen, have_query_cache;\nSHOW_COMP_OPTION have_geometry, have_rtree_keys;\nSHOW_COMP_OPTION have_crypt, have_compress;\nSHOW_COMP_OPTION have_profiling;\nSHOW_COMP_OPTION have_openssl;\n\n#ifndef EMBEDDED_LIBRARY\nstatic std::atomic<char*> shutdown_user;\n#endif //EMBEDDED_LIBRARY\n\n/* Thread specific variables */\n\npthread_key(THD*, THR_THD);\n\n/*\n  LOCK_start_thread is used to syncronize thread start and stop with\n  other threads.\n\n  It also protects these variables:\n  select_thread_in_use\n  slave_init_thread_running\n  check_temp_dir() call\n*/\nmysql_mutex_t  LOCK_start_thread;\n\nmysql_mutex_t LOCK_thread_cache;\nmysql_mutex_t\n  LOCK_status, LOCK_error_log, LOCK_short_uuid_generator,\n  LOCK_delayed_insert, LOCK_delayed_status, LOCK_delayed_create,\n  LOCK_crypt,\n  LOCK_global_system_variables,\n  LOCK_user_conn,\n  LOCK_connection_count, LOCK_error_messages, LOCK_slave_background;\nmysql_mutex_t LOCK_stats, LOCK_global_user_client_stats,\n              LOCK_global_table_stats, LOCK_global_index_stats;\n\n/* This protects against changes in master_info_index */\nmysql_mutex_t LOCK_active_mi;\n\n/* This protects connection id.*/\nmysql_mutex_t LOCK_thread_id;\n\n/**\n  The below lock protects access to two global server variables:\n  max_prepared_stmt_count and prepared_stmt_count. These variables\n  set the limit and hold the current total number of prepared statements\n  in the server, respectively. As PREPARE/DEALLOCATE rate in a loaded\n  server may be fairly high, we need a dedicated lock.\n*/\nmysql_mutex_t LOCK_prepared_stmt_count;\n#ifdef HAVE_OPENSSL\nmysql_mutex_t LOCK_des_key_file;\n#endif\nmysql_rwlock_t LOCK_grant, LOCK_sys_init_connect, LOCK_sys_init_slave;\nmysql_rwlock_t LOCK_ssl_refresh;\nmysql_rwlock_t LOCK_all_status_vars;\nmysql_prlock_t LOCK_system_variables_hash;\nmysql_cond_t COND_start_thread;\npthread_t signal_thread;\npthread_attr_t connection_attrib;\nmysql_mutex_t LOCK_server_started;\nmysql_cond_t COND_server_started;\n\nint mysqld_server_started=0, mysqld_server_initialized= 0;\nFile_parser_dummy_hook file_parser_dummy_hook;\n\n/* replication parameters, if master_host is not NULL, we are a slave */\nuint report_port= 0;\nulong master_retry_count=0;\nchar *master_info_file;\nchar *relay_log_info_file, *report_user, *report_password, *report_host;\nchar *opt_relay_logname = 0, *opt_relaylog_index_name=0;\nchar *opt_logname, *opt_slow_logname, *opt_bin_logname;\nchar *opt_binlog_index_name=0;\n\n/* Static variables */\n\nmy_bool opt_stack_trace;\nmy_bool opt_expect_abort= 0, opt_bootstrap= 0;\nstatic my_bool opt_myisam_log;\nstatic int cleanup_done;\nstatic ulong opt_specialflag;\nchar *mysql_home_ptr, *pidfile_name_ptr;\n/** Initial command line arguments (count), after load_defaults().*/\nstatic int defaults_argc;\n/**\n  Initial command line arguments (arguments), after load_defaults().\n  This memory is allocated by @c load_defaults() and should be freed\n  using @c free_defaults().\n  Do not modify defaults_argc / defaults_argv,\n  use remaining_argc / remaining_argv instead to parse the command\n  line arguments in multiple steps.\n*/\nstatic char **defaults_argv;\n/** Remaining command line arguments (count), filtered by handle_options().*/\nstatic int remaining_argc;\n/** Remaining command line arguments (arguments), filtered by handle_options().*/\nstatic char **remaining_argv;\n\nint orig_argc;\nchar **orig_argv;\n\nstatic struct my_option pfs_early_options[]=\n{\n#ifdef WITH_PERFSCHEMA_STORAGE_ENGINE\n  {\"performance_schema_instrument\", OPT_PFS_INSTRUMENT,\n    \"Default startup value for a performance schema instrument.\",\n    &pfs_param.m_pfs_instrument, &pfs_param.m_pfs_instrument, 0, GET_STR,\n    OPT_ARG, 0, 0, 0, 0, 0, 0},\n  {\"performance_schema_consumer_events_stages_current\", 0,\n    \"Default startup value for the events_stages_current consumer.\",\n    &pfs_param.m_consumer_events_stages_current_enabled,\n    &pfs_param.m_consumer_events_stages_current_enabled, 0, GET_BOOL,\n    OPT_ARG, FALSE, 0, 0, 0, 0, 0},\n  {\"performance_schema_consumer_events_stages_history\", 0,\n    \"Default startup value for the events_stages_history consumer.\",\n    &pfs_param.m_consumer_events_stages_history_enabled,\n    &pfs_param.m_consumer_events_stages_history_enabled, 0,\n    GET_BOOL, OPT_ARG, FALSE, 0, 0, 0, 0, 0},\n  {\"performance_schema_consumer_events_stages_history_long\", 0,\n    \"Default startup value for the events_stages_history_long consumer.\",\n    &pfs_param.m_consumer_events_stages_history_long_enabled,\n    &pfs_param.m_consumer_events_stages_history_long_enabled, 0,\n    GET_BOOL, OPT_ARG, FALSE, 0, 0, 0, 0, 0},\n  {\"performance_schema_consumer_events_statements_current\", 0,\n    \"Default startup value for the events_statements_current consumer.\",\n    &pfs_param.m_consumer_events_statements_current_enabled,\n    &pfs_param.m_consumer_events_statements_current_enabled, 0,\n    GET_BOOL, OPT_ARG, TRUE, 0, 0, 0, 0, 0},\n  {\"performance_schema_consumer_events_statements_history\", 0,\n    \"Default startup value for the events_statements_history consumer.\",\n    &pfs_param.m_consumer_events_statements_history_enabled,\n    &pfs_param.m_consumer_events_statements_history_enabled, 0,\n    GET_BOOL, OPT_ARG, FALSE, 0, 0, 0, 0, 0},\n  {\"performance_schema_consumer_events_statements_history_long\", 0,\n    \"Default startup value for the events_statements_history_long consumer.\",\n    &pfs_param.m_consumer_events_statements_history_long_enabled,\n    &pfs_param.m_consumer_events_statements_history_long_enabled, 0,\n    GET_BOOL, OPT_ARG, FALSE, 0, 0, 0, 0, 0},\n  {\"performance_schema_consumer_events_waits_current\", 0,\n    \"Default startup value for the events_waits_current consumer.\",\n    &pfs_param.m_consumer_events_waits_current_enabled,\n    &pfs_param.m_consumer_events_waits_current_enabled, 0,\n    GET_BOOL, OPT_ARG, FALSE, 0, 0, 0, 0, 0},\n  {\"performance_schema_consumer_events_waits_history\", 0,\n    \"Default startup value for the events_waits_history consumer.\",\n    &pfs_param.m_consumer_events_waits_history_enabled,\n    &pfs_param.m_consumer_events_waits_history_enabled, 0,\n    GET_BOOL, OPT_ARG, FALSE, 0, 0, 0, 0, 0},\n  {\"performance_schema_consumer_events_waits_history_long\", 0,\n    \"Default startup value for the events_waits_history_long consumer.\",\n    &pfs_param.m_consumer_events_waits_history_long_enabled,\n    &pfs_param.m_consumer_events_waits_history_long_enabled, 0,\n    GET_BOOL, OPT_ARG, FALSE, 0, 0, 0, 0, 0},\n  {\"performance_schema_consumer_global_instrumentation\", 0,\n    \"Default startup value for the global_instrumentation consumer.\",\n    &pfs_param.m_consumer_global_instrumentation_enabled,\n    &pfs_param.m_consumer_global_instrumentation_enabled, 0,\n    GET_BOOL, OPT_ARG, TRUE, 0, 0, 0, 0, 0},\n  {\"performance_schema_consumer_thread_instrumentation\", 0,\n    \"Default startup value for the thread_instrumentation consumer.\",\n    &pfs_param.m_consumer_thread_instrumentation_enabled,\n    &pfs_param.m_consumer_thread_instrumentation_enabled, 0,\n    GET_BOOL, OPT_ARG, TRUE, 0, 0, 0, 0, 0},\n  {\"performance_schema_consumer_statements_digest\", 0,\n    \"Default startup value for the statements_digest consumer.\",\n    &pfs_param.m_consumer_statement_digest_enabled,\n    &pfs_param.m_consumer_statement_digest_enabled, 0,\n    GET_BOOL, OPT_ARG, TRUE, 0, 0, 0, 0, 0},\n#endif /* WITH_PERFSCHEMA_STORAGE_ENGINE */\n  {\"getopt-prefix-matching\", 0,\n    \"Recognize command-line options by their unambiguos prefixes.\",\n    &my_getopt_prefix_matching, &my_getopt_prefix_matching, 0, GET_BOOL,\n    NO_ARG, 1, 0, 1, 0, 0, 0}\n};\n\n#ifdef HAVE_PSI_INTERFACE\n#ifdef HAVE_MMAP\nPSI_mutex_key key_PAGE_lock, key_LOCK_sync, key_LOCK_active, key_LOCK_pool,\n  key_LOCK_pending_checkpoint;\n#endif /* HAVE_MMAP */\n\n#ifdef HAVE_OPENSSL\nPSI_mutex_key key_LOCK_des_key_file;\n#endif /* HAVE_OPENSSL */\n\nPSI_mutex_key key_BINLOG_LOCK_index, key_BINLOG_LOCK_xid_list,\n  key_BINLOG_LOCK_binlog_background_thread,\n  key_LOCK_binlog_end_pos,\n  key_delayed_insert_mutex, key_hash_filo_lock, key_LOCK_active_mi,\n  key_LOCK_connection_count, key_LOCK_crypt, key_LOCK_delayed_create,\n  key_LOCK_delayed_insert, key_LOCK_delayed_status, key_LOCK_error_log,\n  key_LOCK_gdl, key_LOCK_global_system_variables,\n  key_LOCK_manager,\n  key_LOCK_prepared_stmt_count,\n  key_LOCK_rpl_status, key_LOCK_server_started,\n  key_LOCK_status,\n  key_LOCK_system_variables_hash, key_LOCK_thd_data, key_LOCK_thd_kill,\n  key_LOCK_user_conn, key_LOCK_uuid_short_generator, key_LOG_LOCK_log,\n  key_master_info_data_lock, key_master_info_run_lock,\n  key_master_info_sleep_lock, key_master_info_start_stop_lock,\n  key_mutex_slave_reporting_capability_err_lock, key_relay_log_info_data_lock,\n  key_rpl_group_info_sleep_lock,\n  key_relay_log_info_log_space_lock, key_relay_log_info_run_lock,\n  key_structure_guard_mutex, key_TABLE_SHARE_LOCK_ha_data,\n  key_LOCK_error_messages,\n  key_LOCK_start_thread,\n  key_LOCK_thread_cache,\n  key_PARTITION_LOCK_auto_inc;\nPSI_mutex_key key_RELAYLOG_LOCK_index;\nPSI_mutex_key key_LOCK_relaylog_end_pos;\nPSI_mutex_key key_LOCK_thread_id;\nPSI_mutex_key key_LOCK_slave_state, key_LOCK_binlog_state,\n  key_LOCK_rpl_thread, key_LOCK_rpl_thread_pool, key_LOCK_parallel_entry;\nPSI_mutex_key key_LOCK_rpl_semi_sync_master_enabled;\nPSI_mutex_key key_LOCK_binlog;\n\nPSI_mutex_key key_LOCK_stats,\n  key_LOCK_global_user_client_stats, key_LOCK_global_table_stats,\n  key_LOCK_global_index_stats,\n  key_LOCK_wakeup_ready, key_LOCK_wait_commit;\nPSI_mutex_key key_LOCK_gtid_waiting;\n\nPSI_mutex_key key_LOCK_after_binlog_sync;\nPSI_mutex_key key_LOCK_prepare_ordered, key_LOCK_commit_ordered,\n  key_LOCK_slave_background;\nPSI_mutex_key key_TABLE_SHARE_LOCK_share;\nPSI_mutex_key key_LOCK_ack_receiver;\n\nPSI_mutex_key key_TABLE_SHARE_LOCK_rotation;\nPSI_cond_key key_TABLE_SHARE_COND_rotation;\n\nstatic PSI_mutex_info all_server_mutexes[]=\n{\n#ifdef HAVE_MMAP\n  { &key_PAGE_lock, \"PAGE::lock\", 0},\n  { &key_LOCK_sync, \"TC_LOG_MMAP::LOCK_sync\", 0},\n  { &key_LOCK_active, \"TC_LOG_MMAP::LOCK_active\", 0},\n  { &key_LOCK_pool, \"TC_LOG_MMAP::LOCK_pool\", 0},\n  { &key_LOCK_pool, \"TC_LOG_MMAP::LOCK_pending_checkpoint\", 0},\n#endif /* HAVE_MMAP */\n\n#ifdef HAVE_OPENSSL\n  { &key_LOCK_des_key_file, \"LOCK_des_key_file\", PSI_FLAG_GLOBAL},\n#endif /* HAVE_OPENSSL */\n\n  { &key_BINLOG_LOCK_index, \"MYSQL_BIN_LOG::LOCK_index\", 0},\n  { &key_BINLOG_LOCK_xid_list, \"MYSQL_BIN_LOG::LOCK_xid_list\", 0},\n  { &key_BINLOG_LOCK_binlog_background_thread, \"MYSQL_BIN_LOG::LOCK_binlog_background_thread\", 0},\n  { &key_LOCK_binlog_end_pos, \"MYSQL_BIN_LOG::LOCK_binlog_end_pos\", 0 },\n  { &key_RELAYLOG_LOCK_index, \"MYSQL_RELAY_LOG::LOCK_index\", 0},\n  { &key_LOCK_relaylog_end_pos, \"MYSQL_RELAY_LOG::LOCK_binlog_end_pos\", 0},\n  { &key_delayed_insert_mutex, \"Delayed_insert::mutex\", 0},\n  { &key_hash_filo_lock, \"hash_filo::lock\", 0},\n  { &key_LOCK_active_mi, \"LOCK_active_mi\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_connection_count, \"LOCK_connection_count\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_thread_id, \"LOCK_thread_id\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_crypt, \"LOCK_crypt\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_delayed_create, \"LOCK_delayed_create\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_delayed_insert, \"LOCK_delayed_insert\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_delayed_status, \"LOCK_delayed_status\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_error_log, \"LOCK_error_log\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_gdl, \"LOCK_gdl\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_global_system_variables, \"LOCK_global_system_variables\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_manager, \"LOCK_manager\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_prepared_stmt_count, \"LOCK_prepared_stmt_count\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_rpl_status, \"LOCK_rpl_status\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_server_started, \"LOCK_server_started\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_status, \"LOCK_status\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_system_variables_hash, \"LOCK_system_variables_hash\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_stats, \"LOCK_stats\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_global_user_client_stats, \"LOCK_global_user_client_stats\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_global_table_stats, \"LOCK_global_table_stats\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_global_index_stats, \"LOCK_global_index_stats\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_wakeup_ready, \"THD::LOCK_wakeup_ready\", 0},\n  { &key_LOCK_wait_commit, \"wait_for_commit::LOCK_wait_commit\", 0},\n  { &key_LOCK_gtid_waiting, \"gtid_waiting::LOCK_gtid_waiting\", 0},\n  { &key_LOCK_thd_data, \"THD::LOCK_thd_data\", 0},\n  { &key_LOCK_thd_kill, \"THD::LOCK_thd_kill\", 0},\n  { &key_LOCK_user_conn, \"LOCK_user_conn\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_uuid_short_generator, \"LOCK_uuid_short_generator\", PSI_FLAG_GLOBAL},\n  { &key_LOG_LOCK_log, \"LOG::LOCK_log\", 0},\n  { &key_master_info_data_lock, \"Master_info::data_lock\", 0},\n  { &key_master_info_start_stop_lock, \"Master_info::start_stop_lock\", 0},\n  { &key_master_info_run_lock, \"Master_info::run_lock\", 0},\n  { &key_master_info_sleep_lock, \"Master_info::sleep_lock\", 0},\n  { &key_mutex_slave_reporting_capability_err_lock, \"Slave_reporting_capability::err_lock\", 0},\n  { &key_relay_log_info_data_lock, \"Relay_log_info::data_lock\", 0},\n  { &key_relay_log_info_log_space_lock, \"Relay_log_info::log_space_lock\", 0},\n  { &key_relay_log_info_run_lock, \"Relay_log_info::run_lock\", 0},\n  { &key_rpl_group_info_sleep_lock, \"Rpl_group_info::sleep_lock\", 0},\n  { &key_structure_guard_mutex, \"Query_cache::structure_guard_mutex\", 0},\n  { &key_TABLE_SHARE_LOCK_ha_data, \"TABLE_SHARE::LOCK_ha_data\", 0},\n  { &key_TABLE_SHARE_LOCK_share, \"TABLE_SHARE::LOCK_share\", 0},\n  { &key_TABLE_SHARE_LOCK_rotation, \"TABLE_SHARE::LOCK_rotation\", 0},\n  { &key_LOCK_error_messages, \"LOCK_error_messages\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_prepare_ordered, \"LOCK_prepare_ordered\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_after_binlog_sync, \"LOCK_after_binlog_sync\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_commit_ordered, \"LOCK_commit_ordered\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_slave_background, \"LOCK_slave_background\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_thread_cache, \"LOCK_thread_cache\", PSI_FLAG_GLOBAL},\n  { &key_PARTITION_LOCK_auto_inc, \"HA_DATA_PARTITION::LOCK_auto_inc\", 0},\n  { &key_LOCK_slave_state, \"LOCK_slave_state\", 0},\n  { &key_LOCK_start_thread, \"LOCK_start_thread\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_binlog_state, \"LOCK_binlog_state\", 0},\n  { &key_LOCK_rpl_thread, \"LOCK_rpl_thread\", 0},\n  { &key_LOCK_rpl_thread_pool, \"LOCK_rpl_thread_pool\", 0},\n  { &key_LOCK_parallel_entry, \"LOCK_parallel_entry\", 0},\n  { &key_LOCK_ack_receiver, \"Ack_receiver::mutex\", 0},\n  { &key_LOCK_rpl_semi_sync_master_enabled, \"LOCK_rpl_semi_sync_master_enabled\", 0},\n  { &key_LOCK_binlog, \"LOCK_binlog\", 0}\n};\n\nPSI_rwlock_key key_rwlock_LOCK_grant, key_rwlock_LOCK_logger,\n  key_rwlock_LOCK_sys_init_connect, key_rwlock_LOCK_sys_init_slave,\n  key_rwlock_LOCK_system_variables_hash, key_rwlock_query_cache_query_lock,\n  key_LOCK_SEQUENCE,\n  key_rwlock_LOCK_vers_stats, key_rwlock_LOCK_stat_serial,\n  key_rwlock_LOCK_ssl_refresh,\n  key_rwlock_THD_list,\n  key_rwlock_LOCK_all_status_vars;\n\nstatic PSI_rwlock_info all_server_rwlocks[]=\n{\n#ifdef HAVE_OPENSSL10\n  { &key_rwlock_openssl, \"CRYPTO_dynlock_value::lock\", 0},\n#endif\n  { &key_rwlock_LOCK_grant, \"LOCK_grant\", PSI_FLAG_GLOBAL},\n  { &key_rwlock_LOCK_logger, \"LOGGER::LOCK_logger\", 0},\n  { &key_rwlock_LOCK_sys_init_connect, \"LOCK_sys_init_connect\", PSI_FLAG_GLOBAL},\n  { &key_rwlock_LOCK_sys_init_slave, \"LOCK_sys_init_slave\", PSI_FLAG_GLOBAL},\n  { &key_LOCK_SEQUENCE, \"LOCK_SEQUENCE\", 0},\n  { &key_rwlock_LOCK_system_variables_hash, \"LOCK_system_variables_hash\", PSI_FLAG_GLOBAL},\n  { &key_rwlock_query_cache_query_lock, \"Query_cache_query::lock\", 0},\n  { &key_rwlock_LOCK_vers_stats, \"Vers_field_stats::lock\", 0},\n  { &key_rwlock_LOCK_stat_serial, \"TABLE_SHARE::LOCK_stat_serial\", 0},\n  { &key_rwlock_LOCK_ssl_refresh, \"LOCK_ssl_refresh\", PSI_FLAG_GLOBAL },\n  { &key_rwlock_THD_list, \"THD_list::lock\", PSI_FLAG_GLOBAL },\n  { &key_rwlock_LOCK_all_status_vars, \"LOCK_all_status_vars\", PSI_FLAG_GLOBAL }\n};\n\n#ifdef HAVE_MMAP\nPSI_cond_key key_PAGE_cond, key_COND_active, key_COND_pool;\n#endif /* HAVE_MMAP */\n\nPSI_cond_key key_BINLOG_COND_xid_list,\n  key_BINLOG_COND_bin_log_updated, key_BINLOG_COND_relay_log_updated,\n  key_BINLOG_COND_binlog_background_thread,\n  key_BINLOG_COND_binlog_background_thread_end,\n  key_COND_cache_status_changed, key_COND_manager,\n  key_COND_rpl_status, key_COND_server_started,\n  key_delayed_insert_cond, key_delayed_insert_cond_client,\n  key_item_func_sleep_cond, key_master_info_data_cond,\n  key_master_info_start_cond, key_master_info_stop_cond,\n  key_master_info_sleep_cond,\n  key_relay_log_info_data_cond, key_relay_log_info_log_space_cond,\n  key_relay_log_info_start_cond, key_relay_log_info_stop_cond,\n  key_rpl_group_info_sleep_cond,\n  key_TABLE_SHARE_cond, key_user_level_lock_cond,\n  key_COND_thread_cache, key_COND_flush_thread_cache,\n  key_COND_start_thread, key_COND_binlog_send,\n  key_BINLOG_COND_queue_busy;\nPSI_cond_key key_RELAYLOG_COND_relay_log_updated,\n  key_RELAYLOG_COND_bin_log_updated, key_COND_wakeup_ready,\n  key_COND_wait_commit;\nPSI_cond_key key_RELAYLOG_COND_queue_busy;\nPSI_cond_key key_TC_LOG_MMAP_COND_queue_busy;\nPSI_cond_key key_COND_rpl_thread_queue, key_COND_rpl_thread,\n  key_COND_rpl_thread_stop, key_COND_rpl_thread_pool,\n  key_COND_parallel_entry, key_COND_group_commit_orderer,\n  key_COND_prepare_ordered, key_COND_slave_background;\nPSI_cond_key key_COND_wait_gtid, key_COND_gtid_ignore_duplicates;\nPSI_cond_key key_COND_ack_receiver;\n\nstatic PSI_cond_info all_server_conds[]=\n{\n#ifdef HAVE_MMAP\n  { &key_PAGE_cond, \"PAGE::cond\", 0},\n  { &key_COND_active, \"TC_LOG_MMAP::COND_active\", 0},\n  { &key_COND_pool, \"TC_LOG_MMAP::COND_pool\", 0},\n  { &key_TC_LOG_MMAP_COND_queue_busy, \"TC_LOG_MMAP::COND_queue_busy\", 0},\n#endif /* HAVE_MMAP */\n  { &key_BINLOG_COND_bin_log_updated, \"MYSQL_BIN_LOG::COND_bin_log_updated\", 0}, { &key_BINLOG_COND_relay_log_updated, \"MYSQL_BIN_LOG::COND_relay_log_updated\", 0},\n  { &key_BINLOG_COND_xid_list, \"MYSQL_BIN_LOG::COND_xid_list\", 0},\n  { &key_BINLOG_COND_binlog_background_thread, \"MYSQL_BIN_LOG::COND_binlog_background_thread\", 0},\n  { &key_BINLOG_COND_binlog_background_thread_end, \"MYSQL_BIN_LOG::COND_binlog_background_thread_end\", 0},\n  { &key_BINLOG_COND_queue_busy, \"MYSQL_BIN_LOG::COND_queue_busy\", 0},\n  { &key_RELAYLOG_COND_relay_log_updated, \"MYSQL_RELAY_LOG::COND_relay_log_updated\", 0},\n  { &key_RELAYLOG_COND_bin_log_updated, \"MYSQL_RELAY_LOG::COND_bin_log_updated\", 0},\n  { &key_RELAYLOG_COND_queue_busy, \"MYSQL_RELAY_LOG::COND_queue_busy\", 0},\n  { &key_COND_wakeup_ready, \"THD::COND_wakeup_ready\", 0},\n  { &key_COND_wait_commit, \"wait_for_commit::COND_wait_commit\", 0},\n  { &key_COND_cache_status_changed, \"Query_cache::COND_cache_status_changed\", 0},\n  { &key_COND_manager, \"COND_manager\", PSI_FLAG_GLOBAL},\n  { &key_COND_server_started, \"COND_server_started\", PSI_FLAG_GLOBAL},\n  { &key_delayed_insert_cond, \"Delayed_insert::cond\", 0},\n  { &key_delayed_insert_cond_client, \"Delayed_insert::cond_client\", 0},\n  { &key_item_func_sleep_cond, \"Item_func_sleep::cond\", 0},\n  { &key_master_info_data_cond, \"Master_info::data_cond\", 0},\n  { &key_master_info_start_cond, \"Master_info::start_cond\", 0},\n  { &key_master_info_stop_cond, \"Master_info::stop_cond\", 0},\n  { &key_master_info_sleep_cond, \"Master_info::sleep_cond\", 0},\n  { &key_relay_log_info_data_cond, \"Relay_log_info::data_cond\", 0},\n  { &key_relay_log_info_log_space_cond, \"Relay_log_info::log_space_cond\", 0},\n  { &key_relay_log_info_start_cond, \"Relay_log_info::start_cond\", 0},\n  { &key_relay_log_info_stop_cond, \"Relay_log_info::stop_cond\", 0},\n  { &key_rpl_group_info_sleep_cond, \"Rpl_group_info::sleep_cond\", 0},\n  { &key_TABLE_SHARE_cond, \"TABLE_SHARE::cond\", 0},\n  { &key_user_level_lock_cond, \"User_level_lock::cond\", 0},\n  { &key_COND_thread_cache, \"COND_thread_cache\", PSI_FLAG_GLOBAL},\n  { &key_COND_flush_thread_cache, \"COND_flush_thread_cache\", PSI_FLAG_GLOBAL},\n  { &key_COND_rpl_thread, \"COND_rpl_thread\", 0},\n  { &key_COND_rpl_thread_queue, \"COND_rpl_thread_queue\", 0},\n  { &key_COND_rpl_thread_stop, \"COND_rpl_thread_stop\", 0},\n  { &key_COND_rpl_thread_pool, \"COND_rpl_thread_pool\", 0},\n  { &key_COND_parallel_entry, \"COND_parallel_entry\", 0},\n  { &key_COND_group_commit_orderer, \"COND_group_commit_orderer\", 0},\n  { &key_COND_prepare_ordered, \"COND_prepare_ordered\", 0},\n  { &key_COND_slave_background, \"COND_slave_background\", 0},\n  { &key_COND_start_thread, \"COND_start_thread\", PSI_FLAG_GLOBAL},\n  { &key_COND_wait_gtid, \"COND_wait_gtid\", 0},\n  { &key_COND_gtid_ignore_duplicates, \"COND_gtid_ignore_duplicates\", 0},\n  { &key_COND_ack_receiver, \"Ack_receiver::cond\", 0},\n  { &key_COND_binlog_send, \"COND_binlog_send\", 0},\n  { &key_TABLE_SHARE_COND_rotation, \"TABLE_SHARE::COND_rotation\", 0}\n};\n\nPSI_thread_key key_thread_delayed_insert,\n  key_thread_handle_manager, key_thread_main,\n  key_thread_one_connection, key_thread_signal_hand,\n  key_thread_slave_background, key_rpl_parallel_thread;\nPSI_thread_key key_thread_ack_receiver;\n\nstatic PSI_thread_info all_server_threads[]=\n{\n  { &key_thread_delayed_insert, \"delayed_insert\", 0},\n  { &key_thread_handle_manager, \"manager\", PSI_FLAG_GLOBAL},\n  { &key_thread_main, \"main\", PSI_FLAG_GLOBAL},\n  { &key_thread_one_connection, \"one_connection\", 0},\n  { &key_thread_signal_hand, \"signal_handler\", PSI_FLAG_GLOBAL},\n  { &key_thread_slave_background, \"slave_background\", PSI_FLAG_GLOBAL},\n  { &key_thread_ack_receiver, \"Ack_receiver\", PSI_FLAG_GLOBAL},\n  { &key_rpl_parallel_thread, \"rpl_parallel_thread\", 0}\n};\n\n#ifdef HAVE_MMAP\nPSI_file_key key_file_map;\n#endif /* HAVE_MMAP */\n\nPSI_file_key key_file_binlog, key_file_binlog_index, key_file_casetest,\n  key_file_dbopt, key_file_des_key_file, key_file_ERRMSG, key_select_to_file,\n  key_file_fileparser, key_file_frm, key_file_global_ddl_log, key_file_load,\n  key_file_loadfile, key_file_log_event_data, key_file_log_event_info,\n  key_file_master_info, key_file_misc, key_file_partition,\n  key_file_pid, key_file_relay_log_info, key_file_send_file, key_file_tclog,\n  key_file_trg, key_file_trn, key_file_init;\nPSI_file_key key_file_query_log, key_file_slow_log;\nPSI_file_key key_file_relaylog, key_file_relaylog_index;\nPSI_file_key key_file_binlog_state;\n\n#endif /* HAVE_PSI_INTERFACE */\n\n#ifdef HAVE_PSI_STATEMENT_INTERFACE\nPSI_statement_info stmt_info_new_packet;\n#endif\n\n#ifndef EMBEDDED_LIBRARY\nvoid net_before_header_psi(struct st_net *net, void *thd, size_t /* unused: count */)\n{\n  DBUG_ASSERT(thd);\n  /*\n    We only come where when the server is IDLE, waiting for the next command.\n    Technically, it is a wait on a socket, which may take a long time,\n    because the call is blocking.\n    Disable the socket instrumentation, to avoid recording a SOCKET event.\n    Instead, start explicitly an IDLE event.\n  */\n  MYSQL_SOCKET_SET_STATE(net->vio->mysql_socket, PSI_SOCKET_STATE_IDLE);\n  MYSQL_START_IDLE_WAIT(static_cast<THD*>(thd)->m_idle_psi,\n                        &static_cast<THD*>(thd)->m_idle_state);\n}\n\nvoid net_after_header_psi(struct st_net *net, void *user_data,\n                          size_t /* unused: count */, my_bool rc)\n{\n  THD *thd;\n  thd= static_cast<THD*> (user_data);\n  DBUG_ASSERT(thd != NULL);\n\n  /*\n    The server just got data for a network packet header,\n    from the network layer.\n    The IDLE event is now complete, since we now have a message to process.\n    We need to:\n    - start a new STATEMENT event\n    - start a new STAGE event, within this statement,\n    - start recording SOCKET WAITS events, within this stage.\n    The proper order is critical to get events numbered correctly,\n    and nested in the proper parent.\n  */\n  MYSQL_END_IDLE_WAIT(thd->m_idle_psi);\n\n  if (! rc)\n  {\n    thd->m_statement_psi= MYSQL_START_STATEMENT(&thd->m_statement_state,\n                                                stmt_info_new_packet.m_key,\n                                                thd->get_db(), thd->db.length,\n                                                thd->charset());\n\n    THD_STAGE_INFO(thd, stage_init);\n  }\n\n  /*\n    TODO: consider recording a SOCKET event for the bytes just read,\n    by also passing count here.\n  */\n  MYSQL_SOCKET_SET_STATE(net->vio->mysql_socket, PSI_SOCKET_STATE_ACTIVE);\n}\n\n\nvoid init_net_server_extension(THD *thd)\n{\n  /* Start with a clean state for connection events. */\n  thd->m_idle_psi= NULL;\n  thd->m_statement_psi= NULL;\n  /* Hook up the NET_SERVER callback in the net layer. */\n  thd->m_net_server_extension.m_user_data= thd;\n  thd->m_net_server_extension.m_before_header= net_before_header_psi;\n  thd->m_net_server_extension.m_after_header= net_after_header_psi;\n  /* Activate this private extension for the mysqld server. */\n  thd->net.extension= & thd->m_net_server_extension;\n}\n#else\nvoid init_net_server_extension(THD *thd)\n{\n}\n#endif /* EMBEDDED_LIBRARY */\n\n\n/**\n  A log message for the error log, buffered in memory.\n  Log messages are temporarily buffered when generated before the error log\n  is initialized, and then printed once the error log is ready.\n*/\nclass Buffered_log : public Sql_alloc\n{\npublic:\n  Buffered_log(enum loglevel level, const char *message);\n\n  ~Buffered_log()\n  {}\n\n  void print(void);\n\nprivate:\n  /** Log message level. */\n  enum loglevel m_level;\n  /** Log message text. */\n  String m_message;\n};\n\n/**\n  Constructor.\n  @param level          the message log level\n  @param message        the message text\n*/\nBuffered_log::Buffered_log(enum loglevel level, const char *message)\n  : m_level(level), m_message()\n{\n  m_message.copy(message, strlen(message), &my_charset_latin1);\n}\n\n/**\n  Print a buffered log to the real log file.\n*/\nvoid Buffered_log::print()\n{\n  /*\n    Since messages are buffered, they can be printed out\n    of order with other entries in the log.\n    Add \"Buffered xxx\" to the message text to prevent confusion.\n  */\n  switch(m_level)\n  {\n  case ERROR_LEVEL:\n    sql_print_error(\"Buffered error: %s\", m_message.c_ptr_safe());\n    break;\n  case WARNING_LEVEL:\n    sql_print_warning(\"Buffered warning: %s\", m_message.c_ptr_safe());\n    break;\n  case INFORMATION_LEVEL:\n    /*\n      Messages printed as \"information\" still end up in the mysqld *error* log,\n      but with a [Note] tag instead of an [ERROR] tag.\n      While this is probably fine for a human reading the log,\n      it is upsetting existing automated scripts used to parse logs,\n      because such scripts are likely to not already handle [Note] properly.\n      INFORMATION_LEVEL messages are simply silenced, on purpose,\n      to avoid un needed verbosity.\n    */\n    break;\n  }\n}\n\n/**\n  Collection of all the buffered log messages.\n*/\nclass Buffered_logs\n{\npublic:\n  Buffered_logs()\n  {}\n\n  ~Buffered_logs()\n  {}\n\n  void init();\n  void cleanup();\n\n  void buffer(enum loglevel m_level, const char *msg);\n  void print();\nprivate:\n  /**\n    Memory root to use to store buffered logs.\n    This memory root lifespan is between init and cleanup.\n    Once the buffered logs are printed, they are not needed anymore,\n    and all the memory used is reclaimed.\n  */\n  MEM_ROOT m_root;\n  /** List of buffered log messages. */\n  List<Buffered_log> m_list;\n};\n\nvoid Buffered_logs::init()\n{\n  init_alloc_root(&m_root, \"Buffered_logs\", 1024, 0, MYF(0));\n}\n\nvoid Buffered_logs::cleanup()\n{\n  m_list.delete_elements();\n  free_root(&m_root, MYF(0));\n}\n\n/**\n  Add a log message to the buffer.\n*/\nvoid Buffered_logs::buffer(enum loglevel level, const char *msg)\n{\n  /*\n    Do not let Sql_alloc::operator new(size_t) allocate memory,\n    there is no memory root associated with the main() thread.\n    Give explicitly the proper memory root to use to\n    Sql_alloc::operator new(size_t, MEM_ROOT *) instead.\n  */\n  Buffered_log *log= new (&m_root) Buffered_log(level, msg);\n  if (log)\n    m_list.push_back(log, &m_root);\n}\n\n/**\n  Print buffered log messages.\n*/\nvoid Buffered_logs::print()\n{\n  Buffered_log *log;\n  List_iterator_fast<Buffered_log> it(m_list);\n  while ((log= it++))\n    log->print();\n}\n\n/** Logs reported before a logger is available. */\nstatic Buffered_logs buffered_logs;\n\nstruct my_rnd_struct sql_rand; ///< used by sql_class.cc:THD::THD()\n\n#ifndef EMBEDDED_LIBRARY\nMYSQL_SOCKET unix_sock, base_ip_sock, extra_ip_sock;\n/**\n  Error reporter that buffer log messages.\n  @param level          log message level\n  @param format         log message format string\n*/\nC_MODE_START\nstatic void buffered_option_error_reporter(enum loglevel level,\n                                           const char *format, ...)\n{\n  va_list args;\n  char buffer[1024];\n\n  va_start(args, format);\n  my_vsnprintf(buffer, sizeof(buffer), format, args);\n  va_end(args);\n  buffered_logs.buffer(level, buffer);\n}\n\n\n/**\n  Character set and collation error reporter that prints to sql error log.\n  @param level          log message level\n  @param format         log message format string\n\n  This routine is used to print character set and collation\n  warnings and errors inside an already running mysqld server,\n  e.g. when a character set or collation is requested for the very first time\n  and its initialization does not go well for some reasons.\n\n  Note: At early mysqld initialization stage,\n  when error log is not yet available,\n  we use buffered_option_error_reporter() instead,\n  to print general character set subsystem initialization errors,\n  such as Index.xml syntax problems, bad XML tag hierarchy, etc.\n*/\nstatic void charset_error_reporter(enum loglevel level,\n                                   const char *format, ...)\n{\n  va_list args;\n  va_start(args, format);\n  vprint_msg_to_log(level, format, args);\n  va_end(args);                      \n}\nC_MODE_END\n\nstruct passwd *user_info;\nstatic pthread_t select_thread;\n#endif\n\n/* OS specific variables */\n\n#ifdef __WIN__\n#undef\t getpid\n#include <process.h>\n\nstatic bool start_mode=0, use_opt_args;\nstatic int opt_argc;\nstatic char **opt_argv;\n\n#if !defined(EMBEDDED_LIBRARY)\nHANDLE hEventShutdown;\nstatic char shutdown_event_name[40];\n#include \"nt_servc.h\"\nstatic\t NTService  Service;\t      ///< Service object for WinNT\n#endif /* EMBEDDED_LIBRARY */\n#endif /* __WIN__ */\n\n#ifndef EMBEDDED_LIBRARY\nbool mysqld_embedded=0;\n#else\nbool mysqld_embedded=1;\n#endif\n\nmy_bool plugins_are_initialized= FALSE;\n\n#ifndef DBUG_OFF\nstatic const char* default_dbug_option;\n#endif\n#ifdef HAVE_LIBWRAP\nconst char *libwrapName= NULL;\nint allow_severity = LOG_INFO;\nint deny_severity = LOG_WARNING;\n#endif\n#ifdef HAVE_QUERY_CACHE\nulong query_cache_min_res_unit= QUERY_CACHE_MIN_RESULT_DATA_SIZE;\nQuery_cache query_cache;\n#endif\n\n\nmy_bool opt_use_ssl  = 0;\nchar *opt_ssl_ca= NULL, *opt_ssl_capath= NULL, *opt_ssl_cert= NULL,\n  *opt_ssl_cipher= NULL, *opt_ssl_key= NULL, *opt_ssl_crl= NULL,\n  *opt_ssl_crlpath= NULL, *opt_tls_version= NULL;\nulonglong tls_version= 0;\n\nstatic scheduler_functions thread_scheduler_struct, extra_thread_scheduler_struct;\nscheduler_functions *thread_scheduler= &thread_scheduler_struct,\n                    *extra_thread_scheduler= &extra_thread_scheduler_struct;\n\n#ifdef HAVE_OPENSSL\n#include <openssl/crypto.h>\n#if defined(HAVE_OPENSSL10) && !defined(HAVE_WOLFSSL)\ntypedef struct CRYPTO_dynlock_value\n{\n  mysql_rwlock_t lock;\n} openssl_lock_t;\n\nstatic openssl_lock_t *openssl_stdlocks;\nstatic openssl_lock_t *openssl_dynlock_create(const char *, int);\nstatic void openssl_dynlock_destroy(openssl_lock_t *, const char *, int);\nstatic void openssl_lock_function(int, int, const char *, int);\nstatic void openssl_lock(int, openssl_lock_t *, const char *, int);\n#endif /* HAVE_OPENSSL10 */\nchar *des_key_file;\n#ifndef EMBEDDED_LIBRARY\nstruct st_VioSSLFd *ssl_acceptor_fd;\n#endif\n#endif /* HAVE_OPENSSL */\n\n/**\n  Number of currently active user connections. The variable is protected by\n  LOCK_connection_count.\n*/\nuint connection_count= 0, extra_connection_count= 0;\n\nmy_bool opt_gtid_strict_mode= FALSE;\n\n\n/* Function declarations */\n\npthread_handler_t signal_hand(void *arg);\nstatic int mysql_init_variables(void);\nstatic int get_options(int *argc_ptr, char ***argv_ptr);\nstatic bool add_terminator(DYNAMIC_ARRAY *options);\nstatic bool add_many_options(DYNAMIC_ARRAY *, my_option *, size_t);\nextern \"C\" my_bool mysqld_get_one_option(int, const struct my_option *, char *);\nstatic int init_thread_environment();\nstatic char *get_relative_path(const char *path);\nstatic int fix_paths(void);\n#ifndef _WIN32\nvoid handle_connections_sockets();\n#endif\n\nstatic bool read_init_file(char *file_name);\npthread_handler_t handle_slave(void *arg);\nstatic void clean_up(bool print_message);\nstatic int test_if_case_insensitive(const char *dir_name);\n\n#ifndef EMBEDDED_LIBRARY\nstatic bool pid_file_created= false;\nstatic void usage(void);\nstatic void start_signal_handler(void);\nstatic void close_server_sock();\nstatic void clean_up_mutexes(void);\nstatic void wait_for_signal_thread_to_end(void);\nstatic void create_pid_file();\nATTRIBUTE_NORETURN static void mysqld_exit(int exit_code);\n#endif\nstatic void delete_pid_file(myf flags);\nstatic void end_ssl();\n\n\n#ifndef EMBEDDED_LIBRARY\n/****************************************************************************\n** Code to end mysqld\n****************************************************************************/\n\n/* common callee of two shutdown phases */\nstatic void kill_thread(THD *thd)\n{\n  if (WSREP(thd)) mysql_mutex_lock(&thd->LOCK_thd_data);\n  mysql_mutex_lock(&thd->LOCK_thd_kill);\n  if (thd->mysys_var)\n  {\n    thd->mysys_var->abort= 1;\n    mysql_mutex_lock(&thd->mysys_var->mutex);\n    if (thd->mysys_var->current_cond)\n    {\n      for (uint i= 0; i < 2; i++)\n      {\n        int ret= mysql_mutex_trylock(thd->mysys_var->current_mutex);\n        mysql_cond_broadcast(thd->mysys_var->current_cond);\n        if (!ret)\n        {\n          /* Thread has surely got the signal, unlock and abort */\n          mysql_mutex_unlock(thd->mysys_var->current_mutex);\n          break;\n        }\n        sleep(1);\n      }\n    }\n    mysql_mutex_unlock(&thd->mysys_var->mutex);\n  }\n  mysql_mutex_unlock(&thd->LOCK_thd_kill);\n  if (WSREP(thd)) mysql_mutex_unlock(&thd->LOCK_thd_data);\n}\n\n\n/**\n  First shutdown everything but slave threads and binlog dump connections\n*/\nstatic my_bool kill_thread_phase_1(THD *thd, void *)\n{\n  DBUG_PRINT(\"quit\", (\"Informing thread %ld that it's time to die\",\n                      (ulong) thd->thread_id));\n  if (thd->slave_thread || thd->is_binlog_dump_thread())\n    return 0;\n\n  if (DBUG_EVALUATE_IF(\"only_kill_system_threads\", !thd->system_thread, 0))\n    return 0;\n\n  thd->set_killed(KILL_SERVER_HARD);\n  MYSQL_CALLBACK(thread_scheduler, post_kill_notification, (thd));\n  kill_thread(thd);\n  return 0;\n}\n\n\n/**\n  Last shutdown binlog dump connections\n*/\nstatic my_bool kill_thread_phase_2(THD *thd, void *)\n{\n  if (shutdown_wait_for_slaves)\n  {\n    thd->set_killed(KILL_SERVER);\n  }\n  else\n  {\n    thd->set_killed(KILL_SERVER_HARD);\n    MYSQL_CALLBACK(thread_scheduler, post_kill_notification, (thd));\n  }\n  kill_thread(thd);\n  return 0;\n}\n\n\n/* associated with the kill thread phase 1 */\nstatic my_bool warn_threads_active_after_phase_1(THD *thd, void *)\n{\n  if (!thd->is_binlog_dump_thread() && thd->vio_ok())\n    sql_print_warning(\"%s: Thread %llu (user : '%s') did not exit\\n\", my_progname,\n                      (ulonglong) thd->thread_id,\n                      (thd->main_security_ctx.user ?\n                       thd->main_security_ctx.user : \"\"));\n  return 0;\n}\n\n\n/* associated with the kill thread phase 2 */\nstatic my_bool warn_threads_active_after_phase_2(THD *thd, void *)\n{\n  mysql_mutex_lock(&thd->LOCK_thd_data);\n  // dump thread may not have yet (or already) current_linfo set\n  sql_print_warning(\"Dump thread %llu last sent to server %lu \"\n                    \"binlog file:pos %s:%llu\",\n                    thd->thread_id, thd->variables.server_id,\n                    thd->current_linfo ?\n                    my_basename(thd->current_linfo->log_file_name) : \"NULL\",\n                    thd->current_linfo ? thd->current_linfo->pos : 0);\n  mysql_mutex_unlock(&thd->LOCK_thd_data);\n\n  return 0;\n}\n\n\n/**\n  Kills main thread.\n\n  @note this function is responsible for setting abort_loop and breaking\n  poll() in main thread. Shutdown as such is supposed to be performed by main\n  thread itself.\n*/\n\nstatic void break_connect_loop()\n{\n#ifdef EXTRA_DEBUG\n  int count=0;\n#endif\n\n  abort_loop= 1;\n\n#if defined(__WIN__)\n  if (!SetEvent(hEventShutdown))\n    DBUG_PRINT(\"error\", (\"Got error: %ld from SetEvent\", GetLastError()));\n#else\n  /* Avoid waiting for ourselves when thread-handling=no-threads. */\n  if (pthread_equal(pthread_self(), select_thread))\n    return;\n  DBUG_PRINT(\"quit\", (\"waiting for select thread: %lu\",\n                      (ulong)select_thread));\n\n  mysql_mutex_lock(&LOCK_start_thread);\n  while (select_thread_in_use)\n  {\n    struct timespec abstime;\n    int UNINIT_VAR(error);\n    DBUG_PRINT(\"info\",(\"Waiting for select thread\"));\n\n#ifndef DONT_USE_THR_ALARM\n    if (pthread_kill(select_thread, thr_client_alarm))\n      break;\t\t\t\t\t// allready dead\n#endif\n    set_timespec(abstime, 2);\n    for (uint tmp=0 ; tmp < 10 && select_thread_in_use; tmp++)\n    {\n      error= mysql_cond_timedwait(&COND_start_thread, &LOCK_start_thread,\n                                  &abstime);\n      if (error != EINTR)\n        break;\n    }\n#ifdef EXTRA_DEBUG\n    if (error != 0 && error != ETIMEDOUT && !count++)\n      sql_print_error(\"Got error %d from mysql_cond_timedwait\", error);\n#endif\n    close_server_sock();\n  }\n  mysql_mutex_unlock(&LOCK_start_thread);\n#endif /* __WIN__ */\n}\n\n\n/**\n  A wrapper around kill_main_thrad().\n\n  Sets shutdown user. This function may be called by multiple threads\n  concurrently, thus it performs safe update of shutdown_user\n  (first thread wins).\n*/\n\nvoid kill_mysql(THD *thd)\n{\n  char user_host_buff[MAX_USER_HOST_SIZE + 1];\n  char *user, *expected_shutdown_user= 0;\n\n  make_user_name(thd, user_host_buff);\n\n  if ((user= my_strdup(user_host_buff, MYF(0))) &&\n      !shutdown_user.compare_exchange_strong(expected_shutdown_user,\n                                             user,\n                                             std::memory_order_relaxed,\n                                             std::memory_order_relaxed))\n  {\n    my_free(user);\n  }\n\n  DBUG_EXECUTE_IF(\"mysql_admin_shutdown_wait_for_slaves\",\n                  thd->lex->is_shutdown_wait_for_slaves= true;);\n  DBUG_EXECUTE_IF(\"simulate_delay_at_shutdown\",\n                  {\n                    DBUG_ASSERT(binlog_dump_thread_count == 3);\n                    const char act[]=\n                      \"now \"\n                      \"SIGNAL greetings_from_kill_mysql\";\n                    DBUG_ASSERT(!debug_sync_set_action(thd,\n                                                       STRING_WITH_LEN(act)));\n                  };);\n\n  if (thd->lex->is_shutdown_wait_for_slaves)\n    shutdown_wait_for_slaves= true;\n  break_connect_loop();\n}\n\n\nstatic void close_connections(void)\n{\n  DBUG_ENTER(\"close_connections\");\n\n  /* Clear thread cache */\n  kill_cached_threads++;\n  flush_thread_cache();\n\n  /* Abort listening to new connections */\n  DBUG_PRINT(\"quit\",(\"Closing sockets\"));\n  if (!opt_disable_networking )\n  {\n    if (mysql_socket_getfd(base_ip_sock) != INVALID_SOCKET)\n    {\n      (void) mysql_socket_close(base_ip_sock);\n      base_ip_sock= MYSQL_INVALID_SOCKET;\n    }\n    if (mysql_socket_getfd(extra_ip_sock) != INVALID_SOCKET)\n    {\n      (void) mysql_socket_close(extra_ip_sock);\n      extra_ip_sock= MYSQL_INVALID_SOCKET;\n    }\n  }\n\n#ifdef HAVE_SYS_UN_H\n  if (mysql_socket_getfd(unix_sock) != INVALID_SOCKET)\n  {\n    (void) mysql_socket_close(unix_sock);\n    (void) unlink(mysqld_unix_port);\n    unix_sock= MYSQL_INVALID_SOCKET;\n  }\n#endif\n  end_thr_alarm(0);\t\t\t // Abort old alarms.\n\n  /*\n    First signal all threads that it's time to die\n    This will give the threads some time to gracefully abort their\n    statements and inform their clients that the server is about to die.\n  */\n  server_threads.iterate(kill_thread_phase_1);\n\n  Events::deinit();\n  slave_prepare_for_shutdown();\n  mysql_bin_log.stop_background_thread();\n  ack_receiver.stop();\n\n  /*\n    Give threads time to die.\n\n    In 5.5, this was waiting 100 rounds @ 20 milliseconds/round, so as little\n    as 2 seconds, depending on thread scheduling.\n\n    From 10.0, we increase this to 1000 rounds / 20 seconds. The rationale is\n    that on a server with heavy I/O load, it is quite possible for eg. an\n    fsync() of the binlog or whatever to cause something like LOCK_log to be\n    held for more than 2 seconds. We do not want to force kill threads in\n    such cases, if it can be avoided. Note that normally, the wait will be\n    much smaller than even 2 seconds, this is only a safety fallback against\n    stuck threads so server shutdown is not held up forever.\n  */\n  DBUG_PRINT(\"info\", (\"thread_count: %u\", uint32_t(thread_count)));\n\n  for (int i= 0; (thread_count - binlog_dump_thread_count) && i < 1000; i++)\n    my_sleep(20000);\n\n  if (global_system_variables.log_warnings)\n    server_threads.iterate(warn_threads_active_after_phase_1);\n\n#ifdef WITH_WSREP\n  if (wsrep_inited == 1)\n  {\n    wsrep_deinit(true);\n  }\n#endif\n  /* All threads has now been aborted */\n  DBUG_PRINT(\"quit\", (\"Waiting for threads to die (count=%u)\",\n                      uint32_t(thread_count)));\n\n  while (thread_count - binlog_dump_thread_count)\n    my_sleep(1000);\n\n  /* Kill phase 2 */\n  server_threads.iterate(kill_thread_phase_2);\n  for (uint64 i= 0; thread_count; i++)\n  {\n    /*\n      This time the warnings are emitted within the loop to provide a\n      dynamic view on the shutdown status through the errorlog.\n    */\n    if (global_system_variables.log_warnings > 2 && i % 60000 == 0)\n      server_threads.iterate(warn_threads_active_after_phase_2);\n    my_sleep(1000);\n  }\n  /* End of kill phase 2 */\n\n  DBUG_PRINT(\"quit\",(\"close_connections thread\"));\n  DBUG_VOID_RETURN;\n}\n\n\n#ifdef HAVE_CLOSE_SERVER_SOCK\nstatic void close_socket(MYSQL_SOCKET sock, const char *info)\n{\n  DBUG_ENTER(\"close_socket\");\n\n  if (mysql_socket_getfd(sock) != INVALID_SOCKET)\n  {\n    DBUG_PRINT(\"info\", (\"calling shutdown on %s socket\", info));\n    (void) mysql_socket_shutdown(sock, SHUT_RDWR);\n  }\n  DBUG_VOID_RETURN;\n}\n#endif\n\n\nstatic void close_server_sock()\n{\n#ifdef HAVE_CLOSE_SERVER_SOCK\n  DBUG_ENTER(\"close_server_sock\");\n\n  close_socket(base_ip_sock, \"TCP/IP\");\n  close_socket(extra_ip_sock, \"TCP/IP\");\n  close_socket(unix_sock, \"unix/IP\");\n\n  if (mysql_socket_getfd(unix_sock) != INVALID_SOCKET)\n    (void) unlink(mysqld_unix_port);\n  base_ip_sock= extra_ip_sock= unix_sock= MYSQL_INVALID_SOCKET;\n\n  DBUG_VOID_RETURN;\n#endif\n}\n\n#endif /*EMBEDDED_LIBRARY*/\n\n\nextern \"C\" sig_handler print_signal_warning(int sig)\n{\n  if (global_system_variables.log_warnings)\n    sql_print_warning(\"Got signal %d from thread %u\", sig,\n                      (uint)my_thread_id());\n#ifdef SIGNAL_HANDLER_RESET_ON_DELIVERY\n  my_sigset(sig,print_signal_warning);\t\t/* int. thread system calls */\n#endif\n#if !defined(__WIN__)\n  if (sig == SIGALRM)\n    alarm(2);\t\t\t\t\t/* reschedule alarm */\n#endif\n}\n\n#ifndef EMBEDDED_LIBRARY\nextern \"C\" void unireg_abort(int exit_code)\n{\n  DBUG_ENTER(\"unireg_abort\");\n\n  if (opt_help)\n    usage();\n  if (exit_code)\n    sql_print_error(\"Aborting\");\n  /* Don't write more notes to the log to not hide error message */\n  disable_log_notes= 1;\n\n#ifdef WITH_WSREP\n  if (WSREP_ON &&\n      Wsrep_server_state::is_inited() &&\n      Wsrep_server_state::instance().state() != wsrep::server_state::s_disconnected)\n  {\n    /*\n      This is an abort situation, we cannot expect to gracefully close all\n      wsrep threads here, we can only diconnect from service\n    */\n    wsrep_close_client_connections(FALSE);\n    Wsrep_server_state::instance().disconnect();\n    WSREP_INFO(\"Service disconnected.\");\n    wsrep_close_threads(NULL); /* this won't close all threads */\n    sleep(1); /* so give some time to exit for those which can */\n    WSREP_INFO(\"Some threads may fail to exit.\");\n  }\n  if (WSREP_ON)\n  {\n    /* In bootstrap mode we deinitialize wsrep here. */\n    if (opt_bootstrap || wsrep_recovery)\n    {\n      if (wsrep_inited) wsrep_deinit(true);\n    }\n  }\n#endif // WITH_WSREP\n\n  clean_up(!opt_abort && (exit_code || !opt_bootstrap)); /* purecov: inspected */\n  DBUG_PRINT(\"quit\",(\"done with cleanup in unireg_abort\"));\n  mysqld_exit(exit_code);\n}\n\n\nstatic void cleanup_tls()\n{\n  if (THR_THD)\n    (void)pthread_key_delete(THR_THD);\n}\n\n\nstatic void mysqld_exit(int exit_code)\n{\n  DBUG_ENTER(\"mysqld_exit\");\n  /*\n    Important note: we wait for the signal thread to end,\n    but if a kill -15 signal was sent, the signal thread did\n    spawn the kill_server_thread thread, which is running concurrently.\n  */\n  rpl_deinit_gtid_waiting();\n  rpl_deinit_gtid_slave_state();\n  wait_for_signal_thread_to_end();\n#ifdef WITH_WSREP\n  wsrep_deinit_server();\n#endif /* WITH_WSREP */\n  mysql_audit_finalize();\n  clean_up_mutexes();\n  my_end((opt_endinfo ? MY_CHECK_ERROR | MY_GIVE_INFO : 0));\n#ifdef WITH_PERFSCHEMA_STORAGE_ENGINE\n  shutdown_performance_schema();        // we do it as late as possible\n#endif\n  set_malloc_size_cb(NULL);\n  if (opt_endinfo && global_status_var.global_memory_used)\n    fprintf(stderr, \"Warning: Memory not freed: %ld\\n\",\n            (long) global_status_var.global_memory_used);\n  if (!opt_debugging && !my_disable_leak_check && exit_code == 0 &&\n      debug_assert_on_not_freed_memory)\n  {\n#ifdef SAFEMALLOC\n    sf_report_leaked_memory(0);\n#endif\n    DBUG_SLOW_ASSERT(global_status_var.global_memory_used == 0);\n  }\n  cleanup_tls();\n  DBUG_LEAVE;\n  sd_notify(0, \"STATUS=MariaDB server is down\");\n  exit(exit_code); /* purecov: inspected */\n}\n\n#endif /* !EMBEDDED_LIBRARY */\n\nstatic void clean_up(bool print_message)\n{\n  DBUG_PRINT(\"exit\",(\"clean_up\"));\n  if (cleanup_done++)\n    return; /* purecov: inspected */\n\n#ifdef HAVE_REPLICATION\n  // We must call end_slave() as clean_up may have been called during startup\n  end_slave();\n  if (use_slave_mask)\n    my_bitmap_free(&slave_error_mask);\n#endif\n  stop_handle_manager();\n  release_ddl_log();\n\n  logger.cleanup_base();\n\n  injector::free_instance();\n  mysql_bin_log.cleanup();\n\n  my_tz_free();\n  my_dboptions_cache_free();\n  ignore_db_dirs_free();\n  servers_free(1);\n#ifndef NO_EMBEDDED_ACCESS_CHECKS\n  acl_free(1);\n  grant_free();\n#endif\n  query_cache_destroy();\n  hostname_cache_free();\n  item_func_sleep_free();\n  lex_free();\t\t\t\t/* Free some memory */\n  item_create_cleanup();\n  tdc_start_shutdown();\n#ifdef HAVE_REPLICATION\n  semi_sync_master_deinit();\n#endif\n  plugin_shutdown();\n  udf_free();\n  ha_end();\n  if (tc_log)\n    tc_log->close();\n  xid_cache_free();\n  tdc_deinit();\n  mdl_destroy();\n  dflt_key_cache= 0;\n  key_caches.delete_elements(free_key_cache);\n  wt_end();\n  multi_keycache_free();\n  sp_cache_end();\n  free_status_vars();\n  end_thr_alarm(1);\t\t\t/* Free allocated memory */\n#ifndef EMBEDDED_LIBRARY\n  end_thr_timer();\n#endif\n  my_free_open_file_info();\n  if (defaults_argv)\n    free_defaults(defaults_argv);\n  free_tmpdir(&mysql_tmpdir_list);\n  my_bitmap_free(&temp_pool);\n  free_max_user_conn();\n  free_global_user_stats();\n  free_global_client_stats();\n  free_global_table_stats();\n  free_global_index_stats();\n  delete_dynamic(&all_options);                 // This should be empty\n  free_all_rpl_filters();\n  wsrep_thr_deinit();\n  my_uuid_end();\n  delete type_handler_data;\n  delete binlog_filter;\n  delete global_rpl_filter;\n  end_ssl();\n#ifndef EMBEDDED_LIBRARY\n  vio_end();\n#endif /*!EMBEDDED_LIBRARY*/\n#if defined(ENABLED_DEBUG_SYNC)\n  /* End the debug sync facility. See debug_sync.cc. */\n  debug_sync_end();\n#endif /* defined(ENABLED_DEBUG_SYNC) */\n\n  delete_pid_file(MYF(0));\n\n  if (print_message && my_default_lc_messages && server_start_time)\n    sql_print_information(ER_DEFAULT(ER_SHUTDOWN_COMPLETE),my_progname);\n  MYSQL_CALLBACK(thread_scheduler, end, ());\n  thread_scheduler= 0;\n  mysql_library_end();\n  finish_client_errs();\n  cleanup_errmsgs();\n  free_error_messages();\n  /* Tell main we are ready */\n  logger.cleanup_end();\n  sys_var_end();\n  free_charsets();\n\n  my_free(const_cast<char*>(log_bin_basename));\n  my_free(const_cast<char*>(log_bin_index));\n#ifndef EMBEDDED_LIBRARY\n  my_free(const_cast<char*>(relay_log_basename));\n  my_free(const_cast<char*>(relay_log_index));\n#endif\n  free_list(opt_plugin_load_list_ptr);\n  destroy_proxy_protocol_networks();\n\n  /*\n    The following lines may never be executed as the main thread may have\n    killed us\n  */\n  DBUG_PRINT(\"quit\", (\"done with cleanup\"));\n} /* clean_up */\n\n\n#ifndef EMBEDDED_LIBRARY\n\n/**\n  This is mainly needed when running with purify, but it's still nice to\n  know that all child threads have died when mysqld exits.\n*/\nstatic void wait_for_signal_thread_to_end()\n{\n  uint i;\n  /*\n    Wait up to 10 seconds for signal thread to die. We use this mainly to\n    avoid getting warnings that my_thread_end has not been called\n  */\n  for (i= 0 ; i < 100 && signal_thread_in_use; i++)\n  {\n    if (pthread_kill(signal_thread, MYSQL_KILL_SIGNAL) == ESRCH)\n      break;\n    my_sleep(100);\t\t\t\t// Give it time to die\n  }\n}\n#endif /*EMBEDDED_LIBRARY*/\n\nstatic void clean_up_mutexes()\n{\n  DBUG_ENTER(\"clean_up_mutexes\");\n  server_threads.destroy();\n  mysql_rwlock_destroy(&LOCK_grant);\n  mysql_mutex_destroy(&LOCK_thread_cache);\n  mysql_mutex_destroy(&LOCK_start_thread);\n  mysql_mutex_destroy(&LOCK_status);\n  mysql_rwlock_destroy(&LOCK_all_status_vars);\n  mysql_mutex_destroy(&LOCK_delayed_insert);\n  mysql_mutex_destroy(&LOCK_delayed_status);\n  mysql_mutex_destroy(&LOCK_delayed_create);\n  mysql_mutex_destroy(&LOCK_crypt);\n  mysql_mutex_destroy(&LOCK_user_conn);\n  mysql_mutex_destroy(&LOCK_connection_count);\n  mysql_mutex_destroy(&LOCK_thread_id);\n  mysql_mutex_destroy(&LOCK_stats);\n  mysql_mutex_destroy(&LOCK_global_user_client_stats);\n  mysql_mutex_destroy(&LOCK_global_table_stats);\n  mysql_mutex_destroy(&LOCK_global_index_stats);\n#ifdef HAVE_OPENSSL\n  mysql_mutex_destroy(&LOCK_des_key_file);\n#if defined(HAVE_OPENSSL10) && !defined(HAVE_WOLFSSL)\n  for (int i= 0; i < CRYPTO_num_locks(); ++i)\n    mysql_rwlock_destroy(&openssl_stdlocks[i].lock);\n  OPENSSL_free(openssl_stdlocks);\n#endif /* HAVE_OPENSSL10 */\n#endif /* HAVE_OPENSSL */\n#ifdef HAVE_REPLICATION\n  mysql_mutex_destroy(&LOCK_rpl_status);\n#endif /* HAVE_REPLICATION */\n  mysql_mutex_destroy(&LOCK_active_mi);\n  mysql_rwlock_destroy(&LOCK_ssl_refresh);\n  mysql_rwlock_destroy(&LOCK_sys_init_connect);\n  mysql_rwlock_destroy(&LOCK_sys_init_slave);\n  mysql_mutex_destroy(&LOCK_global_system_variables);\n  mysql_prlock_destroy(&LOCK_system_variables_hash);\n  mysql_mutex_destroy(&LOCK_short_uuid_generator);\n  mysql_mutex_destroy(&LOCK_prepared_stmt_count);\n  mysql_mutex_destroy(&LOCK_error_messages);\n  mysql_cond_destroy(&COND_thread_cache);\n  mysql_cond_destroy(&COND_start_thread);\n  mysql_cond_destroy(&COND_flush_thread_cache);\n  mysql_mutex_destroy(&LOCK_server_started);\n  mysql_cond_destroy(&COND_server_started);\n  mysql_mutex_destroy(&LOCK_prepare_ordered);\n  mysql_cond_destroy(&COND_prepare_ordered);\n  mysql_mutex_destroy(&LOCK_after_binlog_sync);\n  mysql_mutex_destroy(&LOCK_commit_ordered);\n  mysql_mutex_destroy(&LOCK_slave_background);\n  mysql_cond_destroy(&COND_slave_background);\n#ifndef EMBEDDED_LIBRARY\n  mysql_mutex_destroy(&LOCK_error_log);\n#endif\n  DBUG_VOID_RETURN;\n}\n\n\n/****************************************************************************\n** Init IP and UNIX socket\n****************************************************************************/\n\n#ifdef EMBEDDED_LIBRARY\nvoid close_connection(THD *thd, uint sql_errno)\n{\n}\n#else\nstatic void set_ports()\n{\n  char\t*env;\n  if (!mysqld_port && !opt_disable_networking)\n  {\t\t\t\t\t// Get port if not from commandline\n    mysqld_port= MYSQL_PORT;\n\n    /*\n      if builder specifically requested a default port, use that\n      (even if it coincides with our factory default).\n      only if they didn't do we check /etc/services (and, failing\n      on that, fall back to the factory default of 3306).\n      either default can be overridden by the environment variable\n      MYSQL_TCP_PORT, which in turn can be overridden with command\n      line options.\n    */\n\n#if MYSQL_PORT_DEFAULT == 0\n    struct  servent *serv_ptr;\n    if ((serv_ptr= getservbyname(\"mysql\", \"tcp\")))\n      SYSVAR_AUTOSIZE(mysqld_port, ntohs((u_short) serv_ptr->s_port));\n#endif\n    if ((env = getenv(\"MYSQL_TCP_PORT\")))\n    {\n      mysqld_port= (uint) atoi(env);\n      set_sys_var_value_origin(&mysqld_port, sys_var::ENV);\n    }\n  }\n  if (!mysqld_unix_port)\n  {\n#ifdef __WIN__\n    mysqld_unix_port= (char*) MYSQL_NAMEDPIPE;\n#else\n    mysqld_unix_port= (char*) MYSQL_UNIX_ADDR;\n#endif\n    if ((env = getenv(\"MYSQL_UNIX_PORT\")))\n    {\n      mysqld_unix_port= env;\n      set_sys_var_value_origin(&mysqld_unix_port, sys_var::ENV);\n    }\n  }\n}\n\n/* Change to run as another user if started with --user */\n\nstatic struct passwd *check_user(const char *user)\n{\n  myf flags= 0;\n  if (global_system_variables.log_warnings)\n    flags|= MY_WME;\n  if (!opt_bootstrap && !opt_help)\n    flags|= MY_FAE;\n\n  struct passwd *tmp_user_info= my_check_user(user, MYF(flags));\n\n  if (!tmp_user_info && my_errno==EINVAL && (flags & MY_FAE))\n    unireg_abort(1);\n\n  return tmp_user_info;\n}\n\nstatic inline void allow_coredumps()\n{\n#ifdef PR_SET_DUMPABLE\n  if (test_flags & TEST_CORE_ON_SIGNAL)\n  {\n    /* inform kernel that process is dumpable */\n    (void) prctl(PR_SET_DUMPABLE, 1);\n  }\n#endif\n}\n\n\nstatic void set_user(const char *user, struct passwd *user_info_arg)\n{\n  /*\n    We can get a SIGSEGV when calling initgroups() on some systems when NSS\n    is configured to use LDAP and the server is statically linked.  We set\n    calling_initgroups as a flag to the SIGSEGV handler that is then used to\n    output a specific message to help the user resolve this problem.\n  */\n  calling_initgroups= 1;\n  int res= my_set_user(user, user_info_arg, MYF(MY_WME));\n  calling_initgroups= 0;\n  if (res)\n    unireg_abort(1);\n  allow_coredumps();\n}\n\n#if !defined(__WIN__)\nstatic void set_effective_user(struct passwd *user_info_arg)\n{\n  DBUG_ASSERT(user_info_arg != 0);\n  if (setregid((gid_t)-1, user_info_arg->pw_gid) == -1)\n  {\n    sql_perror(\"setregid\");\n    unireg_abort(1);\n  }\n  if (setreuid((uid_t)-1, user_info_arg->pw_uid) == -1)\n  {\n    sql_perror(\"setreuid\");\n    unireg_abort(1);\n  }\n  allow_coredumps();\n}\n#endif\n\n/** Change root user if started with @c --chroot . */\nstatic void set_root(const char *path)\n{\n#if !defined(__WIN__)\n  if (chroot(path) == -1)\n  {\n    sql_perror(\"chroot\");\n    unireg_abort(1);\n  }\n  my_setwd(\"/\", MYF(0));\n#endif\n}\n\n/**\n   Activate usage of a tcp port\n*/\n\nstatic MYSQL_SOCKET activate_tcp_port(uint port)\n{\n  struct addrinfo *ai, *a;\n  struct addrinfo hints;\n  int error;\n  int\targ;\n  char port_buf[NI_MAXSERV];\n  const char *real_bind_addr_str;\n  MYSQL_SOCKET ip_sock= MYSQL_INVALID_SOCKET;\n  DBUG_ENTER(\"activate_tcp_port\");\n  DBUG_PRINT(\"general\",(\"IP Socket is %d\",port));\n\n  bzero(&hints, sizeof (hints));\n  hints.ai_flags= AI_PASSIVE;\n  hints.ai_socktype= SOCK_STREAM;\n  hints.ai_family= AF_UNSPEC;\n  \n  if (my_bind_addr_str && strcmp(my_bind_addr_str, \"*\") == 0)\n    real_bind_addr_str= NULL; // windows doesn't seem to support * here\n  else\n    real_bind_addr_str= my_bind_addr_str;\n\n  my_snprintf(port_buf, NI_MAXSERV, \"%d\", port);\n  error= getaddrinfo(real_bind_addr_str, port_buf, &hints, &ai);\n  if (unlikely(error != 0))\n  {\n    DBUG_PRINT(\"error\",(\"Got error: %d from getaddrinfo()\", error));\n\n    sql_print_error(\"%s: %s\", ER_DEFAULT(ER_IPSOCK_ERROR), gai_strerror(error));\n    unireg_abort(1);\t\t\t\t/* purecov: tested */\n  }\n\n  /*\n    special case: for wildcard addresses prefer ipv6 over ipv4,\n    because we later switch off IPV6_V6ONLY, so ipv6 wildcard\n    addresses will work for ipv4 too\n  */\n  if (!real_bind_addr_str && ai->ai_family == AF_INET && ai->ai_next\n      && ai->ai_next->ai_family == AF_INET6)\n  {\n    a= ai;\n    ai= ai->ai_next;\n    a->ai_next= ai->ai_next;\n    ai->ai_next= a;\n  }\n\n  for (a= ai; a != NULL; a= a->ai_next)\n  {\n    ip_sock= mysql_socket_socket(key_socket_tcpip, a->ai_family,\n                                 a->ai_socktype, a->ai_protocol);\n\n    char ip_addr[INET6_ADDRSTRLEN];\n    if (vio_get_normalized_ip_string(a->ai_addr, a->ai_addrlen,\n                                     ip_addr, sizeof (ip_addr)))\n    {\n      ip_addr[0]= 0;\n    }\n\n    if (mysql_socket_getfd(ip_sock) == INVALID_SOCKET)\n    {\n      sql_print_message_func func= real_bind_addr_str ? sql_print_error\n                                                      : sql_print_warning;\n      func(\"Failed to create a socket for %s '%s': errno: %d.\",\n           (a->ai_family == AF_INET) ? \"IPv4\" : \"IPv6\",\n           (const char *) ip_addr, (int) socket_errno);\n    }\n    else \n    {\n      server_socket_ai_family= a->ai_family;\n      sql_print_information(\"Server socket created on IP: '%s'.\",\n                          (const char *) ip_addr);\n      break;\n    }\n  }\n\n  if (mysql_socket_getfd(ip_sock) == INVALID_SOCKET)\n  {\n    DBUG_PRINT(\"error\",(\"Got error: %d from socket()\",socket_errno));\n    sql_perror(ER_DEFAULT(ER_IPSOCK_ERROR));  /* purecov: tested */\n    unireg_abort(1);\t\t\t\t/* purecov: tested */\n  }\n\n  mysql_socket_set_thread_owner(ip_sock);\n\n#ifndef __WIN__\n  /*\n    We should not use SO_REUSEADDR on windows as this would enable a\n    user to open two mysqld servers with the same TCP/IP port.\n  */\n  arg= 1;\n  (void) mysql_socket_setsockopt(ip_sock,SOL_SOCKET,SO_REUSEADDR,(char*)&arg,\n                                 sizeof(arg));\n#endif /* __WIN__ */\n\n#ifdef IPV6_V6ONLY\n   /*\n     For interoperability with older clients, IPv6 socket should\n     listen on both IPv6 and IPv4 wildcard addresses.\n     Turn off IPV6_V6ONLY option.\n\n     NOTE: this will work starting from Windows Vista only.\n     On Windows XP dual stack is not available, so it will not\n     listen on the corresponding IPv4-address.\n   */\n  if (a->ai_family == AF_INET6)\n  {\n    arg= 0;\n    (void) mysql_socket_setsockopt(ip_sock, IPPROTO_IPV6, IPV6_V6ONLY,\n                                   (char*)&arg, sizeof(arg));\n  }\n#endif\n\n#ifdef IP_FREEBIND\n  arg= 1;\n  (void) mysql_socket_setsockopt(ip_sock, IPPROTO_IP, IP_FREEBIND, (char*) &arg,\n                                 sizeof(arg));\n#endif\n  /*\n    Sometimes the port is not released fast enough when stopping and\n    restarting the server. This happens quite often with the test suite\n    on busy Linux systems. Retry to bind the address at these intervals:\n    Sleep intervals: 1, 2, 4,  6,  9, 13, 17, 22, ...\n    Retry at second: 1, 3, 7, 13, 22, 35, 52, 74, ...\n    Limit the sequence by mysqld_port_timeout (set --port-open-timeout=#).\n  */\n  int ret;\n  uint waited, retry, this_wait;\n  for (waited= 0, retry= 1; ; retry++, waited+= this_wait)\n  {\n    if (((ret= mysql_socket_bind(ip_sock, a->ai_addr, a->ai_addrlen)) >= 0 ) ||\n        (socket_errno != SOCKET_EADDRINUSE) ||\n        (waited >= mysqld_port_timeout))\n      break;\n    sql_print_information(\"Retrying bind on TCP/IP port %u\", port);\n    this_wait= retry * retry / 3 + 1;\n    sleep(this_wait);\n  }\n  freeaddrinfo(ai);\n  if (ret < 0)\n  {\n    char buff[100];\n    sprintf(buff, \"Can't start server: Bind on TCP/IP port. Got error: %d\",\n            (int) socket_errno);\n    sql_perror(buff);\n    sql_print_error(\"Do you already have another mysqld server running on \"\n                    \"port: %u ?\", port);\n    unireg_abort(1);\n  }\n  if (mysql_socket_listen(ip_sock,(int) back_log) < 0)\n  {\n    sql_perror(\"Can't start server: listen() on TCP/IP port\");\n    sql_print_error(\"listen() on TCP/IP failed with error %d\",\n                    socket_errno);\n    unireg_abort(1);\n  }\n\n#ifdef FD_CLOEXEC\n  (void) fcntl(mysql_socket_getfd(ip_sock), F_SETFD, FD_CLOEXEC);\n#endif\n\n  DBUG_RETURN(ip_sock);\n}\n\nstatic void network_init(void)\n{\n#ifdef HAVE_SYS_UN_H\n  struct sockaddr_un\tUNIXaddr;\n  int\targ;\n#endif\n  DBUG_ENTER(\"network_init\");\n\n  if (MYSQL_CALLBACK_ELSE(thread_scheduler, init, (), 0))\n    unireg_abort(1);\t\t\t/* purecov: inspected */\n\n  if (init_proxy_protocol_networks(my_proxy_protocol_networks))\n    unireg_abort(1);\n\n  set_ports();\n\n  if (report_port == 0)\n  {\n    SYSVAR_AUTOSIZE(report_port, mysqld_port);\n  }\n#ifndef DBUG_OFF\n  if (!opt_disable_networking)\n    DBUG_ASSERT(report_port != 0);\n#endif\n  if (!opt_disable_networking && !opt_bootstrap)\n  {\n    if (mysqld_port)\n      base_ip_sock= activate_tcp_port(mysqld_port);\n    if (mysqld_extra_port)\n      extra_ip_sock= activate_tcp_port(mysqld_extra_port);\n  }\n\n#if defined(HAVE_SYS_UN_H)\n  /*\n  ** Create the UNIX socket\n  */\n  if (mysqld_unix_port[0] && !opt_bootstrap)\n  {\n    size_t port_len;\n    DBUG_PRINT(\"general\",(\"UNIX Socket is %s\",mysqld_unix_port));\n\n    if ((port_len= strlen(mysqld_unix_port)) > sizeof(UNIXaddr.sun_path) - 1)\n    {\n      sql_print_error(\"The socket file path is too long (> %u): %s\",\n                      (uint) sizeof(UNIXaddr.sun_path) - 1, mysqld_unix_port);\n      unireg_abort(1);\n    }\n    unix_sock= mysql_socket_socket(key_socket_unix, AF_UNIX, SOCK_STREAM, 0);\n    if (mysql_socket_getfd(unix_sock) < 0)\n    {\n      sql_perror(\"Can't start server : UNIX Socket \"); /* purecov: inspected */\n      unireg_abort(1);\t\t\t\t/* purecov: inspected */\n    }\n\n    mysql_socket_set_thread_owner(unix_sock);\n\n    bzero((char*) &UNIXaddr, sizeof(UNIXaddr));\n    UNIXaddr.sun_family = AF_UNIX;\n    strmov(UNIXaddr.sun_path, mysqld_unix_port);\n#if defined(__linux__)\n    /* Abstract socket */\n    if (mysqld_unix_port[0] == '@')\n    {\n      UNIXaddr.sun_path[0]= '\\0';\n      port_len+= offsetof(struct sockaddr_un, sun_path);\n    }\n    else\n#endif\n    {\n      (void) unlink(mysqld_unix_port);\n      port_len= sizeof(UNIXaddr);\n    }\n    arg= 1;\n    (void) mysql_socket_setsockopt(unix_sock,SOL_SOCKET,SO_REUSEADDR,\n                                   (char*)&arg, sizeof(arg));\n    umask(0);\n    if (mysql_socket_bind(unix_sock,\n                          reinterpret_cast<struct sockaddr *>(&UNIXaddr),\n                          port_len) < 0)\n    {\n      sql_perror(\"Can't start server : Bind on unix socket\"); /* purecov: tested */\n      sql_print_error(\"Do you already have another mysqld server running on socket: %s ?\",mysqld_unix_port);\n      unireg_abort(1);\t\t\t\t\t/* purecov: tested */\n    }\n    umask(((~my_umask) & 0666));\n#if defined(S_IFSOCK) && defined(SECURE_SOCKETS)\n    (void) chmod(mysqld_unix_port,S_IFSOCK);\t/* Fix solaris 2.6 bug */\n#endif\n    if (mysql_socket_listen(unix_sock,(int) back_log) < 0)\n      sql_print_warning(\"listen() on Unix socket failed with error %d\",\n\t\t      socket_errno);\n#ifdef FD_CLOEXEC\n    (void) fcntl(mysql_socket_getfd(unix_sock), F_SETFD, FD_CLOEXEC);\n#endif\n  }\n#endif\n  DBUG_PRINT(\"info\",(\"server started\"));\n  DBUG_VOID_RETURN;\n}\n\n\n/**\n  Close a connection.\n\n  @param thd        Thread handle.\n  @param sql_errno  The error code to send before disconnect.\n\n  @note\n    For the connection that is doing shutdown, this is called twice\n*/\n\nvoid close_connection(THD *thd, uint sql_errno)\n{\n  int lvl= (thd->main_security_ctx.user ? 3 : 1);\n  DBUG_ENTER(\"close_connection\");\n\n  if (sql_errno)\n  {\n    net_send_error(thd, sql_errno, ER_DEFAULT(sql_errno), NULL);\n    thd->print_aborted_warning(lvl, ER_DEFAULT(sql_errno));\n  }\n  else\n    thd->print_aborted_warning(lvl, (thd->main_security_ctx.user ?\n                                     \"This connection closed normally\" :\n                                     \"This connection closed normally without\"\n                                      \" authentication\"));\n\n  thd->disconnect();\n\n  MYSQL_CONNECTION_DONE((int) sql_errno, thd->thread_id);\n\n  if (MYSQL_CONNECTION_DONE_ENABLED())\n  {\n    sleep(0); /* Workaround to avoid tailcall optimisation */\n  }\n  mysql_audit_notify_connection_disconnect(thd, sql_errno);\n  DBUG_VOID_RETURN;\n}\n\n\n/** Called when mysqld is aborted with ^C */\n/* ARGSUSED */\nextern \"C\" sig_handler end_mysqld_signal(int sig __attribute__((unused)))\n{\n  DBUG_ENTER(\"end_mysqld_signal\");\n  /* Don't kill if signal thread is not running */\n  if (signal_thread_in_use)\n    break_connect_loop();                         // Take down mysqld nicely\n  DBUG_VOID_RETURN;\t\t\t\t/* purecov: deadcode */\n}\n#endif /* EMBEDDED_LIBRARY */\n\n/*\n  Decrease number of connections\n\n  SYNOPSIS\n    dec_connection_count()\n*/\n\nvoid dec_connection_count(scheduler_functions *scheduler)\n{\n  mysql_mutex_lock(&LOCK_connection_count);\n  (*scheduler->connection_count)--;\n  mysql_mutex_unlock(&LOCK_connection_count);\n}\n\n\n/*\n  Unlink thd from global list of available connections\n\n  SYNOPSIS\n    unlink_thd()\n    thd\t\t Thread handler\n*/\n\nvoid unlink_thd(THD *thd)\n{\n  DBUG_ENTER(\"unlink_thd\");\n  DBUG_PRINT(\"enter\", (\"thd: %p\", thd));\n\n  thd->cleanup();\n  thd->add_status_to_global();\n  server_threads.erase(thd);\n\n#ifdef WITH_WSREP\n  /*\n    Do not decrement when its wsrep system thread. wsrep_applier is set for\n    applier as well as rollbacker threads.\n  */\n  if (!thd->wsrep_applier)\n#endif /* WITH_WSREP */\n  dec_connection_count(thd->scheduler);\n\n  thd->free_connection();\n\n  DBUG_VOID_RETURN;\n}\n\n\n/*\n  Store thread in cache for reuse by new connections\n\n  SYNOPSIS\n    cache_thread()\n    thd\t\t Thread handler\n\n  NOTES\n    LOCK_thread_cache is used to protect the cache variables\n\n  RETURN\n    0  Thread was not put in cache\n    1  Thread is to be reused by new connection.\n       (ie, caller should return, not abort with pthread_exit())\n*/\n\n\nstatic bool cache_thread(THD *thd)\n{\n  struct timespec abstime;\n  DBUG_ENTER(\"cache_thread\");\n  DBUG_ASSERT(thd);\n\n  mysql_mutex_lock(&LOCK_thread_cache);\n  if (cached_thread_count < thread_cache_size &&\n      ! abort_loop && !kill_cached_threads)\n  {\n    /* Don't kill the thread, just put it in cache for reuse */\n    DBUG_PRINT(\"info\", (\"Adding thread to cache\"));\n    cached_thread_count++;\n\n    /*\n      Delete the instrumentation for the job that just completed,\n      before parking this pthread in the cache (blocked on COND_thread_cache).\n    */\n    PSI_CALL_delete_current_thread();\n\n#ifndef DBUG_OFF\n    while (_db_is_pushed_())\n      _db_pop_();\n#endif\n\n    set_timespec(abstime, THREAD_CACHE_TIMEOUT);\n    while (!abort_loop && ! wake_thread && ! kill_cached_threads)\n    {\n      int error= mysql_cond_timedwait(&COND_thread_cache, &LOCK_thread_cache,\n                                       &abstime);\n      if (error == ETIMEDOUT || error == ETIME)\n      {\n        /*\n          If timeout, end thread.\n          If a new thread is requested (wake_thread is set), we will handle\n          the call, even if we got a timeout (as we are already awake and free)\n        */\n        break;\n      }\n    }\n    cached_thread_count--;\n    if (kill_cached_threads)\n      mysql_cond_signal(&COND_flush_thread_cache);\n    if (wake_thread)\n    {\n      CONNECT *connect;\n\n      wake_thread--;\n      connect= thread_cache.get();\n      mysql_mutex_unlock(&LOCK_thread_cache);\n\n      if (!(connect->create_thd(thd)))\n      {\n        /* Out of resources. Free thread to get more resources */\n        connect->close_and_delete();\n        DBUG_RETURN(0);\n      }\n      delete connect;\n\n      /*\n        We have to call store_globals to update mysys_var->id and lock_info\n        with the new thread_id\n      */\n      thd->store_globals();\n\n      /*\n        Create new instrumentation for the new THD job,\n        and attach it to this running pthread.\n      */\n      PSI_CALL_set_thread(PSI_CALL_new_thread(key_thread_one_connection,\n                                              thd, thd->thread_id));\n\n      /* reset abort flag for the thread */\n      thd->mysys_var->abort= 0;\n      thd->thr_create_utime= microsecond_interval_timer();\n      thd->start_utime= thd->thr_create_utime;\n\n      server_threads.insert(thd);\n      DBUG_RETURN(1);\n    }\n  }\n  mysql_mutex_unlock(&LOCK_thread_cache);\n  DBUG_RETURN(0);\n}\n\n\n/*\n  End thread for the current connection\n\n  SYNOPSIS\n    one_thread_per_connection_end()\n    thd\t\t  Thread handler. This may be null if we run out of resources.\n    put_in_cache  Store thread in cache, if there is room in it\n                  Normally this is true in all cases except when we got\n                  out of resources initializing the current thread\n\n  NOTES\n    If thread is cached, we will wait until thread is scheduled to be\n    reused and then we will return.\n    If thread is not cached, we end the thread.\n\n  RETURN\n    0    Signal to handle_one_connection to reuse connection\n*/\n\nbool one_thread_per_connection_end(THD *thd, bool put_in_cache)\n{\n  DBUG_ENTER(\"one_thread_per_connection_end\");\n\n  if (thd)\n  {\n    const bool wsrep_applier= IF_WSREP(thd->wsrep_applier, false);\n\n    unlink_thd(thd);\n    if (!wsrep_applier && put_in_cache && cache_thread(thd))\n      DBUG_RETURN(0);                             // Thread is reused\n    delete thd;\n  }\n\n  DBUG_PRINT(\"info\", (\"killing thread\"));\n  DBUG_LEAVE;                                   // Must match DBUG_ENTER()\n#if defined(HAVE_OPENSSL) && !defined(EMBEDDED_LIBRARY)\n  ERR_remove_state(0);\n#endif\n  my_thread_end();\n\n  pthread_exit(0);\n  return 0;                                     // Avoid compiler warnings\n}\n\n\nvoid flush_thread_cache()\n{\n  DBUG_ENTER(\"flush_thread_cache\");\n  mysql_mutex_lock(&LOCK_thread_cache);\n  kill_cached_threads++;\n  while (cached_thread_count)\n  {\n    mysql_cond_broadcast(&COND_thread_cache);\n    mysql_cond_wait(&COND_flush_thread_cache, &LOCK_thread_cache);\n  }\n  kill_cached_threads--;\n  mysql_mutex_unlock(&LOCK_thread_cache);\n  DBUG_VOID_RETURN;\n}\n\n\n/******************************************************************************\n  Setup a signal thread with handles all signals.\n  Because Linux doesn't support schemas use a mutex to check that\n  the signal thread is ready before continuing\n******************************************************************************/\n\n#if defined(__WIN__)\n\n\n/*\n  On Windows, we use native SetConsoleCtrlHandler for handle events like Ctrl-C\n  with graceful shutdown.\n  Also, we do not use signal(), but SetUnhandledExceptionFilter instead - as it\n  provides possibility to pass the exception to just-in-time debugger, collect\n  dumps and potentially also the exception and thread context used to output\n  callstack.\n*/\n\nstatic BOOL WINAPI console_event_handler( DWORD type ) \n{\n  DBUG_ENTER(\"console_event_handler\");\n#ifndef EMBEDDED_LIBRARY\n  if(type == CTRL_C_EVENT)\n  {\n     /*\n       Do not shutdown before startup is finished and shutdown\n       thread is initialized. Otherwise there is a race condition \n       between main thread doing initialization and CTRL-C thread doing\n       cleanup, which can result into crash.\n     */\n#ifndef EMBEDDED_LIBRARY\n     if(hEventShutdown)\n       break_connect_loop();\n     else\n#endif\n       sql_print_warning(\"CTRL-C ignored during startup\");\n     DBUG_RETURN(TRUE);\n  }\n#endif\n  DBUG_RETURN(FALSE);\n}\n\n\n\n\n#ifdef DEBUG_UNHANDLED_EXCEPTION_FILTER\n#define DEBUGGER_ATTACH_TIMEOUT 120\n/*\n  Wait for debugger to attach and break into debugger. If debugger is\n  not attached, resume after timeout.\n*/\nstatic void wait_for_debugger(int timeout_sec)\n{\n   if(!IsDebuggerPresent())\n   {\n     int i;\n     printf(\"Waiting for debugger to attach, pid=%u\\n\",GetCurrentProcessId());\n     fflush(stdout);\n     for(i= 0; i < timeout_sec; i++)\n     {\n       Sleep(1000);\n       if(IsDebuggerPresent())\n       {\n         /* Break into debugger */\n         __debugbreak();\n         return;\n       }\n     }\n     printf(\"pid=%u, debugger not attached after %d seconds, resuming\\n\",GetCurrentProcessId(),\n       timeout_sec);\n     fflush(stdout);\n   }\n}\n#endif /* DEBUG_UNHANDLED_EXCEPTION_FILTER */\n\nLONG WINAPI my_unhandler_exception_filter(EXCEPTION_POINTERS *ex_pointers)\n{\n   static BOOL first_time= TRUE;\n   if(!first_time)\n   {\n     /*\n       This routine can be called twice, typically\n       when detaching in JIT debugger.\n       Return EXCEPTION_EXECUTE_HANDLER to terminate process.\n     */\n     return EXCEPTION_EXECUTE_HANDLER;\n   }\n   first_time= FALSE;\n#ifdef DEBUG_UNHANDLED_EXCEPTION_FILTER\n   /*\n    Unfortunately there is no clean way to debug unhandled exception filters,\n    as debugger does not stop there(also documented in MSDN) \n    To overcome, one could put a MessageBox, but this will not work in service.\n    Better solution is to print error message and sleep some minutes \n    until debugger is attached\n  */\n  wait_for_debugger(DEBUGGER_ATTACH_TIMEOUT);\n#endif /* DEBUG_UNHANDLED_EXCEPTION_FILTER */\n  __try\n  {\n    my_set_exception_pointers(ex_pointers);\n    handle_fatal_signal(ex_pointers->ExceptionRecord->ExceptionCode);\n  }\n  __except(EXCEPTION_EXECUTE_HANDLER)\n  {\n    DWORD written;\n    const char msg[] = \"Got exception in exception handler!\\n\";\n    WriteFile(GetStdHandle(STD_OUTPUT_HANDLE),msg, sizeof(msg)-1, \n      &written,NULL);\n  }\n  /*\n    Return EXCEPTION_CONTINUE_SEARCH to give JIT debugger\n    (drwtsn32 or vsjitdebugger) possibility to attach,\n    if JIT debugger is configured.\n    Windows Error reporting might generate a dump here.\n  */\n  return EXCEPTION_CONTINUE_SEARCH;\n}\n\n\nvoid init_signals(void)\n{\n  if(opt_console)\n    SetConsoleCtrlHandler(console_event_handler,TRUE);\n\n    /* Avoid MessageBox()es*/\n  _CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE);\n  _CrtSetReportFile(_CRT_WARN, _CRTDBG_FILE_STDERR);\n  _CrtSetReportMode(_CRT_ERROR, _CRTDBG_MODE_FILE);\n  _CrtSetReportFile(_CRT_ERROR, _CRTDBG_FILE_STDERR);\n  _CrtSetReportMode(_CRT_ASSERT, _CRTDBG_MODE_FILE);\n  _CrtSetReportFile(_CRT_ASSERT, _CRTDBG_FILE_STDERR);\n\n   /*\n     Do not use SEM_NOGPFAULTERRORBOX in the following SetErrorMode (),\n     because it would prevent JIT debugger and Windows error reporting\n     from working. We need WER or JIT-debugging, since our own unhandled\n     exception filter is not guaranteed to work in all situation\n     (like heap corruption or stack overflow)\n   */\n  SetErrorMode(SetErrorMode(0) | SEM_FAILCRITICALERRORS\n                               | SEM_NOOPENFILEERRORBOX);\n  SetUnhandledExceptionFilter(my_unhandler_exception_filter);\n}\n\n\nstatic void start_signal_handler(void)\n{\n#ifndef EMBEDDED_LIBRARY\n  // Save vm id of this process\n  if (!opt_bootstrap)\n    create_pid_file();\n#endif /* EMBEDDED_LIBRARY */\n}\n\n\nstatic void check_data_home(const char *path)\n{}\n\n#endif /* __WIN__ */\n\n\n#if BACKTRACE_DEMANGLE\n#include <cxxabi.h>\nextern \"C\" char *my_demangle(const char *mangled_name, int *status)\n{\n  return abi::__cxa_demangle(mangled_name, NULL, NULL, status);\n}\n#endif\n\n\n/*\n  pthread_attr_setstacksize() without so much platform-dependency\n\n  Return: The actual stack size if possible.\n*/\n\n#ifndef EMBEDDED_LIBRARY\nstatic size_t my_setstacksize(pthread_attr_t *attr, size_t stacksize)\n{\n  size_t guard_size __attribute__((unused))= 0;\n\n#if defined(__ia64__) || defined(__ia64)\n  /*\n    On IA64, half of the requested stack size is used for \"normal stack\"\n    and half for \"register stack\".  The space measured by check_stack_overrun\n    is the \"normal stack\", so double the request to make sure we have the\n    caller-expected amount of normal stack.\n\n    NOTE: there is no guarantee that the register stack can't grow faster\n    than normal stack, so it's very unclear that we won't dump core due to\n    stack overrun despite check_stack_overrun's efforts.  Experimentation\n    shows that in the execution_constants test, the register stack grows\n    less than half as fast as normal stack, but perhaps other scenarios are\n    less forgiving.  If it turns out that more space is needed for the\n    register stack, that could be forced (rather inefficiently) by using a\n    multiplier higher than 2 here.\n  */\n  stacksize *= 2;\n#endif\n\n  /*\n    On many machines, the \"guard space\" is subtracted from the requested\n    stack size, and that space is quite large on some platforms.  So add\n    it to our request, if we can find out what it is.\n  */\n#ifdef HAVE_PTHREAD_ATTR_GETGUARDSIZE\n  if (pthread_attr_getguardsize(attr, &guard_size))\n    guard_size = 0;\t\t/* if can't find it out, treat as 0 */\n#endif\n\n  pthread_attr_setstacksize(attr, stacksize + guard_size);\n\n  /* Retrieve actual stack size if possible */\n#ifdef HAVE_PTHREAD_ATTR_GETSTACKSIZE\n  {\n    size_t real_stack_size= 0;\n    /* We must ignore real_stack_size = 0 as Solaris 2.9 can return 0 here */\n    if (pthread_attr_getstacksize(attr, &real_stack_size) == 0 &&\n\treal_stack_size > guard_size)\n    {\n      real_stack_size -= guard_size;\n      if (real_stack_size < stacksize)\n      {\n\tif (global_system_variables.log_warnings)\n          sql_print_warning(\"Asked for %zu thread stack, but got %zu\",\n                            stacksize, real_stack_size);\n\tstacksize= real_stack_size;\n      }\n    }\n  }\n#endif /* !EMBEDDED_LIBRARY */\n\n#if defined(__ia64__) || defined(__ia64)\n  stacksize /= 2;\n#endif\n  return stacksize;\n}\n#endif\n\n#ifdef DBUG_ASSERT_AS_PRINTF\nextern \"C\" void\nmariadb_dbug_assert_failed(const char *assert_expr, const char *file,\n                           unsigned long line)\n{\n  fprintf(stderr, \"Warning: assertion failed: %s at %s line %lu\\n\",\n          assert_expr, file, line);\n  if (opt_stack_trace)\n  {\n    fprintf(stderr, \"Attempting backtrace to find out the reason for the assert:\\n\");\n    my_print_stacktrace(NULL, (ulong) my_thread_stack_size, 1);\n  }\n}\n#endif /* DBUG_ASSERT_AS_PRINT */\n\n#if !defined(__WIN__)\n#ifndef SA_RESETHAND\n#define SA_RESETHAND 0\n#endif /* SA_RESETHAND */\n#ifndef SA_NODEFER\n#define SA_NODEFER 0\n#endif /* SA_NODEFER */\n\n#ifndef EMBEDDED_LIBRARY\n\nvoid init_signals(void)\n{\n  sigset_t set;\n  struct sigaction sa;\n  DBUG_ENTER(\"init_signals\");\n\n  my_sigset(THR_SERVER_ALARM,print_signal_warning); // Should never be called!\n\n  if (opt_stack_trace || (test_flags & TEST_CORE_ON_SIGNAL))\n  {\n    sa.sa_flags = SA_RESETHAND | SA_NODEFER;\n    sigemptyset(&sa.sa_mask);\n    sigprocmask(SIG_SETMASK,&sa.sa_mask,NULL);\n\n    my_init_stacktrace();\n#if defined(__amiga__)\n    sa.sa_handler=(void(*)())handle_fatal_signal;\n#else\n    sa.sa_handler=handle_fatal_signal;\n#endif\n    sigaction(SIGSEGV, &sa, NULL);\n    sigaction(SIGABRT, &sa, NULL);\n#ifdef SIGBUS\n    sigaction(SIGBUS, &sa, NULL);\n#endif\n    sigaction(SIGILL, &sa, NULL);\n    sigaction(SIGFPE, &sa, NULL);\n  }\n\n#ifdef HAVE_GETRLIMIT\n  if (test_flags & TEST_CORE_ON_SIGNAL)\n  {\n    /* Change limits so that we will get a core file */\n    STRUCT_RLIMIT rl;\n    rl.rlim_cur = rl.rlim_max = (rlim_t) RLIM_INFINITY;\n    if (setrlimit(RLIMIT_CORE, &rl) && global_system_variables.log_warnings)\n      sql_print_warning(\"setrlimit could not change the size of core files to 'infinity';  We may not be able to generate a core file on signals\");\n  }\n#endif\n  (void) sigemptyset(&set);\n  my_sigset(SIGPIPE,SIG_IGN);\n  sigaddset(&set,SIGPIPE);\n#ifndef IGNORE_SIGHUP_SIGQUIT\n  sigaddset(&set,SIGQUIT);\n  sigaddset(&set,SIGHUP);\n#endif\n  sigaddset(&set,SIGTERM);\n\n  /* Fix signals if blocked by parents (can happen on Mac OS X) */\n  sigemptyset(&sa.sa_mask);\n  sa.sa_flags = 0;\n  sa.sa_handler = print_signal_warning;\n  sigaction(SIGTERM, &sa, (struct sigaction*) 0);\n  sa.sa_flags = 0;\n  sa.sa_handler = print_signal_warning;\n  sigaction(SIGHUP, &sa, (struct sigaction*) 0);\n  if (thd_lib_detected != THD_LIB_LT)\n    sigaddset(&set,THR_SERVER_ALARM);\n  if (test_flags & TEST_SIGINT)\n  {\n    /* Allow SIGINT to break mysqld. This is for debugging with --gdb */\n    my_sigset(SIGINT, end_mysqld_signal);\n    sigdelset(&set, SIGINT);\n  }\n  else\n  {\n    sigaddset(&set,SIGINT);\n#ifdef SIGTSTP\n    sigaddset(&set,SIGTSTP);\n#endif\n  }\n\n  sigprocmask(SIG_SETMASK,&set,NULL);\n  pthread_sigmask(SIG_SETMASK,&set,NULL);\n  DBUG_VOID_RETURN;\n}\n\n\nstatic void start_signal_handler(void)\n{\n  int error;\n  pthread_attr_t thr_attr;\n  DBUG_ENTER(\"start_signal_handler\");\n\n  (void) pthread_attr_init(&thr_attr);\n  pthread_attr_setscope(&thr_attr,PTHREAD_SCOPE_SYSTEM);\n  (void) pthread_attr_setdetachstate(&thr_attr,PTHREAD_CREATE_DETACHED);\n  (void) my_setstacksize(&thr_attr,my_thread_stack_size);\n\n  mysql_mutex_lock(&LOCK_start_thread);\n  if (unlikely((error= mysql_thread_create(key_thread_signal_hand,\n                                           &signal_thread, &thr_attr,\n                                           signal_hand, 0))))\n  {\n    sql_print_error(\"Can't create interrupt-thread (error %d, errno: %d)\",\n\t\t    error,errno);\n    exit(1);\n  }\n  mysql_cond_wait(&COND_start_thread, &LOCK_start_thread);\n  mysql_mutex_unlock(&LOCK_start_thread);\n\n  (void) pthread_attr_destroy(&thr_attr);\n  DBUG_VOID_RETURN;\n}\n\n\n#if defined(USE_ONE_SIGNAL_HAND)\npthread_handler_t kill_server_thread(void *arg __attribute__((unused)))\n{\n  my_thread_init();\t\t\t\t// Initialize new thread\n  break_connect_loop();\n  my_thread_end();\n  pthread_exit(0);\n  return 0;\n}\n#endif\n\n\n/** This threads handles all signals and alarms. */\n/* ARGSUSED */\npthread_handler_t signal_hand(void *arg __attribute__((unused)))\n{\n  sigset_t set;\n  int sig;\n  my_thread_init();\t\t\t\t// Init new thread\n  DBUG_ENTER(\"signal_hand\");\n  signal_thread_in_use= 1;\n\n  /*\n    Setup alarm handler\n    This should actually be '+ max_number_of_slaves' instead of +10,\n    but the +10 should be quite safe.\n  */\n  init_thr_alarm(thread_scheduler->max_threads + extra_max_connections +\n\t\t global_system_variables.max_insert_delayed_threads + 10);\n  if (test_flags & TEST_SIGINT)\n  {\n    /* Allow SIGINT to break mysqld. This is for debugging with --gdb */\n    (void) sigemptyset(&set);\n    (void) sigaddset(&set,SIGINT);\n    (void) pthread_sigmask(SIG_UNBLOCK,&set,NULL);\n  }\n  (void) sigemptyset(&set);\t\t\t// Setup up SIGINT for debug\n#ifdef USE_ONE_SIGNAL_HAND\n  (void) sigaddset(&set,THR_SERVER_ALARM);\t// For alarms\n#endif\n#ifndef IGNORE_SIGHUP_SIGQUIT\n  (void) sigaddset(&set,SIGQUIT);\n  (void) sigaddset(&set,SIGHUP);\n#endif\n  (void) sigaddset(&set,SIGTERM);\n  (void) sigaddset(&set,SIGTSTP);\n\n  /* Save pid to this process (or thread on Linux) */\n  if (!opt_bootstrap)\n    create_pid_file();\n\n  /*\n    signal to start_signal_handler that we are ready\n    This works by waiting for start_signal_handler to free mutex,\n    after which we signal it that we are ready.\n    At this point there is no other threads running, so there\n    should not be any other mysql_cond_signal() calls.\n  */\n  mysql_mutex_lock(&LOCK_start_thread);\n  mysql_cond_broadcast(&COND_start_thread);\n  mysql_mutex_unlock(&LOCK_start_thread);\n\n  (void) pthread_sigmask(SIG_BLOCK,&set,NULL);\n  for (;;)\n  {\n    int error;\n    int origin;\n\n    while ((error= my_sigwait(&set, &sig, &origin)) == EINTR) /* no-op */;\n    if (cleanup_done)\n    {\n      DBUG_PRINT(\"quit\",(\"signal_handler: calling my_thread_end()\"));\n      my_thread_end();\n      DBUG_LEAVE;                               // Must match DBUG_ENTER()\n      signal_thread_in_use= 0;\n      pthread_exit(0);\t\t\t\t// Safety\n      return 0;                                 // Avoid compiler warnings\n    }\n    switch (sig) {\n    case SIGTERM:\n    case SIGQUIT:\n    case SIGKILL:\n#ifdef EXTRA_DEBUG\n      sql_print_information(\"Got signal %d to shutdown mysqld\",sig);\n#endif\n      /* switch to the old log message processing */\n      logger.set_handlers(LOG_FILE, global_system_variables.sql_log_slow ? LOG_FILE:LOG_NONE,\n                          opt_log ? LOG_FILE:LOG_NONE);\n      DBUG_PRINT(\"info\",(\"Got signal: %d  abort_loop: %d\",sig,abort_loop));\n      if (!abort_loop)\n      {\n        /* Delete the instrumentation for the signal thread */\n        PSI_CALL_delete_current_thread();\n#ifdef USE_ONE_SIGNAL_HAND\n\tpthread_t tmp;\n        if (unlikely((error= mysql_thread_create(0, /* Not instrumented */\n                                                 &tmp, &connection_attrib,\n                                                 kill_server_thread,\n                                                 (void*) &sig))))\n          sql_print_error(\"Can't create thread to kill server (errno= %d)\",\n                          error);\n#else\n        my_sigset(sig, SIG_IGN);\n        break_connect_loop(); // MIT THREAD has a alarm thread\n#endif\n      }\n      break;\n    case SIGHUP:\n      if (!abort_loop && origin != SI_KERNEL)\n      {\n        int not_used;\n\tmysql_print_status();\t\t// Print some debug info\n\treload_acl_and_cache((THD*) 0,\n\t\t\t     (REFRESH_LOG | REFRESH_TABLES | REFRESH_FAST |\n\t\t\t      REFRESH_GRANT |\n\t\t\t      REFRESH_THREADS | REFRESH_HOSTS),\n\t\t\t     (TABLE_LIST*) 0, &not_used); // Flush logs\n\n        /* reenable logs after the options were reloaded */\n        ulonglong fixed_log_output_options=\n          log_output_options & LOG_NONE ? LOG_TABLE : log_output_options;\n\n        logger.set_handlers(LOG_FILE, global_system_variables.sql_log_slow\n                                      ? fixed_log_output_options : LOG_NONE,\n                            opt_log ? fixed_log_output_options : LOG_NONE);\n      }\n      break;\n#ifdef USE_ONE_SIGNAL_HAND\n    case THR_SERVER_ALARM:\n      process_alarm(sig);\t\t\t// Trigger alarms.\n      break;\n#endif\n    default:\n#ifdef EXTRA_DEBUG\n      sql_print_warning(\"Got signal: %d  error: %d\",sig,error); /* purecov: tested */\n#endif\n      break;\t\t\t\t\t/* purecov: tested */\n    }\n  }\n  return(0);\t\t\t\t\t/* purecov: deadcode */\n}\n\nstatic void check_data_home(const char *path)\n{}\n\n#endif /*!EMBEDDED_LIBRARY*/\n#endif\t/* __WIN__*/\n\n\n/**\n  All global error messages are sent here where the first one is stored\n  for the client.\n*/\n/* ARGSUSED */\nextern \"C\" void my_message_sql(uint error, const char *str, myf MyFlags);\n\nvoid my_message_sql(uint error, const char *str, myf MyFlags)\n{\n  THD *thd= MyFlags & ME_ERROR_LOG_ONLY ? NULL : current_thd;\n  Sql_condition::enum_warning_level level;\n  sql_print_message_func func;\n  DBUG_ENTER(\"my_message_sql\");\n  DBUG_PRINT(\"error\", (\"error: %u  message: '%s'  Flag: %lu\", error, str,\n                       MyFlags));\n\n  DBUG_ASSERT(str != NULL);\n  DBUG_ASSERT(error != 0);\n  DBUG_ASSERT((MyFlags & ~(ME_BELL | ME_ERROR_LOG | ME_ERROR_LOG_ONLY |\n                           ME_NOTE | ME_WARNING | ME_FATAL)) == 0);\n\n  if (MyFlags & ME_NOTE)\n  {\n    level= Sql_condition::WARN_LEVEL_NOTE;\n    func= sql_print_information;\n  }\n  else if (MyFlags & ME_WARNING)\n  {\n    level= Sql_condition::WARN_LEVEL_WARN;\n    func= sql_print_warning;\n  }\n  else\n  {\n    level= Sql_condition::WARN_LEVEL_ERROR;\n    func= sql_print_error;\n  }\n\n  if (likely(thd))\n  {\n    if (unlikely(MyFlags & ME_FATAL))\n      thd->is_fatal_error= 1;\n    (void) thd->raise_condition(error, NULL, level, str);\n  }\n  else\n    mysql_audit_general(0, MYSQL_AUDIT_GENERAL_ERROR, error, str);\n\n  /* When simulating OOM, skip writing to error log to avoid mtr errors */\n  DBUG_EXECUTE_IF(\"simulate_out_of_memory\", DBUG_VOID_RETURN;);\n\n  if (unlikely(!thd) || thd->log_all_errors || (MyFlags & ME_ERROR_LOG))\n    (*func)(\"%s: %s\", my_progname_short, str); /* purecov: inspected */\n  DBUG_VOID_RETURN;\n}\n\n\nextern \"C\" void *my_str_malloc_mysqld(size_t size);\n\nvoid *my_str_malloc_mysqld(size_t size)\n{\n  return my_malloc(size, MYF(MY_FAE));\n}\n\n\n#include <mysqld_default_groups.h>\n\n#if defined(__WIN__) && !defined(EMBEDDED_LIBRARY)\nstatic const int load_default_groups_sz=\nsizeof(load_default_groups)/sizeof(load_default_groups[0]);\n#endif\n\n\n/**\n  This function is used to check for stack overrun for pathological\n  cases of  regular expressions and 'like' expressions.\n*/\nextern \"C\" int\ncheck_enough_stack_size_slow()\n{\n  uchar stack_top;\n  THD *my_thd= current_thd;\n  if (my_thd != NULL)\n    return check_stack_overrun(my_thd, STACK_MIN_SIZE * 2, &stack_top);\n  return 0;\n}\n\n\n/*\n  The call to current_thd in check_enough_stack_size_slow is quite expensive,\n  so we try to avoid it for the normal cases.\n  The size of  each stack frame for the wildcmp() routines is ~128 bytes,\n  so checking  *every* recursive call is not necessary.\n */\nextern \"C\" int\ncheck_enough_stack_size(int recurse_level)\n{\n  if (recurse_level % 16 != 0)\n    return 0;\n  return check_enough_stack_size_slow();\n}\n\n\nstatic void init_libstrings()\n{\n#ifndef EMBEDDED_LIBRARY\n  my_string_stack_guard= check_enough_stack_size;\n#endif\n}\n\nulonglong my_pcre_frame_size;\n\nstatic void init_pcre()\n{\n  pcre_malloc= pcre_stack_malloc= my_str_malloc_mysqld;\n  pcre_free= pcre_stack_free= my_free;\n  pcre_stack_guard= check_enough_stack_size_slow;\n  /* See http://pcre.org/original/doc/html/pcrestack.html */\n  my_pcre_frame_size= -pcre_exec(NULL, NULL, NULL, -999, -999, 0, NULL, 0);\n  // pcre can underestimate its stack usage. Use a safe value, as in the manual\n  set_if_bigger(my_pcre_frame_size, 500);\n  my_pcre_frame_size += 16; // Again, safety margin, see the manual\n}\n\n\n/**\n  Initialize one of the global date/time format variables.\n\n  @param format_type\t\tWhat kind of format should be supported\n  @param var_ptr\t\tPointer to variable that should be updated\n\n  @retval\n    0 ok\n  @retval\n    1 error\n*/\n\nstatic bool init_global_datetime_format(timestamp_type format_type,\n                                        DATE_TIME_FORMAT *format)\n{\n  /*\n    Get command line option\n    format->format.str is already set by my_getopt\n  */\n  format->format.length= strlen(format->format.str);\n\n  if (parse_date_time_format(format_type, format))\n  {\n    fprintf(stderr, \"Wrong date/time format specifier: %s\\n\",\n            format->format.str);\n    return true;\n  }\n  return false;\n}\n\n#define COM_STATUS(X)  (void*) offsetof(STATUS_VAR, X), SHOW_LONG_STATUS\n#define STMT_STATUS(X) COM_STATUS(com_stat[(uint) X])\n\nSHOW_VAR com_status_vars[]= {\n  {\"admin_commands\",       COM_STATUS(com_other)},\n  {\"alter_db\",             STMT_STATUS(SQLCOM_ALTER_DB)},\n  {\"alter_db_upgrade\",     STMT_STATUS(SQLCOM_ALTER_DB_UPGRADE)},\n  {\"alter_event\",          STMT_STATUS(SQLCOM_ALTER_EVENT)},\n  {\"alter_function\",       STMT_STATUS(SQLCOM_ALTER_FUNCTION)},\n  {\"alter_procedure\",      STMT_STATUS(SQLCOM_ALTER_PROCEDURE)},\n  {\"alter_server\",         STMT_STATUS(SQLCOM_ALTER_SERVER)},\n  {\"alter_sequence\",       STMT_STATUS(SQLCOM_ALTER_SEQUENCE)},\n  {\"alter_table\",          STMT_STATUS(SQLCOM_ALTER_TABLE)},\n  {\"alter_tablespace\",     STMT_STATUS(SQLCOM_ALTER_TABLESPACE)},\n  {\"alter_user\",           STMT_STATUS(SQLCOM_ALTER_USER)},\n  {\"analyze\",              STMT_STATUS(SQLCOM_ANALYZE)},\n  {\"assign_to_keycache\",   STMT_STATUS(SQLCOM_ASSIGN_TO_KEYCACHE)},\n  {\"backup\",               STMT_STATUS(SQLCOM_BACKUP)},\n  {\"backup_lock\",          STMT_STATUS(SQLCOM_BACKUP_LOCK)},\n  {\"begin\",                STMT_STATUS(SQLCOM_BEGIN)},\n  {\"binlog\",               STMT_STATUS(SQLCOM_BINLOG_BASE64_EVENT)},\n  {\"call_procedure\",       STMT_STATUS(SQLCOM_CALL)},\n  {\"change_db\",            STMT_STATUS(SQLCOM_CHANGE_DB)},\n  {\"change_master\",        STMT_STATUS(SQLCOM_CHANGE_MASTER)},\n  {\"check\",                STMT_STATUS(SQLCOM_CHECK)},\n  {\"checksum\",             STMT_STATUS(SQLCOM_CHECKSUM)},\n  {\"commit\",               STMT_STATUS(SQLCOM_COMMIT)},\n  {\"compound_sql\",         STMT_STATUS(SQLCOM_COMPOUND)},\n  {\"create_db\",            STMT_STATUS(SQLCOM_CREATE_DB)},\n  {\"create_event\",         STMT_STATUS(SQLCOM_CREATE_EVENT)},\n  {\"create_function\",      STMT_STATUS(SQLCOM_CREATE_SPFUNCTION)},\n  {\"create_index\",         STMT_STATUS(SQLCOM_CREATE_INDEX)},\n  {\"create_package\",       STMT_STATUS(SQLCOM_CREATE_PACKAGE)},\n  {\"create_package_body\",  STMT_STATUS(SQLCOM_CREATE_PACKAGE_BODY)},\n  {\"create_procedure\",     STMT_STATUS(SQLCOM_CREATE_PROCEDURE)},\n  {\"create_role\",          STMT_STATUS(SQLCOM_CREATE_ROLE)},\n  {\"create_sequence\",      STMT_STATUS(SQLCOM_CREATE_SEQUENCE)},\n  {\"create_server\",        STMT_STATUS(SQLCOM_CREATE_SERVER)},\n  {\"create_table\",         STMT_STATUS(SQLCOM_CREATE_TABLE)},\n  {\"create_temporary_table\", COM_STATUS(com_create_tmp_table)},\n  {\"create_trigger\",       STMT_STATUS(SQLCOM_CREATE_TRIGGER)},\n  {\"create_udf\",           STMT_STATUS(SQLCOM_CREATE_FUNCTION)},\n  {\"create_user\",          STMT_STATUS(SQLCOM_CREATE_USER)},\n  {\"create_view\",          STMT_STATUS(SQLCOM_CREATE_VIEW)},\n  {\"dealloc_sql\",          STMT_STATUS(SQLCOM_DEALLOCATE_PREPARE)},\n  {\"delete\",               STMT_STATUS(SQLCOM_DELETE)},\n  {\"delete_multi\",         STMT_STATUS(SQLCOM_DELETE_MULTI)},\n  {\"do\",                   STMT_STATUS(SQLCOM_DO)},\n  {\"drop_db\",              STMT_STATUS(SQLCOM_DROP_DB)},\n  {\"drop_event\",           STMT_STATUS(SQLCOM_DROP_EVENT)},\n  {\"drop_function\",        STMT_STATUS(SQLCOM_DROP_FUNCTION)},\n  {\"drop_index\",           STMT_STATUS(SQLCOM_DROP_INDEX)},\n  {\"drop_procedure\",       STMT_STATUS(SQLCOM_DROP_PROCEDURE)},\n  {\"drop_package\",         STMT_STATUS(SQLCOM_DROP_PACKAGE)},\n  {\"drop_package_body\",    STMT_STATUS(SQLCOM_DROP_PACKAGE_BODY)},\n  {\"drop_role\",            STMT_STATUS(SQLCOM_DROP_ROLE)},\n  {\"drop_server\",          STMT_STATUS(SQLCOM_DROP_SERVER)},\n  {\"drop_sequence\",        STMT_STATUS(SQLCOM_DROP_SEQUENCE)},\n  {\"drop_table\",           STMT_STATUS(SQLCOM_DROP_TABLE)},\n  {\"drop_temporary_table\", COM_STATUS(com_drop_tmp_table)},\n  {\"drop_trigger\",         STMT_STATUS(SQLCOM_DROP_TRIGGER)},\n  {\"drop_user\",            STMT_STATUS(SQLCOM_DROP_USER)},\n  {\"drop_view\",            STMT_STATUS(SQLCOM_DROP_VIEW)},\n  {\"empty_query\",          STMT_STATUS(SQLCOM_EMPTY_QUERY)},\n  {\"execute_immediate\",    STMT_STATUS(SQLCOM_EXECUTE_IMMEDIATE)},\n  {\"execute_sql\",          STMT_STATUS(SQLCOM_EXECUTE)},\n  {\"flush\",                STMT_STATUS(SQLCOM_FLUSH)},\n  {\"get_diagnostics\",      STMT_STATUS(SQLCOM_GET_DIAGNOSTICS)},\n  {\"grant\",                STMT_STATUS(SQLCOM_GRANT)},\n  {\"grant_role\",           STMT_STATUS(SQLCOM_GRANT_ROLE)},\n  {\"ha_close\",             STMT_STATUS(SQLCOM_HA_CLOSE)},\n  {\"ha_open\",              STMT_STATUS(SQLCOM_HA_OPEN)},\n  {\"ha_read\",              STMT_STATUS(SQLCOM_HA_READ)},\n  {\"help\",                 STMT_STATUS(SQLCOM_HELP)},\n  {\"insert\",               STMT_STATUS(SQLCOM_INSERT)},\n  {\"insert_select\",        STMT_STATUS(SQLCOM_INSERT_SELECT)},\n  {\"install_plugin\",       STMT_STATUS(SQLCOM_INSTALL_PLUGIN)},\n  {\"kill\",                 STMT_STATUS(SQLCOM_KILL)},\n  {\"load\",                 STMT_STATUS(SQLCOM_LOAD)},\n  {\"lock_tables\",          STMT_STATUS(SQLCOM_LOCK_TABLES)},\n  {\"multi\",                COM_STATUS(com_multi)},\n  {\"optimize\",             STMT_STATUS(SQLCOM_OPTIMIZE)},\n  {\"preload_keys\",         STMT_STATUS(SQLCOM_PRELOAD_KEYS)},\n  {\"prepare_sql\",          STMT_STATUS(SQLCOM_PREPARE)},\n  {\"purge\",                STMT_STATUS(SQLCOM_PURGE)},\n  {\"purge_before_date\",    STMT_STATUS(SQLCOM_PURGE_BEFORE)},\n  {\"release_savepoint\",    STMT_STATUS(SQLCOM_RELEASE_SAVEPOINT)},\n  {\"rename_table\",         STMT_STATUS(SQLCOM_RENAME_TABLE)},\n  {\"rename_user\",          STMT_STATUS(SQLCOM_RENAME_USER)},\n  {\"repair\",               STMT_STATUS(SQLCOM_REPAIR)},\n  {\"replace\",              STMT_STATUS(SQLCOM_REPLACE)},\n  {\"replace_select\",       STMT_STATUS(SQLCOM_REPLACE_SELECT)},\n  {\"reset\",                STMT_STATUS(SQLCOM_RESET)},\n  {\"resignal\",             STMT_STATUS(SQLCOM_RESIGNAL)},\n  {\"revoke\",               STMT_STATUS(SQLCOM_REVOKE)},\n  {\"revoke_all\",           STMT_STATUS(SQLCOM_REVOKE_ALL)},\n  {\"revoke_role\",          STMT_STATUS(SQLCOM_REVOKE_ROLE)},\n  {\"rollback\",             STMT_STATUS(SQLCOM_ROLLBACK)},\n  {\"rollback_to_savepoint\",STMT_STATUS(SQLCOM_ROLLBACK_TO_SAVEPOINT)},\n  {\"savepoint\",            STMT_STATUS(SQLCOM_SAVEPOINT)},\n  {\"select\",               STMT_STATUS(SQLCOM_SELECT)},\n  {\"set_option\",           STMT_STATUS(SQLCOM_SET_OPTION)},\n  {\"show_authors\",         STMT_STATUS(SQLCOM_SHOW_AUTHORS)},\n  {\"show_binlog_events\",   STMT_STATUS(SQLCOM_SHOW_BINLOG_EVENTS)},\n  {\"show_binlogs\",         STMT_STATUS(SQLCOM_SHOW_BINLOGS)},\n  {\"show_charsets\",        STMT_STATUS(SQLCOM_SHOW_CHARSETS)},\n  {\"show_collations\",      STMT_STATUS(SQLCOM_SHOW_COLLATIONS)},\n  {\"show_contributors\",    STMT_STATUS(SQLCOM_SHOW_CONTRIBUTORS)},\n  {\"show_create_db\",       STMT_STATUS(SQLCOM_SHOW_CREATE_DB)},\n  {\"show_create_event\",    STMT_STATUS(SQLCOM_SHOW_CREATE_EVENT)},\n  {\"show_create_func\",     STMT_STATUS(SQLCOM_SHOW_CREATE_FUNC)},\n  {\"show_create_package\",  STMT_STATUS(SQLCOM_SHOW_CREATE_PACKAGE)},\n  {\"show_create_package_body\",STMT_STATUS(SQLCOM_SHOW_CREATE_PACKAGE_BODY)},\n  {\"show_create_proc\",     STMT_STATUS(SQLCOM_SHOW_CREATE_PROC)},\n  {\"show_create_table\",    STMT_STATUS(SQLCOM_SHOW_CREATE)},\n  {\"show_create_trigger\",  STMT_STATUS(SQLCOM_SHOW_CREATE_TRIGGER)},\n  {\"show_create_user\",     STMT_STATUS(SQLCOM_SHOW_CREATE_USER)},\n  {\"show_databases\",       STMT_STATUS(SQLCOM_SHOW_DATABASES)},\n  {\"show_engine_logs\",     STMT_STATUS(SQLCOM_SHOW_ENGINE_LOGS)},\n  {\"show_engine_mutex\",    STMT_STATUS(SQLCOM_SHOW_ENGINE_MUTEX)},\n  {\"show_engine_status\",   STMT_STATUS(SQLCOM_SHOW_ENGINE_STATUS)},\n  {\"show_errors\",          STMT_STATUS(SQLCOM_SHOW_ERRORS)},\n  {\"show_events\",          STMT_STATUS(SQLCOM_SHOW_EVENTS)},\n  {\"show_explain\",         STMT_STATUS(SQLCOM_SHOW_EXPLAIN)},\n  {\"show_fields\",          STMT_STATUS(SQLCOM_SHOW_FIELDS)},\n#ifndef DBUG_OFF\n  {\"show_function_code\",   STMT_STATUS(SQLCOM_SHOW_FUNC_CODE)},\n#endif\n  {\"show_function_status\", STMT_STATUS(SQLCOM_SHOW_STATUS_FUNC)},\n  {\"show_generic\",         STMT_STATUS(SQLCOM_SHOW_GENERIC)},\n  {\"show_grants\",          STMT_STATUS(SQLCOM_SHOW_GRANTS)},\n  {\"show_keys\",            STMT_STATUS(SQLCOM_SHOW_KEYS)},\n  {\"show_master_status\",   STMT_STATUS(SQLCOM_SHOW_MASTER_STAT)},\n  {\"show_open_tables\",     STMT_STATUS(SQLCOM_SHOW_OPEN_TABLES)},\n  {\"show_package_status\",  STMT_STATUS(SQLCOM_SHOW_STATUS_PACKAGE)},\n#ifndef DBUG_OFF\n  {\"show_package_body_code\",   STMT_STATUS(SQLCOM_SHOW_PACKAGE_BODY_CODE)},\n#endif\n  {\"show_package_body_status\", STMT_STATUS(SQLCOM_SHOW_STATUS_PACKAGE_BODY)},\n  {\"show_plugins\",         STMT_STATUS(SQLCOM_SHOW_PLUGINS)},\n  {\"show_privileges\",      STMT_STATUS(SQLCOM_SHOW_PRIVILEGES)},\n#ifndef DBUG_OFF\n  {\"show_procedure_code\",  STMT_STATUS(SQLCOM_SHOW_PROC_CODE)},\n#endif\n  {\"show_procedure_status\",STMT_STATUS(SQLCOM_SHOW_STATUS_PROC)},\n  {\"show_processlist\",     STMT_STATUS(SQLCOM_SHOW_PROCESSLIST)},\n  {\"show_profile\",         STMT_STATUS(SQLCOM_SHOW_PROFILE)},\n  {\"show_profiles\",        STMT_STATUS(SQLCOM_SHOW_PROFILES)},\n  {\"show_relaylog_events\", STMT_STATUS(SQLCOM_SHOW_RELAYLOG_EVENTS)},\n  {\"show_slave_hosts\",     STMT_STATUS(SQLCOM_SHOW_SLAVE_HOSTS)},\n  {\"show_slave_status\",    STMT_STATUS(SQLCOM_SHOW_SLAVE_STAT)},\n  {\"show_status\",          STMT_STATUS(SQLCOM_SHOW_STATUS)},\n  {\"show_storage_engines\", STMT_STATUS(SQLCOM_SHOW_STORAGE_ENGINES)},\n  {\"show_table_status\",    STMT_STATUS(SQLCOM_SHOW_TABLE_STATUS)},\n  {\"show_tables\",          STMT_STATUS(SQLCOM_SHOW_TABLES)},\n  {\"show_triggers\",        STMT_STATUS(SQLCOM_SHOW_TRIGGERS)},\n  {\"show_variables\",       STMT_STATUS(SQLCOM_SHOW_VARIABLES)},\n  {\"show_warnings\",        STMT_STATUS(SQLCOM_SHOW_WARNS)},\n  {\"shutdown\",             STMT_STATUS(SQLCOM_SHUTDOWN)},\n  {\"signal\",               STMT_STATUS(SQLCOM_SIGNAL)},\n  {\"start_all_slaves\",     STMT_STATUS(SQLCOM_SLAVE_ALL_START)},\n  {\"start_slave\",          STMT_STATUS(SQLCOM_SLAVE_START)},\n  {\"stmt_close\",           COM_STATUS(com_stmt_close)},\n  {\"stmt_execute\",         COM_STATUS(com_stmt_execute)},\n  {\"stmt_fetch\",           COM_STATUS(com_stmt_fetch)},\n  {\"stmt_prepare\",         COM_STATUS(com_stmt_prepare)},\n  {\"stmt_reprepare\",       COM_STATUS(com_stmt_reprepare)},\n  {\"stmt_reset\",           COM_STATUS(com_stmt_reset)},\n  {\"stmt_send_long_data\",  COM_STATUS(com_stmt_send_long_data)},\n  {\"stop_all_slaves\",      STMT_STATUS(SQLCOM_SLAVE_ALL_STOP)},\n  {\"stop_slave\",           STMT_STATUS(SQLCOM_SLAVE_STOP)},\n  {\"truncate\",             STMT_STATUS(SQLCOM_TRUNCATE)},\n  {\"uninstall_plugin\",     STMT_STATUS(SQLCOM_UNINSTALL_PLUGIN)},\n  {\"unlock_tables\",        STMT_STATUS(SQLCOM_UNLOCK_TABLES)},\n  {\"update\",               STMT_STATUS(SQLCOM_UPDATE)},\n  {\"update_multi\",         STMT_STATUS(SQLCOM_UPDATE_MULTI)},\n  {\"xa_commit\",            STMT_STATUS(SQLCOM_XA_COMMIT)},\n  {\"xa_end\",               STMT_STATUS(SQLCOM_XA_END)},\n  {\"xa_prepare\",           STMT_STATUS(SQLCOM_XA_PREPARE)},\n  {\"xa_recover\",           STMT_STATUS(SQLCOM_XA_RECOVER)},\n  {\"xa_rollback\",          STMT_STATUS(SQLCOM_XA_ROLLBACK)},\n  {\"xa_start\",             STMT_STATUS(SQLCOM_XA_START)},\n  {NullS, NullS, SHOW_LONG}\n};\n\n\n#ifdef HAVE_PSI_STATEMENT_INTERFACE\nPSI_statement_info sql_statement_info[(uint) SQLCOM_END + 1];\nPSI_statement_info com_statement_info[(uint) COM_END + 1];\n\n/**\n  Initialize the command names array.\n  Since we do not want to maintain a separate array,\n  this is populated from data mined in com_status_vars,\n  which already has one name for each command.\n*/\nvoid init_sql_statement_info()\n{\n  size_t first_com= offsetof(STATUS_VAR, com_stat[0]);\n  size_t last_com=  offsetof(STATUS_VAR, com_stat[(uint) SQLCOM_END]);\n  int record_size= offsetof(STATUS_VAR, com_stat[1])\n                   - offsetof(STATUS_VAR, com_stat[0]);\n  size_t ptr;\n  uint i;\n  uint com_index;\n\n  static const char* dummy= \"\";\n  for (i= 0; i < ((uint) SQLCOM_END + 1); i++)\n  {\n    sql_statement_info[i].m_name= dummy;\n    sql_statement_info[i].m_flags= 0;\n  }\n\n  SHOW_VAR *var= &com_status_vars[0];\n  while (var->name != NULL)\n  {\n    ptr= (size_t)(var->value);\n    if ((first_com <= ptr) && (ptr < last_com))\n    {\n      com_index= ((int)(ptr - first_com))/record_size;\n      DBUG_ASSERT(com_index < (uint) SQLCOM_END);\n      sql_statement_info[com_index].m_name= var->name;\n    }\n    var++;\n  }\n\n  DBUG_ASSERT(strcmp(sql_statement_info[(uint) SQLCOM_SELECT].m_name, \"select\") == 0);\n  DBUG_ASSERT(strcmp(sql_statement_info[(uint) SQLCOM_SIGNAL].m_name, \"signal\") == 0);\n\n  sql_statement_info[(uint) SQLCOM_END].m_name= \"error\";\n}\n\nvoid init_com_statement_info()\n{\n  uint index;\n\n  for (index= 0; index < (uint) COM_END + 1; index++)\n  {\n    com_statement_info[index].m_name= command_name[index].str;\n    com_statement_info[index].m_flags= 0;\n  }\n\n  /* \"statement/abstract/query\" can mutate into \"statement/sql/...\" */\n  com_statement_info[(uint) COM_QUERY].m_flags= PSI_FLAG_MUTABLE;\n}\n#endif\n\n\n#ifdef SAFEMALLOC\n/*\n  Return the id for the current THD, to allow safemalloc to associate\n  the memory with the right id.\n*/\n\nextern \"C\" my_thread_id mariadb_dbug_id()\n{\n  THD *thd;\n  if ((thd= current_thd) && thd->thread_dbug_id)\n  {\n    return thd->thread_dbug_id;\n  }\n  return my_thread_dbug_id();\n}\n#endif /* SAFEMALLOC */\n\n/* Thread Mem Usage By P.Linux */\nextern \"C\" {\nstatic void my_malloc_size_cb_func(long long size, my_bool is_thread_specific)\n{\n  THD *thd= current_thd;\n\n  /*\n    When thread specific is set, both mysqld_server_initialized and thd\n    must be set, and we check that with DBUG_ASSERT.\n\n    However, do not crash, if current_thd is NULL, in release version.\n  */\n  DBUG_ASSERT(!is_thread_specific || (mysqld_server_initialized && thd));\n\n  if (is_thread_specific && likely(thd))  /* If thread specific memory */\n  {\n    DBUG_PRINT(\"info\", (\"thd memory_used: %lld  size: %lld\",\n                        (longlong) thd->status_var.local_memory_used,\n                        size));\n    thd->status_var.local_memory_used+= size;\n    set_if_bigger(thd->status_var.max_local_memory_used,\n                  thd->status_var.local_memory_used);\n    if (size > 0 &&\n        thd->status_var.local_memory_used > (int64)thd->variables.max_mem_used &&\n        likely(!thd->killed) && !thd->get_stmt_da()->is_set())\n    {\n      /* Ensure we don't get called here again */\n      char buf[50], *buf2;\n      thd->set_killed(KILL_QUERY);\n      my_snprintf(buf, sizeof(buf), \"--max-thread-mem-used=%llu\",\n                  thd->variables.max_mem_used);\n      if ((buf2= (char*) thd->alloc(256)))\n      {\n        my_snprintf(buf2, 256, ER_THD(thd, ER_OPTION_PREVENTS_STATEMENT), buf);\n        thd->set_killed(KILL_QUERY, ER_OPTION_PREVENTS_STATEMENT, buf2);\n      }\n    }\n    DBUG_ASSERT((longlong) thd->status_var.local_memory_used >= 0 ||\n                !debug_assert_on_not_freed_memory);\n  }\n  else if (likely(thd))\n  {\n    DBUG_PRINT(\"info\", (\"global thd memory_used: %lld  size: %lld\",\n                        (longlong) thd->status_var.global_memory_used, size));\n    thd->status_var.global_memory_used+= size;\n  }\n  else\n    update_global_memory_status(size);\n}\n\nint json_escape_string(const char *str,const char *str_end,\n                       char *json, char *json_end)\n{\n  return json_escape(system_charset_info,\n                     (const uchar *) str, (const uchar *) str_end,\n                     &my_charset_utf8mb4_bin,\n                     (uchar *) json, (uchar *) json_end);\n}\n\n\nint json_unescape_json(const char *json_str, const char *json_end,\n                       char *res, char *res_end)\n{\n  return json_unescape(&my_charset_utf8mb4_bin,\n                       (const uchar *) json_str, (const uchar *) json_end,\n                       system_charset_info, (uchar *) res, (uchar *) res_end);\n}\n\n} /*extern \"C\"*/\n\n\n/**\n  Create a replication file name or base for file names.\n\n  @param[in] opt Value of option, or NULL\n  @param[in] def Default value if option value is not set.\n  @param[in] ext Extension to use for the path\n\n  @returns Pointer to string containing the full file path, or NULL if\n  it was not possible to create the path.\n */\nstatic inline const char *\nrpl_make_log_name(const char *opt,\n                  const char *def,\n                  const char *ext)\n{\n  DBUG_ENTER(\"rpl_make_log_name\");\n  DBUG_PRINT(\"enter\", (\"opt: %s, def: %s, ext: %s\", opt, def, ext));\n  char buff[FN_REFLEN];\n  const char *base= opt ? opt : def;\n  unsigned int options=\n    MY_REPLACE_EXT | MY_UNPACK_FILENAME | MY_SAFE_PATH;\n\n  /* mysql_real_data_home_ptr  may be null if no value of datadir has been\n     specified through command-line or througha cnf file. If that is the\n     case we make mysql_real_data_home_ptr point to mysql_real_data_home\n     which, in that case holds the default path for data-dir.\n  */\n  if(mysql_real_data_home_ptr == NULL)\n    mysql_real_data_home_ptr= mysql_real_data_home;\n\n  if (fn_format(buff, base, mysql_real_data_home_ptr, ext, options))\n    DBUG_RETURN(my_strdup(buff, MYF(MY_WME)));\n  else\n    DBUG_RETURN(NULL);\n}\n\n/* We have to setup my_malloc_size_cb_func early to catch all mallocs */\n\nstatic int init_early_variables()\n{\n  if (pthread_key_create(&THR_THD, NULL))\n  {\n    fprintf(stderr, \"Fatal error: Can't create thread-keys\\n\");\n    return 1;\n  }\n  set_current_thd(0);\n  set_malloc_size_cb(my_malloc_size_cb_func);\n  global_status_var.global_memory_used= 0;\n  return 0;\n}\n\n#ifdef _WIN32\nstatic void get_win_tzname(char* buf, size_t size)\n{\n  static struct\n  {\n    const wchar_t* windows_name;\n    const char*  tzdb_name;\n  }\n  tz_data[] =\n  {\n#include \"win_tzname_data.h\"\n    {0,0}\n  };\n  DYNAMIC_TIME_ZONE_INFORMATION  tzinfo;\n  if (GetDynamicTimeZoneInformation(&tzinfo) == TIME_ZONE_ID_UNKNOWN)\n  {\n    strncpy(buf, \"unknown\", size);\n    return;\n  }\n\n  for (size_t i= 0; tz_data[i].windows_name; i++)\n  {\n    if (wcscmp(tzinfo.TimeZoneKeyName, tz_data[i].windows_name) == 0)\n    {\n      strncpy(buf, tz_data[i].tzdb_name, size);\n      return;\n    }\n  }\n  wcstombs(buf, tzinfo.TimeZoneKeyName, size);\n  buf[size-1]= 0;\n  return;\n}\n#endif\n\nstatic int init_common_variables()\n{\n  umask(((~my_umask) & 0666));\n  connection_errors_select= 0;\n  connection_errors_accept= 0;\n  connection_errors_tcpwrap= 0;\n  connection_errors_internal= 0;\n  connection_errors_max_connection= 0;\n  connection_errors_peer_addr= 0;\n  my_decimal_set_zero(&decimal_zero); // set decimal_zero constant;\n\n  init_libstrings();\n  tzset();\t\t\t// Set tzname\n\n#ifdef SAFEMALLOC\n  sf_malloc_dbug_id= mariadb_dbug_id;\n#endif /* SAFEMALLOC */\n#ifdef DBUG_ASSERT_AS_PRINTF\n  my_dbug_assert_failed= mariadb_dbug_assert_failed;\n#endif /* DBUG_ASSERT_AS_PRINTF */\n\n  if (!(type_handler_data= new Type_handler_data) ||\n      type_handler_data->init())\n  {\n    sql_perror(\"Could not allocate type_handler_data\");\n    return 1;\n  }\n\n  max_system_variables.pseudo_thread_id= ~(my_thread_id) 0;\n  server_start_time= flush_status_time= my_time(0);\n  my_disable_copystat_in_redel= 1;\n\n  global_rpl_filter= new Rpl_filter;\n  binlog_filter= new Rpl_filter;\n  if (!global_rpl_filter || !binlog_filter)\n  {\n    sql_perror(\"Could not allocate replication and binlog filters\");\n    exit(1);\n  }\n\n#ifdef HAVE_OPENSSL\n  if (check_openssl_compatibility())\n  {\n    sql_print_error(\"Incompatible OpenSSL version. Cannot continue...\");\n    exit(1);\n  }\n#endif\n\n  if (init_thread_environment() || mysql_init_variables())\n    exit(1);\n\n  if (ignore_db_dirs_init())\n    exit(1);\n\n#ifdef _WIN32\n  get_win_tzname(system_time_zone, sizeof(system_time_zone));\n#elif defined(HAVE_TZNAME)\n  struct tm tm_tmp;\n  localtime_r(&server_start_time,&tm_tmp);\n  const char *tz_name=  tzname[tm_tmp.tm_isdst != 0 ? 1 : 0];\n  strmake_buf(system_time_zone, tz_name);\n#endif /* HAVE_TZNAME */\n\n  /*\n    We set SYSTEM time zone as reasonable default and\n    also for failure of my_tz_init() and bootstrap mode.\n    If user explicitly set time zone with --default-time-zone\n    option we will change this value in my_tz_init().\n  */\n  global_system_variables.time_zone= my_tz_SYSTEM;\n\n#ifdef HAVE_PSI_INTERFACE\n  /*\n    Complete the mysql_bin_log initialization.\n    Instrumentation keys are known only after the performance schema\n    initialization, and can not be set in the MYSQL_BIN_LOG\n    constructor (called before main()).\n  */\n  mysql_bin_log.set_psi_keys(key_BINLOG_LOCK_index,\n                             key_BINLOG_COND_relay_log_updated,\n                             key_BINLOG_COND_bin_log_updated,\n                             key_file_binlog,\n                             key_file_binlog_index,\n                             key_BINLOG_COND_queue_busy,\n                             key_LOCK_binlog_end_pos);\n#endif\n\n  /*\n    Init mutexes for the global MYSQL_BIN_LOG objects.\n    As safe_mutex depends on what MY_INIT() does, we can't init the mutexes of\n    global MYSQL_BIN_LOGs in their constructors, because then they would be\n    inited before MY_INIT(). So we do it here.\n  */\n  mysql_bin_log.init_pthread_objects();\n\n  /* TODO: remove this when my_time_t is 64 bit compatible */\n  if (!IS_TIME_T_VALID_FOR_TIMESTAMP(server_start_time))\n  {\n    sql_print_error(\"This MySQL server doesn't support dates later than 2038\");\n    exit(1);\n  }\n\n  opt_log_basename= const_cast<char *>(\"mysql\");\n\n  if (gethostname(glob_hostname,sizeof(glob_hostname)) < 0)\n  {\n    /*\n      Get hostname of computer (used by 'show variables') and as default\n      basename for the pid file if --log-basename is not given.\n    */\n    strmake(glob_hostname, STRING_WITH_LEN(\"localhost\"));\n    sql_print_warning(\"gethostname failed, using '%s' as hostname\",\n                        glob_hostname);\n  }\n  else if (is_filename_allowed(glob_hostname, strlen(glob_hostname), FALSE))\n    opt_log_basename= glob_hostname;\n\n  strmake(pidfile_name, opt_log_basename, sizeof(pidfile_name)-5);\n  strmov(fn_ext(pidfile_name),\".pid\");\t\t// Add proper extension\n  SYSVAR_AUTOSIZE(pidfile_name_ptr, pidfile_name);\n  set_sys_var_value_origin(&opt_tc_log_size, sys_var::AUTO);\n\n  /*\n    The default-storage-engine entry in my_long_options should have a\n    non-null default value. It was earlier intialized as\n    (longlong)\"MyISAM\" in my_long_options but this triggered a\n    compiler error in the Sun Studio 12 compiler. As a work-around we\n    set the def_value member to 0 in my_long_options and initialize it\n    to the correct value here.\n\n    From MySQL 5.5 onwards, the default storage engine is InnoDB\n    (except in the embedded server, where the default continues to\n    be MyISAM)\n  */\n#if defined(WITH_INNOBASE_STORAGE_ENGINE)\n  default_storage_engine= const_cast<char *>(\"InnoDB\");\n#else\n  default_storage_engine= const_cast<char *>(\"MyISAM\");\n#endif\n  default_tmp_storage_engine= NULL;\n  gtid_pos_auto_engines= const_cast<char *>(\"\");\n\n  /*\n    Add server status variables to the dynamic list of\n    status variables that is shown by SHOW STATUS.\n    Later, in plugin_init, and mysql_install_plugin\n    new entries could be added to that list.\n  */\n  if (add_status_vars(status_vars))\n    exit(1); // an error was already reported\n\n#ifndef DBUG_OFF\n  /*\n    We have few debug-only commands in com_status_vars, only visible in debug\n    builds. for simplicity we enable the assert only in debug builds\n\n    There are 10 Com_ variables which don't have corresponding SQLCOM_ values:\n    (TODO strictly speaking they shouldn't be here, should not have Com_ prefix\n    that is. Perhaps Stmt_ ? Comstmt_ ? Prepstmt_ ?)\n\n      Com_admin_commands         => com_other\n      Com_create_temporary_table => com_create_tmp_table\n      Com_drop_temporary_table   => com_drop_tmp_table\n      Com_stmt_close             => com_stmt_close\n      Com_stmt_execute           => com_stmt_execute\n      Com_stmt_fetch             => com_stmt_fetch\n      Com_stmt_prepare           => com_stmt_prepare\n      Com_stmt_reprepare         => com_stmt_reprepare\n      Com_stmt_reset             => com_stmt_reset\n      Com_stmt_send_long_data    => com_stmt_send_long_data\n\n    With this correction the number of Com_ variables (number of elements in\n    the array, excluding the last element - terminator) must match the number\n    of SQLCOM_ constants.\n  */\n  compile_time_assert(sizeof(com_status_vars)/sizeof(com_status_vars[0]) - 1 ==\n                     SQLCOM_END + 11);\n#endif\n\n  if (get_options(&remaining_argc, &remaining_argv))\n    exit(1);\n  if (IS_SYSVAR_AUTOSIZE(&server_version_ptr))\n    set_server_version(server_version, sizeof(server_version));\n\n  mysql_real_data_home_len= uint(strlen(mysql_real_data_home));\n\n  if (!opt_abort)\n  {\n    if (IS_SYSVAR_AUTOSIZE(&server_version_ptr))\n      sql_print_information(\"%s (mysqld %s) starting as process %lu ...\",\n                            my_progname, server_version, (ulong) getpid());\n    else\n    {\n      char real_server_version[SERVER_VERSION_LENGTH];\n      set_server_version(real_server_version, sizeof(real_server_version));\n      sql_print_information(\"%s (mysqld %s as %s) starting as process %lu ...\",\n                            my_progname, real_server_version, server_version,\n                            (ulong) getpid());\n    }\n  }\n\n  sf_leaking_memory= 0; // no memory leaks from now on\n\n#ifndef EMBEDDED_LIBRARY\n  if (opt_abort && !opt_verbose)\n    unireg_abort(0);\n#endif /*!EMBEDDED_LIBRARY*/\n\n  DBUG_PRINT(\"info\",(\"%s  Ver %s for %s on %s\\n\",my_progname,\n\t\t     server_version, SYSTEM_TYPE,MACHINE_TYPE));\n\n#ifdef HAVE_LINUX_LARGE_PAGES\n  /* Initialize large page size */\n  if (opt_large_pages)\n  {\n    SYSVAR_AUTOSIZE(opt_large_page_size, my_get_large_page_size());\n    if (opt_large_page_size)\n    {\n      DBUG_PRINT(\"info\", (\"Large page set, large_page_size = %d\",\n                 opt_large_page_size));\n      my_use_large_pages= 1;\n      my_large_page_size= opt_large_page_size;\n    }\n    else\n      SYSVAR_AUTOSIZE(opt_large_pages, 0);\n  }\n#endif /* HAVE_LINUX_LARGE_PAGES */\n#ifdef HAVE_SOLARIS_LARGE_PAGES\n#define LARGE_PAGESIZE (4*1024*1024)  /* 4MB */\n#define SUPER_LARGE_PAGESIZE (256*1024*1024)  /* 256MB */\n  if (opt_large_pages)\n  {\n  /*\n    tell the kernel that we want to use 4/256MB page for heap storage\n    and also for the stack. We use 4 MByte as default and if the\n    super-large-page is set we increase it to 256 MByte. 256 MByte\n    is for server installations with GBytes of RAM memory where\n    the MySQL Server will have page caches and other memory regions\n    measured in a number of GBytes.\n    We use as big pages as possible which isn't bigger than the above\n    desired page sizes.\n  */\n   int nelem;\n   size_t max_desired_page_size;\n   if (opt_super_large_pages)\n     max_desired_page_size= SUPER_LARGE_PAGESIZE;\n   else\n     max_desired_page_size= LARGE_PAGESIZE;\n   nelem = getpagesizes(NULL, 0);\n   if (nelem > 0)\n   {\n     size_t *pagesize = (size_t *) malloc(sizeof(size_t) * nelem);\n     if (pagesize != NULL && getpagesizes(pagesize, nelem) > 0)\n     {\n       size_t max_page_size= 0;\n       for (int i= 0; i < nelem; i++)\n       {\n         if (pagesize[i] > max_page_size &&\n             pagesize[i] <= max_desired_page_size)\n            max_page_size= pagesize[i];\n       }\n       free(pagesize);\n       if (max_page_size > 0)\n       {\n         struct memcntl_mha mpss;\n\n         mpss.mha_cmd= MHA_MAPSIZE_BSSBRK;\n         mpss.mha_pagesize= max_page_size;\n         mpss.mha_flags= 0;\n         memcntl(NULL, 0, MC_HAT_ADVISE, (caddr_t)&mpss, 0, 0);\n         mpss.mha_cmd= MHA_MAPSIZE_STACK;\n         memcntl(NULL, 0, MC_HAT_ADVISE, (caddr_t)&mpss, 0, 0);\n       }\n     }\n   }\n  }\n#endif /* HAVE_SOLARIS_LARGE_PAGES */\n\n\n#if defined(HAVE_POOL_OF_THREADS)\n  if (IS_SYSVAR_AUTOSIZE(&threadpool_size))\n    SYSVAR_AUTOSIZE(threadpool_size, my_getncpus());\n#endif\n\n  /* connections and databases needs lots of files */\n  {\n    uint files, wanted_files, max_open_files, min_tc_size, extra_files,\n      min_connections;\n    ulong org_max_connections, org_tc_size;\n\n    /* Number of files reserved for temporary files */\n    extra_files= 30;\n    min_connections= 10;\n    /* MyISAM requires two file handles per table. */\n    wanted_files= (extra_files + max_connections + extra_max_connections +\n                   tc_size * 2);\n#if defined(HAVE_POOL_OF_THREADS) && !defined(__WIN__)\n    // add epoll or kevent fd for each threadpool group, in case pool of threads is used\n    wanted_files+= (thread_handling > SCHEDULER_NO_THREADS) ? 0 : threadpool_size;\n#endif\n\n    min_tc_size= MY_MIN(tc_size, TABLE_OPEN_CACHE_MIN);\n    org_max_connections= max_connections;\n    org_tc_size= tc_size;\n\n    /*\n      We are trying to allocate no less than max_connections*5 file\n      handles (i.e. we are trying to set the limit so that they will\n      be available).  In addition, we allocate no less than how much\n      was already allocated.  However below we report a warning and\n      recompute values only if we got less file handles than were\n      explicitly requested.  No warning and re-computation occur if we\n      can't get max_connections*5 but still got no less than was\n      requested (value of wanted_files).\n    */\n    max_open_files= MY_MAX(MY_MAX(wanted_files,\n                                  (max_connections + extra_max_connections)*5),\n                           open_files_limit);\n    files= my_set_max_open_files(max_open_files);\n    SYSVAR_AUTOSIZE_IF_CHANGED(open_files_limit, files, ulong);\n\n    if (files < wanted_files && global_system_variables.log_warnings)\n      sql_print_warning(\"Could not increase number of max_open_files to more than %u (request: %u)\", files, wanted_files);\n\n    /*\n      If we have requested too much file handles than we bring\n      max_connections in supported bounds. Still leave at least\n      'min_connections' connections\n    */\n    SYSVAR_AUTOSIZE_IF_CHANGED(max_connections,\n                               (ulong) MY_MAX(MY_MIN(files- extra_files-\n                                                     min_tc_size*2,\n                                                     max_connections),\n                                              min_connections),\n                               ulong);\n\n    /*\n      Decrease tc_size according to max_connections, but\n      not below min_tc_size.  Outer MY_MIN() ensures that we\n      never increase tc_size automatically (that could\n      happen if max_connections is decreased above).\n    */\n    SYSVAR_AUTOSIZE_IF_CHANGED(tc_size,\n                               (ulong) MY_MIN(MY_MAX((files - extra_files -\n                                                      max_connections) / 2,\n                                                     min_tc_size),\n                                              tc_size), ulong);\n    DBUG_PRINT(\"warning\",\n               (\"Current limits: max_open_files: %u  max_connections: %ld  table_cache: %ld\",\n                files, max_connections, tc_size));\n    if (global_system_variables.log_warnings > 1 &&\n        (max_connections < org_max_connections ||\n         tc_size < org_tc_size))\n      sql_print_warning(\"Changed limits: max_open_files: %u  max_connections: %lu (was %lu)  table_cache: %lu (was %lu)\",\n\t\t\tfiles, max_connections, org_max_connections,\n                        tc_size, org_tc_size);\n  }\n  /*\n    Max_connections and tc_cache are now set.\n    Now we can fix other variables depending on this variable.\n  */\n\n  /* Fix host_cache_size */\n  if (IS_SYSVAR_AUTOSIZE(&host_cache_size))\n  {\n    /*\n      The default value is 128.\n      The autoset value is 128, plus 1 for a value of max_connections\n      up to 500, plus 1 for every increment of 20 over 500 in the\n      max_connections value, capped at 2000.\n    */\n    uint size= (HOST_CACHE_SIZE + MY_MIN(max_connections, 500) +\n                MY_MAX(((long) max_connections)-500,0)/20);\n    SYSVAR_AUTOSIZE(host_cache_size, size);\n  }\n\n  /* Fix back_log (back_log == 0 added for MySQL compatibility) */\n  if (back_log == 0 || IS_SYSVAR_AUTOSIZE(&back_log))\n  {\n    /*\n      The default value is 150.\n      The autoset value is 50 + max_connections / 5 capped at 900\n    */\n    SYSVAR_AUTOSIZE(back_log, MY_MIN(900, (50 + max_connections / 5)));\n  }\n\n  unireg_init(opt_specialflag); /* Set up extern variabels */\n  if (!(my_default_lc_messages=\n        my_locale_by_name(lc_messages)))\n  {\n    sql_print_error(\"Unknown locale: '%s'\", lc_messages);\n    return 1;\n  }\n\n  if (init_errmessage())\t/* Read error messages from file */\n    return 1;\n  global_system_variables.lc_messages= my_default_lc_messages;\n  global_system_variables.errmsgs= my_default_lc_messages->errmsgs->errmsgs;\n  init_client_errs();\n  mysql_library_init(unused,unused,unused); /* for replication */\n  lex_init();\n  if (item_create_init())\n    return 1;\n  item_init();\n  init_pcre();\n  /*\n    Process a comma-separated character set list and choose\n    the first available character set. This is mostly for\n    test purposes, to be able to start \"mysqld\" even if\n    the requested character set is not available (see bug#18743).\n  */\n  for (;;)\n  {\n    char *next_character_set_name= strchr(default_character_set_name, ',');\n    if (next_character_set_name)\n      *next_character_set_name++= '\\0';\n    if (!(default_charset_info=\n          get_charset_by_csname(default_character_set_name,\n                                MY_CS_PRIMARY, MYF(MY_WME))))\n    {\n      if (next_character_set_name)\n      {\n        default_character_set_name= next_character_set_name;\n        default_collation_name= 0;          // Ignore collation\n      }\n      else\n        return 1;                           // Eof of the list\n    }\n    else\n      break;\n  }\n\n  if (default_collation_name)\n  {\n    CHARSET_INFO *default_collation;\n    default_collation= get_charset_by_name(default_collation_name, MYF(0));\n    if (!default_collation)\n    {\n#ifdef WITH_PERFSCHEMA_STORAGE_ENGINE\n      buffered_logs.print();\n      buffered_logs.cleanup();\n#endif\n      sql_print_error(ER_DEFAULT(ER_UNKNOWN_COLLATION), default_collation_name);\n      return 1;\n    }\n    if (!my_charset_same(default_charset_info, default_collation))\n    {\n      sql_print_error(ER_DEFAULT(ER_COLLATION_CHARSET_MISMATCH),\n\t\t      default_collation_name,\n\t\t      default_charset_info->csname);\n      return 1;\n    }\n    default_charset_info= default_collation;\n  }\n  /* Set collactions that depends on the default collation */\n  global_system_variables.collation_server= default_charset_info;\n  global_system_variables.collation_database= default_charset_info;\n  if (is_supported_parser_charset(default_charset_info))\n  {\n    global_system_variables.collation_connection= default_charset_info;\n    global_system_variables.character_set_results= default_charset_info;\n    global_system_variables.character_set_client= default_charset_info;\n  }\n  else\n  {\n    sql_print_warning(\"'%s' can not be used as client character set. \"\n                      \"'%s' will be used as default client character set.\",\n                      default_charset_info->csname,\n                      my_charset_latin1.csname);\n    global_system_variables.collation_connection= &my_charset_latin1;\n    global_system_variables.character_set_results= &my_charset_latin1;\n    global_system_variables.character_set_client= &my_charset_latin1;\n  }\n\n  if (!(character_set_filesystem=\n        get_charset_by_csname(character_set_filesystem_name,\n                              MY_CS_PRIMARY, MYF(MY_WME))))\n    return 1;\n  global_system_variables.character_set_filesystem= character_set_filesystem;\n\n  if (!(my_default_lc_time_names=\n        my_locale_by_name(lc_time_names_name)))\n  {\n    sql_print_error(\"Unknown locale: '%s'\", lc_time_names_name);\n    return 1;\n  }\n  global_system_variables.lc_time_names= my_default_lc_time_names;\n\n  /* check log options and issue warnings if needed */\n  if (opt_log && opt_logname && *opt_logname &&\n      !(log_output_options & (LOG_FILE | LOG_NONE)))\n    sql_print_warning(\"Although a path was specified for the \"\n                      \"--log option, log tables are used. \"\n                      \"To enable logging to files use the --log-output option.\");\n\n  if (global_system_variables.sql_log_slow && opt_slow_logname &&\n      *opt_slow_logname &&\n      !(log_output_options & (LOG_FILE | LOG_NONE)))\n    sql_print_warning(\"Although a path was specified for the \"\n                      \"--log-slow-queries option, log tables are used. \"\n                      \"To enable logging to files use the --log-output=file option.\");\n\n  if (!opt_logname || !*opt_logname)\n    make_default_log_name(&opt_logname, \".log\", false);\n  if (!opt_slow_logname || !*opt_slow_logname)\n    make_default_log_name(&opt_slow_logname, \"-slow.log\", false);\n\n#if defined(ENABLED_DEBUG_SYNC)\n  /* Initialize the debug sync facility. See debug_sync.cc. */\n  if (debug_sync_init())\n    return 1; /* purecov: tested */\n#endif /* defined(ENABLED_DEBUG_SYNC) */\n\n#if (ENABLE_TEMP_POOL)\n  if (use_temp_pool && my_bitmap_init(&temp_pool,0,1024,1))\n    return 1;\n#else\n  use_temp_pool= 0;\n#endif\n\n  if (my_dboptions_cache_init())\n    return 1;\n\n  /*\n    Ensure that lower_case_table_names is set on system where we have case\n    insensitive names.  If this is not done the users MyISAM tables will\n    get corrupted if accesses with names of different case.\n  */\n  DBUG_PRINT(\"info\", (\"lower_case_table_names: %d\", lower_case_table_names));\n  SYSVAR_AUTOSIZE(lower_case_file_system,\n                  test_if_case_insensitive(mysql_real_data_home));\n  if (!lower_case_table_names && lower_case_file_system == 1)\n  {\n    if (lower_case_table_names_used)\n    {\n      sql_print_error(\"The server option 'lower_case_table_names' is \"\n                      \"configured to use case sensitive table names but the \"\n                      \"data directory resides on a case-insensitive file system. \"\n                      \"Please use a case sensitive file system for your data \"\n                      \"directory or switch to a case-insensitive table name \"\n                      \"mode.\");\n      return 1;\n    }\n    else\n    {\n      if (global_system_variables.log_warnings)\n\tsql_print_warning(\"Setting lower_case_table_names=2 because file \"\n                  \"system for %s is case insensitive\", mysql_real_data_home);\n      SYSVAR_AUTOSIZE(lower_case_table_names, 2);\n    }\n  }\n  else if (lower_case_table_names == 2 &&\n           !(lower_case_file_system= (lower_case_file_system == 1)))\n  {\n    if (global_system_variables.log_warnings)\n      sql_print_warning(\"lower_case_table_names was set to 2, even though your \"\n                        \"the file system '%s' is case sensitive.  Now setting \"\n                        \"lower_case_table_names to 0 to avoid future problems.\",\n\t\t\tmysql_real_data_home);\n    SYSVAR_AUTOSIZE(lower_case_table_names, 0);\n  }\n  else\n  {\n    lower_case_file_system= (lower_case_file_system == 1);\n  }\n\n  /* Reset table_alias_charset, now that lower_case_table_names is set. */\n  table_alias_charset= (lower_case_table_names ?\n\t\t\tfiles_charset_info :\n\t\t\t&my_charset_bin);\n\n  if (ignore_db_dirs_process_additions())\n  {\n    sql_print_error(\"An error occurred while storing ignore_db_dirs to a hash.\");\n    return 1;\n  }\n\n\n#ifdef WITH_WSREP\n  /*\n    We need to initialize auxiliary variables, that will be\n    further keep the original values of auto-increment options\n    as they set by the user. These variables used to restore\n    user-defined values of the auto-increment options after\n    setting of the wsrep_auto_increment_control to 'OFF'.\n  */\n  global_system_variables.saved_auto_increment_increment=\n    global_system_variables.auto_increment_increment;\n  global_system_variables.saved_auto_increment_offset=\n    global_system_variables.auto_increment_offset;\n#endif /* WITH_WSREP */\n\n  return 0;\n}\n\n\nstatic int init_thread_environment()\n{\n  DBUG_ENTER(\"init_thread_environment\");\n  server_threads.init();\n  mysql_mutex_init(key_LOCK_thread_cache, &LOCK_thread_cache, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_start_thread, &LOCK_start_thread, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_status, &LOCK_status, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_delayed_insert,\n                   &LOCK_delayed_insert, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_delayed_status,\n                   &LOCK_delayed_status, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_delayed_create,\n                   &LOCK_delayed_create, MY_MUTEX_INIT_SLOW);\n  mysql_mutex_init(key_LOCK_crypt, &LOCK_crypt, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_user_conn, &LOCK_user_conn, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_active_mi, &LOCK_active_mi, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_global_system_variables,\n                   &LOCK_global_system_variables, MY_MUTEX_INIT_FAST);\n  mysql_mutex_record_order(&LOCK_active_mi, &LOCK_global_system_variables);\n  mysql_prlock_init(key_rwlock_LOCK_system_variables_hash,\n                    &LOCK_system_variables_hash);\n  mysql_mutex_init(key_LOCK_prepared_stmt_count,\n                   &LOCK_prepared_stmt_count, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_error_messages,\n                   &LOCK_error_messages, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_uuid_short_generator,\n                   &LOCK_short_uuid_generator, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_connection_count,\n                   &LOCK_connection_count, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_thread_id,\n                   &LOCK_thread_id, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_stats, &LOCK_stats, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_global_user_client_stats,\n                   &LOCK_global_user_client_stats, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_global_table_stats,\n                   &LOCK_global_table_stats, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_global_index_stats,\n                   &LOCK_global_index_stats, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_prepare_ordered, &LOCK_prepare_ordered,\n                   MY_MUTEX_INIT_SLOW);\n  mysql_cond_init(key_COND_prepare_ordered, &COND_prepare_ordered, NULL);\n  mysql_mutex_init(key_LOCK_after_binlog_sync, &LOCK_after_binlog_sync,\n                   MY_MUTEX_INIT_SLOW);\n  mysql_mutex_init(key_LOCK_commit_ordered, &LOCK_commit_ordered,\n                   MY_MUTEX_INIT_SLOW);\n  mysql_mutex_init(key_LOCK_slave_background, &LOCK_slave_background,\n                   MY_MUTEX_INIT_SLOW);\n  mysql_cond_init(key_COND_slave_background, &COND_slave_background, NULL);\n\n#ifdef HAVE_OPENSSL\n  mysql_mutex_init(key_LOCK_des_key_file,\n                   &LOCK_des_key_file, MY_MUTEX_INIT_FAST);\n#if defined(HAVE_OPENSSL10) && !defined(HAVE_WOLFSSL)\n  openssl_stdlocks= (openssl_lock_t*) OPENSSL_malloc(CRYPTO_num_locks() *\n                                                     sizeof(openssl_lock_t));\n  for (int i= 0; i < CRYPTO_num_locks(); ++i)\n    mysql_rwlock_init(key_rwlock_openssl, &openssl_stdlocks[i].lock);\n  CRYPTO_set_dynlock_create_callback(openssl_dynlock_create);\n  CRYPTO_set_dynlock_destroy_callback(openssl_dynlock_destroy);\n  CRYPTO_set_dynlock_lock_callback(openssl_lock);\n  CRYPTO_set_locking_callback(openssl_lock_function);\n#endif /* HAVE_OPENSSL10 */\n#endif /* HAVE_OPENSSL */\n  mysql_rwlock_init(key_rwlock_LOCK_sys_init_connect, &LOCK_sys_init_connect);\n  mysql_rwlock_init(key_rwlock_LOCK_sys_init_slave, &LOCK_sys_init_slave);\n  mysql_rwlock_init(key_rwlock_LOCK_ssl_refresh, &LOCK_ssl_refresh);\n  mysql_rwlock_init(key_rwlock_LOCK_grant, &LOCK_grant);\n  mysql_rwlock_init(key_rwlock_LOCK_all_status_vars, &LOCK_all_status_vars);\n  mysql_cond_init(key_COND_thread_cache, &COND_thread_cache, NULL);\n  mysql_cond_init(key_COND_start_thread, &COND_start_thread, NULL);\n  mysql_cond_init(key_COND_flush_thread_cache, &COND_flush_thread_cache, NULL);\n#ifdef HAVE_REPLICATION\n  mysql_mutex_init(key_LOCK_rpl_status, &LOCK_rpl_status, MY_MUTEX_INIT_FAST);\n#endif\n  mysql_mutex_init(key_LOCK_server_started,\n                   &LOCK_server_started, MY_MUTEX_INIT_FAST);\n  mysql_cond_init(key_COND_server_started, &COND_server_started, NULL);\n  sp_cache_init();\n#ifdef HAVE_EVENT_SCHEDULER\n  Events::init_mutexes();\n#endif\n  init_show_explain_psi_keys();\n  /* Parameter for threads created for connections */\n  (void) pthread_attr_init(&connection_attrib);\n  (void) pthread_attr_setdetachstate(&connection_attrib,\n\t\t\t\t     PTHREAD_CREATE_DETACHED);\n  pthread_attr_setscope(&connection_attrib, PTHREAD_SCOPE_SYSTEM);\n\n#ifdef HAVE_REPLICATION\n  rpl_init_gtid_slave_state();\n  rpl_init_gtid_waiting();\n#endif\n\n  DBUG_RETURN(0);\n}\n\n\n#if defined(HAVE_OPENSSL10) && !defined(HAVE_WOLFSSL)\nstatic openssl_lock_t *openssl_dynlock_create(const char *file, int line)\n{\n  openssl_lock_t *lock= new openssl_lock_t;\n  mysql_rwlock_init(key_rwlock_openssl, &lock->lock);\n  return lock;\n}\n\n\nstatic void openssl_dynlock_destroy(openssl_lock_t *lock, const char *file,\n\t\t\t\t    int line)\n{\n  mysql_rwlock_destroy(&lock->lock);\n  delete lock;\n}\n\n\nstatic void openssl_lock_function(int mode, int n, const char *file, int line)\n{\n  if (n < 0 || n > CRYPTO_num_locks())\n  {\n    /* Lock number out of bounds. */\n    sql_print_error(\"Fatal: OpenSSL interface problem (n = %d)\", n);\n    abort();\n  }\n  openssl_lock(mode, &openssl_stdlocks[n], file, line);\n}\n\n\nstatic void openssl_lock(int mode, openssl_lock_t *lock, const char *file,\n\t\t\t int line)\n{\n  int err;\n  char const *what;\n\n  switch (mode) {\n  case CRYPTO_LOCK|CRYPTO_READ:\n    what = \"read lock\";\n    err= mysql_rwlock_rdlock(&lock->lock);\n    break;\n  case CRYPTO_LOCK|CRYPTO_WRITE:\n    what = \"write lock\";\n    err= mysql_rwlock_wrlock(&lock->lock);\n    break;\n  case CRYPTO_UNLOCK|CRYPTO_READ:\n  case CRYPTO_UNLOCK|CRYPTO_WRITE:\n    what = \"unlock\";\n    err= mysql_rwlock_unlock(&lock->lock);\n    break;\n  default:\n    /* Unknown locking mode. */\n    sql_print_error(\"Fatal: OpenSSL interface problem (mode=0x%x)\", mode);\n    abort();\n  }\n  if (err)\n  {\n    sql_print_error(\"Fatal: can't %s OpenSSL lock\", what);\n    abort();\n  }\n}\n#endif /* HAVE_OPENSSL10 */\n\n\nstruct SSL_ACCEPTOR_STATS\n{\n  long accept;\n  long accept_good;\n  long cache_size;\n  long verify_mode;\n  long verify_depth;\n  long zero;\n  const char *session_cache_mode;\n\n  SSL_ACCEPTOR_STATS():\n    accept(),accept_good(),cache_size(),verify_mode(),verify_depth(),zero(),\n    session_cache_mode(\"NONE\")\n  {\n  }\n\n  void init()\n  {\n    DBUG_ASSERT(ssl_acceptor_fd !=0 && ssl_acceptor_fd->ssl_context != 0);\n    SSL_CTX *ctx= ssl_acceptor_fd->ssl_context;\n    accept= 0;\n    accept_good= 0;\n    verify_mode= SSL_CTX_get_verify_mode(ctx);\n    verify_depth= SSL_CTX_get_verify_depth(ctx);\n    cache_size= SSL_CTX_sess_get_cache_size(ctx);\n    switch (SSL_CTX_get_session_cache_mode(ctx))\n    {\n    case SSL_SESS_CACHE_OFF:\n      session_cache_mode= \"OFF\"; break;\n    case SSL_SESS_CACHE_CLIENT:\n      session_cache_mode= \"CLIENT\"; break;\n    case SSL_SESS_CACHE_SERVER:\n      session_cache_mode= \"SERVER\"; break;\n    case SSL_SESS_CACHE_BOTH:\n      session_cache_mode= \"BOTH\"; break;\n    case SSL_SESS_CACHE_NO_AUTO_CLEAR:\n      session_cache_mode= \"NO_AUTO_CLEAR\"; break;\n    case SSL_SESS_CACHE_NO_INTERNAL_LOOKUP:\n      session_cache_mode= \"NO_INTERNAL_LOOKUP\"; break;\n    default:\n      session_cache_mode= \"Unknown\"; break;\n    }\n  }\n};\n\nstatic SSL_ACCEPTOR_STATS ssl_acceptor_stats;\nvoid ssl_acceptor_stats_update(int sslaccept_ret)\n{\n  statistic_increment(ssl_acceptor_stats.accept, &LOCK_status);\n  if (!sslaccept_ret)\n    statistic_increment(ssl_acceptor_stats.accept_good,&LOCK_status);\n}\n\nstatic void init_ssl()\n{\n#if defined(HAVE_OPENSSL) && !defined(EMBEDDED_LIBRARY)\n  if (opt_use_ssl)\n  {\n    enum enum_ssl_init_error error= SSL_INITERR_NOERROR;\n\n    /* having ssl_acceptor_fd != 0 signals the use of SSL */\n    ssl_acceptor_fd= new_VioSSLAcceptorFd(opt_ssl_key, opt_ssl_cert,\n\t\t\t\t\t  opt_ssl_ca, opt_ssl_capath,\n\t\t\t\t\t  opt_ssl_cipher, &error,\n\t\t\t\t\t  opt_ssl_crl, opt_ssl_crlpath,\n\t\t\t\t\t  tls_version);\n    DBUG_PRINT(\"info\",(\"ssl_acceptor_fd: %p\", ssl_acceptor_fd));\n    if (!ssl_acceptor_fd)\n    {\n      sql_print_warning(\"Failed to setup SSL\");\n      sql_print_warning(\"SSL error: %s\", sslGetErrString(error));\n      opt_use_ssl = 0;\n      have_ssl= SHOW_OPTION_DISABLED;\n    }\n    else\n      ssl_acceptor_stats.init();\n\n    if (global_system_variables.log_warnings > 0)\n    {\n      ulong err;\n      while ((err= ERR_get_error()))\n        sql_print_warning(\"SSL error: %s\", ERR_error_string(err, NULL));\n    }\n    else\n      ERR_remove_state(0);\n  }\n  else\n  {\n    have_ssl= SHOW_OPTION_DISABLED;\n  }\n  if (des_key_file)\n    load_des_key_file(des_key_file);\n#endif /* HAVE_OPENSSL && ! EMBEDDED_LIBRARY */\n}\n\n/* Reinitialize SSL (FLUSH SSL) */\nint reinit_ssl()\n{\n#if defined(HAVE_OPENSSL) && !defined(EMBEDDED_LIBRARY)\n  if (!opt_use_ssl)\n    return 0;\n\n  enum enum_ssl_init_error error = SSL_INITERR_NOERROR;\n  st_VioSSLFd *new_fd = new_VioSSLAcceptorFd(opt_ssl_key, opt_ssl_cert,\n    opt_ssl_ca, opt_ssl_capath, opt_ssl_cipher, &error, opt_ssl_crl,\n    opt_ssl_crlpath, tls_version);\n\n  if (!new_fd)\n  {\n    my_printf_error(ER_UNKNOWN_ERROR, \"Failed to refresh SSL, error: %s\", MYF(0),\n      sslGetErrString(error));\n    ERR_clear_error();\n    return 1;\n  }\n  mysql_rwlock_wrlock(&LOCK_ssl_refresh);\n  free_vio_ssl_acceptor_fd(ssl_acceptor_fd);\n  ssl_acceptor_fd= new_fd;\n  ssl_acceptor_stats.init();\n  mysql_rwlock_unlock(&LOCK_ssl_refresh);\n#endif\n  return 0;\n}\n\nstatic void end_ssl()\n{\n#ifdef HAVE_OPENSSL\n#ifndef EMBEDDED_LIBRARY\n  if (ssl_acceptor_fd)\n  {\n    free_vio_ssl_acceptor_fd(ssl_acceptor_fd);\n    ssl_acceptor_fd= 0;\n  }\n#endif /* ! EMBEDDED_LIBRARY */\n#endif /* HAVE_OPENSSL */\n}\n\n#ifdef _WIN32\n/**\n  Registers a file to be collected when Windows Error Reporting creates a crash \n  report.\n*/\n#include <werapi.h>\nstatic void add_file_to_crash_report(char *file)\n{\n  wchar_t wfile[MAX_PATH+1]= {0};\n  if (mbstowcs(wfile, file, MAX_PATH) != (size_t)-1)\n  {\n    WerRegisterFile(wfile, WerRegFileTypeOther, WER_FILE_ANONYMOUS_DATA);\n  }\n}\n#endif\n\n#define init_default_storage_engine(X,Y) \\\n  init_default_storage_engine_impl(#X, X, &global_system_variables.Y)\n\nstatic int init_default_storage_engine_impl(const char *opt_name,\n                                            char *engine_name, plugin_ref *res)\n{\n  if (!engine_name)\n  {\n    *res= 0;\n    return 0;\n  }\n\n  LEX_CSTRING name= { engine_name, strlen(engine_name) };\n  plugin_ref plugin;\n  handlerton *hton;\n  if ((plugin= ha_resolve_by_name(0, &name, false)))\n    hton= plugin_hton(plugin);\n  else\n  {\n    sql_print_error(\"Unknown/unsupported storage engine: %s\", engine_name);\n    return 1;\n  }\n  if (!ha_storage_engine_is_enabled(hton))\n  {\n    if (!opt_bootstrap)\n    {\n      sql_print_error(\"%s (%s) is not available\", opt_name, engine_name);\n      return 1;\n    }\n    DBUG_ASSERT(*res);\n  }\n  else\n  {\n    /*\n      Need to unlock as global_system_variables.table_plugin\n      was acquired during plugin_init()\n    */\n    mysql_mutex_lock(&LOCK_global_system_variables);\n    if (*res)\n      plugin_unlock(0, *res);\n    *res= plugin;\n    mysql_mutex_unlock(&LOCK_global_system_variables);\n  }\n  return 0;\n}\n\n\nstatic int\ninit_gtid_pos_auto_engines(void)\n{\n  plugin_ref *plugins;\n\n  /*\n    For the command-line option --gtid_pos_auto_engines, we allow (and ignore)\n    engines that are unknown. This is convenient, since it allows to set\n    default auto-create engines that might not be used by particular users.\n    The option sets a list of storage engines that will have gtid position\n    table auto-created for them if needed. And if the engine is not available,\n    then it will certainly not be needed.\n  */\n  if (gtid_pos_auto_engines)\n    plugins= resolve_engine_list(NULL, gtid_pos_auto_engines,\n                                 strlen(gtid_pos_auto_engines), false, false);\n  else\n    plugins= resolve_engine_list(NULL, \"\", 0, false, false);\n  if (!plugins)\n    return 1;\n  mysql_mutex_lock(&LOCK_global_system_variables);\n  opt_gtid_pos_auto_plugins= plugins;\n  mysql_mutex_unlock(&LOCK_global_system_variables);\n  return 0;\n}\n\n\nstatic int init_server_components()\n{\n  DBUG_ENTER(\"init_server_components\");\n  /*\n    We need to call each of these following functions to ensure that\n    all things are initialized so that unireg_abort() doesn't fail\n  */\n  my_cpu_init();\n  mdl_init();\n  if (tdc_init() || hostname_cache_init())\n    unireg_abort(1);\n\n  query_cache_set_min_res_unit(query_cache_min_res_unit);\n  query_cache_result_size_limit(query_cache_limit);\n  /* if we set size of QC non zero in config then probably we want it ON */\n  if (query_cache_size != 0 &&\n      global_system_variables.query_cache_type == 0 &&\n      !IS_SYSVAR_AUTOSIZE(&query_cache_size))\n  {\n    global_system_variables.query_cache_type= 1;\n  }\n  query_cache_init();\n  DBUG_ASSERT(query_cache_size < ULONG_MAX);\n  query_cache_resize((ulong)query_cache_size);\n  my_rnd_init(&sql_rand,(ulong) server_start_time,(ulong) server_start_time/2);\n  setup_fpu();\n  init_thr_lock();\n  backup_init();\n\n#ifndef EMBEDDED_LIBRARY\n  if (init_thr_timer(thread_scheduler->max_threads + extra_max_connections))\n  {\n    fprintf(stderr, \"Can't initialize timers\\n\");\n    unireg_abort(1);\n  }\n#endif\n\n  my_uuid_init((ulong) (my_rnd(&sql_rand))*12345,12345);\n  wt_init();\n\n  /* Setup logs */\n\n  setup_log_handling();\n\n  /*\n    Enable old-fashioned error log, except when the user has requested\n    help information. Since the implementation of plugin server\n    variables the help output is now written much later.\n  */\n#ifdef _WIN32\n  if (opt_console)\n   opt_error_log= false;\n#endif\n\n  if (opt_error_log && !opt_abort)\n  {\n    if (!log_error_file_ptr[0])\n    {\n      fn_format(log_error_file, pidfile_name, mysql_data_home, \".err\",\n                MY_REPLACE_EXT); /* replace '.<domain>' by '.err', bug#4997 */\n      SYSVAR_AUTOSIZE(log_error_file_ptr, log_error_file);\n    }\n    else\n    {\n      fn_format(log_error_file, log_error_file_ptr, mysql_data_home, \".err\",\n                MY_UNPACK_FILENAME | MY_SAFE_PATH);\n      log_error_file_ptr= log_error_file;\n    }\n    if (!log_error_file[0])\n      opt_error_log= 0;                         // Too long file name\n    else\n    {\n      my_bool res;\n#ifndef EMBEDDED_LIBRARY\n      res= reopen_fstreams(log_error_file, stdout, stderr);\n#else\n      res= reopen_fstreams(log_error_file, NULL, stderr);\n#endif\n\n      if (!res)\n        setbuf(stderr, NULL);\n\n#ifdef _WIN32\n      /* Add error log to windows crash reporting. */\n      add_file_to_crash_report(log_error_file);\n#endif\n    }\n  }\n\n  /* set up the hook before initializing plugins which may use it */\n  error_handler_hook= my_message_sql;\n  proc_info_hook= set_thd_stage_info;\n\n#ifdef WITH_PERFSCHEMA_STORAGE_ENGINE\n  /*\n    Parsing the performance schema command line option may have reported\n    warnings/information messages.\n    Now that the logger is finally available, and redirected\n    to the proper file when the --log--error option is used,\n    print the buffered messages to the log.\n  */\n  buffered_logs.print();\n  buffered_logs.cleanup();\n#endif /* WITH_PERFSCHEMA_STORAGE_ENGINE */\n\n#ifndef EMBEDDED_LIBRARY\n  /*\n    Now that the logger is available, redirect character set\n    errors directly to the logger\n    (instead of the buffered_logs used at the server startup time).\n  */\n  my_charset_error_reporter= charset_error_reporter;\n#endif\n\n  xid_cache_init();\n\n  /* need to configure logging before initializing storage engines */\n  if (!opt_bin_log_used && !WSREP_ON)\n  {\n    if (opt_log_slave_updates)\n      sql_print_warning(\"You need to use --log-bin to make \"\n                        \"--log-slave-updates work.\");\n    if (binlog_format_used)\n      sql_print_warning(\"You need to use --log-bin to make \"\n                        \"--binlog-format work.\");\n  }\n\n  /* Check that we have not let the format to unspecified at this point */\n  DBUG_ASSERT((uint)global_system_variables.binlog_format <=\n              array_elements(binlog_format_names)-1);\n\n#ifdef HAVE_REPLICATION\n  if (opt_log_slave_updates && replicate_same_server_id)\n  {\n    if (opt_bin_log)\n    {\n      sql_print_error(\"using --replicate-same-server-id in conjunction with \"\n                      \"--log-slave-updates is impossible, it would lead to \"\n                      \"infinite loops in this server.\");\n      unireg_abort(1);\n    }\n    else\n      sql_print_warning(\"using --replicate-same-server-id in conjunction with \"\n                        \"--log-slave-updates would lead to infinite loops in \"\n                        \"this server. However this will be ignored as the \"\n                        \"--log-bin option is not defined.\");\n  }\n#endif\n\n  if (opt_bin_log)\n  {\n    /* Reports an error and aborts, if the --log-bin's path \n       is a directory.*/\n    if (opt_bin_logname[0] && \n        opt_bin_logname[strlen(opt_bin_logname) - 1] == FN_LIBCHAR)\n    {\n      sql_print_error(\"Path '%s' is a directory name, please specify \"\n                      \"a file name for --log-bin option\", opt_bin_logname);\n      unireg_abort(1);\n    }\n\n    /* Reports an error and aborts, if the --log-bin-index's path \n       is a directory.*/\n    if (opt_binlog_index_name && \n        opt_binlog_index_name[strlen(opt_binlog_index_name) - 1] \n        == FN_LIBCHAR)\n    {\n      sql_print_error(\"Path '%s' is a directory name, please specify \"\n                      \"a file name for --log-bin-index option\",\n                      opt_binlog_index_name);\n      unireg_abort(1);\n    }\n\n    char buf[FN_REFLEN];\n    const char *ln;\n    ln= mysql_bin_log.generate_name(opt_bin_logname, \"-bin\", 1, buf);\n    if (!opt_bin_logname[0] && !opt_binlog_index_name)\n    {\n      /*\n        User didn't give us info to name the binlog index file.\n        Picking `hostname`-bin.index like did in 4.x, causes replication to\n        fail if the hostname is changed later. So, we would like to instead\n        require a name. But as we don't want to break many existing setups, we\n        only give warning, not error.\n      */\n      sql_print_warning(\"No argument was provided to --log-bin and \"\n                        \"neither --log-basename or --log-bin-index where \"\n                        \"used;  This may cause repliction to break when this \"\n                        \"server acts as a master and has its hostname \"\n                        \"changed! Please use '--log-basename=%s' or \"\n                        \"'--log-bin=%s' to avoid this problem.\",\n                        opt_log_basename, ln);\n    }\n    if (ln == buf)\n      opt_bin_logname= my_once_strdup(buf, MYF(MY_WME));\n  }\n\n  /*\n    Since some wsrep threads (THDs) are create before plugins are\n    initialized, LOCK_plugin mutex needs to be initialized here.\n  */\n  plugin_mutex_init();\n\n  /*\n    Wsrep initialization must happen at this point, because:\n    - opt_bin_logname must be known when starting replication\n      since SST may need it\n    - SST may modify binlog index file, so it must be opened\n      after SST has happened\n\n    We also (unconditionally) initialize wsrep LOCKs and CONDs.\n    It is because they are used while accessing wsrep system\n    variables even when a wsrep provider is not loaded.\n  */\n\n  /* It's now safe to use thread specific memory */\n  mysqld_server_initialized= 1;\n\n#ifndef EMBEDDED_LIBRARY\n  wsrep_thr_init();\n#endif\n\n#ifdef WITH_WSREP\n  if (wsrep_init_server()) unireg_abort(1);\n\n  if (WSREP_ON && !wsrep_recovery && !opt_abort)\n  {\n    if (opt_bootstrap) // bootsrap option given - disable wsrep functionality\n    {\n      wsrep_provider_init(WSREP_NONE);\n      if (wsrep_init())\n        unireg_abort(1);\n    }\n    else // full wsrep initialization\n    {\n      // add basedir/bin to PATH to resolve wsrep script names\n      char* const tmp_path= (char*)my_alloca(strlen(mysql_home) +\n                                             strlen(\"/bin\") + 1);\n      if (tmp_path)\n      {\n        strcpy(tmp_path, mysql_home);\n        strcat(tmp_path, \"/bin\");\n        wsrep_prepend_PATH(tmp_path);\n      }\n      else\n      {\n        WSREP_ERROR(\"Could not append %s/bin to PATH\", mysql_home);\n      }\n      my_afree(tmp_path);\n\n      if (wsrep_before_SE())\n      {\n        set_ports(); // this is also called in network_init() later but we need\n                     // to know mysqld_port now - lp:1071882\n        wsrep_init_startup(true);\n      }\n    }\n  }\n#endif /* WITH_WSREP */\n\n  if (opt_bin_log)\n  {\n    if (mysql_bin_log.open_index_file(opt_binlog_index_name, opt_bin_logname,\n                                      TRUE))\n    {\n      unireg_abort(1);\n    }\n\n    log_bin_basename=\n      rpl_make_log_name(opt_bin_logname, pidfile_name,\n                        opt_bin_logname ? \"\" : \"-bin\");\n    log_bin_index=\n      rpl_make_log_name(opt_binlog_index_name, log_bin_basename, \".index\");\n    if (log_bin_basename == NULL || log_bin_index == NULL)\n    {\n      sql_print_error(\"Unable to create replication path names:\"\n                      \" out of memory or path names too long\"\n                      \" (path name exceeds \" STRINGIFY_ARG(FN_REFLEN)\n                      \" or file name exceeds \" STRINGIFY_ARG(FN_LEN) \").\");\n      unireg_abort(1);\n    }\n  }\n\n#ifndef EMBEDDED_LIBRARY\n  DBUG_PRINT(\"debug\",\n             (\"opt_bin_logname: %s, opt_relay_logname: %s, pidfile_name: %s\",\n              opt_bin_logname, opt_relay_logname, pidfile_name));\n  if (opt_relay_logname)\n  {\n    relay_log_basename=\n      rpl_make_log_name(opt_relay_logname, pidfile_name,\n                        opt_relay_logname ? \"\" : \"-relay-bin\");\n    relay_log_index=\n      rpl_make_log_name(opt_relaylog_index_name, relay_log_basename, \".index\");\n    if (relay_log_basename == NULL || relay_log_index == NULL)\n    {\n      sql_print_error(\"Unable to create replication path names:\"\n                      \" out of memory or path names too long\"\n                      \" (path name exceeds \" STRINGIFY_ARG(FN_REFLEN)\n                      \" or file name exceeds \" STRINGIFY_ARG(FN_LEN) \").\");\n      unireg_abort(1);\n    }\n  }\n#endif /* !EMBEDDED_LIBRARY */\n\n  /* call ha_init_key_cache() on all key caches to init them */\n  process_key_caches(&ha_init_key_cache, 0);\n\n  init_global_table_stats();\n  init_global_index_stats();\n\n  /* Allow storage engine to give real error messages */\n  if (unlikely(ha_init_errors()))\n    DBUG_RETURN(1);\n\n  tc_log= 0; // ha_initialize_handlerton() needs that\n\n  if (plugin_init(&remaining_argc, remaining_argv,\n                  (opt_noacl ? PLUGIN_INIT_SKIP_PLUGIN_TABLE : 0) |\n                  (opt_abort ? PLUGIN_INIT_SKIP_INITIALIZATION : 0)))\n  {\n    sql_print_error(\"Failed to initialize plugins.\");\n    unireg_abort(1);\n  }\n  plugins_are_initialized= TRUE;  /* Don't separate from init function */\n\n#ifdef HAVE_REPLICATION\n  /*\n    Semisync is not required by other components, which justifies its\n    initialization at this point when thread specific memory is also available.\n  */\n  if (repl_semisync_master.init_object() ||\n      repl_semisync_slave.init_object())\n  {\n    sql_print_error(\"Could not initialize semisync.\");\n    unireg_abort(1);\n  }\n#endif\n\n#ifndef EMBEDDED_LIBRARY\n  if (session_tracker_init())\n    return 1;\n#endif //EMBEDDED_LIBRARY\n\n  /* we do want to exit if there are any other unknown options */\n  if (remaining_argc > 1)\n  {\n    int ho_error;\n    struct my_option no_opts[]=\n    {\n      {0, 0, 0, 0, 0, 0, GET_NO_ARG, NO_ARG, 0, 0, 0, 0, 0, 0}\n    };\n    /*\n      We need to eat any 'loose' arguments first before we conclude\n      that there are unprocessed options.\n    */\n    my_getopt_skip_unknown= 0;\n\n    if ((ho_error= handle_options(&remaining_argc, &remaining_argv, no_opts,\n                                  mysqld_get_one_option)))\n      unireg_abort(ho_error);\n    /* Add back the program name handle_options removes */\n    remaining_argc++;\n    remaining_argv--;\n    my_getopt_skip_unknown= TRUE;\n\n    if (remaining_argc > 1)\n    {\n      fprintf(stderr, \"%s: Too many arguments (first extra is '%s').\\n\",\n              my_progname, remaining_argv[1]);\n      unireg_abort(1);\n    }\n  }\n\n  if (init_io_cache_encryption())\n    unireg_abort(1);\n\n  if (opt_abort)\n    unireg_abort(0);\n\n  /* if the errmsg.sys is not loaded, terminate to maintain behaviour */\n  if (!DEFAULT_ERRMSGS[0][0])\n    unireg_abort(1);  \n\n  /* We have to initialize the storage engines before CSV logging */\n  if (ha_init())\n  {\n    sql_print_error(\"Can't init databases\");\n    unireg_abort(1);\n  }\n\n  if (opt_bootstrap)\n    log_output_options= LOG_FILE;\n  else\n    logger.init_log_tables();\n\n  if (log_output_options & LOG_NONE)\n  {\n    /*\n      Issue a warining if there were specified additional options to the\n      log-output along with NONE. Probably this wasn't what user wanted.\n    */\n    if ((log_output_options & LOG_NONE) && (log_output_options & ~LOG_NONE))\n      sql_print_warning(\"There were other values specified to \"\n                        \"log-output besides NONE. Disabling slow \"\n                        \"and general logs anyway.\");\n    logger.set_handlers(LOG_FILE, LOG_NONE, LOG_NONE);\n  }\n  else\n  {\n    /* fall back to the log files if tables are not present */\n    LEX_CSTRING csv_name={STRING_WITH_LEN(\"csv\")};\n    if (!plugin_is_ready(&csv_name, MYSQL_STORAGE_ENGINE_PLUGIN))\n    {\n      /* purecov: begin inspected */\n      sql_print_error(\"CSV engine is not present, falling back to the \"\n                      \"log files\");\n      SYSVAR_AUTOSIZE(log_output_options, \n                      (log_output_options & ~LOG_TABLE) | LOG_FILE);\n      /* purecov: end */\n    }\n\n    logger.set_handlers(LOG_FILE,\n                        global_system_variables.sql_log_slow ?\n                        log_output_options:LOG_NONE,\n                        opt_log ? log_output_options:LOG_NONE);\n  }\n\n  if (init_default_storage_engine(default_storage_engine, table_plugin))\n    unireg_abort(1);\n\n  if (default_tmp_storage_engine && !*default_tmp_storage_engine)\n    default_tmp_storage_engine= NULL;\n\n  if (enforced_storage_engine && !*enforced_storage_engine)\n    enforced_storage_engine= NULL;\n\n  if (init_default_storage_engine(default_tmp_storage_engine, tmp_table_plugin))\n    unireg_abort(1);\n\n  if (init_default_storage_engine(enforced_storage_engine, enforced_table_plugin))\n    unireg_abort(1);\n\n  if (init_gtid_pos_auto_engines())\n    unireg_abort(1);\n\n#ifdef USE_ARIA_FOR_TMP_TABLES\n  if (!ha_storage_engine_is_enabled(maria_hton) && !opt_bootstrap)\n  {\n    sql_print_error(\"Aria engine is not enabled or did not start. The Aria engine must be enabled to continue as mysqld was configured with --with-aria-tmp-tables\");\n    unireg_abort(1);\n  }\n#endif\n\n#ifdef WITH_WSREP\n  /*\n    Now is the right time to initialize members of wsrep startup threads\n    that rely on plugins and other related global system variables to be\n    initialized. This initialization was not possible before, as plugins\n    (and thus some global system variables) are initialized after wsrep\n    startup threads are created.\n    Note: This only needs to be done for rsync and mariabackup based SST\n    methods.\n  */\n  if (wsrep_before_SE())\n    wsrep_plugins_post_init();\n\n  if (WSREP_ON && !opt_bin_log)\n  {\n    wsrep_emulate_bin_log= 1;\n  }\n#endif\n\n  tc_log= get_tc_log_implementation();\n\n  if (tc_log->open(opt_bin_log ? opt_bin_logname : opt_tc_log_file))\n  {\n    sql_print_error(\"Can't init tc log\");\n    unireg_abort(1);\n  }\n\n  if (ha_recover(0))\n  {\n    unireg_abort(1);\n  }\n\n  if (opt_bin_log)\n  {\n    int error;\n    mysql_mutex_t *log_lock= mysql_bin_log.get_log_lock();\n    mysql_mutex_lock(log_lock);\n    error= mysql_bin_log.open(opt_bin_logname, LOG_BIN, 0, 0,\n                              WRITE_CACHE, max_binlog_size, 0, TRUE);\n    mysql_mutex_unlock(log_lock);\n    if (unlikely(error))\n      unireg_abort(1);\n  }\n\n#ifdef HAVE_REPLICATION\n  if (opt_bin_log && expire_logs_days)\n  {\n    time_t purge_time= server_start_time - expire_logs_days*24*60*60;\n    if (purge_time >= 0)\n      mysql_bin_log.purge_logs_before_date(purge_time);\n  }\n#endif\n\n  if (opt_myisam_log)\n    (void) mi_log(1);\n\n#if defined(HAVE_MLOCKALL) && defined(MCL_CURRENT) && !defined(EMBEDDED_LIBRARY)\n  if (locked_in_memory)\n  {\n    int error;\n    if (user_info)\n    {\n      DBUG_ASSERT(!getuid());\n      if (setreuid((uid_t) -1, 0) == -1)\n      {\n        sql_perror(\"setreuid\");\n        unireg_abort(1);\n      }\n      error= mlockall(MCL_CURRENT);\n      set_user(mysqld_user, user_info);\n    }\n    else\n      error= mlockall(MCL_CURRENT);\n\n    if (unlikely(error))\n    {\n      if (global_system_variables.log_warnings)\n\tsql_print_warning(\"Failed to lock memory. Errno: %d\\n\",errno);\n      locked_in_memory= 0;\n    }\n  }\n#else\n  locked_in_memory= 0;\n#endif\n\n  ft_init_stopwords();\n\n  init_max_user_conn();\n  init_update_queries();\n  init_global_user_stats();\n  init_global_client_stats();\n  if (!opt_bootstrap)\n    servers_init(0);\n  init_status_vars();\n  DBUG_RETURN(0);\n}\n\n\n#ifndef EMBEDDED_LIBRARY\n#ifdef _WIN32\nstatic void create_shutdown_event()\n{\n  hEventShutdown=CreateEvent(0, FALSE, FALSE, shutdown_event_name);\n  // On \"Stop Service\" we have to do regular shutdown\n  Service.SetShutdownEvent(hEventShutdown);\n}\n#else /*_WIN32*/\n#define create_shutdown_event()\n#endif\n#endif /* EMBEDDED_LIBRARY */\n\n#ifndef EMBEDDED_LIBRARY\n\n#ifndef DBUG_OFF\n/*\n  Debugging helper function to keep the locale database\n  (see sql_locale.cc) and max_month_name_length and\n  max_day_name_length variable values in consistent state.\n*/\nstatic void test_lc_time_sz()\n{\n  DBUG_ENTER(\"test_lc_time_sz\");\n  for (MY_LOCALE **loc= my_locales; *loc; loc++)\n  {\n    size_t max_month_len= 0;\n    size_t max_day_len= 0;\n    for (const char **month= (*loc)->month_names->type_names; *month; month++)\n    {\n      set_if_bigger(max_month_len,\n                    my_numchars_mb(&my_charset_utf8_general_ci,\n                                   *month, *month + strlen(*month)));\n    }\n    for (const char **day= (*loc)->day_names->type_names; *day; day++)\n    {\n      set_if_bigger(max_day_len,\n                    my_numchars_mb(&my_charset_utf8_general_ci,\n                                   *day, *day + strlen(*day)));\n    }\n    if ((*loc)->max_month_name_length != max_month_len ||\n        (*loc)->max_day_name_length != max_day_len)\n    {\n      DBUG_PRINT(\"Wrong max day name(or month name) length for locale:\",\n                 (\"%s\", (*loc)->name));\n      DBUG_ASSERT(0);\n    }\n  }\n  DBUG_VOID_RETURN;\n}\n#endif//DBUG_OFF\n\n\n#ifdef __WIN__\nint win_main(int argc, char **argv)\n#else\nint mysqld_main(int argc, char **argv)\n#endif\n{\n#ifndef _WIN32\n  /* We can't close stdin just now, because it may be booststrap mode. */\n  bool please_close_stdin= fcntl(STDIN_FILENO, F_GETFD) >= 0;\n#endif\n\n  /*\n    Perform basic thread library and malloc initialization,\n    to be able to read defaults files and parse options.\n  */\n  my_progname= argv[0];\n  sf_leaking_memory= 1; // no safemalloc memory leak reports if we exit early\n  mysqld_server_started= mysqld_server_initialized= 0;\n\n  if (init_early_variables())\n    exit(1);\n\n#ifdef HAVE_NPTL\n  ld_assume_kernel_is_set= (getenv(\"LD_ASSUME_KERNEL\") != 0);\n#endif\n#ifndef _WIN32\n  // For windows, my_init() is called from the win specific mysqld_main\n  if (my_init())                 // init my_sys library & pthreads\n  {\n    fprintf(stderr, \"my_init() failed.\");\n    return 1;\n  }\n#endif\n\n  orig_argc= argc;\n  orig_argv= argv;\n  my_getopt_use_args_separator= TRUE;\n  load_defaults_or_exit(MYSQL_CONFIG_NAME, load_default_groups, &argc, &argv);\n  my_getopt_use_args_separator= FALSE;\n  defaults_argc= argc;\n  defaults_argv= argv;\n  remaining_argc= argc;\n  remaining_argv= argv;\n\n  /* Must be initialized early for comparison of options name */\n  system_charset_info= &my_charset_utf8_general_ci;\n\n  sys_var_init();\n\n#ifdef WITH_PERFSCHEMA_STORAGE_ENGINE\n  /*\n    Initialize the array of performance schema instrument configurations.\n  */\n  init_pfs_instrument_array();\n#endif /* WITH_PERFSCHEMA_STORAGE_ENGINE */\n  /*\n    Logs generated while parsing the command line\n    options are buffered and printed later.\n  */\n  buffered_logs.init();\n  my_getopt_error_reporter= buffered_option_error_reporter;\n  my_charset_error_reporter= buffered_option_error_reporter;\n#ifdef WITH_PERFSCHEMA_STORAGE_ENGINE\n  pfs_param.m_pfs_instrument= const_cast<char*>(\"\");\n#endif /* WITH_PERFSCHEMA_STORAGE_ENGINE */\n  my_timer_init(&sys_timer_info);\n\n  int ho_error __attribute__((unused))= handle_early_options();\n\n  /* fix tdc_size */\n  if (IS_SYSVAR_AUTOSIZE(&tdc_size))\n  {\n    SYSVAR_AUTOSIZE(tdc_size, MY_MIN(400 + tdc_size / 2, 2000));\n  }\n\n#ifdef WITH_PERFSCHEMA_STORAGE_ENGINE\n  if (ho_error == 0)\n  {\n    if (pfs_param.m_enabled  && !opt_help && !opt_bootstrap)\n    {\n      /* Add sizing hints from the server sizing parameters. */\n      pfs_param.m_hints.m_table_definition_cache= tdc_size;\n      pfs_param.m_hints.m_table_open_cache= tc_size;\n      pfs_param.m_hints.m_max_connections= max_connections;\n      pfs_param.m_hints.m_open_files_limit= open_files_limit;\n      PSI_hook= initialize_performance_schema(&pfs_param);\n      if (PSI_hook == NULL)\n      {\n        pfs_param.m_enabled= false;\n        buffered_logs.buffer(WARNING_LEVEL,\n                             \"Performance schema disabled (reason: init failed).\");\n      }\n    }\n  }\n#else\n  /*\n    Other provider of the instrumentation interface should\n    initialize PSI_hook here:\n    - HAVE_PSI_INTERFACE is for the instrumentation interface\n    - WITH_PERFSCHEMA_STORAGE_ENGINE is for one implementation\n      of the interface,\n    but there could be alternate implementations, which is why\n    these two defines are kept separate.\n  */\n#endif /* WITH_PERFSCHEMA_STORAGE_ENGINE */\n\n#ifdef HAVE_PSI_INTERFACE\n  /*\n    Obtain the current performance schema instrumentation interface,\n    if available.\n  */\n  if (PSI_hook)\n  {\n    PSI *psi_server= (PSI*) PSI_hook->get_interface(PSI_CURRENT_VERSION);\n    if (likely(psi_server != NULL))\n    {\n      set_psi_server(psi_server);\n\n      /*\n        Now that we have parsed the command line arguments, and have\n        initialized the performance schema itself, the next step is to\n        register all the server instruments.\n      */\n      init_server_psi_keys();\n      /* Instrument the main thread */\n      PSI_thread *psi= PSI_CALL_new_thread(key_thread_main, NULL, 0);\n      PSI_CALL_set_thread(psi);\n\n      /*\n        Now that some instrumentation is in place,\n        recreate objects which were initialised early,\n        so that they are instrumented as well.\n      */\n      my_thread_global_reinit();\n    }\n  }\n#endif /* HAVE_PSI_INTERFACE */\n\n  mysql_mutex_init(key_LOCK_error_log, &LOCK_error_log, MY_MUTEX_INIT_FAST);\n\n  /* Initialize audit interface globals. Audit plugins are inited later. */\n  mysql_audit_initialize();\n\n  /*\n    Perform basic logger initialization logger. Should be called after\n    MY_INIT, as it initializes mutexes. Log tables are inited later.\n  */\n  logger.init_base();\n\n#ifdef WITH_PERFSCHEMA_STORAGE_ENGINE\n  if (ho_error)\n  {\n    /*\n      Parsing command line option failed,\n      Since we don't have a workable remaining_argc/remaining_argv\n      to continue the server initialization, this is as far as this\n      code can go.\n      This is the best effort to log meaningful messages:\n      - messages will be printed to stderr, which is not redirected yet,\n      - messages will be printed in the NT event log, for windows.\n    */\n    buffered_logs.print();\n    buffered_logs.cleanup();\n    /*\n      Not enough initializations for unireg_abort()\n      Using exit() for windows.\n    */\n    exit (ho_error);\n  }\n#endif /* WITH_PERFSCHEMA_STORAGE_ENGINE */\n\n#ifdef _CUSTOMSTARTUPCONFIG_\n  if (_cust_check_startup())\n  {\n    / * _cust_check_startup will report startup failure error * /\n    exit(1);\n  }\n#endif\n\n  if (init_common_variables())\n    unireg_abort(1);\t\t\t\t// Will do exit\n\n  init_signals();\n\n  ulonglong new_thread_stack_size;\n  new_thread_stack_size= my_setstacksize(&connection_attrib,\n                                         (size_t)my_thread_stack_size);\n  if (new_thread_stack_size != my_thread_stack_size)\n    SYSVAR_AUTOSIZE(my_thread_stack_size, new_thread_stack_size);\n\n  (void) thr_setconcurrency(concurrency);\t// 10 by default\n\n  select_thread=pthread_self();\n  select_thread_in_use=1;\n\n#ifdef HAVE_LIBWRAP\n  libwrapName= my_progname+dirname_length(my_progname);\n  openlog(libwrapName, LOG_PID, LOG_AUTH);\n#endif\n\n#ifndef DBUG_OFF\n  test_lc_time_sz();\n  srand((uint) time(NULL)); \n#endif\n\n  /*\n    We have enough space for fiddling with the argv, continue\n  */\n  check_data_home(mysql_real_data_home);\n  if (my_setwd(mysql_real_data_home, opt_abort ? 0 : MYF(MY_WME)) && !opt_abort)\n    unireg_abort(1);\t\t\t\t/* purecov: inspected */\n\n  /* Atomic write initialization must be done as root */\n  my_init_atomic_write();\n\n  if ((user_info= check_user(mysqld_user)))\n  {\n#if defined(HAVE_MLOCKALL) && defined(MCL_CURRENT)\n    if (locked_in_memory) // getuid() == 0 here\n      set_effective_user(user_info);\n    else\n#endif\n      set_user(mysqld_user, user_info);\n  }\n\n  if (WSREP_ON && wsrep_check_opts()) unireg_abort(1);\n\n  /* \n   The subsequent calls may take a long time : e.g. innodb log read.\n   Thus set the long running service control manager timeout\n  */\n#if defined(_WIN32) && !defined(EMBEDDED_LIBRARY)\n  Service.SetSlowStarting(slow_start_timeout);\n#endif\n\n  if (init_server_components())\n    unireg_abort(1);\n\n  init_ssl();\n  network_init();\n\n#ifdef _WIN32\n  if (!opt_console)\n  {\n    FreeConsole();\t\t\t\t// Remove window\n  }\n#endif\n\n#ifdef WITH_WSREP\n  // Recover and exit.\n  if (wsrep_recovery)\n  {\n    select_thread_in_use= 0;\n    if (WSREP_ON)\n      wsrep_recover();\n    else\n      sql_print_information(\"WSREP: disabled, skipping position recovery\");\n    unireg_abort(0);\n  }\n#endif\n\n  /*\n    init signals & alarm\n    After this we can't quit by a simple unireg_abort\n  */\n  start_signal_handler();\t\t\t\t// Creates pidfile\n\n  if (mysql_rm_tmp_tables() || acl_init(opt_noacl) ||\n      my_tz_init((THD *)0, default_tz_name, opt_bootstrap))\n    unireg_abort(1);\n\n  if (!opt_noacl)\n    (void) grant_init();\n\n  udf_init();\n\n  if (opt_bootstrap) /* If running with bootstrap, do not start replication. */\n    opt_skip_slave_start= 1;\n\n  binlog_unsafe_map_init();\n\n#ifdef WITH_PERFSCHEMA_STORAGE_ENGINE\n  initialize_performance_schema_acl(opt_bootstrap);\n#endif\n\n  initialize_information_schema_acl();\n\n  execute_ddl_log_recovery();\n\n  /*\n    Change EVENTS_ORIGINAL to EVENTS_OFF (the default value) as there is no\n    point in using ORIGINAL during startup\n  */\n  if (Events::opt_event_scheduler == Events::EVENTS_ORIGINAL)\n    Events::opt_event_scheduler= Events::EVENTS_OFF;\n\n  Events::set_original_state(Events::opt_event_scheduler);\n  if (Events::init((THD*) 0, opt_noacl || opt_bootstrap))\n    unireg_abort(1);\n\n  if (WSREP_ON)\n  {\n    if (opt_bootstrap)\n    {\n      /*! bootstrap wsrep init was taken care of above */\n    }\n    else\n    {\n      wsrep_init_globals();\n      if (!wsrep_before_SE())\n      {\n        wsrep_init_startup (false);\n      }\n\n      WSREP_DEBUG(\"Startup creating %ld applier threads running %lu\",\n\t      wsrep_slave_threads - 1, wsrep_running_applier_threads);\n      wsrep_create_appliers(wsrep_slave_threads - 1);\n    }\n  }\n\n  if (opt_bootstrap)\n  {\n    select_thread_in_use= 0;                    // Allow 'kill' to work\n    int bootstrap_error= bootstrap(mysql_stdin);\n    if (!abort_loop)\n      unireg_abort(bootstrap_error);\n    else\n    {\n      sleep(2);                                 // Wait for kill\n      exit(0);\n    }\n  }\n\n  create_shutdown_event();\n  start_handle_manager();\n\n  /* Copy default global rpl_filter to global_rpl_filter */\n  copy_filter_setting(global_rpl_filter, get_or_create_rpl_filter(\"\", 0));\n\n  /*\n    init_slave() must be called after the thread keys are created.\n    Some parts of the code (e.g. SHOW STATUS LIKE 'slave_running' and other\n    places) assume that active_mi != 0, so let's fail if it's 0 (out of\n    memory); a message has already been printed.\n  */\n  if (init_slave() && !active_mi)\n  {\n    unireg_abort(1);\n  }\n\n  if (opt_init_file && *opt_init_file)\n  {\n    if (read_init_file(opt_init_file))\n      unireg_abort(1);\n  }\n\n  disable_log_notes= 0; /* Startup done, now we can give notes again */\n\n  if (IS_SYSVAR_AUTOSIZE(&server_version_ptr))\n    sql_print_information(ER_DEFAULT(ER_STARTUP), my_progname, server_version,\n                          ((mysql_socket_getfd(unix_sock) == INVALID_SOCKET) ?\n                           (char*) \"\" : mysqld_unix_port),\n                          mysqld_port, MYSQL_COMPILATION_COMMENT);\n  else\n  {\n    char real_server_version[2 * SERVER_VERSION_LENGTH + 10];\n\n    set_server_version(real_server_version, sizeof(real_server_version));\n    strcat(real_server_version, \"' as '\");\n    strcat(real_server_version, server_version);\n\n    sql_print_information(ER_DEFAULT(ER_STARTUP), my_progname,\n                          real_server_version,\n                          ((mysql_socket_getfd(unix_sock) == INVALID_SOCKET) ?\n                           (char*) \"\" : mysqld_unix_port),\n                          mysqld_port, MYSQL_COMPILATION_COMMENT);\n  }\n\n#ifndef _WIN32\n  // try to keep fd=0 busy\n  if (please_close_stdin && !freopen(\"/dev/null\", \"r\", stdin))\n  {\n    // fall back on failure\n    fclose(stdin);\n  }\n#endif\n\n#if defined(_WIN32) && !defined(EMBEDDED_LIBRARY)\n  Service.SetRunning();\n#endif\n\n  /* Signal threads waiting for server to be started */\n  mysql_mutex_lock(&LOCK_server_started);\n  mysqld_server_started= 1;\n  mysql_cond_broadcast(&COND_server_started);\n  mysql_mutex_unlock(&LOCK_server_started);\n\n  MYSQL_SET_STAGE(0 ,__FILE__, __LINE__);\n\n  /* Memory used when everything is setup */\n  start_memory_used= global_status_var.global_memory_used;\n\n#ifdef _WIN32\n  handle_connections_win();\n#else\n  handle_connections_sockets();\n\n  mysql_mutex_lock(&LOCK_start_thread);\n  select_thread_in_use=0;\n  mysql_cond_broadcast(&COND_start_thread);\n  mysql_mutex_unlock(&LOCK_start_thread);\n#endif /* _WIN32 */\n\n  /* Shutdown requested */\n  char *user= shutdown_user.load(std::memory_order_relaxed);\n  sql_print_information(ER_DEFAULT(ER_NORMAL_SHUTDOWN), my_progname,\n                        user ? user : \"unknown\");\n  if (user)\n    my_free(user);\n\n#ifdef WITH_WSREP\n  /* Stop wsrep threads in case they are running. */\n  if (wsrep_running_threads > 0)\n  {\n    wsrep_shutdown_replication();\n  }\n#endif\n\n  close_connections();\n\n  clean_up(1);\n  sd_notify(0, \"STATUS=MariaDB server is down\");\n\n  /* (void) pthread_attr_destroy(&connection_attrib); */\n\n  DBUG_PRINT(\"quit\",(\"Exiting main thread\"));\n\n  /*\n    Disable the main thread instrumentation,\n    to avoid recording events during the shutdown.\n  */\n  PSI_CALL_delete_current_thread();\n\n#if defined(__WIN__) && !defined(EMBEDDED_LIBRARY)\n  if (start_mode)\n    Service.Stop();\n  else\n  {\n    Service.SetShutdownEvent(0);\n    if (hEventShutdown)\n      CloseHandle(hEventShutdown);\n  }\n#endif\n#if (defined(HAVE_OPENSSL) && !defined(EMBEDDED_LIBRARY))\n  ERR_remove_state(0);\n#endif\n  mysqld_exit(0);\n  return 0;\n}\n\n#endif /* !EMBEDDED_LIBRARY */\n\n\n/****************************************************************************\n  Main and thread entry function for Win32\n  (all this is needed only to run mysqld as a service on WinNT)\n****************************************************************************/\n\n#if defined(__WIN__) && !defined(EMBEDDED_LIBRARY)\nvoid  mysql_service(void *p)\n{\n  if (my_thread_init())\n    abort();\n  \n  if (use_opt_args)\n    win_main(opt_argc, opt_argv);\n  else\n    win_main(Service.my_argc, Service.my_argv);\n\n  my_thread_end();\n}\n\n\n/* Quote string if it contains space, else copy */\n\nstatic char *add_quoted_string(char *to, const char *from, char *to_end)\n{\n  uint length= (uint) (to_end-to);\n\n  if (!strchr(from, ' '))\n    return strmake(to, from, length-1);\n  return strxnmov(to, length-1, \"\\\"\", from, \"\\\"\", NullS);\n}\n\n\n/**\n  Handle basic handling of services, like installation and removal.\n\n  @param argv\t   \t        Pointer to argument list\n  @param servicename\t\tInternal name of service\n  @param displayname\t\tDisplay name of service (in taskbar ?)\n  @param file_path\t\tPath to this program\n  @param startup_option\tStartup option to mysqld\n\n  @retval 0\toption handled\n  @retval 1\tCould not handle option\n*/\n\nstatic bool\ndefault_service_handling(char **argv,\n\t\t\t const char *servicename,\n\t\t\t const char *displayname,\n\t\t\t const char *file_path,\n\t\t\t const char *extra_opt,\n\t\t\t const char *account_name)\n{\n  char path_and_service[FN_REFLEN+FN_REFLEN+32], *pos, *end;\n  const char *opt_delim;\n  end= path_and_service + sizeof(path_and_service)-3;\n\n  /* We have to quote filename if it contains spaces */\n  pos= add_quoted_string(path_and_service, file_path, end);\n  if (extra_opt && *extra_opt)\n  {\n    /* \n     Add option after file_path. There will be zero or one extra option.  It's \n     assumed to be --defaults-file=file but isn't checked.  The variable (not\n     the option name) should be quoted if it contains a string.  \n    */\n    *pos++= ' ';\n    if ((opt_delim= strchr(extra_opt, '=')))\n    {\n      size_t length= ++opt_delim - extra_opt;\n      pos= strnmov(pos, extra_opt, length);\n    }\n    else\n      opt_delim= extra_opt;\n    \n    pos= add_quoted_string(pos, opt_delim, end);\n  }\n  /* We must have servicename last */\n  *pos++= ' ';\n  (void) add_quoted_string(pos, servicename, end);\n\n  if (Service.got_service_option(argv, \"install\"))\n  {\n    Service.Install(1, servicename, displayname, path_and_service,\n                    account_name);\n    return 0;\n  }\n  if (Service.got_service_option(argv, \"install-manual\"))\n  {\n    Service.Install(0, servicename, displayname, path_and_service,\n                    account_name);\n    return 0;\n  }\n  if (Service.got_service_option(argv, \"remove\"))\n  {\n    Service.Remove(servicename);\n    return 0;\n  }\n  return 1;\n}\n\n\nint mysqld_main(int argc, char **argv)\n{\n  my_progname= argv[0];\n\n  /*\n    When several instances are running on the same machine, we\n    need to have an  unique  named  hEventShudown  through the\n    application PID e.g.: MySQLShutdown1890; MySQLShutdown2342\n  */\n  int10_to_str((int) GetCurrentProcessId(),strmov(shutdown_event_name,\n                                                  \"MySQLShutdown\"), 10);\n\n  /* Must be initialized early for comparison of service name */\n  system_charset_info= &my_charset_utf8_general_ci;\n\n  if (my_init())\n  {\n    fprintf(stderr, \"my_init() failed.\");\n    return 1;\n  }\n\n\n  char file_path[FN_REFLEN];\n  my_path(file_path, argv[0], \"\");\t\t      /* Find name in path */\n  fn_format(file_path,argv[0],file_path,\"\",   MY_REPLACE_DIR | MY_UNPACK_FILENAME | MY_RESOLVE_SYMLINKS);\n\n  if (argc == 2)\n  {\n    if (!default_service_handling(argv, MYSQL_SERVICENAME, MYSQL_SERVICENAME,\n      file_path, \"\", NULL))\n      return 0;\n\n    if (Service.IsService(argv[1]))        /* Start an optional service */\n    {\n      /*\n      Only add the service name to the groups read from the config file\n      if it's not \"MySQL\". (The default service name should be 'mysqld'\n      but we started a bad tradition by calling it MySQL from the start\n      and we are now stuck with it.\n      */\n      if (my_strcasecmp(system_charset_info, argv[1],\"mysql\"))\n        load_default_groups[load_default_groups_sz-2]= argv[1];\n      start_mode= 1;\n      Service.Init(argv[1], mysql_service);\n      return 0;\n    }\n  }\n  else if (argc == 3) /* install or remove any optional service */\n  {\n    if (!default_service_handling(argv, argv[2], argv[2], file_path, \"\",\n                                  NULL))\n      return 0;\n    if (Service.IsService(argv[2]))\n    {\n      /*\n       mysqld was started as\n       mysqld --defaults-file=my_path\\my.ini service-name\n      */\n      use_opt_args=1;\n      opt_argc= 2;\t\t\t\t// Skip service-name\n      opt_argv=argv;\n      start_mode= 1;\n      if (my_strcasecmp(system_charset_info, argv[2],\"mysql\"))\n        load_default_groups[load_default_groups_sz-2]= argv[2];\n      Service.Init(argv[2], mysql_service);\n      return 0;\n    }\n  }\n  else if (argc == 4 || argc == 5)\n  {\n    /*\n      This may seem strange, because we handle --local-service while\n      preserving 4.1's behavior of allowing any one other argument that is\n      passed to the service on startup. (The assumption is that this is\n      --defaults-file=file, but that was not enforced in 4.1, so we don't\n      enforce it here.)\n    */\n    const char *extra_opt= NullS;\n    const char *account_name = NullS;\n    int index;\n    for (index = 3; index < argc; index++)\n    {\n      if (!strcmp(argv[index], \"--local-service\"))\n        account_name= \"NT AUTHORITY\\\\LocalService\";\n      else\n        extra_opt= argv[index];\n    }\n\n    if (argc == 4 || account_name)\n      if (!default_service_handling(argv, argv[2], argv[2], file_path,\n                                    extra_opt, account_name))\n        return 0;\n  }\n  else if (argc == 1 && Service.IsService(MYSQL_SERVICENAME))\n  {\n    /* start the default service */\n    start_mode= 1;\n    Service.Init(MYSQL_SERVICENAME, mysql_service);\n    return 0;\n  }\n\n  /* Start as standalone server */\n  Service.my_argc=argc;\n  Service.my_argv=argv;\n  mysql_service(NULL);\n  return 0;\n}\n#endif\n\n\nstatic bool read_init_file(char *file_name)\n{\n  MYSQL_FILE *file;\n  DBUG_ENTER(\"read_init_file\");\n  DBUG_PRINT(\"enter\",(\"name: %s\",file_name));\n  if (!(file= mysql_file_fopen(key_file_init, file_name,\n                               O_RDONLY, MYF(MY_WME))))\n    DBUG_RETURN(TRUE);\n  bootstrap(file);\n  mysql_file_fclose(file, MYF(MY_WME));\n  DBUG_RETURN(FALSE);\n}\n\n\n/**\n  Increment number of created threads\n*/\nvoid inc_thread_created(void)\n{\n  statistic_increment(thread_created, &LOCK_status);\n}\n\n#ifndef EMBEDDED_LIBRARY\n\n/*\n   Simple scheduler that use the main thread to handle the request\n\n   NOTES\n     This is only used for debugging, when starting mysqld with\n     --thread-handling=no-threads or --one-thread\n*/\n\nvoid handle_connection_in_main_thread(CONNECT *connect)\n{\n  thread_cache_size= 0;\t\t\t// Safety\n  do_handle_one_connection(connect);\n}\n\n\n/*\n  Scheduler that uses one thread per connection\n*/\n\nvoid create_thread_to_handle_connection(CONNECT *connect)\n{\n  char error_message_buff[MYSQL_ERRMSG_SIZE];\n  int error;\n  DBUG_ENTER(\"create_thread_to_handle_connection\");\n\n  /* Check if we can get thread from the cache */\n  if (cached_thread_count > wake_thread)\n  {\n    mysql_mutex_lock(&LOCK_thread_cache);\n    /* Recheck condition when we have the lock */\n    if (cached_thread_count > wake_thread)\n    {\n      /* Get thread from cache */\n      thread_cache.push_back(connect);\n      wake_thread++;\n      mysql_cond_signal(&COND_thread_cache);\n      mysql_mutex_unlock(&LOCK_thread_cache);\n      DBUG_PRINT(\"info\",(\"Thread created\"));\n      DBUG_VOID_RETURN;\n    }\n    mysql_mutex_unlock(&LOCK_thread_cache);\n  }\n\n  /* Create new thread to handle connection */\n  inc_thread_created();\n  DBUG_PRINT(\"info\",((\"creating thread %lu\"), (ulong) connect->thread_id));\n  connect->prior_thr_create_utime= microsecond_interval_timer();\n\n  if ((error= mysql_thread_create(key_thread_one_connection,\n                                  &connect->real_id, &connection_attrib,\n                                  handle_one_connection, (void*) connect)))\n  {\n    /* purecov: begin inspected */\n    DBUG_PRINT(\"error\", (\"Can't create thread to handle request (error %d)\",\n                error));\n    my_snprintf(error_message_buff, sizeof(error_message_buff),\n                ER_DEFAULT(ER_CANT_CREATE_THREAD), error);\n    connect->close_with_error(ER_CANT_CREATE_THREAD, error_message_buff,\n                              ER_OUT_OF_RESOURCES);\n    DBUG_VOID_RETURN;\n    /* purecov: end */\n  }\n  DBUG_PRINT(\"info\",(\"Thread created\"));\n  DBUG_VOID_RETURN;\n}\n\n\n/**\n  Create new thread to handle incoming connection.\n\n    This function will create new thread to handle the incoming\n    connection.  If there are idle cached threads one will be used.\n    'thd' will be pushed into 'threads'.\n\n    In single-threaded mode (\\#define ONE_THREAD) connection will be\n    handled inside this function.\n\n  @param[in,out] thd    Thread handle of future thread.\n*/\n\nvoid create_new_thread(CONNECT *connect)\n{\n  DBUG_ENTER(\"create_new_thread\");\n\n  /*\n    Don't allow too many connections. We roughly check here that we allow\n    only (max_connections + 1) connections.\n  */\n\n  mysql_mutex_lock(&LOCK_connection_count);\n\n  if (*connect->scheduler->connection_count >=\n      *connect->scheduler->max_connections + 1|| abort_loop)\n  {\n    DBUG_PRINT(\"error\",(\"Too many connections\"));\n\n    mysql_mutex_unlock(&LOCK_connection_count);\n    statistic_increment(denied_connections, &LOCK_status);\n    statistic_increment(connection_errors_max_connection, &LOCK_status);\n    connect->close_with_error(0, NullS, abort_loop ? ER_SERVER_SHUTDOWN : ER_CON_COUNT_ERROR);\n    DBUG_VOID_RETURN;\n  }\n\n  ++*connect->scheduler->connection_count;\n\n  if (connection_count + extra_connection_count > max_used_connections)\n    max_used_connections= connection_count + extra_connection_count;\n\n  mysql_mutex_unlock(&LOCK_connection_count);\n\n  connect->thread_count_incremented= 1;\n\n  /*\n    The initialization of thread_id is done in create_embedded_thd() for\n    the embedded library.\n    TODO: refactor this to avoid code duplication there\n  */\n  connect->thread_id= next_thread_id();\n  connect->scheduler->add_connection(connect);\n\n  DBUG_VOID_RETURN;\n}\n#endif /* EMBEDDED_LIBRARY */\n\n\n\t/* Handle new connections and spawn new process to handle them */\n\n#ifndef EMBEDDED_LIBRARY\n\nvoid handle_accepted_socket(MYSQL_SOCKET new_sock, MYSQL_SOCKET sock)\n{\n  CONNECT *connect;\n  bool is_unix_sock;\n\n#ifdef FD_CLOEXEC\n  (void) fcntl(mysql_socket_getfd(new_sock), F_SETFD, FD_CLOEXEC);\n#endif\n\n#ifdef HAVE_LIBWRAP\n  {\n    if (mysql_socket_getfd(sock) == mysql_socket_getfd(base_ip_sock) ||\n      mysql_socket_getfd(sock) == mysql_socket_getfd(extra_ip_sock))\n    {\n      struct request_info req;\n      signal(SIGCHLD, SIG_DFL);\n      request_init(&req, RQ_DAEMON, libwrapName, RQ_FILE,\n        mysql_socket_getfd(new_sock), NULL);\n      my_fromhost(&req);\n      if (!my_hosts_access(&req))\n      {\n        /*\n          This may be stupid but refuse() includes an exit(0)\n          which we surely don't want...\n          clean_exit() - same stupid thing ...\n        */\n        syslog(deny_severity, \"refused connect from %s\",\n          my_eval_client(&req));\n\n        /*\n          C++ sucks (the gibberish in front just translates the supplied\n          sink function pointer in the req structure from a void (*sink)();\n          to a void(*sink)(int) if you omit the cast, the C++ compiler\n          will cry...\n        */\n        if (req.sink)\n          ((void(*)(int))req.sink)(req.fd);\n\n        (void)mysql_socket_shutdown(new_sock, SHUT_RDWR);\n        (void)mysql_socket_close(new_sock);\n        /*\n          The connection was refused by TCP wrappers.\n          There are no details (by client IP) available to update the\n          host_cache.\n        */\n        statistic_increment(connection_errors_tcpwrap, &LOCK_status);\n        return;\n      }\n    }\n  }\n#endif /* HAVE_LIBWRAP */\n\n  DBUG_PRINT(\"info\", (\"Creating CONNECT for new connection\"));\n\n  if ((connect= new CONNECT()))\n  {\n    is_unix_sock= (mysql_socket_getfd(sock) ==\n      mysql_socket_getfd(unix_sock));\n\n    if (!(connect->vio=\n      mysql_socket_vio_new(new_sock,\n        is_unix_sock ? VIO_TYPE_SOCKET :\n        VIO_TYPE_TCPIP,\n        is_unix_sock ? VIO_LOCALHOST : 0)))\n    {\n      delete connect;\n      connect= 0;                             // Error handling below\n    }\n  }\n\n  if (!connect)\n  {\n    /* Connect failure */\n    (void)mysql_socket_close(new_sock);\n    statistic_increment(aborted_connects, &LOCK_status);\n    statistic_increment(connection_errors_internal, &LOCK_status);\n    return;\n  }\n\n  if (is_unix_sock)\n    connect->host= my_localhost;\n\n  if (mysql_socket_getfd(sock) == mysql_socket_getfd(extra_ip_sock))\n  {\n    connect->extra_port= 1;\n    connect->scheduler= extra_thread_scheduler;\n  }\n  create_new_thread(connect);\n}\n\n#ifndef _WIN32\nvoid handle_connections_sockets()\n{\n  MYSQL_SOCKET sock= mysql_socket_invalid();\n  MYSQL_SOCKET new_sock= mysql_socket_invalid();\n  uint error_count=0;\n  struct sockaddr_storage cAddr;\n  int ip_flags __attribute__((unused))=0;\n  int socket_flags __attribute__((unused))= 0;\n  int extra_ip_flags __attribute__((unused))=0;\n  int flags=0,retval;\n#ifdef HAVE_POLL\n  int socket_count= 0;\n  struct pollfd fds[3]; // for ip_sock, unix_sock and extra_ip_sock\n  MYSQL_SOCKET  pfs_fds[3]; // for performance schema\n#define setup_fds(X)                    \\\n    mysql_socket_set_thread_owner(X);             \\\n    pfs_fds[socket_count]= (X);                   \\\n    fds[socket_count].fd= mysql_socket_getfd(X);  \\\n    fds[socket_count].events= POLLIN;   \\\n    socket_count++\n#else\n#define setup_fds(X)    FD_SET(mysql_socket_getfd(X),&clientFDs)\n  fd_set readFDs,clientFDs;\n  FD_ZERO(&clientFDs);\n#endif\n\n  DBUG_ENTER(\"handle_connections_sockets\");\n\n  if (mysql_socket_getfd(base_ip_sock) != INVALID_SOCKET)\n  {\n    setup_fds(base_ip_sock);\n    ip_flags = fcntl(mysql_socket_getfd(base_ip_sock), F_GETFL, 0);\n  }\n  if (mysql_socket_getfd(extra_ip_sock) != INVALID_SOCKET)\n  {\n    setup_fds(extra_ip_sock);\n    extra_ip_flags = fcntl(mysql_socket_getfd(extra_ip_sock), F_GETFL, 0);\n  }\n#ifdef HAVE_SYS_UN_H\n  setup_fds(unix_sock);\n  socket_flags=fcntl(mysql_socket_getfd(unix_sock), F_GETFL, 0);\n#endif\n\n  sd_notify(0, \"READY=1\\n\"\n            \"STATUS=Taking your SQL requests now...\\n\");\n\n  DBUG_PRINT(\"general\",(\"Waiting for connections.\"));\n  while (!abort_loop)\n  {\n#ifdef HAVE_POLL\n    retval= poll(fds, socket_count, -1);\n#else\n    readFDs=clientFDs;\n    retval= select((int) 0,&readFDs,0,0,0);\n#endif\n\n    if (retval < 0)\n    {\n      if (socket_errno != SOCKET_EINTR)\n      {\n        /*\n          select(2)/poll(2) failed on the listening port.\n          There is not much details to report about the client,\n          increment the server global status variable.\n        */\n        statistic_increment(connection_errors_accept, &LOCK_status);\n\tif (!select_errors++ && !abort_loop)\t/* purecov: inspected */\n\t  sql_print_error(\"mysqld: Got error %d from select\",socket_errno); /* purecov: inspected */\n      }\n      continue;\n    }\n\n    if (abort_loop)\n      break;\n\n    /* Is this a new connection request ? */\n#ifdef HAVE_POLL\n    for (int i= 0; i < socket_count; ++i) \n    {\n      if (fds[i].revents & POLLIN)\n      {\n        sock= pfs_fds[i];\n        flags= fcntl(mysql_socket_getfd(sock), F_GETFL, 0);\n        break;\n      }\n    }\n#else  // HAVE_POLL\n    if (FD_ISSET(mysql_socket_getfd(base_ip_sock),&readFDs))\n    {\n      sock=  base_ip_sock;\n      flags= ip_flags;\n    }\n    else\n    if (FD_ISSET(mysql_socket_getfd(extra_ip_sock),&readFDs))\n    {\n      sock=  extra_ip_sock;\n      flags= extra_ip_flags;\n    }\n    else\n    {\n      sock = unix_sock;\n      flags= socket_flags;\n    }\n#endif // HAVE_POLL\n\n#if !defined(NO_FCNTL_NONBLOCK)\n    if (!(test_flags & TEST_BLOCKING))\n    {\n#if defined(O_NONBLOCK)\n      fcntl(mysql_socket_getfd(sock), F_SETFL, flags | O_NONBLOCK);\n#elif defined(O_NDELAY)\n      fcntl(mysql_socket_getfd(sock), F_SETFL, flags | O_NDELAY);\n#endif\n    }\n#endif /* NO_FCNTL_NONBLOCK */\n    for (uint retry=0; retry < MAX_ACCEPT_RETRY; retry++)\n    {\n      size_socket length= sizeof(struct sockaddr_storage);\n      new_sock= mysql_socket_accept(key_socket_client_connection, sock,\n                                    (struct sockaddr *)(&cAddr),\n                                    &length);\n      if (mysql_socket_getfd(new_sock) != INVALID_SOCKET ||\n\t  (socket_errno != SOCKET_EINTR && socket_errno != SOCKET_EAGAIN))\n\tbreak;\n#if !defined(NO_FCNTL_NONBLOCK)\n      if (!(test_flags & TEST_BLOCKING))\n      {\n\tif (retry == MAX_ACCEPT_RETRY - 1)\n        {\n          // Try without O_NONBLOCK\n\t  fcntl(mysql_socket_getfd(sock), F_SETFL, flags);\n        }\n      }\n#endif\n    }\n\n    if (mysql_socket_getfd(new_sock) == INVALID_SOCKET)\n    {\n      /*\n        accept(2) failed on the listening port, after many retries.\n        There is not much details to report about the client,\n        increment the server global status variable.\n      */\n      statistic_increment(connection_errors_accept, &LOCK_status);\n      if ((error_count++ & 255) == 0)\t\t// This can happen often\n\tsql_perror(\"Error in accept\");\n      if (socket_errno == SOCKET_ENFILE || socket_errno == SOCKET_EMFILE)\n\tsleep(1);\t\t\t\t// Give other threads some time\n      continue;\n    }\n#if !defined(NO_FCNTL_NONBLOCK)\n\tif (!(test_flags & TEST_BLOCKING))\n\t\tfcntl(mysql_socket_getfd(sock), F_SETFL, flags);\n#endif\n    handle_accepted_socket(new_sock, sock);\n  }\n  sd_notify(0, \"STOPPING=1\\n\"\n            \"STATUS=Shutdown in progress\\n\");\n  DBUG_VOID_RETURN;\n}\n\n#endif /* _WIN32*/\n#endif /* EMBEDDED_LIBRARY */\n\n\n/****************************************************************************\n  Handle start options\n******************************************************************************/\n\n\n/**\n  Process command line options flagged as 'early'.\n  Some components needs to be initialized as early as possible,\n  because the rest of the server initialization depends on them.\n  Options that needs to be parsed early includes:\n  - the performance schema, when compiled in,\n  - options related to the help,\n  - options related to the bootstrap\n  The performance schema needs to be initialized as early as possible,\n  before to-be-instrumented objects of the server are initialized.\n*/\n\nint handle_early_options()\n{\n  int ho_error;\n  DYNAMIC_ARRAY all_early_options;\n\n  my_getopt_register_get_addr(NULL);\n  /* Skip unknown options so that they may be processed later */\n  my_getopt_skip_unknown= TRUE;\n\n  /* prepare all_early_options array */\n  my_init_dynamic_array(&all_early_options, sizeof(my_option), 100, 25, MYF(0));\n  add_many_options(&all_early_options, pfs_early_options,\n                  array_elements(pfs_early_options));\n  sys_var_add_options(&all_early_options, sys_var::PARSE_EARLY);\n  add_terminator(&all_early_options);\n\n  ho_error= handle_options(&remaining_argc, &remaining_argv,\n                           (my_option*)(all_early_options.buffer),\n                           mysqld_get_one_option);\n  if (ho_error == 0)\n  {\n    /* Add back the program name handle_options removes */\n    remaining_argc++;\n    remaining_argv--;\n  }\n\n  delete_dynamic(&all_early_options);\n\n  return ho_error;\n}\n\n\n#define MYSQL_COMPATIBILITY_OPTION(option) \\\n  { option, OPT_MYSQL_COMPATIBILITY, \\\n   0, 0, 0, 0, GET_STR, OPT_ARG, 0, 0, 0, 0, 0, 0 }\n\n#define MYSQL_TO_BE_IMPLEMENTED_OPTION(option) \\\n  { option, OPT_MYSQL_TO_BE_IMPLEMENTED, \\\n   0, 0, 0, 0, GET_STR, OPT_ARG, 0, 0, 0, 0, 0, 0 }\n\n#define MYSQL_SUGGEST_ANALOG_OPTION(option, str) \\\n  { option, OPT_MYSQL_COMPATIBILITY, \\\n   0, 0, 0, 0, GET_STR, OPT_ARG, 0, 0, 0, 0, 0, 0 }\n\n\n/**\n  System variables are automatically command-line options (few\n  exceptions are documented in sys_var.h), so don't need\n  to be listed here.\n*/\n\nstruct my_option my_long_options[]=\n{\n  {\"help\", '?', \"Display this help and exit.\", \n   &opt_help, &opt_help, 0, GET_BOOL, NO_ARG, 0, 0, 0, 0,\n   0, 0},\n  {\"allow-suspicious-udfs\", 0,\n   \"Allows use of UDFs consisting of only one symbol xxx() \"\n   \"without corresponding xxx_init() or xxx_deinit(). That also means \"\n   \"that one can load any function from any library, for example exit() \"\n   \"from libc.so\",\n   &opt_allow_suspicious_udfs, &opt_allow_suspicious_udfs,\n   0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0, 0},\n  {\"ansi\", 'a', \"Use ANSI SQL syntax instead of MySQL syntax. This mode \"\n   \"will also set transaction isolation level 'serializable'.\", 0, 0, 0,\n   GET_NO_ARG, NO_ARG, 0, 0, 0, 0, 0, 0},\n  /*\n    Because Sys_var_bit does not support command-line options, we need to\n    explicitly add one for --autocommit\n  */\n  {\"autocommit\", 0, \"Set default value for autocommit (0 or 1)\",\n   &opt_autocommit, &opt_autocommit, 0,\n   GET_BOOL, OPT_ARG, 1, 0, 0, 0, 0, NULL},\n  {\"binlog-do-db\", OPT_BINLOG_DO_DB,\n   \"Tells the master it should log updates for the specified database, \"\n   \"and exclude all others not explicitly mentioned.\",\n   0, 0, 0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"binlog-ignore-db\", OPT_BINLOG_IGNORE_DB,\n   \"Tells the master that updates to the given database should not be logged to the binary log.\",\n   0, 0, 0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"binlog-row-event-max-size\", 0,\n   \"The maximum size of a row-based binary log event in bytes. Rows will be \"\n   \"grouped into events smaller than this size if possible. \"\n   \"The value has to be a multiple of 256.\",\n   &opt_binlog_rows_event_max_size, &opt_binlog_rows_event_max_size,\n   0, GET_ULONG, REQUIRED_ARG,\n   /* def_value */ 8192, /* min_value */  256, /* max_value */ UINT_MAX32-1,\n   /* sub_size */     0, /* block_size */ 256,\n   /* app_type */ 0\n  },\n#ifndef DISABLE_GRANT_OPTIONS\n  {\"bootstrap\", OPT_BOOTSTRAP, \"Used by mysql installation scripts.\", 0, 0, 0,\n   GET_NO_ARG, NO_ARG, 0, 0, 0, 0, 0, 0},\n#endif\n  {\"character-set-client-handshake\", 0,\n   \"Don't ignore client side character set value sent during handshake.\",\n   &opt_character_set_client_handshake,\n   &opt_character_set_client_handshake,\n    0, GET_BOOL, NO_ARG, 1, 0, 0, 0, 0, 0},\n  {\"character-set-filesystem\", 0,\n   \"Set the filesystem character set.\",\n   &character_set_filesystem_name,\n   &character_set_filesystem_name,\n   0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0 },\n  {\"character-set-server\", 'C', \"Set the default character set.\",\n   &default_character_set_name, &default_character_set_name,\n   0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0 },\n  {\"chroot\", 'r', \"Chroot mysqld daemon during startup.\",\n   &mysqld_chroot, &mysqld_chroot, 0, GET_STR, REQUIRED_ARG,\n   0, 0, 0, 0, 0, 0},\n  {\"collation-server\", 0, \"Set the default collation.\",\n   &default_collation_name, &default_collation_name,\n   0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0 },\n  {\"console\", OPT_CONSOLE, \"Write error output on screen; don't remove the console window on windows.\",\n   &opt_console, &opt_console, 0, GET_BOOL, NO_ARG, 0, 0, 0,\n   0, 0, 0},\n  {\"core-file\", OPT_WANT_CORE, \"Write core on errors.\", 0, 0, 0, GET_NO_ARG,\n   NO_ARG, 0, 0, 0, 0, 0, 0},\n#ifdef DBUG_OFF\n  {\"debug\", '#', \"Built in DBUG debugger. Disabled in this build.\",\n   &current_dbug_option, &current_dbug_option, 0, GET_STR, OPT_ARG,\n   0, 0, 0, 0, 0, 0},\n#endif\n#ifdef HAVE_REPLICATION\n  {\"debug-abort-slave-event-count\", 0,\n   \"Option used by mysql-test for debugging and testing of replication.\",\n   &abort_slave_event_count,  &abort_slave_event_count,\n   0, GET_INT, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n#endif /* HAVE_REPLICATION */\n#ifndef DBUG_OFF\n  {\"debug-assert\", 0,\n   \"Allow DBUG_ASSERT() to invoke assert()\",\n   &my_assert, &my_assert,\n   0, GET_BOOL, OPT_ARG, 1, 0, 0, 0, 0, 0},\n  {\"debug-assert-on-error\", 0,\n   \"Do an assert in various functions if we get a fatal error\",\n   &my_assert_on_error, &my_assert_on_error,\n   0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0, 0},\n  {\"debug-assert-if-crashed-table\", 0,\n   \"Do an assert in handler::print_error() if we get a crashed table\",\n   &debug_assert_if_crashed_table, &debug_assert_if_crashed_table,\n   0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0, 0},\n#endif\n#ifdef HAVE_REPLICATION\n  {\"debug-disconnect-slave-event-count\", 0,\n   \"Option used by mysql-test for debugging and testing of replication.\",\n   &disconnect_slave_event_count, &disconnect_slave_event_count,\n   0, GET_INT, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n#endif /* HAVE_REPLICATION */\n  {\"debug-exit-info\", 'T', \"Used for debugging. Use at your own risk.\",\n   0, 0, 0, GET_LONG, OPT_ARG, 0, 0, 0, 0, 0, 0},\n  {\"debug-gdb\", 0,\n   \"Set up signals usable for debugging.\",\n   &opt_debugging, &opt_debugging,\n   0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0, 0},\n#ifdef HAVE_REPLICATION\n  {\"debug-max-binlog-dump-events\", 0,\n   \"Option used by mysql-test for debugging and testing of replication.\",\n   &max_binlog_dump_events, &max_binlog_dump_events, 0,\n   GET_INT, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n#endif /* HAVE_REPLICATION */\n  {\"debug-no-sync\", 0,\n   \"Disables system sync calls. Only for running tests or debugging!\",\n   &my_disable_sync, &my_disable_sync, 0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0, 0},\n#ifdef HAVE_REPLICATION\n  {\"debug-sporadic-binlog-dump-fail\", 0,\n   \"Option used by mysql-test for debugging and testing of replication.\",\n   &opt_sporadic_binlog_dump_fail,\n   &opt_sporadic_binlog_dump_fail, 0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0,\n   0},\n#endif /* HAVE_REPLICATION */\n#ifndef DBUG_OFF\n  {\"debug-assert-on-not-freed-memory\", 0,\n   \"Assert if we found problems with memory allocation\",\n   &debug_assert_on_not_freed_memory,\n   &debug_assert_on_not_freed_memory, 0, GET_BOOL, NO_ARG, 1, 0, 0, 0, 0,\n   0},\n#endif /* DBUG_OFF */\n  /* default-storage-engine should have \"MyISAM\" as def_value. Instead\n     of initializing it here it is done in init_common_variables() due\n     to a compiler bug in Sun Studio compiler. */\n  {\"default-storage-engine\", 0, \"The default storage engine for new tables\",\n   &default_storage_engine, 0, 0, GET_STR, REQUIRED_ARG,\n   0, 0, 0, 0, 0, 0 },\n  {\"default-tmp-storage-engine\", 0,\n    \"The default storage engine for user-created temporary tables\",\n   &default_tmp_storage_engine, 0, 0, GET_STR, REQUIRED_ARG,\n   0, 0, 0, 0, 0, 0 },\n  {\"default-time-zone\", 0, \"Set the default time zone.\",\n   &default_tz_name, &default_tz_name,\n   0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0 },\n#if defined(ENABLED_DEBUG_SYNC)\n  {\"debug-sync-timeout\", OPT_DEBUG_SYNC_TIMEOUT,\n   \"Enable the debug sync facility \"\n   \"and optionally specify a default wait timeout in seconds. \"\n   \"A zero value keeps the facility disabled.\",\n   &opt_debug_sync_timeout, 0,\n   0, GET_UINT, OPT_ARG, 0, 0, UINT_MAX, 0, 0, 0},\n#endif /* defined(ENABLED_DEBUG_SYNC) */\n#ifdef HAVE_OPENSSL\n  {\"des-key-file\", 0,\n   \"Load keys for des_encrypt() and des_encrypt from given file.\",\n   &des_key_file, &des_key_file, 0, GET_STR, REQUIRED_ARG,\n   0, 0, 0, 0, 0, 0},\n#endif /* HAVE_OPENSSL */\n#ifdef HAVE_STACKTRACE\n  {\"stack-trace\", 0 , \"Print a symbolic stack trace on failure\",\n   &opt_stack_trace, &opt_stack_trace, 0, GET_BOOL, NO_ARG, 1, 0, 0, 0, 0, 0},\n#endif /* HAVE_STACKTRACE */\n  {\"enforce-storage-engine\", 0, \"Force the use of a storage engine for new tables\",\n   &enforced_storage_engine, 0, 0, GET_STR, REQUIRED_ARG,\n   0, 0, 0, 0, 0, 0 },\n  {\"external-locking\", 0, \"Use system (external) locking (disabled by \"\n   \"default).  With this option enabled you can run myisamchk to test \"\n   \"(not repair) tables while the MySQL server is running. Disable with \"\n   \"--skip-external-locking.\", &opt_external_locking, &opt_external_locking,\n   0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0, 0},\n  /* We must always support the next option to make scripts like mysqltest\n     easier to do */\n  {\"flashback\", 0,\n   \"Setup the server to use flashback. This enables binary log in row mode and will enable extra logging for DDL's needed by flashback feature\",\n   &opt_support_flashback, &opt_support_flashback,\n   0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0, 0},\n  {\"gdb\", 0,\n   \"Set up signals usable for debugging. Deprecated, use --debug-gdb instead.\",\n   &opt_debugging, &opt_debugging,\n   0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0, 0},\n  {\"gtid-pos-auto-engines\", 0,\n   \"List of engines for which to automatically create a \"\n   \"mysql.gtid_slave_pos_ENGINE table, if a transaction using that engine \"\n   \"is replicated. This can be used to avoid introducing cross-engine \"\n   \"transactions, if engines are used different from that used by table \"\n   \"mysql.gtid_slave_pos\",\n   &gtid_pos_auto_engines, 0, 0, GET_STR, REQUIRED_ARG,\n   0, 0, 0, 0, 0, 0 },\n#ifdef HAVE_LARGE_PAGE_OPTION\n  {\"super-large-pages\", 0, \"Enable support for super large pages.\",\n   &opt_super_large_pages, &opt_super_large_pages, 0,\n   GET_BOOL, OPT_ARG, 0, 0, 1, 0, 1, 0},\n#endif\n  {\"language\", 'L',\n   \"Client error messages in given language. May be given as a full path. \"\n   \"Deprecated. Use --lc-messages-dir instead.\",\n   0, 0, 0,\n   GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"lc-messages\", 0,\n   \"Set the language used for the error messages.\",\n   &lc_messages, &lc_messages, 0, GET_STR, REQUIRED_ARG,\n   0, 0, 0, 0, 0, 0 },\n  {\"lc-time-names\", 0,\n   \"Set the language used for the month names and the days of the week.\",\n   &lc_time_names_name, &lc_time_names_name,\n   0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0 },\n  {\"log-basename\", OPT_LOG_BASENAME,\n   \"Basename for all log files and the .pid file. This sets all log file \"\n   \"names at once (in 'datadir') and is normally the only option you need \"\n   \"for specifying log files. Sets names for --log-bin, --log-bin-index, \"\n   \"--relay-log, --relay-log-index, --general-log-file, \"\n   \"--log-slow-query-log-file, --log-error-file, and --pid-file\",\n   &opt_log_basename, &opt_log_basename, 0, GET_STR, REQUIRED_ARG,\n   0, 0, 0, 0, 0, 0},\n  {\"log-bin\", OPT_BIN_LOG,\n   \"Log update queries in binary format. Optional argument should be name for \"\n   \"binary log. If not given \"\n   \"'datadir'/'log-basename'-bin or 'datadir'/mysql-bin will be used (the later if \"\n   \"--log-basename is not specified). We strongly recommend to use either \"\n   \"--log-basename or specify a filename to ensure that replication doesn't \"\n   \"stop if the real hostname of the computer changes.\",\n   &opt_bin_logname, &opt_bin_logname, 0, GET_STR,\n   OPT_ARG, 0, 0, 0, 0, 0, 0},\n  {\"log-bin-index\", 0,\n   \"File that holds the names for last binary log files.\",\n   &opt_binlog_index_name, &opt_binlog_index_name, 0, GET_STR,\n   REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"relay-log-index\", 0,\n   \"The location and name to use for the file that keeps a list of the last \"\n   \"relay logs\",\n   &opt_relaylog_index_name, &opt_relaylog_index_name, 0, GET_STR,\n   REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"log-isam\", OPT_ISAM_LOG, \"Log all MyISAM changes to file.\",\n   &myisam_log_filename, &myisam_log_filename, 0, GET_STR,\n   OPT_ARG, 0, 0, 0, 0, 0, 0},\n  {\"log-short-format\", 0,\n   \"Don't log extra information to update and slow-query logs.\",\n   &opt_short_log_format, &opt_short_log_format,\n   0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0, 0},\n  {\"log-tc\", 0,\n   \"Path to transaction coordinator log (used for transactions that affect \"\n   \"more than one storage engine, when binary log is disabled).\",\n   &opt_tc_log_file, &opt_tc_log_file, 0, GET_STR,\n   REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"master-info-file\", 0,\n   \"The location and name of the file that remembers the master and where \"\n   \"the I/O replication thread is in the master's binlogs. Defaults to \"\n   \"master.info\",\n   &master_info_file, &master_info_file, 0, GET_STR,\n   REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"master-retry-count\", 0,\n   \"The number of tries the slave will make to connect to the master before giving up.\",\n   &master_retry_count, &master_retry_count, 0, GET_ULONG,\n   REQUIRED_ARG, 3600*24, 0, 0, 0, 0, 0},\n#ifdef HAVE_REPLICATION\n  {\"init-rpl-role\", 0, \"Set the replication role\",\n   &rpl_status, &rpl_status, &rpl_role_typelib,\n   GET_ENUM, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n#endif /* HAVE_REPLICATION */\n  {\"memlock\", 0, \"Lock mysqld in memory.\", &locked_in_memory,\n   &locked_in_memory, 0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0, 0},\n  {\"old-style-user-limits\", 0,\n   \"Enable old-style user limits (before 5.0.3, user resources were counted \"\n   \"per each user+host vs. per account).\",\n   &opt_old_style_user_limits, &opt_old_style_user_limits,\n   0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0, 0},\n  {\"port-open-timeout\", 0,\n   \"Maximum time in seconds to wait for the port to become free. \"\n   \"(Default: No wait).\", &mysqld_port_timeout, &mysqld_port_timeout, 0,\n   GET_UINT, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"replicate-do-db\", OPT_REPLICATE_DO_DB,\n   \"Tells the slave thread to restrict replication to the specified database. \"\n   \"To specify more than one database, use the directive multiple times, \"\n   \"once for each database. Note that this will only work if you do not use \"\n   \"cross-database queries such as UPDATE some_db.some_table SET foo='bar' \"\n   \"while having selected a different or no database. If you need cross \"\n   \"database updates to work, make sure you have 3.23.28 or later, and use \"\n   \"replicate-wild-do-table=db_name.%.\",\n   0, 0, 0, GET_STR | GET_ASK_ADDR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"replicate-do-table\", OPT_REPLICATE_DO_TABLE,\n   \"Tells the slave thread to restrict replication to the specified table. \"\n   \"To specify more than one table, use the directive multiple times, once \"\n   \"for each table. This will work for cross-database updates, in contrast \"\n   \"to replicate-do-db.\", 0, 0, 0, GET_STR | GET_ASK_ADDR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"replicate-ignore-db\", OPT_REPLICATE_IGNORE_DB,\n   \"Tells the slave thread to not replicate to the specified database. To \"\n   \"specify more than one database to ignore, use the directive multiple \"\n   \"times, once for each database. This option will not work if you use \"\n   \"cross database updates. If you need cross database updates to work, \"\n   \"make sure you have 3.23.28 or later, and use replicate-wild-ignore-\"\n   \"table=db_name.%. \", 0, 0, 0, GET_STR | GET_ASK_ADDR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"replicate-ignore-table\", OPT_REPLICATE_IGNORE_TABLE,\n   \"Tells the slave thread to not replicate to the specified table. To specify \"\n   \"more than one table to ignore, use the directive multiple times, once for \"\n   \"each table. This will work for cross-database updates, in contrast to \"\n   \"replicate-ignore-db.\", 0, 0, 0, GET_STR | GET_ASK_ADDR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"replicate-rewrite-db\", OPT_REPLICATE_REWRITE_DB,\n   \"Updates to a database with a different name than the original. Example: \"\n   \"replicate-rewrite-db=master_db_name->slave_db_name.\",\n   0, 0, 0, GET_STR | GET_ASK_ADDR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n#ifdef HAVE_REPLICATION\n  {\"replicate-same-server-id\", 0,\n   \"In replication, if set to 1, do not skip events having our server id. \"\n   \"Default value is 0 (to break infinite loops in circular replication). \"\n   \"Can't be set to 1 if --log-slave-updates is used.\",\n   &replicate_same_server_id, &replicate_same_server_id,\n   0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0, 0},\n#endif\n  {\"replicate-wild-do-table\", OPT_REPLICATE_WILD_DO_TABLE,\n   \"Tells the slave thread to restrict replication to the tables that match \"\n   \"the specified wildcard pattern. To specify more than one table, use the \"\n   \"directive multiple times, once for each table. This will work for cross-\"\n   \"database updates. Example: replicate-wild-do-table=foo%.bar% will \"\n   \"replicate only updates to tables in all databases that start with foo \"\n   \"and whose table names start with bar.\",\n   0, 0, 0, GET_STR | GET_ASK_ADDR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"replicate-wild-ignore-table\", OPT_REPLICATE_WILD_IGNORE_TABLE,\n   \"Tells the slave thread to not replicate to the tables that match the \"\n   \"given wildcard pattern. To specify more than one table to ignore, use \"\n   \"the directive multiple times, once for each table. This will work for \"\n   \"cross-database updates. Example: replicate-wild-ignore-table=foo%.bar% \"\n   \"will not do updates to tables in databases that start with foo and whose \"\n   \"table names start with bar.\",\n   0, 0, 0, GET_STR | GET_ASK_ADDR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"safe-mode\", OPT_SAFE, \"Skip some optimize stages (for testing). Deprecated.\",\n   0, 0, 0, GET_NO_ARG, NO_ARG, 0, 0, 0, 0, 0, 0},\n  {\"safe-user-create\", 0,\n   \"Don't allow new user creation by the user who has no write privileges to the mysql.user table.\",\n   &opt_safe_user_create, &opt_safe_user_create, 0, GET_BOOL,\n   NO_ARG, 0, 0, 0, 0, 0, 0},\n  {\"show-slave-auth-info\", 0,\n   \"Show user and password in SHOW SLAVE HOSTS on this master.\",\n   &opt_show_slave_auth_info, &opt_show_slave_auth_info, 0,\n   GET_BOOL, NO_ARG, 0, 0, 0, 0, 0, 0},\n  {\"silent-startup\", OPT_SILENT, \"Don't print [Note] to the error log during startup.\",\n   &opt_silent_startup, &opt_silent_startup, 0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0, 0},\n  {\"skip-bdb\", OPT_DEPRECATED_OPTION,\n   \"Deprecated option; Exist only for compatibility with old my.cnf files\",\n   0, 0, 0, GET_NO_ARG, NO_ARG, 0, 0, 0, 0, 0, 0},\n#ifndef DISABLE_GRANT_OPTIONS\n  {\"skip-grant-tables\", 0,\n   \"Start without grant tables. This gives all users FULL ACCESS to all tables.\",\n   &opt_noacl, &opt_noacl, 0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0,\n   0},\n#endif\n  {\"skip-host-cache\", OPT_SKIP_HOST_CACHE, \"Don't cache host names.\", 0, 0, 0,\n   GET_NO_ARG, NO_ARG, 0, 0, 0, 0, 0, 0},\n  {\"skip-slave-start\", 0,\n   \"If set, slave is not autostarted.\", &opt_skip_slave_start,\n   &opt_skip_slave_start, 0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0, 0},\n#ifdef HAVE_REPLICATION\n  {\"slave-parallel-mode\", OPT_SLAVE_PARALLEL_MODE,\n   \"Controls what transactions are applied in parallel when using \"\n   \"--slave-parallel-threads. Possible values: \\\"optimistic\\\" tries to \"\n   \"apply most transactional DML in parallel, and handles any conflicts \"\n   \"with rollback and retry. \\\"conservative\\\" limits parallelism in an \"\n   \"effort to avoid any conflicts. \\\"aggressive\\\" tries to maximise the \"\n   \"parallelism, possibly at the cost of increased conflict rate. \"\n   \"\\\"minimal\\\" only parallelizes the commit steps of transactions. \"\n   \"\\\"none\\\" disables parallel apply completely.\",\n   &opt_slave_parallel_mode, &opt_slave_parallel_mode,\n   &slave_parallel_mode_typelib, GET_ENUM | GET_ASK_ADDR, REQUIRED_ARG,\n   SLAVE_PARALLEL_CONSERVATIVE, 0, 0, 0, 0, 0},\n#endif\n#if defined(_WIN32) && !defined(EMBEDDED_LIBRARY)\n  {\"slow-start-timeout\", 0,\n   \"Maximum number of milliseconds that the service control manager should wait \"\n   \"before trying to kill the windows service during startup\"\n   \"(Default: 15000).\", &slow_start_timeout, &slow_start_timeout, 0,\n   GET_ULONG, REQUIRED_ARG, 15000, 0, 0, 0, 0, 0},\n#endif\n#ifdef HAVE_OPENSSL\n  {\"ssl\", 0,\n   \"Enable SSL for connection (automatically enabled if an ssl option is used).\",\n   &opt_use_ssl, &opt_use_ssl, 0, GET_BOOL, OPT_ARG, 0, 0, 0,\n   0, 0, 0},\n#endif\n#ifdef __WIN__\n  {\"standalone\", 0,\n  \"Dummy option to start as a standalone program (NT).\", 0, 0, 0, GET_NO_ARG,\n   NO_ARG, 0, 0, 0, 0, 0, 0},\n#endif\n  {\"symbolic-links\", 's', \"Enable symbolic link support.\",\n   &my_use_symdir, &my_use_symdir, 0, GET_BOOL, NO_ARG,\n   /*\n     The system call realpath() produces warnings under valgrind and\n     purify. These are not suppressed: instead we disable symlinks\n     option if compiled with valgrind support.\n     Also disable by default on Windows, due to high overhead for checking .sym \n     files.\n   */\n   IF_VALGRIND(0,IF_WIN(0,1)), 0, 0, 0, 0, 0},\n  {\"sysdate-is-now\", 0,\n   \"Non-default option to alias SYSDATE() to NOW() to make it safe-replicable. \"\n   \"Since 5.0, SYSDATE() returns a `dynamic' value different for different \"\n   \"invocations, even within the same statement.\",\n   &global_system_variables.sysdate_is_now,\n   0, 0, GET_BOOL, NO_ARG, 0, 0, 1, 0, 1, 0},\n  {\"tc-heuristic-recover\", 0,\n   \"Decision to use in heuristic recover process\",\n   &tc_heuristic_recover, &tc_heuristic_recover,\n   &tc_heuristic_recover_typelib, GET_ENUM, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"temp-pool\", 0,\n#if (ENABLE_TEMP_POOL)\n   \"Using this option will cause most temporary files created to use a small \"\n   \"set of names, rather than a unique name for each new file.\",\n#else\n   \"This option is ignored on this OS.\",\n#endif\n   &use_temp_pool, &use_temp_pool, 0, GET_BOOL, NO_ARG, 1,\n   0, 0, 0, 0, 0},\n  {\"transaction-isolation\", 0,\n   \"Default transaction isolation level\",\n   &global_system_variables.tx_isolation,\n   &global_system_variables.tx_isolation, &tx_isolation_typelib,\n   GET_ENUM, REQUIRED_ARG, ISO_REPEATABLE_READ, 0, 0, 0, 0, 0},\n  {\"transaction-read-only\", 0,\n   \"Default transaction access mode. \"\n   \"True if transactions are read-only.\",\n   &global_system_variables.tx_read_only,\n   &global_system_variables.tx_read_only, 0,\n   GET_BOOL, OPT_ARG, 0, 0, 0, 0, 0, 0},\n  {\"user\", 'u', \"Run mysqld daemon as user.\", 0, 0, 0, GET_STR, REQUIRED_ARG,\n   0, 0, 0, 0, 0, 0},\n  {\"verbose\", 'v', \"Used with --help option for detailed help.\",\n   &opt_verbose, &opt_verbose, 0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0, 0},\n  {\"version\", 'V', \"Output version information and exit.\", 0, 0, 0, GET_STR,\n   OPT_ARG, 0, 0, 0, 0, 0, 0},\n  {\"plugin-load\", OPT_PLUGIN_LOAD,\n   \"Semicolon-separated list of plugins to load, where each plugin is \"\n   \"specified as ether a plugin_name=library_file pair or only a library_file. \"\n   \"If the latter case, all plugins from a given library_file will be loaded.\",\n   0, 0, 0,\n   GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"plugin-load-add\", OPT_PLUGIN_LOAD_ADD,\n   \"Optional semicolon-separated list of plugins to load. This option adds \"\n   \"to the list specified by --plugin-load in an incremental way. \"\n   \"It can be specified many times, adding more plugins every time.\",\n   0, 0, 0,\n    GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n  {\"table_cache\", 0, \"Deprecated; use --table-open-cache instead.\",\n   &tc_size, &tc_size, 0, GET_ULONG,\n   REQUIRED_ARG, TABLE_OPEN_CACHE_DEFAULT, 1, 512*1024L, 0, 1, 0},\n#ifdef WITH_WSREP\n  {\"wsrep-new-cluster\", 0, \"Bootstrap a cluster. It works by overriding the \"\n   \"current value of wsrep_cluster_address. It is recommended not to add this \"\n   \"option to the config file as this will trigger bootstrap on every server \"\n   \"start.\", &wsrep_new_cluster, &wsrep_new_cluster, 0, GET_BOOL, NO_ARG,\n   0, 0, 0, 0, 0, 0},\n#endif\n\n  /* The following options exist in 5.6 but not in 10.0 */\n  MYSQL_COMPATIBILITY_OPTION(\"log-raw\"),\n  MYSQL_COMPATIBILITY_OPTION(\"log-bin-use-v1-row-events\"),\n  MYSQL_TO_BE_IMPLEMENTED_OPTION(\"default-authentication-plugin\"),\n  MYSQL_COMPATIBILITY_OPTION(\"binlog-max-flush-queue-time\"),\n  MYSQL_COMPATIBILITY_OPTION(\"master-info-repository\"),\n  MYSQL_COMPATIBILITY_OPTION(\"relay-log-info-repository\"),\n  MYSQL_SUGGEST_ANALOG_OPTION(\"binlog-rows-query-log-events\", \"--binlog-annotate-row-events\"),\n  MYSQL_COMPATIBILITY_OPTION(\"binlog-order-commits\"),\n  MYSQL_TO_BE_IMPLEMENTED_OPTION(\"log-throttle-queries-not-using-indexes\"),\n  MYSQL_TO_BE_IMPLEMENTED_OPTION(\"end-markers-in-json\"),\n  MYSQL_TO_BE_IMPLEMENTED_OPTION(\"optimizer-trace-features\"),     // OPTIMIZER_TRACE\n  MYSQL_TO_BE_IMPLEMENTED_OPTION(\"optimizer-trace-offset\"),       // OPTIMIZER_TRACE\n  MYSQL_TO_BE_IMPLEMENTED_OPTION(\"optimizer-trace-limit\"),        // OPTIMIZER_TRACE\n  MYSQL_COMPATIBILITY_OPTION(\"server-id-bits\"),\n  MYSQL_TO_BE_IMPLEMENTED_OPTION(\"slave-rows-search-algorithms\"), // HAVE_REPLICATION\n  MYSQL_TO_BE_IMPLEMENTED_OPTION(\"slave-allow-batching\"),         // HAVE_REPLICATION\n  MYSQL_COMPATIBILITY_OPTION(\"slave-checkpoint-period\"),      // HAVE_REPLICATION\n  MYSQL_COMPATIBILITY_OPTION(\"slave-checkpoint-group\"),       // HAVE_REPLICATION\n  MYSQL_SUGGEST_ANALOG_OPTION(\"slave-pending-jobs-size-max\", \"--slave-parallel-max-queued\"),  // HAVE_REPLICATION\n  MYSQL_TO_BE_IMPLEMENTED_OPTION(\"sha256-password-private-key-path\"), // HAVE_OPENSSL\n  MYSQL_TO_BE_IMPLEMENTED_OPTION(\"sha256-password-public-key-path\"),  // HAVE_OPENSSL\n\n  /* The following options exist in 5.5 and 5.6 but not in 10.0 */\n  MYSQL_SUGGEST_ANALOG_OPTION(\"abort-slave-event-count\", \"--debug-abort-slave-event-count\"),\n  MYSQL_SUGGEST_ANALOG_OPTION(\"disconnect-slave-event-count\", \"--debug-disconnect-slave-event-count\"),\n  MYSQL_SUGGEST_ANALOG_OPTION(\"exit-info\", \"--debug-exit-info\"),\n  MYSQL_SUGGEST_ANALOG_OPTION(\"max-binlog-dump-events\", \"--debug-max-binlog-dump-events\"),\n  MYSQL_SUGGEST_ANALOG_OPTION(\"sporadic-binlog-dump-fail\", \"--debug-sporadic-binlog-dump-fail\"),\n  MYSQL_COMPATIBILITY_OPTION(\"new\"),\n  MYSQL_COMPATIBILITY_OPTION(\"show_compatibility_56\"),\n\n  /* The following options were added after 5.6.10 */\n  MYSQL_TO_BE_IMPLEMENTED_OPTION(\"rpl-stop-slave-timeout\"),\n  MYSQL_TO_BE_IMPLEMENTED_OPTION(\"validate-user-plugins\") // NO_EMBEDDED_ACCESS_CHECKS\n};\n\nstatic int show_queries(THD *thd, SHOW_VAR *var, char *buff,\n                        enum enum_var_type scope)\n{\n  var->type= SHOW_LONGLONG;\n  var->value= &thd->query_id;\n  return 0;\n}\n\n\nstatic int show_net_compression(THD *thd, SHOW_VAR *var, char *buff,\n                                enum enum_var_type scope)\n{\n  var->type= SHOW_MY_BOOL;\n  var->value= &thd->net.compress;\n  return 0;\n}\n\nstatic int show_starttime(THD *thd, SHOW_VAR *var, char *buff,\n                          enum enum_var_type scope)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  *((long *)buff)= (long) (thd->query_start() - server_start_time);\n  return 0;\n}\n\n#ifdef ENABLED_PROFILING\nstatic int show_flushstatustime(THD *thd, SHOW_VAR *var, char *buff,\n                                enum enum_var_type scope)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  *((long *)buff)= (long) (thd->query_start() - flush_status_time);\n  return 0;\n}\n#endif\n\n#ifdef HAVE_REPLICATION\nstatic int show_rpl_status(THD *thd, SHOW_VAR *var, char *buff,\n                           enum enum_var_type scope)\n{\n  var->type= SHOW_CHAR;\n  var->value= const_cast<char*>(rpl_status_type[(int)rpl_status]);\n  return 0;\n}\n\nstatic int show_slave_running(THD *thd, SHOW_VAR *var, char *buff,\n                              enum enum_var_type scope)\n{\n  Master_info *mi= NULL;\n  bool UNINIT_VAR(tmp);\n\n  var->type= SHOW_MY_BOOL;\n  var->value= buff;\n\n  if ((mi= get_master_info(&thd->variables.default_master_connection,\n                           Sql_condition::WARN_LEVEL_NOTE)))\n  {\n    tmp= (my_bool) (mi->slave_running == MYSQL_SLAVE_RUN_READING &&\n                    mi->rli.slave_running != MYSQL_SLAVE_NOT_RUN);\n    mi->release();\n  }\n  if (mi)\n    *((my_bool *)buff)= tmp;\n  else\n    var->type= SHOW_UNDEF;\n  return 0;\n}\n\n\n/* How many slaves are connected to this master */\n\nstatic int show_slaves_connected(THD *thd, SHOW_VAR *var, char *buff)\n{\n\n  var->type= SHOW_LONGLONG;\n  var->value= buff;\n  *((longlong*) buff)= uint32_t(binlog_dump_thread_count);\n  return 0;\n}\n\n\n/* How many masters this slave is connected to */\n\n\nstatic int show_slaves_running(THD *thd, SHOW_VAR *var, char *buff)\n{\n  var->type= SHOW_LONGLONG;\n  var->value= buff;\n\n  *((longlong *)buff)= any_slave_sql_running(false);\n\n  return 0;\n}\n\n\nstatic int show_slave_received_heartbeats(THD *thd, SHOW_VAR *var, char *buff,\n                                          enum enum_var_type scope)\n{\n  Master_info *mi;\n\n  var->type= SHOW_LONGLONG;\n  var->value= buff;\n\n  if ((mi= get_master_info(&thd->variables.default_master_connection,\n                           Sql_condition::WARN_LEVEL_NOTE)))\n  {\n    *((longlong *)buff)= mi->received_heartbeats;\n    mi->release();\n  }\n  else\n    var->type= SHOW_UNDEF;\n  return 0;\n}\n\n\nstatic int show_heartbeat_period(THD *thd, SHOW_VAR *var, char *buff,\n                                 enum enum_var_type scope)\n{\n  Master_info *mi;\n\n  var->type= SHOW_CHAR;\n  var->value= buff;\n\n  if ((mi= get_master_info(&thd->variables.default_master_connection,\n                           Sql_condition::WARN_LEVEL_NOTE)))\n  {\n    sprintf(buff, \"%.3f\", mi->heartbeat_period);\n    mi->release();\n  }\n  else\n    var->type= SHOW_UNDEF;\n  return 0;\n}\n\n\n#endif /* HAVE_REPLICATION */\n\nstatic int show_open_tables(THD *thd, SHOW_VAR *var, char *buff,\n                            enum enum_var_type scope)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  *((long *) buff)= (long) tc_records();\n  return 0;\n}\n\nstatic int show_prepared_stmt_count(THD *thd, SHOW_VAR *var, char *buff,\n                                    enum enum_var_type scope)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  mysql_mutex_lock(&LOCK_prepared_stmt_count);\n  *((long *)buff)= (long)prepared_stmt_count;\n  mysql_mutex_unlock(&LOCK_prepared_stmt_count);\n  return 0;\n}\n\nstatic int show_table_definitions(THD *thd, SHOW_VAR *var, char *buff,\n                                  enum enum_var_type scope)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  *((long *) buff)= (long) tdc_records();\n  return 0;\n}\n\n\nstatic int show_flush_commands(THD *thd, SHOW_VAR *var, char *buff,\n                               enum enum_var_type scope)\n{\n  var->type= SHOW_LONGLONG;\n  var->value= buff;\n  *((longlong *) buff)= (longlong)tdc_refresh_version();\n  return 0;\n}\n\n\n#if defined(HAVE_OPENSSL) && !defined(EMBEDDED_LIBRARY)\n\n/*\n   Functions relying on SSL\n   Note: In the show_ssl_* functions, we need to check if we have a\n         valid vio-object since this isn't always true, specifically\n         when session_status or global_status is requested from\n         inside an Event.\n */\n\nstatic int show_ssl_get_version(THD *thd, SHOW_VAR *var, char *buff,\n                                enum enum_var_type scope)\n{\n  var->type= SHOW_CHAR;\n  if( thd->vio_ok() && thd->net.vio->ssl_arg )\n    var->value= const_cast<char*>(SSL_get_version((SSL*) thd->net.vio->ssl_arg));\n  else\n    var->value= const_cast<char*>(\"\");\n  return 0;\n}\n\nstatic int show_ssl_get_default_timeout(THD *thd, SHOW_VAR *var, char *buff,\n                                        enum enum_var_type scope)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  if( thd->vio_ok() && thd->net.vio->ssl_arg )\n    *((long *)buff)= (long)SSL_get_default_timeout((SSL*)thd->net.vio->ssl_arg);\n  else\n    *((long *)buff)= 0;\n  return 0;\n}\n\nstatic int show_ssl_get_verify_mode(THD *thd, SHOW_VAR *var, char *buff,\n                                    enum enum_var_type scope)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n#ifndef HAVE_WOLFSSL\n  if( thd->net.vio && thd->net.vio->ssl_arg )\n    *((long *)buff)= (long)SSL_get_verify_mode((SSL*)thd->net.vio->ssl_arg);\n  else\n    *((long *)buff)= 0;\n#else\n  *((long *)buff)= 0;\n#endif\n  return 0;\n}\n\nstatic int show_ssl_get_verify_depth(THD *thd, SHOW_VAR *var, char *buff,\n                                     enum enum_var_type scope)\n{\n  var->type= SHOW_LONG;\n  var->value= buff;\n  if( thd->vio_ok() && thd->net.vio->ssl_arg )\n    *((long *)buff)= (long)SSL_get_verify_depth((SSL*)thd->net.vio->ssl_arg);\n  else\n    *((long *)buff)= 0;\n\n  return 0;\n}\n\nstatic int show_ssl_get_cipher(THD *thd, SHOW_VAR *var, char *buff,\n                               enum enum_var_type scope)\n{\n  var->type= SHOW_CHAR;\n  if( thd->vio_ok() && thd->net.vio->ssl_arg )\n    var->value= const_cast<char*>(SSL_get_cipher((SSL*) thd->net.vio->ssl_arg));\n  else\n    var->value= const_cast<char*>(\"\");\n  return 0;\n}\n\nstatic int show_ssl_get_cipher_list(THD *thd, SHOW_VAR *var, char *buff,\n                                    enum enum_var_type scope)\n{\n  var->type= SHOW_CHAR;\n  var->value= buff;\n  if (thd->vio_ok() && thd->net.vio->ssl_arg)\n  {\n    int i;\n    const char *p;\n    char *end= buff + SHOW_VAR_FUNC_BUFF_SIZE;\n    for (i=0; (p= SSL_get_cipher_list((SSL*) thd->net.vio->ssl_arg,i)) &&\n               buff < end; i++)\n    {\n      buff= strnmov(buff, p, end-buff-1);\n      *buff++= ':';\n    }\n    if (i)\n      buff--;\n  }\n  *buff=0;\n  return 0;\n}\n\n#define SHOW_FNAME(name)                        \\\n    rpl_semi_sync_master_show_##name\n\n#define DEF_SHOW_FUNC(name, show_type)                                       \\\n    static  int SHOW_FNAME(name)(MYSQL_THD thd, SHOW_VAR *var, char *buff)   \\\n    {                                                                        \\\n      repl_semisync_master.set_export_stats();                                 \\\n      var->type= show_type;                                                  \\\n      var->value= (char *)&rpl_semi_sync_master_##name;                      \\\n      return 0;                                                              \\\n    }\n\nDEF_SHOW_FUNC(status, SHOW_BOOL)\nDEF_SHOW_FUNC(clients, SHOW_LONG)\nDEF_SHOW_FUNC(wait_sessions, SHOW_LONG)\nDEF_SHOW_FUNC(trx_wait_time, SHOW_LONGLONG)\nDEF_SHOW_FUNC(trx_wait_num, SHOW_LONGLONG)\nDEF_SHOW_FUNC(net_wait_time, SHOW_LONGLONG)\nDEF_SHOW_FUNC(net_wait_num, SHOW_LONGLONG)\nDEF_SHOW_FUNC(avg_net_wait_time, SHOW_LONG)\nDEF_SHOW_FUNC(avg_trx_wait_time, SHOW_LONG)\n\n\nstatic char *\nmy_asn1_time_to_string(const ASN1_TIME *time, char *buf, size_t len)\n{\n  int n_read;\n  char *res= NULL;\n  BIO *bio= BIO_new(BIO_s_mem());\n\n  if (bio == NULL)\n    return NULL;\n\n  if (!ASN1_TIME_print(bio, const_cast<ASN1_TIME*>(time)))\n    goto end;\n\n  n_read= BIO_read(bio, buf, (int) (len - 1));\n\n  if (n_read > 0)\n  {\n    buf[n_read]= 0;\n    res= buf;\n  }\n\nend:\n  BIO_free(bio);\n  return res;\n}\n\n\n/**\n  Handler function for the 'ssl_get_server_not_before' variable\n\n  @param      thd  the mysql thread structure\n  @param      var  the data for the variable\n  @param[out] buf  the string to put the value of the variable into\n\n  @return          status\n  @retval     0    success\n*/\n\nstatic int\nshow_ssl_get_server_not_before(THD *thd, SHOW_VAR *var, char *buff,\n                               enum enum_var_type scope)\n{\n  var->type= SHOW_CHAR;\n  if(thd->vio_ok() && thd->net.vio->ssl_arg)\n  {\n    SSL *ssl= (SSL*) thd->net.vio->ssl_arg;\n    X509 *cert= SSL_get_certificate(ssl);\n    const ASN1_TIME *not_before= X509_get0_notBefore(cert);\n\n    var->value= my_asn1_time_to_string(not_before, buff,\n                                       SHOW_VAR_FUNC_BUFF_SIZE);\n    if (!var->value)\n      return 1;\n    var->value= buff;\n  }\n  else\n    var->value= empty_c_string;\n  return 0;\n}\n\n\n/**\n  Handler function for the 'ssl_get_server_not_after' variable\n\n  @param      thd  the mysql thread structure\n  @param      var  the data for the variable\n  @param[out] buf  the string to put the value of the variable into\n\n  @return          status\n  @retval     0    success\n*/\n\nstatic int\nshow_ssl_get_server_not_after(THD *thd, SHOW_VAR *var, char *buff,\n                              enum enum_var_type scope)\n{\n  var->type= SHOW_CHAR;\n  if(thd->vio_ok() && thd->net.vio->ssl_arg)\n  {\n    SSL *ssl= (SSL*) thd->net.vio->ssl_arg;\n    X509 *cert= SSL_get_certificate(ssl);\n    const ASN1_TIME *not_after= X509_get0_notAfter(cert);\n\n    var->value= my_asn1_time_to_string(not_after, buff,\n                                       SHOW_VAR_FUNC_BUFF_SIZE);\n    if (!var->value)\n      return 1;\n  }\n  else\n    var->value= empty_c_string;\n  return 0;\n}\n\n#endif /* HAVE_OPENSSL && !EMBEDDED_LIBRARY */\n\nstatic int show_default_keycache(THD *thd, SHOW_VAR *var, char *buff,\n                                 enum enum_var_type scope)\n{\n  struct st_data {\n    KEY_CACHE_STATISTICS stats;\n    SHOW_VAR var[9];\n  } *data;\n  SHOW_VAR *v;\n\n  data=(st_data *)buff;\n  v= data->var;\n\n  var->type= SHOW_ARRAY;\n  var->value= v;\n\n  get_key_cache_statistics(dflt_key_cache, 0, &data->stats);\n\n#define set_one_keycache_var(X,Y)       \\\n  v->name= X;                           \\\n  v->type= SHOW_LONGLONG;               \\\n  v->value= &data->stats.Y;      \\\n  v++;\n\n  set_one_keycache_var(\"blocks_not_flushed\", blocks_changed);\n  set_one_keycache_var(\"blocks_unused\",      blocks_unused);\n  set_one_keycache_var(\"blocks_used\",        blocks_used);\n  set_one_keycache_var(\"blocks_warm\",        blocks_warm);\n  set_one_keycache_var(\"read_requests\",      read_requests);\n  set_one_keycache_var(\"reads\",              reads);\n  set_one_keycache_var(\"write_requests\",     write_requests);\n  set_one_keycache_var(\"writes\",             writes);\n\n  v->name= 0;\n\n  DBUG_ASSERT((char*)(v+1) <= buff + SHOW_VAR_FUNC_BUFF_SIZE);\n\n#undef set_one_keycache_var\n\n  return 0;\n}\n\n\nstatic int show_memory_used(THD *thd, SHOW_VAR *var, char *buff,\n                            struct system_status_var *status_var,\n                            enum enum_var_type scope)\n{\n  var->type= SHOW_LONGLONG;\n  var->value= buff;\n  if (scope == OPT_GLOBAL)\n    *(longlong*) buff= (status_var->global_memory_used +\n                        status_var->local_memory_used);\n  else\n    *(longlong*) buff= status_var->local_memory_used;\n  return 0;\n}\n\n\n#ifndef DBUG_OFF\nstatic int debug_status_func(THD *thd, SHOW_VAR *var, char *buff,\n                             enum enum_var_type scope)\n{\n#define add_var(X,Y,Z)                  \\\n  v->name= X;                           \\\n  v->value= (char*)Y;                   \\\n  v->type= Z;                           \\\n  v++;\n\n  var->type= SHOW_ARRAY;\n  var->value= buff;\n\n  SHOW_VAR *v= (SHOW_VAR *)buff;\n\n  if (_db_keyword_(0, \"role_merge_stats\", 1))\n  {\n    static SHOW_VAR roles[]= {\n      {\"global\",  &role_global_merges,  SHOW_ULONG},\n      {\"db\",      &role_db_merges,      SHOW_ULONG},\n      {\"table\",   &role_table_merges,   SHOW_ULONG},\n      {\"column\",  &role_column_merges,  SHOW_ULONG},\n      {\"routine\", &role_routine_merges, SHOW_ULONG},\n      {NullS, NullS, SHOW_LONG}\n    };\n\n    add_var(\"role_merges\", roles, SHOW_ARRAY);\n  }\n\n  v->name= 0;\n\n#undef add_var\n\n  return 0;\n}\n#endif\n\n#ifdef HAVE_POOL_OF_THREADS\nint show_threadpool_idle_threads(THD *thd, SHOW_VAR *var, char *buff,\n                                 enum enum_var_type scope)\n{\n  var->type= SHOW_INT;\n  var->value= buff;\n  *(int *)buff= tp_get_idle_thread_count(); \n  return 0;\n}\n#endif\n\n/*\n  Variables shown by SHOW STATUS in alphabetical order\n*/\n\nSHOW_VAR status_vars[]= {\n  {\"Aborted_clients\",          (char*) &aborted_threads,        SHOW_LONG},\n  {\"Aborted_connects\",         (char*) &aborted_connects,       SHOW_LONG},\n  {\"Aborted_connects_preauth\", (char*) &aborted_connects_preauth, SHOW_LONG},\n  {\"Acl\",                      (char*) acl_statistics,          SHOW_ARRAY},\n  {\"Access_denied_errors\",     (char*) offsetof(STATUS_VAR, access_denied_errors), SHOW_LONG_STATUS},\n  {\"Binlog_bytes_written\",     (char*) offsetof(STATUS_VAR, binlog_bytes_written), SHOW_LONGLONG_STATUS},\n  {\"Binlog_cache_disk_use\",    (char*) &binlog_cache_disk_use,  SHOW_LONG},\n  {\"Binlog_cache_use\",         (char*) &binlog_cache_use,       SHOW_LONG},\n  {\"Binlog_stmt_cache_disk_use\",(char*) &binlog_stmt_cache_disk_use,  SHOW_LONG},\n  {\"Binlog_stmt_cache_use\",    (char*) &binlog_stmt_cache_use,       SHOW_LONG},\n  {\"Busy_time\",                (char*) offsetof(STATUS_VAR, busy_time), SHOW_DOUBLE_STATUS},\n  {\"Bytes_received\",           (char*) offsetof(STATUS_VAR, bytes_received), SHOW_LONGLONG_STATUS},\n  {\"Bytes_sent\",               (char*) offsetof(STATUS_VAR, bytes_sent), SHOW_LONGLONG_STATUS},\n  {\"Column_compressions\",      (char*) offsetof(STATUS_VAR, column_compressions), SHOW_LONG_STATUS},\n  {\"Column_decompressions\",    (char*) offsetof(STATUS_VAR, column_decompressions), SHOW_LONG_STATUS},\n  {\"Com\",                      (char*) com_status_vars, SHOW_ARRAY},\n  {\"Compression\",              (char*) &show_net_compression, SHOW_SIMPLE_FUNC},\n  {\"Connections\",              (char*) &global_thread_id,         SHOW_LONG_NOFLUSH},\n  {\"Connection_errors_accept\", (char*) &connection_errors_accept, SHOW_LONG},\n  {\"Connection_errors_internal\", (char*) &connection_errors_internal, SHOW_LONG},\n  {\"Connection_errors_max_connections\", (char*) &connection_errors_max_connection, SHOW_LONG},\n  {\"Connection_errors_peer_address\", (char*) &connection_errors_peer_addr, SHOW_LONG},\n  {\"Connection_errors_select\", (char*) &connection_errors_select, SHOW_LONG},\n  {\"Connection_errors_tcpwrap\", (char*) &connection_errors_tcpwrap, SHOW_LONG},\n  {\"Cpu_time\",                 (char*) offsetof(STATUS_VAR, cpu_time), SHOW_DOUBLE_STATUS},\n  {\"Created_tmp_disk_tables\",  (char*) offsetof(STATUS_VAR, created_tmp_disk_tables_), SHOW_LONG_STATUS},\n  {\"Created_tmp_files\",\t       (char*) &my_tmp_file_created,\tSHOW_LONG},\n  {\"Created_tmp_tables\",       (char*) offsetof(STATUS_VAR, created_tmp_tables_), SHOW_LONG_STATUS},\n#ifndef DBUG_OFF\n  {\"Debug\",                    (char*) &debug_status_func,  SHOW_FUNC},\n#endif\n  {\"Delayed_errors\",           (char*) &delayed_insert_errors,  SHOW_LONG},\n  {\"Delayed_insert_threads\",   (char*) &delayed_insert_threads, SHOW_LONG_NOFLUSH},\n  {\"Delayed_writes\",           (char*) &delayed_insert_writes,  SHOW_LONG},\n  {\"Delete_scan\",\t       (char*) offsetof(STATUS_VAR, delete_scan_count), SHOW_LONG_STATUS},\n  {\"Empty_queries\",            (char*) offsetof(STATUS_VAR, empty_queries), SHOW_LONG_STATUS},\n  {\"Executed_events\",          (char*) &executed_events, SHOW_LONG_NOFLUSH },\n  {\"Executed_triggers\",        (char*) offsetof(STATUS_VAR, executed_triggers), SHOW_LONG_STATUS},\n  {\"Feature_check_constraint\", (char*) &feature_check_constraint, SHOW_LONG },\n  {\"Feature_custom_aggregate_functions\", (char*) offsetof(STATUS_VAR, feature_custom_aggregate_functions), SHOW_LONG_STATUS},\n  {\"Feature_delay_key_write\",  (char*) &feature_files_opened_with_delayed_keys, SHOW_LONG },\n  {\"Feature_dynamic_columns\",  (char*) offsetof(STATUS_VAR, feature_dynamic_columns), SHOW_LONG_STATUS},\n  {\"Feature_fulltext\",         (char*) offsetof(STATUS_VAR, feature_fulltext), SHOW_LONG_STATUS},\n  {\"Feature_gis\",              (char*) offsetof(STATUS_VAR, feature_gis), SHOW_LONG_STATUS},\n  {\"Feature_invisible_columns\",   (char*) offsetof(STATUS_VAR, feature_invisible_columns), SHOW_LONG_STATUS},\n  {\"Feature_json\",             (char*) offsetof(STATUS_VAR, feature_json), SHOW_LONG_STATUS},\n  {\"Feature_locale\",           (char*) offsetof(STATUS_VAR, feature_locale), SHOW_LONG_STATUS},\n  {\"Feature_subquery\",         (char*) offsetof(STATUS_VAR, feature_subquery), SHOW_LONG_STATUS},\n  {\"Feature_system_versioning\",   (char*) offsetof(STATUS_VAR, feature_system_versioning), SHOW_LONG_STATUS},\n  {\"Feature_application_time_periods\", (char*) offsetof(STATUS_VAR, feature_application_time_periods), SHOW_LONG_STATUS},\n  {\"Feature_timezone\",         (char*) offsetof(STATUS_VAR, feature_timezone), SHOW_LONG_STATUS},\n  {\"Feature_trigger\",          (char*) offsetof(STATUS_VAR, feature_trigger), SHOW_LONG_STATUS},\n  {\"Feature_window_functions\", (char*) offsetof(STATUS_VAR, feature_window_functions), SHOW_LONG_STATUS},\n  {\"Feature_xml\",              (char*) offsetof(STATUS_VAR, feature_xml), SHOW_LONG_STATUS},\n  {\"Flush_commands\",           (char*) &show_flush_commands, SHOW_SIMPLE_FUNC},\n  {\"Handler_commit\",           (char*) offsetof(STATUS_VAR, ha_commit_count), SHOW_LONG_STATUS},\n  {\"Handler_delete\",           (char*) offsetof(STATUS_VAR, ha_delete_count), SHOW_LONG_STATUS},\n  {\"Handler_discover\",         (char*) offsetof(STATUS_VAR, ha_discover_count), SHOW_LONG_STATUS},\n  {\"Handler_external_lock\",    (char*) offsetof(STATUS_VAR, ha_external_lock_count), SHOW_LONG_STATUS},\n  {\"Handler_icp_attempts\",     (char*) offsetof(STATUS_VAR, ha_icp_attempts), SHOW_LONG_STATUS},\n  {\"Handler_icp_match\",        (char*) offsetof(STATUS_VAR, ha_icp_match), SHOW_LONG_STATUS},\n  {\"Handler_mrr_init\",         (char*) offsetof(STATUS_VAR, ha_mrr_init_count),  SHOW_LONG_STATUS},\n  {\"Handler_mrr_key_refills\",  (char*) offsetof(STATUS_VAR, ha_mrr_key_refills_count), SHOW_LONG_STATUS},\n  {\"Handler_mrr_rowid_refills\",(char*) offsetof(STATUS_VAR, ha_mrr_rowid_refills_count), SHOW_LONG_STATUS},\n  {\"Handler_prepare\",          (char*) offsetof(STATUS_VAR, ha_prepare_count),  SHOW_LONG_STATUS},\n  {\"Handler_read_first\",       (char*) offsetof(STATUS_VAR, ha_read_first_count), SHOW_LONG_STATUS},\n  {\"Handler_read_key\",         (char*) offsetof(STATUS_VAR, ha_read_key_count), SHOW_LONG_STATUS},\n  {\"Handler_read_last\",        (char*) offsetof(STATUS_VAR, ha_read_last_count), SHOW_LONG_STATUS},\n  {\"Handler_read_next\",        (char*) offsetof(STATUS_VAR, ha_read_next_count), SHOW_LONG_STATUS},\n  {\"Handler_read_prev\",        (char*) offsetof(STATUS_VAR, ha_read_prev_count), SHOW_LONG_STATUS},\n  {\"Handler_read_retry\",       (char*) offsetof(STATUS_VAR, ha_read_retry_count), SHOW_LONG_STATUS},\n  {\"Handler_read_rnd\",         (char*) offsetof(STATUS_VAR, ha_read_rnd_count), SHOW_LONG_STATUS},\n  {\"Handler_read_rnd_deleted\", (char*) offsetof(STATUS_VAR, ha_read_rnd_deleted_count), SHOW_LONG_STATUS},\n  {\"Handler_read_rnd_next\",    (char*) offsetof(STATUS_VAR, ha_read_rnd_next_count), SHOW_LONG_STATUS},\n  {\"Handler_rollback\",         (char*) offsetof(STATUS_VAR, ha_rollback_count), SHOW_LONG_STATUS},\n  {\"Handler_savepoint\",        (char*) offsetof(STATUS_VAR, ha_savepoint_count), SHOW_LONG_STATUS},\n  {\"Handler_savepoint_rollback\",(char*) offsetof(STATUS_VAR, ha_savepoint_rollback_count), SHOW_LONG_STATUS},\n  {\"Handler_tmp_delete\",       (char*) offsetof(STATUS_VAR, ha_tmp_delete_count), SHOW_LONG_STATUS},\n  {\"Handler_tmp_update\",       (char*) offsetof(STATUS_VAR, ha_tmp_update_count), SHOW_LONG_STATUS},\n  {\"Handler_tmp_write\",        (char*) offsetof(STATUS_VAR, ha_tmp_write_count), SHOW_LONG_STATUS},\n  {\"Handler_update\",           (char*) offsetof(STATUS_VAR, ha_update_count), SHOW_LONG_STATUS},\n  {\"Handler_write\",            (char*) offsetof(STATUS_VAR, ha_write_count), SHOW_LONG_STATUS},\n  {\"Key\",                      (char*) &show_default_keycache, SHOW_FUNC},\n  {\"Last_query_cost\",          (char*) offsetof(STATUS_VAR, last_query_cost), SHOW_DOUBLE_STATUS},\n  {\"Max_statement_time_exceeded\", (char*) offsetof(STATUS_VAR, max_statement_time_exceeded), SHOW_LONG_STATUS},\n  {\"Master_gtid_wait_count\",   (char*) offsetof(STATUS_VAR, master_gtid_wait_count), SHOW_LONGLONG_STATUS},\n  {\"Master_gtid_wait_timeouts\", (char*) offsetof(STATUS_VAR, master_gtid_wait_timeouts), SHOW_LONGLONG_STATUS},\n  {\"Master_gtid_wait_time\",    (char*) offsetof(STATUS_VAR, master_gtid_wait_time), SHOW_LONGLONG_STATUS},\n  {\"Max_used_connections\",     (char*) &max_used_connections,  SHOW_LONG},\n  {\"Memory_used\",              (char*) &show_memory_used, SHOW_SIMPLE_FUNC},\n  {\"Memory_used_initial\",      (char*) &start_memory_used, SHOW_LONGLONG},\n  {\"Not_flushed_delayed_rows\", (char*) &delayed_rows_in_use,    SHOW_LONG_NOFLUSH},\n  {\"Open_files\",               (char*) &my_file_opened,         SHOW_SINT},\n  {\"Open_streams\",             (char*) &my_stream_opened,       SHOW_LONG_NOFLUSH},\n  {\"Open_table_definitions\",   (char*) &show_table_definitions, SHOW_SIMPLE_FUNC},\n  {\"Open_tables\",              (char*) &show_open_tables,       SHOW_SIMPLE_FUNC},\n  {\"Opened_files\",             (char*) &my_file_total_opened, SHOW_LONG_NOFLUSH},\n  {\"Opened_plugin_libraries\",  (char*) &dlopen_count, SHOW_LONG},\n  {\"Opened_table_definitions\", (char*) offsetof(STATUS_VAR, opened_shares), SHOW_LONG_STATUS},\n  {\"Opened_tables\",            (char*) offsetof(STATUS_VAR, opened_tables), SHOW_LONG_STATUS},\n  {\"Opened_views\",             (char*) offsetof(STATUS_VAR, opened_views), SHOW_LONG_STATUS},\n  {\"Prepared_stmt_count\",      (char*) &show_prepared_stmt_count, SHOW_SIMPLE_FUNC},\n  {\"Rows_sent\",                (char*) offsetof(STATUS_VAR, rows_sent), SHOW_LONGLONG_STATUS},\n  {\"Rows_read\",                (char*) offsetof(STATUS_VAR, rows_read), SHOW_LONGLONG_STATUS},\n  {\"Rows_tmp_read\",            (char*) offsetof(STATUS_VAR, rows_tmp_read), SHOW_LONGLONG_STATUS},\n#ifdef HAVE_REPLICATION\n  {\"Rpl_semi_sync_master_status\", (char*) &SHOW_FNAME(status), SHOW_FUNC},\n  {\"Rpl_semi_sync_master_clients\", (char*) &SHOW_FNAME(clients), SHOW_FUNC},\n  {\"Rpl_semi_sync_master_yes_tx\", (char*) &rpl_semi_sync_master_yes_transactions, SHOW_LONG},\n  {\"Rpl_semi_sync_master_no_tx\", (char*) &rpl_semi_sync_master_no_transactions, SHOW_LONG},\n  {\"Rpl_semi_sync_master_wait_sessions\", (char*) &SHOW_FNAME(wait_sessions), SHOW_FUNC},\n  {\"Rpl_semi_sync_master_no_times\", (char*) &rpl_semi_sync_master_off_times, SHOW_LONG},\n  {\"Rpl_semi_sync_master_timefunc_failures\", (char*) &rpl_semi_sync_master_timefunc_fails, SHOW_LONG},\n  {\"Rpl_semi_sync_master_wait_pos_backtraverse\", (char*) &rpl_semi_sync_master_wait_pos_backtraverse, SHOW_LONG},\n  {\"Rpl_semi_sync_master_tx_wait_time\", (char*) &SHOW_FNAME(trx_wait_time), SHOW_FUNC},\n  {\"Rpl_semi_sync_master_tx_waits\", (char*) &SHOW_FNAME(trx_wait_num), SHOW_FUNC},\n  {\"Rpl_semi_sync_master_tx_avg_wait_time\", (char*) &SHOW_FNAME(avg_trx_wait_time), SHOW_FUNC},\n  {\"Rpl_semi_sync_master_net_wait_time\", (char*) &SHOW_FNAME(net_wait_time), SHOW_FUNC},\n  {\"Rpl_semi_sync_master_net_waits\", (char*) &SHOW_FNAME(net_wait_num), SHOW_FUNC},\n  {\"Rpl_semi_sync_master_net_avg_wait_time\", (char*) &SHOW_FNAME(avg_net_wait_time), SHOW_FUNC},\n  {\"Rpl_semi_sync_master_request_ack\", (char*) &rpl_semi_sync_master_request_ack, SHOW_LONGLONG},\n  {\"Rpl_semi_sync_master_get_ack\", (char*)&rpl_semi_sync_master_get_ack, SHOW_LONGLONG},\n  {\"Rpl_semi_sync_slave_status\", (char*) &rpl_semi_sync_slave_status, SHOW_BOOL},\n  {\"Rpl_semi_sync_slave_send_ack\", (char*) &rpl_semi_sync_slave_send_ack, SHOW_LONGLONG},\n#endif /* HAVE_REPLICATION */\n#ifdef HAVE_QUERY_CACHE\n  {\"Qcache_free_blocks\",       (char*) &query_cache.free_memory_blocks, SHOW_LONG_NOFLUSH},\n  {\"Qcache_free_memory\",       (char*) &query_cache.free_memory, SHOW_LONG_NOFLUSH},\n  {\"Qcache_hits\",              (char*) &query_cache.hits,       SHOW_LONG},\n  {\"Qcache_inserts\",           (char*) &query_cache.inserts,    SHOW_LONG},\n  {\"Qcache_lowmem_prunes\",     (char*) &query_cache.lowmem_prunes, SHOW_LONG},\n  {\"Qcache_not_cached\",        (char*) &query_cache.refused,    SHOW_LONG},\n  {\"Qcache_queries_in_cache\",  (char*) &query_cache.queries_in_cache, SHOW_LONG_NOFLUSH},\n  {\"Qcache_total_blocks\",      (char*) &query_cache.total_blocks, SHOW_LONG_NOFLUSH},\n#endif /*HAVE_QUERY_CACHE*/\n  {\"Queries\",                  (char*) &show_queries,            SHOW_SIMPLE_FUNC},\n  {\"Questions\",                (char*) offsetof(STATUS_VAR, questions), SHOW_LONG_STATUS},\n#ifdef HAVE_REPLICATION\n  {\"Rpl_status\",               (char*) &show_rpl_status,          SHOW_SIMPLE_FUNC},\n#endif\n  {\"Select_full_join\",         (char*) offsetof(STATUS_VAR, select_full_join_count_), SHOW_LONG_STATUS},\n  {\"Select_full_range_join\",   (char*) offsetof(STATUS_VAR, select_full_range_join_count_), SHOW_LONG_STATUS},\n  {\"Select_range\",             (char*) offsetof(STATUS_VAR, select_range_count_), SHOW_LONG_STATUS},\n  {\"Select_range_check\",       (char*) offsetof(STATUS_VAR, select_range_check_count_), SHOW_LONG_STATUS},\n  {\"Select_scan\",\t       (char*) offsetof(STATUS_VAR, select_scan_count_), SHOW_LONG_STATUS},\n  {\"Slave_open_temp_tables\",   (char*) &slave_open_temp_tables, SHOW_INT},\n#ifdef HAVE_REPLICATION\n  {\"Slaves_connected\",        (char*) &show_slaves_connected, SHOW_SIMPLE_FUNC },\n  {\"Slaves_running\",          (char*) &show_slaves_running, SHOW_SIMPLE_FUNC },\n  {\"Slave_connections\",       (char*) offsetof(STATUS_VAR, com_register_slave), SHOW_LONG_STATUS},\n  {\"Slave_heartbeat_period\",   (char*) &show_heartbeat_period, SHOW_SIMPLE_FUNC},\n  {\"Slave_received_heartbeats\",(char*) &show_slave_received_heartbeats, SHOW_SIMPLE_FUNC},\n  {\"Slave_retried_transactions\",(char*)&slave_retried_transactions, SHOW_LONG},\n  {\"Slave_running\",            (char*) &show_slave_running,     SHOW_SIMPLE_FUNC},\n  {\"Slave_skipped_errors\",     (char*) &slave_skipped_errors, SHOW_LONGLONG},\n#endif\n  {\"Slow_launch_threads\",      (char*) &slow_launch_threads,    SHOW_LONG},\n  {\"Slow_queries\",             (char*) offsetof(STATUS_VAR, long_query_count), SHOW_LONG_STATUS},\n  {\"Sort_merge_passes\",\t       (char*) offsetof(STATUS_VAR, filesort_merge_passes_), SHOW_LONG_STATUS},\n  {\"Sort_priority_queue_sorts\",(char*) offsetof(STATUS_VAR, filesort_pq_sorts_), SHOW_LONG_STATUS}, \n  {\"Sort_range\",\t       (char*) offsetof(STATUS_VAR, filesort_range_count_), SHOW_LONG_STATUS},\n  {\"Sort_rows\",\t\t       (char*) offsetof(STATUS_VAR, filesort_rows_), SHOW_LONG_STATUS},\n  {\"Sort_scan\",\t\t       (char*) offsetof(STATUS_VAR, filesort_scan_count_), SHOW_LONG_STATUS},\n#ifdef HAVE_OPENSSL\n#ifndef EMBEDDED_LIBRARY\n  {\"Ssl_accept_renegotiates\",  (char*) &ssl_acceptor_stats.zero, SHOW_LONG},\n  {\"Ssl_accepts\",              (char*) &ssl_acceptor_stats.accept, SHOW_LONG},\n  {\"Ssl_callback_cache_hits\",  (char*) &ssl_acceptor_stats.zero, SHOW_LONG},\n  {\"Ssl_cipher\",               (char*) &show_ssl_get_cipher, SHOW_SIMPLE_FUNC},\n  {\"Ssl_cipher_list\",          (char*) &show_ssl_get_cipher_list, SHOW_SIMPLE_FUNC},\n  {\"Ssl_client_connects\",      (char*) &ssl_acceptor_stats.zero, SHOW_LONG},\n  {\"Ssl_connect_renegotiates\", (char*) &ssl_acceptor_stats.zero, SHOW_LONG},\n  {\"Ssl_ctx_verify_depth\",     (char*) &ssl_acceptor_stats.verify_depth, SHOW_LONG},\n  {\"Ssl_ctx_verify_mode\",      (char*) &ssl_acceptor_stats.verify_mode, SHOW_LONG},\n  {\"Ssl_default_timeout\",      (char*) &show_ssl_get_default_timeout, SHOW_SIMPLE_FUNC},\n  {\"Ssl_finished_accepts\",     (char*) &ssl_acceptor_stats.accept_good, SHOW_LONG},\n  {\"Ssl_finished_connects\",    (char*) &ssl_acceptor_stats.zero, SHOW_LONG},\n  {\"Ssl_server_not_after\",     (char*) &show_ssl_get_server_not_after, SHOW_SIMPLE_FUNC},\n  {\"Ssl_server_not_before\",    (char*) &show_ssl_get_server_not_before, SHOW_SIMPLE_FUNC},\n  {\"Ssl_session_cache_hits\",   (char*) &ssl_acceptor_stats.zero, SHOW_LONG},\n  {\"Ssl_session_cache_misses\", (char*) &ssl_acceptor_stats.zero, SHOW_LONG},\n  {\"Ssl_session_cache_mode\",   (char*) &ssl_acceptor_stats.session_cache_mode, SHOW_CHAR_PTR},\n  {\"Ssl_session_cache_overflows\", (char*) &ssl_acceptor_stats.zero, SHOW_LONG},\n  {\"Ssl_session_cache_size\",   (char*) &ssl_acceptor_stats.cache_size, SHOW_LONG},\n  {\"Ssl_session_cache_timeouts\", (char*) &ssl_acceptor_stats.zero, SHOW_LONG},\n  {\"Ssl_sessions_reused\",      (char*) &ssl_acceptor_stats.zero, SHOW_LONG},\n  {\"Ssl_used_session_cache_entries\",(char*) &ssl_acceptor_stats.zero, SHOW_LONG},\n  {\"Ssl_verify_depth\",         (char*) &show_ssl_get_verify_depth, SHOW_SIMPLE_FUNC},\n  {\"Ssl_verify_mode\",          (char*) &show_ssl_get_verify_mode, SHOW_SIMPLE_FUNC},\n  {\"Ssl_version\",              (char*) &show_ssl_get_version, SHOW_SIMPLE_FUNC},\n#endif\n#endif /* HAVE_OPENSSL */\n  {\"Syncs\",                    (char*) &my_sync_count,          SHOW_LONG_NOFLUSH},\n  /*\n    Expression cache used only for caching subqueries now, so its statistic\n    variables we call subquery_cache*.\n  */\n  {\"Subquery_cache_hit\",       (char*) &subquery_cache_hit,     SHOW_LONG},\n  {\"Subquery_cache_miss\",      (char*) &subquery_cache_miss,    SHOW_LONG},\n  {\"Table_locks_immediate\",    (char*) &locks_immediate,        SHOW_LONG},\n  {\"Table_locks_waited\",       (char*) &locks_waited,           SHOW_LONG},\n  {\"Table_open_cache_active_instances\", (char*) &tc_active_instances, SHOW_UINT},\n  {\"Table_open_cache_hits\",    (char*) offsetof(STATUS_VAR, table_open_cache_hits), SHOW_LONGLONG_STATUS},\n  {\"Table_open_cache_misses\",  (char*) offsetof(STATUS_VAR, table_open_cache_misses), SHOW_LONGLONG_STATUS},\n  {\"Table_open_cache_overflows\", (char*) offsetof(STATUS_VAR, table_open_cache_overflows), SHOW_LONGLONG_STATUS},\n#ifdef HAVE_MMAP\n  {\"Tc_log_max_pages_used\",    (char*) &tc_log_max_pages_used,  SHOW_LONG},\n  {\"Tc_log_page_size\",         (char*) &tc_log_page_size,       SHOW_LONG_NOFLUSH},\n  {\"Tc_log_page_waits\",        (char*) &tc_log_page_waits,      SHOW_LONG},\n#endif\n#ifdef HAVE_POOL_OF_THREADS\n  {\"Threadpool_idle_threads\",  (char *) &show_threadpool_idle_threads, SHOW_SIMPLE_FUNC},\n  {\"Threadpool_threads\",       (char *) &tp_stats.num_worker_threads, SHOW_INT},\n#endif\n  {\"Threads_cached\",           (char*) &cached_thread_count,    SHOW_LONG_NOFLUSH},\n  {\"Threads_connected\",        (char*) &connection_count,       SHOW_INT},\n  {\"Threads_created\",\t       (char*) &thread_created,\t\tSHOW_LONG_NOFLUSH},\n  {\"Threads_running\",          (char*) offsetof(STATUS_VAR, threads_running), SHOW_UINT32_STATUS},\n  {\"Transactions_multi_engine\", (char*) &transactions_multi_engine, SHOW_LONG},\n  {\"Rpl_transactions_multi_engine\", (char*) &rpl_transactions_multi_engine, SHOW_LONG},\n  {\"Transactions_gtid_foreign_engine\", (char*) &transactions_gtid_foreign_engine, SHOW_LONG},\n  {\"Update_scan\",\t       (char*) offsetof(STATUS_VAR, update_scan_count), SHOW_LONG_STATUS},\n  {\"Uptime\",                   (char*) &show_starttime,         SHOW_SIMPLE_FUNC},\n#ifdef ENABLED_PROFILING\n  {\"Uptime_since_flush_status\",(char*) &show_flushstatustime,   SHOW_SIMPLE_FUNC},\n#endif\n#ifdef WITH_WSREP\n  {\"wsrep_connected\",         (char*) &wsrep_connected,         SHOW_BOOL},\n  {\"wsrep_ready\",             (char*) &wsrep_show_ready,        SHOW_FUNC},\n  {\"wsrep_cluster_state_uuid\",(char*) &wsrep_cluster_state_uuid,SHOW_CHAR_PTR},\n  {\"wsrep_cluster_conf_id\",   (char*) &wsrep_cluster_conf_id,   SHOW_LONGLONG},\n  {\"wsrep_cluster_status\",    (char*) &wsrep_cluster_status,    SHOW_CHAR_PTR},\n  {\"wsrep_cluster_size\",      (char*) &wsrep_cluster_size,      SHOW_LONG_NOFLUSH},\n  {\"wsrep_local_index\",       (char*) &wsrep_local_index,       SHOW_LONG_NOFLUSH},\n  {\"wsrep_local_bf_aborts\",   (char*) &wsrep_show_bf_aborts,    SHOW_FUNC},\n  {\"wsrep_provider_name\",     (char*) &wsrep_provider_name,     SHOW_CHAR_PTR},\n  {\"wsrep_provider_version\",  (char*) &wsrep_provider_version,  SHOW_CHAR_PTR},\n  {\"wsrep_provider_vendor\",   (char*) &wsrep_provider_vendor,   SHOW_CHAR_PTR},\n  {\"wsrep_provider_capabilities\", (char*) &wsrep_provider_capabilities, SHOW_CHAR_PTR},\n  {\"wsrep_thread_count\",      (char*) &wsrep_running_threads,   SHOW_LONG_NOFLUSH},\n  {\"wsrep_applier_thread_count\", (char*) &wsrep_running_applier_threads, SHOW_LONG_NOFLUSH},\n  {\"wsrep_rollbacker_thread_count\", (char *) &wsrep_running_rollbacker_threads, SHOW_LONG_NOFLUSH},\n  {\"wsrep_cluster_capabilities\", (char*) &wsrep_cluster_capabilities, SHOW_CHAR_PTR},\n  {\"wsrep\",                    (char*) &wsrep_show_status,       SHOW_FUNC},\n#endif\n  {NullS, NullS, SHOW_LONG}\n};\n\nstatic bool add_terminator(DYNAMIC_ARRAY *options)\n{\n  my_option empty_element= {0, 0, 0, 0, 0, 0, GET_NO_ARG, NO_ARG, 0, 0, 0, 0, 0, 0};\n  return insert_dynamic(options, (uchar *)&empty_element);\n}\n\nstatic bool add_many_options(DYNAMIC_ARRAY *options, my_option *list,\n                            size_t elements)\n{\n  for (my_option *opt= list; opt < list + elements; opt++)\n    if (insert_dynamic(options, opt))\n      return 1;\n  return 0;\n}\n\n#ifndef EMBEDDED_LIBRARY\nstatic void print_version(void)\n{\n  if (IS_SYSVAR_AUTOSIZE(&server_version_ptr))\n    set_server_version(server_version, sizeof(server_version));\n\n  printf(\"%s  Ver %s for %s on %s (%s)\\n\",my_progname,\n\t server_version,SYSTEM_TYPE,MACHINE_TYPE, MYSQL_COMPILATION_COMMENT);\n}\n\n/** Compares two options' names, treats - and _ the same */\nstatic int option_cmp(my_option *a, my_option *b)\n{\n  const char *sa= a->name;\n  const char *sb= b->name;\n  for (; *sa || *sb; sa++, sb++)\n  {\n    if (*sa < *sb)\n    {\n      if (*sa == '-' && *sb == '_')\n        continue;\n      else\n        return -1;\n    }\n    if (*sa > *sb)\n    {\n      if (*sa == '_' && *sb == '-')\n        continue;\n      else\n        return 1;\n    }\n  }\n  return 0;\n}\n\nstatic void print_help()\n{\n  MEM_ROOT mem_root;\n  init_alloc_root(&mem_root, \"help\", 4096, 4096, MYF(0));\n\n  pop_dynamic(&all_options);\n  add_many_options(&all_options, pfs_early_options,\n                  array_elements(pfs_early_options));\n  sys_var_add_options(&all_options, sys_var::PARSE_EARLY);\n  add_plugin_options(&all_options, &mem_root);\n  sort_dynamic(&all_options, (qsort_cmp) option_cmp);\n  sort_dynamic(&all_options, (qsort_cmp) option_cmp);\n  add_terminator(&all_options);\n\n  my_print_help((my_option*) all_options.buffer);\n\n  /* Add variables that must be shown but not changed, like version numbers */\n  pop_dynamic(&all_options);\n  sys_var_add_options(&all_options, sys_var::GETOPT_ONLY_HELP);\n  sort_dynamic(&all_options, (qsort_cmp) option_cmp);\n  add_terminator(&all_options);\n  my_print_variables((my_option*) all_options.buffer);\n\n  free_root(&mem_root, MYF(0));\n}\n\nstatic void usage(void)\n{\n  DBUG_ENTER(\"usage\");\n  if (!(default_charset_info= get_charset_by_csname(default_character_set_name,\n\t\t\t\t\t           MY_CS_PRIMARY,\n\t\t\t\t\t\t   MYF(MY_WME))))\n    exit(1);\n  if (!default_collation_name)\n    default_collation_name= (char*) default_charset_info->name;\n  print_version();\n  puts(ORACLE_WELCOME_COPYRIGHT_NOTICE(\"2000\"));\n  puts(\"Starts the MariaDB database server.\\n\");\n  printf(\"Usage: %s [OPTIONS]\\n\", my_progname);\n  if (!opt_verbose)\n    puts(\"\\nFor more help options (several pages), use mysqld --verbose --help.\");\n  else\n  {\n#ifdef __WIN__\n  puts(\"NT and Win32 specific options:\\n\"\n       \"  --install                     Install the default service (NT).\\n\"\n       \"  --install-manual              Install the default service started manually (NT).\\n\"\n       \"  --install service_name        Install an optional service (NT).\\n\"\n       \"  --install-manual service_name Install an optional service started manually (NT).\\n\"\n       \"  --remove                      Remove the default service from the service list (NT).\\n\"\n       \"  --remove service_name         Remove the service_name from the service list (NT).\\n\"\n       \"  --enable-named-pipe           Only to be used for the default server (NT).\\n\"\n       \"  --standalone                  Dummy option to start as a standalone server (NT).\");\n  puts(\"\");\n#endif\n  print_defaults(MYSQL_CONFIG_NAME,load_default_groups);\n  puts(\"\");\n  set_ports();\n\n  /* Print out all the options including plugin supplied options */\n  print_help();\n\n  if (! plugins_are_initialized)\n  {\n    puts(\"\\nPlugins have parameters that are not reflected in this list\"\n         \"\\nbecause execution stopped before plugins were initialized.\");\n  }\n\n    puts(\"\\nTo see what variables a running MySQL server is using, type\"\n         \"\\n'mysqladmin variables' instead of 'mysqld --verbose --help'.\");\n  }\n  DBUG_VOID_RETURN;\n}\n#endif /*!EMBEDDED_LIBRARY*/\n\n/**\n  Initialize MySQL global variables to default values.\n\n  @note\n    The reason to set a lot of global variables to zero is to allow one to\n    restart the embedded server with a clean environment\n    It's also needed on some exotic platforms where global variables are\n    not set to 0 when a program starts.\n\n    We don't need to set variables refered to in my_long_options\n    as these are initialized by my_getopt.\n*/\n\nstatic int mysql_init_variables(void)\n{\n  /* Things reset to zero */\n  opt_skip_slave_start= opt_reckless_slave = 0;\n  mysql_home[0]= pidfile_name[0]= log_error_file[0]= 0;\n#if defined(HAVE_REALPATH) && !defined(HAVE_valgrind) && !defined(HAVE_BROKEN_REALPATH)\n  /*  We can only test for sub paths if my_symlink.c is using realpath */\n  mysys_test_invalid_symlink= path_starts_from_data_home_dir;\n#endif\n  opt_log= 0;\n  opt_bin_log= opt_bin_log_used= 0;\n  opt_disable_networking= opt_skip_show_db=0;\n  opt_skip_name_resolve= 0;\n  opt_ignore_builtin_innodb= 0;\n  opt_logname= opt_binlog_index_name= opt_slow_logname= 0;\n  opt_log_basename= 0;\n  opt_tc_log_file= (char *)\"tc.log\";      // no hostname in tc_log file name !\n  opt_secure_auth= 0;\n  opt_bootstrap= opt_myisam_log= 0;\n  disable_log_notes= 0;\n  mqh_used= 0;\n  cleanup_done= 0;\n  test_flags= select_errors= dropping_tables= ha_open_options=0;\n  thread_count= kill_cached_threads= wake_thread= 0;\n  slave_open_temp_tables= 0;\n  cached_thread_count= 0;\n  opt_endinfo= using_udf_functions= 0;\n  opt_using_transactions= 0;\n  abort_loop= select_thread_in_use= signal_thread_in_use= 0;\n  grant_option= 0;\n  aborted_threads= aborted_connects= aborted_connects_preauth= 0;\n  subquery_cache_miss= subquery_cache_hit= 0;\n  delayed_insert_threads= delayed_insert_writes= delayed_rows_in_use= 0;\n  delayed_insert_errors= thread_created= 0;\n  specialflag= 0;\n  binlog_cache_use=  binlog_cache_disk_use= 0;\n  max_used_connections= slow_launch_threads = 0;\n  mysqld_user= mysqld_chroot= opt_init_file= opt_bin_logname = 0;\n  prepared_stmt_count= 0;\n  mysqld_unix_port= opt_mysql_tmpdir= my_bind_addr_str= NullS;\n  bzero((uchar*) &mysql_tmpdir_list, sizeof(mysql_tmpdir_list));\n  /* Clear all except global_memory_used */\n  bzero((char*) &global_status_var, offsetof(STATUS_VAR,\n                                             last_cleared_system_status_var));\n  opt_large_pages= 0;\n  opt_super_large_pages= 0;\n#if defined(ENABLED_DEBUG_SYNC)\n  opt_debug_sync_timeout= 0;\n#endif /* defined(ENABLED_DEBUG_SYNC) */\n  key_map_full.set_all();\n\n  /* Character sets */\n  system_charset_info= &my_charset_utf8_general_ci;\n  files_charset_info= &my_charset_utf8_general_ci;\n  national_charset_info= &my_charset_utf8_general_ci;\n  table_alias_charset= &my_charset_bin;\n  character_set_filesystem= &my_charset_bin;\n\n  opt_specialflag= SPECIAL_ENGLISH;\n#ifndef EMBEDDED_LIBRARY \n  unix_sock= base_ip_sock= extra_ip_sock= MYSQL_INVALID_SOCKET;\n#endif\n  mysql_home_ptr= mysql_home;\n  log_error_file_ptr= log_error_file;\n  protocol_version= PROTOCOL_VERSION;\n  what_to_log= ~(1UL << COM_TIME);\n  denied_connections= 0;\n  executed_events= 0;\n  global_query_id= 1;\n  global_thread_id= 0;\n  strnmov(server_version, MYSQL_SERVER_VERSION, sizeof(server_version)-1);\n  thread_cache.empty();\n  key_caches.empty();\n  if (!(dflt_key_cache= get_or_create_key_cache(default_key_cache_base.str,\n                                                default_key_cache_base.length)))\n  {\n    sql_print_error(\"Cannot allocate the keycache\");\n    return 1;\n  }\n\n  /* set key_cache_hash.default_value = dflt_key_cache */\n  multi_keycache_init();\n\n  /* Set directory paths */\n  mysql_real_data_home_len=\n    (uint)(strmake_buf(mysql_real_data_home,\n                get_relative_path(MYSQL_DATADIR)) - mysql_real_data_home);\n  /* Replication parameters */\n  master_info_file= (char*) \"master.info\",\n    relay_log_info_file= (char*) \"relay-log.info\";\n  report_user= report_password = report_host= 0;\t/* TO BE DELETED */\n  opt_relay_logname= opt_relaylog_index_name= 0;\n  slave_retried_transactions= 0;\n  transactions_multi_engine= 0;\n  rpl_transactions_multi_engine= 0;\n  transactions_gtid_foreign_engine= 0;\n  log_bin_basename= NULL;\n  log_bin_index= NULL;\n\n  /* Variables in libraries */\n  charsets_dir= 0;\n  default_character_set_name= (char*) MYSQL_DEFAULT_CHARSET_NAME;\n  default_collation_name= compiled_default_collation_name;\n  character_set_filesystem_name= (char*) \"binary\";\n  lc_messages= (char*) \"en_US\";\n  lc_time_names_name= (char*) \"en_US\";\n  \n  /* Variables that depends on compile options */\n#ifndef DBUG_OFF\n  default_dbug_option=IF_WIN(\"d:t:i:O,\\\\mysqld.trace\",\n\t\t\t     \"d:t:i:o,/tmp/mysqld.trace\");\n  current_dbug_option= default_dbug_option;\n#endif\n  opt_error_log= IF_WIN(1,0);\n#ifdef ENABLED_PROFILING\n    have_profiling = SHOW_OPTION_YES;\n#else\n    have_profiling = SHOW_OPTION_NO;\n#endif\n\n#if defined(HAVE_OPENSSL) && !defined(EMBEDDED_LIBRARY)\n  have_ssl=SHOW_OPTION_YES;\n#if defined(HAVE_WOLFSSL)\n  have_openssl= SHOW_OPTION_NO;\n#else\n  have_openssl= SHOW_OPTION_YES;\n#endif\n#else\n  have_openssl= have_ssl= SHOW_OPTION_NO;\n#endif\n#ifdef HAVE_BROKEN_REALPATH\n  have_symlink=SHOW_OPTION_NO;\n#else\n  have_symlink=SHOW_OPTION_YES;\n#endif\n#ifdef HAVE_DLOPEN\n  have_dlopen=SHOW_OPTION_YES;\n#else\n  have_dlopen=SHOW_OPTION_NO;\n#endif\n#ifdef HAVE_QUERY_CACHE\n  have_query_cache=SHOW_OPTION_YES;\n#else\n  have_query_cache=SHOW_OPTION_NO;\n#endif\n#ifdef HAVE_SPATIAL\n  have_geometry=SHOW_OPTION_YES;\n#else\n  have_geometry=SHOW_OPTION_NO;\n#endif\n#ifdef HAVE_RTREE_KEYS\n  have_rtree_keys=SHOW_OPTION_YES;\n#else\n  have_rtree_keys=SHOW_OPTION_NO;\n#endif\n#ifdef HAVE_CRYPT\n  have_crypt=SHOW_OPTION_YES;\n#else\n  have_crypt=SHOW_OPTION_NO;\n#endif\n#ifdef HAVE_COMPRESS\n  have_compress= SHOW_OPTION_YES;\n#else\n  have_compress= SHOW_OPTION_NO;\n#endif\n#ifdef HAVE_LIBWRAP\n  libwrapName= NullS;\n#endif\n#ifdef HAVE_OPENSSL\n  des_key_file = 0;\n#ifndef EMBEDDED_LIBRARY\n  ssl_acceptor_fd= 0;\n#endif /* ! EMBEDDED_LIBRARY */\n#endif /* HAVE_OPENSSL */\n\n#if defined(__WIN__)\n  /* Allow Win32 users to move MySQL anywhere */\n  {\n    char prg_dev[LIBLEN];\n    char executing_path_name[LIBLEN];\n    if (!test_if_hard_path(my_progname))\n    {\n      // we don't want to use GetModuleFileName inside of my_path since\n      // my_path is a generic path dereferencing function and here we care\n      // only about the executing binary.\n      GetModuleFileName(NULL, executing_path_name, sizeof(executing_path_name));\n      my_path(prg_dev, executing_path_name, NULL);\n    }\n    else\n      my_path(prg_dev, my_progname, \"mysql/bin\");\n    strcat(prg_dev,\"/../\");\t\t\t// Remove 'bin' to get base dir\n    cleanup_dirname(mysql_home,prg_dev);\n  }\n#else\n  const char *tmpenv;\n  if (!(tmpenv = getenv(\"MY_BASEDIR_VERSION\")))\n    tmpenv = DEFAULT_MYSQL_HOME;\n  strmake_buf(mysql_home, tmpenv);\n  set_sys_var_value_origin(&mysql_home_ptr, sys_var::ENV);\n#endif\n\n  if (wsrep_init_vars())\n    return 1;\n\n  return 0;\n}\n\nmy_bool\nmysqld_get_one_option(int optid, const struct my_option *opt, char *argument)\n{\n  if (opt->app_type)\n  {\n    sys_var *var= (sys_var*) opt->app_type;\n    if (argument == autoset_my_option)\n    {\n      var->value_origin= sys_var::AUTO;\n      return 0;\n    }\n    var->value_origin= sys_var::CONFIG;\n  }\n\n  switch(optid) {\n  case '#':\n#ifndef DBUG_OFF\n    if (!argument)\n      argument= (char*) default_dbug_option;\n    if (argument[0] == '0' && !argument[1])\n    {\n      DEBUGGER_OFF;\n      break;\n    }\n    DEBUGGER_ON;\n    if (argument[0] == '1' && !argument[1])\n      break;\n    DBUG_SET_INITIAL(argument);\n    current_dbug_option= argument;\n    opt_endinfo=1;\t\t\t\t/* unireg: memory allocation */\n#else\n    sql_print_warning(\"'%s' is disabled in this build\", opt->name);\n#endif\n    break;\n  case OPT_DEPRECATED_OPTION:\n    sql_print_warning(\"'%s' is deprecated. It does nothing and exists only \"\n                      \"for compatibility with old my.cnf files.\",\n                      opt->name);\n    break;\n  case OPT_MYSQL_COMPATIBILITY:\n    sql_print_warning(\"'%s' is MySQL 5.6 / 5.7 compatible option. Not used or \"\n                      \"needed in MariaDB.\", opt->name);\n    break;\n  case OPT_MYSQL_TO_BE_IMPLEMENTED:\n    sql_print_warning(\"'%s' is MySQL 5.6 / 5.7 compatible option. To be \"\n                      \"implemented in later versions.\", opt->name);\n    break;\n  case 'a':\n    SYSVAR_AUTOSIZE(global_system_variables.sql_mode, MODE_ANSI);\n    SYSVAR_AUTOSIZE(global_system_variables.tx_isolation, ISO_SERIALIZABLE);\n    break;\n  case 'b':\n    strmake_buf(mysql_home, argument);\n    break;\n  case 'C':\n    if (default_collation_name == compiled_default_collation_name)\n      default_collation_name= 0;\n    break;\n  case 'h':\n    strmake_buf(mysql_real_data_home, argument);\n    /* Correct pointer set by my_getopt (for embedded library) */\n    mysql_real_data_home_ptr= mysql_real_data_home;\n    break;\n  case 'u':\n    if (!mysqld_user || !strcmp(mysqld_user, argument))\n      mysqld_user= argument;\n    else\n      sql_print_warning(\"Ignoring user change to '%s' because the user was set to '%s' earlier on the command line\\n\", argument, mysqld_user);\n    break;\n  case 'L':\n    strmake_buf(lc_messages_dir, argument);\n    break;\n  case OPT_BINLOG_FORMAT:\n    binlog_format_used= true;\n    break;\n#include <sslopt-case.h>\n  case 'V':\n    if (argument)\n    {\n      strmake(server_version, argument, sizeof(server_version) - 1);\n      set_sys_var_value_origin(&server_version_ptr, sys_var::CONFIG);\n      using_custom_server_version= true;\n    }\n#ifndef EMBEDDED_LIBRARY\n    else\n    {\n      print_version();\n      opt_abort= 1;                    // Abort after parsing all options\n    }\n#endif /*EMBEDDED_LIBRARY*/\n    break;\n  case 'W':\n    if (!argument)\n      global_system_variables.log_warnings++;\n    else if (argument == disabled_my_option)\n      global_system_variables.log_warnings= 0L;\n    else\n      global_system_variables.log_warnings= atoi(argument);\n    break;\n  case 'T':\n    test_flags= argument ? (uint) atoi(argument) : 0;\n    opt_endinfo=1;\n    break;\n  case OPT_THREAD_CONCURRENCY:\n    WARN_DEPRECATED_NO_REPLACEMENT(NULL, \"THREAD_CONCURRENCY\");\n    break;\n  case (int) OPT_ISAM_LOG:\n    opt_myisam_log=1;\n    break;\n  case (int) OPT_BIN_LOG:\n    opt_bin_log= MY_TEST(argument != disabled_my_option);\n    opt_bin_log_used= 1;\n    break;\n  case (int) OPT_LOG_BASENAME:\n  {\n    if (opt_log_basename[0] == 0 || strchr(opt_log_basename, FN_EXTCHAR) ||\n        strchr(opt_log_basename,FN_LIBCHAR) ||\n        !is_filename_allowed(opt_log_basename, strlen(opt_log_basename), FALSE))\n    {\n      sql_print_error(\"Wrong argument for --log-basename. It can't be empty or contain '.' or '\" FN_DIRSEP \"'. It must be valid filename.\");\n      return 1;\n    }\n    if (log_error_file_ptr != disabled_my_option)\n      SYSVAR_AUTOSIZE(log_error_file_ptr, opt_log_basename);\n\n    /* General log file */\n    make_default_log_name(&opt_logname, \".log\", false);\n    /* Slow query log file */\n    make_default_log_name(&opt_slow_logname, \"-slow.log\", false);\n    /* Binary log file */\n    make_default_log_name(&opt_bin_logname, \"-bin\", true);\n    /* Binary log index file */\n    make_default_log_name(&opt_binlog_index_name, \"-bin.index\", true);\n    set_sys_var_value_origin(&opt_logname, sys_var::AUTO);\n    set_sys_var_value_origin(&opt_slow_logname, sys_var::AUTO);\n    if (!opt_logname || !opt_slow_logname || !opt_bin_logname ||\n        !opt_binlog_index_name)\n      return 1;\n\n#ifdef HAVE_REPLICATION\n    /* Relay log file */\n    make_default_log_name(&opt_relay_logname, \"-relay-bin\", true);\n    /* Relay log index file */\n    make_default_log_name(&opt_relaylog_index_name, \"-relay-bin.index\", true);\n    set_sys_var_value_origin(&opt_relay_logname, sys_var::AUTO);\n    if (!opt_relay_logname || !opt_relaylog_index_name)\n      return 1;\n#endif\n\n    if (IS_SYSVAR_AUTOSIZE(&pidfile_name_ptr))\n    {\n      SYSVAR_AUTOSIZE(pidfile_name_ptr, pidfile_name);\n      /* PID file */\n      strmake(pidfile_name, argument, sizeof(pidfile_name)-5);\n      strmov(fn_ext(pidfile_name),\".pid\");\n    }\n    break;\n  }\n#ifdef HAVE_REPLICATION\n  case (int)OPT_REPLICATE_IGNORE_DB:\n  {\n    cur_rpl_filter->add_ignore_db(argument);\n    break;\n  }\n  case (int)OPT_REPLICATE_DO_DB:\n  {\n    cur_rpl_filter->add_do_db(argument);\n    break;\n  }\n  case (int)OPT_REPLICATE_REWRITE_DB:\n  {\n    /* See also OPT_REWRITE_DB handling in client/mysqlbinlog.cc */\n    char* key = argument,*p, *val;\n\n    if (!(p= strstr(argument, \"->\")))\n    {\n      sql_print_error(\"Bad syntax in replicate-rewrite-db - missing '->'!\");\n      return 1;\n    }\n    val= p--;\n    while (my_isspace(mysqld_charset, *p) && p > argument)\n      *p-- = 0;\n    /* Db name can be one char also */\n    if (p == argument && my_isspace(mysqld_charset, *p))\n    {\n      sql_print_error(\"Bad syntax in replicate-rewrite-db - empty FROM db!\");\n      return 1;\n    }\n    *val= 0;\n    val+= 2;\n    while (*val && my_isspace(mysqld_charset, *val))\n      val++;\n    if (!*val)\n    {\n      sql_print_error(\"Bad syntax in replicate-rewrite-db - empty TO db!\");\n      return 1;\n    }\n\n    cur_rpl_filter->add_db_rewrite(key, val);\n    break;\n  }\n  case (int)OPT_SLAVE_PARALLEL_MODE:\n  {\n    /* Store latest mode for Master::Info */\n    cur_rpl_filter->set_parallel_mode\n      ((enum_slave_parallel_mode)opt_slave_parallel_mode);\n    break;\n  }\n\n  case (int)OPT_BINLOG_IGNORE_DB:\n  {\n    binlog_filter->add_ignore_db(argument);\n    break;\n  }\n  case (int)OPT_BINLOG_DO_DB:\n  {\n    binlog_filter->add_do_db(argument);\n    break;\n  }\n  case (int)OPT_REPLICATE_DO_TABLE:\n  {\n    if (cur_rpl_filter->add_do_table(argument))\n    {\n      sql_print_error(\"Could not add do table rule '%s'!\", argument);\n      return 1;\n    }\n    break;\n  }\n  case (int)OPT_REPLICATE_WILD_DO_TABLE:\n  {\n    if (cur_rpl_filter->add_wild_do_table(argument))\n    {\n      sql_print_error(\"Could not add do table rule '%s'!\", argument);\n      return 1;\n    }\n    break;\n  }\n  case (int)OPT_REPLICATE_WILD_IGNORE_TABLE:\n  {\n    if (cur_rpl_filter->add_wild_ignore_table(argument))\n    {\n      sql_print_error(\"Could not add ignore table rule '%s'!\", argument);\n      return 1;\n    }\n    break;\n  }\n  case (int)OPT_REPLICATE_IGNORE_TABLE:\n  {\n    if (cur_rpl_filter->add_ignore_table(argument))\n    {\n      sql_print_error(\"Could not add ignore table rule '%s'!\", argument);\n      return 1;\n    }\n    break;\n  }\n#endif /* HAVE_REPLICATION */\n  case (int) OPT_SAFE:\n    opt_specialflag|= SPECIAL_SAFE_MODE | SPECIAL_NO_NEW_FUNC;\n    SYSVAR_AUTOSIZE(delay_key_write_options, (uint) DELAY_KEY_WRITE_NONE);\n    SYSVAR_AUTOSIZE(myisam_recover_options, HA_RECOVER_DEFAULT);\n    ha_open_options&= ~(HA_OPEN_DELAY_KEY_WRITE);\n#ifdef HAVE_QUERY_CACHE\n    SYSVAR_AUTOSIZE(query_cache_size, 0);\n#endif\n    sql_print_warning(\"The syntax '--safe-mode' is deprecated and will be \"\n                      \"removed in a future release.\");\n    break;\n  case (int) OPT_SKIP_HOST_CACHE:\n    opt_specialflag|= SPECIAL_NO_HOST_CACHE;\n    break;\n  case (int) OPT_SKIP_RESOLVE:\n    if ((opt_skip_name_resolve= (argument != disabled_my_option)))\n      opt_specialflag|= SPECIAL_NO_RESOLVE;\n    else\n      opt_specialflag&= ~SPECIAL_NO_RESOLVE;\n    break;\n  case (int) OPT_WANT_CORE:\n    test_flags |= TEST_CORE_ON_SIGNAL;\n    break;\n  case OPT_CONSOLE:\n    if (opt_console)\n      opt_error_log= 0;\t\t\t// Force logs to stdout\n    break;\n  case OPT_BOOTSTRAP:\n    opt_noacl=opt_bootstrap=1;\n    break;\n  case OPT_SERVER_ID:\n    ::server_id= global_system_variables.server_id;\n    break;\n  case OPT_LOWER_CASE_TABLE_NAMES:\n    lower_case_table_names_used= 1;\n    break;\n#if defined(ENABLED_DEBUG_SYNC)\n  case OPT_DEBUG_SYNC_TIMEOUT:\n    /*\n      Debug Sync Facility. See debug_sync.cc.\n      Default timeout for WAIT_FOR action.\n      Default value is zero (facility disabled).\n      If option is given without an argument, supply a non-zero value.\n    */\n    if (!argument)\n    {\n      /* purecov: begin tested */\n      opt_debug_sync_timeout= DEBUG_SYNC_DEFAULT_WAIT_TIMEOUT;\n      /* purecov: end */\n    }\n    break;\n#endif /* defined(ENABLED_DEBUG_SYNC) */\n  case OPT_LOG_ERROR:\n    /*\n      \"No --log-error\" == \"write errors to stderr\",\n      \"--log-error without argument\" == \"write errors to a file\".\n    */\n    if (argument == NULL) /* no argument */\n      log_error_file_ptr= const_cast<char*>(\"\");\n    break;\n  case OPT_IGNORE_DB_DIRECTORY:\n    opt_ignore_db_dirs= NULL; // will be set in ignore_db_dirs_process_additions\n    if (*argument == 0)\n      ignore_db_dirs_reset();\n    else\n    {\n      if (push_ignored_db_dir(argument))\n      {\n        sql_print_error(\"Can't start server: \"\n                        \"cannot process --ignore-db-dir=%.*s\", \n                        FN_REFLEN, argument);\n        return 1;\n      }\n    }\n    break;\n  case OPT_PLUGIN_LOAD:\n    free_list(opt_plugin_load_list_ptr);\n    if (argument == disabled_my_option)\n      break;                                    // Resets plugin list\n    /* fall through */\n  case OPT_PLUGIN_LOAD_ADD:\n    opt_plugin_load_list_ptr->push_back(new i_string(argument));\n    break;\n  case OPT_MAX_LONG_DATA_SIZE:\n    max_long_data_size_used= true;\n    break;\n  case OPT_PFS_INSTRUMENT:\n  {\n#ifdef WITH_PERFSCHEMA_STORAGE_ENGINE\n#ifndef EMBEDDED_LIBRARY\n    /* Parse instrument name and value from argument string */\n    char* name = argument,*p, *val;\n\n    /* Assignment required */\n    if (!(p= strchr(argument, '=')))\n    {\n       my_getopt_error_reporter(WARNING_LEVEL,\n                             \"Missing value for performance_schema_instrument \"\n                             \"'%s'\", argument);\n      return 0;\n    }\n\n    /* Option value */\n    val= p + 1;\n    if (!*val)\n    {\n       my_getopt_error_reporter(WARNING_LEVEL,\n                             \"Missing value for performance_schema_instrument \"\n                             \"'%s'\", argument);\n      return 0;\n    }\n\n    /* Trim leading spaces from instrument name */\n    while (*name && my_isspace(mysqld_charset, *name))\n      name++;\n\n    /* Trim trailing spaces and slashes from instrument name */\n    while (p > argument && (my_isspace(mysqld_charset, p[-1]) || p[-1] == '/'))\n      p--;\n    *p= 0;\n\n    if (!*name)\n    {\n       my_getopt_error_reporter(WARNING_LEVEL,\n                             \"Invalid instrument name for \"\n                             \"performance_schema_instrument '%s'\", argument);\n      return 0;\n    }\n\n    /* Trim leading spaces from option value */\n    while (*val && my_isspace(mysqld_charset, *val))\n      val++;\n\n    /* Trim trailing spaces from option value */\n    if ((p= my_strchr(mysqld_charset, val, val+strlen(val), ' ')) != NULL)\n      *p= 0;\n\n    if (!*val)\n    {\n       my_getopt_error_reporter(WARNING_LEVEL,\n                             \"Invalid value for performance_schema_instrument \"\n                             \"'%s'\", argument);\n      return 0;\n    }\n\n    /* Add instrument name and value to array of configuration options */\n    if (add_pfs_instr_to_array(name, val))\n    {\n       my_getopt_error_reporter(WARNING_LEVEL,\n                             \"Invalid value for performance_schema_instrument \"\n                             \"'%s'\", argument);\n      return 0;\n    }\n#endif /* EMBEDDED_LIBRARY */\n#endif\n    break;\n  }\n#ifdef WITH_WSREP\n  case OPT_WSREP_CAUSAL_READS:\n  {\n    if (global_system_variables.wsrep_causal_reads)\n    {\n      WSREP_WARN(\"option --wsrep-causal-reads is deprecated\");\n      if (!(global_system_variables.wsrep_sync_wait & WSREP_SYNC_WAIT_BEFORE_READ))\n      {\n        WSREP_WARN(\"--wsrep-causal-reads=ON takes precedence over --wsrep-sync-wait=%u. \"\n                     \"WSREP_SYNC_WAIT_BEFORE_READ is on\",\n                     global_system_variables.wsrep_sync_wait);\n        global_system_variables.wsrep_sync_wait |= WSREP_SYNC_WAIT_BEFORE_READ;\n      }\n    }\n    else\n    {\n      if (global_system_variables.wsrep_sync_wait & WSREP_SYNC_WAIT_BEFORE_READ) {\n          WSREP_WARN(\"--wsrep-sync-wait=%u takes precedence over --wsrep-causal-reads=OFF. \"\n                     \"WSREP_SYNC_WAIT_BEFORE_READ is on\",\n                     global_system_variables.wsrep_sync_wait);\n          global_system_variables.wsrep_causal_reads = 1;\n      }\n    }\n    break;\n  }\n  case OPT_WSREP_SYNC_WAIT:\n    global_system_variables.wsrep_causal_reads=\n      MY_TEST(global_system_variables.wsrep_sync_wait &\n              WSREP_SYNC_WAIT_BEFORE_READ);\n    break;\n#endif /* WITH_WSREP */\n  }\n  return 0;\n}\n\n\n/** Handle arguments for multiple key caches. */\n\nC_MODE_START\n\nstatic void*\nmysql_getopt_value(const char *name, uint length,\n\t\t   const struct my_option *option, int *error)\n{\n  if (error)\n    *error= 0;\n  switch (option->id) {\n  case OPT_KEY_BUFFER_SIZE:\n  case OPT_KEY_CACHE_BLOCK_SIZE:\n  case OPT_KEY_CACHE_DIVISION_LIMIT:\n  case OPT_KEY_CACHE_AGE_THRESHOLD:\n  case OPT_KEY_CACHE_PARTITIONS:\n  case OPT_KEY_CACHE_CHANGED_BLOCKS_HASH_SIZE:\n  {\n    KEY_CACHE *key_cache;\n    if (unlikely(!(key_cache= get_or_create_key_cache(name, length))))\n    {\n      if (error)\n        *error= EXIT_OUT_OF_MEMORY;\n      return 0;\n    }\n    switch (option->id) {\n    case OPT_KEY_BUFFER_SIZE:\n      return &key_cache->param_buff_size;\n    case OPT_KEY_CACHE_BLOCK_SIZE:\n      return &key_cache->param_block_size;\n    case OPT_KEY_CACHE_DIVISION_LIMIT:\n      return &key_cache->param_division_limit;\n    case OPT_KEY_CACHE_AGE_THRESHOLD:\n      return &key_cache->param_age_threshold;\n    case OPT_KEY_CACHE_PARTITIONS:\n      return (uchar**) &key_cache->param_partitions;\n    case OPT_KEY_CACHE_CHANGED_BLOCKS_HASH_SIZE:\n      return (uchar**) &key_cache->changed_blocks_hash_size;\n    }\n  }\n  /* We return in all cases above. Let us silence -Wimplicit-fallthrough */\n  DBUG_ASSERT(0);\n#ifdef HAVE_REPLICATION\n  /* fall through */\n  case OPT_REPLICATE_DO_DB:\n  case OPT_REPLICATE_DO_TABLE:\n  case OPT_REPLICATE_IGNORE_DB:\n  case OPT_REPLICATE_IGNORE_TABLE:\n  case OPT_REPLICATE_WILD_DO_TABLE:\n  case OPT_REPLICATE_WILD_IGNORE_TABLE:\n  case OPT_REPLICATE_REWRITE_DB:\n  case OPT_SLAVE_PARALLEL_MODE:\n  {\n    /* Store current filter for mysqld_get_one_option() */\n    if (!(cur_rpl_filter= get_or_create_rpl_filter(name, length)))\n    {\n      if (error)\n        *error= EXIT_OUT_OF_MEMORY;\n    }\n    if (option->id == OPT_SLAVE_PARALLEL_MODE)\n    {\n      /*\n        Ensure parallel_mode variable is shown in --help. The other\n        variables are not easily printable here.\n       */\n      return (char**) &opt_slave_parallel_mode;\n    }\n    return 0;\n  }\n#endif\n  }\n  return option->value;\n}\n\nstatic void option_error_reporter(enum loglevel level, const char *format, ...)\n{\n  va_list args;\n  va_start(args, format);\n\n  /* Don't print warnings for --loose options during bootstrap */\n  if (level == ERROR_LEVEL || !opt_bootstrap ||\n      global_system_variables.log_warnings)\n  {\n    vprint_msg_to_log(level, format, args);\n  }\n  va_end(args);\n}\n\nC_MODE_END\n\n/**\n  Get server options from the command line,\n  and perform related server initializations.\n  @param [in, out] argc_ptr       command line options (count)\n  @param [in, out] argv_ptr       command line options (values)\n  @return 0 on success\n\n  @todo\n  - FIXME add EXIT_TOO_MANY_ARGUMENTS to \"mysys_err.h\" and return that code?\n*/\nstatic int get_options(int *argc_ptr, char ***argv_ptr)\n{\n  int ho_error;\n\n  my_getopt_register_get_addr(mysql_getopt_value);\n  my_getopt_error_reporter= option_error_reporter;\n\n  /* prepare all_options array */\n  my_init_dynamic_array(&all_options, sizeof(my_option),\n                        array_elements(my_long_options) +\n                        sys_var_elements(),\n                        array_elements(my_long_options)/4, MYF(0));\n  add_many_options(&all_options, my_long_options, array_elements(my_long_options));\n  sys_var_add_options(&all_options, 0);\n  add_terminator(&all_options);\n\n  /* Skip unknown options so that they may be processed later by plugins */\n  my_getopt_skip_unknown= TRUE;\n\n  if ((ho_error= handle_options(argc_ptr, argv_ptr, (my_option*)(all_options.buffer),\n                                mysqld_get_one_option)))\n    return ho_error;\n\n  if (!opt_help)\n    delete_dynamic(&all_options);\n  else\n    opt_abort= 1;\n\n  /* Add back the program name handle_options removes */\n  (*argc_ptr)++;\n  (*argv_ptr)--;\n\n  disable_log_notes= opt_silent_startup;\n\n  /*\n    Options have been parsed. Now some of them need additional special\n    handling, like custom value checking, checking of incompatibilites\n    between options, setting of multiple variables, etc.\n    Do them here.\n  */\n  if (global_system_variables.net_buffer_length > \n      global_system_variables.max_allowed_packet)\n  {\n    sql_print_warning(\"net_buffer_length (%lu) is set to be larger \"\n                      \"than max_allowed_packet (%lu). Please rectify.\",\n                      global_system_variables.net_buffer_length, \n                      global_system_variables.max_allowed_packet);\n  }\n\n  if (log_error_file_ptr != disabled_my_option)\n    opt_error_log= 1;\n  else\n    log_error_file_ptr= const_cast<char*>(\"\");\n\n  opt_init_connect.length=strlen(opt_init_connect.str);\n  opt_init_slave.length=strlen(opt_init_slave.str);\n\n  if (global_system_variables.low_priority_updates)\n    thr_upgraded_concurrent_insert_lock= TL_WRITE_LOW_PRIORITY;\n\n  if (ft_boolean_check_syntax_string((uchar*) ft_boolean_syntax))\n  {\n    sql_print_error(\"Invalid ft-boolean-syntax string: %s\",\n                    ft_boolean_syntax);\n    return 1;\n  }\n\n  if (opt_disable_networking)\n    mysqld_port= mysqld_extra_port= 0;\n\n  if (opt_skip_show_db)\n    opt_specialflag|= SPECIAL_SKIP_SHOW_DB;\n\n  if (myisam_flush)\n    flush_time= 0;\n\n#ifdef HAVE_REPLICATION\n  if (init_slave_skip_errors(opt_slave_skip_errors))\n    return 1;\n  if (init_slave_transaction_retry_errors(opt_slave_transaction_retry_errors))\n    return 1;\n#endif\n\n  if (global_system_variables.max_join_size == HA_POS_ERROR)\n    global_system_variables.option_bits|= OPTION_BIG_SELECTS;\n  else\n    global_system_variables.option_bits&= ~OPTION_BIG_SELECTS;\n\n  if (opt_support_flashback)\n  {\n    /* Force binary logging */\n    if (!opt_bin_logname)\n      opt_bin_logname= (char*) \"\";                  // Use default name\n    opt_bin_log= opt_bin_log_used= 1;\n\n    /* Force format to row */\n    binlog_format_used= 1;\n    global_system_variables.binlog_format= BINLOG_FORMAT_ROW;\n  }\n\n  if (!opt_bootstrap && WSREP_PROVIDER_EXISTS && WSREP_ON &&\n      global_system_variables.binlog_format != BINLOG_FORMAT_ROW)\n  {\n\n    WSREP_ERROR (\"Only binlog_format = 'ROW' is currently supported. \"\n                 \"Configured value: '%s'. Please adjust your configuration.\",\n                 binlog_format_names[global_system_variables.binlog_format]);\n    return 1;\n  }\n\n  // Synchronize @@global.autocommit on --autocommit\n  const ulonglong turn_bit_on= opt_autocommit ?\n    OPTION_AUTOCOMMIT : OPTION_NOT_AUTOCOMMIT;\n  global_system_variables.option_bits=\n    (global_system_variables.option_bits &\n     ~(OPTION_NOT_AUTOCOMMIT | OPTION_AUTOCOMMIT)) | turn_bit_on;\n\n  global_system_variables.sql_mode=\n    expand_sql_mode(global_system_variables.sql_mode);\n#if !defined(HAVE_REALPATH) || defined(HAVE_BROKEN_REALPATH)\n  my_use_symdir=0;\n  my_disable_symlinks=1;\n  have_symlink=SHOW_OPTION_NO;\n#else\n  if (!my_use_symdir)\n  {\n    my_disable_symlinks=1;\n    have_symlink=SHOW_OPTION_DISABLED;\n  }\n#endif\n  if (opt_debugging)\n  {\n    /* Allow break with SIGINT, no core or stack trace */\n    test_flags|= TEST_SIGINT;\n    opt_stack_trace= 1;\n    test_flags&= ~TEST_CORE_ON_SIGNAL;\n  }\n  /* Set global MyISAM variables from delay_key_write_options */\n  fix_delay_key_write(0, 0, OPT_GLOBAL);\n\n#ifndef EMBEDDED_LIBRARY\n  if (mysqld_chroot)\n    set_root(mysqld_chroot);\n#else\n  SYSVAR_AUTOSIZE(thread_handling, SCHEDULER_NO_THREADS);\n  max_allowed_packet= global_system_variables.max_allowed_packet;\n  net_buffer_length= global_system_variables.net_buffer_length;\n#endif\n  if (fix_paths())\n    return 1;\n\n  /*\n    Set some global variables from the global_system_variables\n    In most cases the global variables will not be used\n  */\n  my_disable_locking= myisam_single_user= MY_TEST(opt_external_locking == 0);\n  my_default_record_cache_size=global_system_variables.read_buff_size;\n\n  /*\n    Log mysys errors when we don't have a thd or thd->log_all_errors is set\n    (recovery) to the log.  This is mainly useful for debugging strange system\n    errors.\n  */\n  if (global_system_variables.log_warnings >= 10)\n    my_global_flags= MY_WME | ME_NOTE;\n  /* Log all errors not handled by thd->handle_error() to my_message_sql() */\n  if (global_system_variables.log_warnings >= 11)\n    my_global_flags|= ME_ERROR_LOG;\n  if (my_assert_on_error)\n    debug_assert_if_crashed_table= 1;\n\n  global_system_variables.long_query_time= (ulonglong)\n    (global_system_variables.long_query_time_double * 1e6 + 0.1);\n  global_system_variables.max_statement_time= (ulonglong)\n    (global_system_variables.max_statement_time_double * 1e6 + 0.1);\n\n  if (opt_short_log_format)\n    opt_specialflag|= SPECIAL_SHORT_LOG_FORMAT;\n\n  if (init_global_datetime_format(MYSQL_TIMESTAMP_DATE,\n                                  &global_date_format) ||\n      init_global_datetime_format(MYSQL_TIMESTAMP_TIME,\n                                  &global_time_format) ||\n      init_global_datetime_format(MYSQL_TIMESTAMP_DATETIME,\n                                  &global_datetime_format))\n    return 1;\n\n#ifdef EMBEDDED_LIBRARY\n  one_thread_scheduler(thread_scheduler);\n  one_thread_scheduler(extra_thread_scheduler);\n#else\n\n  if (thread_handling <= SCHEDULER_ONE_THREAD_PER_CONNECTION)\n    one_thread_per_connection_scheduler(thread_scheduler, &max_connections,\n                                        &connection_count);\n  else if (thread_handling == SCHEDULER_NO_THREADS)\n    one_thread_scheduler(thread_scheduler);\n  else\n    pool_of_threads_scheduler(thread_scheduler,  &max_connections,\n                                        &connection_count); \n\n  one_thread_per_connection_scheduler(extra_thread_scheduler,\n                                      &extra_max_connections,\n                                      &extra_connection_count);\n#endif\n\n  opt_readonly= read_only;\n\n  /*\n    If max_long_data_size is not specified explicitly use\n    value of max_allowed_packet.\n  */\n  if (!max_long_data_size_used)\n    SYSVAR_AUTOSIZE(max_long_data_size,\n                    global_system_variables.max_allowed_packet);\n\n  /* Remember if max_user_connections was 0 at startup */\n  max_user_connections_checking= global_system_variables.max_user_connections != 0;\n\n#ifdef HAVE_REPLICATION\n  {\n    sys_var *max_relay_log_size_var, *max_binlog_size_var;\n    /* If max_relay_log_size is 0, then set it to max_binlog_size */\n    if (!global_system_variables.max_relay_log_size)\n      SYSVAR_AUTOSIZE(global_system_variables.max_relay_log_size,\n                      max_binlog_size);\n\n    /*\n      Fix so that DEFAULT and limit checking works with max_relay_log_size\n      (Yes, this is a hack, but it's required as the definition of\n      max_relay_log_size allows it to be set to 0).\n    */\n    max_relay_log_size_var= intern_find_sys_var(STRING_WITH_LEN(\"max_relay_log_size\"));\n    max_binlog_size_var= intern_find_sys_var(STRING_WITH_LEN(\"max_binlog_size\"));\n    if (max_binlog_size_var && max_relay_log_size_var)\n    {\n      max_relay_log_size_var->option.min_value=\n        max_binlog_size_var->option.min_value; \n      max_relay_log_size_var->option.def_value=\n        max_binlog_size_var->option.def_value;\n    }\n  }\n#endif\n\n  /* Ensure that some variables are not set higher than needed */\n  if (thread_cache_size > max_connections)\n    SYSVAR_AUTOSIZE(thread_cache_size, max_connections);\n\n  return 0;\n}\n\n\n/*\n  Create version name for running mysqld version\n  We automaticly add suffixes -debug, -embedded and -log to the version\n  name to make the version more descriptive.\n  (MYSQL_SERVER_SUFFIX is set by the compilation environment)\n*/\n\nvoid set_server_version(char *buf, size_t size)\n{\n  bool is_log= opt_log || global_system_variables.sql_log_slow || opt_bin_log;\n  bool is_debug= IF_DBUG(!strstr(MYSQL_SERVER_SUFFIX_STR, \"-debug\"), 0);\n  strxnmov(buf, size - 1,\n           MYSQL_SERVER_VERSION,\n           MYSQL_SERVER_SUFFIX_STR,\n           IF_EMBEDDED(\"-embedded\", \"\"),\n           is_debug ? \"-debug\" : \"\",\n           is_log ? \"-log\" : \"\",\n           NullS);\n}\n\n\nstatic char *get_relative_path(const char *path)\n{\n  if (test_if_hard_path(path) &&\n      is_prefix(path,DEFAULT_MYSQL_HOME) &&\n      strcmp(DEFAULT_MYSQL_HOME,FN_ROOTDIR))\n  {\n    path+=(uint) strlen(DEFAULT_MYSQL_HOME);\n    while (*path == FN_LIBCHAR || *path == FN_LIBCHAR2)\n      path++;\n  }\n  return (char*) path;\n}\n\n\n/**\n  Fix filename and replace extension where 'dir' is relative to\n  mysql_real_data_home.\n  @return\n    1 if len(path) > FN_REFLEN\n*/\n\nbool\nfn_format_relative_to_data_home(char * to, const char *name,\n\t\t\t\tconst char *dir, const char *extension)\n{\n  char tmp_path[FN_REFLEN];\n  if (!test_if_hard_path(dir))\n  {\n    strxnmov(tmp_path,sizeof(tmp_path)-1, mysql_real_data_home,\n\t     dir, NullS);\n    dir=tmp_path;\n  }\n  return !fn_format(to, name, dir, extension,\n\t\t    MY_APPEND_EXT | MY_UNPACK_FILENAME | MY_SAFE_PATH);\n}\n\n\n/**\n  Test a file path to determine if the path is compatible with the secure file\n  path restriction.\n \n  @param path null terminated character string\n\n  @return\n    @retval TRUE The path is secure\n    @retval FALSE The path isn't secure\n*/\n\nbool is_secure_file_path(char *path)\n{\n  char buff1[FN_REFLEN], buff2[FN_REFLEN];\n  size_t opt_secure_file_priv_len;\n  /*\n    All paths are secure if opt_secure_file_path is 0\n  */\n  if (!opt_secure_file_priv)\n    return TRUE;\n\n  opt_secure_file_priv_len= strlen(opt_secure_file_priv);\n\n  if (strlen(path) >= FN_REFLEN)\n    return FALSE;\n\n  if (my_realpath(buff1, path, 0))\n  {\n    /*\n      The supplied file path might have been a file and not a directory.\n    */\n    size_t length= dirname_length(path);        // Guaranteed to be < FN_REFLEN\n    memcpy(buff2, path, length);\n    buff2[length]= '\\0';\n    if (length == 0 || my_realpath(buff1, buff2, 0))\n      return FALSE;\n  }\n  convert_dirname(buff2, buff1, NullS);\n  if (!lower_case_file_system)\n  {\n    if (strncmp(opt_secure_file_priv, buff2, opt_secure_file_priv_len))\n      return FALSE;\n  }\n  else\n  {\n    if (files_charset_info->coll->strnncoll(files_charset_info,\n                                            (uchar *) buff2, strlen(buff2),\n                                            (uchar *) opt_secure_file_priv,\n                                            opt_secure_file_priv_len,\n                                            TRUE))\n      return FALSE;\n  }\n  return TRUE;\n}\n\n\nstatic int fix_paths(void)\n{\n  char buff[FN_REFLEN],*pos;\n  DBUG_ENTER(\"fix_paths\");\n\n  convert_dirname(mysql_home,mysql_home,NullS);\n  /* Resolve symlinks to allow 'mysql_home' to be a relative symlink */\n  my_realpath(mysql_home,mysql_home,MYF(0));\n  /* Ensure that mysql_home ends in FN_LIBCHAR */\n  pos=strend(mysql_home);\n  if (pos[-1] != FN_LIBCHAR)\n  {\n    pos[0]= FN_LIBCHAR;\n    pos[1]= 0;\n  }\n  convert_dirname(lc_messages_dir, lc_messages_dir, NullS);\n  convert_dirname(mysql_real_data_home,mysql_real_data_home,NullS);\n  (void) my_load_path(mysql_home,mysql_home,\"\"); // Resolve current dir\n  (void) my_load_path(mysql_real_data_home,mysql_real_data_home,mysql_home);\n  (void) my_load_path(pidfile_name, pidfile_name_ptr, mysql_real_data_home);\n\n  convert_dirname(opt_plugin_dir, opt_plugin_dir_ptr ? opt_plugin_dir_ptr : \n                                  get_relative_path(PLUGINDIR), NullS);\n  (void) my_load_path(opt_plugin_dir, opt_plugin_dir, mysql_home);\n  opt_plugin_dir_ptr= opt_plugin_dir;\n  pidfile_name_ptr= pidfile_name;\n\n  my_realpath(mysql_unpacked_real_data_home, mysql_real_data_home, MYF(0));\n  mysql_unpacked_real_data_home_len= \n  strlen(mysql_unpacked_real_data_home);\n  if (mysql_unpacked_real_data_home[mysql_unpacked_real_data_home_len-1] == FN_LIBCHAR)\n    --mysql_unpacked_real_data_home_len;\n\n  char *sharedir=get_relative_path(SHAREDIR);\n  if (test_if_hard_path(sharedir))\n    strmake_buf(buff, sharedir);\t\t/* purecov: tested */\n  else\n    strxnmov(buff,sizeof(buff)-1,mysql_home,sharedir,NullS);\n  convert_dirname(buff,buff,NullS);\n  (void) my_load_path(lc_messages_dir, lc_messages_dir, buff);\n\n  /* If --character-sets-dir isn't given, use shared library dir */\n  if (charsets_dir)\n  {\n    strmake_buf(mysql_charsets_dir, charsets_dir);\n    charsets_dir= mysql_charsets_dir;\n  }\n  else\n  {\n    strxnmov(mysql_charsets_dir, sizeof(mysql_charsets_dir)-1, buff,\n\t     CHARSET_DIR, NullS);\n    SYSVAR_AUTOSIZE(charsets_dir, mysql_charsets_dir);\n  }\n  (void) my_load_path(mysql_charsets_dir, mysql_charsets_dir, buff);\n  convert_dirname(mysql_charsets_dir, mysql_charsets_dir, NullS);\n\n  if (init_tmpdir(&mysql_tmpdir_list, opt_mysql_tmpdir))\n    DBUG_RETURN(1);\n  if (!opt_mysql_tmpdir)\n    opt_mysql_tmpdir= mysql_tmpdir;\n#ifdef HAVE_REPLICATION\n  if (!slave_load_tmpdir)\n    SYSVAR_AUTOSIZE(slave_load_tmpdir, mysql_tmpdir);\n#endif /* HAVE_REPLICATION */\n  /*\n    Convert the secure-file-priv option to system format, allowing\n    a quick strcmp to check if read or write is in an allowed dir\n  */\n  if (opt_secure_file_priv)\n  {\n    if (*opt_secure_file_priv == 0)\n    {\n      my_free(opt_secure_file_priv);\n      opt_secure_file_priv= 0;\n    }\n    else\n    {\n      if (strlen(opt_secure_file_priv) >= FN_REFLEN)\n        opt_secure_file_priv[FN_REFLEN-1]= '\\0';\n      if (my_realpath(buff, opt_secure_file_priv, 0))\n      {\n        sql_print_warning(\"Failed to normalize the argument for --secure-file-priv.\");\n        DBUG_RETURN(1);\n      }\n      char *secure_file_real_path= (char *)my_malloc(FN_REFLEN, MYF(MY_FAE));\n      convert_dirname(secure_file_real_path, buff, NullS);\n      my_free(opt_secure_file_priv);\n      opt_secure_file_priv= secure_file_real_path;\n    }\n  }\n  DBUG_RETURN(0);\n}\n\n/**\n  Check if file system used for databases is case insensitive.\n\n  @param dir_name\t\t\tDirectory to test\n\n  @retval -1  Don't know (Test failed)\n  @retval  0   File system is case sensitive\n  @retval  1   File system is case insensitive\n*/\n\nstatic int test_if_case_insensitive(const char *dir_name)\n{\n  int result= 0;\n  File file;\n  char buff[FN_REFLEN], buff2[FN_REFLEN];\n  MY_STAT stat_info;\n  DBUG_ENTER(\"test_if_case_insensitive\");\n\n  fn_format(buff, opt_log_basename, dir_name, \".lower-test\",\n\t    MY_UNPACK_FILENAME | MY_REPLACE_EXT | MY_REPLACE_DIR);\n  fn_format(buff2, opt_log_basename, dir_name, \".LOWER-TEST\",\n\t    MY_UNPACK_FILENAME | MY_REPLACE_EXT | MY_REPLACE_DIR);\n  mysql_file_delete(key_file_casetest, buff2, MYF(0));\n  if ((file= mysql_file_create(key_file_casetest,\n                               buff, 0666, O_RDWR, MYF(0))) < 0)\n  {\n    if (!opt_abort)\n      sql_print_warning(\"Can't create test file %s\", buff);\n    DBUG_RETURN(-1);\n  }\n  mysql_file_close(file, MYF(0));\n  if (mysql_file_stat(key_file_casetest, buff2, &stat_info, MYF(0)))\n    result= 1;\t\t\t\t\t// Can access file\n  mysql_file_delete(key_file_casetest, buff, MYF(MY_WME));\n  DBUG_PRINT(\"exit\", (\"result: %d\", result));\n  DBUG_RETURN(result);\n}\n\n\n#ifndef EMBEDDED_LIBRARY\n\n/**\n  Create file to store pid number.\n*/\nstatic void create_pid_file()\n{\n  File file;\n  if ((file= mysql_file_create(key_file_pid, pidfile_name, 0664,\n                               O_WRONLY | O_TRUNC, MYF(MY_WME))) >= 0)\n  {\n    char buff[MAX_BIGINT_WIDTH + 1], *end;\n    end= int10_to_str((long) getpid(), buff, 10);\n    *end++= '\\n';\n    if (!mysql_file_write(file, (uchar*) buff, (uint) (end-buff),\n                          MYF(MY_WME | MY_NABP)))\n    {\n      mysql_file_close(file, MYF(0));\n      pid_file_created= true;\n      return;\n    }\n    mysql_file_close(file, MYF(0));\n  }\n  sql_perror(\"Can't start server: can't create PID file\");\n  exit(1);\n}\n#endif /* EMBEDDED_LIBRARY */\n\n\n/**\n  Remove the process' pid file.\n  \n  @param  flags  file operation flags\n*/\n\nstatic void delete_pid_file(myf flags)\n{\n#ifndef EMBEDDED_LIBRARY\n  if (pid_file_created)\n  {\n    mysql_file_delete(key_file_pid, pidfile_name, flags);\n    pid_file_created= false;\n  }\n#endif /* EMBEDDED_LIBRARY */\n  return;\n}\n\n\n/** Clear most status variables. */\nvoid refresh_status(THD *thd)\n{\n  mysql_mutex_lock(&LOCK_status);\n\n  /* Add thread's status variabes to global status */\n  add_to_status(&global_status_var, &thd->status_var);\n\n  /* Reset thread's status variables */\n  thd->set_status_var_init();\n  thd->status_var.global_memory_used= 0;\n  bzero((uchar*) &thd->org_status_var, sizeof(thd->org_status_var)); \n  thd->start_bytes_received= 0;\n\n  /* Reset some global variables */\n  reset_status_vars();\n#ifdef WITH_WSREP\n  if (WSREP_ON)\n  {\n    Wsrep_server_state::instance().provider().reset_status();\n  }\n#endif /* WITH_WSREP */\n\n  /* Reset the counters of all key caches (default and named). */\n  process_key_caches(reset_key_cache_counters, 0);\n  flush_status_time= time((time_t*) 0);\n  mysql_mutex_unlock(&LOCK_status);\n\n  /*\n    Set max_used_connections to the number of currently open\n    connections.  This is not perfect, but status data is not exact anyway.\n  */\n  max_used_connections= connection_count + extra_connection_count;\n}\n\n#ifdef HAVE_PSI_INTERFACE\nstatic PSI_file_info all_server_files[]=\n{\n#ifdef HAVE_MMAP\n  { &key_file_map, \"map\", 0},\n#endif /* HAVE_MMAP */\n  { &key_file_binlog, \"binlog\", 0},\n  { &key_file_binlog_index, \"binlog_index\", 0},\n  { &key_file_relaylog, \"relaylog\", 0},\n  { &key_file_relaylog_index, \"relaylog_index\", 0},\n  { &key_file_casetest, \"casetest\", 0},\n  { &key_file_dbopt, \"dbopt\", 0},\n  { &key_file_des_key_file, \"des_key_file\", 0},\n  { &key_file_ERRMSG, \"ERRMSG\", 0},\n  { &key_select_to_file, \"select_to_file\", 0},\n  { &key_file_fileparser, \"file_parser\", 0},\n  { &key_file_frm, \"FRM\", 0},\n  { &key_file_global_ddl_log, \"global_ddl_log\", 0},\n  { &key_file_load, \"load\", 0},\n  { &key_file_loadfile, \"LOAD_FILE\", 0},\n  { &key_file_log_event_data, \"log_event_data\", 0},\n  { &key_file_log_event_info, \"log_event_info\", 0},\n  { &key_file_master_info, \"master_info\", 0},\n  { &key_file_misc, \"misc\", 0},\n  { &key_file_partition, \"partition\", 0},\n  { &key_file_pid, \"pid\", 0},\n  { &key_file_query_log, \"query_log\", 0},\n  { &key_file_relay_log_info, \"relay_log_info\", 0},\n  { &key_file_send_file, \"send_file\", 0},\n  { &key_file_slow_log, \"slow_log\", 0},\n  { &key_file_tclog, \"tclog\", 0},\n  { &key_file_trg, \"trigger_name\", 0},\n  { &key_file_trn, \"trigger\", 0},\n  { &key_file_init, \"init\", 0},\n  { &key_file_binlog_state, \"binlog_state\", 0}\n};\n#endif /* HAVE_PSI_INTERFACE */\n\nPSI_stage_info stage_after_apply_event= { 0, \"After apply log event\", 0};\nPSI_stage_info stage_after_create= { 0, \"After create\", 0};\nPSI_stage_info stage_after_opening_tables= { 0, \"After opening tables\", 0};\nPSI_stage_info stage_after_table_lock= { 0, \"After table lock\", 0};\nPSI_stage_info stage_allocating_local_table= { 0, \"Allocating local table\", 0};\nPSI_stage_info stage_alter_inplace_prepare= { 0, \"Preparing for alter table\", 0};\nPSI_stage_info stage_alter_inplace= { 0, \"Altering table\", 0};\nPSI_stage_info stage_alter_inplace_commit= { 0, \"Committing alter table to storage engine\", 0};\nPSI_stage_info stage_apply_event= { 0, \"Apply log event\", 0};\nPSI_stage_info stage_changing_master= { 0, \"Changing master\", 0};\nPSI_stage_info stage_checking_master_version= { 0, \"Checking master version\", 0};\nPSI_stage_info stage_checking_permissions= { 0, \"Checking permissions\", 0};\nPSI_stage_info stage_checking_privileges_on_cached_query= { 0, \"Checking privileges on cached query\", 0};\nPSI_stage_info stage_checking_query_cache_for_query= { 0, \"Checking query cache for query\", 0};\nPSI_stage_info stage_cleaning_up= { 0, \"Reset for next command\", 0};\nPSI_stage_info stage_closing_tables= { 0, \"Closing tables\", 0};\nPSI_stage_info stage_connecting_to_master= { 0, \"Connecting to master\", 0};\nPSI_stage_info stage_converting_heap_to_myisam= { 0, \"Converting HEAP to \" TMP_ENGINE_NAME, 0};\nPSI_stage_info stage_copying_to_group_table= { 0, \"Copying to group table\", 0};\nPSI_stage_info stage_copying_to_tmp_table= { 0, \"Copying to tmp table\", 0};\nPSI_stage_info stage_copy_to_tmp_table= { 0, \"Copy to tmp table\", 0};\nPSI_stage_info stage_creating_delayed_handler= { 0, \"Creating delayed handler\", 0};\nPSI_stage_info stage_creating_sort_index= { 0, \"Creating sort index\", 0};\nPSI_stage_info stage_creating_table= { 0, \"Creating table\", 0};\nPSI_stage_info stage_creating_tmp_table= { 0, \"Creating tmp table\", 0};\nPSI_stage_info stage_deleting_from_main_table= { 0, \"Deleting from main table\", 0};\nPSI_stage_info stage_deleting_from_reference_tables= { 0, \"Deleting from reference tables\", 0};\nPSI_stage_info stage_discard_or_import_tablespace= { 0, \"Discard_or_import_tablespace\", 0};\nPSI_stage_info stage_enabling_keys= { 0, \"Enabling keys\", 0};\nPSI_stage_info stage_end= { 0, \"End of update loop\", 0};\nPSI_stage_info stage_executing= { 0, \"Executing\", 0};\nPSI_stage_info stage_execution_of_init_command= { 0, \"Execution of init_command\", 0};\nPSI_stage_info stage_explaining= { 0, \"Explaining\", 0};\nPSI_stage_info stage_finding_key_cache= { 0, \"Finding key cache\", 0};\nPSI_stage_info stage_finished_reading_one_binlog_switching_to_next_binlog= { 0, \"Finished reading one binlog; switching to next binlog\", 0};\nPSI_stage_info stage_flushing_relay_log_and_master_info_repository= { 0, \"Flushing relay log and master info repository.\", 0};\nPSI_stage_info stage_flushing_relay_log_info_file= { 0, \"Flushing relay-log info file.\", 0};\nPSI_stage_info stage_freeing_items= { 0, \"Freeing items\", 0};\nPSI_stage_info stage_fulltext_initialization= { 0, \"Fulltext initialization\", 0};\nPSI_stage_info stage_got_handler_lock= { 0, \"Got handler lock\", 0};\nPSI_stage_info stage_got_old_table= { 0, \"Got old table\", 0};\nPSI_stage_info stage_init= { 0, \"Init\", 0};\nPSI_stage_info stage_init_update= { 0, \"Init for update\", 0};\nPSI_stage_info stage_insert= { 0, \"Insert\", 0};\nPSI_stage_info stage_invalidating_query_cache_entries_table= { 0, \"Invalidating query cache entries (table)\", 0};\nPSI_stage_info stage_invalidating_query_cache_entries_table_list= { 0, \"Invalidating query cache entries (table list)\", 0};\nPSI_stage_info stage_killing_slave= { 0, \"Killing slave\", 0};\nPSI_stage_info stage_logging_slow_query= { 0, \"Logging slow query\", 0};\nPSI_stage_info stage_making_temp_file_append_before_load_data= { 0, \"Making temporary file (append) before replaying LOAD DATA INFILE.\", 0};\nPSI_stage_info stage_making_temp_file_create_before_load_data= { 0, \"Making temporary file (create) before replaying LOAD DATA INFILE.\", 0};\nPSI_stage_info stage_manage_keys= { 0, \"Manage keys\", 0};\nPSI_stage_info stage_master_has_sent_all_binlog_to_slave= { 0, \"Master has sent all binlog to slave; waiting for binlog to be updated\", 0};\nPSI_stage_info stage_opening_tables= { 0, \"Opening tables\", 0};\nPSI_stage_info stage_optimizing= { 0, \"Optimizing\", 0};\nPSI_stage_info stage_preparing= { 0, \"Preparing\", 0};\nPSI_stage_info stage_purging_old_relay_logs= { 0, \"Purging old relay logs\", 0};\nPSI_stage_info stage_query_end= { 0, \"Query end\", 0};\nPSI_stage_info stage_starting_cleanup= { 0, \"Starting cleanup\", 0};\nPSI_stage_info stage_rollback= { 0, \"Rollback\", 0};\nPSI_stage_info stage_rollback_implicit= { 0, \"Rollback_implicit\", 0};\nPSI_stage_info stage_commit= { 0, \"Commit\", 0};\nPSI_stage_info stage_commit_implicit= { 0, \"Commit_implicit\", 0};\nPSI_stage_info stage_queueing_master_event_to_the_relay_log= { 0, \"Queueing master event to the relay log\", 0};\nPSI_stage_info stage_reading_event_from_the_relay_log= { 0, \"Reading event from the relay log\", 0};\nPSI_stage_info stage_recreating_table= { 0, \"Recreating table\", 0};\nPSI_stage_info stage_registering_slave_on_master= { 0, \"Registering slave on master\", 0};\nPSI_stage_info stage_removing_duplicates= { 0, \"Removing duplicates\", 0};\nPSI_stage_info stage_removing_tmp_table= { 0, \"Removing tmp table\", 0};\nPSI_stage_info stage_rename= { 0, \"Rename\", 0};\nPSI_stage_info stage_rename_result_table= { 0, \"Rename result table\", 0};\nPSI_stage_info stage_requesting_binlog_dump= { 0, \"Requesting binlog dump\", 0};\nPSI_stage_info stage_reschedule= { 0, \"Reschedule\", 0};\nPSI_stage_info stage_searching_rows_for_update= { 0, \"Searching rows for update\", 0};\nPSI_stage_info stage_sending_binlog_event_to_slave= { 0, \"Sending binlog event to slave\", 0};\nPSI_stage_info stage_sending_cached_result_to_client= { 0, \"Sending cached result to client\", 0};\nPSI_stage_info stage_sending_data= { 0, \"Sending data\", 0};\nPSI_stage_info stage_setup= { 0, \"Setup\", 0};\nPSI_stage_info stage_show_explain= { 0, \"Show explain\", 0};\nPSI_stage_info stage_slave_has_read_all_relay_log= { 0, \"Slave has read all relay log; waiting for the slave I/O thread to update it\", 0};\nPSI_stage_info stage_sorting= { 0, \"Sorting\", 0};\nPSI_stage_info stage_sorting_for_group= { 0, \"Sorting for group\", 0};\nPSI_stage_info stage_sorting_for_order= { 0, \"Sorting for order\", 0};\nPSI_stage_info stage_sorting_result= { 0, \"Sorting result\", 0};\nPSI_stage_info stage_statistics= { 0, \"Statistics\", 0};\nPSI_stage_info stage_sql_thd_waiting_until_delay= { 0, \"Waiting until MASTER_DELAY seconds after master executed event\", 0 };\nPSI_stage_info stage_storing_result_in_query_cache= { 0, \"Storing result in query cache\", 0};\nPSI_stage_info stage_storing_row_into_queue= { 0, \"Storing row into queue\", 0};\nPSI_stage_info stage_system_lock= { 0, \"System lock\", 0};\nPSI_stage_info stage_unlocking_tables= { 0, \"Unlocking tables\", 0};\nPSI_stage_info stage_table_lock= { 0, \"Table lock\", 0};\nPSI_stage_info stage_filling_schema_table= { 0, \"Filling schema table\", 0};\nPSI_stage_info stage_update= { 0, \"Update\", 0};\nPSI_stage_info stage_updating= { 0, \"Updating\", 0};\nPSI_stage_info stage_updating_main_table= { 0, \"Updating main table\", 0};\nPSI_stage_info stage_updating_reference_tables= { 0, \"Updating reference tables\", 0};\nPSI_stage_info stage_upgrading_lock= { 0, \"Upgrading lock\", 0};\nPSI_stage_info stage_user_lock= { 0, \"User lock\", 0};\nPSI_stage_info stage_user_sleep= { 0, \"User sleep\", 0};\nPSI_stage_info stage_verifying_table= { 0, \"Verifying table\", 0};\nPSI_stage_info stage_waiting_for_delay_list= { 0, \"Waiting for delay_list\", 0};\nPSI_stage_info stage_waiting_for_gtid_to_be_written_to_binary_log= { 0, \"Waiting for GTID to be written to binary log\", 0};\nPSI_stage_info stage_waiting_for_handler_insert= { 0, \"Waiting for handler insert\", 0};\nPSI_stage_info stage_waiting_for_handler_lock= { 0, \"Waiting for handler lock\", 0};\nPSI_stage_info stage_waiting_for_handler_open= { 0, \"Waiting for handler open\", 0};\nPSI_stage_info stage_waiting_for_insert= { 0, \"Waiting for INSERT\", 0};\nPSI_stage_info stage_waiting_for_master_to_send_event= { 0, \"Waiting for master to send event\", 0};\nPSI_stage_info stage_waiting_for_master_update= { 0, \"Waiting for master update\", 0};\nPSI_stage_info stage_waiting_for_relay_log_space= { 0, \"Waiting for the slave SQL thread to free enough relay log space\", 0};\nPSI_stage_info stage_waiting_for_semi_sync_ack_from_slave=\n{ 0, \"Waiting for semi-sync ACK from slave\", 0};\nPSI_stage_info stage_waiting_for_semi_sync_slave={ 0, \"Waiting for semi-sync slave connection\", 0};\nPSI_stage_info stage_reading_semi_sync_ack={ 0, \"Reading semi-sync ACK from slave\", 0};\nPSI_stage_info stage_waiting_for_slave_mutex_on_exit= { 0, \"Waiting for slave mutex on exit\", 0};\nPSI_stage_info stage_waiting_for_slave_thread_to_start= { 0, \"Waiting for slave thread to start\", 0};\nPSI_stage_info stage_waiting_for_table_flush= { 0, \"Waiting for table flush\", 0};\nPSI_stage_info stage_waiting_for_query_cache_lock= { 0, \"Waiting for query cache lock\", 0};\nPSI_stage_info stage_waiting_for_the_next_event_in_relay_log= { 0, \"Waiting for the next event in relay log\", 0};\nPSI_stage_info stage_waiting_for_the_slave_thread_to_advance_position= { 0, \"Waiting for the slave SQL thread to advance position\", 0};\nPSI_stage_info stage_waiting_to_finalize_termination= { 0, \"Waiting to finalize termination\", 0};\nPSI_stage_info stage_waiting_to_get_readlock= { 0, \"Waiting to get readlock\", 0};\nPSI_stage_info stage_binlog_waiting_background_tasks= { 0, \"Waiting for background binlog tasks\", 0};\nPSI_stage_info stage_binlog_write= { 0, \"Writing to binlog\", 0};\nPSI_stage_info stage_binlog_processing_checkpoint_notify= { 0, \"Processing binlog checkpoint notification\", 0};\nPSI_stage_info stage_binlog_stopping_background_thread= { 0, \"Stopping binlog background thread\", 0};\nPSI_stage_info stage_waiting_for_work_from_sql_thread= { 0, \"Waiting for work from SQL thread\", 0};\nPSI_stage_info stage_waiting_for_prior_transaction_to_commit= { 0, \"Waiting for prior transaction to commit\", 0};\nPSI_stage_info stage_waiting_for_prior_transaction_to_start_commit= { 0, \"Waiting for prior transaction to start commit before starting next transaction\", 0};\nPSI_stage_info stage_waiting_for_room_in_worker_thread= { 0, \"Waiting for room in worker thread event queue\", 0};\nPSI_stage_info stage_waiting_for_workers_idle= { 0, \"Waiting for worker threads to be idle\", 0};\nPSI_stage_info stage_waiting_for_ftwrl= { 0, \"Waiting due to global read lock\", 0};\nPSI_stage_info stage_waiting_for_ftwrl_threads_to_pause= { 0, \"Waiting for worker threads to pause for global read lock\", 0};\nPSI_stage_info stage_waiting_for_rpl_thread_pool= { 0, \"Waiting while replication worker thread pool is busy\", 0};\nPSI_stage_info stage_master_gtid_wait_primary= { 0, \"Waiting in MASTER_GTID_WAIT() (primary waiter)\", 0};\nPSI_stage_info stage_master_gtid_wait= { 0, \"Waiting in MASTER_GTID_WAIT()\", 0};\nPSI_stage_info stage_gtid_wait_other_connection= { 0, \"Waiting for other master connection to process GTID received on multiple master connections\", 0};\nPSI_stage_info stage_slave_background_process_request= { 0, \"Processing requests\", 0};\nPSI_stage_info stage_slave_background_wait_request= { 0, \"Waiting for requests\", 0};\nPSI_stage_info stage_waiting_for_deadlock_kill= { 0, \"Waiting for parallel replication deadlock handling to complete\", 0};\n\n#ifdef HAVE_PSI_INTERFACE\n\nPSI_stage_info *all_server_stages[]=\n{\n  & stage_after_apply_event,\n  & stage_after_create,\n  & stage_after_opening_tables,\n  & stage_after_table_lock,\n  & stage_allocating_local_table,\n  & stage_alter_inplace,\n  & stage_alter_inplace_commit,\n  & stage_alter_inplace_prepare,\n  & stage_apply_event,\n  & stage_binlog_write,\n  & stage_binlog_processing_checkpoint_notify,\n  & stage_binlog_stopping_background_thread,\n  & stage_binlog_waiting_background_tasks,\n  & stage_changing_master,\n  & stage_checking_master_version,\n  & stage_checking_permissions,\n  & stage_checking_privileges_on_cached_query,\n  & stage_checking_query_cache_for_query,\n  & stage_cleaning_up,\n  & stage_closing_tables,\n  & stage_commit,\n  & stage_commit_implicit,\n  & stage_connecting_to_master,\n  & stage_converting_heap_to_myisam,\n  & stage_copy_to_tmp_table,\n  & stage_copying_to_group_table,\n  & stage_copying_to_tmp_table,\n  & stage_creating_delayed_handler,\n  & stage_creating_sort_index,\n  & stage_creating_table,\n  & stage_creating_tmp_table,\n  & stage_deleting_from_main_table,\n  & stage_deleting_from_reference_tables,\n  & stage_discard_or_import_tablespace,\n  & stage_enabling_keys,\n  & stage_end,\n  & stage_executing,\n  & stage_execution_of_init_command,\n  & stage_explaining,\n  & stage_finding_key_cache,\n  & stage_finished_reading_one_binlog_switching_to_next_binlog,\n  & stage_flushing_relay_log_and_master_info_repository,\n  & stage_flushing_relay_log_info_file,\n  & stage_freeing_items,\n  & stage_fulltext_initialization,\n  & stage_got_handler_lock,\n  & stage_got_old_table,\n  & stage_init,\n  & stage_init_update,\n  & stage_insert,\n  & stage_invalidating_query_cache_entries_table,\n  & stage_invalidating_query_cache_entries_table_list,\n  & stage_killing_slave,\n  & stage_logging_slow_query,\n  & stage_making_temp_file_append_before_load_data,\n  & stage_making_temp_file_create_before_load_data,\n  & stage_manage_keys,\n  & stage_master_has_sent_all_binlog_to_slave,\n  & stage_opening_tables,\n  & stage_optimizing,\n  & stage_preparing,\n  & stage_purging_old_relay_logs,\n  & stage_starting_cleanup,\n  & stage_query_end,\n  & stage_queueing_master_event_to_the_relay_log,\n  & stage_reading_event_from_the_relay_log,\n  & stage_recreating_table,\n  & stage_registering_slave_on_master,\n  & stage_removing_duplicates,\n  & stage_removing_tmp_table,\n  & stage_rename,\n  & stage_rename_result_table,\n  & stage_requesting_binlog_dump,\n  & stage_reschedule,\n  & stage_rollback,\n  & stage_rollback_implicit,\n  & stage_searching_rows_for_update,\n  & stage_sending_binlog_event_to_slave,\n  & stage_sending_cached_result_to_client,\n  & stage_sending_data,\n  & stage_setup,\n  & stage_show_explain,\n  & stage_slave_has_read_all_relay_log,\n  & stage_sorting,\n  & stage_sorting_for_group,\n  & stage_sorting_for_order,\n  & stage_sorting_result,\n  & stage_sql_thd_waiting_until_delay,\n  & stage_statistics,\n  & stage_storing_result_in_query_cache,\n  & stage_storing_row_into_queue,\n  & stage_system_lock,\n  & stage_unlocking_tables,\n  & stage_table_lock,\n  & stage_filling_schema_table,\n  & stage_update,\n  & stage_updating,\n  & stage_updating_main_table,\n  & stage_updating_reference_tables,\n  & stage_upgrading_lock,\n  & stage_user_lock,\n  & stage_user_sleep,\n  & stage_verifying_table,\n  & stage_waiting_for_delay_list,\n  & stage_waiting_for_gtid_to_be_written_to_binary_log,\n  & stage_waiting_for_handler_insert,\n  & stage_waiting_for_handler_lock,\n  & stage_waiting_for_handler_open,\n  & stage_waiting_for_insert,\n  & stage_waiting_for_master_to_send_event,\n  & stage_waiting_for_master_update,\n  & stage_waiting_for_prior_transaction_to_commit,\n  & stage_waiting_for_prior_transaction_to_start_commit,\n  & stage_waiting_for_query_cache_lock,\n  & stage_waiting_for_relay_log_space,\n  & stage_waiting_for_room_in_worker_thread,\n  & stage_waiting_for_slave_mutex_on_exit,\n  & stage_waiting_for_slave_thread_to_start,\n  & stage_waiting_for_table_flush,\n  & stage_waiting_for_the_next_event_in_relay_log,\n  & stage_waiting_for_the_slave_thread_to_advance_position,\n  & stage_waiting_for_work_from_sql_thread,\n  & stage_waiting_to_finalize_termination,\n  & stage_waiting_to_get_readlock,\n  & stage_master_gtid_wait_primary,\n  & stage_master_gtid_wait,\n  & stage_gtid_wait_other_connection,\n  & stage_slave_background_process_request,\n  & stage_slave_background_wait_request,\n  & stage_waiting_for_semi_sync_ack_from_slave,\n  & stage_waiting_for_semi_sync_slave,\n  & stage_reading_semi_sync_ack,\n  & stage_waiting_for_deadlock_kill\n};\n\nPSI_socket_key key_socket_tcpip, key_socket_unix, key_socket_client_connection;\n\nstatic PSI_socket_info all_server_sockets[]=\n{\n  { &key_socket_tcpip, \"server_tcpip_socket\", PSI_FLAG_GLOBAL},\n  { &key_socket_unix, \"server_unix_socket\", PSI_FLAG_GLOBAL},\n  { &key_socket_client_connection, \"client_connection\", 0}\n};\n\n/**\n  Initialise all the performance schema instrumentation points\n  used by the server.\n*/\nvoid init_server_psi_keys(void)\n{\n  const char* category= \"sql\";\n  int count;\n\n  count= array_elements(all_server_mutexes);\n  mysql_mutex_register(category, all_server_mutexes, count);\n\n  count= array_elements(all_server_rwlocks);\n  mysql_rwlock_register(category, all_server_rwlocks, count);\n\n  count= array_elements(all_server_conds);\n  mysql_cond_register(category, all_server_conds, count);\n\n  count= array_elements(all_server_threads);\n  mysql_thread_register(category, all_server_threads, count);\n\n  count= array_elements(all_server_files);\n  mysql_file_register(category, all_server_files, count);\n\n  count= array_elements(all_server_stages);\n  mysql_stage_register(category, all_server_stages, count);\n\n  count= array_elements(all_server_sockets);\n  mysql_socket_register(category, all_server_sockets, count);\n\n#ifdef HAVE_PSI_STATEMENT_INTERFACE\n  init_sql_statement_info();\n  count= array_elements(sql_statement_info);\n  mysql_statement_register(category, sql_statement_info, count);\n\n  category= \"com\";\n  init_com_statement_info();\n\n  /*\n    Register [0 .. COM_QUERY - 1] as \"statement/com/...\"\n  */\n  count= (int) COM_QUERY;\n  mysql_statement_register(category, com_statement_info, count);\n\n  /*\n    Register [COM_QUERY + 1 .. COM_END] as \"statement/com/...\"\n  */\n  count= (int) COM_END - (int) COM_QUERY;\n  mysql_statement_register(category, & com_statement_info[(int) COM_QUERY + 1], count);\n\n  category= \"abstract\";\n  /*\n    Register [COM_QUERY] as \"statement/abstract/com_query\"\n  */\n  mysql_statement_register(category, & com_statement_info[(int) COM_QUERY], 1);\n\n  /*\n    When a new packet is received,\n    it is instrumented as \"statement/abstract/new_packet\".\n    Based on the packet type found, it later mutates to the\n    proper narrow type, for example\n    \"statement/abstract/query\" or \"statement/com/ping\".\n    In cases of \"statement/abstract/query\", SQL queries are given to\n    the parser, which mutates the statement type to an even more\n    narrow classification, for example \"statement/sql/select\".\n  */\n  stmt_info_new_packet.m_key= 0;\n  stmt_info_new_packet.m_name= \"new_packet\";\n  stmt_info_new_packet.m_flags= PSI_FLAG_MUTABLE;\n  mysql_statement_register(category, &stmt_info_new_packet, 1);\n\n  /*\n    Statements processed from the relay log are initially instrumented as\n    \"statement/abstract/relay_log\". The parser will mutate the statement type to\n    a more specific classification, for example \"statement/sql/insert\".\n  */\n  stmt_info_rpl.m_key= 0;\n  stmt_info_rpl.m_name= \"relay_log\";\n  stmt_info_rpl.m_flags= PSI_FLAG_MUTABLE;\n  mysql_statement_register(category, &stmt_info_rpl, 1);\n#endif\n}\n\n#endif /* HAVE_PSI_INTERFACE */\n\n\n/*\n  Connection ID allocation.\n\n  We need to maintain thread_ids in the 32bit range,\n  because this is how it is passed to the client in the protocol.\n\n  The idea is to maintain a id range, initially set to\n (0,UINT32_MAX). Whenever new id is needed, we increment the\n  lower limit and return its new value.\n\n  On \"overflow\", if id can not be generated anymore(i.e lower == upper -1),\n  we recalculate the range boundaries.\n  To do that, we first collect thread ids that are in use, by traversing\n  THD list, and find largest region within (0,UINT32_MAX), that is still free.\n\n*/\n\nstatic my_thread_id thread_id_max= UINT_MAX32;\n\n#include <vector>\n#include <algorithm>\n\n/*\n  Find largest unused thread_id range.\n\n  i.e for every number N within the returned range,\n  there is no existing connection with thread_id equal to N.\n\n  The range is exclusive, lower bound is always >=0 and\n  upper bound <=MAX_UINT32.\n\n  @param[out] low  - lower bound for the range\n  @param[out] high - upper bound for the range\n*/\n\nstatic my_bool recalculate_callback(THD *thd, std::vector<my_thread_id> *ids)\n{\n  ids->push_back(thd->thread_id);\n  return 0;\n}\n\n\nstatic void recalculate_thread_id_range(my_thread_id *low, my_thread_id *high)\n{\n  std::vector<my_thread_id> ids;\n\n  // Add sentinels\n  ids.push_back(0);\n  ids.push_back(UINT_MAX32);\n  server_threads.iterate(recalculate_callback, &ids);\n\n  std::sort(ids.begin(), ids.end());\n  my_thread_id max_gap= 0;\n  for (size_t i= 0; i < ids.size() - 1; i++)\n  {\n    my_thread_id gap= ids[i+1] - ids[i];\n    if (gap > max_gap)\n    {\n      *low= ids[i];\n      *high= ids[i+1];\n      max_gap= gap;\n    }\n  }\n\n  if (max_gap < 2)\n  {\n    /* Can't find free id. This is not really possible,\n      we'd need 2^32 connections for this to happen.*/\n    sql_print_error(\"Cannot find free connection id.\");\n    abort();\n  }\n}\n\n\nmy_thread_id next_thread_id(void)\n{\n  my_thread_id retval;\n  DBUG_EXECUTE_IF(\"thread_id_overflow\", global_thread_id= thread_id_max-2;);\n\n  mysql_mutex_lock(&LOCK_thread_id);\n\n  if (unlikely(global_thread_id == thread_id_max - 1))\n  {\n    recalculate_thread_id_range(&global_thread_id, &thread_id_max);\n  }\n\n  retval= ++global_thread_id;\n\n  mysql_mutex_unlock(&LOCK_thread_id);\n  return retval;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/sql/sql_plugin.h": "/* Copyright (c) 2005, 2012, Oracle and/or its affiliates.\n   Copyright (c) 2009, 2017, MariaDB Corporation.\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; version 2 of the License.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1335  USA */\n\n#ifndef _sql_plugin_h\n#define _sql_plugin_h\n\n/*\n  the following #define adds server-only members to enum_mysql_show_type,\n  that is defined in plugin.h\n*/\n#define SHOW_always_last SHOW_KEY_CACHE_LONG, \\\n            SHOW_LONG_STATUS, SHOW_DOUBLE_STATUS, \\\n            SHOW_HAVE, SHOW_MY_BOOL, SHOW_HA_ROWS, SHOW_SYS, \\\n            SHOW_LONG_NOFLUSH, SHOW_LONGLONG_STATUS, SHOW_UINT32_STATUS, \\\n            SHOW_LEX_STRING\n#include \"mariadb.h\"\n#undef SHOW_always_last\n\n#include \"m_string.h\"                       /* LEX_STRING */\n#include \"my_alloc.h\"                       /* MEM_ROOT */\n\nclass sys_var;\nenum SHOW_COMP_OPTION { SHOW_OPTION_YES, SHOW_OPTION_NO, SHOW_OPTION_DISABLED};\nenum enum_plugin_load_option { PLUGIN_OFF, PLUGIN_ON, PLUGIN_FORCE,\n  PLUGIN_FORCE_PLUS_PERMANENT };\nextern const char *global_plugin_typelib_names[];\n\nextern volatile int global_plugin_version;\nextern ulong dlopen_count;\n\n#include <my_sys.h>\n#include \"sql_list.h\"\n\n#ifdef DBUG_OFF\n#define plugin_ref_to_int(A) A\n#define plugin_int_to_ref(A) A\n#else\n#define plugin_ref_to_int(A) (A ? A[0] : NULL)\n#define plugin_int_to_ref(A) &(A)\n#endif\n\n/*\n  the following flags are valid for plugin_init()\n*/\n#define PLUGIN_INIT_SKIP_DYNAMIC_LOADING 1U\n#define PLUGIN_INIT_SKIP_PLUGIN_TABLE    2U\n#define PLUGIN_INIT_SKIP_INITIALIZATION  4U\n\n#define INITIAL_LEX_PLUGIN_LIST_SIZE    16\n\ntypedef enum enum_mysql_show_type SHOW_TYPE;\ntypedef struct st_mysql_show_var SHOW_VAR;\n\n#define MYSQL_ANY_PLUGIN         -1\n\n/*\n  different values of st_plugin_int::state\n  though they look like a bitmap, plugin may only\n  be in one of those eigenstates, not in a superposition of them :)\n  It's a bitmap, because it makes it easier to test\n  \"whether the state is one of those...\"\n*/\n#define PLUGIN_IS_FREED         1U\n#define PLUGIN_IS_DELETED       2U\n#define PLUGIN_IS_UNINITIALIZED 4U\n#define PLUGIN_IS_READY         8U\n#define PLUGIN_IS_DYING         16U\n#define PLUGIN_IS_DISABLED      32U\n\nstruct st_ptr_backup {\n  void **ptr;\n  void *value;\n  void save(void **p) { ptr= p; value= *p; }\n  void save(const char **p) { save((void**)p); }\n  void restore() { *ptr= value; }\n};\n\n/* A handle for the dynamic library containing a plugin or plugins. */\n\nstruct st_plugin_dl\n{\n  LEX_CSTRING dl;\n  void *handle;\n  struct st_maria_plugin *plugins;\n  st_ptr_backup *ptr_backup;\n  uint nbackups;\n  uint ref_count;            /* number of plugins loaded from the library */\n  int mysqlversion;\n  int mariaversion;\n  bool   allocated;\n};\n\n/* A handle of a plugin */\n\nstruct st_plugin_int\n{\n  LEX_CSTRING name;\n  struct st_maria_plugin *plugin;\n  struct st_plugin_dl *plugin_dl;\n  st_ptr_backup *ptr_backup;\n  uint nbackups;\n  uint state;\n  uint ref_count;               /* number of threads using the plugin */\n  uint locks_total;             /* how many times the plugin was locked */\n  void *data;                   /* plugin type specific, e.g. handlerton */\n  MEM_ROOT mem_root;            /* memory for dynamic plugin structures */\n  sys_var *system_vars;         /* server variables for this plugin */\n  enum enum_plugin_load_option load_option; /* OFF, ON, FORCE, F+PERMANENT */\n};\n\n\nextern mysql_mutex_t LOCK_plugin;\n\n/*\n  See intern_plugin_lock() for the explanation for the\n  conditionally defined plugin_ref type\n*/\n#ifdef DBUG_OFF\ntypedef struct st_plugin_int *plugin_ref;\n#define plugin_ref_to_int(A) A\n#define plugin_int_to_ref(A) A\n#define plugin_decl(pi) ((pi)->plugin)\n#define plugin_dlib(pi) ((pi)->plugin_dl)\n#define plugin_data(pi,cast) ((cast)((pi)->data))\n#define plugin_name(pi) (&((pi)->name))\n#define plugin_state(pi) ((pi)->state)\n#define plugin_load_option(pi) ((pi)->load_option)\n#define plugin_equals(p1,p2) ((p1) == (p2))\n#else\ntypedef struct st_plugin_int **plugin_ref;\n#define plugin_ref_to_int(A) (A ? A[0] : NULL)\n#define plugin_int_to_ref(A) &(A)\n#define plugin_decl(pi) ((pi)[0]->plugin)\n#define plugin_dlib(pi) ((pi)[0]->plugin_dl)\n#define plugin_data(pi,cast) ((cast)((pi)[0]->data))\n#define plugin_name(pi) (&((pi)[0]->name))\n#define plugin_state(pi) ((pi)[0]->state)\n#define plugin_load_option(pi) ((pi)[0]->load_option)\n#define plugin_equals(p1,p2) ((p1) && (p2) && (p1)[0] == (p2)[0])\n#endif\n\ntypedef int (*plugin_type_init)(struct st_plugin_int *);\n\nextern I_List<i_string> *opt_plugin_load_list_ptr;\nextern char *opt_plugin_dir_ptr;\nextern MYSQL_PLUGIN_IMPORT char opt_plugin_dir[FN_REFLEN];\nextern const LEX_CSTRING plugin_type_names[];\nextern ulong plugin_maturity;\nextern TYPELIB plugin_maturity_values;\nextern const char *plugin_maturity_names[];\n\nextern int plugin_init(int *argc, char **argv, int init_flags);\nextern void plugin_shutdown(void);\nvoid add_plugin_options(DYNAMIC_ARRAY *options, MEM_ROOT *mem_root);\nextern bool plugin_is_ready(const LEX_CSTRING *name, int type);\n#define my_plugin_lock_by_name(A,B,C) plugin_lock_by_name(A,B,C)\n#define my_plugin_lock(A,B) plugin_lock(A,B)\nextern plugin_ref plugin_lock(THD *thd, plugin_ref ptr);\nextern plugin_ref plugin_lock_by_name(THD *thd, const LEX_CSTRING *name,\n                                      int type);\nextern void plugin_unlock(THD *thd, plugin_ref plugin);\nextern void plugin_unlock_list(THD *thd, plugin_ref *list, uint count);\nextern bool mysql_install_plugin(THD *thd, const LEX_CSTRING *name,\n                                 const LEX_CSTRING *dl);\nextern bool mysql_uninstall_plugin(THD *thd, const LEX_CSTRING *name,\n                                   const LEX_CSTRING *dl);\nextern bool plugin_register_builtin(struct st_mysql_plugin *plugin);\nextern void plugin_thdvar_init(THD *thd);\nextern void plugin_thdvar_cleanup(THD *thd);\nsys_var *find_plugin_sysvar(st_plugin_int *plugin, st_mysql_sys_var *var);\nvoid plugin_opt_set_limits(struct my_option *, const struct st_mysql_sys_var *);\nextern SHOW_COMP_OPTION plugin_status(const char *name, size_t len, int type);\nextern bool check_valid_path(const char *path, size_t length);\nextern void plugin_mutex_init();\n\ntypedef my_bool (plugin_foreach_func)(THD *thd,\n                                      plugin_ref plugin,\n                                      void *arg);\n#define plugin_foreach(A,B,C,D) plugin_foreach_with_mask(A,B,C,PLUGIN_IS_READY,D)\nextern bool plugin_foreach_with_mask(THD *thd, plugin_foreach_func *func,\n                                     int type, uint state_mask, void *arg);\nextern void sync_dynamic_session_variables(THD* thd, bool global_lock);\n\nextern bool plugin_dl_foreach(THD *thd, const LEX_CSTRING *dl,\n                              plugin_foreach_func *func, void *arg);\n\nextern void sync_dynamic_session_variables(THD* thd, bool global_lock);\n#endif\n\n#ifdef WITH_WSREP\nextern void wsrep_plugins_pre_init();\nextern void wsrep_plugins_post_init();\n#endif /* WITH_WSREP */\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/sql/sys_vars.cc": "/* Copyright (c) 2002, 2015, Oracle and/or its affiliates.\n   Copyright (c) 2012, 2018, MariaDB Corporation.\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; version 2 of the License.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1335  USA */\n\n/**\n  @file\n  Definitions of all server's session or global variables.\n\n  How to add new variables:\n\n  1. copy one of the existing variables, and edit the declaration.\n  2. if you need special behavior on assignment or additional checks\n     use ON_CHECK and ON_UPDATE callbacks.\n  3. *Don't* add new Sys_var classes or uncle Occam will come\n     with his razor to haunt you at nights\n\n  Note - all storage engine variables (for example myisam_whatever)\n  should go into the corresponding storage engine sources\n  (for example in storage/myisam/ha_myisam.cc) !\n*/\n\n#include \"sql_plugin.h\"\n#include \"sql_priv.h\"\n#include \"sql_class.h\"                          // set_var.h: THD\n#include \"sys_vars.ic\"\n#include \"my_sys.h\"\n\n#include \"events.h\"\n#include <thr_alarm.h>\n#include \"slave.h\"\n#include \"rpl_mi.h\"\n#include \"transaction.h\"\n#include \"mysqld.h\"\n#include \"lock.h\"\n#include \"sql_time.h\"                       // known_date_time_formats\n#include \"sql_acl.h\" // SUPER_ACL,\n                     // mysql_user_table_is_in_short_password_format\n#include \"derror.h\"  // read_texts\n#include \"sql_base.h\"                           // close_cached_tables\n#include \"hostname.h\"                           // host_cache_size\n#include <myisam.h>\n#include \"debug_sync.h\"                         // DEBUG_SYNC\n#include \"sql_show.h\"\n#include \"opt_trace_context.h\"\n\n#include \"log_event.h\"\n#ifdef WITH_PERFSCHEMA_STORAGE_ENGINE\n#include \"../storage/perfschema/pfs_server.h\"\n#endif /* WITH_PERFSCHEMA_STORAGE_ENGINE */\n#include \"threadpool.h\"\n#include \"sql_repl.h\"\n#include \"opt_range.h\"\n#include \"rpl_parallel.h\"\n#include \"semisync_master.h\"\n#include \"semisync_slave.h\"\n#include <ssl_compat.h>\n\n/*\n  The rule for this file: everything should be 'static'. When a sys_var\n  variable or a function from this file is - in very rare cases - needed\n  elsewhere it should be explicitly declared 'export' here to show that it's\n  not a mistakenly forgotten 'static' keyword.\n*/\n#define export /* not static */\n\n#ifdef WITH_PERFSCHEMA_STORAGE_ENGINE\n\nstatic Sys_var_mybool Sys_pfs_enabled(\n       \"performance_schema\",\n       \"Enable the performance schema.\",\n       PARSED_EARLY READ_ONLY GLOBAL_VAR(pfs_param.m_enabled),\n       CMD_LINE(OPT_ARG), DEFAULT(FALSE));\n\nstatic Sys_var_long Sys_pfs_events_waits_history_long_size(\n       \"performance_schema_events_waits_history_long_size\",\n       \"Number of rows in EVENTS_WAITS_HISTORY_LONG.\"\n       \" Use 0 to disable, -1 for automated sizing.\",\n       PARSED_EARLY READ_ONLY\n       GLOBAL_VAR(pfs_param.m_events_waits_history_long_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 1024*1024),\n       DEFAULT(-1), BLOCK_SIZE(1));\n\nstatic Sys_var_long Sys_pfs_events_waits_history_size(\n       \"performance_schema_events_waits_history_size\",\n       \"Number of rows per thread in EVENTS_WAITS_HISTORY.\"\n       \" Use 0 to disable, -1 for automated sizing.\",\n       PARSED_EARLY READ_ONLY GLOBAL_VAR(pfs_param.m_events_waits_history_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 1024),\n       DEFAULT(-1), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_pfs_max_cond_classes(\n       \"performance_schema_max_cond_classes\",\n       \"Maximum number of condition instruments.\",\n       PARSED_EARLY READ_ONLY GLOBAL_VAR(pfs_param.m_cond_class_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, 256),\n       DEFAULT(PFS_MAX_COND_CLASS), BLOCK_SIZE(1));\n\nstatic Sys_var_long Sys_pfs_max_cond_instances(\n       \"performance_schema_max_cond_instances\",\n       \"Maximum number of instrumented condition objects.\"\n       \" Use 0 to disable, -1 for automated sizing.\",\n       PARSED_EARLY READ_ONLY GLOBAL_VAR(pfs_param.m_cond_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 1024*1024),\n       DEFAULT(-1), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_pfs_max_file_classes(\n       \"performance_schema_max_file_classes\",\n       \"Maximum number of file instruments.\",\n       PARSED_EARLY READ_ONLY GLOBAL_VAR(pfs_param.m_file_class_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, 256),\n       DEFAULT(PFS_MAX_FILE_CLASS), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_pfs_max_file_handles(\n       \"performance_schema_max_file_handles\",\n       \"Maximum number of opened instrumented files.\",\n       PARSED_EARLY READ_ONLY GLOBAL_VAR(pfs_param.m_file_handle_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, 1024*1024),\n       DEFAULT(PFS_MAX_FILE_HANDLE), BLOCK_SIZE(1));\n\nstatic Sys_var_long Sys_pfs_max_file_instances(\n       \"performance_schema_max_file_instances\",\n       \"Maximum number of instrumented files.\"\n       \" Use 0 to disable, -1 for automated sizing.\",\n       PARSED_EARLY READ_ONLY GLOBAL_VAR(pfs_param.m_file_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 1024*1024),\n       DEFAULT(-1), BLOCK_SIZE(1));\n\nstatic Sys_var_long Sys_pfs_max_sockets(\n       \"performance_schema_max_socket_instances\",\n       \"Maximum number of opened instrumented sockets.\"\n       \" Use 0 to disable, -1 for automated sizing.\",\n       PARSED_EARLY READ_ONLY GLOBAL_VAR(pfs_param.m_socket_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 1024*1024),\n       DEFAULT(-1),\n       BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_pfs_max_socket_classes(\n       \"performance_schema_max_socket_classes\",\n       \"Maximum number of socket instruments.\",\n       PARSED_EARLY READ_ONLY GLOBAL_VAR(pfs_param.m_socket_class_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, 256),\n       DEFAULT(PFS_MAX_SOCKET_CLASS),\n       BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_pfs_max_mutex_classes(\n       \"performance_schema_max_mutex_classes\",\n       \"Maximum number of mutex instruments.\",\n       PARSED_EARLY READ_ONLY GLOBAL_VAR(pfs_param.m_mutex_class_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, 256),\n       DEFAULT(PFS_MAX_MUTEX_CLASS), BLOCK_SIZE(1));\n\nstatic Sys_var_long Sys_pfs_max_mutex_instances(\n       \"performance_schema_max_mutex_instances\",\n       \"Maximum number of instrumented MUTEX objects.\"\n       \" Use 0 to disable, -1 for automated sizing.\",\n       PARSED_EARLY READ_ONLY GLOBAL_VAR(pfs_param.m_mutex_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 100*1024*1024),\n       DEFAULT(-1), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_pfs_max_rwlock_classes(\n       \"performance_schema_max_rwlock_classes\",\n       \"Maximum number of rwlock instruments.\",\n       PARSED_EARLY READ_ONLY GLOBAL_VAR(pfs_param.m_rwlock_class_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, 256),\n       DEFAULT(PFS_MAX_RWLOCK_CLASS), BLOCK_SIZE(1));\n\nstatic Sys_var_long Sys_pfs_max_rwlock_instances(\n       \"performance_schema_max_rwlock_instances\",\n       \"Maximum number of instrumented RWLOCK objects.\"\n       \" Use 0 to disable, -1 for automated sizing.\",\n       PARSED_EARLY READ_ONLY GLOBAL_VAR(pfs_param.m_rwlock_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 100*1024*1024),\n       DEFAULT(-1), BLOCK_SIZE(1));\n\nstatic Sys_var_long Sys_pfs_max_table_handles(\n       \"performance_schema_max_table_handles\",\n       \"Maximum number of opened instrumented tables.\"\n       \" Use 0 to disable, -1 for automated sizing.\",\n       PARSED_EARLY READ_ONLY GLOBAL_VAR(pfs_param.m_table_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 1024*1024),\n       DEFAULT(-1), BLOCK_SIZE(1));\n\nstatic Sys_var_long Sys_pfs_max_table_instances(\n       \"performance_schema_max_table_instances\",\n       \"Maximum number of instrumented tables.\"\n       \" Use 0 to disable, -1 for automated sizing.\",\n       PARSED_EARLY READ_ONLY GLOBAL_VAR(pfs_param.m_table_share_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 1024*1024),\n       DEFAULT(-1), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_pfs_max_thread_classes(\n       \"performance_schema_max_thread_classes\",\n       \"Maximum number of thread instruments.\",\n       PARSED_EARLY READ_ONLY GLOBAL_VAR(pfs_param.m_thread_class_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, 256),\n       DEFAULT(PFS_MAX_THREAD_CLASS), BLOCK_SIZE(1));\n\nstatic Sys_var_long Sys_pfs_max_thread_instances(\n       \"performance_schema_max_thread_instances\",\n       \"Maximum number of instrumented threads.\"\n       \" Use 0 to disable, -1 for automated sizing.\",\n       PARSED_EARLY READ_ONLY GLOBAL_VAR(pfs_param.m_thread_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 1024*1024),\n       DEFAULT(-1), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_pfs_setup_actors_size(\n       \"performance_schema_setup_actors_size\",\n       \"Maximum number of rows in SETUP_ACTORS.\",\n       PARSED_EARLY READ_ONLY GLOBAL_VAR(pfs_param.m_setup_actor_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, 1024),\n       DEFAULT(PFS_MAX_SETUP_ACTOR),\n       BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_pfs_setup_objects_size(\n       \"performance_schema_setup_objects_size\",\n       \"Maximum number of rows in SETUP_OBJECTS.\",\n       PARSED_EARLY READ_ONLY GLOBAL_VAR(pfs_param.m_setup_object_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, 1024*1024),\n       DEFAULT(PFS_MAX_SETUP_OBJECT),\n       BLOCK_SIZE(1));\n\nstatic Sys_var_long Sys_pfs_accounts_size(\n       \"performance_schema_accounts_size\",\n       \"Maximum number of instrumented user@host accounts.\"\n       \" Use 0 to disable, -1 for automated sizing.\",\n       PARSED_EARLY READ_ONLY GLOBAL_VAR(pfs_param.m_account_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 1024*1024),\n       DEFAULT(-1),\n       BLOCK_SIZE(1));\n\nstatic Sys_var_long Sys_pfs_hosts_size(\n       \"performance_schema_hosts_size\",\n       \"Maximum number of instrumented hosts.\"\n       \" Use 0 to disable, -1 for automated sizing.\",\n       PARSED_EARLY READ_ONLY GLOBAL_VAR(pfs_param.m_host_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 1024*1024),\n       DEFAULT(-1),\n       BLOCK_SIZE(1));\n\nstatic Sys_var_long Sys_pfs_users_size(\n       \"performance_schema_users_size\",\n       \"Maximum number of instrumented users.\"\n       \" Use 0 to disable, -1 for automated sizing.\",\n       PARSED_EARLY READ_ONLY GLOBAL_VAR(pfs_param.m_user_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 1024*1024),\n       DEFAULT(-1),\n       BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_pfs_max_stage_classes(\n       \"performance_schema_max_stage_classes\",\n       \"Maximum number of stage instruments.\",\n       PARSED_EARLY READ_ONLY GLOBAL_VAR(pfs_param.m_stage_class_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, 256),\n       DEFAULT(PFS_MAX_STAGE_CLASS),\n       BLOCK_SIZE(1));\n\nstatic Sys_var_long Sys_pfs_events_stages_history_long_size(\n       \"performance_schema_events_stages_history_long_size\",\n       \"Number of rows in EVENTS_STAGES_HISTORY_LONG.\"\n       \" Use 0 to disable, -1 for automated sizing.\",\n       PARSED_EARLY READ_ONLY GLOBAL_VAR(pfs_param.m_events_stages_history_long_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 1024*1024),\n       DEFAULT(-1),\n       BLOCK_SIZE(1));\n\nstatic Sys_var_long Sys_pfs_events_stages_history_size(\n       \"performance_schema_events_stages_history_size\",\n       \"Number of rows per thread in EVENTS_STAGES_HISTORY.\"\n       \" Use 0 to disable, -1 for automated sizing.\",\n       PARSED_EARLY READ_ONLY GLOBAL_VAR(pfs_param.m_events_stages_history_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 1024),\n       DEFAULT(-1),\n       BLOCK_SIZE(1));\n\n/**\n  Variable performance_schema_max_statement_classes.\n  The default number of statement classes is the sum of:\n  - (COM_END - mariadb gap) for all regular \"statement/com/...\",\n  - 1 for \"statement/com/new_packet\", for unknown enum_server_command\n  - 1 for \"statement/com/Error\", for invalid enum_server_command\n  - SQLCOM_END for all regular \"statement/sql/...\",\n  - 1 for \"statement/sql/error\", for invalid enum_sql_command\n  - 1 for \"statement/rpl/relay_log\", for replicated statements.\n*/\nstatic Sys_var_ulong Sys_pfs_max_statement_classes(\n       \"performance_schema_max_statement_classes\",\n       \"Maximum number of statement instruments.\",\n       PARSED_EARLY READ_ONLY GLOBAL_VAR(pfs_param.m_statement_class_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, 256),\n       DEFAULT((ulong) SQLCOM_END +\n               (ulong) (COM_END -(COM_MDB_GAP_END - COM_MDB_GAP_BEG + 1)) + 4),\n       BLOCK_SIZE(1));\n\nstatic Sys_var_long Sys_pfs_events_statements_history_long_size(\n       \"performance_schema_events_statements_history_long_size\",\n       \"Number of rows in EVENTS_STATEMENTS_HISTORY_LONG.\"\n       \" Use 0 to disable, -1 for automated sizing.\",\n       PARSED_EARLY READ_ONLY GLOBAL_VAR(pfs_param.m_events_statements_history_long_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 1024*1024),\n       DEFAULT(-1),\n       BLOCK_SIZE(1));\n\nstatic Sys_var_long Sys_pfs_events_statements_history_size(\n       \"performance_schema_events_statements_history_size\",\n       \"Number of rows per thread in EVENTS_STATEMENTS_HISTORY.\"\n       \" Use 0 to disable, -1 for automated sizing.\",\n       PARSED_EARLY READ_ONLY GLOBAL_VAR(pfs_param.m_events_statements_history_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 1024),\n       DEFAULT(-1),\n       BLOCK_SIZE(1));\n\nstatic Sys_var_long Sys_pfs_digest_size(\n       \"performance_schema_digests_size\",\n       \"Size of the statement digest.\"\n       \" Use 0 to disable, -1 for automated sizing.\",\n       PARSED_EARLY READ_ONLY GLOBAL_VAR(pfs_param.m_digest_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 200),\n       DEFAULT(-1),\n       BLOCK_SIZE(1));\n\nstatic Sys_var_long Sys_pfs_max_digest_length(\n       \"performance_schema_max_digest_length\",\n       \"Maximum length considered for digest text, when stored in performance_schema tables.\",\n       PARSED_EARLY READ_ONLY GLOBAL_VAR(pfs_param.m_max_digest_length),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, 1024 * 1024),\n       DEFAULT(1024),\n       BLOCK_SIZE(1));\n\nstatic Sys_var_long Sys_pfs_connect_attrs_size(\n       \"performance_schema_session_connect_attrs_size\",\n       \"Size of session attribute string buffer per thread.\"\n         \" Use 0 to disable, -1 for automated sizing.\",\n       PARSED_EARLY READ_ONLY\n       GLOBAL_VAR(pfs_param.m_session_connect_attrs_sizing),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 1024 * 1024),\n       DEFAULT(-1),\n       BLOCK_SIZE(1));\n\n#endif /* WITH_PERFSCHEMA_STORAGE_ENGINE */\n\n#ifdef WITH_WSREP\n\n/*\n  We need to keep the original values set by the user, as they will\n  be lost if wsrep_auto_increment_control set to 'ON':\n*/\nstatic bool update_auto_increment_increment (sys_var *self, THD *thd, enum_var_type type)\n{\n  if (type == OPT_GLOBAL)\n    global_system_variables.saved_auto_increment_increment=\n      global_system_variables.auto_increment_increment;\n  else\n    thd->variables.saved_auto_increment_increment=\n      thd->variables.auto_increment_increment;\n  return false;\n}\n\n#endif /* WITH_WSREP */\n\nstatic Sys_var_double Sys_analyze_sample_percentage(\n       \"analyze_sample_percentage\",\n       \"Percentage of rows from the table ANALYZE TABLE will sample \"\n       \"to collect table statistics. Set to 0 to let MariaDB decide \"\n       \"what percentage of rows to sample.\",\n       SESSION_VAR(sample_percentage),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, 100),\n       DEFAULT(100));\n\nstatic Sys_var_ulong Sys_auto_increment_increment(\n       \"auto_increment_increment\",\n       \"Auto-increment columns are incremented by this\",\n       SESSION_VAR(auto_increment_increment),\n       CMD_LINE(OPT_ARG),\n       VALID_RANGE(1, 65535), DEFAULT(1), BLOCK_SIZE(1),\n#ifdef WITH_WSREP\n       NO_MUTEX_GUARD, IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(update_auto_increment_increment));\n#else\n       NO_MUTEX_GUARD, IN_BINLOG);\n#endif /* WITH_WSREP */\n\n#ifdef WITH_WSREP\n\n/*\n  We need to keep the original values set by the user, as they will\n  be lost if wsrep_auto_increment_control set to 'ON':\n*/\nstatic bool update_auto_increment_offset (sys_var *self, THD *thd, enum_var_type type)\n{\n  if (type == OPT_GLOBAL)\n    global_system_variables.saved_auto_increment_offset=\n      global_system_variables.auto_increment_offset;\n  else\n    thd->variables.saved_auto_increment_offset=\n      thd->variables.auto_increment_offset;\n  return false;\n}\n\n#endif /* WITH_WSREP */\n\nstatic Sys_var_ulong Sys_auto_increment_offset(\n       \"auto_increment_offset\",\n       \"Offset added to Auto-increment columns. Used when \"\n       \"auto-increment-increment != 1\",\n       SESSION_VAR(auto_increment_offset),\n       CMD_LINE(OPT_ARG),\n       VALID_RANGE(1, 65535), DEFAULT(1), BLOCK_SIZE(1),\n#ifdef WITH_WSREP\n       NO_MUTEX_GUARD, IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(update_auto_increment_offset));\n#else\n       NO_MUTEX_GUARD, IN_BINLOG);\n#endif /* WITH_WSREP */\n\nstatic Sys_var_mybool Sys_automatic_sp_privileges(\n       \"automatic_sp_privileges\",\n       \"Creating and dropping stored procedures alters ACLs\",\n       GLOBAL_VAR(sp_automatic_privileges),\n       CMD_LINE(OPT_ARG), DEFAULT(TRUE));\n\nstatic Sys_var_ulong Sys_back_log(\n       \"back_log\", \"The number of outstanding connection requests \"\n       \"MariaDB can have. This comes into play when the main MariaDB thread \"\n       \"gets very many connection requests in a very short time\",\n       AUTO_SET READ_ONLY GLOBAL_VAR(back_log), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, 65535), DEFAULT(150), BLOCK_SIZE(1));\n\nstatic Sys_var_charptr Sys_basedir(\n       \"basedir\", \"Path to installation directory. All paths are \"\n       \"usually resolved relative to this\",\n       READ_ONLY GLOBAL_VAR(mysql_home_ptr), CMD_LINE(REQUIRED_ARG, 'b'),\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic Sys_var_charptr Sys_my_bind_addr(\n       \"bind_address\", \"IP address to bind to.\",\n       READ_ONLY GLOBAL_VAR(my_bind_addr_str), CMD_LINE(REQUIRED_ARG),\n       IN_FS_CHARSET, DEFAULT(0));\n\nconst char *Sys_var_vers_asof::asof_keywords[]= {\"DEFAULT\", NULL};\nstatic Sys_var_vers_asof Sys_vers_asof_timestamp(\n       \"system_versioning_asof\", \"Default value for the FOR SYSTEM_TIME AS OF clause\",\n       SESSION_VAR(vers_asof_timestamp.type), NO_CMD_LINE,\n       Sys_var_vers_asof::asof_keywords, DEFAULT(SYSTEM_TIME_UNSPECIFIED));\n\nstatic const char *vers_alter_history_keywords[]= {\"ERROR\", \"KEEP\", NullS};\nstatic Sys_var_enum Sys_vers_alter_history(\n       \"system_versioning_alter_history\", \"Versioning ALTER TABLE mode. \"\n       \"ERROR: Fail ALTER with error; \" /* TODO: fail only when history non-empty */\n       \"KEEP: Keep historical system rows and subject them to ALTER\",\n       SESSION_VAR(vers_alter_history), CMD_LINE(REQUIRED_ARG),\n       vers_alter_history_keywords, DEFAULT(VERS_ALTER_HISTORY_ERROR));\n\nstatic Sys_var_ulonglong Sys_binlog_cache_size(\n       \"binlog_cache_size\", \"The size of the transactional cache for \"\n       \"updates to transactional engines for the binary log. \"\n       \"If you often use transactions containing many statements, \"\n       \"you can increase this to get more performance\",\n       GLOBAL_VAR(binlog_cache_size),\n       CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(IO_SIZE, SIZE_T_MAX), DEFAULT(32768), BLOCK_SIZE(IO_SIZE));\n\nstatic Sys_var_ulonglong  Sys_binlog_file_cache_size(\n       \"binlog_file_cache_size\", \n       \"The size of file cache for the binary log\", \n       GLOBAL_VAR(binlog_file_cache_size),\n       CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(IO_SIZE*2, SIZE_T_MAX), DEFAULT(IO_SIZE*4), BLOCK_SIZE(IO_SIZE));\n\nstatic Sys_var_ulonglong Sys_binlog_stmt_cache_size(\n       \"binlog_stmt_cache_size\", \"The size of the statement cache for \"\n       \"updates to non-transactional engines for the binary log. \"\n       \"If you often use statements updating a great number of rows, \"\n       \"you can increase this to get more performance.\",\n       GLOBAL_VAR(binlog_stmt_cache_size),\n       CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(IO_SIZE, SIZE_T_MAX), DEFAULT(32768), BLOCK_SIZE(IO_SIZE));\n\n/*\n  Some variables like @sql_log_bin and @binlog_format change how/if binlogging\n  is done. We must not change them inside a running transaction or statement,\n  otherwise the event group eventually written to the binlog may become\n  incomplete or otherwise garbled.\n\n  This function does the appropriate check.\n\n  It returns true if an error is caused by incorrect usage, false if ok.\n*/\nstatic bool\nerror_if_in_trans_or_substatement(THD *thd, int in_substatement_error,\n                                  int in_transaction_error)\n{\n  if (unlikely(thd->in_sub_stmt))\n  {\n    my_error(in_substatement_error, MYF(0));\n    return true;\n  }\n\n  if (unlikely(thd->in_active_multi_stmt_transaction()))\n  {\n    my_error(in_transaction_error, MYF(0));\n    return true;\n  }\n\n  return false;\n}\n\nbool check_has_super(sys_var *self, THD *thd, set_var *var)\n{\n  DBUG_ASSERT(self->scope() != sys_var::GLOBAL);// don't abuse check_has_super()\n#ifndef NO_EMBEDDED_ACCESS_CHECKS\n  if (!(thd->security_ctx->master_access & SUPER_ACL))\n  {\n    my_error(ER_SPECIFIC_ACCESS_DENIED_ERROR, MYF(0), \"SUPER\");\n    return true;\n  }\n#endif\n  return false;\n}\n\nstatic Sys_var_bit Sys_core_file(\"core_file\", \"write a core-file on crashes\",\n          READ_ONLY GLOBAL_VAR(test_flags), NO_CMD_LINE,\n          TEST_CORE_ON_SIGNAL, DEFAULT(IF_WIN(TRUE,FALSE)), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n          0,0,0);\n\nstatic bool binlog_format_check(sys_var *self, THD *thd, set_var *var)\n{\n  if (check_has_super(self, thd, var))\n    return true;\n\n  /*\n    MariaDB Galera does not support STATEMENT or MIXED binlog format currently.\n  */\n  if ((WSREP(thd) || opt_support_flashback) &&\n      var->save_result.ulonglong_value != BINLOG_FORMAT_ROW)\n  {\n    // Push a warning to the error log.\n    push_warning_printf(thd, Sql_condition::WARN_LEVEL_WARN, ER_UNKNOWN_ERROR,\n                        \"MariaDB Galera and flashback do not support binlog format: %s\",\n                        binlog_format_names[var->save_result.ulonglong_value]);\n    /*\n      We allow setting up binlog_format other then ROW for session scope when\n      wsrep/flasback is enabled.This is done because of 2 reasons\n      1. User might want to run pt-table-checksum.\n      2. SuperUser knows what is doing :-)\n\n      For refrence:- MDEV-7322\n    */\n    if (var->type == OPT_GLOBAL)\n    {\n      if (WSREP(thd))\n        WSREP_ERROR(\"MariaDB Galera does not support binlog format: %s\",\n                    binlog_format_names[var->save_result.ulonglong_value]);\n      else\n        my_error(ER_FLASHBACK_NOT_SUPPORTED,MYF(0),\"binlog_format\",\n                 binlog_format_names[var->save_result.ulonglong_value]);\n      return true;\n    }\n  }\n\n  if (var->type == OPT_GLOBAL)\n    return false;\n\n  /*\n     If RBR and open temporary tables, their CREATE TABLE may not be in the\n     binlog, so we can't toggle to SBR in this connection.\n\n     If binlog_format=MIXED, there are open temporary tables, and an unsafe\n     statement is executed, then subsequent statements are logged in row\n     format and hence changes to temporary tables may be lost. So we forbid\n     switching @@SESSION.binlog_format from MIXED to STATEMENT when there are\n     open temp tables and we are logging in row format.\n  */\n  if (thd->has_thd_temporary_tables() &&\n      var->type == OPT_SESSION &&\n      var->save_result.ulonglong_value == BINLOG_FORMAT_STMT &&\n      ((thd->variables.binlog_format == BINLOG_FORMAT_MIXED &&\n        thd->is_current_stmt_binlog_format_row()) ||\n       thd->variables.binlog_format == BINLOG_FORMAT_ROW))\n  {\n    my_error(ER_TEMP_TABLE_PREVENTS_SWITCH_OUT_OF_RBR, MYF(0));\n    return true;\n  }\n\n  if (unlikely(error_if_in_trans_or_substatement(thd,\n                                                 ER_STORED_FUNCTION_PREVENTS_SWITCH_BINLOG_FORMAT,\n                                                 ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_BINLOG_FORMAT)))\n    return true;\n\n  return false;\n}\n\nstatic bool fix_binlog_format_after_update(sys_var *self, THD *thd,\n                                           enum_var_type type)\n{\n  if (type == OPT_SESSION)\n    thd->reset_current_stmt_binlog_format_row();\n  return false;\n}\n\nstatic Sys_var_enum Sys_binlog_format(\n       \"binlog_format\", \"What form of binary logging the master will \"\n       \"use: either ROW for row-based binary logging, STATEMENT \"\n       \"for statement-based binary logging, or MIXED. MIXED is statement-\"\n       \"based binary logging except for those statements where only row-\"\n       \"based is correct: those which involve user-defined functions (i.e. \"\n       \"UDFs) or the UUID() function; for those, row-based binary logging is \"\n       \"automatically used.\",\n       SESSION_VAR(binlog_format), CMD_LINE(REQUIRED_ARG, OPT_BINLOG_FORMAT),\n       binlog_format_names, DEFAULT(BINLOG_FORMAT_MIXED),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(binlog_format_check),\n       ON_UPDATE(fix_binlog_format_after_update));\n\nstatic bool binlog_direct_check(sys_var *self, THD *thd, set_var *var)\n{\n  if (check_has_super(self, thd, var))\n    return true;\n\n  if (var->type == OPT_GLOBAL)\n    return false;\n\n  if (unlikely(error_if_in_trans_or_substatement(thd,\n                                                 ER_STORED_FUNCTION_PREVENTS_SWITCH_BINLOG_DIRECT,\n                                                 ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_BINLOG_DIRECT)))\n     return true;\n\n  return false;\n}\n\nstatic Sys_var_mybool Sys_binlog_direct(\n       \"binlog_direct_non_transactional_updates\",\n       \"Causes updates to non-transactional engines using statement format to \"\n       \"be written directly to binary log. Before using this option make sure \"\n       \"that there are no dependencies between transactional and \"\n       \"non-transactional tables such as in the statement INSERT INTO t_myisam \"\n       \"SELECT * FROM t_innodb; otherwise, slaves may diverge from the master.\",\n       SESSION_VAR(binlog_direct_non_trans_update),\n       CMD_LINE(OPT_ARG), DEFAULT(FALSE),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(binlog_direct_check));\n\n\nstatic Sys_var_mybool Sys_explicit_defaults_for_timestamp(\n       \"explicit_defaults_for_timestamp\",\n       \"This option causes CREATE TABLE to create all TIMESTAMP columns \"\n       \"as NULL with DEFAULT NULL attribute, Without this option, \"\n       \"TIMESTAMP columns are NOT NULL and have implicit DEFAULT clauses.\",\n       READ_ONLY GLOBAL_VAR(opt_explicit_defaults_for_timestamp),\n       CMD_LINE(OPT_ARG), DEFAULT(FALSE));\n\n\nstatic Sys_var_ulonglong Sys_bulk_insert_buff_size(\n       \"bulk_insert_buffer_size\", \"Size of tree cache used in bulk \"\n       \"insert optimisation. Note that this is a limit per thread!\",\n       SESSION_VAR(bulk_insert_buff_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, SIZE_T_MAX), DEFAULT(8192*1024), BLOCK_SIZE(1));\n\nstatic Sys_var_charptr Sys_character_sets_dir(\n       \"character_sets_dir\", \"Directory where character sets are\",\n       READ_ONLY GLOBAL_VAR(charsets_dir), CMD_LINE(REQUIRED_ARG),\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic bool check_not_null(sys_var *self, THD *thd, set_var *var)\n{\n  return var->value && var->value->is_null();\n}\nstatic bool check_charset(sys_var *self, THD *thd, set_var *var)\n{\n  if (!var->value)\n    return false;\n\n  char buff[STRING_BUFFER_USUAL_SIZE];\n  if (var->value->result_type() == STRING_RESULT)\n  {\n    String str(buff, sizeof(buff), system_charset_info), *res;\n    if (!(res= var->value->val_str(&str)))\n      var->save_result.ptr= NULL;\n    else\n    {\n      ErrConvString err(res); /* Get utf8 '\\0' terminated string */\n      if (!(var->save_result.ptr= get_charset_by_csname(err.ptr(),\n                                                         MY_CS_PRIMARY,\n                                                         MYF(0))) &&\n          !(var->save_result.ptr= get_old_charset_by_name(err.ptr())))\n      {\n        my_error(ER_UNKNOWN_CHARACTER_SET, MYF(0), err.ptr());\n        return true;\n      }\n    }\n  }\n  else // INT_RESULT\n  {\n    int csno= (int)var->value->val_int();\n    if (!(var->save_result.ptr= get_charset(csno, MYF(0))))\n    {\n      my_error(ER_UNKNOWN_CHARACTER_SET, MYF(0), llstr(csno, buff));\n      return true;\n    }\n  }\n  return false;\n}\nstatic bool check_charset_not_null(sys_var *self, THD *thd, set_var *var)\n{\n  return check_charset(self, thd, var) || check_not_null(self, thd, var);\n}\nstatic Sys_var_struct Sys_character_set_system(\n       \"character_set_system\", \"The character set used by the server \"\n       \"for storing identifiers\",\n       READ_ONLY GLOBAL_VAR(system_charset_info), NO_CMD_LINE,\n       offsetof(CHARSET_INFO, csname), DEFAULT(0));\n\nstatic Sys_var_struct Sys_character_set_server(\n       \"character_set_server\", \"The default character set\",\n       SESSION_VAR(collation_server), NO_CMD_LINE,\n       offsetof(CHARSET_INFO, csname), DEFAULT(&default_charset_info),\n       NO_MUTEX_GUARD, IN_BINLOG, ON_CHECK(check_charset_not_null));\n\nstatic bool check_charset_db(sys_var *self, THD *thd, set_var *var)\n{\n  if (check_charset_not_null(self, thd, var))\n    return true;\n  if (!var->value) // = DEFAULT\n    var->save_result.ptr= thd->db_charset;\n  return false;\n}\nstatic Sys_var_struct Sys_character_set_database(\n       \"character_set_database\",\n       \"The character set used by the default database\",\n       SESSION_VAR(collation_database), NO_CMD_LINE,\n       offsetof(CHARSET_INFO, csname), DEFAULT(&default_charset_info),\n       NO_MUTEX_GUARD, IN_BINLOG, ON_CHECK(check_charset_db));\n\nstatic bool check_cs_client(sys_var *self, THD *thd, set_var *var)\n{\n  if (check_charset_not_null(self, thd, var))\n    return true;\n\n  // Currently, UCS-2 cannot be used as a client character set\n  if (!is_supported_parser_charset((CHARSET_INFO *)(var->save_result.ptr)))\n    return true;\n\n  return false;\n}\nstatic bool fix_thd_charset(sys_var *self, THD *thd, enum_var_type type)\n{\n  if (type == OPT_SESSION)\n    thd->update_charset();\n  return false;\n}\nstatic Sys_var_struct Sys_character_set_client(\n       \"character_set_client\", \"The character set for statements \"\n       \"that arrive from the client\",\n       NO_SET_STMT SESSION_VAR(character_set_client), NO_CMD_LINE,\n       offsetof(CHARSET_INFO, csname), DEFAULT(&default_charset_info),\n       NO_MUTEX_GUARD, IN_BINLOG, ON_CHECK(check_cs_client),\n       ON_UPDATE(fix_thd_charset));\n// for check changing\nexport sys_var *Sys_character_set_client_ptr= &Sys_character_set_client;\n\nstatic Sys_var_struct Sys_character_set_connection(\n       \"character_set_connection\", \"The character set used for \"\n       \"literals that do not have a character set introducer and for \"\n       \"number-to-string conversion\",\n       NO_SET_STMT SESSION_VAR(collation_connection), NO_CMD_LINE,\n       offsetof(CHARSET_INFO, csname), DEFAULT(&default_charset_info),\n       NO_MUTEX_GUARD, IN_BINLOG, ON_CHECK(check_charset_not_null),\n       ON_UPDATE(fix_thd_charset));\n// for check changing\nexport sys_var *Sys_character_set_connection_ptr= &Sys_character_set_connection;\n\nstatic Sys_var_struct Sys_character_set_results(\n       \"character_set_results\", \"The character set used for returning \"\n       \"query results to the client\",\n       SESSION_VAR(character_set_results), NO_CMD_LINE,\n       offsetof(CHARSET_INFO, csname), DEFAULT(&default_charset_info),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(check_charset));\n// for check changing\nexport sys_var *Sys_character_set_results_ptr= &Sys_character_set_results;\n\nstatic Sys_var_struct Sys_character_set_filesystem(\n       \"character_set_filesystem\", \"The filesystem character set\",\n       NO_SET_STMT SESSION_VAR(character_set_filesystem), NO_CMD_LINE,\n       offsetof(CHARSET_INFO, csname), DEFAULT(&character_set_filesystem),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(check_charset_not_null),\n       ON_UPDATE(fix_thd_charset));\n\nstatic const char *completion_type_names[]= {\"NO_CHAIN\", \"CHAIN\", \"RELEASE\", 0};\nstatic Sys_var_enum Sys_completion_type(\n       \"completion_type\", \"The transaction completion type\",\n       SESSION_VAR(completion_type), CMD_LINE(REQUIRED_ARG),\n       completion_type_names, DEFAULT(0));\n\nstatic bool check_collation_not_null(sys_var *self, THD *thd, set_var *var)\n{\n  if (!var->value)\n    return false;\n\n  char buff[STRING_BUFFER_USUAL_SIZE];\n  if (var->value->result_type() == STRING_RESULT)\n  {\n    String str(buff, sizeof(buff), system_charset_info), *res;\n    if (!(res= var->value->val_str(&str)))\n      var->save_result.ptr= NULL;\n    else\n    {\n      ErrConvString err(res); /* Get utf8 '\\0'-terminated string */\n      if (!(var->save_result.ptr= get_charset_by_name(err.ptr(), MYF(0))))\n      {\n        my_error(ER_UNKNOWN_COLLATION, MYF(0), err.ptr());\n        return true;\n      }\n    }\n  }\n  else // INT_RESULT\n  {\n    int csno= (int)var->value->val_int();\n    if (!(var->save_result.ptr= get_charset(csno, MYF(0))))\n    {\n      my_error(ER_UNKNOWN_COLLATION, MYF(0), llstr(csno, buff));\n      return true;\n    }\n  }\n  return check_not_null(self, thd, var);\n}\nstatic Sys_var_struct Sys_collation_connection(\n       \"collation_connection\", \"The collation of the connection \"\n       \"character set\",\n       NO_SET_STMT SESSION_VAR(collation_connection), NO_CMD_LINE,\n       offsetof(CHARSET_INFO, name), DEFAULT(&default_charset_info),\n       NO_MUTEX_GUARD, IN_BINLOG, ON_CHECK(check_collation_not_null),\n       ON_UPDATE(fix_thd_charset));\n\nstatic bool check_collation_db(sys_var *self, THD *thd, set_var *var)\n{\n  if (check_collation_not_null(self, thd, var))\n    return true;\n  if (!var->value) // = DEFAULT\n    var->save_result.ptr= thd->db_charset;\n  return false;\n}\nstatic Sys_var_struct Sys_collation_database(\n       \"collation_database\", \"The collation of the database \"\n       \"character set\",\n       SESSION_VAR(collation_database), NO_CMD_LINE,\n       offsetof(CHARSET_INFO, name), DEFAULT(&default_charset_info),\n       NO_MUTEX_GUARD, IN_BINLOG, ON_CHECK(check_collation_db));\n\nstatic Sys_var_struct Sys_collation_server(\n       \"collation_server\", \"The server default collation\",\n       SESSION_VAR(collation_server), NO_CMD_LINE,\n       offsetof(CHARSET_INFO, name), DEFAULT(&default_charset_info),\n       NO_MUTEX_GUARD, IN_BINLOG, ON_CHECK(check_collation_not_null));\n\nstatic Sys_var_uint Sys_column_compression_threshold(\n       \"column_compression_threshold\",\n       \"Minimum column data length eligible for compression\",\n       SESSION_VAR(column_compression_threshold), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, UINT_MAX), DEFAULT(100), BLOCK_SIZE(1));\n\nstatic Sys_var_uint Sys_column_compression_zlib_level(\n       \"column_compression_zlib_level\",\n       \"zlib compression level (1 gives best speed, 9 gives best compression)\",\n       SESSION_VAR(column_compression_zlib_level), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, 9), DEFAULT(6), BLOCK_SIZE(1));\n\n/*\n  Note that names must correspond to zlib strategy definition. So that we can\n  pass column_compression_zlib_strategy directly to deflateInit2().\n*/\nstatic const char *column_compression_zlib_strategy_names[]=\n{ \"DEFAULT_STRATEGY\", \"FILTERED\", \"HUFFMAN_ONLY\", \"RLE\", \"FIXED\", 0 };\n\nstatic Sys_var_enum Sys_column_compression_zlib_strategy(\n       \"column_compression_zlib_strategy\",\n       \"The strategy parameter is used to tune the compression algorithm. Use \"\n       \"the value DEFAULT_STRATEGY for normal data, FILTERED for data produced \"\n       \"by a filter (or predictor), HUFFMAN_ONLY to force Huffman encoding \"\n       \"only (no string match), or RLE to limit match distances to one \"\n       \"(run-length encoding). Filtered data consists mostly of small values \"\n       \"with a somewhat random distribution. In this case, the compression \"\n       \"algorithm is tuned to compress them better. The effect of FILTERED is \"\n       \"to force more Huffman coding and less string matching; it is somewhat \"\n       \"intermediate between DEFAULT_STRATEGY and HUFFMAN_ONLY. RLE is \"\n       \"designed to be almost as fast as HUFFMAN_ONLY, but give better \"\n       \"compression for PNG image data. The strategy parameter only affects \"\n       \"the compression ratio but not the correctness of the compressed output \"\n       \"even if it is not set appropriately. FIXED prevents the use of dynamic \"\n       \"Huffman codes, allowing for a simpler decoder for special \"\n       \"applications.\",\n       SESSION_VAR(column_compression_zlib_strategy), CMD_LINE(REQUIRED_ARG),\n       column_compression_zlib_strategy_names, DEFAULT(0));\n\nstatic Sys_var_mybool Sys_column_compression_zlib_wrap(\n       \"column_compression_zlib_wrap\",\n       \"Generate zlib header and trailer and compute adler32 check value. \"\n       \"It can be used with storage engines that don't provide data integrity \"\n       \"verification to detect data corruption.\",\n       SESSION_VAR(column_compression_zlib_wrap), CMD_LINE(OPT_ARG),\n       DEFAULT(FALSE));\n\nstatic const char *concurrent_insert_names[]= {\"NEVER\", \"AUTO\", \"ALWAYS\", 0};\nstatic Sys_var_enum Sys_concurrent_insert(\n       \"concurrent_insert\", \"Use concurrent insert with MyISAM\",\n       GLOBAL_VAR(myisam_concurrent_insert), CMD_LINE(OPT_ARG),\n       concurrent_insert_names, DEFAULT(1));\n\nstatic Sys_var_ulong Sys_connect_timeout(\n       \"connect_timeout\",\n       \"The number of seconds the mysqld server is waiting for a connect \"\n       \"packet before responding with 'Bad handshake'\",\n       GLOBAL_VAR(connect_timeout), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(2, LONG_TIMEOUT), DEFAULT(CONNECT_TIMEOUT), BLOCK_SIZE(1));\n\nstatic Sys_var_charptr Sys_datadir(\n       \"datadir\", \"Path to the database root directory\",\n       READ_ONLY GLOBAL_VAR(mysql_real_data_home_ptr),\n       CMD_LINE(REQUIRED_ARG, 'h'), IN_FS_CHARSET, DEFAULT(mysql_real_data_home));\n\n#ifndef DBUG_OFF\nstatic Sys_var_dbug Sys_dbug(\n       \"debug\", \"Built-in DBUG debugger\", sys_var::SESSION,\n       CMD_LINE(OPT_ARG, '#'), DEFAULT(\"\"), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(check_has_super), ON_UPDATE(0),\n       DEPRECATED(\"'@@debug_dbug'\"));\n\nstatic Sys_var_dbug Sys_debug_dbug(\n       \"debug_dbug\", \"Built-in DBUG debugger\", sys_var::SESSION,\n       CMD_LINE(OPT_ARG, '#'), DEFAULT(\"\"), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(check_has_super));\n#endif\n\n/**\n  @todo\n    When updating myisam_delay_key_write, we should do a 'flush tables'\n    of all MyISAM tables to ensure that they are reopen with the\n    new attribute.\n*/\nexport bool fix_delay_key_write(sys_var *self, THD *thd, enum_var_type type)\n{\n  switch (delay_key_write_options) {\n  case DELAY_KEY_WRITE_NONE:\n    myisam_delay_key_write=0;\n    ha_open_options&= ~HA_OPEN_DELAY_KEY_WRITE;\n    break;\n  case DELAY_KEY_WRITE_ON:\n    myisam_delay_key_write=1;\n    ha_open_options&= ~HA_OPEN_DELAY_KEY_WRITE;\n    break;\n  case DELAY_KEY_WRITE_ALL:\n    myisam_delay_key_write=1;\n    ha_open_options|= HA_OPEN_DELAY_KEY_WRITE;\n    break;\n  }\n#ifdef WITH_ARIA_STORAGE_ENGINE\n  maria_delay_key_write= myisam_delay_key_write;\n#endif\n  return false;\n}\nstatic const char *delay_key_write_names[]= { \"OFF\", \"ON\", \"ALL\", NullS };\nstatic Sys_var_enum Sys_delay_key_write(\n       \"delay_key_write\", \"Specifies how MyISAM tables handles CREATE \"\n       \"TABLE DELAY_KEY_WRITE. If set to ON, the default, any DELAY KEY \"\n       \"WRITEs are honored. The key buffer is then flushed only when the \"\n       \"table closes, speeding up writes. MyISAM tables should be \"\n       \"automatically checked upon startup in this case, and \"\n       \"--external locking should not be used, as it can lead to index \"\n       \"corruption. If set to OFF, DELAY KEY WRITEs are ignored, while if \"\n       \"set to ALL, all new opened tables are treated as if created with \"\n       \"DELAY KEY WRITEs enabled.\",\n       GLOBAL_VAR(delay_key_write_options), CMD_LINE(OPT_ARG),\n       delay_key_write_names, DEFAULT(DELAY_KEY_WRITE_ON),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_delay_key_write));\n\nstatic Sys_var_ulong Sys_delayed_insert_limit(\n       \"delayed_insert_limit\",\n       \"After inserting delayed_insert_limit rows, the INSERT DELAYED \"\n       \"handler will check if there are any SELECT statements pending. \"\n       \"If so, it allows these to execute before continuing.\",\n       GLOBAL_VAR(delayed_insert_limit), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, UINT_MAX), DEFAULT(DELAYED_LIMIT), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_delayed_insert_timeout(\n       \"delayed_insert_timeout\",\n       \"How long a INSERT DELAYED thread should wait for INSERT statements \"\n       \"before terminating\",\n       GLOBAL_VAR(delayed_insert_timeout), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, LONG_TIMEOUT), DEFAULT(DELAYED_WAIT_TIMEOUT),\n       BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_delayed_queue_size(\n       \"delayed_queue_size\",\n       \"What size queue (in rows) should be allocated for handling INSERT \"\n       \"DELAYED. If the queue becomes full, any client that does INSERT \"\n       \"DELAYED will wait until there is room in the queue again\",\n       GLOBAL_VAR(delayed_queue_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, UINT_MAX), DEFAULT(DELAYED_QUEUE_SIZE), BLOCK_SIZE(1));\n\n#ifdef HAVE_EVENT_SCHEDULER\nstatic const char *event_scheduler_names[]= { \"OFF\", \"ON\", \"DISABLED\",\n                                              \"ORIGINAL\", NullS };\nstatic bool event_scheduler_check(sys_var *self, THD *thd, set_var *var)\n{\n  if (Events::opt_event_scheduler == Events::EVENTS_DISABLED)\n  {\n    my_error(ER_OPTION_PREVENTS_STATEMENT, MYF(0),\n             \"--event-scheduler=DISABLED or --skip-grant-tables\");\n    return true;\n  }\n  /* DISABLED is only accepted on the command line */\n  if (var->save_result.ulonglong_value == Events::EVENTS_DISABLED)\n    return true;\n  return false;\n}\n\nstatic bool event_scheduler_update(sys_var *self, THD *thd, enum_var_type type)\n{\n  int err_no= 0;\n  bool ret;\n  uint opt_event_scheduler_value= Events::opt_event_scheduler;\n  mysql_mutex_unlock(&LOCK_global_system_variables);\n  /*\n    Events::start() is heavyweight. In particular it creates a new THD,\n    which takes LOCK_global_system_variables internally.\n    Thus we have to release it here.\n    We need to re-take it before returning, though.\n\n    Note that since we release LOCK_global_system_variables before calling\n    start/stop, there is a possibility that the server variable\n    can become out of sync with the real event scheduler state.\n\n    This can happen with two concurrent statments if the first gets\n    interrupted after start/stop but before retaking\n    LOCK_global_system_variables. However, this problem should be quite\n    rare and it's difficult to avoid it without opening up possibilities\n    for deadlocks. See bug#51160.\n  */\n\n  /* EVENTS_ORIGINAL means we should revert back to the startup state */\n  if (opt_event_scheduler_value == Events::EVENTS_ORIGINAL)\n  {\n    opt_event_scheduler_value= Events::opt_event_scheduler=\n      Events::startup_state;\n  }\n \n  /*\n    If the scheduler was not properly inited (because of wrong system tables),\n    try to init it again. This is needed for mysql_upgrade to work properly if\n    the event tables where upgraded.\n  */\n  if (!Events::inited && (Events::init(thd, 0) || !Events::inited))\n    ret= 1;\n  else\n    ret= opt_event_scheduler_value == Events::EVENTS_ON ?\n      Events::start(&err_no) :\n      Events::stop();\n  mysql_mutex_lock(&LOCK_global_system_variables);\n  if (ret)\n  {\n    Events::opt_event_scheduler= Events::EVENTS_OFF;\n    my_error(ER_EVENT_SET_VAR_ERROR, MYF(0), err_no);\n  }\n  return ret;\n}\n\nstatic Sys_var_enum Sys_event_scheduler(\n       \"event_scheduler\", \"Enable the event scheduler. Possible values are \"\n       \"ON, OFF, and DISABLED (keep the event scheduler completely \"\n       \"deactivated, it cannot be activated run-time)\",\n       GLOBAL_VAR(Events::opt_event_scheduler), CMD_LINE(OPT_ARG),\n       event_scheduler_names, DEFAULT(Events::EVENTS_OFF),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(event_scheduler_check), ON_UPDATE(event_scheduler_update));\n#endif\n\nstatic Sys_var_ulong Sys_expire_logs_days(\n       \"expire_logs_days\",\n       \"If non-zero, binary logs will be purged after expire_logs_days \"\n       \"days; possible purges happen at startup and at binary log rotation\",\n       GLOBAL_VAR(expire_logs_days),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, 99), DEFAULT(0), BLOCK_SIZE(1));\n\nstatic Sys_var_mybool Sys_flush(\n       \"flush\", \"Flush MyISAM tables to disk between SQL commands\",\n       GLOBAL_VAR(myisam_flush),\n       CMD_LINE(OPT_ARG), DEFAULT(FALSE));\n\nstatic Sys_var_ulong Sys_flush_time(\n       \"flush_time\",\n       \"A dedicated thread is created to flush all tables at the \"\n       \"given interval\",\n       GLOBAL_VAR(flush_time),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, LONG_TIMEOUT),\n       DEFAULT(0), BLOCK_SIZE(1));\n\nstatic bool check_ftb_syntax(sys_var *self, THD *thd, set_var *var)\n{\n  return ft_boolean_check_syntax_string((uchar*)\n                      (var->save_result.string_value.str));\n}\nstatic bool query_cache_flush(sys_var *self, THD *thd, enum_var_type type)\n{\n#ifdef HAVE_QUERY_CACHE\n  query_cache.flush();\n#endif /* HAVE_QUERY_CACHE */\n  return false;\n}\n/// @todo make SESSION_VAR (usability enhancement and a fix for a race condition)\nstatic Sys_var_charptr Sys_ft_boolean_syntax(\n       \"ft_boolean_syntax\", \"List of operators for \"\n       \"MATCH ... AGAINST ( ... IN BOOLEAN MODE)\",\n       GLOBAL_VAR(ft_boolean_syntax),\n       CMD_LINE(REQUIRED_ARG), IN_SYSTEM_CHARSET,\n       DEFAULT(DEFAULT_FTB_SYNTAX), NO_MUTEX_GUARD,\n       NOT_IN_BINLOG, ON_CHECK(check_ftb_syntax), ON_UPDATE(query_cache_flush));\n\nstatic Sys_var_ulong Sys_ft_max_word_len(\n       \"ft_max_word_len\",\n       \"The maximum length of the word to be included in a FULLTEXT index. \"\n       \"Note: FULLTEXT indexes must be rebuilt after changing this variable\",\n       READ_ONLY GLOBAL_VAR(ft_max_word_len), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(10, HA_FT_MAXCHARLEN), DEFAULT(HA_FT_MAXCHARLEN),\n       BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_ft_min_word_len(\n       \"ft_min_word_len\",\n       \"The minimum length of the word to be included in a FULLTEXT index. \"\n       \"Note: FULLTEXT indexes must be rebuilt after changing this variable\",\n       READ_ONLY GLOBAL_VAR(ft_min_word_len), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, HA_FT_MAXCHARLEN), DEFAULT(4), BLOCK_SIZE(1));\n\n/// @todo make it an updatable SESSION_VAR\nstatic Sys_var_ulong Sys_ft_query_expansion_limit(\n       \"ft_query_expansion_limit\",\n       \"Number of best matches to use for query expansion\",\n       READ_ONLY GLOBAL_VAR(ft_query_expansion_limit),\n       CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, 1000), DEFAULT(20), BLOCK_SIZE(1));\n\nstatic Sys_var_charptr Sys_ft_stopword_file(\n       \"ft_stopword_file\",\n       \"Use stopwords from this file instead of built-in list\",\n       READ_ONLY GLOBAL_VAR(ft_stopword_file), CMD_LINE(REQUIRED_ARG),\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic Sys_var_mybool Sys_ignore_builtin_innodb(\n       \"ignore_builtin_innodb\",\n       \"Disable initialization of builtin InnoDB plugin\",\n       READ_ONLY GLOBAL_VAR(opt_ignore_builtin_innodb),\n       CMD_LINE(OPT_ARG), DEFAULT(FALSE));\n\nstatic bool check_init_string(sys_var *self, THD *thd, set_var *var)\n{\n  if (var->save_result.string_value.str == 0)\n  {\n    var->save_result.string_value.str= const_cast<char*>(\"\");\n    var->save_result.string_value.length= 0;\n  }\n  return false;\n}\nstatic PolyLock_rwlock PLock_sys_init_connect(&LOCK_sys_init_connect);\nstatic Sys_var_lexstring Sys_init_connect(\n       \"init_connect\", \"Command(s) that are executed for each \"\n       \"new connection (unless the user has SUPER privilege)\",\n       GLOBAL_VAR(opt_init_connect), CMD_LINE(REQUIRED_ARG), IN_SYSTEM_CHARSET,\n       DEFAULT(\"\"), &PLock_sys_init_connect, NOT_IN_BINLOG,\n       ON_CHECK(check_init_string));\n\n#ifdef HAVE_REPLICATION\nstatic bool check_master_connection(sys_var *self, THD *thd, set_var *var)\n{\n  LEX_CSTRING tmp;\n  tmp.str= var->save_result.string_value.str;\n  tmp.length= var->save_result.string_value.length;\n  if (!tmp.str || check_master_connection_name(&tmp))\n    return true;\n\n  return false;\n}\n\nstatic Sys_var_session_lexstring Sys_default_master_connection(\n       \"default_master_connection\",\n       \"Master connection to use for all slave variables and slave commands\",\n       SESSION_ONLY(default_master_connection),\n       NO_CMD_LINE, IN_SYSTEM_CHARSET,\n       DEFAULT(\"\"), MAX_CONNECTION_NAME, ON_CHECK(check_master_connection));\n#endif\n\nstatic Sys_var_charptr Sys_init_file(\n       \"init_file\", \"Read SQL commands from this file at startup\",\n       READ_ONLY GLOBAL_VAR(opt_init_file),\n#ifdef DISABLE_GRANT_OPTIONS\n       NO_CMD_LINE,\n#else\n       CMD_LINE(REQUIRED_ARG),\n#endif\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic PolyLock_rwlock PLock_sys_init_slave(&LOCK_sys_init_slave);\nstatic Sys_var_lexstring Sys_init_slave(\n       \"init_slave\", \"Command(s) that are executed by a slave server \"\n       \"each time the SQL thread starts\", GLOBAL_VAR(opt_init_slave),\n       CMD_LINE(REQUIRED_ARG), IN_SYSTEM_CHARSET,\n       DEFAULT(\"\"), &PLock_sys_init_slave,\n       NOT_IN_BINLOG, ON_CHECK(check_init_string));\n\nstatic Sys_var_ulong Sys_interactive_timeout(\n       \"interactive_timeout\",\n       \"The number of seconds the server waits for activity on an interactive \"\n       \"connection before closing it\",\n       NO_SET_STMT SESSION_VAR(net_interactive_timeout),\n       CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, LONG_TIMEOUT), DEFAULT(NET_WAIT_TIMEOUT), BLOCK_SIZE(1));\n\nstatic Sys_var_ulonglong Sys_join_buffer_size(\n       \"join_buffer_size\",\n       \"The size of the buffer that is used for joins\",\n       SESSION_VAR(join_buff_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(128, SIZE_T_MAX), DEFAULT(256*1024), BLOCK_SIZE(128));\n\nstatic Sys_var_keycache Sys_key_buffer_size(\n       \"key_buffer_size\", \"The size of the buffer used for \"\n       \"index blocks for MyISAM tables. Increase this to get better index \"\n       \"handling (for all reads and multiple writes) to as much as you can \"\n       \"afford\",\n       KEYCACHE_VAR(param_buff_size),\n       CMD_LINE(REQUIRED_ARG, OPT_KEY_BUFFER_SIZE),\n       VALID_RANGE(0, SIZE_T_MAX), DEFAULT(KEY_CACHE_SIZE),\n       BLOCK_SIZE(IO_SIZE), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(update_buffer_size));\n\nstatic Sys_var_keycache Sys_key_cache_block_size(\n       \"key_cache_block_size\", \"The default size of key cache blocks\",\n       KEYCACHE_VAR(param_block_size),\n       CMD_LINE(REQUIRED_ARG, OPT_KEY_CACHE_BLOCK_SIZE),\n       VALID_RANGE(512, 1024*16), DEFAULT(KEY_CACHE_BLOCK_SIZE),\n       BLOCK_SIZE(512), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(resize_keycache));\n\nstatic Sys_var_keycache Sys_key_cache_division_limit(\n       \"key_cache_division_limit\",\n       \"The minimum percentage of warm blocks in key cache\",\n       KEYCACHE_VAR(param_division_limit),\n       CMD_LINE(REQUIRED_ARG, OPT_KEY_CACHE_DIVISION_LIMIT),\n       VALID_RANGE(1, 100), DEFAULT(100),\n       BLOCK_SIZE(1), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(change_keycache_param));\n\nstatic Sys_var_keycache Sys_key_cache_age_threshold(\n       \"key_cache_age_threshold\", \"This characterizes the number of \"\n       \"hits a hot block has to be untouched until it is considered aged \"\n       \"enough to be downgraded to a warm block. This specifies the \"\n       \"percentage ratio of that number of hits to the total number of \"\n       \"blocks in key cache\",\n       KEYCACHE_VAR(param_age_threshold),\n       CMD_LINE(REQUIRED_ARG, OPT_KEY_CACHE_AGE_THRESHOLD),\n       VALID_RANGE(100, UINT_MAX), DEFAULT(300),\n       BLOCK_SIZE(100), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(change_keycache_param));\n\nstatic Sys_var_keycache Sys_key_cache_file_hash_size(\n       \"key_cache_file_hash_size\",\n       \"Number of hash buckets for open and changed files.  If you have a lot of MyISAM \"\n       \"files open you should increase this for faster flush of changes. A good \"\n       \"value is probably 1/10 of number of possible open MyISAM files.\",\n       KEYCACHE_VAR(changed_blocks_hash_size),\n       CMD_LINE(REQUIRED_ARG, OPT_KEY_CACHE_CHANGED_BLOCKS_HASH_SIZE),\n       VALID_RANGE(128, 16384), DEFAULT(512),\n       BLOCK_SIZE(1), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(resize_keycache));\n\nstatic Sys_var_mybool Sys_large_files_support(\n       \"large_files_support\",\n       \"Whether mysqld was compiled with options for large file support\",\n       READ_ONLY GLOBAL_VAR(opt_large_files),\n       CMD_LINE_HELP_ONLY, DEFAULT(sizeof(my_off_t) > 4));\n\nstatic Sys_var_uint Sys_large_page_size(\n       \"large_page_size\",\n       \"If large page support is enabled, this shows the size of memory pages\",\n       READ_ONLY GLOBAL_VAR(opt_large_page_size), NO_CMD_LINE,\n       VALID_RANGE(0, UINT_MAX), DEFAULT(0), BLOCK_SIZE(1));\n\nstatic Sys_var_mybool Sys_large_pages(\n       \"large_pages\", \"Enable support for large pages\",\n       READ_ONLY GLOBAL_VAR(opt_large_pages),\n       IF_WIN(NO_CMD_LINE, CMD_LINE(OPT_ARG)), DEFAULT(FALSE));\n\nstatic Sys_var_charptr Sys_language(\n       \"lc_messages_dir\", \"Directory where error messages are\",\n       READ_ONLY GLOBAL_VAR(lc_messages_dir_ptr), CMD_LINE(REQUIRED_ARG, 'L'),\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic Sys_var_mybool Sys_local_infile(\n       \"local_infile\", \"Enable LOAD DATA LOCAL INFILE\",\n       GLOBAL_VAR(opt_local_infile), CMD_LINE(OPT_ARG), DEFAULT(TRUE));\n\nstatic Sys_var_ulong Sys_lock_wait_timeout(\n       \"lock_wait_timeout\",\n       \"Timeout in seconds to wait for a lock before returning an error.\",\n       SESSION_VAR(lock_wait_timeout), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, LONG_TIMEOUT), DEFAULT(24 * 60 * 60), BLOCK_SIZE(1));\n\n#ifdef HAVE_MLOCKALL\nstatic Sys_var_mybool Sys_locked_in_memory(\n       \"locked_in_memory\",\n       \"Whether mysqld was locked in memory with --memlock\",\n       READ_ONLY GLOBAL_VAR(locked_in_memory), NO_CMD_LINE, DEFAULT(FALSE));\n#endif\n\n/* this says NO_CMD_LINE, as command-line option takes a string, not a bool */\nstatic Sys_var_mybool Sys_log_bin(\n       \"log_bin\", \"Whether the binary log is enabled\",\n       READ_ONLY GLOBAL_VAR(opt_bin_log), NO_CMD_LINE, DEFAULT(FALSE));\n\nstatic Sys_var_mybool Sys_log_bin_compress(\n  \"log_bin_compress\", \"Whether the binary log can be compressed\",\n  GLOBAL_VAR(opt_bin_log_compress), CMD_LINE(OPT_ARG), DEFAULT(FALSE));\n\n/* the min length is 10, means that Begin/Commit/Rollback would never be compressed!   */\nstatic Sys_var_uint Sys_log_bin_compress_min_len(\n  \"log_bin_compress_min_len\",\n  \"Minimum length of sql statement(in statement mode) or record(in row mode)\"\n  \"that can be compressed.\",\n  GLOBAL_VAR(opt_bin_log_compress_min_len),\n  CMD_LINE(OPT_ARG), VALID_RANGE(10, 1024), DEFAULT(256), BLOCK_SIZE(1));\n\nstatic Sys_var_mybool Sys_trust_function_creators(\n       \"log_bin_trust_function_creators\",\n       \"If set to FALSE (the default), then when --log-bin is used, creation \"\n       \"of a stored function (or trigger) is allowed only to users having the \"\n       \"SUPER privilege and only if this stored function (trigger) may not \"\n       \"break binary logging. Note that if ALL connections to this server \"\n       \"ALWAYS use row-based binary logging, the security issues do not \"\n       \"exist and the binary logging cannot break, so you can safely set \"\n       \"this to TRUE\",\n       GLOBAL_VAR(trust_function_creators),\n       CMD_LINE(OPT_ARG), DEFAULT(FALSE));\n\nstatic Sys_var_charptr Sys_log_error(\n       \"log_error\",\n       \"Log errors to file (instead of stdout).  If file name is not specified \"\n       \"then 'datadir'/'log-basename'.err or the 'pid-file' path with extension \"\n       \".err is used\",\n       READ_ONLY GLOBAL_VAR(log_error_file_ptr),\n       CMD_LINE(OPT_ARG, OPT_LOG_ERROR),\n       IN_FS_CHARSET, DEFAULT(disabled_my_option));\n\nstatic Sys_var_bit Sys_log_queries_not_using_indexes(\n       \"log_queries_not_using_indexes\",\n       \"Log queries that are executed without benefit of any index to the \"\n       \"slow log if it is open. Same as log_slow_filter='not_using_index'\",\n       SESSION_VAR(log_slow_filter), CMD_LINE(OPT_ARG), QPLAN_NOT_USING_INDEX,\n       DEFAULT(FALSE));\n\nstatic Sys_var_bit Sys_log_slow_admin_statements(\n       \"log_slow_admin_statements\",\n       \"Log slow OPTIMIZE, ANALYZE, ALTER and other administrative statements \"\n       \"to the slow log if it is open.  Resets or sets the option 'admin' in \"\n       \"log_slow_disabled_statements\",\n       SESSION_VAR(log_slow_disabled_statements),\n       CMD_LINE(OPT_ARG), REVERSE(LOG_SLOW_DISABLE_ADMIN), DEFAULT(TRUE));\n\nstatic Sys_var_bit Sys_log_slow_slave_statements(\n       \"log_slow_slave_statements\",\n       \"Log slow statements executed by slave thread to the slow log if it is \"\n       \"open. Resets or sets the option 'slave' in \"\n       \"log_slow_disabled_statements\",\n       SESSION_VAR(log_slow_disabled_statements),\n       CMD_LINE(OPT_ARG), REVERSE(LOG_SLOW_DISABLE_SLAVE), DEFAULT(TRUE));\n\nstatic Sys_var_ulong Sys_log_warnings(\n       \"log_warnings\",\n       \"Log some not critical warnings to the general log file.\"\n       \"Value can be between 0 and 11. Higher values mean more verbosity\",\n       SESSION_VAR(log_warnings),\n       CMD_LINE(OPT_ARG, 'W'),\n       VALID_RANGE(0, UINT_MAX), DEFAULT(2), BLOCK_SIZE(1));\n\nstatic bool update_cached_long_query_time(sys_var *self, THD *thd,\n                                          enum_var_type type)\n{\n  if (type == OPT_SESSION)\n    thd->variables.long_query_time=\n      double2ulonglong(thd->variables.long_query_time_double * 1e6);\n  else\n    global_system_variables.long_query_time=\n      double2ulonglong(global_system_variables.long_query_time_double * 1e6);\n  return false;\n}\n\nstatic Sys_var_double Sys_long_query_time(\n       \"long_query_time\",\n       \"Log all queries that have taken more than long_query_time seconds \"\n       \"to execute to the slow query log file. The argument will be treated \"\n       \"as a decimal value with microsecond precision\",\n       SESSION_VAR(long_query_time_double),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, LONG_TIMEOUT), DEFAULT(10),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(update_cached_long_query_time));\n\n\nstatic bool update_cached_max_statement_time(sys_var *self, THD *thd,\n                                         enum_var_type type)\n{\n  if (type == OPT_SESSION)\n    thd->variables.max_statement_time=\n      double2ulonglong(thd->variables.max_statement_time_double * 1e6);\n  else\n    global_system_variables.max_statement_time=\n      double2ulonglong(global_system_variables.max_statement_time_double * 1e6);\n  return false;\n}\n\nstatic Sys_var_double Sys_max_statement_time(\n       \"max_statement_time\",\n       \"A query that has taken more than max_statement_time seconds \"\n       \"will be aborted. The argument will be treated as a decimal value \"\n       \"with microsecond precision. A value of 0 (default) means no timeout\",\n       SESSION_VAR(max_statement_time_double),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, LONG_TIMEOUT), DEFAULT(0),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(update_cached_max_statement_time));\n\nstatic bool fix_low_prio_updates(sys_var *self, THD *thd, enum_var_type type)\n{\n  if (type == OPT_SESSION)\n    thd->update_lock_default= (thd->variables.low_priority_updates ?\n                               TL_WRITE_LOW_PRIORITY : TL_WRITE);\n  else\n    thr_upgraded_concurrent_insert_lock=\n      (global_system_variables.low_priority_updates ?\n       TL_WRITE_LOW_PRIORITY : TL_WRITE);\n  return false;\n}\nstatic Sys_var_mybool Sys_low_priority_updates(\n       \"low_priority_updates\",\n       \"INSERT/DELETE/UPDATE has lower priority than selects\",\n       SESSION_VAR(low_priority_updates),\n       CMD_LINE(OPT_ARG),\n       DEFAULT(FALSE), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_low_prio_updates));\n\nstatic Sys_var_mybool Sys_lower_case_file_system(\n       \"lower_case_file_system\",\n       \"Case sensitivity of file names on the file system where the \"\n       \"data directory is located\",\n       READ_ONLY GLOBAL_VAR(lower_case_file_system),\n       CMD_LINE_HELP_ONLY,\n       DEFAULT(FALSE));\n\nstatic Sys_var_uint Sys_lower_case_table_names(\n       \"lower_case_table_names\",\n       \"If set to 1 table names are stored in lowercase on disk and table \"\n       \"names will be case-insensitive.  Should be set to 2 if you are using \"\n       \"a case insensitive file system\",\n       READ_ONLY GLOBAL_VAR(lower_case_table_names),\n       CMD_LINE(OPT_ARG, OPT_LOWER_CASE_TABLE_NAMES),\n       VALID_RANGE(0, 2),\n#ifdef FN_NO_CASE_SENSE\n    DEFAULT(1),\n#else\n    DEFAULT(0),\n#endif\n       BLOCK_SIZE(1));\n\nstatic bool session_readonly(sys_var *self, THD *thd, set_var *var)\n{\n  if (var->type == OPT_GLOBAL)\n    return false;\n  my_error(ER_VARIABLE_IS_READONLY, MYF(0), \"SESSION\",\n           self->name.str, \"GLOBAL\");\n  return true;\n}\n\nstatic bool check_max_allowed_packet(sys_var *self, THD *thd,  set_var *var)\n{\n  longlong val;\n  if (session_readonly(self, thd, var))\n    return true;\n\n  val= var->save_result.ulonglong_value;\n  if (val < (longlong) global_system_variables.net_buffer_length)\n  {\n    push_warning_printf(thd, Sql_condition::WARN_LEVEL_WARN,\n                        WARN_OPTION_BELOW_LIMIT,\n                        ER_THD(thd, WARN_OPTION_BELOW_LIMIT),\n                        \"max_allowed_packet\", \"net_buffer_length\");\n  }\n  return false;\n}\n\n\nstatic Sys_var_ulong Sys_max_allowed_packet(\n       \"max_allowed_packet\",\n       \"Max packet length to send to or receive from the server\",\n       SESSION_VAR(max_allowed_packet), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1024, 1024*1024*1024), DEFAULT(16*1024*1024),\n       BLOCK_SIZE(1024), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(check_max_allowed_packet));\n\nstatic Sys_var_ulong Sys_slave_max_allowed_packet(\n       \"slave_max_allowed_packet\",\n       \"The maximum packet length to sent successfully from the master to slave.\",\n       GLOBAL_VAR(slave_max_allowed_packet), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1024, MAX_MAX_ALLOWED_PACKET),\n       DEFAULT(MAX_MAX_ALLOWED_PACKET),\n       BLOCK_SIZE(1024));\n\nstatic Sys_var_ulonglong Sys_max_binlog_cache_size(\n       \"max_binlog_cache_size\",\n       \"Sets the total size of the transactional cache\",\n       GLOBAL_VAR(max_binlog_cache_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(IO_SIZE, SIZE_T_MAX),\n       DEFAULT((SIZE_T_MAX/IO_SIZE)*IO_SIZE),\n       BLOCK_SIZE(IO_SIZE));\n\nstatic Sys_var_ulonglong Sys_max_binlog_stmt_cache_size(\n       \"max_binlog_stmt_cache_size\",\n       \"Sets the total size of the statement cache\",\n       GLOBAL_VAR(max_binlog_stmt_cache_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(IO_SIZE, SIZE_T_MAX),\n       DEFAULT((SIZE_T_MAX/IO_SIZE)*IO_SIZE),\n       BLOCK_SIZE(IO_SIZE));\n\nstatic bool fix_max_binlog_size(sys_var *self, THD *thd, enum_var_type type)\n{\n  mysql_bin_log.set_max_size(max_binlog_size);\n  return false;\n}\nstatic Sys_var_ulong Sys_max_binlog_size(\n       \"max_binlog_size\",\n       \"Binary log will be rotated automatically when the size exceeds this \"\n       \"value.\",\n       GLOBAL_VAR(max_binlog_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(IO_SIZE, 1024*1024L*1024L), DEFAULT(1024*1024L*1024L),\n       BLOCK_SIZE(IO_SIZE), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_max_binlog_size));\n\nstatic bool fix_max_connections(sys_var *self, THD *thd, enum_var_type type)\n{\n#ifndef EMBEDDED_LIBRARY\n  resize_thr_alarm(max_connections + extra_max_connections +\n                   global_system_variables.max_insert_delayed_threads + 10);\n#endif\n  return false;\n}\n\n// Default max_connections of 151 is larger than Apache's default max\n// children, to avoid \"too many connections\" error in a common setup\nstatic Sys_var_ulong Sys_max_connections(\n       \"max_connections\", \"The number of simultaneous clients allowed\",\n       PARSED_EARLY GLOBAL_VAR(max_connections), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(10, 100000),\n       DEFAULT(MAX_CONNECTIONS_DEFAULT), BLOCK_SIZE(1), NO_MUTEX_GUARD,\n       NOT_IN_BINLOG, ON_CHECK(0), ON_UPDATE(fix_max_connections));\n\nstatic Sys_var_uint Sys_default_password_lifetime(\n       \"default_password_lifetime\",\n       \"This defines the global password expiration policy. 0 means \"\n       \"automatic password expiration is disabled. If the value is a \"\n       \"positive integer N, the passwords must be changed every N days. This \"\n       \"behavior can be overridden using the password expiration options in \"\n       \"ALTER USER.\",\n       GLOBAL_VAR(default_password_lifetime), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, UINT_MAX), DEFAULT(0), BLOCK_SIZE(1));\n\nstatic Sys_var_mybool Sys_disconnect_on_expired_password(\n       \"disconnect_on_expired_password\",\n       \"This variable controls how the server handles clients that are not \"\n       \"aware of the sandbox mode. If enabled, the server disconnects the \"\n       \"client, otherwise the server puts the client in a sandbox mode.\",\n       GLOBAL_VAR(disconnect_on_expired_password), CMD_LINE(OPT_ARG),\n       DEFAULT(FALSE));\n\nstatic Sys_var_ulong Sys_max_connect_errors(\n       \"max_connect_errors\",\n       \"If there is more than this number of interrupted connections from \"\n       \"a host this host will be blocked from further connections\",\n       GLOBAL_VAR(max_connect_errors), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, UINT_MAX), DEFAULT(MAX_CONNECT_ERRORS),\n       BLOCK_SIZE(1));\n\nstatic Sys_var_uint Sys_max_password_errors(\n       \"max_password_errors\",\n       \"If there is more than this number of failed connect attempts \"\n       \"due to invalid password, user will be blocked from further connections until FLUSH_PRIVILEGES.\",\n       GLOBAL_VAR(max_password_errors), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, UINT_MAX), DEFAULT(UINT_MAX),\n       BLOCK_SIZE(1));\n\nstatic Sys_var_uint Sys_max_digest_length(\n       \"max_digest_length\", \"Maximum length considered for digest text.\",\n       READ_ONLY GLOBAL_VAR(max_digest_length),\n       CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, 1024 * 1024), DEFAULT(1024), BLOCK_SIZE(1));\n\nstatic bool check_max_delayed_threads(sys_var *self, THD *thd, set_var *var)\n{\n  return var->type != OPT_GLOBAL &&\n         var->save_result.ulonglong_value != 0 &&\n         var->save_result.ulonglong_value !=\n                           global_system_variables.max_insert_delayed_threads;\n}\n\n// Alias for max_delayed_threads\nstatic Sys_var_ulong Sys_max_insert_delayed_threads(\n       \"max_insert_delayed_threads\",\n       \"Don't start more than this number of threads to handle INSERT \"\n       \"DELAYED statements. If set to zero INSERT DELAYED will be not used\",\n       SESSION_VAR(max_insert_delayed_threads),\n       NO_CMD_LINE, VALID_RANGE(0, 16384), DEFAULT(20),\n       BLOCK_SIZE(1), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(check_max_delayed_threads), ON_UPDATE(fix_max_connections));\n\nstatic Sys_var_ulong Sys_max_delayed_threads(\n       \"max_delayed_threads\",\n       \"Don't start more than this number of threads to handle INSERT \"\n       \"DELAYED statements. If set to zero INSERT DELAYED will be not used\",\n       SESSION_VAR(max_insert_delayed_threads),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, 16384), DEFAULT(20),\n       BLOCK_SIZE(1), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(check_max_delayed_threads), ON_UPDATE(fix_max_connections));\n\nstatic Sys_var_ulong Sys_max_error_count(\n       \"max_error_count\",\n       \"Max number of errors/warnings to store for a statement\",\n       SESSION_VAR(max_error_count), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, 65535), DEFAULT(DEFAULT_ERROR_COUNT), BLOCK_SIZE(1));\n\nstatic Sys_var_ulonglong Sys_max_heap_table_size(\n       \"max_heap_table_size\",\n       \"Don't allow creation of heap tables bigger than this\",\n       SESSION_VAR(max_heap_table_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(16384, SIZE_T_MAX), DEFAULT(16*1024*1024),\n       BLOCK_SIZE(1024));\n\nstatic ulong mdl_locks_cache_size;\nstatic Sys_var_ulong Sys_metadata_locks_cache_size(\n       \"metadata_locks_cache_size\", \"Unused\",\n       READ_ONLY GLOBAL_VAR(mdl_locks_cache_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, 1024*1024), DEFAULT(1024),\n       BLOCK_SIZE(1));\n\nstatic ulong mdl_locks_hash_partitions;\nstatic Sys_var_ulong Sys_metadata_locks_hash_instances(\n       \"metadata_locks_hash_instances\", \"Unused\",\n       READ_ONLY GLOBAL_VAR(mdl_locks_hash_partitions), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, 1024), DEFAULT(8),\n       BLOCK_SIZE(1));\n\nstatic Sys_var_ulonglong Sys_pseudo_thread_id(\n       \"pseudo_thread_id\",\n       \"This variable is for internal server use\",\n       SESSION_ONLY(pseudo_thread_id),\n       NO_CMD_LINE, VALID_RANGE(0, ULONGLONG_MAX), DEFAULT(0),\n       BLOCK_SIZE(1), NO_MUTEX_GUARD, IN_BINLOG,\n       ON_CHECK(check_has_super));\n\nstatic bool\ncheck_gtid_domain_id(sys_var *self, THD *thd, set_var *var)\n{\n  if (check_has_super(self, thd, var))\n    return true;\n  if (var->type != OPT_GLOBAL &&\n      error_if_in_trans_or_substatement(thd,\n          ER_STORED_FUNCTION_PREVENTS_SWITCH_GTID_DOMAIN_ID_SEQ_NO,\n          ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_GTID_DOMAIN_ID_SEQ_NO))\n    return true;\n\n  return false;\n}\n\n\nstatic Sys_var_uint Sys_gtid_domain_id(\n       \"gtid_domain_id\",\n       \"Used with global transaction ID to identify logically independent \"\n       \"replication streams. When events can propagate through multiple \"\n       \"parallel paths (for example multiple masters), each independent \"\n       \"source server must use a distinct domain_id. For simple tree-shaped \"\n       \"replication topologies, it can be left at its default, 0.\",\n       SESSION_VAR(gtid_domain_id),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, UINT_MAX32), DEFAULT(0),\n       BLOCK_SIZE(1), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(check_gtid_domain_id));\n\n\nstatic bool check_gtid_seq_no(sys_var *self, THD *thd, set_var *var)\n{\n  uint32 domain_id, server_id;\n  uint64 seq_no;\n\n  if (check_has_super(self, thd, var))\n    return true;\n  if (unlikely(error_if_in_trans_or_substatement(thd,\n                                                 ER_STORED_FUNCTION_PREVENTS_SWITCH_GTID_DOMAIN_ID_SEQ_NO,\n                                                 ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_GTID_DOMAIN_ID_SEQ_NO)))\n    return true;\n\n  domain_id= thd->variables.gtid_domain_id;\n  server_id= thd->variables.server_id;\n  seq_no= (uint64)var->value->val_uint();\n  DBUG_EXECUTE_IF(\"ignore_set_gtid_seq_no_check\", return 0;);\n  if (opt_gtid_strict_mode && opt_bin_log &&\n      mysql_bin_log.check_strict_gtid_sequence(domain_id, server_id, seq_no))\n    return true;\n\n  return false;\n}\n\n\nstatic Sys_var_ulonglong Sys_gtid_seq_no(\n       \"gtid_seq_no\",\n       \"Internal server usage, for replication with global transaction id. \"\n       \"When set, next event group logged to the binary log will use this \"\n       \"sequence number, not generate a new one, thus allowing to preserve \"\n       \"master's GTID in slave's binlog.\",\n       SESSION_ONLY(gtid_seq_no),\n       NO_CMD_LINE, VALID_RANGE(0, ULONGLONG_MAX), DEFAULT(0),\n       BLOCK_SIZE(1), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(check_gtid_seq_no));\n\n\n#ifdef HAVE_REPLICATION\nstatic unsigned char opt_gtid_binlog_pos_dummy;\nstatic Sys_var_gtid_binlog_pos Sys_gtid_binlog_pos(\n       \"gtid_binlog_pos\", \"Last GTID logged to the binary log, per replication\"\n       \"domain\",\n       READ_ONLY GLOBAL_VAR(opt_gtid_binlog_pos_dummy), NO_CMD_LINE);\n\n\nuchar *\nSys_var_gtid_binlog_pos::global_value_ptr(THD *thd, const LEX_CSTRING *base)\n{\n  char buf[128];\n  String str(buf, sizeof(buf), system_charset_info);\n  char *p;\n\n  str.length(0);\n  if ((opt_bin_log && mysql_bin_log.append_state_pos(&str)) ||\n      !(p= thd->strmake(str.ptr(), str.length())))\n  {\n    my_error(ER_OUT_OF_RESOURCES, MYF(0));\n    return NULL;\n  }\n\n  return (uchar *)p;\n}\n\n\nstatic unsigned char opt_gtid_current_pos_dummy;\nstatic Sys_var_gtid_current_pos Sys_gtid_current_pos(\n       \"gtid_current_pos\", \"Current GTID position of the server. Per \"\n       \"replication domain, this is either the last GTID replicated by a \"\n       \"slave thread, or the GTID logged to the binary log, whichever is \"\n       \"most recent.\",\n       READ_ONLY GLOBAL_VAR(opt_gtid_current_pos_dummy), NO_CMD_LINE);\n\n\nuchar *\nSys_var_gtid_current_pos::global_value_ptr(THD *thd, const LEX_CSTRING *base)\n{\n  String str;\n  char *p;\n\n  str.length(0);\n  if (rpl_append_gtid_state(&str, true) ||\n      !(p= thd->strmake(str.ptr(), str.length())))\n  {\n    my_error(ER_OUT_OF_RESOURCES, MYF(0));\n    return NULL;\n  }\n\n  return (uchar *)p;\n}\n\n\nbool\nSys_var_gtid_slave_pos::do_check(THD *thd, set_var *var)\n{\n  String str, *res;\n\n  DBUG_ASSERT(var->type == OPT_GLOBAL);\n\n  if (rpl_load_gtid_slave_state(thd))\n  {\n    my_error(ER_CANNOT_LOAD_SLAVE_GTID_STATE, MYF(0), \"mysql\",\n             rpl_gtid_slave_state_table_name.str);\n    return true;\n  }\n\n  if (give_error_if_slave_running(0))\n    return true;\n  if (!(res= var->value->val_str(&str)))\n    return true;\n  if (thd->in_active_multi_stmt_transaction())\n  {\n    my_error(ER_CANT_DO_THIS_DURING_AN_TRANSACTION, MYF(0));\n    return true;\n  }\n  if (rpl_gtid_pos_check(thd, &((*res)[0]), res->length()))\n    return true;\n\n  if (!(var->save_result.string_value.str=\n        thd->strmake(res->ptr(), res->length())))\n  {\n    my_error(ER_OUT_OF_RESOURCES, MYF(0));\n    return true;\n  }\n  var->save_result.string_value.length= res->length();\n  return false;\n}\n\n\nbool\nSys_var_gtid_slave_pos::global_update(THD *thd, set_var *var)\n{\n  bool err;\n\n  DBUG_ASSERT(var->type == OPT_GLOBAL);\n\n  if (!var->value)\n  {\n    my_error(ER_NO_DEFAULT, MYF(0), var->var->name.str);\n    return true;\n  }\n\n  mysql_mutex_unlock(&LOCK_global_system_variables);\n  mysql_mutex_lock(&LOCK_active_mi);\n  if (give_error_if_slave_running(1))\n    err= true;\n  else\n    err= rpl_gtid_pos_update(thd, var->save_result.string_value.str,\n                             var->save_result.string_value.length);\n  mysql_mutex_unlock(&LOCK_active_mi);\n  mysql_mutex_lock(&LOCK_global_system_variables);\n  return err;\n}\n\n\nuchar *\nSys_var_gtid_slave_pos::global_value_ptr(THD *thd, const LEX_CSTRING *base)\n{\n  String str;\n  char *p;\n\n  str.length(0);\n  /*\n    If the mysql.rpl_slave_pos table could not be loaded, then we cannot\n    easily automatically try to reload it here - we may be inside a statement\n    that already has tables locked and so opening more tables is problematic.\n\n    But if the table is not loaded (eg. missing mysql_upgrade_db or some such),\n    then the slave state must be empty anyway.\n  */\n  if ((rpl_global_gtid_slave_state->loaded &&\n       rpl_append_gtid_state(&str, false)) ||\n      !(p= thd->strmake(str.ptr(), str.length())))\n  {\n    my_error(ER_OUT_OF_RESOURCES, MYF(0));\n    return NULL;\n  }\n\n  return (uchar *)p;\n}\n\n\nstatic unsigned char opt_gtid_slave_pos_dummy;\nstatic Sys_var_gtid_slave_pos Sys_gtid_slave_pos(\n       \"gtid_slave_pos\",\n       \"The list of global transaction IDs that were last replicated on the \"\n       \"server, one for each replication domain.\",\n       GLOBAL_VAR(opt_gtid_slave_pos_dummy), NO_CMD_LINE);\n\n\nstatic Sys_var_mybool Sys_gtid_strict_mode(\n       \"gtid_strict_mode\",\n       \"Enforce strict seq_no ordering of events in the binary log. Slave \"\n       \"stops with an error if it encounters an event that would cause it to \"\n       \"generate an out-of-order binlog if executed.\",\n       GLOBAL_VAR(opt_gtid_strict_mode),\n       CMD_LINE(OPT_ARG), DEFAULT(FALSE));\n\n\nstruct gtid_binlog_state_data { rpl_gtid *list; uint32 list_len; };\n\nbool\nSys_var_gtid_binlog_state::do_check(THD *thd, set_var *var)\n{\n  String str, *res;\n  struct gtid_binlog_state_data *data;\n  rpl_gtid *list;\n  uint32 list_len;\n\n  DBUG_ASSERT(var->type == OPT_GLOBAL);\n\n  if (!(res= var->value->val_str(&str)))\n    return true;\n  if (thd->in_active_multi_stmt_transaction())\n  {\n    my_error(ER_CANT_DO_THIS_DURING_AN_TRANSACTION, MYF(0));\n    return true;\n  }\n  if (!mysql_bin_log.is_open())\n  {\n    my_error(ER_FLUSH_MASTER_BINLOG_CLOSED, MYF(0));\n    return true;\n  }\n  if (!mysql_bin_log.is_empty_state())\n  {\n    my_error(ER_BINLOG_MUST_BE_EMPTY, MYF(0));\n    return true;\n  }\n  if (res->length() == 0)\n  {\n    list= NULL;\n    list_len= 0;\n  }\n  else if (!(list= gtid_parse_string_to_list(res->ptr(), res->length(),\n                                             &list_len)))\n  {\n    my_error(ER_INCORRECT_GTID_STATE, MYF(0));\n    return true;\n  }\n  if (!(data= (gtid_binlog_state_data *)my_malloc(sizeof(*data), MYF(0))))\n  {\n    my_free(list);\n    my_error(ER_OUT_OF_RESOURCES, MYF(0));\n    return true;\n  }\n  data->list= list;\n  data->list_len= list_len;\n  var->save_result.ptr= data;\n  return false;\n}\n\n\nbool\nSys_var_gtid_binlog_state::global_update(THD *thd, set_var *var)\n{\n  bool res;\n\n  DBUG_ASSERT(var->type == OPT_GLOBAL);\n\n  if (!var->value)\n  {\n    my_error(ER_NO_DEFAULT, MYF(0), var->var->name.str);\n    return true;\n  }\n\n  struct gtid_binlog_state_data *data=\n    (struct gtid_binlog_state_data *)var->save_result.ptr;\n  mysql_mutex_unlock(&LOCK_global_system_variables);\n  res= (reset_master(thd, data->list, data->list_len, 0) != 0);\n  mysql_mutex_lock(&LOCK_global_system_variables);\n  my_free(data->list);\n  my_free(data);\n  return res;\n}\n\n\nuchar *\nSys_var_gtid_binlog_state::global_value_ptr(THD *thd, const LEX_CSTRING *base)\n{\n  char buf[512];\n  String str(buf, sizeof(buf), system_charset_info);\n  char *p;\n\n  str.length(0);\n  if ((opt_bin_log && mysql_bin_log.append_state(&str)) ||\n      !(p= thd->strmake(str.ptr(), str.length())))\n  {\n    my_error(ER_OUT_OF_RESOURCES, MYF(0));\n    return NULL;\n  }\n\n  return (uchar *)p;\n}\n\n\nstatic unsigned char opt_gtid_binlog_state_dummy;\nstatic Sys_var_gtid_binlog_state Sys_gtid_binlog_state(\n       \"gtid_binlog_state\",\n       \"The internal GTID state of the binlog, used to keep track of all \"\n       \"GTIDs ever logged to the binlog.\",\n       GLOBAL_VAR(opt_gtid_binlog_state_dummy), NO_CMD_LINE);\n\n\nstatic Sys_var_last_gtid Sys_last_gtid(\n       \"last_gtid\", \"The GTID of the last commit (if binlogging was enabled), \"\n       \"or the empty string if none.\",\n       READ_ONLY sys_var::ONLY_SESSION, NO_CMD_LINE);\n\nexport sys_var *Sys_last_gtid_ptr= &Sys_last_gtid; // for check changing\n\n\nuchar *\nSys_var_last_gtid::session_value_ptr(THD *thd, const LEX_CSTRING *base)\n{\n  char buf[10+1+10+1+20+1];\n  String str(buf, sizeof(buf), system_charset_info);\n  char *p;\n  bool first= true;\n\n  str.length(0);\n  rpl_gtid gtid= thd->get_last_commit_gtid();\n  if ((gtid.seq_no > 0 &&\n       rpl_slave_state_tostring_helper(&str, &gtid, &first)) ||\n      !(p= thd->strmake(str.ptr(), str.length())))\n  {\n    my_error(ER_OUT_OF_RESOURCES, MYF(0));\n    return NULL;\n  }\n\n  return (uchar *)p;\n}\n\n\nstatic Sys_var_uint Sys_gtid_cleanup_batch_size(\n       \"gtid_cleanup_batch_size\",\n       \"Normally does not need tuning. How many old rows must accumulate in \"\n       \"the mysql.gtid_slave_pos table before a background job will be run to \"\n       \"delete them. Can be increased to reduce number of commits if \"\n       \"using many different engines with --gtid_pos_auto_engines, or to \"\n       \"reduce CPU overhead if using a huge number of different \"\n       \"gtid_domain_ids. Can be decreased to reduce number of old rows in the \"\n       \"table.\",\n       GLOBAL_VAR(opt_gtid_cleanup_batch_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0,2147483647), DEFAULT(64), BLOCK_SIZE(1));\n\n\nstatic bool\ncheck_slave_parallel_threads(sys_var *self, THD *thd, set_var *var)\n{\n  return give_error_if_slave_running(0);\n}\n\nstatic bool\nfix_slave_parallel_threads(sys_var *self, THD *thd, enum_var_type type)\n{\n  bool err;\n\n  mysql_mutex_unlock(&LOCK_global_system_variables);\n  err= give_error_if_slave_running(0);\n  mysql_mutex_lock(&LOCK_global_system_variables);\n\n  return err;\n}\n\n\nstatic Sys_var_ulong Sys_slave_parallel_threads(\n       \"slave_parallel_threads\",\n       \"If non-zero, number of threads to spawn to apply in parallel events \"\n       \"on the slave that were group-committed on the master or were logged \"\n       \"with GTID in different replication domains. Note that these threads \"\n       \"are in addition to the IO and SQL threads, which are always created \"\n       \"by a replication slave\",\n       GLOBAL_VAR(opt_slave_parallel_threads), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0,16383), DEFAULT(0), BLOCK_SIZE(1), NO_MUTEX_GUARD,\n       NOT_IN_BINLOG, ON_CHECK(check_slave_parallel_threads),\n       ON_UPDATE(fix_slave_parallel_threads));\n\n/* Alias for @@slave_parallel_threads to match what MySQL 5.7 uses. */\nstatic Sys_var_ulong Sys_slave_parallel_workers(\n       \"slave_parallel_workers\",\n       \"Alias for slave_parallel_threads\",\n       GLOBAL_VAR(opt_slave_parallel_threads), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0,16383), DEFAULT(0), BLOCK_SIZE(1), NO_MUTEX_GUARD,\n       NOT_IN_BINLOG, ON_CHECK(check_slave_parallel_threads),\n       ON_UPDATE(fix_slave_parallel_threads));\n\n\nstatic bool\ncheck_slave_domain_parallel_threads(sys_var *self, THD *thd, set_var *var)\n{\n  return give_error_if_slave_running(0);\n}\n\nstatic bool\nfix_slave_domain_parallel_threads(sys_var *self, THD *thd, enum_var_type type)\n{\n  bool running;\n\n  mysql_mutex_unlock(&LOCK_global_system_variables);\n  running= give_error_if_slave_running(0);\n  mysql_mutex_lock(&LOCK_global_system_variables);\n\n  return running;\n}\n\n\nstatic Sys_var_ulong Sys_slave_domain_parallel_threads(\n       \"slave_domain_parallel_threads\",\n       \"Maximum number of parallel threads to use on slave for events in a \"\n       \"single replication domain. When using multiple domains, this can be \"\n       \"used to limit a single domain from grabbing all threads and thus \"\n       \"stalling other domains. The default of 0 means to allow a domain to \"\n       \"grab as many threads as it wants, up to the value of \"\n       \"slave_parallel_threads.\",\n       GLOBAL_VAR(opt_slave_domain_parallel_threads), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0,16383), DEFAULT(0), BLOCK_SIZE(1), NO_MUTEX_GUARD,\n       NOT_IN_BINLOG, ON_CHECK(check_slave_domain_parallel_threads),\n       ON_UPDATE(fix_slave_domain_parallel_threads));\n\n\nstatic Sys_var_ulong Sys_slave_parallel_max_queued(\n       \"slave_parallel_max_queued\",\n       \"Limit on how much memory SQL threads should use per parallel \"\n       \"replication thread when reading ahead in the relay log looking for \"\n       \"opportunities for parallel replication. Only used when \"\n       \"--slave-parallel-threads > 0.\",\n       GLOBAL_VAR(opt_slave_parallel_max_queued), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0,2147483647), DEFAULT(131072), BLOCK_SIZE(1));\n\n\nbool\nSys_var_slave_parallel_mode::global_update(THD *thd, set_var *var)\n{\n  enum_slave_parallel_mode new_value=\n    (enum_slave_parallel_mode)var->save_result.ulonglong_value;\n  LEX_CSTRING *base_name= &var->base;\n  Master_info *mi;\n  bool res= false;\n\n  if (!base_name->length)\n    base_name= &thd->variables.default_master_connection;\n\n  mysql_mutex_unlock(&LOCK_global_system_variables);\n  mysql_mutex_lock(&LOCK_active_mi);\n\n  mi= master_info_index->\n    get_master_info(base_name, !base_name->length ?\n                    Sql_condition::WARN_LEVEL_ERROR :\n                    Sql_condition::WARN_LEVEL_WARN);\n\n  if (mi)\n  {\n    if (mi->rli.slave_running)\n    {\n      my_error(ER_SLAVE_MUST_STOP, MYF(0),\n               (int) mi->connection_name.length, mi->connection_name.str);\n      res= true;\n    }\n    else\n    {\n      mi->parallel_mode= new_value;\n      if (!base_name->length)\n      {\n        /* Use as default value for new connections */\n        opt_slave_parallel_mode= new_value;\n      }\n    }\n  }\n\n  mysql_mutex_unlock(&LOCK_active_mi);\n  mysql_mutex_lock(&LOCK_global_system_variables);\n\n  return res;\n}\n\n\nuchar *\nSys_var_slave_parallel_mode::global_value_ptr(THD *thd,\n                                              const LEX_CSTRING *base_name)\n{\n  Master_info *mi;\n  enum_slave_parallel_mode val=\n    (enum_slave_parallel_mode)opt_slave_parallel_mode;\n\n  if (!base_name->length)\n    base_name= &thd->variables.default_master_connection;\n\n  mysql_mutex_unlock(&LOCK_global_system_variables);\n  mysql_mutex_lock(&LOCK_active_mi);\n\n  mi= master_info_index->\n    get_master_info(base_name, !base_name->length ?\n                    Sql_condition::WARN_LEVEL_ERROR :\n                    Sql_condition::WARN_LEVEL_WARN);\n  if (mi)\n    val= mi->parallel_mode;\n\n  mysql_mutex_unlock(&LOCK_active_mi);\n  mysql_mutex_lock(&LOCK_global_system_variables);\n  if (!mi)\n    return 0;\n\n  return valptr(thd, val);\n}\n\n\n/* The order here must match enum_slave_parallel_mode in mysqld.h. */\nstatic const char *slave_parallel_mode_names[] = {\n  \"none\", \"minimal\", \"conservative\", \"optimistic\", \"aggressive\", NULL\n};\nexport TYPELIB slave_parallel_mode_typelib = {\n  array_elements(slave_parallel_mode_names)-1,\n  \"\",\n  slave_parallel_mode_names,\n  NULL\n};\n\nstatic Sys_var_slave_parallel_mode Sys_slave_parallel_mode(\n       \"slave_parallel_mode\",\n       \"Controls what transactions are applied in parallel when using \"\n       \"--slave-parallel-threads. Possible values: \\\"optimistic\\\" tries to \"\n       \"apply most transactional DML in parallel, and handles any conflicts \"\n       \"with rollback and retry. \\\"conservative\\\" limits parallelism in an \"\n       \"effort to avoid any conflicts. \\\"aggressive\\\" tries to maximise the \"\n       \"parallelism, possibly at the cost of increased conflict rate. \"\n       \"\\\"minimal\\\" only parallelizes the commit steps of transactions. \"\n       \"\\\"none\\\" disables parallel apply completely.\",\n       GLOBAL_VAR(opt_slave_parallel_mode), NO_CMD_LINE,\n       slave_parallel_mode_names, DEFAULT(SLAVE_PARALLEL_CONSERVATIVE));\n\n\nstatic Sys_var_bit Sys_skip_parallel_replication(\n       \"skip_parallel_replication\",\n       \"If set when a transaction is written to the binlog, parallel apply of \"\n       \"that transaction will be avoided on a slave where slave_parallel_mode \"\n       \"is not \\\"aggressive\\\". Can be used to avoid unnecessary rollback and \"\n       \"retry for transactions that are likely to cause a conflict if \"\n       \"replicated in parallel.\",\n       SESSION_ONLY(option_bits), NO_CMD_LINE, OPTION_RPL_SKIP_PARALLEL,\n       DEFAULT(FALSE));\n\n\nstatic bool\ncheck_gtid_ignore_duplicates(sys_var *self, THD *thd, set_var *var)\n{\n  return give_error_if_slave_running(0);\n}\n\nstatic bool\nfix_gtid_ignore_duplicates(sys_var *self, THD *thd, enum_var_type type)\n{\n  bool running;\n\n  mysql_mutex_unlock(&LOCK_global_system_variables);\n  running= give_error_if_slave_running(0);\n  mysql_mutex_lock(&LOCK_global_system_variables);\n\n  return running;\n}\n\n\nstatic Sys_var_mybool Sys_gtid_ignore_duplicates(\n       \"gtid_ignore_duplicates\",\n       \"When set, different master connections in multi-source replication are \"\n       \"allowed to receive and process event groups with the same GTID (when \"\n       \"using GTID mode). Only one will be applied, any others will be \"\n       \"ignored. Within a given replication domain, just the sequence number \"\n       \"will be used to decide whether a given GTID has been already applied; \"\n       \"this means it is the responsibility of the user to ensure that GTID \"\n       \"sequence numbers are strictly increasing.\",\n       GLOBAL_VAR(opt_gtid_ignore_duplicates), CMD_LINE(OPT_ARG),\n       DEFAULT(FALSE), NO_MUTEX_GUARD,\n       NOT_IN_BINLOG, ON_CHECK(check_gtid_ignore_duplicates),\n       ON_UPDATE(fix_gtid_ignore_duplicates));\n#endif\n\n\nstatic Sys_var_ulong Sys_binlog_commit_wait_count(\n       \"binlog_commit_wait_count\",\n       \"If non-zero, binlog write will wait at most binlog_commit_wait_usec \"\n       \"microseconds for at least this many commits to queue up for group \"\n       \"commit to the binlog. This can reduce I/O on the binlog and provide \"\n       \"increased opportunity for parallel apply on the slave, but too high \"\n       \"a value will decrease commit throughput.\",\n       GLOBAL_VAR(opt_binlog_commit_wait_count), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, ULONG_MAX), DEFAULT(0), BLOCK_SIZE(1));\n\n\nstatic Sys_var_ulong Sys_binlog_commit_wait_usec(\n       \"binlog_commit_wait_usec\",\n       \"Maximum time, in microseconds, to wait for more commits to queue up \"\n       \"for binlog group commit. Only takes effect if the value of \"\n       \"binlog_commit_wait_count is non-zero.\",\n       GLOBAL_VAR(opt_binlog_commit_wait_usec), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, ULONG_MAX), DEFAULT(100000), BLOCK_SIZE(1));\n\n\nstatic bool fix_max_join_size(sys_var *self, THD *thd, enum_var_type type)\n{\n  SV *sv= type == OPT_GLOBAL ? &global_system_variables : &thd->variables;\n  if (sv->max_join_size == HA_POS_ERROR)\n    sv->option_bits|= OPTION_BIG_SELECTS;\n  else\n    sv->option_bits&= ~OPTION_BIG_SELECTS;\n  return false;\n}\nstatic Sys_var_harows Sys_max_join_size(\n       \"max_join_size\",\n       \"Joins that are probably going to read more than max_join_size \"\n       \"records return an error\",\n       SESSION_VAR(max_join_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, HA_POS_ERROR), DEFAULT(HA_POS_ERROR), BLOCK_SIZE(1),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_max_join_size));\n\nstatic Sys_var_ulong Sys_max_seeks_for_key(\n       \"max_seeks_for_key\",\n       \"Limit assumed max number of seeks when looking up rows based on a key\",\n       SESSION_VAR(max_seeks_for_key), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, UINT_MAX), DEFAULT(UINT_MAX), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_max_length_for_sort_data(\n       \"max_length_for_sort_data\",\n       \"Max number of bytes in sorted records\",\n       SESSION_VAR(max_length_for_sort_data), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(4, 8192*1024L), DEFAULT(1024), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_max_long_data_size(\n       \"max_long_data_size\",\n       \"The maximum BLOB length to send to server from \"\n       \"mysql_send_long_data API. Deprecated option; \"\n       \"use max_allowed_packet instead.\",\n       READ_ONLY GLOBAL_VAR(max_long_data_size),\n       CMD_LINE(REQUIRED_ARG, OPT_MAX_LONG_DATA_SIZE),\n       VALID_RANGE(1024, UINT_MAX32), DEFAULT(1024*1024),\n       BLOCK_SIZE(1), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(0), ON_UPDATE(0),\n       DEPRECATED(\"'@@max_allowed_packet'\"));\n\nstatic PolyLock_mutex PLock_prepared_stmt_count(&LOCK_prepared_stmt_count);\nstatic Sys_var_uint Sys_max_prepared_stmt_count(\n       \"max_prepared_stmt_count\",\n       \"Maximum number of prepared statements in the server\",\n       GLOBAL_VAR(max_prepared_stmt_count), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, UINT_MAX32), DEFAULT(16382), BLOCK_SIZE(1),\n       &PLock_prepared_stmt_count);\n\nstatic Sys_var_ulong Sys_max_recursive_iterations(\n       \"max_recursive_iterations\",\n       \"Maximum number of iterations when executing recursive queries\",\n       SESSION_VAR(max_recursive_iterations), CMD_LINE(OPT_ARG),\n       VALID_RANGE(0, UINT_MAX), DEFAULT(UINT_MAX), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_max_sort_length(\n       \"max_sort_length\",\n       \"The number of bytes to use when sorting BLOB or TEXT values (only \"\n       \"the first max_sort_length bytes of each value are used; the rest \"\n       \"are ignored)\",\n       SESSION_VAR(max_sort_length), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(4, 8192*1024L), DEFAULT(1024), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_max_sp_recursion_depth(\n       \"max_sp_recursion_depth\",\n       \"Maximum stored procedure recursion depth\",\n       SESSION_VAR(max_sp_recursion_depth), CMD_LINE(OPT_ARG),\n       VALID_RANGE(0, 255), DEFAULT(0), BLOCK_SIZE(1));\n\n\nstatic bool if_checking_enabled(sys_var *self, THD *thd,  set_var *var)\n{\n  if (session_readonly(self, thd, var))\n    return true;\n  \n  if (!max_user_connections_checking)\n  {\n    my_error(ER_OPTION_PREVENTS_STATEMENT, MYF(0), \"--max-user-connections=0\");\n    return true;\n  }\n\n  return false;\n}\n// non-standard session_value_ptr() here\nstatic Sys_var_max_user_conn Sys_max_user_connections(\n       \"max_user_connections\",\n       \"The maximum number of active connections for a single user \"\n       \"(0 = no limit)\",\n       SESSION_VAR(max_user_connections), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(-1, INT_MAX), DEFAULT(0), BLOCK_SIZE(1), NO_MUTEX_GUARD,\n       NOT_IN_BINLOG, ON_CHECK(if_checking_enabled));\n\nstatic Sys_var_ulong Sys_max_tmp_tables(\n       \"max_tmp_tables\", \"Unused, will be removed.\",\n       SESSION_VAR(max_tmp_tables), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, UINT_MAX), DEFAULT(32), BLOCK_SIZE(1),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0), ON_UPDATE(0),\n       DEPRECATED(\"\"));\n\nstatic Sys_var_ulong Sys_max_write_lock_count(\n       \"max_write_lock_count\",\n       \"After this many write locks, allow some read locks to run in between\",\n       GLOBAL_VAR(max_write_lock_count), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, UINT_MAX), DEFAULT(UINT_MAX), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_min_examined_row_limit(\n       \"min_examined_row_limit\",\n       \"Don't write queries to slow log that examine fewer rows \"\n       \"than that\",\n       SESSION_VAR(min_examined_row_limit), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, UINT_MAX), DEFAULT(0), BLOCK_SIZE(1));\n\n#ifdef _WIN32\nstatic Sys_var_mybool Sys_named_pipe(\n       \"named_pipe\", \"Enable the named pipe (NT)\",\n       READ_ONLY GLOBAL_VAR(opt_enable_named_pipe), CMD_LINE(OPT_ARG),\n       DEFAULT(FALSE));\n#endif\n\n\nstatic bool check_net_buffer_length(sys_var *self, THD *thd,  set_var *var)\n{\n  longlong val;\n  if (session_readonly(self, thd, var))\n    return true;\n\n  val= var->save_result.ulonglong_value;\n  if (val > (longlong) global_system_variables.max_allowed_packet)\n  {\n    push_warning_printf(thd, Sql_condition::WARN_LEVEL_WARN,\n                        WARN_OPTION_BELOW_LIMIT,\n                        ER_THD(thd, WARN_OPTION_BELOW_LIMIT),\n                        \"max_allowed_packet\", \"net_buffer_length\");\n  }\n  return false;\n}\nstatic Sys_var_ulong Sys_net_buffer_length(\n       \"net_buffer_length\",\n       \"Buffer length for TCP/IP and socket communication\",\n       SESSION_VAR(net_buffer_length), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1024, 1024*1024), DEFAULT(16384), BLOCK_SIZE(1024),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(check_net_buffer_length));\n\nstatic bool fix_net_read_timeout(sys_var *self, THD *thd, enum_var_type type)\n{\n  if (type != OPT_GLOBAL)\n    my_net_set_read_timeout(&thd->net, thd->variables.net_read_timeout);\n  return false;\n}\nstatic Sys_var_ulong Sys_net_read_timeout(\n       \"net_read_timeout\",\n       \"Number of seconds to wait for more data from a connection before \"\n       \"aborting the read\",\n       SESSION_VAR(net_read_timeout), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, LONG_TIMEOUT), DEFAULT(NET_READ_TIMEOUT), BLOCK_SIZE(1),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_net_read_timeout));\n\nstatic bool fix_net_write_timeout(sys_var *self, THD *thd, enum_var_type type)\n{\n  if (type != OPT_GLOBAL)\n    my_net_set_write_timeout(&thd->net, thd->variables.net_write_timeout);\n  return false;\n}\nstatic Sys_var_ulong Sys_net_write_timeout(\n       \"net_write_timeout\",\n       \"Number of seconds to wait for a block to be written to a connection \"\n       \"before aborting the write\",\n       SESSION_VAR(net_write_timeout), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, LONG_TIMEOUT), DEFAULT(NET_WRITE_TIMEOUT), BLOCK_SIZE(1),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_net_write_timeout));\n\nstatic bool fix_net_retry_count(sys_var *self, THD *thd, enum_var_type type)\n{\n  if (type != OPT_GLOBAL)\n    thd->net.retry_count=thd->variables.net_retry_count;\n  return false;\n}\nstatic Sys_var_ulong Sys_net_retry_count(\n       \"net_retry_count\",\n       \"If a read on a communication port is interrupted, retry this \"\n       \"many times before giving up\",\n       SESSION_VAR(net_retry_count), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, UINT_MAX), DEFAULT(MYSQLD_NET_RETRY_COUNT),\n       BLOCK_SIZE(1), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_net_retry_count));\n\nstatic Sys_var_mybool Sys_old_mode(\n       \"old\", \"Use compatible behavior from previous MariaDB version. See also --old-mode\",\n       SESSION_VAR(old_mode), CMD_LINE(OPT_ARG), DEFAULT(FALSE));\n\nstatic const char *alter_algorithm_modes[]= {\"DEFAULT\", \"COPY\", \"INPLACE\",\n\"NOCOPY\", \"INSTANT\", NULL};\n\nstatic Sys_var_enum Sys_alter_algorithm(\n\t\"alter_algorithm\", \"Specify the alter table algorithm\",\n\tSESSION_VAR(alter_algorithm), CMD_LINE(OPT_ARG),\n\talter_algorithm_modes, DEFAULT(0));\n\nstatic Sys_var_enum Sys_old_alter_table(\n       \"old_alter_table\", \"Alias for alter_algorithm. \"\n       \"Deprecated. Use --alter-algorithm instead.\",\n       SESSION_VAR(alter_algorithm), CMD_LINE(OPT_ARG),\n       alter_algorithm_modes, DEFAULT(0));\n\nstatic bool check_old_passwords(sys_var *self, THD *thd, set_var *var)\n{\n  return mysql_user_table_is_in_short_password_format;\n}\nstatic Sys_var_mybool Sys_old_passwords(\n       \"old_passwords\",\n       \"Use old password encryption method (needed for 4.0 and older clients)\",\n       SESSION_VAR(old_passwords), CMD_LINE(OPT_ARG),\n       DEFAULT(FALSE), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(check_old_passwords));\nexport sys_var *Sys_old_passwords_ptr= &Sys_old_passwords; // for sql_acl.cc\n\nstatic Sys_var_ulong Sys_open_files_limit(\n       \"open_files_limit\",\n       \"If this is not 0, then mysqld will use this value to reserve file \"\n       \"descriptors to use with setrlimit(). If this value is 0 or autoset \"\n       \"then mysqld will reserve max_connections*5 or max_connections + \"\n       \"table_cache*2 (whichever is larger) number of file descriptors\",\n       AUTO_SET READ_ONLY GLOBAL_VAR(open_files_limit), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, OS_FILE_LIMIT), DEFAULT(0), BLOCK_SIZE(1));\n\n/// @todo change to enum\nstatic Sys_var_ulong Sys_optimizer_prune_level(\n       \"optimizer_prune_level\",\n       \"Controls the heuristic(s) applied during query optimization to prune \"\n       \"less-promising partial plans from the optimizer search space. \"\n       \"Meaning: 0 - do not apply any heuristic, thus perform exhaustive \"\n       \"search; 1 - prune plans based on number of retrieved rows\",\n       SESSION_VAR(optimizer_prune_level), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, 1), DEFAULT(1), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_optimizer_selectivity_sampling_limit(\n       \"optimizer_selectivity_sampling_limit\",\n       \"Controls number of record samples to check condition selectivity\",\n       SESSION_VAR(optimizer_selectivity_sampling_limit),\n       CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(SELECTIVITY_SAMPLING_THRESHOLD, UINT_MAX),\n       DEFAULT(SELECTIVITY_SAMPLING_LIMIT), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_optimizer_use_condition_selectivity(\n       \"optimizer_use_condition_selectivity\",\n       \"Controls selectivity of which conditions the optimizer takes into \"\n       \"account to calculate cardinality of a partial join when it searches \"\n       \"for the best execution plan \"\n       \"Meaning: \"\n       \"1 - use selectivity of index backed range conditions to calculate \"\n       \"the cardinality of a partial join if the last joined table is \"\n       \"accessed by full table scan or an index scan, \"\n       \"2 - use selectivity of index backed range conditions to calculate \"\n       \"the cardinality of a partial join in any case, \"\n       \"3 - additionally always use selectivity of range conditions that are \"\n       \"not backed by any index to calculate the cardinality of a partial join, \"\n       \"4 - use histograms to calculate selectivity of range conditions that \"\n       \"are not backed by any index to calculate the cardinality of \"\n       \"a partial join.\"\n       \"5 - additionally use selectivity of certain non-range predicates \"\n       \"calculated on record samples\",\n       SESSION_VAR(optimizer_use_condition_selectivity), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, 5), DEFAULT(4), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_optimizer_search_depth(\n       \"optimizer_search_depth\",\n       \"Maximum depth of search performed by the query optimizer. Values \"\n       \"larger than the number of relations in a query result in better \"\n       \"query plans, but take longer to compile a query. Values smaller \"\n       \"than the number of tables in a relation result in faster \"\n       \"optimization, but may produce very bad query plans. If set to 0, \"\n       \"the system will automatically pick a reasonable value.\",\n       SESSION_VAR(optimizer_search_depth), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, MAX_TABLES+1), DEFAULT(MAX_TABLES+1), BLOCK_SIZE(1));\n\n/* this is used in the sigsegv handler */\nexport const char *optimizer_switch_names[]=\n{\n  \"index_merge\",\"index_merge_union\",\"index_merge_sort_union\",\n  \"index_merge_intersection\",\"index_merge_sort_intersection\",\n  \"engine_condition_pushdown\",\n  \"index_condition_pushdown\",\n  \"derived_merge\", \"derived_with_keys\",\n  \"firstmatch\",\"loosescan\",\"materialization\",\"in_to_exists\",\"semijoin\",\n  \"partial_match_rowid_merge\",\n  \"partial_match_table_scan\",\n  \"subquery_cache\",\n  \"mrr\",\n  \"mrr_cost_based\",\n  \"mrr_sort_keys\",\n  \"outer_join_with_cache\",\n  \"semijoin_with_cache\",\n  \"join_cache_incremental\",\n  \"join_cache_hashed\",\n  \"join_cache_bka\",\n  \"optimize_join_buffer_size\",\n  \"table_elimination\",\n  \"extended_keys\",\n  \"exists_to_in\",\n  \"orderby_uses_equalities\",\n  \"condition_pushdown_for_derived\",\n  \"split_materialized\",\n  \"condition_pushdown_for_subquery\",\n  \"rowid_filter\",\n  \"condition_pushdown_from_having\",\n  \"default\", \n  NullS\n};\nstatic bool fix_optimizer_switch(sys_var *self, THD *thd,\n                                 enum_var_type type)\n{\n  SV *sv= (type == OPT_GLOBAL) ? &global_system_variables : &thd->variables;\n  if (sv->optimizer_switch & deprecated_ENGINE_CONDITION_PUSHDOWN)\n    push_warning_printf(current_thd, Sql_condition::WARN_LEVEL_WARN,\n                        ER_WARN_DEPRECATED_SYNTAX_NO_REPLACEMENT,\n                        ER_THD(thd, ER_WARN_DEPRECATED_SYNTAX_NO_REPLACEMENT),\n                        \"engine_condition_pushdown=on\");\n  return false;\n}\nstatic Sys_var_flagset Sys_optimizer_switch(\n       \"optimizer_switch\",\n       \"Fine-tune the optimizer behavior\",\n       SESSION_VAR(optimizer_switch), CMD_LINE(REQUIRED_ARG),\n       optimizer_switch_names, DEFAULT(OPTIMIZER_SWITCH_DEFAULT),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_optimizer_switch));\n\nstatic Sys_var_flagset Sys_optimizer_trace(\n    \"optimizer_trace\",\n    \"Controls tracing of the Optimizer:\"\n    \" optimizer_trace=option=val[,option=val...], where option is one of\"\n    \" {enabled}\"\n    \" and val is one of {on, off, default}\",\n    SESSION_VAR(optimizer_trace), CMD_LINE(REQUIRED_ARG),\n    Opt_trace_context::flag_names, DEFAULT(Opt_trace_context::FLAG_DEFAULT));\n    // @see set_var::is_var_optimizer_trace()\nexport sys_var *Sys_optimizer_trace_ptr = &Sys_optimizer_trace;\n\nstatic Sys_var_ulong Sys_optimizer_trace_max_mem_size(\n    \"optimizer_trace_max_mem_size\",\n    \"Maximum allowed size of an optimizer trace\",\n    SESSION_VAR(optimizer_trace_max_mem_size), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(0, ULONG_MAX), DEFAULT(1024 * 1024), BLOCK_SIZE(1));\n\nstatic Sys_var_charptr Sys_pid_file(\n       \"pid_file\", \"Pid file used by safe_mysqld\",\n       READ_ONLY GLOBAL_VAR(pidfile_name_ptr), CMD_LINE(REQUIRED_ARG),\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic Sys_var_charptr Sys_plugin_dir(\n       \"plugin_dir\", \"Directory for plugins\",\n       READ_ONLY GLOBAL_VAR(opt_plugin_dir_ptr), CMD_LINE(REQUIRED_ARG),\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic Sys_var_uint Sys_port(\n       \"port\",\n       \"Port number to use for connection or 0 to default to, \"\n       \"my.cnf, $MYSQL_TCP_PORT, \"\n#if MYSQL_PORT_DEFAULT == 0\n       \"/etc/services, \"\n#endif\n       \"built-in default (\" STRINGIFY_ARG(MYSQL_PORT) \"), whatever comes first\",\n       READ_ONLY GLOBAL_VAR(mysqld_port), CMD_LINE(REQUIRED_ARG, 'P'),\n       VALID_RANGE(0, UINT_MAX32), DEFAULT(0), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_preload_buff_size(\n       \"preload_buffer_size\",\n       \"The size of the buffer that is allocated when preloading indexes\",\n       SESSION_VAR(preload_buff_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1024, 1024*1024*1024), DEFAULT(32768), BLOCK_SIZE(1));\n\nstatic Sys_var_uint Sys_protocol_version(\n       \"protocol_version\",\n       \"The version of the client/server protocol used by the MariaDB server\",\n       READ_ONLY GLOBAL_VAR(protocol_version), CMD_LINE_HELP_ONLY,\n       VALID_RANGE(0, ~0U), DEFAULT(PROTOCOL_VERSION), BLOCK_SIZE(1));\n\nstatic Sys_var_proxy_user Sys_proxy_user(\n       \"proxy_user\", \"The proxy user account name used when logging in\",\n       IN_SYSTEM_CHARSET);\n\nstatic Sys_var_external_user Sys_exterenal_user(\n       \"external_user\", \"The external user account used when logging in\",\n       IN_SYSTEM_CHARSET);\n\nstatic Sys_var_ulong Sys_read_buff_size(\n       \"read_buffer_size\",\n       \"Each thread that does a sequential scan allocates a buffer of \"\n       \"this size for each table it scans. If you do many sequential scans, \"\n       \"you may want to increase this value\",\n       SESSION_VAR(read_buff_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(IO_SIZE*2, INT_MAX32), DEFAULT(128*1024),\n       BLOCK_SIZE(IO_SIZE));\n\nstatic bool check_read_only(sys_var *self, THD *thd, set_var *var)\n{\n  /* Prevent self dead-lock */\n  if (thd->locked_tables_mode || thd->in_active_multi_stmt_transaction() ||\n      thd->current_backup_stage != BACKUP_FINISHED)\n  {\n    my_error(ER_LOCK_OR_ACTIVE_TRANSACTION, MYF(0));\n    return true;\n  }\n  return false;\n}\n\nstatic bool fix_read_only(sys_var *self, THD *thd, enum_var_type type)\n{\n  bool result= true;\n  my_bool new_read_only= read_only; // make a copy before releasing a mutex\n  DBUG_ENTER(\"sys_var_opt_readonly::update\");\n\n  if (read_only == FALSE || read_only == opt_readonly)\n  {\n    opt_readonly= read_only;\n    DBUG_RETURN(false);\n  }\n\n  if (check_read_only(self, thd, 0)) // just in case\n    goto end;\n\n  if (thd->global_read_lock.is_acquired())\n  {\n    /*\n      This connection already holds the global read lock.\n      This can be the case with:\n      - FLUSH TABLES WITH READ LOCK\n      - SET GLOBAL READ_ONLY = 1\n    */\n    opt_readonly= read_only;\n    DBUG_RETURN(false);\n  }\n\n  /*\n    READ_ONLY=1 prevents write locks from being taken on tables and\n    blocks transactions from committing. We therefore should make sure\n    that no such events occur while setting the read_only variable.\n    This is a 2 step process:\n    [1] lock_global_read_lock()\n      Prevents connections from obtaining new write locks on\n      tables. Note that we can still have active rw transactions.\n    [2] make_global_read_lock_block_commit()\n      Prevents transactions from committing.\n  */\n\n  read_only= opt_readonly;\n  mysql_mutex_unlock(&LOCK_global_system_variables);\n\n  if (thd->global_read_lock.lock_global_read_lock(thd))\n    goto end_with_mutex_unlock;\n\n  if ((result= thd->global_read_lock.make_global_read_lock_block_commit(thd)))\n    goto end_with_read_lock;\n\n  /* Change the opt_readonly system variable, safe because the lock is held */\n  opt_readonly= new_read_only;\n  result= false;\n\n end_with_read_lock:\n  /* Release the lock */\n  thd->global_read_lock.unlock_global_read_lock(thd);\n end_with_mutex_unlock:\n  mysql_mutex_lock(&LOCK_global_system_variables);\n end:\n  read_only= opt_readonly;\n  DBUG_RETURN(result);\n}\n\n\n/**\n  The read_only boolean is always equal to the opt_readonly boolean except\n  during fix_read_only(); when that function is entered, opt_readonly is\n  the pre-update value and read_only is the post-update value.\n  fix_read_only() compares them and runs needed operations for the\n  transition (especially when transitioning from false to true) and\n  synchronizes both booleans in the end.\n*/\nstatic Sys_var_mybool Sys_readonly(\n       \"read_only\",\n       \"Make all non-temporary tables read-only, with the exception for \"\n       \"replication (slave) threads and users with the SUPER privilege\",\n       GLOBAL_VAR(read_only), CMD_LINE(OPT_ARG), DEFAULT(FALSE),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(check_read_only), ON_UPDATE(fix_read_only));\n\n// Small lower limit to be able to test MRR\nstatic Sys_var_ulong Sys_read_rnd_buff_size(\n       \"read_rnd_buffer_size\",\n       \"When reading rows in sorted order after a sort, the rows are read \"\n       \"through this buffer to avoid a disk seeks\",\n       SESSION_VAR(read_rnd_buff_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, INT_MAX32), DEFAULT(256*1024), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_div_precincrement(\n       \"div_precision_increment\", \"Precision of the result of '/' \"\n       \"operator will be increased on that value\",\n       SESSION_VAR(div_precincrement), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, DECIMAL_MAX_SCALE), DEFAULT(4), BLOCK_SIZE(1));\n\nstatic Sys_var_uint Sys_eq_range_index_dive_limit(\n       \"eq_range_index_dive_limit\",\n       \"The optimizer will use existing index statistics instead of \"\n       \"doing index dives for equality ranges if the number of equality \"\n       \"ranges for the index is larger than or equal to this number. \"\n       \"If set to 0, index dives are always used.\",\n       SESSION_VAR(eq_range_index_dive_limit), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, UINT_MAX32), DEFAULT(200),\n       BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_range_alloc_block_size(\n       \"range_alloc_block_size\",\n       \"Allocation block size for storing ranges during optimization\",\n       SESSION_VAR(range_alloc_block_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(RANGE_ALLOC_BLOCK_SIZE, UINT_MAX),\n       DEFAULT(RANGE_ALLOC_BLOCK_SIZE), BLOCK_SIZE(1024));\n\nstatic Sys_var_ulong Sys_multi_range_count(\n       \"multi_range_count\", \"Ignored. Use mrr_buffer_size instead\",\n       SESSION_VAR(multi_range_count), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, ULONG_MAX), DEFAULT(256), BLOCK_SIZE(1),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0), ON_UPDATE(0),\n       DEPRECATED(\"'@@mrr_buffer_size'\"));\n\nstatic bool fix_thd_mem_root(sys_var *self, THD *thd, enum_var_type type)\n{\n  if (type != OPT_GLOBAL)\n    reset_root_defaults(thd->mem_root,\n                        thd->variables.query_alloc_block_size,\n                        thd->variables.query_prealloc_size);\n  return false;\n}\nstatic Sys_var_ulong Sys_query_alloc_block_size(\n       \"query_alloc_block_size\",\n       \"Allocation block size for query parsing and execution\",\n       SESSION_VAR(query_alloc_block_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1024, UINT_MAX), DEFAULT(QUERY_ALLOC_BLOCK_SIZE),\n       BLOCK_SIZE(1024), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_thd_mem_root));\n\nstatic Sys_var_ulong Sys_query_prealloc_size(\n       \"query_prealloc_size\",\n       \"Persistent buffer for query parsing and execution\",\n       SESSION_VAR(query_prealloc_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1024, UINT_MAX),\n       DEFAULT(QUERY_ALLOC_PREALLOC_SIZE),\n       BLOCK_SIZE(1024), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_thd_mem_root));\n\n\n// this has to be NO_CMD_LINE as the command-line option has a different name\nstatic Sys_var_mybool Sys_skip_external_locking(\n       \"skip_external_locking\", \"Don't use system (external) locking\",\n       READ_ONLY GLOBAL_VAR(my_disable_locking), NO_CMD_LINE, DEFAULT(TRUE));\n\nstatic Sys_var_mybool Sys_skip_networking(\n       \"skip_networking\", \"Don't allow connection with TCP/IP\",\n       READ_ONLY GLOBAL_VAR(opt_disable_networking), CMD_LINE(OPT_ARG),\n       DEFAULT(FALSE));\n\nstatic Sys_var_mybool Sys_skip_name_resolve(\n       \"skip_name_resolve\",\n       \"Don't resolve hostnames. All hostnames are IP's or 'localhost'.\",\n       READ_ONLY GLOBAL_VAR(opt_skip_name_resolve),\n       CMD_LINE(OPT_ARG, OPT_SKIP_RESOLVE),\n       DEFAULT(FALSE));\n\nstatic Sys_var_mybool Sys_skip_show_database(\n       \"skip_show_database\", \"Don't allow 'SHOW DATABASE' commands\",\n       READ_ONLY GLOBAL_VAR(opt_skip_show_db), CMD_LINE(OPT_ARG),\n       DEFAULT(FALSE));\n\nstatic Sys_var_charptr Sys_socket(\n       \"socket\", \"Socket file to use for connection\",\n       READ_ONLY GLOBAL_VAR(mysqld_unix_port), CMD_LINE(REQUIRED_ARG),\n       IN_FS_CHARSET, DEFAULT(0));\n\n/* \n  thread_concurrency is a no-op on all platforms since\n  MySQL 5.1.  It will be removed in the context of\n  WL#5265\n*/\nstatic Sys_var_ulong Sys_thread_concurrency(\n       \"thread_concurrency\",\n       \"Permits the application to give the threads system a hint for \"\n       \"the desired number of threads that should be run at the same time.\"\n       \"This variable has no effect, and is deprecated. \"\n       \"It will be removed in a future release.\",\n       READ_ONLY GLOBAL_VAR(concurrency),\n       CMD_LINE(REQUIRED_ARG, OPT_THREAD_CONCURRENCY),\n       VALID_RANGE(1, 512), DEFAULT(DEFAULT_CONCURRENCY), BLOCK_SIZE(1),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0), ON_UPDATE(0),\n       DEPRECATED(\"\"));\n\nstatic Sys_var_ulonglong Sys_thread_stack(\n       \"thread_stack\", \"The stack size for each thread\",\n       READ_ONLY GLOBAL_VAR(my_thread_stack_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(128*1024, ULONGLONG_MAX), DEFAULT(DEFAULT_THREAD_STACK),\n       BLOCK_SIZE(1024));\n\nstatic Sys_var_charptr Sys_tmpdir(\n       \"tmpdir\", \"Path for temporary files. Several paths may \"\n       \"be specified, separated by a \"\n#if defined(__WIN__)\n       \"semicolon (;)\"\n#else\n       \"colon (:)\"\n#endif\n       \", in this case they are used in a round-robin fashion\",\n       READ_ONLY GLOBAL_VAR(opt_mysql_tmpdir), CMD_LINE(REQUIRED_ARG, 't'),\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic bool fix_trans_mem_root(sys_var *self, THD *thd, enum_var_type type)\n{\n  if (type != OPT_GLOBAL)\n    reset_root_defaults(&thd->transaction.mem_root,\n                        thd->variables.trans_alloc_block_size,\n                        thd->variables.trans_prealloc_size);\n  return false;\n}\nstatic Sys_var_ulong Sys_trans_alloc_block_size(\n       \"transaction_alloc_block_size\",\n       \"Allocation block size for transactions to be stored in binary log\",\n       SESSION_VAR(trans_alloc_block_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1024, 128 * 1024 * 1024), DEFAULT(TRANS_ALLOC_BLOCK_SIZE),\n       BLOCK_SIZE(1024), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_trans_mem_root));\n\nstatic Sys_var_ulong Sys_trans_prealloc_size(\n       \"transaction_prealloc_size\",\n       \"Persistent buffer for transactions to be stored in binary log\",\n       SESSION_VAR(trans_prealloc_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1024, 128 * 1024 * 1024), DEFAULT(TRANS_ALLOC_PREALLOC_SIZE),\n       BLOCK_SIZE(1024), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_trans_mem_root));\n\nstatic const char *thread_handling_names[]=\n{\n  \"one-thread-per-connection\", \"no-threads\",\n#ifdef HAVE_POOL_OF_THREADS\n  \"pool-of-threads\",\n#endif\n  0\n};\n\n#if defined (_WIN32) && defined (HAVE_POOL_OF_THREADS)\n/* Windows is using OS threadpool, so we're pretty sure it works well */\n#define DEFAULT_THREAD_HANDLING 2\n#else\n#define DEFAULT_THREAD_HANDLING 0\n#endif\n\nstatic Sys_var_enum Sys_thread_handling(\n       \"thread_handling\",\n       \"Define threads usage for handling queries\",\n       READ_ONLY GLOBAL_VAR(thread_handling), CMD_LINE(REQUIRED_ARG),\n       thread_handling_names, \n       DEFAULT(DEFAULT_THREAD_HANDLING)\n );\n\n#ifdef HAVE_QUERY_CACHE\nstatic bool fix_query_cache_size(sys_var *self, THD *thd, enum_var_type type)\n{\n  size_t new_cache_size= query_cache.resize((size_t)query_cache_size);\n  /*\n     Note: query_cache_size is a global variable reflecting the\n     requested cache size. See also query_cache_size_arg\n  */\n  if (query_cache_size != new_cache_size)\n    push_warning_printf(current_thd, Sql_condition::WARN_LEVEL_WARN,\n                        ER_WARN_QC_RESIZE, ER_THD(thd, ER_WARN_QC_RESIZE),\n                        query_cache_size, (ulong)new_cache_size);\n\n  query_cache_size= new_cache_size;\n\n  return false;\n}\n\nstatic bool fix_query_cache_limit(sys_var *self, THD *thd, enum_var_type type)\n{\n  query_cache.result_size_limit(query_cache_limit);\n  return false;\n}\nstatic Sys_var_ulonglong Sys_query_cache_size(\n       \"query_cache_size\",\n       \"The memory allocated to store results from old queries\",\n       GLOBAL_VAR(query_cache_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, ULONG_MAX), DEFAULT(1024*1024), BLOCK_SIZE(1024),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, NULL,\n       ON_UPDATE(fix_query_cache_size));\n\nstatic Sys_var_ulong Sys_query_cache_limit(\n       \"query_cache_limit\",\n       \"Don't cache results that are bigger than this\",\n       GLOBAL_VAR(query_cache_limit), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, UINT_MAX), DEFAULT(1024*1024), BLOCK_SIZE(1),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_query_cache_limit));\n\nstatic bool fix_qcache_min_res_unit(sys_var *self, THD *thd, enum_var_type type)\n{\n  query_cache_min_res_unit=\n    (ulong)query_cache.set_min_res_unit(query_cache_min_res_unit);\n  return false;\n}\nstatic Sys_var_ulong Sys_query_cache_min_res_unit(\n       \"query_cache_min_res_unit\",\n       \"The minimum size for blocks allocated by the query cache\",\n       GLOBAL_VAR(query_cache_min_res_unit), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, UINT_MAX), DEFAULT(QUERY_CACHE_MIN_RESULT_DATA_SIZE),\n       BLOCK_SIZE(8), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_qcache_min_res_unit));\n\nstatic const char *query_cache_type_names[]= { \"OFF\", \"ON\", \"DEMAND\", 0 };\n\nstatic bool check_query_cache_type(sys_var *self, THD *thd, set_var *var)\n{\n  if (query_cache.is_disable_in_progress())\n  {\n    my_error(ER_QUERY_CACHE_IS_DISABLED, MYF(0));\n    return true;\n  }\n\n  if (var->type != OPT_GLOBAL && global_system_variables.query_cache_type == 0)\n  {\n    if (var->value)\n    {\n      if (var->save_result.ulonglong_value != 0)\n      {\n        my_error(ER_QUERY_CACHE_IS_GLOBALY_DISABLED, MYF(0));\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\n\nstatic bool fix_query_cache_type(sys_var *self, THD *thd, enum_var_type type)\n{\n  if (type != OPT_GLOBAL)\n    return false;\n\n  if (global_system_variables.query_cache_type != 0 &&\n      query_cache.is_disabled())\n  {\n    /* if disabling in progress variable will not be set */\n    DBUG_ASSERT(!query_cache.is_disable_in_progress());\n    /* Enable query cache because it was disabled */\n    fix_query_cache_size(0, thd, type);\n  }\n  else if (global_system_variables.query_cache_type == 0)\n    query_cache.disable_query_cache(thd);\n  return false;\n}\nstatic Sys_var_enum Sys_query_cache_type(\n       \"query_cache_type\",\n       \"OFF = Don't cache or retrieve results. ON = Cache all results \"\n       \"except SELECT SQL_NO_CACHE ... queries. DEMAND = Cache only \"\n       \"SELECT SQL_CACHE ... queries\",\n       NO_SET_STMT SESSION_VAR(query_cache_type), CMD_LINE(REQUIRED_ARG),\n       query_cache_type_names, DEFAULT(0), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(check_query_cache_type),\n       ON_UPDATE(fix_query_cache_type));\n\nstatic Sys_var_mybool Sys_query_cache_wlock_invalidate(\n       \"query_cache_wlock_invalidate\",\n       \"Invalidate queries in query cache on LOCK for write\",\n       SESSION_VAR(query_cache_wlock_invalidate), CMD_LINE(OPT_ARG),\n       DEFAULT(FALSE));\n#endif /* HAVE_QUERY_CACHE */\n\nstatic Sys_var_mybool Sys_secure_auth(\n       \"secure_auth\",\n       \"Disallow authentication for accounts that have old (pre-4.1) \"\n       \"passwords\",\n       GLOBAL_VAR(opt_secure_auth), CMD_LINE(OPT_ARG),\n       DEFAULT(TRUE));\n\nstatic Sys_var_charptr Sys_secure_file_priv(\n       \"secure_file_priv\",\n       \"Limit LOAD DATA, SELECT ... OUTFILE, and LOAD_FILE() to files \"\n       \"within specified directory\",\n       PREALLOCATED READ_ONLY GLOBAL_VAR(opt_secure_file_priv),\n       CMD_LINE(REQUIRED_ARG), IN_FS_CHARSET, DEFAULT(0));\n\nstatic bool fix_server_id(sys_var *self, THD *thd, enum_var_type type)\n{\n  if (type == OPT_GLOBAL)\n  {\n    thd->variables.server_id= global_system_variables.server_id;\n    /*\n      Historically, server_id was a global variable that is exported to\n      plugins. Now it is a session variable, and lives in the\n      global_system_variables struct, but we still need to export the\n      value for reading to plugins for backwards compatibility reasons.\n    */\n    ::server_id= global_system_variables.server_id;\n  }\n  return false;\n}\nstatic Sys_var_ulong Sys_server_id(\n       \"server_id\",\n       \"Uniquely identifies the server instance in the community of \"\n       \"replication partners\",\n       SESSION_VAR(server_id), CMD_LINE(REQUIRED_ARG, OPT_SERVER_ID),\n       VALID_RANGE(1, UINT_MAX32), DEFAULT(1), BLOCK_SIZE(1), NO_MUTEX_GUARD,\n       NOT_IN_BINLOG, ON_CHECK(check_has_super), ON_UPDATE(fix_server_id));\n\nstatic Sys_var_mybool Sys_slave_compressed_protocol(\n       \"slave_compressed_protocol\",\n       \"Use compression on master/slave protocol\",\n       GLOBAL_VAR(opt_slave_compressed_protocol), CMD_LINE(OPT_ARG),\n       DEFAULT(FALSE));\n\n#ifdef HAVE_REPLICATION\nstatic const char *slave_exec_mode_names[]= {\"STRICT\", \"IDEMPOTENT\", 0};\nstatic Sys_var_enum Slave_exec_mode(\n       \"slave_exec_mode\",\n       \"How replication events should be executed. Legal values \"\n       \"are STRICT (default) and IDEMPOTENT. In IDEMPOTENT mode, \"\n       \"replication will not stop for operations that are idempotent. \"\n       \"For example, in row based replication attempts to delete rows that \"\n       \"doesn't exist will be ignored. \"\n       \"In STRICT mode, replication will stop on any unexpected difference \"\n       \"between the master and the slave.\",\n       GLOBAL_VAR(slave_exec_mode_options), CMD_LINE(REQUIRED_ARG),\n       slave_exec_mode_names, DEFAULT(SLAVE_EXEC_MODE_STRICT));\n\nstatic Sys_var_enum Slave_ddl_exec_mode(\n       \"slave_ddl_exec_mode\",\n       \"How replication events should be executed. Legal values \"\n       \"are STRICT and IDEMPOTENT (default). In IDEMPOTENT mode, \"\n       \"replication will not stop for DDL operations that are idempotent. \"\n       \"This means that CREATE TABLE is treated as CREATE TABLE OR REPLACE and \"\n       \"DROP TABLE is treated as DROP TABLE IF EXISTS.\",\n       GLOBAL_VAR(slave_ddl_exec_mode_options), CMD_LINE(REQUIRED_ARG),\n       slave_exec_mode_names, DEFAULT(SLAVE_EXEC_MODE_IDEMPOTENT));\n\nstatic const char *slave_run_triggers_for_rbr_names[]=\n  {\"NO\", \"YES\", \"LOGGING\", 0};\nstatic Sys_var_enum Slave_run_triggers_for_rbr(\n       \"slave_run_triggers_for_rbr\",\n       \"Modes for how triggers in row-base replication on slave side will be \"\n       \"executed. Legal values are NO (default), YES and LOGGING. NO means \"\n       \"that trigger for RBR will not be running on slave. YES and LOGGING \"\n       \"means that triggers will be running on slave, if there was not \"\n       \"triggers running on the master for the statement. LOGGING also means \"\n       \"results of that the executed triggers work will be written to \"\n       \"the binlog.\",\n       GLOBAL_VAR(slave_run_triggers_for_rbr), CMD_LINE(REQUIRED_ARG),\n       slave_run_triggers_for_rbr_names,\n       DEFAULT(SLAVE_RUN_TRIGGERS_FOR_RBR_NO));\n\nstatic const char *slave_type_conversions_name[]= {\"ALL_LOSSY\", \"ALL_NON_LOSSY\", 0};\nstatic Sys_var_set Slave_type_conversions(\n       \"slave_type_conversions\",\n       \"Set of slave type conversions that are enabled.\"\n       \" If the variable is empty, no conversions are\"\n       \" allowed and it is expected that the types match exactly\",\n       GLOBAL_VAR(slave_type_conversions_options), CMD_LINE(REQUIRED_ARG),\n       slave_type_conversions_name,\n       DEFAULT(0));\n\nstatic Sys_var_mybool Sys_slave_sql_verify_checksum(\n       \"slave_sql_verify_checksum\",\n       \"Force checksum verification of replication events after reading them \"\n       \"from relay log. Note: Events are always checksum-verified by slave on \"\n       \"receiving them from the network before writing them to the relay log\",\n       GLOBAL_VAR(opt_slave_sql_verify_checksum), CMD_LINE(OPT_ARG),\n       DEFAULT(TRUE));\n\nstatic Sys_var_mybool Sys_master_verify_checksum(\n       \"master_verify_checksum\",\n       \"Force checksum verification of logged events in the binary log before \"\n       \"sending them to slaves or printing them in the output of \"\n       \"SHOW BINLOG EVENTS\",\n       GLOBAL_VAR(opt_master_verify_checksum), CMD_LINE(OPT_ARG),\n       DEFAULT(FALSE));\n\n/* These names must match RPL_SKIP_XXX #defines in slave.h. */\nstatic const char *replicate_events_marked_for_skip_names[]= {\n  \"REPLICATE\", \"FILTER_ON_SLAVE\", \"FILTER_ON_MASTER\", 0\n};\n\nbool\nSys_var_replicate_events_marked_for_skip::global_update(THD *thd, set_var *var)\n{\n  bool result= true;                            // Assume error\n  DBUG_ENTER(\"Sys_var_replicate_events_marked_for_skip::global_update\");\n\n  mysql_mutex_unlock(&LOCK_global_system_variables);\n  if (!give_error_if_slave_running(0))\n    result= Sys_var_enum::global_update(thd, var);\n  mysql_mutex_lock(&LOCK_global_system_variables);\n  DBUG_RETURN(result);\n}\n\nstatic Sys_var_replicate_events_marked_for_skip Replicate_events_marked_for_skip\n   (\"replicate_events_marked_for_skip\",\n   \"Whether the slave should replicate events that were created with \"\n   \"@@skip_replication=1 on the master. Default REPLICATE (no events are \"\n   \"skipped). Other values are FILTER_ON_SLAVE (events will be sent by the \"\n   \"master but ignored by the slave) and FILTER_ON_MASTER (events marked with \"\n   \"@@skip_replication=1 will be filtered on the master and never be sent to \"\n   \"the slave).\",\n   GLOBAL_VAR(opt_replicate_events_marked_for_skip), CMD_LINE(REQUIRED_ARG),\n   replicate_events_marked_for_skip_names, DEFAULT(RPL_SKIP_REPLICATE));\n\n/* new options for semisync */\n\nstatic bool fix_rpl_semi_sync_master_enabled(sys_var *self, THD *thd,\n                                             enum_var_type type)\n{\n  mysql_mutex_unlock(&LOCK_global_system_variables);\n  mysql_mutex_lock(&repl_semisync_master.LOCK_rpl_semi_sync_master_enabled);\n  if (rpl_semi_sync_master_enabled)\n  {\n    if (repl_semisync_master.enable_master() != 0)\n      rpl_semi_sync_master_enabled= false;\n    else if (ack_receiver.start())\n    {\n      repl_semisync_master.disable_master();\n      rpl_semi_sync_master_enabled= false;\n    }\n  }\n  else\n  {\n    repl_semisync_master.disable_master();\n    ack_receiver.stop();\n  }\n  mysql_mutex_unlock(&repl_semisync_master.LOCK_rpl_semi_sync_master_enabled);\n  mysql_mutex_lock(&LOCK_global_system_variables);\n  return false;\n}\n\nstatic bool fix_rpl_semi_sync_master_timeout(sys_var *self, THD *thd,\n                                             enum_var_type type)\n{\n  repl_semisync_master.set_wait_timeout(rpl_semi_sync_master_timeout);\n  return false;\n}\n\nstatic bool fix_rpl_semi_sync_master_trace_level(sys_var *self, THD *thd,\n                                                 enum_var_type type)\n{\n  repl_semisync_master.set_trace_level(rpl_semi_sync_master_trace_level);\n  ack_receiver.set_trace_level(rpl_semi_sync_master_trace_level);\n  return false;\n}\n\nstatic bool fix_rpl_semi_sync_master_wait_point(sys_var *self, THD *thd,\n                                                enum_var_type type)\n{\n  repl_semisync_master.set_wait_point(rpl_semi_sync_master_wait_point);\n  return false;\n}\n\nstatic bool fix_rpl_semi_sync_master_wait_no_slave(sys_var *self, THD *thd,\n                                                   enum_var_type type)\n{\n  repl_semisync_master.check_and_switch();\n  return false;\n}\n\nstatic Sys_var_mybool Sys_semisync_master_enabled(\n       \"rpl_semi_sync_master_enabled\",\n       \"Enable semi-synchronous replication master (disabled by default).\",\n       GLOBAL_VAR(rpl_semi_sync_master_enabled),\n       CMD_LINE(OPT_ARG), DEFAULT(FALSE),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_rpl_semi_sync_master_enabled));\n\nstatic Sys_var_ulong Sys_semisync_master_timeout(\n       \"rpl_semi_sync_master_timeout\",\n       \"The timeout value (in ms) for semi-synchronous replication in the \"\n       \"master\",\n       GLOBAL_VAR(rpl_semi_sync_master_timeout),\n       CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0,~0L),DEFAULT(10000),BLOCK_SIZE(1),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_rpl_semi_sync_master_timeout));\n\nstatic Sys_var_mybool Sys_semisync_master_wait_no_slave(\n       \"rpl_semi_sync_master_wait_no_slave\",\n       \"Wait until timeout when no semi-synchronous replication slave \"\n       \"available (enabled by default).\",\n       GLOBAL_VAR(rpl_semi_sync_master_wait_no_slave),\n       CMD_LINE(OPT_ARG), DEFAULT(TRUE),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_rpl_semi_sync_master_wait_no_slave));\n\nstatic Sys_var_ulong Sys_semisync_master_trace_level(\n       \"rpl_semi_sync_master_trace_level\",\n       \"The tracing level for semi-sync replication.\",\n       GLOBAL_VAR(rpl_semi_sync_master_trace_level),\n       CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0,~0L),DEFAULT(32),BLOCK_SIZE(1),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_rpl_semi_sync_master_trace_level));\n\nstatic const char *repl_semisync_wait_point[]=\n{\"AFTER_SYNC\", \"AFTER_COMMIT\", NullS};\n\nstatic Sys_var_enum Sys_semisync_master_wait_point(\n       \"rpl_semi_sync_master_wait_point\",\n       \"Should transaction wait for semi-sync ack after having synced binlog, \"\n       \"or after having committed in storage engine.\",\n       GLOBAL_VAR(rpl_semi_sync_master_wait_point), CMD_LINE(REQUIRED_ARG),\n       repl_semisync_wait_point, DEFAULT(1),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG,ON_CHECK(0),\n       ON_UPDATE(fix_rpl_semi_sync_master_wait_point));\n\nstatic bool fix_rpl_semi_sync_slave_enabled(sys_var *self, THD *thd,\n                                            enum_var_type type)\n{\n  repl_semisync_slave.set_slave_enabled(rpl_semi_sync_slave_enabled != 0);\n  return false;\n}\n\nstatic bool fix_rpl_semi_sync_slave_trace_level(sys_var *self, THD *thd,\n                                                enum_var_type type)\n{\n  repl_semisync_slave.set_trace_level(rpl_semi_sync_slave_trace_level);\n  return false;\n}\n\nstatic bool fix_rpl_semi_sync_slave_delay_master(sys_var *self, THD *thd,\n                                                 enum_var_type type)\n{\n  repl_semisync_slave.set_delay_master(rpl_semi_sync_slave_delay_master);\n  return false;\n}\n\nstatic bool fix_rpl_semi_sync_slave_kill_conn_timeout(sys_var *self, THD *thd,\n                                                      enum_var_type type)\n{\n  repl_semisync_slave.\n    set_kill_conn_timeout(rpl_semi_sync_slave_kill_conn_timeout);\n  return false;\n}\n\nstatic Sys_var_mybool Sys_semisync_slave_enabled(\n       \"rpl_semi_sync_slave_enabled\",\n       \"Enable semi-synchronous replication slave (disabled by default).\",\n       GLOBAL_VAR(rpl_semi_sync_slave_enabled),\n       CMD_LINE(OPT_ARG), DEFAULT(FALSE),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_rpl_semi_sync_slave_enabled));\n\nstatic Sys_var_ulong Sys_semisync_slave_trace_level(\n       \"rpl_semi_sync_slave_trace_level\",\n       \"The tracing level for semi-sync replication.\",\n       GLOBAL_VAR(rpl_semi_sync_slave_trace_level),\n       CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0,~0L),DEFAULT(32),BLOCK_SIZE(1),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_rpl_semi_sync_slave_trace_level));\n\nstatic Sys_var_mybool Sys_semisync_slave_delay_master(\n       \"rpl_semi_sync_slave_delay_master\",\n       \"Only write master info file when ack is needed.\",\n       GLOBAL_VAR(rpl_semi_sync_slave_delay_master),\n       CMD_LINE(OPT_ARG), DEFAULT(FALSE),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_rpl_semi_sync_slave_delay_master));\n\nstatic Sys_var_uint  Sys_semisync_slave_kill_conn_timeout(\n       \"rpl_semi_sync_slave_kill_conn_timeout\",\n       \"Timeout for the mysql connection used to kill the slave io_thread's \"\n       \"connection on master. This timeout comes into play when stop slave \"\n       \"is executed.\",\n       GLOBAL_VAR(rpl_semi_sync_slave_kill_conn_timeout),\n       CMD_LINE(OPT_ARG),\n       VALID_RANGE(0, UINT_MAX), DEFAULT(5), BLOCK_SIZE(1),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_rpl_semi_sync_slave_kill_conn_timeout));\n#endif /* HAVE_REPLICATION */\n\nstatic Sys_var_ulong Sys_slow_launch_time(\n       \"slow_launch_time\",\n       \"If creating the thread takes longer than this value (in seconds), \"\n       \"the Slow_launch_threads counter will be incremented\",\n       GLOBAL_VAR(slow_launch_time), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, LONG_TIMEOUT), DEFAULT(2), BLOCK_SIZE(1));\n\nstatic Sys_var_ulonglong Sys_sort_buffer(\n       \"sort_buffer_size\",\n       \"Each thread that needs to do a sort allocates a buffer of this size\",\n       SESSION_VAR(sortbuff_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(MIN_SORT_MEMORY, SIZE_T_MAX), DEFAULT(MAX_SORT_MEMORY),\n       BLOCK_SIZE(1));\n\nexport sql_mode_t expand_sql_mode(sql_mode_t sql_mode)\n{\n  if (sql_mode & MODE_ANSI)\n  {\n    /*\n      Note that we dont set\n      MODE_NO_KEY_OPTIONS | MODE_NO_TABLE_OPTIONS | MODE_NO_FIELD_OPTIONS\n      to allow one to get full use of MySQL in this mode.\n\n      MODE_ONLY_FULL_GROUP_BY was removed from ANSI mode because it is\n      currently overly restrictive (see BUG#8510).\n    */\n    sql_mode|= (MODE_REAL_AS_FLOAT | MODE_PIPES_AS_CONCAT | MODE_ANSI_QUOTES |\n                MODE_IGNORE_SPACE);\n  }\n  if (sql_mode & MODE_ORACLE)\n    sql_mode|= (MODE_PIPES_AS_CONCAT | MODE_ANSI_QUOTES |\n                MODE_IGNORE_SPACE |\n                MODE_NO_KEY_OPTIONS | MODE_NO_TABLE_OPTIONS |\n                MODE_NO_FIELD_OPTIONS | MODE_NO_AUTO_CREATE_USER |\n                MODE_SIMULTANEOUS_ASSIGNMENT);\n  if (sql_mode & MODE_MSSQL)\n    sql_mode|= (MODE_PIPES_AS_CONCAT | MODE_ANSI_QUOTES |\n                MODE_IGNORE_SPACE |\n                MODE_NO_KEY_OPTIONS | MODE_NO_TABLE_OPTIONS |\n                MODE_NO_FIELD_OPTIONS);\n  if (sql_mode & MODE_POSTGRESQL)\n    sql_mode|= (MODE_PIPES_AS_CONCAT | MODE_ANSI_QUOTES |\n                MODE_IGNORE_SPACE |\n                MODE_NO_KEY_OPTIONS | MODE_NO_TABLE_OPTIONS |\n                MODE_NO_FIELD_OPTIONS);\n  if (sql_mode & MODE_DB2)\n    sql_mode|= (MODE_PIPES_AS_CONCAT | MODE_ANSI_QUOTES |\n                MODE_IGNORE_SPACE |\n                MODE_NO_KEY_OPTIONS | MODE_NO_TABLE_OPTIONS |\n                MODE_NO_FIELD_OPTIONS);\n  if (sql_mode & MODE_MAXDB)\n    sql_mode|= (MODE_PIPES_AS_CONCAT | MODE_ANSI_QUOTES |\n                MODE_IGNORE_SPACE |\n                MODE_NO_KEY_OPTIONS | MODE_NO_TABLE_OPTIONS |\n                MODE_NO_FIELD_OPTIONS | MODE_NO_AUTO_CREATE_USER);\n  if (sql_mode & MODE_MYSQL40)\n    sql_mode|= MODE_HIGH_NOT_PRECEDENCE;\n  if (sql_mode & MODE_MYSQL323)\n    sql_mode|= MODE_HIGH_NOT_PRECEDENCE;\n  if (sql_mode & MODE_TRADITIONAL)\n    sql_mode|= (MODE_STRICT_TRANS_TABLES | MODE_STRICT_ALL_TABLES |\n                MODE_NO_ZERO_IN_DATE | MODE_NO_ZERO_DATE |\n                MODE_ERROR_FOR_DIVISION_BY_ZERO | MODE_NO_AUTO_CREATE_USER |\n                MODE_NO_ENGINE_SUBSTITUTION);\n  return sql_mode;\n}\nstatic bool check_sql_mode(sys_var *self, THD *thd, set_var *var)\n{\n  var->save_result.ulonglong_value=\n    (ulonglong) expand_sql_mode(var->save_result.ulonglong_value);\n  return false;\n}\nstatic bool fix_sql_mode(sys_var *self, THD *thd, enum_var_type type)\n{\n  if (type != OPT_GLOBAL)\n  {\n    /* Update thd->server_status */\n    if (thd->variables.sql_mode & MODE_NO_BACKSLASH_ESCAPES)\n      thd->server_status|= SERVER_STATUS_NO_BACKSLASH_ESCAPES;\n    else\n      thd->server_status&= ~SERVER_STATUS_NO_BACKSLASH_ESCAPES;\n    if (thd->variables.sql_mode & MODE_ANSI_QUOTES)\n      thd->server_status|= SERVER_STATUS_ANSI_QUOTES;\n    else\n      thd->server_status&= ~SERVER_STATUS_ANSI_QUOTES;\n  }\n  return false;\n}\n/*\n  WARNING: When adding new SQL modes don't forget to update the\n  tables definitions that stores it's value (ie: mysql.event, mysql.proc)\n*/\nstatic const char *sql_mode_names[]=\n{\n  \"REAL_AS_FLOAT\", \"PIPES_AS_CONCAT\", \"ANSI_QUOTES\", \"IGNORE_SPACE\",\n  \"IGNORE_BAD_TABLE_OPTIONS\",\n  \"ONLY_FULL_GROUP_BY\", \"NO_UNSIGNED_SUBTRACTION\", \"NO_DIR_IN_CREATE\",\n  \"POSTGRESQL\", \"ORACLE\", \"MSSQL\", \"DB2\", \"MAXDB\", \"NO_KEY_OPTIONS\",\n  \"NO_TABLE_OPTIONS\", \"NO_FIELD_OPTIONS\", \"MYSQL323\", \"MYSQL40\", \"ANSI\",\n  \"NO_AUTO_VALUE_ON_ZERO\", \"NO_BACKSLASH_ESCAPES\", \"STRICT_TRANS_TABLES\",\n  \"STRICT_ALL_TABLES\", \"NO_ZERO_IN_DATE\", \"NO_ZERO_DATE\",\n  \"ALLOW_INVALID_DATES\", \"ERROR_FOR_DIVISION_BY_ZERO\", \"TRADITIONAL\",\n  \"NO_AUTO_CREATE_USER\", \"HIGH_NOT_PRECEDENCE\", \"NO_ENGINE_SUBSTITUTION\",\n  \"PAD_CHAR_TO_FULL_LENGTH\", \"EMPTY_STRING_IS_NULL\", \"SIMULTANEOUS_ASSIGNMENT\",\n  \"TIME_ROUND_FRACTIONAL\",\n  0\n};\n\n\nconst char *sql_mode_string_representation(uint bit_number)\n{\n  DBUG_ASSERT(bit_number < array_elements(sql_mode_names));\n  return sql_mode_names[bit_number];\n}\n\n\nexport bool sql_mode_string_representation(THD *thd, sql_mode_t sql_mode,\n                                           LEX_CSTRING *ls)\n{\n  set_to_string(thd, ls, sql_mode, sql_mode_names);\n  return ls->str == 0;\n}\n/*\n  sql_mode should *not* be IN_BINLOG: even though it is written to the binlog,\n  the slave ignores the MODE_NO_DIR_IN_CREATE variable, so slave's value\n  differs from master's (see log_event.cc: Query_log_event::do_apply_event()).\n*/\nstatic Sys_var_set Sys_sql_mode(\n       \"sql_mode\",\n       \"Sets the sql mode\",\n       SESSION_VAR(sql_mode), CMD_LINE(REQUIRED_ARG),\n       sql_mode_names,\n       DEFAULT(MODE_STRICT_TRANS_TABLES |\n               MODE_ERROR_FOR_DIVISION_BY_ZERO |\n               MODE_NO_ENGINE_SUBSTITUTION |\n               MODE_NO_AUTO_CREATE_USER),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(check_sql_mode), ON_UPDATE(fix_sql_mode));\n\nstatic const char *old_mode_names[]=\n{\n  \"NO_DUP_KEY_WARNINGS_WITH_IGNORE\",\n  \"NO_PROGRESS_INFO\",\n  \"ZERO_DATE_TIME_CAST\",\n  0\n};\n\n/*\n  sql_mode should *not* be IN_BINLOG as the slave can't remember this\n  anyway on restart.\n*/\nstatic Sys_var_set Sys_old_behavior(\n       \"old_mode\",\n       \"Used to emulate old behavior from earlier MariaDB or MySQL versions\",\n       SESSION_VAR(old_behavior), CMD_LINE(REQUIRED_ARG),\n       old_mode_names, DEFAULT(0));\n\n#if defined(HAVE_OPENSSL) && !defined(EMBEDDED_LIBRARY)\n#define SSL_OPT(X) CMD_LINE(REQUIRED_ARG,X)\n#else\n#define SSL_OPT(X) NO_CMD_LINE\n#endif\n\nstatic Sys_var_charptr Sys_ssl_ca(\n       \"ssl_ca\",\n       \"CA file in PEM format (check OpenSSL docs, implies --ssl)\",\n       READ_ONLY GLOBAL_VAR(opt_ssl_ca), SSL_OPT(OPT_SSL_CA),\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic Sys_var_charptr Sys_ssl_capath(\n       \"ssl_capath\",\n       \"CA directory (check OpenSSL docs, implies --ssl)\",\n       READ_ONLY GLOBAL_VAR(opt_ssl_capath), SSL_OPT(OPT_SSL_CAPATH),\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic Sys_var_charptr Sys_ssl_cert(\n       \"ssl_cert\", \"X509 cert in PEM format (implies --ssl)\",\n       READ_ONLY GLOBAL_VAR(opt_ssl_cert), SSL_OPT(OPT_SSL_CERT),\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic Sys_var_charptr Sys_ssl_cipher(\n       \"ssl_cipher\", \"SSL cipher to use (implies --ssl)\",\n       READ_ONLY GLOBAL_VAR(opt_ssl_cipher), SSL_OPT(OPT_SSL_CIPHER),\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic Sys_var_charptr Sys_ssl_key(\n       \"ssl_key\", \"X509 key in PEM format (implies --ssl)\",\n       READ_ONLY GLOBAL_VAR(opt_ssl_key), SSL_OPT(OPT_SSL_KEY),\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic Sys_var_charptr Sys_ssl_crl(\n       \"ssl_crl\",\n       \"CRL file in PEM format (check OpenSSL docs, implies --ssl)\",\n       READ_ONLY GLOBAL_VAR(opt_ssl_crl), SSL_OPT(OPT_SSL_CRL),\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic Sys_var_charptr Sys_ssl_crlpath(\n       \"ssl_crlpath\",\n       \"CRL directory (check OpenSSL docs, implies --ssl)\",\n       READ_ONLY GLOBAL_VAR(opt_ssl_crlpath), SSL_OPT(OPT_SSL_CRLPATH),\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic const char *tls_version_names[]=\n{\n  \"TLSv1.0\",\n  \"TLSv1.1\",\n  \"TLSv1.2\",\n  \"TLSv1.3\",\n  0\n};\n\nexport bool tls_version_string_representation(THD *thd, sql_mode_t sql_mode,\n                                              LEX_CSTRING *ls)\n{\n  set_to_string(thd, ls, tls_version, tls_version_names);\n  return ls->str == 0;\n}\n\nstatic Sys_var_set Sys_tls_version(\n       \"tls_version\",\n       \"TLS protocol version for secure connections.\",\n       READ_ONLY GLOBAL_VAR(tls_version), CMD_LINE(REQUIRED_ARG),\n       tls_version_names,\n       DEFAULT(VIO_TLSv1_1 | VIO_TLSv1_2 | VIO_TLSv1_3));\n\nstatic Sys_var_mybool Sys_standard_compliant_cte(\n       \"standard_compliant_cte\",\n       \"Allow only CTEs compliant to SQL standard\",\n       SESSION_VAR(only_standard_compliant_cte), CMD_LINE(OPT_ARG),\n       DEFAULT(TRUE));\n\n\n// why ENUM and not BOOL ?\nstatic const char *updatable_views_with_limit_names[]= {\"NO\", \"YES\", 0};\nstatic Sys_var_enum Sys_updatable_views_with_limit(\n       \"updatable_views_with_limit\",\n       \"YES = Don't issue an error message (warning only) if a VIEW without \"\n       \"presence of a key of the underlying table is used in queries with a \"\n       \"LIMIT clause for updating. NO = Prohibit update of a VIEW, which \"\n       \"does not contain a key of the underlying table and the query uses \"\n       \"a LIMIT clause (usually get from GUI tools)\",\n       SESSION_VAR(updatable_views_with_limit), CMD_LINE(REQUIRED_ARG),\n       updatable_views_with_limit_names, DEFAULT(TRUE));\n\nstatic Sys_var_mybool Sys_sync_frm(\n       \"sync_frm\", \"Sync .frm files to disk on creation\",\n       GLOBAL_VAR(opt_sync_frm), CMD_LINE(OPT_ARG),\n       DEFAULT(TRUE));\n\nstatic char *system_time_zone_ptr;\nstatic Sys_var_charptr Sys_system_time_zone(\n       \"system_time_zone\", \"The server system time zone\",\n       READ_ONLY GLOBAL_VAR(system_time_zone_ptr),\n       CMD_LINE_HELP_ONLY,\n       IN_SYSTEM_CHARSET, DEFAULT(system_time_zone));\n\n/*\n  If One use views with prepared statements this should be bigger than\n  table_open_cache (now we allow 2 times bigger value)\n*/\nstatic Sys_var_ulong Sys_table_def_size(\n       \"table_definition_cache\",\n       \"The number of cached table definitions\",\n       GLOBAL_VAR(tdc_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(TABLE_DEF_CACHE_MIN, 2*1024*1024),\n       DEFAULT(TABLE_DEF_CACHE_DEFAULT), BLOCK_SIZE(1));\n\n\nstatic bool fix_table_open_cache(sys_var *, THD *, enum_var_type)\n{\n  mysql_mutex_unlock(&LOCK_global_system_variables);\n  tc_purge();\n  mysql_mutex_lock(&LOCK_global_system_variables);\n  return false;\n}\n\n/* Check the table_definition_cache comment if makes changes */\nstatic Sys_var_ulong Sys_table_cache_size(\n       \"table_open_cache\", \"The number of cached open tables\",\n       GLOBAL_VAR(tc_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(10, 1024*1024), DEFAULT(TABLE_OPEN_CACHE_DEFAULT),\n       BLOCK_SIZE(1), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_table_open_cache));\n\nstatic Sys_var_uint Sys_table_cache_instances(\n       \"table_open_cache_instances\", \"Maximum number of table cache instances\",\n       READ_ONLY GLOBAL_VAR(tc_instances), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, 64), DEFAULT(8), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_thread_cache_size(\n       \"thread_cache_size\",\n       \"How many threads we should keep in a cache for reuse. These are freed after 5 minutes of idle time\",\n       GLOBAL_VAR(thread_cache_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, 16384), DEFAULT(256), BLOCK_SIZE(1));\n\n#ifdef HAVE_POOL_OF_THREADS\nstatic bool fix_tp_max_threads(sys_var *, THD *, enum_var_type)\n{\n  tp_set_max_threads(threadpool_max_threads);\n  return false;\n}\n\n\n#ifdef _WIN32\nstatic bool fix_tp_min_threads(sys_var *, THD *, enum_var_type)\n{\n  tp_set_min_threads(threadpool_min_threads);\n  return false;\n}\n#endif\n\nstatic bool check_threadpool_size(sys_var *self, THD *thd, set_var *var)\n{\n  ulonglong v= var->save_result.ulonglong_value;\n  if (v > threadpool_max_size)\n  {\n    var->save_result.ulonglong_value= threadpool_max_size;\n    return throw_bounds_warning(thd, self->name.str, true, true, v);\n  }\n  return false;\n}\n\n\nstatic bool fix_threadpool_size(sys_var*, THD*, enum_var_type)\n{\n  tp_set_threadpool_size(threadpool_size);\n  return false;\n}\n\n\nstatic bool fix_threadpool_stall_limit(sys_var*, THD*, enum_var_type)\n{\n  tp_set_threadpool_stall_limit(threadpool_stall_limit);\n  return false;\n}\n\n#ifdef _WIN32\nstatic Sys_var_uint Sys_threadpool_min_threads(\n  \"thread_pool_min_threads\",\n  \"Minimum number of threads in the thread pool.\",\n  GLOBAL_VAR(threadpool_min_threads), CMD_LINE(REQUIRED_ARG),\n  VALID_RANGE(1, 256), DEFAULT(1), BLOCK_SIZE(1),\n  NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n  ON_UPDATE(fix_tp_min_threads)\n  );\n\nstatic const char *threadpool_mode_names[]={ \"windows\", \"generic\", 0 };\nstatic Sys_var_enum Sys_threadpool_mode(\n  \"thread_pool_mode\",\n  \"Chose implementation of the threadpool\",\n  READ_ONLY GLOBAL_VAR(threadpool_mode), CMD_LINE(REQUIRED_ARG),\n  threadpool_mode_names, DEFAULT(TP_MODE_WINDOWS)\n  );\n#endif\n\nstatic const char *threadpool_priority_names[]={ \"high\", \"low\", \"auto\", 0 };\nstatic Sys_var_enum Sys_thread_pool_priority(\n  \"thread_pool_priority\",\n  \"Threadpool priority. High priority connections usually start executing earlier than low priority.\"\n  \"If priority set to 'auto', the the actual priority(low or high) is determined based on whether or not connection is inside transaction.\",\n  SESSION_VAR(threadpool_priority), CMD_LINE(REQUIRED_ARG),\n  threadpool_priority_names, DEFAULT(TP_PRIORITY_AUTO));\n\nstatic Sys_var_uint Sys_threadpool_idle_thread_timeout(\n  \"thread_pool_idle_timeout\",\n  \"Timeout in seconds for an idle thread in the thread pool.\"\n  \"Worker thread will be shut down after timeout\",\n  GLOBAL_VAR(threadpool_idle_timeout), CMD_LINE(REQUIRED_ARG),\n  VALID_RANGE(1, UINT_MAX), DEFAULT(60), BLOCK_SIZE(1)\n);\nstatic Sys_var_uint Sys_threadpool_oversubscribe(\n  \"thread_pool_oversubscribe\",\n  \"How many additional active worker threads in a group are allowed.\",\n  GLOBAL_VAR(threadpool_oversubscribe), CMD_LINE(REQUIRED_ARG),\n  VALID_RANGE(1, 1000), DEFAULT(3), BLOCK_SIZE(1)\n);\nstatic Sys_var_uint Sys_threadpool_size(\n \"thread_pool_size\",\n \"Number of thread groups in the pool. \"\n \"This parameter is roughly equivalent to maximum number of concurrently \"\n \"executing threads (threads in a waiting state do not count as executing).\",\n  GLOBAL_VAR(threadpool_size), CMD_LINE(REQUIRED_ARG),\n  VALID_RANGE(1, MAX_THREAD_GROUPS), DEFAULT(8), BLOCK_SIZE(1),\n  NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(check_threadpool_size),\n  ON_UPDATE(fix_threadpool_size)\n);\nstatic Sys_var_uint Sys_threadpool_stall_limit(\n \"thread_pool_stall_limit\",\n \"Maximum query execution time in milliseconds,\"\n \"before an executing non-yielding thread is considered stalled.\"\n \"If a worker thread is stalled, additional worker thread \"\n \"may be created to handle remaining clients.\",\n  GLOBAL_VAR(threadpool_stall_limit), CMD_LINE(REQUIRED_ARG),\n  VALID_RANGE(10, UINT_MAX), DEFAULT(500), BLOCK_SIZE(1),\n  NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0), \n  ON_UPDATE(fix_threadpool_stall_limit)\n);\n\nstatic Sys_var_uint Sys_threadpool_max_threads(\n  \"thread_pool_max_threads\",\n  \"Maximum allowed number of worker threads in the thread pool\",\n   GLOBAL_VAR(threadpool_max_threads), CMD_LINE(REQUIRED_ARG),\n   VALID_RANGE(1, 65536), DEFAULT(65536), BLOCK_SIZE(1),\n   NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0), \n   ON_UPDATE(fix_tp_max_threads)\n);\n\nstatic Sys_var_uint Sys_threadpool_threadpool_prio_kickup_timer(\n \"thread_pool_prio_kickup_timer\",\n \"The number of milliseconds before a dequeued low-priority statement is moved to the high-priority queue\",\n  GLOBAL_VAR(threadpool_prio_kickup_timer), CMD_LINE(REQUIRED_ARG),\n  VALID_RANGE(0, UINT_MAX), DEFAULT(1000), BLOCK_SIZE(1)\n);\n#endif /* HAVE_POOL_OF_THREADS */\n\n/**\n  Can't change the 'next' tx_isolation if we are already in a\n  transaction.\n*/\n\nstatic bool check_tx_isolation(sys_var *self, THD *thd, set_var *var)\n{\n  if (var->type == OPT_DEFAULT && thd->in_active_multi_stmt_transaction())\n  {\n    DBUG_ASSERT(thd->in_multi_stmt_transaction_mode());\n    my_error(ER_CANT_CHANGE_TX_CHARACTERISTICS, MYF(0));\n    return TRUE;\n  }\n  return FALSE;\n}\n\n// NO_CMD_LINE - different name of the option\nstatic Sys_var_tx_isolation Sys_tx_isolation(\n       \"tx_isolation\", \"Default transaction isolation level\",\n       NO_SET_STMT SESSION_VAR(tx_isolation), NO_CMD_LINE,\n       tx_isolation_names, DEFAULT(ISO_REPEATABLE_READ),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(check_tx_isolation));\n\n\n/**\n  Can't change the tx_read_only state if we are already in a\n  transaction.\n*/\n\nstatic bool check_tx_read_only(sys_var *self, THD *thd, set_var *var)\n{\n  if (var->type == OPT_DEFAULT && thd->in_active_multi_stmt_transaction())\n  {\n    DBUG_ASSERT(thd->in_multi_stmt_transaction_mode());\n    my_error(ER_CANT_CHANGE_TX_CHARACTERISTICS, MYF(0));\n    return true;\n  }\n  return false;\n}\n\n\nbool Sys_var_tx_read_only::session_update(THD *thd, set_var *var)\n{\n  if (var->type == OPT_SESSION && Sys_var_mybool::session_update(thd, var))\n    return true;\n  if (var->type == OPT_DEFAULT || !thd->in_active_multi_stmt_transaction())\n  {\n    // @see Sys_var_tx_isolation::session_update() above for the rules.\n    thd->tx_read_only= var->save_result.ulonglong_value;\n\n#ifndef EMBEDDED_LIBRARY\n    if (thd->variables.session_track_transaction_info > TX_TRACK_NONE)\n    {\n      if (var->type == OPT_DEFAULT)\n        thd->session_tracker.transaction_info.set_read_flags(thd,\n                            thd->tx_read_only ? TX_READ_ONLY : TX_READ_WRITE);\n      else\n        thd->session_tracker.transaction_info.set_read_flags(thd,\n                            TX_READ_INHERIT);\n    }\n#endif //EMBEDDED_LIBRARY\n  }\n  return false;\n}\n\n\nstatic Sys_var_tx_read_only Sys_tx_read_only(\n       \"tx_read_only\", \"Default transaction access mode. If set to OFF, \"\n       \"the default, access is read/write. If set to ON, access is read-only. \"\n       \"The SET TRANSACTION statement can also change the value of this variable. \"\n       \"See SET TRANSACTION and START TRANSACTION.\",\n       SESSION_VAR(tx_read_only), NO_CMD_LINE, DEFAULT(0),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(check_tx_read_only));\n\nstatic Sys_var_ulonglong Sys_tmp_table_size(\n       \"tmp_table_size\",\n       \"Alias for tmp_memory_table_size. \"\n       \"If an internal in-memory temporary table exceeds this size, MariaDB \"\n       \"will automatically convert it to an on-disk MyISAM or Aria table.\",\n       SESSION_VAR(tmp_memory_table_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1024, (ulonglong)~(intptr)0), DEFAULT(16*1024*1024),\n       BLOCK_SIZE(1));\n\nstatic Sys_var_ulonglong Sys_tmp_memory_table_size(\n       \"tmp_memory_table_size\",\n       \"If an internal in-memory temporary table exceeds this size, MariaDB \"\n       \"will automatically convert it to an on-disk MyISAM or Aria table. \"\n       \"Same as tmp_table_size.\",\n       SESSION_VAR(tmp_memory_table_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1024, (ulonglong)~(intptr)0), DEFAULT(16*1024*1024),\n       BLOCK_SIZE(1));\n\nstatic Sys_var_ulonglong Sys_tmp_disk_table_size(\n       \"tmp_disk_table_size\",\n       \"Max size for data for an internal temporary on-disk MyISAM or Aria table.\",\n       SESSION_VAR(tmp_disk_table_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1024, (ulonglong)~(intptr)0),\n       DEFAULT((ulonglong)~(intptr)0),\n       BLOCK_SIZE(1));\n\nstatic Sys_var_mybool Sys_timed_mutexes(\n       \"timed_mutexes\",\n       \"Specify whether to time mutexes. Deprecated, has no effect.\",\n       GLOBAL_VAR(timed_mutexes), CMD_LINE(OPT_ARG), DEFAULT(0),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0), ON_UPDATE(0),\n       DEPRECATED(\"\"));\n\nstatic Sys_var_charptr Sys_version(\n       \"version\", \"Server version number. It may also include a suffix \"\n       \"with configuration or build information. -debug indicates \"\n       \"debugging support was enabled on the server, and -log indicates \"\n       \"at least one of the binary log, general log or slow query log are \"\n       \"enabled, for example 10.1.1-MariaDB-mariadb1precise-log.\",\n       READ_ONLY GLOBAL_VAR(server_version_ptr),\n       CMD_LINE_HELP_ONLY,\n       IN_SYSTEM_CHARSET, DEFAULT(server_version));\n\nstatic char *server_version_comment_ptr;\nstatic Sys_var_charptr Sys_version_comment(\n       \"version_comment\", \"Value of the COMPILATION_COMMENT option \"\n       \"specified by CMake when building MariaDB, for example \"\n       \"mariadb.org binary distribution.\",\n       READ_ONLY GLOBAL_VAR(server_version_comment_ptr),\n       CMD_LINE_HELP_ONLY,\n       IN_SYSTEM_CHARSET, DEFAULT(MYSQL_COMPILATION_COMMENT));\n\nstatic char *server_version_compile_machine_ptr;\nstatic Sys_var_charptr Sys_version_compile_machine(\n       \"version_compile_machine\", \"The machine type or architecture \"\n       \"MariaDB was built on, for example i686.\",\n       READ_ONLY GLOBAL_VAR(server_version_compile_machine_ptr),\n       CMD_LINE_HELP_ONLY, IN_SYSTEM_CHARSET, DEFAULT(DEFAULT_MACHINE));\n\nstatic char *server_version_compile_os_ptr;\nstatic Sys_var_charptr Sys_version_compile_os(\n       \"version_compile_os\", \"Operating system that MariaDB was built \"\n       \"on, for example debian-linux-gnu.\",\n       READ_ONLY GLOBAL_VAR(server_version_compile_os_ptr),\n       CMD_LINE_HELP_ONLY,\n       IN_SYSTEM_CHARSET, DEFAULT(SYSTEM_TYPE));\n\n#include <source_revision.h>\nstatic char *server_version_source_revision;\nstatic Sys_var_charptr Sys_version_source_revision(\n       \"version_source_revision\", \"Source control revision id for MariaDB source code\",\n       READ_ONLY GLOBAL_VAR(server_version_source_revision),\n       CMD_LINE_HELP_ONLY,\n       IN_SYSTEM_CHARSET, DEFAULT(SOURCE_REVISION));\n\nstatic char *malloc_library;\nstatic Sys_var_charptr Sys_malloc_library(\n       \"version_malloc_library\", \"Version of the used malloc library\",\n       READ_ONLY GLOBAL_VAR(malloc_library), CMD_LINE_HELP_ONLY,\n       IN_SYSTEM_CHARSET, DEFAULT(guess_malloc_library()));\n\nstatic char *ssl_library;\nstatic Sys_var_charptr Sys_ssl_library(\n       \"version_ssl_library\", \"Version of the used SSL library\",\n       READ_ONLY GLOBAL_VAR(ssl_library), CMD_LINE_HELP_ONLY,\n       IN_SYSTEM_CHARSET, DEFAULT(SSL_LIBRARY));\n\nstatic Sys_var_ulong Sys_net_wait_timeout(\n       \"wait_timeout\",\n       \"The number of seconds the server waits for activity on a \"\n       \"connection before closing it\",\n       NO_SET_STMT SESSION_VAR(net_wait_timeout), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, IF_WIN(INT_MAX32/1000, LONG_TIMEOUT)),\n       DEFAULT(NET_WAIT_TIMEOUT), BLOCK_SIZE(1));\n\nstatic Sys_var_uint Sys_idle_transaction_timeout(\n       \"idle_transaction_timeout\",\n       \"The number of seconds the server waits for idle transaction\",\n       SESSION_VAR(idle_transaction_timeout), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, IF_WIN(INT_MAX32/1000, LONG_TIMEOUT)),\n       DEFAULT(0), BLOCK_SIZE(1));\n\nstatic Sys_var_uint Sys_idle_readonly_transaction_timeout(\n       \"idle_readonly_transaction_timeout\",\n       \"The number of seconds the server waits for read-only idle transaction\",\n       SESSION_VAR(idle_readonly_transaction_timeout), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, IF_WIN(INT_MAX32/1000, LONG_TIMEOUT)),\n       DEFAULT(0), BLOCK_SIZE(1));\n\nstatic Sys_var_uint Sys_idle_write_transaction_timeout(\n       \"idle_write_transaction_timeout\",\n       \"The number of seconds the server waits for write idle transaction\",\n       SESSION_VAR(idle_write_transaction_timeout), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, IF_WIN(INT_MAX32/1000, LONG_TIMEOUT)),\n       DEFAULT(0), BLOCK_SIZE(1));\n\nstatic Sys_var_plugin Sys_default_storage_engine(\n       \"default_storage_engine\", \"The default storage engine for new tables\",\n       SESSION_VAR(table_plugin), NO_CMD_LINE,\n       MYSQL_STORAGE_ENGINE_PLUGIN, DEFAULT(&default_storage_engine),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(check_not_null));\n\n//  Alias for @@default_storage_engine\nstatic Sys_var_plugin Sys_storage_engine(\n       \"storage_engine\", \"Alias for @@default_storage_engine. Deprecated\",\n       SESSION_VAR(table_plugin), NO_CMD_LINE,\n       MYSQL_STORAGE_ENGINE_PLUGIN, DEFAULT(&default_storage_engine),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(check_not_null));\n\nstatic Sys_var_plugin Sys_default_tmp_storage_engine(\n       \"default_tmp_storage_engine\", \"The default storage engine for user-created temporary tables\",\n       SESSION_VAR(tmp_table_plugin), NO_CMD_LINE,\n       MYSQL_STORAGE_ENGINE_PLUGIN, DEFAULT(&default_tmp_storage_engine));\n\nstatic Sys_var_plugin Sys_enforce_storage_engine(\n       \"enforce_storage_engine\", \"Force the use of a storage engine for new tables\",\n       SESSION_VAR(enforced_table_plugin),\n       NO_CMD_LINE, MYSQL_STORAGE_ENGINE_PLUGIN,\n       DEFAULT(&enforced_storage_engine), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(check_has_super));\n\n\n#ifdef HAVE_REPLICATION\n/*\n  Check\n   1. Value for gtid_pos_auto_engines is not NULL.\n   2. No slave SQL thread is running.\n*/\nstatic bool\ncheck_gtid_pos_auto_engines(sys_var *self, THD *thd, set_var *var)\n{\n  bool running;\n  bool err= false;\n\n  DBUG_ASSERT(var->type == OPT_GLOBAL);\n  if (var->value && var->value->is_null())\n    err= true;\n  else\n  {\n    running= give_error_if_slave_running(false);\n    if (running)\n      err= true;\n  }\n  return err;\n}\n\n\nstatic Sys_var_pluginlist Sys_gtid_pos_auto_engines(\n       \"gtid_pos_auto_engines\",\n       \"List of engines for which to automatically create a \"\n       \"mysql.gtid_slave_pos_ENGINE table, if a transaction using that engine \"\n       \"is replicated. This can be used to avoid introducing cross-engine \"\n       \"transactions, if engines are used different from that used by table \"\n       \"mysql.gtid_slave_pos\",\n       GLOBAL_VAR(opt_gtid_pos_auto_plugins), NO_CMD_LINE,\n       DEFAULT(&gtid_pos_auto_engines),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(check_gtid_pos_auto_engines));\n#endif\n\n\n#if defined(ENABLED_DEBUG_SYNC)\n/*\n  Variable can be set for the session only.\n\n  This could be changed later. Then we need to have a global array of\n  actions in addition to the thread local ones. SET GLOBAL would\n  manage the global array, SET [SESSION] the local array. A sync point\n  would need to look for a local and a global action. Setting and\n  executing of global actions need to be protected by a mutex.\n\n  The purpose of global actions could be to allow synchronizing with\n  connectionless threads that cannot execute SET statements.\n*/\nstatic Sys_var_debug_sync Sys_debug_sync(\n       \"debug_sync\", \"Debug Sync Facility\",\n       NO_SET_STMT sys_var::ONLY_SESSION, NO_CMD_LINE,\n       DEFAULT(0), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(check_has_super));\n#endif /* defined(ENABLED_DEBUG_SYNC) */\n\n/**\n \"time_format\" \"date_format\" \"datetime_format\"\n\n  the following three variables are unused, and the source of confusion\n  (bug reports like \"I've changed date_format, but date format hasn't changed.\n  I've made them read-only, to alleviate the situation somewhat.\n\n  @todo make them NO_CMD_LINE ?\n*/\nstatic Sys_var_charptr Sys_date_format(\n       \"date_format\", \"The DATE format (ignored)\",\n       READ_ONLY GLOBAL_VAR(global_date_format.format.str),\n       CMD_LINE(REQUIRED_ARG), IN_SYSTEM_CHARSET,\n       DEFAULT(known_date_time_formats[ISO_FORMAT].date_format),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0), ON_UPDATE(0), DEPRECATED(\"\"));\n\nstatic Sys_var_charptr Sys_datetime_format(\n       \"datetime_format\", \"The DATETIME format (ignored)\",\n       READ_ONLY GLOBAL_VAR(global_datetime_format.format.str),\n       CMD_LINE(REQUIRED_ARG), IN_SYSTEM_CHARSET,\n       DEFAULT(known_date_time_formats[ISO_FORMAT].datetime_format),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0), ON_UPDATE(0), DEPRECATED(\"\"));\n\nstatic Sys_var_charptr Sys_time_format(\n       \"time_format\", \"The TIME format (ignored)\",\n       READ_ONLY GLOBAL_VAR(global_time_format.format.str),\n       CMD_LINE(REQUIRED_ARG), IN_SYSTEM_CHARSET,\n       DEFAULT(known_date_time_formats[ISO_FORMAT].time_format),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0), ON_UPDATE(0), DEPRECATED(\"\"));\n\nstatic bool fix_autocommit(sys_var *self, THD *thd, enum_var_type type)\n{\n  if (type == OPT_GLOBAL)\n  {\n    if (global_system_variables.option_bits & OPTION_AUTOCOMMIT)\n      global_system_variables.option_bits&= ~OPTION_NOT_AUTOCOMMIT;\n    else\n      global_system_variables.option_bits|= OPTION_NOT_AUTOCOMMIT;\n    return false;\n  }\n\n  if (test_all_bits(thd->variables.option_bits,\n                    (OPTION_AUTOCOMMIT | OPTION_NOT_AUTOCOMMIT)))\n  {\n    // activating autocommit\n    if (trans_commit_stmt(thd) || trans_commit(thd))\n    {\n      thd->variables.option_bits&= ~OPTION_AUTOCOMMIT;\n      thd->mdl_context.release_transactional_locks();\n      WSREP_DEBUG(\"autocommit, MDL TRX lock released: %lld\",\n                  (longlong) thd->thread_id);\n      return true;\n    }\n    /*\n      Don't close thread tables or release metadata locks: if we do so, we\n      risk releasing locks/closing tables of expressions used to assign\n      other variables, as in:\n      set @var=my_stored_function1(), @@autocommit=1, @var2=(select MY_MAX(a)\n      from my_table), ...\n      The locks will be released at statement end anyway, as SET\n      statement that assigns autocommit is marked to commit\n      transaction implicitly at the end (@sa stmt_causes_implicitcommit()).\n    */\n    thd->variables.option_bits&=\n                 ~(OPTION_BEGIN | OPTION_KEEP_LOG | OPTION_NOT_AUTOCOMMIT |\n                   OPTION_GTID_BEGIN);\n    thd->transaction.all.modified_non_trans_table= false;\n    thd->transaction.all.m_unsafe_rollback_flags&= ~THD_TRANS::DID_WAIT;\n    thd->server_status|= SERVER_STATUS_AUTOCOMMIT;\n    return false;\n  }\n\n  if ((thd->variables.option_bits &\n       (OPTION_AUTOCOMMIT |OPTION_NOT_AUTOCOMMIT)) == 0)\n  {\n    // disabling autocommit\n    thd->transaction.all.modified_non_trans_table= false;\n    thd->transaction.all.m_unsafe_rollback_flags&= ~THD_TRANS::DID_WAIT;\n    thd->server_status&= ~SERVER_STATUS_AUTOCOMMIT;\n    thd->variables.option_bits|= OPTION_NOT_AUTOCOMMIT;\n    return false;\n  }\n\n  return false; // autocommit value wasn't changed\n}\n\nstatic Sys_var_bit Sys_autocommit(\n       \"autocommit\", \"If set to 1, the default, all queries are committed \"\n       \"immediately. If set to 0, they are only committed upon a COMMIT statement\"\n       \", or rolled back with a ROLLBACK statement. If autocommit is set to 0, \"\n       \"and then changed to 1, all open transactions are immediately committed.\",\n       NO_SET_STMT SESSION_VAR(option_bits), NO_CMD_LINE,\n       OPTION_AUTOCOMMIT, DEFAULT(TRUE),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0), ON_UPDATE(fix_autocommit));\nexport sys_var *Sys_autocommit_ptr= &Sys_autocommit; // for sql_yacc.yy\n\nstatic Sys_var_mybool Sys_big_tables(\n       \"big_tables\", \"Old variable, which if set to 1, allows large result sets \"\n       \"by saving all temporary sets to disk, avoiding 'table full' errors. No \"\n       \"longer needed, as the server now handles this automatically. \"\n       \"sql_big_tables is a synonym.\",\n       SESSION_VAR(big_tables), CMD_LINE(OPT_ARG), DEFAULT(FALSE));\n\nstatic Sys_var_bit Sys_big_selects(\n       \"sql_big_selects\", \"If set to 0, MariaDB will not perform large SELECTs.\"\n       \" See max_join_size for details. If max_join_size is set to anything but \"\n       \"DEFAULT, sql_big_selects is automatically set to 0. If sql_big_selects \"\n       \"is again set, max_join_size will be ignored.\",\n       SESSION_VAR(option_bits), NO_CMD_LINE, OPTION_BIG_SELECTS,\n       DEFAULT(FALSE));\n\nstatic Sys_var_bit Sys_log_off(\n       \"sql_log_off\", \"If set to 1 (0 is the default), no logging to the general \"\n       \"query log is done for the client. Only clients with the SUPER privilege \"\n       \"can update this variable.\",\n       NO_SET_STMT SESSION_VAR(option_bits), NO_CMD_LINE, OPTION_LOG_OFF,\n       DEFAULT(FALSE), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(check_has_super));\n\n/**\n  This function sets the session variable thd->variables.sql_log_bin \n  to reflect changes to @@session.sql_log_bin.\n\n  @param[IN] self   A pointer to the sys_var, i.e. Sys_log_binlog.\n  @param[IN] type   The type either session or global.\n\n  @return @c FALSE.\n*/\nstatic bool fix_sql_log_bin_after_update(sys_var *self, THD *thd,\n                                         enum_var_type type)\n{\n  DBUG_ASSERT(type == OPT_SESSION);\n\n  if (thd->variables.sql_log_bin)\n    thd->variables.option_bits |= OPTION_BIN_LOG;\n  else\n    thd->variables.option_bits &= ~OPTION_BIN_LOG;\n\n  return FALSE;\n}\n\nstatic bool check_session_only_variable(sys_var *self, THD *,set_var *var)\n{\n  if (unlikely(var->type == OPT_GLOBAL))\n  {\n    my_error(ER_INCORRECT_GLOBAL_LOCAL_VAR, MYF(0), self->name.str, \"SESSION\");\n    return true;\n  }\n  return false;\n}\n\n/**\n  This function checks if the sql_log_bin can be changed,\n  what is possible if:\n    - the user is a super user;\n    - the set is not called from within a function/trigger;\n    - there is no on-going transaction.\n\n  @param[IN] self   A pointer to the sys_var, i.e. Sys_log_binlog.\n  @param[IN] var    A pointer to the set_var created by the parser.\n\n  @return @c FALSE if the change is allowed, otherwise @c TRUE.\n*/\nstatic bool check_sql_log_bin(sys_var *self, THD *thd, set_var *var)\n{\n  if (check_has_super(self, thd, var))\n    return true;\n\n  if (check_session_only_variable(self, thd, var))\n    return true;\n\n  if (unlikely(error_if_in_trans_or_substatement(thd,\n                                                 ER_STORED_FUNCTION_PREVENTS_SWITCH_SQL_LOG_BIN,\n                                                 ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_SQL_LOG_BIN)))\n    return true;\n\n  return false;\n}\n\nstatic Sys_var_mybool Sys_log_binlog(\t\n       \"sql_log_bin\", \"If set to 0 (1 is the default), no logging to the binary \"\n       \"log is done for the client. Only clients with the SUPER privilege can \"\n       \"update this variable. Can have unintended consequences if set globally, \"\n       \"see SET SQL_LOG_BIN. Starting MariaDB 10.1.7, this variable does not \"\n       \"affect the replication of events in a Galera cluster.\",\n       SESSION_VAR(sql_log_bin), NO_CMD_LINE, DEFAULT(TRUE),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(check_sql_log_bin),\n       ON_UPDATE(fix_sql_log_bin_after_update));\n\nstatic Sys_var_bit Sys_sql_warnings(\n       \"sql_warnings\", \"If set to 1, single-row INSERTs will produce a string \"\n       \"containing warning information if a warning occurs.\",\n       SESSION_VAR(option_bits), NO_CMD_LINE, OPTION_WARNINGS,\n       DEFAULT(FALSE));\n\nstatic Sys_var_bit Sys_sql_notes(\n       \"sql_notes\", \"If set to 1, the default, warning_count is incremented each \"\n       \"time a Note warning is encountered. If set to 0, Note warnings are not \"\n       \"recorded. mysqldump has outputs to set this variable to 0 so that no \"\n       \"unnecessary increments occur when data is reloaded.\",\n       SESSION_VAR(option_bits), NO_CMD_LINE, OPTION_SQL_NOTES,\n       DEFAULT(TRUE));\n\nstatic Sys_var_bit Sys_auto_is_null(\n       \"sql_auto_is_null\", \"If set to 1, the query SELECT * FROM table_name WHERE \"\n       \"auto_increment_column IS NULL will return an auto-increment that has just \"\n       \"been successfully inserted, the same as the LAST_INSERT_ID() function. Some\"\n       \" ODBC programs make use of this IS NULL comparison.\",\n       SESSION_VAR(option_bits), NO_CMD_LINE, OPTION_AUTO_IS_NULL,\n       DEFAULT(FALSE), NO_MUTEX_GUARD, IN_BINLOG);\n\nstatic Sys_var_bit Sys_safe_updates(\n       \"sql_safe_updates\", \"If set to 1, UPDATEs and DELETEs need either a key in \"\n       \"the WHERE clause, or a LIMIT clause, or else they will aborted. Prevents \"\n       \"the common mistake of accidentally deleting or updating every row in a table.\",\n       SESSION_VAR(option_bits), CMD_LINE(OPT_ARG), OPTION_SAFE_UPDATES,\n       DEFAULT(FALSE));\n\nstatic Sys_var_bit Sys_buffer_results(\n       \"sql_buffer_result\", \"If set to 1 (0 is default), results from SELECT \"\n       \"statements are always placed into temporary tables. This can help the \"\n       \"server when it takes a long time to send the results to the client by \"\n       \"allowing the table locks to be freed early.\",\n       SESSION_VAR(option_bits), NO_CMD_LINE, OPTION_BUFFER_RESULT,\n       DEFAULT(FALSE));\n\nstatic Sys_var_bit Sys_quote_show_create(\n       \"sql_quote_show_create\", \"If set to 1, the default, the server will \"\n       \"quote identifiers for SHOW CREATE DATABASE, SHOW CREATE TABLE and \"\n       \"SHOW CREATE VIEW statements. Quoting is disabled if set to 0. Enable \"\n       \"to ensure replications works when identifiers require quoting.\",\n       SESSION_VAR(option_bits), NO_CMD_LINE, OPTION_QUOTE_SHOW_CREATE,\n       DEFAULT(TRUE));\n\nstatic Sys_var_bit Sys_foreign_key_checks(\n       \"foreign_key_checks\", \"If set to 1 (the default) foreign key constraints\"\n       \" (including ON UPDATE and ON DELETE behavior) InnoDB tables are checked,\"\n       \" while if set to 0, they are not checked. 0 is not recommended for normal \"\n       \"use, though it can be useful in situations where you know the data is \"\n       \"consistent, but want to reload data in a different order from that that \"\n       \"specified by parent/child relationships. Setting this variable to 1 does \"\n       \"not retrospectively check for inconsistencies introduced while set to 0.\",\n       SESSION_VAR(option_bits), NO_CMD_LINE,\n       REVERSE(OPTION_NO_FOREIGN_KEY_CHECKS),\n       DEFAULT(TRUE), NO_MUTEX_GUARD, IN_BINLOG);\n\nstatic Sys_var_bit Sys_unique_checks(\n       \"unique_checks\", \"If set to 1, the default, secondary indexes in InnoDB \"\n       \"tables are performed. If set to 0, storage engines can (but are not \"\n       \"required to) assume that duplicate keys are not present in input data. \"\n       \"Set to 0 to speed up imports of large tables to InnoDB. The storage \"\n       \"engine will still issue a duplicate key error if it detects one, even \"\n       \"if set to 0.\",\n       SESSION_VAR(option_bits), NO_CMD_LINE,\n       REVERSE(OPTION_RELAXED_UNIQUE_CHECKS),\n       DEFAULT(TRUE), NO_MUTEX_GUARD, IN_BINLOG);\n\nstatic Sys_var_bit Sys_no_check_constraint(\n       \"check_constraint_checks\", \"check_constraint_checks\",\n       SESSION_VAR(option_bits), NO_CMD_LINE,\n       REVERSE(OPTION_NO_CHECK_CONSTRAINT_CHECKS),\n       DEFAULT(TRUE), NO_MUTEX_GUARD, IN_BINLOG);\n\n#ifdef ENABLED_PROFILING\nstatic bool update_profiling(sys_var *self, THD *thd, enum_var_type type)\n{\n  if (type == OPT_SESSION)\n    thd->profiling.reset();\n  return false;\n}\n\nstatic Sys_var_bit Sys_profiling(\n       \"profiling\", \"If set to 1 (0 is default), statement profiling will be \"\n       \"enabled. See SHOW PROFILES and SHOW PROFILE.\",\n       NO_SET_STMT SESSION_VAR(option_bits), NO_CMD_LINE, OPTION_PROFILING,\n       DEFAULT(FALSE), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(update_profiling));\n\nstatic Sys_var_ulong Sys_profiling_history_size(\n       \"profiling_history_size\", \"Number of statements about which profiling \"\n       \"information is maintained. If set to 0, no profiles are stored. \"\n       \"See SHOW PROFILES.\",\n       NO_SET_STMT SESSION_VAR(profiling_history_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, 100), DEFAULT(15), BLOCK_SIZE(1));\n#endif\n\n/*\n  When this is set by a connection, binlogged events will be marked with a\n  corresponding flag. The slave can be configured to not replicate events\n  so marked.\n  In the binlog dump thread on the master, this variable is re-used for a\n  related purpose: The slave sets this flag when connecting to the master to\n  request that the master filter out (ie. not send) any events with the flag\n  set, thus saving network traffic on events that would be ignored by the\n  slave anyway.\n*/\nstatic bool check_skip_replication(sys_var *self, THD *thd, set_var *var)\n{\n  /*\n    We must not change @@skip_replication in the middle of a transaction or\n    statement, as that could result in only part of the transaction / statement\n    being replicated.\n    (This would be particularly serious if we were to replicate eg.\n    Rows_log_event without Table_map_log_event or transactional updates without\n    the COMMIT).\n  */\n  if (unlikely(error_if_in_trans_or_substatement(thd,\n                                                 ER_STORED_FUNCTION_PREVENTS_SWITCH_SKIP_REPLICATION,\n                                                 ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_SKIP_REPLICATION)))\n    return 1;\n\n  return 0;\n}\n\nstatic Sys_var_bit Sys_skip_replication(\n       \"skip_replication\", \"Changes are logged into the binary log with the \"\n       \"@@skip_replication flag set. Such events will not be replicated by \"\n       \"slaves that run with --replicate-events-marked-for-skip set different \"\n       \"from its default of REPLICATE. See Selectively skipping replication \"\n       \"of binlog events for more information.\",\n       NO_SET_STMT SESSION_ONLY(option_bits),\n       NO_CMD_LINE, OPTION_SKIP_REPLICATION,\n       DEFAULT(FALSE), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(check_skip_replication));\n\nstatic Sys_var_harows Sys_select_limit(\n       \"sql_select_limit\",\n       \"The maximum number of rows to return from SELECT statements\",\n       SESSION_VAR(select_limit), NO_CMD_LINE,\n       VALID_RANGE(0, HA_POS_ERROR), DEFAULT(HA_POS_ERROR), BLOCK_SIZE(1));\n\nstatic const char *secure_timestamp_levels[]= {\"NO\", \"SUPER\", \"REPLICATION\", \"YES\", 0};\nstatic bool check_timestamp(sys_var *self, THD *thd, set_var *var)\n{\n  if (opt_secure_timestamp == SECTIME_NO)\n    return false;\n  if (opt_secure_timestamp == SECTIME_SUPER)\n    return check_has_super(self, thd, var);\n  char buf[1024];\n  strxnmov(buf, sizeof(buf), \"--secure-timestamp=\",\n           secure_timestamp_levels[opt_secure_timestamp], NULL);\n  my_error(ER_OPTION_PREVENTS_STATEMENT, MYF(0), buf);\n  return true;\n}\nstatic Sys_var_timestamp Sys_timestamp(\n       \"timestamp\", \"Set the time for this client\",\n       sys_var::ONLY_SESSION, NO_CMD_LINE,\n       VALID_RANGE(0, TIMESTAMP_MAX_VALUE),\n       NO_MUTEX_GUARD, IN_BINLOG, ON_CHECK(check_timestamp));\n\nstatic bool update_last_insert_id(THD *thd, set_var *var)\n{\n  if (!var->value)\n  {\n    my_error(ER_NO_DEFAULT, MYF(0), var->var->name.str);\n    return true;\n  }\n  thd->first_successful_insert_id_in_prev_stmt=\n    var->save_result.ulonglong_value;\n  return false;\n}\nstatic ulonglong read_last_insert_id(THD *thd)\n{\n  return (ulonglong) thd->read_first_successful_insert_id_in_prev_stmt();\n}\nstatic Sys_var_session_special Sys_last_insert_id(\n       \"last_insert_id\", \"The value to be returned from LAST_INSERT_ID()\",\n       sys_var::ONLY_SESSION, NO_CMD_LINE,\n       VALID_RANGE(0, ULONGLONG_MAX), BLOCK_SIZE(1),\n       NO_MUTEX_GUARD, IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(update_last_insert_id), ON_READ(read_last_insert_id));\n\n// alias for last_insert_id(), Sybase-style\nstatic Sys_var_session_special Sys_identity(\n       \"identity\", \"Synonym for the last_insert_id variable\",\n       sys_var::ONLY_SESSION, NO_CMD_LINE,\n       VALID_RANGE(0, ULONGLONG_MAX), BLOCK_SIZE(1),\n       NO_MUTEX_GUARD, IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(update_last_insert_id), ON_READ(read_last_insert_id));\n\n/*\n  insert_id should *not* be marked as written to the binlog (i.e., it\n  should *not* be IN_BINLOG), because we want any statement that\n  refers to insert_id explicitly to be unsafe.  (By \"explicitly\", we\n  mean using @@session.insert_id, whereas insert_id is used\n  \"implicitly\" when NULL value is inserted into an auto_increment\n  column).\n\n  We want statements referring explicitly to @@session.insert_id to be\n  unsafe, because insert_id is modified internally by the slave sql\n  thread when NULL values are inserted in an AUTO_INCREMENT column.\n  This modification interfers with the value of the\n  @@session.insert_id variable if @@session.insert_id is referred\n  explicitly by an insert statement (as is seen by executing \"SET\n  @@session.insert_id=0; CREATE TABLE t (a INT, b INT KEY\n  AUTO_INCREMENT); INSERT INTO t(a) VALUES (@@session.insert_id);\" in\n  statement-based logging mode: t will be different on master and\n  slave).\n*/\nstatic bool update_insert_id(THD *thd, set_var *var)\n{\n  if (!var->value)\n  {\n    my_error(ER_NO_DEFAULT, MYF(0), var->var->name.str);\n    return true;\n  }\n  thd->force_one_auto_inc_interval(var->save_result.ulonglong_value);\n  return false;\n}\n\nstatic ulonglong read_insert_id(THD *thd)\n{\n  return thd->auto_inc_intervals_forced.minimum();\n}\nstatic Sys_var_session_special Sys_insert_id(\n       \"insert_id\", \"The value to be used by the following INSERT \"\n       \"or ALTER TABLE statement when inserting an AUTO_INCREMENT value\",\n       sys_var::ONLY_SESSION, NO_CMD_LINE,\n       VALID_RANGE(0, ULONGLONG_MAX), BLOCK_SIZE(1),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(update_insert_id), ON_READ(read_insert_id));\n\nstatic bool update_rand_seed1(THD *thd, set_var *var)\n{\n  if (!var->value)\n  {\n    my_error(ER_NO_DEFAULT, MYF(0), var->var->name.str);\n    return true;\n  }\n  thd->rand.seed1= (ulong) var->save_result.ulonglong_value;\n  return false;\n}\nstatic ulonglong read_rand_seed1(THD *thd)\n{\n  return thd->rand.seed1;\n}\nstatic Sys_var_session_special Sys_rand_seed1(\n       \"rand_seed1\", \"Sets the internal state of the RAND() \"\n       \"generator for replication purposes\",\n       sys_var::ONLY_SESSION, NO_CMD_LINE,\n       VALID_RANGE(0, ULONG_MAX), BLOCK_SIZE(1),\n       NO_MUTEX_GUARD, IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(update_rand_seed1), ON_READ(read_rand_seed1));\n\nstatic bool update_rand_seed2(THD *thd, set_var *var)\n{\n  if (!var->value)\n  {\n    my_error(ER_NO_DEFAULT, MYF(0), var->var->name.str);\n    return true;\n  }\n  thd->rand.seed2= (ulong) var->save_result.ulonglong_value;\n  return false;\n}\nstatic ulonglong read_rand_seed2(THD *thd)\n{\n  return thd->rand.seed2;\n}\nstatic Sys_var_session_special Sys_rand_seed2(\n       \"rand_seed2\", \"Sets the internal state of the RAND() \"\n       \"generator for replication purposes\",\n       sys_var::ONLY_SESSION, NO_CMD_LINE,\n       VALID_RANGE(0, ULONG_MAX), BLOCK_SIZE(1),\n       NO_MUTEX_GUARD, IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(update_rand_seed2), ON_READ(read_rand_seed2));\n\nstatic ulonglong read_error_count(THD *thd)\n{\n  return thd->get_stmt_da()->error_count();\n}\n// this really belongs to the SHOW STATUS\nstatic Sys_var_session_special Sys_error_count(\n       \"error_count\", \"The number of errors that resulted from the \"\n       \"last statement that generated messages\",\n       READ_ONLY sys_var::ONLY_SESSION, NO_CMD_LINE,\n       VALID_RANGE(0, ULONGLONG_MAX), BLOCK_SIZE(1), NO_MUTEX_GUARD,\n       NOT_IN_BINLOG, ON_CHECK(0), ON_UPDATE(0), ON_READ(read_error_count));\n\nstatic ulonglong read_warning_count(THD *thd)\n{\n  return thd->get_stmt_da()->warn_count();\n}\n// this really belongs to the SHOW STATUS\nstatic Sys_var_session_special Sys_warning_count(\n       \"warning_count\", \"The number of errors, warnings, and notes \"\n       \"that resulted from the last statement that generated messages\",\n       READ_ONLY sys_var::ONLY_SESSION, NO_CMD_LINE,\n       VALID_RANGE(0, ULONGLONG_MAX), BLOCK_SIZE(1), NO_MUTEX_GUARD,\n       NOT_IN_BINLOG, ON_CHECK(0), ON_UPDATE(0), ON_READ(read_warning_count));\n\nstatic Sys_var_ulong Sys_default_week_format(\n       \"default_week_format\",\n       \"The default week format used by WEEK() functions\",\n       SESSION_VAR(default_week_format), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, 7), DEFAULT(0), BLOCK_SIZE(1));\n\nstatic Sys_var_ulonglong Sys_group_concat_max_len(\n       \"group_concat_max_len\",\n       \"The maximum length of the result of function GROUP_CONCAT()\",\n       SESSION_VAR(group_concat_max_len), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(4, SIZE_T_MAX), DEFAULT(1024*1024), BLOCK_SIZE(1));\n\nstatic char *glob_hostname_ptr;\nstatic Sys_var_charptr Sys_hostname(\n       \"hostname\", \"Server host name\",\n       READ_ONLY GLOBAL_VAR(glob_hostname_ptr), NO_CMD_LINE,\n       IN_SYSTEM_CHARSET, DEFAULT(glob_hostname));\n\n#ifndef EMBEDDED_LIBRARY\nstatic Sys_var_charptr Sys_repl_report_host(\n       \"report_host\",\n       \"Hostname or IP of the slave to be reported to the master during \"\n       \"slave registration. Will appear in the output of SHOW SLAVE HOSTS. \"\n       \"Leave unset if you do not want the slave to register itself with the \"\n       \"master. Note that it is not sufficient for the master to simply read \"\n       \"the IP of the slave off the socket once the slave connects. Due to \"\n       \"NAT and other routing issues, that IP may not be valid for connecting \"\n       \"to the slave from the master or other hosts\",\n       READ_ONLY GLOBAL_VAR(report_host), CMD_LINE(REQUIRED_ARG),\n       IN_SYSTEM_CHARSET, DEFAULT(0));\n\nstatic Sys_var_charptr Sys_repl_report_user(\n       \"report_user\",\n       \"The account user name of the slave to be reported to the master \"\n       \"during slave registration\",\n       READ_ONLY GLOBAL_VAR(report_user), CMD_LINE(REQUIRED_ARG),\n       IN_SYSTEM_CHARSET, DEFAULT(0));\n\nstatic Sys_var_charptr Sys_repl_report_password(\n       \"report_password\",\n       \"The account password of the slave to be reported to the master \"\n       \"during slave registration\",\n       READ_ONLY GLOBAL_VAR(report_password), CMD_LINE(REQUIRED_ARG),\n       IN_SYSTEM_CHARSET, DEFAULT(0));\n\nstatic Sys_var_uint Sys_repl_report_port(\n       \"report_port\",\n       \"Port for connecting to slave reported to the master during slave \"\n       \"registration. Set it only if the slave is listening on a non-default \"\n       \"port or if you have a special tunnel from the master or other clients \"\n       \"to the slave. If not sure, leave this option unset\",\n       READ_ONLY GLOBAL_VAR(report_port), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, UINT_MAX), DEFAULT(0), BLOCK_SIZE(1));\n#endif\n\nstatic Sys_var_mybool Sys_keep_files_on_create(\n       \"keep_files_on_create\",\n       \"Don't overwrite stale .MYD and .MYI even if no directory is specified\",\n       SESSION_VAR(keep_files_on_create), CMD_LINE(OPT_ARG),\n       DEFAULT(FALSE));\n\nstatic char *license;\nstatic Sys_var_charptr Sys_license(\n       \"license\", \"The type of license the server has\",\n       READ_ONLY GLOBAL_VAR(license), NO_CMD_LINE, IN_SYSTEM_CHARSET,\n       DEFAULT(STRINGIFY_ARG(LICENSE)));\n\n#include <proxy_protocol.h>\nchar *my_proxy_protocol_networks;\nstatic bool check_proxy_protocol_networks(sys_var *, THD *, set_var *var)\n{\n  if (!var->value)\n    return false;\n  return !proxy_protocol_networks_valid(var->save_result.string_value.str);\n}\n\n\nstatic bool fix_proxy_protocol_networks(sys_var *, THD *, enum_var_type)\n{\n  return (bool)set_proxy_protocol_networks(my_proxy_protocol_networks);\n}\n\n\nstatic Sys_var_charptr Sys_proxy_protocol_networks(\n    \"proxy_protocol_networks\", \"Enable proxy protocol for these source \"\n    \"networks. The syntax is a comma separated list of IPv4 and IPv6 \"\n    \"networks. If the network doesn't contain mask, it is considered to be \"\n    \"a single host. \\\"*\\\" represents all networks and must the only \"\n    \"directive on the line. String \\\"localhost\\\" represents non-TCP \"\n    \"local connections (Unix domain socket, Windows named pipe or shared memory).\",\n    GLOBAL_VAR(my_proxy_protocol_networks), CMD_LINE(REQUIRED_ARG),\n    IN_FS_CHARSET, DEFAULT(\"\"), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n    ON_CHECK(check_proxy_protocol_networks), ON_UPDATE(fix_proxy_protocol_networks));\n\n\nstatic bool check_log_path(sys_var *self, THD *thd, set_var *var)\n{\n  if (!var->value)\n    return false; // DEFAULT is ok\n\n  if (!var->save_result.string_value.str)\n    return true;\n\n  LEX_STRING *val= &var->save_result.string_value;\n\n  if (val->length > FN_REFLEN)\n  { // path is too long\n    my_error(ER_PATH_LENGTH, MYF(0), self->name.str);\n    return true;\n  }\n\n  char path[FN_REFLEN];\n  size_t path_length= unpack_filename(path, val->str);\n\n  if (!path_length)\n    return true;\n\n  if (!is_filename_allowed(var->save_result.string_value.str, \n                           var->save_result.string_value.length, TRUE))\n  {\n     my_error(ER_WRONG_VALUE_FOR_VAR, MYF(0), \n              self->name.str, var->save_result.string_value.str);\n     return true;\n  }\n\n  static const LEX_CSTRING my_cnf= { STRING_WITH_LEN(\"my.cnf\") };\n  static const LEX_CSTRING my_ini= { STRING_WITH_LEN(\"my.ini\") };\n  if (path_length >= my_cnf.length)\n  {\n    if (strcasecmp(path + path_length - my_cnf.length, my_cnf.str) == 0)\n      return true; // log file name ends with \"my.cnf\"\n    DBUG_ASSERT(my_cnf.length == my_ini.length);\n    if (strcasecmp(path + path_length - my_ini.length, my_ini.str) == 0)\n      return true; // log file name ends with \"my.ini\"\n  }\n\n  MY_STAT f_stat;\n\n  if (my_stat(path, &f_stat, MYF(0)))\n  {\n    if (!MY_S_ISREG(f_stat.st_mode) || !(f_stat.st_mode & MY_S_IWRITE))\n      return true; // not a regular writable file\n    return false;\n  }\n\n  (void) dirname_part(path, val->str, &path_length);\n\n  if (val->length - path_length >= FN_LEN)\n  { // filename is too long\n      my_error(ER_PATH_LENGTH, MYF(0), self->name.str);\n      return true;\n  }\n\n  if (!path_length) // no path is good path (remember, relative to datadir)\n    return false;\n\n  if (my_access(path, (F_OK|W_OK)))\n    return true; // directory is not writable\n\n  return false;\n}\nstatic bool fix_log(char** logname, const char* default_logname,\n                    const char*ext, bool enabled, void (*reopen)(char*))\n{\n  if (!*logname) // SET ... = DEFAULT\n  {\n    make_default_log_name(logname, ext, false);\n    if (!*logname)\n      return true;\n  }\n  logger.lock_exclusive();\n  mysql_mutex_unlock(&LOCK_global_system_variables);\n  if (enabled)\n    reopen(*logname);\n  logger.unlock();\n  mysql_mutex_lock(&LOCK_global_system_variables);\n  return false;\n}\nstatic void reopen_general_log(char* name)\n{\n  logger.get_log_file_handler()->close(0);\n  logger.get_log_file_handler()->open_query_log(name);\n}\nstatic bool fix_general_log_file(sys_var *self, THD *thd, enum_var_type type)\n{\n  return fix_log(&opt_logname,  opt_log_basename, \".log\", opt_log,\n                 reopen_general_log);\n}\nstatic Sys_var_charptr Sys_general_log_path(\n       \"general_log_file\", \"Log connections and queries to given file\",\n       PREALLOCATED GLOBAL_VAR(opt_logname), CMD_LINE(REQUIRED_ARG),\n       IN_FS_CHARSET, DEFAULT(0), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(check_log_path), ON_UPDATE(fix_general_log_file));\n\nstatic void reopen_slow_log(char* name)\n{\n  logger.get_slow_log_file_handler()->close(0);\n  logger.get_slow_log_file_handler()->open_slow_log(name);\n}\nstatic bool fix_slow_log_file(sys_var *self, THD *thd, enum_var_type type)\n{\n  return fix_log(&opt_slow_logname, opt_log_basename, \"-slow.log\",\n                 global_system_variables.sql_log_slow, reopen_slow_log);\n}\nstatic Sys_var_charptr Sys_slow_log_path(\n       \"slow_query_log_file\", \"Log slow queries to given log file. \"\n       \"Defaults logging to 'hostname'-slow.log. Must be enabled to activate \"\n       \"other slow log options\",\n       PREALLOCATED GLOBAL_VAR(opt_slow_logname), CMD_LINE(REQUIRED_ARG),\n       IN_FS_CHARSET, DEFAULT(0), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(check_log_path), ON_UPDATE(fix_slow_log_file));\n\nstatic Sys_var_have Sys_have_compress(\n       \"have_compress\", \"If the zlib compression library is accessible to the \"\n       \"server, this will be set to YES, otherwise it will be NO. The COMPRESS() \"\n       \"and UNCOMPRESS() functions will only be available if set to YES.\",\n       READ_ONLY GLOBAL_VAR(have_compress), NO_CMD_LINE);\n\nstatic Sys_var_have Sys_have_crypt(\n       \"have_crypt\", \"If the crypt() system call is available this variable will \"\n       \"be set to YES, otherwise it will be set to NO. If set to NO, the \"\n       \"ENCRYPT() function cannot be used.\",\n       READ_ONLY GLOBAL_VAR(have_crypt), NO_CMD_LINE);\n\nstatic Sys_var_have Sys_have_dlopen(\n       \"have_dynamic_loading\", \"If the server supports dynamic loading of plugins, \"\n       \"will be set to YES, otherwise will be set to NO.\",\n       READ_ONLY GLOBAL_VAR(have_dlopen), NO_CMD_LINE);\n\nstatic Sys_var_have Sys_have_geometry(\n       \"have_geometry\", \"If the server supports spatial data types, will be set to \"\n       \"YES, otherwise will be set to NO.\",\n       READ_ONLY GLOBAL_VAR(have_geometry), NO_CMD_LINE);\n\nstatic Sys_var_have Sys_have_openssl(\n       \"have_openssl\", \"Comparing have_openssl with have_ssl will indicate whether \"\n       \"YaSSL or openssl was used. If YaSSL, have_ssl will be YES, but have_openssl \"\n       \"will be NO.\",\n       READ_ONLY GLOBAL_VAR(have_openssl), NO_CMD_LINE);\n\nstatic Sys_var_have Sys_have_profiling(\n       \"have_profiling\", \"If statement profiling is available, will be set to YES, \"\n       \"otherwise will be set to NO. See SHOW PROFILES and SHOW PROFILE.\",\n       READ_ONLY GLOBAL_VAR(have_profiling), NO_CMD_LINE);\n\nstatic Sys_var_have Sys_have_query_cache(\n       \"have_query_cache\", \"If the server supports the query cache, will be set to \"\n       \"YES, otherwise will be set to NO.\",\n       READ_ONLY GLOBAL_VAR(have_query_cache), NO_CMD_LINE);\n\nstatic Sys_var_have Sys_have_rtree_keys(\n       \"have_rtree_keys\", \"If RTREE indexes (used for spatial indexes) \"\n       \"are available, will be set to YES, otherwise will be set to NO.\",\n       READ_ONLY GLOBAL_VAR(have_rtree_keys), NO_CMD_LINE);\n\nstatic Sys_var_have Sys_have_ssl(\n       \"have_ssl\", \"If the server supports secure connections, will be set to YES, \"\n       \"otherwise will be set to NO. If set to DISABLED, the server was compiled with \"\n       \"TLS support, but was not started with TLS support (see the mysqld options). \"\n       \"See also have_openssl.\",\n       READ_ONLY GLOBAL_VAR(have_ssl), NO_CMD_LINE);\n\nstatic Sys_var_have Sys_have_symlink(\n       \"have_symlink\", \"If symbolic link support is enabled, will be set to YES, \"\n       \"otherwise will be set to NO. Required for the INDEX DIRECTORY and DATA \"\n       \"DIRECTORY table options (see CREATE TABLE) and Windows symlink support. \"\n       \"Will be set to DISABLED if the server is started with the \"\n       \"--skip-symbolic-links option.\",\n       READ_ONLY GLOBAL_VAR(have_symlink), NO_CMD_LINE);\n\nstatic bool fix_log_state(sys_var *self, THD *thd, enum_var_type type);\n\nstatic Sys_var_mybool Sys_general_log(\n       \"general_log\", \"Log connections and queries to a table or log file. \"\n       \"Defaults logging to a file 'hostname'.log or a table mysql.general_log\"\n       \"if --log-output=TABLE is used.\",\n       GLOBAL_VAR(opt_log), CMD_LINE(OPT_ARG),\n       DEFAULT(FALSE), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_log_state));\n\nstatic Sys_var_mybool Sys_slow_query_log(\n       \"slow_query_log\",\n       \"Log slow queries to a table or log file. Defaults logging to a file \"\n       \"'hostname'-slow.log or a table mysql.slow_log if --log-output=TABLE is \"\n       \"used. Must be enabled to activate other slow log options.\",\n       SESSION_VAR(sql_log_slow), CMD_LINE(OPT_ARG),\n       DEFAULT(FALSE), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(0), ON_UPDATE(fix_log_state));\n\nstatic bool fix_log_state(sys_var *self, THD *thd, enum_var_type type)\n{\n  bool res;\n  my_bool *UNINIT_VAR(newvalptr), newval, UNINIT_VAR(oldval);\n  uint UNINIT_VAR(log_type);\n\n  if (type != OPT_GLOBAL)\n    return 0;\n\n  if (self == &Sys_general_log)\n  {\n    newvalptr= &opt_log;\n    oldval=    logger.get_log_file_handler()->is_open();\n    log_type=  QUERY_LOG_GENERAL;\n  }\n  else\n  {\n    DBUG_ASSERT(self == &Sys_slow_query_log);\n    newvalptr= &global_system_variables.sql_log_slow;\n    oldval=    logger.get_slow_log_file_handler()->is_open();\n    log_type=  QUERY_LOG_SLOW;\n  }\n\n  newval= *newvalptr;\n  if (oldval == newval)\n    return false;\n\n  *newvalptr= oldval; // [de]activate_log_handler works that way (sigh)\n\n  mysql_mutex_unlock(&LOCK_global_system_variables);\n  if (!newval)\n  {\n    logger.deactivate_log_handler(thd, log_type);\n    res= false;\n  }\n  else\n    res= logger.activate_log_handler(thd, log_type);\n  mysql_mutex_lock(&LOCK_global_system_variables);\n  return res;\n}\n\n\nstatic bool check_not_empty_set(sys_var *self, THD *thd, set_var *var)\n{\n  return var->save_result.ulonglong_value == 0;\n}\nstatic bool fix_log_output(sys_var *self, THD *thd, enum_var_type type)\n{\n  logger.lock_exclusive();\n  logger.init_slow_log(log_output_options);\n  logger.init_general_log(log_output_options);\n  logger.unlock();\n  return false;\n}\n\nstatic const char *log_output_names[] = { \"NONE\", \"FILE\", \"TABLE\", NULL};\n\nstatic Sys_var_set Sys_log_output(\n       \"log_output\", \"How logs should be written\",\n       GLOBAL_VAR(log_output_options), CMD_LINE(REQUIRED_ARG),\n       log_output_names, DEFAULT(LOG_FILE), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(check_not_empty_set), ON_UPDATE(fix_log_output));\n\n#ifdef HAVE_REPLICATION\nstatic Sys_var_mybool Sys_log_slave_updates(\n       \"log_slave_updates\", \"Tells the slave to log the updates from \"\n       \"the slave thread to the binary log. You will need to turn it on if \"\n       \"you plan to daisy-chain the slaves.\",\n       READ_ONLY GLOBAL_VAR(opt_log_slave_updates), CMD_LINE(OPT_ARG),\n       DEFAULT(0));\n\nstatic Sys_var_charptr Sys_relay_log(\n       \"relay_log\", \"The location and name to use for relay logs.\",\n       READ_ONLY GLOBAL_VAR(opt_relay_logname), CMD_LINE(REQUIRED_ARG),\n       IN_FS_CHARSET, DEFAULT(0));\n\n/*\n  Uses NO_CMD_LINE since the --relay-log-index option set\n  opt_relaylog_index_name variable and computes a value for the\n  relay_log_index variable.\n*/\nstatic Sys_var_charptr Sys_relay_log_index(\n       \"relay_log_index\", \"The location and name to use for the file \"\n       \"that keeps a list of the last relay logs.\",\n       READ_ONLY GLOBAL_VAR(relay_log_index), NO_CMD_LINE,\n       IN_FS_CHARSET, DEFAULT(0));\n\n/*\n  Uses NO_CMD_LINE since the --log-bin-index option set\n  opt_binlog_index_name variable and computes a value for the\n  log_bin_index variable.\n*/\nstatic Sys_var_charptr Sys_binlog_index(\n       \"log_bin_index\", \"File that holds the names for last binary log files.\",\n       READ_ONLY GLOBAL_VAR(log_bin_index), NO_CMD_LINE,\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic Sys_var_charptr Sys_relay_log_basename(\n       \"relay_log_basename\",\n       \"The full path of the relay log file names, excluding the extension.\",\n       READ_ONLY GLOBAL_VAR(relay_log_basename), NO_CMD_LINE,\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic Sys_var_charptr Sys_log_bin_basename(\n       \"log_bin_basename\",\n       \"The full path of the binary log file names, excluding the extension.\",\n       READ_ONLY GLOBAL_VAR(log_bin_basename), NO_CMD_LINE,\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic Sys_var_charptr Sys_relay_log_info_file(\n       \"relay_log_info_file\", \"The location and name of the file that \"\n       \"remembers where the SQL replication thread is in the relay logs.\",\n       READ_ONLY GLOBAL_VAR(relay_log_info_file), CMD_LINE(REQUIRED_ARG),\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic Sys_var_mybool Sys_relay_log_purge(\n       \"relay_log_purge\", \"if disabled - do not purge relay logs. \"\n       \"if enabled - purge them as soon as they are no more needed.\",\n       GLOBAL_VAR(relay_log_purge), CMD_LINE(OPT_ARG), DEFAULT(TRUE));\n\nstatic Sys_var_mybool Sys_relay_log_recovery(\n       \"relay_log_recovery\", \"Enables automatic relay log recovery \"\n       \"right after the database startup, which means that the IO Thread \"\n       \"starts re-fetching from the master right after the last transaction \"\n       \"processed.\",\n       GLOBAL_VAR(relay_log_recovery), CMD_LINE(OPT_ARG), DEFAULT(FALSE));\n\n\nbool Sys_var_rpl_filter::global_update(THD *thd, set_var *var)\n{\n  bool result= true;                            // Assume error\n  LEX_CSTRING *base_name= &var->base;\n\n  if (!base_name->length)\n    base_name= &thd->variables.default_master_connection;\n\n  mysql_mutex_unlock(&LOCK_global_system_variables);\n\n  if (Master_info *mi= get_master_info(base_name, !var->base.length ?\n                                       Sql_condition::WARN_LEVEL_ERROR :\n                                       Sql_condition::WARN_LEVEL_WARN))\n  {\n    if (mi->rli.slave_running)\n    {\n      my_error(ER_SLAVE_MUST_STOP, MYF(0), \n               (int) mi->connection_name.length,\n               mi->connection_name.str);\n      result= true;\n    }\n    else\n    {\n      result= set_filter_value(var->save_result.string_value.str, mi);\n    }\n    mi->release();\n  }\n\n  mysql_mutex_lock(&LOCK_global_system_variables);\n  return result;\n}\n\nbool Sys_var_rpl_filter::set_filter_value(const char *value, Master_info *mi)\n{\n  bool status= true;\n  Rpl_filter* rpl_filter= mi->rpl_filter;\n\n  /* Proctect against other threads */\n  mysql_mutex_lock(&LOCK_active_mi);\n  switch (opt_id) {\n  case OPT_REPLICATE_DO_DB:\n    status= rpl_filter->set_do_db(value);\n    break;\n  case OPT_REPLICATE_DO_TABLE:\n    status= rpl_filter->set_do_table(value);\n    break;\n  case OPT_REPLICATE_IGNORE_DB:\n    status= rpl_filter->set_ignore_db(value);\n    break;\n  case OPT_REPLICATE_IGNORE_TABLE:\n    status= rpl_filter->set_ignore_table(value);\n    break;\n  case OPT_REPLICATE_WILD_DO_TABLE:\n    status= rpl_filter->set_wild_do_table(value);\n    break;\n  case OPT_REPLICATE_WILD_IGNORE_TABLE:\n    status= rpl_filter->set_wild_ignore_table(value);\n    break;\n  }\n  mysql_mutex_unlock(&LOCK_active_mi);\n  return status;\n}\n\nuchar *Sys_var_rpl_filter::global_value_ptr(THD *thd,\n                                            const LEX_CSTRING *base_name)\n{\n  char buf[256];\n  String tmp(buf, sizeof(buf), &my_charset_bin);\n  uchar *ret;\n  Master_info *mi;\n  Rpl_filter *rpl_filter;\n\n  mysql_mutex_unlock(&LOCK_global_system_variables);\n  mi= get_master_info(base_name, !base_name->length ?\n                      Sql_condition::WARN_LEVEL_ERROR :\n                      Sql_condition::WARN_LEVEL_WARN);\n\n  if (!mi)\n  {\n    mysql_mutex_lock(&LOCK_global_system_variables);\n    return 0;\n  }\n\n  rpl_filter= mi->rpl_filter;\n  tmp.length(0);\n\n  mysql_mutex_lock(&LOCK_active_mi);\n  switch (opt_id) {\n  case OPT_REPLICATE_DO_DB:\n    rpl_filter->get_do_db(&tmp);\n    break;\n  case OPT_REPLICATE_DO_TABLE:\n    rpl_filter->get_do_table(&tmp);\n    break;\n  case OPT_REPLICATE_IGNORE_DB:\n    rpl_filter->get_ignore_db(&tmp);\n    break;\n  case OPT_REPLICATE_IGNORE_TABLE:\n    rpl_filter->get_ignore_table(&tmp);\n    break;\n  case OPT_REPLICATE_WILD_DO_TABLE:\n    rpl_filter->get_wild_do_table(&tmp);\n    break;\n  case OPT_REPLICATE_WILD_IGNORE_TABLE:\n    rpl_filter->get_wild_ignore_table(&tmp);\n    break;\n  }\n  mysql_mutex_unlock(&LOCK_active_mi);\n  mysql_mutex_lock(&LOCK_global_system_variables);\n\n  mi->release();\n\n  ret= (uchar *) thd->strmake(tmp.ptr(), tmp.length());\n\n  return ret;\n}\n\nstatic Sys_var_rpl_filter Sys_replicate_do_db(\n       \"replicate_do_db\", OPT_REPLICATE_DO_DB,\n       \"Tell the slave to restrict replication to updates of tables \"\n       \"whose names appear in the comma-separated list. For \"\n       \"statement-based replication, only the default database (that \"\n       \"is, the one selected by USE) is considered, not any explicitly \"\n       \"mentioned tables in the query. For row-based replication, the \"\n       \"actual names of table(s) being updated are checked.\");\n\nstatic Sys_var_rpl_filter Sys_replicate_do_table(\n       \"replicate_do_table\", OPT_REPLICATE_DO_TABLE,\n       \"Tells the slave to restrict replication to tables in the \"\n       \"comma-separated list.\");\n\nstatic Sys_var_rpl_filter Sys_replicate_ignore_db(\n       \"replicate_ignore_db\", OPT_REPLICATE_IGNORE_DB,\n       \"Tell the slave to restrict replication to updates of tables \"\n       \"whose names do not appear in the comma-separated list. For \"\n       \"statement-based replication, only the default database (that \"\n       \"is, the one selected by USE) is considered, not any explicitly \"\n       \"mentioned tables in the query. For row-based replication, the \"\n       \"actual names of table(s) being updated are checked.\");\n\nstatic Sys_var_rpl_filter Sys_replicate_ignore_table(\n       \"replicate_ignore_table\", OPT_REPLICATE_IGNORE_TABLE,\n       \"Tells the slave thread not to replicate any statement that \"\n       \"updates the specified table, even if any other tables might be \"\n       \"updated by the same statement.\");\n\nstatic Sys_var_rpl_filter Sys_replicate_wild_do_table(\n       \"replicate_wild_do_table\", OPT_REPLICATE_WILD_DO_TABLE,\n       \"Tells the slave thread to restrict replication to statements \"\n       \"where any of the updated tables match the specified database \"\n       \"and table name patterns.\");\n\nstatic Sys_var_rpl_filter Sys_replicate_wild_ignore_table(\n       \"replicate_wild_ignore_table\", OPT_REPLICATE_WILD_IGNORE_TABLE,\n       \"Tells the slave thread to not replicate to the tables that \"\n       \"match the given wildcard pattern.\");\n\nstatic Sys_var_charptr Sys_slave_load_tmpdir(\n       \"slave_load_tmpdir\", \"The location where the slave should put \"\n       \"its temporary files when replicating a LOAD DATA INFILE command\",\n       READ_ONLY GLOBAL_VAR(slave_load_tmpdir), CMD_LINE(REQUIRED_ARG),\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic Sys_var_uint Sys_slave_net_timeout(\n       \"slave_net_timeout\", \"Number of seconds to wait for more data \"\n       \"from any master/slave connection before aborting the read\",\n       GLOBAL_VAR(slave_net_timeout), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, LONG_TIMEOUT), DEFAULT(SLAVE_NET_TIMEOUT), BLOCK_SIZE(1));\n\n\n/*\n  Access a multi_source variable\n  Return 0 + warning if it doesn't exist\n*/\n\nulonglong Sys_var_multi_source_ulonglong::\nget_master_info_ulonglong_value(THD *thd, ptrdiff_t offset)\n{\n  Master_info *mi;\n  ulonglong res= 0;                                  // Default value\n  mysql_mutex_unlock(&LOCK_global_system_variables);\n  if ((mi= get_master_info(&thd->variables.default_master_connection,\n                           Sql_condition::WARN_LEVEL_WARN)))\n  {\n    res= *((ulonglong*) (((uchar*) mi) + master_info_offset));\n    mi->release();\n  }\n  mysql_mutex_lock(&LOCK_global_system_variables);\n  return res;\n}\n  \n\nbool update_multi_source_variable(sys_var *self_var, THD *thd,\n                                  enum_var_type type)\n{\n  Sys_var_multi_source_ulonglong *self= (Sys_var_multi_source_ulonglong*) self_var;\n  bool result= true;\n  Master_info *mi;\n\n  if (type == OPT_GLOBAL)\n    mysql_mutex_unlock(&LOCK_global_system_variables);\n  if ((mi= (get_master_info(&thd->variables.default_master_connection,\n                            Sql_condition::WARN_LEVEL_ERROR))))\n  {\n    mysql_mutex_lock(&mi->rli.run_lock);\n    mysql_mutex_lock(&mi->rli.data_lock);\n    result= self->update_variable(thd, mi);\n    mysql_mutex_unlock(&mi->rli.data_lock);\n    mysql_mutex_unlock(&mi->rli.run_lock);\n    mi->release();\n  }\n  if (type == OPT_GLOBAL)\n    mysql_mutex_lock(&LOCK_global_system_variables);\n  return result;\n}\n\nstatic bool update_slave_skip_counter(sys_var *self, THD *thd, Master_info *mi)\n{\n  if (mi->rli.slave_running)\n  {\n    my_error(ER_SLAVE_MUST_STOP, MYF(0), (int) mi->connection_name.length,\n             mi->connection_name.str);\n    return true;\n  }\n  if (mi->using_gtid != Master_info::USE_GTID_NO && mi->using_parallel())\n  {\n    ulong domain_count;\n    mysql_mutex_lock(&rpl_global_gtid_slave_state->LOCK_slave_state);\n    domain_count= rpl_global_gtid_slave_state->count();\n    mysql_mutex_unlock(&rpl_global_gtid_slave_state->LOCK_slave_state);\n    if (domain_count > 1)\n    {\n      /*\n        With domain-based parallel replication, the slave position is\n        multi-dimensional, so the relay log position is not very meaningful.\n        It might not even correspond to the next GTID to execute in _any_\n        domain (the case after error stop). So slave_skip_counter will most\n        likely not do what the user intends. Instead give an error, with a\n        suggestion to instead set @@gtid_slave_pos past the point of error;\n        this works reliably also in the case of multiple domains.\n      */\n      my_error(ER_SLAVE_SKIP_NOT_IN_GTID, MYF(0));\n      return true;\n    }\n  }\n\n  /* The value was stored temporarily in thd */\n  mi->rli.slave_skip_counter= thd->variables.slave_skip_counter;\n  return false;\n}\n\nstatic Sys_var_multi_source_ulonglong Sys_slave_skip_counter(\n       \"sql_slave_skip_counter\", \"Skip the next N events from the master log\",\n       SESSION_VAR(slave_skip_counter), NO_CMD_LINE,\n       MASTER_INFO_VAR(rli.slave_skip_counter),\n       VALID_RANGE(0, UINT_MAX), DEFAULT(0), BLOCK_SIZE(1),\n       ON_UPDATE(update_slave_skip_counter));\n\nstatic bool update_max_relay_log_size(sys_var *self, THD *thd, Master_info *mi)\n{\n  mi->rli.max_relay_log_size= thd->variables.max_relay_log_size;\n  mi->rli.relay_log.set_max_size((ulong)mi->rli.max_relay_log_size);\n  return false;\n}\n\nstatic Sys_var_multi_source_ulonglong Sys_max_relay_log_size(\n       \"max_relay_log_size\",\n       \"relay log will be rotated automatically when the size exceeds this \"\n       \"value.  If 0 at startup, it's set to max_binlog_size\",\n       SESSION_VAR(max_relay_log_size), CMD_LINE(REQUIRED_ARG),\n       MASTER_INFO_VAR(rli.max_relay_log_size),\n       VALID_RANGE(0, 1024L*1024*1024), DEFAULT(0), BLOCK_SIZE(IO_SIZE),\n       ON_UPDATE(update_max_relay_log_size));\n\nstatic Sys_var_charptr Sys_slave_skip_errors(\n       \"slave_skip_errors\", \"Tells the slave thread to continue \"\n       \"replication when a query event returns an error from the \"\n       \"provided list\",\n       READ_ONLY GLOBAL_VAR(opt_slave_skip_errors), CMD_LINE(REQUIRED_ARG),\n       IN_SYSTEM_CHARSET, DEFAULT(0));\n\nstatic Sys_var_ulonglong Sys_read_binlog_speed_limit(\n       \"read_binlog_speed_limit\", \"Maximum speed(KB/s) to read binlog from\"\n       \" master (0 = no limit)\",\n       GLOBAL_VAR(opt_read_binlog_speed_limit), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, ULONG_MAX), DEFAULT(0), BLOCK_SIZE(1));\n\nstatic Sys_var_charptr Sys_slave_transaction_retry_errors(\n       \"slave_transaction_retry_errors\", \"Tells the slave thread to retry \"\n       \"transaction for replication when a query event returns an error from \"\n       \"the provided list. Deadlock error, elapsed lock wait timeout, \"\n       \"net read error, net read timeout, net write error, net write timeout, \"\n       \"connect error and 2 types of lost connection error are automatically \"\n       \"added to this list\",\n       READ_ONLY GLOBAL_VAR(opt_slave_transaction_retry_errors), CMD_LINE(REQUIRED_ARG),\n       IN_SYSTEM_CHARSET, DEFAULT(0));\n\nstatic Sys_var_ulonglong Sys_relay_log_space_limit(\n       \"relay_log_space_limit\", \"Maximum space to use for all relay logs\",\n       READ_ONLY GLOBAL_VAR(relay_log_space_limit), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, ULONGLONG_MAX), DEFAULT(0), BLOCK_SIZE(1));\n\nstatic Sys_var_uint Sys_sync_relaylog_period(\n       \"sync_relay_log\", \"Synchronously flush relay log to disk after \"\n       \"every #th event. Use 0 to disable synchronous flushing\",\n       GLOBAL_VAR(sync_relaylog_period), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, UINT_MAX), DEFAULT(10000), BLOCK_SIZE(1));\n\nstatic Sys_var_uint Sys_sync_relayloginfo_period(\n       \"sync_relay_log_info\", \"Synchronously flush relay log info \"\n       \"to disk after every #th transaction. Use 0 to disable \"\n       \"synchronous flushing\",\n       GLOBAL_VAR(sync_relayloginfo_period), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, UINT_MAX), DEFAULT(10000), BLOCK_SIZE(1));\n#endif\n\nstatic Sys_var_uint Sys_sync_binlog_period(\n       \"sync_binlog\", \"Synchronously flush binary log to disk after \"\n       \"every #th event. Use 0 (default) to disable synchronous flushing\",\n       GLOBAL_VAR(sync_binlog_period), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, UINT_MAX), DEFAULT(0), BLOCK_SIZE(1));\n\nstatic Sys_var_uint Sys_sync_masterinfo_period(\n       \"sync_master_info\", \"Synchronously flush master info to disk \"\n       \"after every #th event. Use 0 to disable synchronous flushing\",\n       GLOBAL_VAR(sync_masterinfo_period), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, UINT_MAX), DEFAULT(10000), BLOCK_SIZE(1));\n\n#ifdef HAVE_REPLICATION\nstatic Sys_var_ulong Sys_slave_trans_retries(\n       \"slave_transaction_retries\", \"Number of times the slave SQL \"\n       \"thread will retry a transaction in case it failed with a deadlock, \"\n       \"elapsed lock wait timeout or listed in \"\n       \"slave_transaction_retry_errors, before giving up and stopping\",\n       GLOBAL_VAR(slave_trans_retries), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, UINT_MAX), DEFAULT(10), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_slave_trans_retry_interval(\n       \"slave_transaction_retry_interval\", \"Interval of the slave SQL \"\n       \"thread will retry a transaction in case it failed with a deadlock \"\n       \"or elapsed lock wait timeout or listed in \"\n       \"slave_transaction_retry_errors\",\n       GLOBAL_VAR(slave_trans_retry_interval), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, 3600), DEFAULT(0), BLOCK_SIZE(1));\n#endif\n\nstatic bool check_locale(sys_var *self, THD *thd, set_var *var)\n{\n  if (!var->value)\n    return false;\n\n  MY_LOCALE *locale;\n  char buff[STRING_BUFFER_USUAL_SIZE];\n  if (var->value->result_type() == INT_RESULT)\n  {\n    int lcno= (int)var->value->val_int();\n    if (!(locale= my_locale_by_number(lcno)))\n    {\n      my_error(ER_UNKNOWN_LOCALE, MYF(0), llstr(lcno, buff));\n      return true;\n    }\n    if (check_not_null(self, thd, var))\n      return true;\n  }\n  else // STRING_RESULT\n  {\n    String str(buff, sizeof(buff), system_charset_info), *res;\n    if (!(res=var->value->val_str(&str)))\n      return true;\n    else if (!(locale= my_locale_by_name(res->c_ptr_safe())))\n    {\n      ErrConvString err(res);\n      my_error(ER_UNKNOWN_LOCALE, MYF(0), err.ptr());\n      return true;\n    }\n  }\n\n  var->save_result.ptr= locale;\n\n  if (!locale->errmsgs->errmsgs)\n  {\n    bool res;\n    mysql_mutex_lock(&LOCK_error_messages);\n    res= (!locale->errmsgs->errmsgs &&\n          read_texts(ERRMSG_FILE, locale->errmsgs->language,\n                     &locale->errmsgs->errmsgs));\n    mysql_mutex_unlock(&LOCK_error_messages);\n    if (res)\n    {\n      push_warning_printf(thd, Sql_condition::WARN_LEVEL_WARN, ER_UNKNOWN_ERROR,\n                          \"Can't process error message file for locale '%s'\",\n                          locale->name);\n      return true;\n    }\n  }\n  status_var_increment(thd->status_var.feature_locale);\n  return false;\n}\n\nstatic bool update_locale(sys_var *self, THD* thd, enum_var_type type)\n{\n  /* Cache pointer to error messages */\n  if (type == OPT_SESSION)\n    thd->variables.errmsgs= thd->variables.lc_messages->errmsgs->errmsgs;\n  else\n    global_system_variables.errmsgs=\n      global_system_variables.lc_messages->errmsgs->errmsgs;\n  return false;\n}\n  \nstatic Sys_var_struct Sys_lc_messages(\n       \"lc_messages\", \"Set the language used for the error messages\",\n       SESSION_VAR(lc_messages), NO_CMD_LINE,\n       my_offsetof(MY_LOCALE, name), DEFAULT(&my_default_lc_messages),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(check_locale), ON_UPDATE(update_locale));\n\nstatic Sys_var_struct Sys_lc_time_names(\n       \"lc_time_names\", \"Set the language used for the month \"\n       \"names and the days of the week\",\n       SESSION_VAR(lc_time_names), NO_CMD_LINE,\n       my_offsetof(MY_LOCALE, name), DEFAULT(&my_default_lc_time_names),\n       NO_MUTEX_GUARD, IN_BINLOG, ON_CHECK(check_locale));\n\nstatic Sys_var_tz Sys_time_zone(\n       \"time_zone\", \"The current time zone, used to initialize the time \"\n       \"zone for a client when it connects. Set to SYSTEM by default, in \"\n       \"which the client uses the system time zone value.\",\n       SESSION_VAR(time_zone), NO_CMD_LINE,\n       DEFAULT(&default_tz), NO_MUTEX_GUARD, IN_BINLOG);\n\n#ifdef WITH_WSREP\n#include \"wsrep_var.h\"\n#include \"wsrep_sst.h\"\n#include \"wsrep_binlog.h\"\n\nstatic Sys_var_charptr Sys_wsrep_provider(\n       \"wsrep_provider\", \"Path to replication provider library\",\n       PREALLOCATED GLOBAL_VAR(wsrep_provider), CMD_LINE(REQUIRED_ARG),\n       IN_FS_CHARSET, DEFAULT(WSREP_NONE),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(wsrep_provider_check), ON_UPDATE(wsrep_provider_update));\n\nstatic Sys_var_charptr Sys_wsrep_provider_options(\n       \"wsrep_provider_options\", \"Semicolon (;) separated list of wsrep \"\n       \"options (see wsrep_provider_options documentation).\",\n       PREALLOCATED GLOBAL_VAR(wsrep_provider_options), \n       CMD_LINE(REQUIRED_ARG),\n       IN_SYSTEM_CHARSET, DEFAULT(\"\"), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(wsrep_provider_options_check), \n       ON_UPDATE(wsrep_provider_options_update));\n\nstatic Sys_var_charptr Sys_wsrep_data_home_dir(\n       \"wsrep_data_home_dir\", \"home directory for wsrep provider\",\n       READ_ONLY GLOBAL_VAR(wsrep_data_home_dir), CMD_LINE(REQUIRED_ARG),\n       IN_FS_CHARSET, DEFAULT(mysql_real_data_home));\n\nstatic Sys_var_charptr Sys_wsrep_cluster_name(\n       \"wsrep_cluster_name\", \"Name for the cluster\",\n       PREALLOCATED GLOBAL_VAR(wsrep_cluster_name), CMD_LINE(REQUIRED_ARG),\n       IN_SYSTEM_CHARSET, DEFAULT(WSREP_CLUSTER_NAME),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(wsrep_cluster_name_check),\n       ON_UPDATE(wsrep_cluster_name_update));\n\nstatic PolyLock_mutex PLock_wsrep_cluster_config(&LOCK_wsrep_cluster_config);\nstatic Sys_var_charptr Sys_wsrep_cluster_address (\n       \"wsrep_cluster_address\", \"Address to initially connect to cluster\",\n       PREALLOCATED GLOBAL_VAR(wsrep_cluster_address), \n       CMD_LINE(REQUIRED_ARG),\n       IN_SYSTEM_CHARSET, DEFAULT(\"\"),\n       &PLock_wsrep_cluster_config, NOT_IN_BINLOG,\n       ON_CHECK(wsrep_cluster_address_check), \n       ON_UPDATE(wsrep_cluster_address_update));\n\nstatic Sys_var_charptr Sys_wsrep_node_name (\n       \"wsrep_node_name\", \"Name of this node. This name can be used in \"\n       \"wsrep_sst_donor as a preferred donor. Note that multiple nodes \"\n       \"in a cluster can have the same name.\",\n       PREALLOCATED GLOBAL_VAR(wsrep_node_name), CMD_LINE(REQUIRED_ARG),\n       IN_SYSTEM_CHARSET, DEFAULT(glob_hostname), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       wsrep_node_name_check, wsrep_node_name_update);\n\nstatic Sys_var_charptr Sys_wsrep_node_address (\n       \"wsrep_node_address\", \"Specifies the node's network address, in \"\n       \"the format ip address[:port]. Used in situations where autoguessing \"\n       \"is not reliable. As of MariaDB 10.1.8, supports IPv6.\",\n       PREALLOCATED GLOBAL_VAR(wsrep_node_address), CMD_LINE(REQUIRED_ARG),\n       IN_SYSTEM_CHARSET, DEFAULT(\"\"),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(wsrep_node_address_check),\n       ON_UPDATE(wsrep_node_address_update));\n\nstatic Sys_var_charptr Sys_wsrep_node_incoming_address(\n       \"wsrep_node_incoming_address\", \"Client connection address\",\n       PREALLOCATED GLOBAL_VAR(wsrep_node_incoming_address),CMD_LINE(REQUIRED_ARG),\n       IN_SYSTEM_CHARSET, DEFAULT(WSREP_NODE_INCOMING_AUTO));\n\nstatic Sys_var_ulong Sys_wsrep_slave_threads(\n       \"wsrep_slave_threads\", \"Number of slave appliers to launch\",\n       GLOBAL_VAR(wsrep_slave_threads), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, 512), DEFAULT(1), BLOCK_SIZE(1),\n       &PLock_wsrep_cluster_config, NOT_IN_BINLOG,\n       ON_CHECK(0),\n       ON_UPDATE(wsrep_slave_threads_update));\n\nstatic Sys_var_charptr Sys_wsrep_dbug_option(\n       \"wsrep_dbug_option\", \"DBUG options to provider library\",\n       GLOBAL_VAR(wsrep_dbug_option),CMD_LINE(REQUIRED_ARG),\n       IN_SYSTEM_CHARSET, DEFAULT(\"\"));\n\nstatic const char *wsrep_debug_names[]=\n{ \"NONE\", \"SERVER\", \"TRANSACTION\", \"STREAMING\", \"CLIENT\", NullS };\nstatic Sys_var_enum Sys_wsrep_debug(\n       \"wsrep_debug\", \"WSREP debug level logging\",\n       GLOBAL_VAR(wsrep_debug), CMD_LINE(REQUIRED_ARG),\n       wsrep_debug_names, DEFAULT(0),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(0), ON_UPDATE(wsrep_debug_update));\n\nstatic Sys_var_mybool Sys_wsrep_convert_LOCK_to_trx(\n       \"wsrep_convert_LOCK_to_trx\", \"To convert locking sessions \"\n       \"into transactions\",\n       GLOBAL_VAR(wsrep_convert_LOCK_to_trx), \n       CMD_LINE(OPT_ARG), DEFAULT(FALSE));\n\nstatic Sys_var_ulong Sys_wsrep_retry_autocommit(\n      \"wsrep_retry_autocommit\", \"Max number of times to retry \"\n      \"a failed autocommit statement\",\n       SESSION_VAR(wsrep_retry_autocommit), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, 10000), DEFAULT(1), BLOCK_SIZE(1));\n\nstatic bool update_wsrep_auto_increment_control (sys_var *self, THD *thd, enum_var_type type)\n{\n  if (wsrep_auto_increment_control)\n  {\n    /*\n      The variables that control auto increment shall be calculated\n      automaticaly based on the size of the cluster. This usually done\n      within the wsrep_view_handler_cb callback. However, if the user\n      manually sets the value of wsrep_auto_increment_control to 'ON',\n      then we should to re-calculate these variables again (because\n      these values may be required before wsrep_view_handler_cb will\n      be re-invoked, which is rarely invoked if the cluster stays in\n      the stable state):\n    */\n    global_system_variables.auto_increment_increment=\n       wsrep_cluster_size ? wsrep_cluster_size : 1;\n    global_system_variables.auto_increment_offset=\n       wsrep_local_index >= 0 ? wsrep_local_index + 1 : 1;\n    thd->variables.auto_increment_increment=\n      global_system_variables.auto_increment_increment;\n    thd->variables.auto_increment_offset=\n      global_system_variables.auto_increment_offset;\n  }\n  else\n  {\n    /*\n      We must restore the last values of the variables that\n      are explicitly specified by the user:\n    */\n    global_system_variables.auto_increment_increment=\n      global_system_variables.saved_auto_increment_increment;\n    global_system_variables.auto_increment_offset=\n      global_system_variables.saved_auto_increment_offset;\n    thd->variables.auto_increment_increment=\n      thd->variables.saved_auto_increment_increment;\n    thd->variables.auto_increment_offset=\n      thd->variables.saved_auto_increment_offset;\n  }\n  return false;\n}\n\nstatic Sys_var_mybool Sys_wsrep_auto_increment_control(\n       \"wsrep_auto_increment_control\", \"To automatically control the \"\n       \"assignment of autoincrement variables\",\n       GLOBAL_VAR(wsrep_auto_increment_control), \n       CMD_LINE(OPT_ARG), DEFAULT(TRUE),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(update_wsrep_auto_increment_control));\n\nstatic Sys_var_mybool Sys_wsrep_drupal_282555_workaround(\n       \"wsrep_drupal_282555_workaround\", \"Enable a workaround to handle the \"\n       \"cases where inserting a DEFAULT value into an auto-increment column \"\n       \"could fail with duplicate key error\",\n       GLOBAL_VAR(wsrep_drupal_282555_workaround),\n       CMD_LINE(OPT_ARG), DEFAULT(FALSE));\n\nstatic Sys_var_charptr sys_wsrep_sst_method(\n       \"wsrep_sst_method\", \"State snapshot transfer method\",\n       GLOBAL_VAR(wsrep_sst_method),CMD_LINE(REQUIRED_ARG),\n       IN_SYSTEM_CHARSET, DEFAULT(WSREP_SST_DEFAULT), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(wsrep_sst_method_check));\n\nstatic Sys_var_charptr Sys_wsrep_sst_receive_address( \n       \"wsrep_sst_receive_address\", \"Address where node is waiting for \"\n       \"SST contact\", \n       GLOBAL_VAR(wsrep_sst_receive_address),CMD_LINE(REQUIRED_ARG),\n       IN_SYSTEM_CHARSET, DEFAULT(WSREP_SST_ADDRESS_AUTO), NO_MUTEX_GUARD,\n       NOT_IN_BINLOG,\n       ON_CHECK(wsrep_sst_receive_address_check),\n       ON_UPDATE(wsrep_sst_receive_address_update)); \n\nstatic Sys_var_charptr Sys_wsrep_sst_auth(\n       \"wsrep_sst_auth\", \"Authentication for SST connection\",\n       PREALLOCATED GLOBAL_VAR(wsrep_sst_auth), CMD_LINE(REQUIRED_ARG),\n       IN_SYSTEM_CHARSET, DEFAULT(NULL), NO_MUTEX_GUARD,\n       NOT_IN_BINLOG,\n       ON_CHECK(wsrep_sst_auth_check),\n       ON_UPDATE(wsrep_sst_auth_update)); \n\nstatic Sys_var_charptr Sys_wsrep_sst_donor(\n       \"wsrep_sst_donor\", \"preferred donor node for the SST\",\n       GLOBAL_VAR(wsrep_sst_donor),CMD_LINE(REQUIRED_ARG),\n       IN_SYSTEM_CHARSET, DEFAULT(\"\"), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(wsrep_sst_donor_check),\n       ON_UPDATE(wsrep_sst_donor_update)); \n\nstatic Sys_var_mybool Sys_wsrep_sst_donor_rejects_queries(\n       \"wsrep_sst_donor_rejects_queries\", \"Reject client queries \"\n       \"when donating state snapshot transfer\", \n       GLOBAL_VAR(wsrep_sst_donor_rejects_queries), \n       CMD_LINE(OPT_ARG), DEFAULT(FALSE));\n\nstatic Sys_var_mybool Sys_wsrep_on (\n       \"wsrep_on\", \"To enable wsrep replication \",\n       SESSION_VAR(wsrep_on), \n       CMD_LINE(OPT_ARG), DEFAULT(FALSE),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(wsrep_on_check),\n       ON_UPDATE(wsrep_on_update));\n\nstatic Sys_var_charptr Sys_wsrep_start_position (\n       \"wsrep_start_position\", \"global transaction position to start from \",\n       PREALLOCATED GLOBAL_VAR(wsrep_start_position), \n       CMD_LINE(REQUIRED_ARG),\n       IN_SYSTEM_CHARSET, DEFAULT(WSREP_START_POSITION_ZERO),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(wsrep_start_position_check), \n       ON_UPDATE(wsrep_start_position_update));\n\nstatic Sys_var_ulong Sys_wsrep_max_ws_size (\n       \"wsrep_max_ws_size\", \"Max write set size (bytes)\",\n       GLOBAL_VAR(wsrep_max_ws_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1024, WSREP_MAX_WS_SIZE), DEFAULT(WSREP_MAX_WS_SIZE),\n       BLOCK_SIZE(1), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(wsrep_max_ws_size_check), ON_UPDATE(wsrep_max_ws_size_update));\n\nstatic Sys_var_ulong Sys_wsrep_max_ws_rows (\n       \"wsrep_max_ws_rows\", \"Max number of rows in write set\",\n       GLOBAL_VAR(wsrep_max_ws_rows), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, 1048576), DEFAULT(0), BLOCK_SIZE(1));\n\nstatic Sys_var_charptr Sys_wsrep_notify_cmd(\n       \"wsrep_notify_cmd\", \"\",\n       GLOBAL_VAR(wsrep_notify_cmd),CMD_LINE(REQUIRED_ARG),\n       IN_SYSTEM_CHARSET, DEFAULT(\"\"));\n\nstatic Sys_var_mybool Sys_wsrep_certify_nonPK(\n       \"wsrep_certify_nonPK\", \"Certify tables with no primary key\",\n       GLOBAL_VAR(wsrep_certify_nonPK), \n       CMD_LINE(OPT_ARG), DEFAULT(TRUE));\n\nstatic const char *wsrep_certification_rules_names[]= { \"strict\", \"optimized\", NullS };\nstatic Sys_var_enum Sys_wsrep_certification_rules(\n       \"wsrep_certification_rules\",\n       \"Certification rules to use in the cluster. Possible values are: \"\n       \"\\\"strict\\\": stricter rules that could result in more certification \"\n       \"failures. \"\n       \"\\\"optimized\\\": relaxed rules that allow more concurrency and \"\n       \"cause less certification failures.\",\n       GLOBAL_VAR(wsrep_certification_rules), CMD_LINE(REQUIRED_ARG),\n       wsrep_certification_rules_names, DEFAULT(WSREP_CERTIFICATION_RULES_STRICT),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(0));\n\nstatic Sys_var_mybool Sys_wsrep_causal_reads(\n       \"wsrep_causal_reads\", \"Setting this variable is equivalent \"\n       \"to setting wsrep_sync_wait READ flag\",\n       SESSION_VAR(wsrep_causal_reads),\n       CMD_LINE(OPT_ARG, OPT_WSREP_CAUSAL_READS), DEFAULT(FALSE),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(wsrep_causal_reads_update),\n       DEPRECATED(\"'@@wsrep_sync_wait=1'\"));\n\nstatic Sys_var_uint Sys_wsrep_sync_wait(\n       \"wsrep_sync_wait\", \"Ensure \\\"synchronous\\\" read view before executing \"\n       \"an operation of the type specified by bitmask: 1 - READ(includes \"\n       \"SELECT, SHOW and BEGIN/START TRANSACTION); 2 - UPDATE and DELETE; 4 - \"\n       \"INSERT and REPLACE\",\n       SESSION_VAR(wsrep_sync_wait), CMD_LINE(OPT_ARG, OPT_WSREP_SYNC_WAIT),\n       VALID_RANGE(WSREP_SYNC_WAIT_NONE, WSREP_SYNC_WAIT_MAX),\n       DEFAULT(WSREP_SYNC_WAIT_NONE), BLOCK_SIZE(1),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(wsrep_sync_wait_update));\n\nstatic const char *wsrep_OSU_method_names[]= { \"TOI\", \"RSU\", NullS };\nstatic Sys_var_enum Sys_wsrep_OSU_method(\n       \"wsrep_OSU_method\", \"Method for Online Schema Upgrade\",\n       SESSION_VAR(wsrep_OSU_method), CMD_LINE(OPT_ARG),\n       wsrep_OSU_method_names, DEFAULT(WSREP_OSU_TOI));\n\nstatic PolyLock_mutex PLock_wsrep_desync(&LOCK_wsrep_desync);\nstatic Sys_var_mybool Sys_wsrep_desync (\n       \"wsrep_desync\", \"To desynchronize the node from the cluster\",\n       GLOBAL_VAR(wsrep_desync), \n       CMD_LINE(OPT_ARG), DEFAULT(FALSE),\n       &PLock_wsrep_desync, NOT_IN_BINLOG,\n       ON_CHECK(wsrep_desync_check),\n       ON_UPDATE(wsrep_desync_update));\n\nstatic const char *wsrep_reject_queries_names[]= { \"NONE\", \"ALL\", \"ALL_KILL\", NullS };\nstatic Sys_var_enum Sys_wsrep_reject_queries(\n       \"wsrep_reject_queries\", \"Variable to set to reject queries\",\n       GLOBAL_VAR(wsrep_reject_queries), CMD_LINE(OPT_ARG),\n       wsrep_reject_queries_names, DEFAULT(WSREP_REJECT_NONE),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(wsrep_reject_queries_update));\n\nstatic const char *wsrep_binlog_format_names[]=\n       {\"MIXED\", \"STATEMENT\", \"ROW\", \"NONE\", NullS};\nstatic Sys_var_enum Sys_wsrep_forced_binlog_format(\n       \"wsrep_forced_binlog_format\", \"binlog format to take effect over user's choice\",\n       GLOBAL_VAR(wsrep_forced_binlog_format), CMD_LINE(REQUIRED_ARG),\n       wsrep_binlog_format_names, DEFAULT(BINLOG_FORMAT_UNSPEC));\n\nstatic Sys_var_mybool Sys_wsrep_recover_datadir(\n       \"wsrep_recover\", \"Recover database state after crash and exit\",\n       READ_ONLY GLOBAL_VAR(wsrep_recovery),\n       CMD_LINE(OPT_ARG), DEFAULT(FALSE));\n\nstatic Sys_var_mybool Sys_wsrep_replicate_myisam(\n       \"wsrep_replicate_myisam\", \"To enable myisam replication\",\n       GLOBAL_VAR(wsrep_replicate_myisam), CMD_LINE(OPT_ARG), DEFAULT(FALSE));\n\nstatic Sys_var_mybool Sys_wsrep_log_conflicts(\n       \"wsrep_log_conflicts\", \"To log multi-master conflicts\",\n       GLOBAL_VAR(wsrep_log_conflicts), CMD_LINE(OPT_ARG), DEFAULT(FALSE));\n\nstatic Sys_var_ulong Sys_wsrep_mysql_replication_bundle(\n      \"wsrep_mysql_replication_bundle\", \"mysql replication group commit \",\n       GLOBAL_VAR(wsrep_mysql_replication_bundle), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, 1000), DEFAULT(0), BLOCK_SIZE(1));\n\nstatic Sys_var_mybool Sys_wsrep_load_data_splitting(\n       \"wsrep_load_data_splitting\", \"To commit LOAD DATA \"\n       \"transaction after every 10K rows inserted (deprecated)\",\n       GLOBAL_VAR(wsrep_load_data_splitting), \n       CMD_LINE(OPT_ARG), DEFAULT(0), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(0), ON_UPDATE(0), DEPRECATED(\"\"));\n\nstatic Sys_var_mybool Sys_wsrep_slave_FK_checks(\n       \"wsrep_slave_FK_checks\", \"Should slave thread do \"\n       \"foreign key constraint checks\",\n       GLOBAL_VAR(wsrep_slave_FK_checks), \n       CMD_LINE(OPT_ARG), DEFAULT(TRUE));\n\nstatic Sys_var_mybool Sys_wsrep_slave_UK_checks(\n       \"wsrep_slave_UK_checks\", \"Should slave thread do \"\n       \"secondary index uniqueness checks\",\n       GLOBAL_VAR(wsrep_slave_UK_checks), \n       CMD_LINE(OPT_ARG), DEFAULT(FALSE));\n\nstatic Sys_var_mybool Sys_wsrep_restart_slave(\n       \"wsrep_restart_slave\", \"Should MariaDB slave be restarted automatically, when node joins back to cluster\",\n       GLOBAL_VAR(wsrep_restart_slave), CMD_LINE(OPT_ARG), DEFAULT(FALSE));\n\nstatic Sys_var_ulonglong Sys_wsrep_trx_fragment_size(\n      \"wsrep_trx_fragment_size\",\n      \"Size of transaction fragments for streaming replication (measured in \"\n      \"units of 'wsrep_trx_fragment_unit')\",\n      SESSION_VAR(wsrep_trx_fragment_size), CMD_LINE(REQUIRED_ARG),\n      VALID_RANGE(0, WSREP_MAX_WS_SIZE), DEFAULT(0), BLOCK_SIZE(1),\n      NO_MUTEX_GUARD, NOT_IN_BINLOG,\n      ON_CHECK(wsrep_trx_fragment_size_check),\n      ON_UPDATE(wsrep_trx_fragment_size_update));\n\nextern const char *wsrep_fragment_units[];\n\nstatic Sys_var_enum Sys_wsrep_trx_fragment_unit(\n      \"wsrep_trx_fragment_unit\",\n      \"Unit for streaming replication transaction fragments' size: bytes, \"\n      \"rows, statements\",\n      SESSION_VAR(wsrep_trx_fragment_unit), CMD_LINE(REQUIRED_ARG),\n      wsrep_fragment_units,\n      DEFAULT(WSREP_FRAG_BYTES),\n      NO_MUTEX_GUARD, NOT_IN_BINLOG,\n      ON_CHECK(0),\n      ON_UPDATE(wsrep_trx_fragment_unit_update));\n\nextern const char *wsrep_SR_store_types[];\nstatic Sys_var_enum Sys_wsrep_SR_store(\n       \"wsrep_SR_store\", \"Storage for streaming replication fragments\",\n       READ_ONLY GLOBAL_VAR(wsrep_SR_store_type), CMD_LINE(REQUIRED_ARG),\n       wsrep_SR_store_types, DEFAULT(WSREP_SR_STORE_TABLE));\n\nstatic Sys_var_mybool Sys_wsrep_dirty_reads(\n       \"wsrep_dirty_reads\",\n       \"Allow reads even when the node is not in the primary component.\",\n       SESSION_VAR(wsrep_dirty_reads), CMD_LINE(OPT_ARG),\n       DEFAULT(FALSE));\n\nstatic Sys_var_uint Sys_wsrep_ignore_apply_errors (\n       \"wsrep_ignore_apply_errors\", \"Ignore replication errors\",\n       GLOBAL_VAR(wsrep_ignore_apply_errors), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(WSREP_IGNORE_ERRORS_NONE, WSREP_IGNORE_ERRORS_MAX),\n       DEFAULT(7), BLOCK_SIZE(1));\n\nstatic Sys_var_uint Sys_wsrep_gtid_domain_id(\n       \"wsrep_gtid_domain_id\", \"When wsrep_gtid_mode is set, this value is \"\n       \"used as gtid_domain_id for galera transactions and also copied to the \"\n       \"joiner nodes during state transfer. It is ignored, otherwise.\",\n       GLOBAL_VAR(wsrep_gtid_domain_id), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, UINT_MAX32), DEFAULT(0), BLOCK_SIZE(1));\n\nstatic Sys_var_mybool Sys_wsrep_gtid_mode(\n       \"wsrep_gtid_mode\", \"Automatically update the (joiner) node's \"\n       \"wsrep_gtid_domain_id value with that of donor's (received during \"\n       \"state transfer) and use it in place of gtid_domain_id for all galera \"\n       \"transactions. When OFF (default), wsrep_gtid_domain_id is simply \"\n       \"ignored (backward compatibility).\",\n       GLOBAL_VAR(wsrep_gtid_mode), CMD_LINE(OPT_ARG), DEFAULT(FALSE));\n\nstatic char *wsrep_patch_version_ptr;\nstatic Sys_var_charptr Sys_wsrep_patch_version(\n       \"wsrep_patch_version\", \"Wsrep patch version, for example wsrep_25.10.\",\n       READ_ONLY GLOBAL_VAR(wsrep_patch_version_ptr), CMD_LINE_HELP_ONLY,\n       IN_SYSTEM_CHARSET, DEFAULT(WSREP_PATCH_VERSION));\n\n#endif /* WITH_WSREP */\n\nstatic bool fix_host_cache_size(sys_var *, THD *, enum_var_type)\n{\n  hostname_cache_resize((uint) host_cache_size);\n  return false;\n}\n\nstatic Sys_var_ulong Sys_host_cache_size(\n       \"host_cache_size\",\n       \"How many host names should be cached to avoid resolving.\",\n       AUTO_SET GLOBAL_VAR(host_cache_size),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, 65536),\n       DEFAULT(HOST_CACHE_SIZE),\n       BLOCK_SIZE(1),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(fix_host_cache_size));\n\nvio_keepalive_opts opt_vio_keepalive;\n\nstatic Sys_var_int Sys_keepalive_time(\n       \"tcp_keepalive_time\",\n       \"Timeout, in milliseconds, with no activity until the first TCP keep-alive packet is sent.\"\n       \"If set to 0, system dependent default is used.\",\n       AUTO_SET GLOBAL_VAR(opt_vio_keepalive.idle),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, INT_MAX32/1000), DEFAULT(0),\n       BLOCK_SIZE(1));\n\nstatic Sys_var_int Sys_keepalive_interval(\n       \"tcp_keepalive_interval\",\n       \"The interval, in seconds, between when successive keep-alive packets are sent if no acknowledgement is received.\"\n       \"If set to 0, system dependent default is used.\",\n       AUTO_SET GLOBAL_VAR(opt_vio_keepalive.interval),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, INT_MAX32/1000), DEFAULT(0),\n       BLOCK_SIZE(1));\n\nstatic Sys_var_int Sys_keepalive_probes(\n       \"tcp_keepalive_probes\",\n       \"The number of unacknowledged probes to send before considering the connection dead and notifying the application layer.\"\n       \"If set to 0, system dependent default is used.\",\n       AUTO_SET GLOBAL_VAR(opt_vio_keepalive.probes),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, INT_MAX32/1000), DEFAULT(0),\n       BLOCK_SIZE(1));\n\n\nstatic bool update_tcp_nodelay(sys_var *self, THD *thd,\n  enum_var_type type)\n{\n  DBUG_ASSERT(thd);\n\n  Vio *vio = thd->net.vio;\n  if (vio)\n    return (MY_TEST(vio_nodelay(vio, thd->variables.tcp_nodelay)));\n\n  return false;\n}\n\nstatic Sys_var_mybool Sys_tcp_nodelay(\n       \"tcp_nodelay\",\n       \"Set option TCP_NODELAY (disable Nagle's algorithm) on socket\",\n       SESSION_VAR(tcp_nodelay), CMD_LINE(OPT_ARG),\n       DEFAULT(TRUE),NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(check_session_only_variable),\n       ON_UPDATE(update_tcp_nodelay));\n\nstatic Sys_var_charptr Sys_ignore_db_dirs(\n       \"ignore_db_dirs\",\n       \"Specifies a directory to add to the ignore list when collecting \"\n       \"database names from the datadir. Put a blank argument to reset \"\n       \"the list accumulated so far.\",\n       READ_ONLY GLOBAL_VAR(opt_ignore_db_dirs), \n       CMD_LINE(REQUIRED_ARG, OPT_IGNORE_DB_DIRECTORY),\n       IN_FS_CHARSET, DEFAULT(0));\n\nstatic Sys_var_ulong Sys_sp_cache_size(\n       \"stored_program_cache\",\n       \"The soft upper limit for number of cached stored routines for \"\n       \"one connection.\",\n       GLOBAL_VAR(stored_program_cache_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, 512 * 1024), DEFAULT(256), BLOCK_SIZE(1));\n\nexport const char *plugin_maturity_names[]=\n{ \"unknown\", \"experimental\", \"alpha\", \"beta\", \"gamma\", \"stable\", 0 };\nstatic Sys_var_enum Sys_plugin_maturity(\n       \"plugin_maturity\",\n       \"The lowest desirable plugin maturity. \"\n       \"Plugins less mature than that will not be installed or loaded\",\n       READ_ONLY GLOBAL_VAR(plugin_maturity), CMD_LINE(REQUIRED_ARG),\n       plugin_maturity_names,\n       DEFAULT(SERVER_MATURITY_LEVEL > 0 ?\n               SERVER_MATURITY_LEVEL - 1 : SERVER_MATURITY_LEVEL));\n\nstatic Sys_var_ulong Sys_deadlock_search_depth_short(\n       \"deadlock_search_depth_short\",\n       \"Short search depth for the two-step deadlock detection\",\n       SESSION_VAR(wt_deadlock_search_depth_short), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, 32), DEFAULT(4), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_deadlock_search_depth_long(\n       \"deadlock_search_depth_long\",\n       \"Long search depth for the two-step deadlock detection\",\n       SESSION_VAR(wt_deadlock_search_depth_long), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, 33), DEFAULT(15), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_deadlock_timeout_depth_short(\n       \"deadlock_timeout_short\",\n       \"Short timeout for the two-step deadlock detection (in microseconds)\",\n       SESSION_VAR(wt_timeout_short), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, UINT_MAX), DEFAULT(10000), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_deadlock_timeout_depth_long(\n       \"deadlock_timeout_long\",\n       \"Long timeout for the two-step deadlock detection (in microseconds)\",\n       SESSION_VAR(wt_timeout_long), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, UINT_MAX), DEFAULT(50000000), BLOCK_SIZE(1));\n\nstatic Sys_var_uint Sys_extra_port(\n       \"extra_port\",\n       \"Extra port number to use for tcp connections in a \"\n       \"one-thread-per-connection manner. 0 means don't use another port\",\n       READ_ONLY GLOBAL_VAR(mysqld_extra_port), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, UINT_MAX32), DEFAULT(0), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_extra_max_connections(\n       \"extra_max_connections\", \"The number of connections on extra-port\",\n       GLOBAL_VAR(extra_max_connections), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, 100000), DEFAULT(1), BLOCK_SIZE(1), NO_MUTEX_GUARD,\n       NOT_IN_BINLOG, ON_CHECK(0), ON_UPDATE(fix_max_connections));\n\n#ifdef SAFE_MUTEX\nstatic Sys_var_mybool Sys_mutex_deadlock_detector(\n       \"debug_mutex_deadlock_detector\", \"Enable checking of wrong mutex usage\",\n       READ_ONLY GLOBAL_VAR(safe_mutex_deadlock_detector),\n       CMD_LINE(OPT_ARG), DEFAULT(TRUE));\n#endif\n\nstatic Sys_var_keycache Sys_key_cache_segments(\n       \"key_cache_segments\", \"The number of segments in a key cache\",\n       KEYCACHE_VAR(param_partitions),\n       CMD_LINE(REQUIRED_ARG, OPT_KEY_CACHE_PARTITIONS),\n       VALID_RANGE(0, MAX_KEY_CACHE_PARTITIONS),\n       DEFAULT(DEFAULT_KEY_CACHE_PARTITIONS),\n       BLOCK_SIZE(1), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(repartition_keycache));\n\nstatic const char *log_slow_filter_names[]= \n{\n  \"admin\", \"filesort\", \"filesort_on_disk\", \"filesort_priority_queue\",\n  \"full_join\", \"full_scan\", \"not_using_index\", \"query_cache\",\n  \"query_cache_miss\", \"tmp_table\", \"tmp_table_on_disk\", 0\n};\n\n\nstatic Sys_var_set Sys_log_slow_filter(\n       \"log_slow_filter\",\n       \"Log only certain types of queries to the slow log. If variable empty alll kind of queries are logged.  All types are bound by slow_query_time, except 'not_using_index' which is always logged if enabled\",\n       SESSION_VAR(log_slow_filter), CMD_LINE(REQUIRED_ARG),\n       log_slow_filter_names,\n       /* by default we log all queries except 'not_using_index' */\n       DEFAULT(my_set_bits(array_elements(log_slow_filter_names)-1) &\n               ~QPLAN_NOT_USING_INDEX));\n\nstatic const char *log_slow_disabled_statements_names[]=\n{ \"admin\", \"call\", \"slave\", \"sp\", 0 };\n\nstatic const char *log_disabled_statements_names[]=\n{ \"slave\", \"sp\", 0 };\n\nstatic Sys_var_set Sys_log_slow_disabled_statements(\n       \"log_slow_disabled_statements\",\n       \"Don't log certain types of statements to slow log\",\n       SESSION_VAR(log_slow_disabled_statements), CMD_LINE(REQUIRED_ARG),\n       log_slow_disabled_statements_names,\n       DEFAULT(LOG_SLOW_DISABLE_SP));\n\nstatic Sys_var_set Sys_log_disabled_statements(\n       \"log_disabled_statements\",\n       \"Don't log certain types of statements to general log\",\n       SESSION_VAR(log_disabled_statements), CMD_LINE(REQUIRED_ARG),\n       log_disabled_statements_names,\n       DEFAULT(LOG_DISABLE_SP),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(check_has_super));\n\nstatic const char *default_regex_flags_names[]= \n{\n  \"DOTALL\",    // (?s)  . matches anything including NL\n  \"DUPNAMES\",  // (?J)  Allow duplicate names for subpatterns\n  \"EXTENDED\",  // (?x)  Ignore white space and # comments\n  \"EXTRA\",     // (?X)  extra features (e.g. error on unknown escape character)\n  \"MULTILINE\", // (?m)  ^ and $ match newlines within data\n  \"UNGREEDY\",  // (?U)  Invert greediness of quantifiers\n  0\n};\nstatic const int default_regex_flags_to_pcre[]=\n{\n  PCRE_DOTALL,\n  PCRE_DUPNAMES,\n  PCRE_EXTENDED,\n  PCRE_EXTRA,\n  PCRE_MULTILINE,\n  PCRE_UNGREEDY,\n  0\n};\nint default_regex_flags_pcre(const THD *thd)\n{\n  ulonglong src= thd->variables.default_regex_flags;\n  int i, res;\n  for (i= res= 0; default_regex_flags_to_pcre[i]; i++)\n  {\n    if (src & (1ULL << i))\n      res|= default_regex_flags_to_pcre[i];\n  }\n  return res;\n}\nstatic Sys_var_set Sys_default_regex_flags(\n       \"default_regex_flags\",\n       \"Default flags for the regex library\",\n       SESSION_VAR(default_regex_flags), CMD_LINE(REQUIRED_ARG),\n       default_regex_flags_names,\n       DEFAULT(0));\n\nstatic Sys_var_ulong Sys_log_slow_rate_limit(\n       \"log_slow_rate_limit\",\n       \"Write to slow log every #th slow query. Set to 1 to log everything. \"\n       \"Increase it to reduce the size of the slow or the performance impact \"\n       \"of slow logging\",\n       SESSION_VAR(log_slow_rate_limit), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1, UINT_MAX), DEFAULT(1), BLOCK_SIZE(1));\n\nstatic const char *log_slow_verbosity_names[]= { \"innodb\", \"query_plan\", \n                                                 \"explain\", 0 };\nstatic Sys_var_set Sys_log_slow_verbosity(\n       \"log_slow_verbosity\",\n       \"Verbosity level for the slow log\",\n       SESSION_VAR(log_slow_verbosity), CMD_LINE(REQUIRED_ARG),\n       log_slow_verbosity_names, DEFAULT(LOG_SLOW_VERBOSITY_INIT));\n\nstatic Sys_var_ulong Sys_join_cache_level(\n       \"join_cache_level\",\n       \"Controls what join operations can be executed with join buffers. Odd \"\n       \"numbers are used for plain join buffers while even numbers are used \"\n       \"for linked buffers\",\n       SESSION_VAR(join_cache_level), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, 8), DEFAULT(2), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_mrr_buffer_size(\n       \"mrr_buffer_size\",\n       \"Size of buffer to use when using MRR with range access\",\n       SESSION_VAR(mrr_buff_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(IO_SIZE*2, INT_MAX32), DEFAULT(256*1024), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_rowid_merge_buff_size(\n       \"rowid_merge_buff_size\",\n       \"The size of the buffers used [NOT] IN evaluation via partial matching\",\n       SESSION_VAR(rowid_merge_buff_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, LONG_MAX), DEFAULT(8*1024*1024),\n       BLOCK_SIZE(1));\n\nstatic Sys_var_mybool Sys_userstat(\n       \"userstat\",\n       \"Enables statistics gathering for USER_STATISTICS, CLIENT_STATISTICS, \"\n       \"INDEX_STATISTICS and TABLE_STATISTICS tables in the INFORMATION_SCHEMA\",\n       GLOBAL_VAR(opt_userstat_running),\n       CMD_LINE(OPT_ARG), DEFAULT(FALSE));\n\nstatic Sys_var_mybool Sys_binlog_annotate_row_events(\n       \"binlog_annotate_row_events\",\n       \"Tells the master to annotate RBR events with the statement that \"\n       \"caused these events\",\n       SESSION_VAR(binlog_annotate_row_events), CMD_LINE(OPT_ARG),\n       DEFAULT(TRUE));\n\n#ifdef HAVE_REPLICATION\nstatic Sys_var_mybool Sys_replicate_annotate_row_events(\n       \"replicate_annotate_row_events\",\n       \"Tells the slave to write annotate rows events received from the master \"\n       \"to its own binary log. Ignored if log_slave_updates is not set\",\n       READ_ONLY GLOBAL_VAR(opt_replicate_annotate_row_events),\n       CMD_LINE(OPT_ARG), DEFAULT(TRUE));\n#endif\n\nstatic Sys_var_ulonglong Sys_join_buffer_space_limit(\n       \"join_buffer_space_limit\",\n       \"The limit of the space for all join buffers used by a query\",\n       SESSION_VAR(join_buff_space_limit), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(2048, ULONGLONG_MAX), DEFAULT(16*128*1024),\n       BLOCK_SIZE(2048));\n\nstatic Sys_var_ulong Sys_progress_report_time(\n       \"progress_report_time\",\n       \"Seconds between sending progress reports to the client for \"\n       \"time-consuming statements. Set to 0 to disable progress reporting.\",\n       SESSION_VAR(progress_report_time), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, UINT_MAX), DEFAULT(5), BLOCK_SIZE(1));\n\nconst char *use_stat_tables_modes[] =\n           {\"NEVER\", \"COMPLEMENTARY\", \"PREFERABLY\",\n           \"COMPLEMENTARY_FOR_QUERIES\", \"PREFERABLY_FOR_QUERIES\", 0};\nstatic Sys_var_enum Sys_optimizer_use_stat_tables(\n       \"use_stat_tables\",\n       \"Specifies how to use system statistics tables\",\n       SESSION_VAR(use_stat_tables), CMD_LINE(REQUIRED_ARG),\n       use_stat_tables_modes, DEFAULT(4));\n\nstatic Sys_var_ulong Sys_histogram_size(\n       \"histogram_size\",\n       \"Number of bytes used for a histogram. \"\n       \"If set to 0, no histograms are created by ANALYZE.\",\n       SESSION_VAR(histogram_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, 255), DEFAULT(254), BLOCK_SIZE(1));\n\nextern const char *histogram_types[];\nstatic Sys_var_enum Sys_histogram_type(\n       \"histogram_type\",\n       \"Specifies type of the histograms created by ANALYZE. \"\n       \"Possible values are: \"\n       \"SINGLE_PREC_HB - single precision height-balanced, \"\n       \"DOUBLE_PREC_HB - double precision height-balanced.\",\n       SESSION_VAR(histogram_type), CMD_LINE(REQUIRED_ARG),\n       histogram_types, DEFAULT(1));\n\nstatic Sys_var_mybool Sys_no_thread_alarm(\n       \"debug_no_thread_alarm\",\n       \"Disable system thread alarm calls. Disabling it may be useful \"\n       \"in debugging or testing, never do it in production\",\n       READ_ONLY GLOBAL_VAR(my_disable_thr_alarm), CMD_LINE(OPT_ARG),\n       DEFAULT(FALSE));\n\nstatic Sys_var_mybool Sys_query_cache_strip_comments(\n       \"query_cache_strip_comments\",\n       \"Strip all comments from a query before storing it \"\n       \"in the query cache\",\n       SESSION_VAR(query_cache_strip_comments), CMD_LINE(OPT_ARG),\n       DEFAULT(FALSE));\n\nstatic ulonglong in_transaction(THD *thd)\n{\n  return MY_TEST(thd->in_active_multi_stmt_transaction());\n}\nstatic Sys_var_session_special Sys_in_transaction(\n       \"in_transaction\", \"Whether there is an active transaction\",\n       READ_ONLY sys_var::ONLY_SESSION, NO_CMD_LINE,\n       VALID_RANGE(0, 1), BLOCK_SIZE(1), NO_MUTEX_GUARD,\n       NOT_IN_BINLOG, ON_CHECK(0), ON_UPDATE(0), ON_READ(in_transaction));\n\n#ifndef DBUG_OFF\nstatic Sys_var_ulong Sys_debug_binlog_fsync_sleep(\n       \"debug_binlog_fsync_sleep\",\n       \"Extra sleep (in microseconds) to add to binlog fsync(), for debugging\",\n       GLOBAL_VAR(opt_binlog_dbug_fsync_sleep),\n       CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, UINT_MAX), DEFAULT(0), BLOCK_SIZE(1));\n#endif\n\nstatic Sys_var_harows Sys_expensive_subquery_limit(\n       \"expensive_subquery_limit\",\n       \"The maximum number of rows a subquery may examine in order to be \"\n       \"executed during optimization and used for constant optimization\",\n       SESSION_VAR(expensive_subquery_limit), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, HA_POS_ERROR), DEFAULT(100), BLOCK_SIZE(1));\n\nstatic Sys_var_mybool Sys_encrypt_tmp_disk_tables(\n       \"encrypt_tmp_disk_tables\",\n       \"Encrypt temporary on-disk tables (created as part of query execution)\",\n       GLOBAL_VAR(encrypt_tmp_disk_tables),\n       CMD_LINE(OPT_ARG), DEFAULT(FALSE));\n\nstatic Sys_var_mybool Sys_encrypt_tmp_files(\n       \"encrypt_tmp_files\",\n       \"Encrypt temporary files (created for filesort, binary log cache, etc)\",\n       READ_ONLY GLOBAL_VAR(encrypt_tmp_files),\n       CMD_LINE(OPT_ARG), DEFAULT(FALSE));\n\nstatic Sys_var_mybool Sys_binlog_encryption(\n       \"encrypt_binlog\", \"Encrypt binary logs (including relay logs)\",\n       READ_ONLY GLOBAL_VAR(encrypt_binlog), CMD_LINE(OPT_ARG),\n       DEFAULT(FALSE));\n\nstatic const char *binlog_row_image_names[]= {\"MINIMAL\", \"NOBLOB\", \"FULL\", NullS};\nstatic Sys_var_enum Sys_binlog_row_image(\n       \"binlog_row_image\",\n       \"Controls whether rows should be logged in 'FULL', 'NOBLOB' or \"\n       \"'MINIMAL' formats. 'FULL', means that all columns in the before \"\n       \"and after image are logged. 'NOBLOB', means that mysqld avoids logging \"\n       \"blob columns whenever possible (eg, blob column was not changed or \"\n       \"is not part of primary key). 'MINIMAL', means that a PK equivalent (PK \"\n       \"columns or full row if there is no PK in the table) is logged in the \"\n       \"before image, and only changed columns are logged in the after image. \"\n       \"(Default: FULL).\",\n       SESSION_VAR(binlog_row_image), CMD_LINE(REQUIRED_ARG),\n       binlog_row_image_names, DEFAULT(BINLOG_ROW_IMAGE_FULL));\n\nstatic bool check_pseudo_slave_mode(sys_var *self, THD *thd, set_var *var)\n{\n  longlong previous_val= thd->variables.pseudo_slave_mode;\n  longlong val= (longlong) var->save_result.ulonglong_value;\n  bool rli_fake= false;\n\n#ifndef EMBEDDED_LIBRARY\n  rli_fake= thd->rli_fake ? true : false;\n#endif\n\n  if (rli_fake)\n  {\n    if (!val)\n    {\n#ifndef EMBEDDED_LIBRARY\n      delete thd->rli_fake;\n      thd->rli_fake= NULL;\n      delete thd->rgi_fake;\n      thd->rgi_fake= NULL;\n#endif\n    }\n    else if (previous_val && val)\n      goto ineffective;\n    else if (!previous_val && val)\n      push_warning(thd, Sql_condition::WARN_LEVEL_WARN,\n                   ER_WRONG_VALUE_FOR_VAR,\n                   \"'pseudo_slave_mode' is already ON.\");\n  }\n  else\n  {\n    if (!previous_val && !val)\n      goto ineffective;\n    else if (previous_val && !val)\n      push_warning(thd, Sql_condition::WARN_LEVEL_WARN,\n                   ER_WRONG_VALUE_FOR_VAR,\n                   \"Slave applier execution mode not active, \"\n                   \"statement ineffective.\");\n  }\n  goto end;\n\nineffective:\n  push_warning(thd, Sql_condition::WARN_LEVEL_WARN,\n               ER_WRONG_VALUE_FOR_VAR,\n               \"'pseudo_slave_mode' change was ineffective.\");\n\nend:\n  return FALSE;\n}\nstatic Sys_var_mybool Sys_pseudo_slave_mode(\n       \"pseudo_slave_mode\",\n       \"SET pseudo_slave_mode= 0,1 are commands that mysqlbinlog \"\n       \"adds to beginning and end of binary log dumps. While zero \"\n       \"value indeed disables, the actual enabling of the slave \"\n       \"applier execution mode is done implicitly when a \"\n       \"Format_description_event is sent through the session.\",\n       SESSION_ONLY(pseudo_slave_mode), NO_CMD_LINE, DEFAULT(FALSE),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(check_pseudo_slave_mode));\n\nstatic Sys_var_mybool Sys_mysql56_temporal_format(\n       \"mysql56_temporal_format\",\n       \"Use MySQL-5.6 (instead of MariaDB-5.3) format for TIME, DATETIME, TIMESTAMP columns.\",\n       GLOBAL_VAR(opt_mysql56_temporal_format),\n       CMD_LINE(OPT_ARG), DEFAULT(TRUE));\n\nstatic Sys_var_mybool Sys_strict_password_validation(\n       \"strict_password_validation\",\n       \"When password validation plugins are enabled, reject passwords \"\n       \"that cannot be validated (passwords specified as a hash)\",\n       GLOBAL_VAR(strict_password_validation),\n       CMD_LINE(OPT_ARG), DEFAULT(TRUE));\n\n#ifdef HAVE_MMAP\nstatic Sys_var_ulong Sys_log_tc_size(\n       \"log_tc_size\",\n       \"Size of transaction coordinator log.\",\n       READ_ONLY GLOBAL_VAR(opt_tc_log_size),\n       CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(my_getpagesize() * 3, ULONG_MAX),\n       DEFAULT(my_getpagesize() * 6),\n       BLOCK_SIZE(my_getpagesize()));\n#endif\n\nstatic Sys_var_ulonglong Sys_max_thread_mem(\n       \"max_session_mem_used\", \"Amount of memory a single user session \"\n       \"is allowed to allocate. This limits the value of the \"\n       \"session variable MEM_USED\", SESSION_VAR(max_mem_used),\n       CMD_LINE(REQUIRED_ARG), VALID_RANGE(8192,  ULONGLONG_MAX),\n       DEFAULT(LONGLONG_MAX), BLOCK_SIZE(1));\n\n#ifndef EMBEDDED_LIBRARY\n\nstatic Sys_var_sesvartrack Sys_track_session_sys_vars(\n       \"session_track_system_variables\",\n       \"Track changes in registered system variables. \",\n       CMD_LINE(REQUIRED_ARG), IN_SYSTEM_CHARSET,\n       DEFAULT(\"autocommit,character_set_client,character_set_connection,\"\n       \"character_set_results,time_zone\"));\n\nstatic bool update_session_track_schema(sys_var *self, THD *thd,\n                                        enum_var_type type)\n{\n  DBUG_ENTER(\"update_session_track_schema\");\n  DBUG_RETURN(thd->session_tracker.current_schema.update(thd, NULL));\n}\n\nstatic Sys_var_mybool Sys_session_track_schema(\n       \"session_track_schema\",\n       \"Track changes to the default schema.\",\n       SESSION_VAR(session_track_schema),\n       CMD_LINE(OPT_ARG), DEFAULT(TRUE),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(0),\n       ON_UPDATE(update_session_track_schema));\n\n\nstatic bool update_session_track_tx_info(sys_var *self, THD *thd,\n                                         enum_var_type type)\n{\n  DBUG_ENTER(\"update_session_track_tx_info\");\n  DBUG_RETURN(thd->session_tracker.transaction_info.update(thd, NULL));\n}\n\nstatic const char *session_track_transaction_info_names[]=\n  { \"OFF\", \"STATE\", \"CHARACTERISTICS\", NullS };\n\nstatic Sys_var_enum Sys_session_track_transaction_info(\n       \"session_track_transaction_info\",\n       \"Track changes to the transaction attributes. OFF to disable; \"\n       \"STATE to track just transaction state (Is there an active transaction? \"\n       \"Does it have any data? etc.); CHARACTERISTICS to track transaction \"\n       \"state and report all statements needed to start a transaction with \"\n       \"the same characteristics (isolation level, read only/read write,\"\n       \"snapshot - but not any work done / data modified within the \"\n       \"transaction).\",\n       SESSION_VAR(session_track_transaction_info),\n       CMD_LINE(REQUIRED_ARG), session_track_transaction_info_names,\n       DEFAULT(0), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(0),\n       ON_UPDATE(update_session_track_tx_info));\n\n\nstatic bool update_session_track_state_change(sys_var *self, THD *thd,\n                                              enum_var_type type)\n{\n  DBUG_ENTER(\"update_session_track_state_change\");\n  DBUG_RETURN(thd->session_tracker.state_change.update(thd, NULL));\n}\n\nstatic Sys_var_mybool Sys_session_track_state_change(\n       \"session_track_state_change\",\n       \"Track changes to the session state.\",\n       SESSION_VAR(session_track_state_change),\n       CMD_LINE(OPT_ARG), DEFAULT(FALSE),\n       NO_MUTEX_GUARD, NOT_IN_BINLOG,\n       ON_CHECK(0),\n       ON_UPDATE(update_session_track_state_change));\n\n#endif //EMBEDDED_LIBRARY\n\nstatic Sys_var_uint Sys_in_subquery_conversion_threshold(\n       \"in_predicate_conversion_threshold\",\n       \"The minimum number of scalar elements in the value list of \"\n       \"IN predicate that triggers its conversion to IN subquery. Set to \"\n       \"0 to disable the conversion.\",\n       SESSION_VAR(in_subquery_conversion_threshold), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(0, UINT_MAX), DEFAULT(IN_SUBQUERY_CONVERSION_THRESHOLD), BLOCK_SIZE(1));\n\nstatic Sys_var_enum Sys_secure_timestamp(\n       \"secure_timestamp\", \"Restricts direct setting of a session \"\n       \"timestamp. Possible levels are: YES - timestamp cannot deviate from \"\n       \"the system clock, REPLICATION - replication thread can adjust \"\n       \"timestamp to match the master's, SUPER - a user with this \"\n       \"privilege and a replication thread can adjust timestamp, NO - \"\n       \"historical behavior, anyone can modify session timestamp\",\n       READ_ONLY GLOBAL_VAR(opt_secure_timestamp), CMD_LINE(REQUIRED_ARG),\n       secure_timestamp_levels, DEFAULT(SECTIME_NO));\n\nstatic Sys_var_ulonglong Sys_max_rowid_filter_size(\n       \"max_rowid_filter_size\",\n       \"The maximum size of the container of a rowid filter\",\n       SESSION_VAR(max_rowid_filter_size), CMD_LINE(REQUIRED_ARG),\n       VALID_RANGE(1024, (ulonglong)~(intptr)0), DEFAULT(128*1024),\n       BLOCK_SIZE(1));\n",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/sql/set_var.h": "#ifndef SET_VAR_INCLUDED\n#define SET_VAR_INCLUDED\n/* Copyright (c) 2002, 2013, Oracle and/or its affiliates.\n   Copyright (c) 2009, 2014, SkySQL Ab.\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; version 2 of the License.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1335  USA */\n\n/**\n  @file\n  \"public\" interface to sys_var - server configuration variables.\n*/\n\n#ifdef USE_PRAGMA_INTERFACE\n#pragma interface                       /* gcc class implementation */\n#endif\n\n#include <my_getopt.h>\n\nclass sys_var;\nclass set_var;\nclass sys_var_pluginvar;\nclass PolyLock;\nclass Item_func_set_user_var;\n\n// This include needs to be here since item.h requires enum_var_type :-P\n#include \"item.h\"                          /* Item */\n#include \"sql_class.h\"                     /* THD  */\n\nextern TYPELIB bool_typelib;\n\nstruct sys_var_chain\n{\n  sys_var *first;\n  sys_var *last;\n};\n\nint mysql_add_sys_var_chain(sys_var *chain);\nint mysql_del_sys_var_chain(sys_var *chain);\n\n\n/**\n  A class representing one system variable - that is something\n  that can be accessed as @@global.variable_name or @@session.variable_name,\n  visible in SHOW xxx VARIABLES and in INFORMATION_SCHEMA.xxx_VARIABLES,\n  optionally it can be assigned to, optionally it can have a command-line\n  counterpart with the same name.\n*/\nclass sys_var: protected Value_source // for double_from_string_with_check\n{\npublic:\n  sys_var *next;\n  LEX_CSTRING name;\n  bool *test_load;\n  enum flag_enum { GLOBAL, SESSION, ONLY_SESSION, SCOPE_MASK=1023,\n                   READONLY=1024, ALLOCATED=2048, PARSE_EARLY=4096,\n                   NO_SET_STATEMENT=8192, AUTO_SET=16384};\n  enum { NO_GETOPT=-1, GETOPT_ONLY_HELP=-2 };\n  enum where { CONFIG, AUTO, SQL, COMPILE_TIME, ENV };\n\n  /**\n    Enumeration type to indicate for a system variable whether\n    it will be written to the binlog or not.\n  */    \n  enum binlog_status_enum { VARIABLE_NOT_IN_BINLOG,\n                            SESSION_VARIABLE_IN_BINLOG } binlog_status;\n\n  my_option option;     ///< min, max, default values are stored here\n  enum where value_origin;\n\nprotected:\n  typedef bool (*on_check_function)(sys_var *self, THD *thd, set_var *var);\n  typedef bool (*on_update_function)(sys_var *self, THD *thd, enum_var_type type);\n\n  int flags;            ///< or'ed flag_enum values\n  const SHOW_TYPE show_val_type; ///< what value_ptr() returns for sql_show.cc\n  PolyLock *guard;      ///< *second* lock that protects the variable\n  ptrdiff_t offset;     ///< offset to the value from global_system_variables\n  on_check_function on_check;\n  on_update_function on_update;\n  const char *const deprecation_substitute;\n  bool is_os_charset; ///< true if the value is in character_set_filesystem\n\npublic:\n  sys_var(sys_var_chain *chain, const char *name_arg, const char *comment,\n          int flag_args, ptrdiff_t off, int getopt_id,\n          enum get_opt_arg_type getopt_arg_type, SHOW_TYPE show_val_type_arg,\n          longlong def_val, PolyLock *lock, enum binlog_status_enum binlog_status_arg,\n          on_check_function on_check_func, on_update_function on_update_func,\n          const char *substitute);\n\n  virtual ~sys_var() {}\n\n  /**\n    All the cleanup procedures should be performed here\n  */\n  virtual void cleanup() {}\n  /**\n    downcast for sys_var_pluginvar. Returns this if it's an instance\n    of sys_var_pluginvar, and 0 otherwise.\n  */\n  virtual sys_var_pluginvar *cast_pluginvar() { return 0; }\n\n  bool check(THD *thd, set_var *var);\n  uchar *value_ptr(THD *thd, enum_var_type type, const LEX_CSTRING *base);\n\n  /**\n     Update the system variable with the default value from either\n     session or global scope.  The default value is stored in the\n     'var' argument. Return false when successful.\n  */\n  bool set_default(THD *thd, set_var *var);\n  bool update(THD *thd, set_var *var);\n\n  String *val_str_nolock(String *str, THD *thd, const uchar *value);\n  longlong val_int(bool *is_null, THD *thd, enum_var_type type, const LEX_CSTRING *base);\n  String *val_str(String *str, THD *thd, enum_var_type type, const LEX_CSTRING *base);\n  double val_real(bool *is_null, THD *thd, enum_var_type type, const LEX_CSTRING *base);\n\n  SHOW_TYPE show_type() { return show_val_type; }\n  int scope() const { return flags & SCOPE_MASK; }\n  CHARSET_INFO *charset(THD *thd);\n  bool is_readonly() const { return flags & READONLY; }\n  /**\n    the following is only true for keycache variables,\n    that support the syntax @@keycache_name.variable_name\n  */\n  bool is_struct() { return option.var_type & GET_ASK_ADDR; }\n  bool is_set_stmt_ok() const { return !(flags & NO_SET_STATEMENT); }\n  bool is_written_to_binlog(enum_var_type type)\n  { return type != OPT_GLOBAL && binlog_status == SESSION_VARIABLE_IN_BINLOG; }\n  bool check_update_type(const Item *item)\n  {\n    Item_result type= item->result_type();\n    switch (option.var_type & GET_TYPE_MASK) {\n    case GET_INT:\n    case GET_UINT:\n    case GET_LONG:\n    case GET_ULONG:\n    case GET_LL:\n    case GET_ULL:\n      return type != INT_RESULT &&\n             (type != DECIMAL_RESULT || item->decimals != 0);\n    case GET_STR:\n    case GET_STR_ALLOC:\n      return type != STRING_RESULT;\n    case GET_ENUM:\n    case GET_BOOL:\n    case GET_SET:\n    case GET_FLAGSET:\n    case GET_BIT:\n      return type != STRING_RESULT && type != INT_RESULT;\n    case GET_DOUBLE:\n      return type != INT_RESULT && type != REAL_RESULT && type != DECIMAL_RESULT;\n    default:\n      return true;\n    }\n  }\n\n  bool check_type(enum_var_type type)\n  {\n    switch (scope())\n    {\n    case GLOBAL:       return type != OPT_GLOBAL;\n    case SESSION:      return false; // always ok\n    case ONLY_SESSION: return type == OPT_GLOBAL;\n    }\n    return true; // keep gcc happy\n  }\n  bool register_option(DYNAMIC_ARRAY *array, int parse_flags)\n  {\n    DBUG_ASSERT(parse_flags == GETOPT_ONLY_HELP ||\n                parse_flags == PARSE_EARLY || parse_flags == 0);\n    if (option.id == NO_GETOPT)\n      return 0;\n    if (parse_flags == GETOPT_ONLY_HELP)\n    {\n      if (option.id != GETOPT_ONLY_HELP)\n        return 0;\n    }\n    else\n    {\n      if (option.id == GETOPT_ONLY_HELP)\n        return 0;\n      if ((flags & PARSE_EARLY) != parse_flags)\n        return 0;\n    }\n    return insert_dynamic(array, (uchar*)&option);\n  }\n  void do_deprecated_warning(THD *thd);\n  /**\n    whether session value of a sysvar is a default one.\n\n    in this simple implementation we don't distinguish between default\n    and non-default values. for most variables it's ok, they don't treat\n    default values specially. this method is overwritten in descendant\n    classes as necessary.\n  */\n  virtual bool session_is_default(THD *thd) { return false; }\n\n  virtual uchar *default_value_ptr(THD *thd)\n  { return (uchar*)&option.def_value; }\n\nprivate:\n  virtual bool do_check(THD *thd, set_var *var) = 0;\n  /**\n    save the session default value of the variable in var\n  */\n  virtual void session_save_default(THD *thd, set_var *var) = 0;\n  /**\n    save the global default value of the variable in var\n  */\n  virtual void global_save_default(THD *thd, set_var *var) = 0;\n  virtual bool session_update(THD *thd, set_var *var) = 0;\n  virtual bool global_update(THD *thd, set_var *var) = 0;\n\nprotected:\n  /**\n    A pointer to a value of the variable for SHOW.\n    It must be of show_val_type type (my_bool for SHOW_MY_BOOL,\n    int for SHOW_INT, longlong for SHOW_LONGLONG, etc).\n  */\n  virtual uchar *session_value_ptr(THD *thd, const LEX_CSTRING *base);\n  virtual uchar *global_value_ptr(THD *thd, const LEX_CSTRING *base);\n\n  /**\n    A pointer to a storage area of the variable, to the raw data.\n    Typically it's the same as session_value_ptr(), but it's different,\n    for example, for ENUM, that is printed as a string, but stored as a number.\n  */\n  uchar *session_var_ptr(THD *thd)\n  { return ((uchar*)&(thd->variables)) + offset; }\n\n  uchar *global_var_ptr()\n  { return ((uchar*)&global_system_variables) + offset; }\n\n  void *max_var_ptr()\n  {\n    return scope() == SESSION ? (((uchar*)&max_system_variables) + offset) :\n                                0;\n  }\n\n  friend class Session_sysvars_tracker;\n  friend class Session_tracker;\n};\n\n#include \"sql_plugin.h\"                    /* SHOW_HA_ROWS, SHOW_MY_BOOL */\n\n\n/****************************************************************************\n  Classes for parsing of the SET command\n****************************************************************************/\n\n/**\n  A base class for everything that can be set with SET command.\n  It's similar to Items, an instance of this is created by the parser\n  for every assigmnent in SET (or elsewhere, e.g. in SELECT).\n*/\nclass set_var_base :public Sql_alloc\n{\npublic:\n  set_var_base() {}\n  virtual ~set_var_base() {}\n  virtual int check(THD *thd)=0;           /* To check privileges etc. */\n  virtual int update(THD *thd)=0;                  /* To set the value */\n  virtual int light_check(THD *thd) { return check(thd); }   /* for PS */\n  virtual bool is_system() { return FALSE; }\n  /**\n    @returns whether this variable is @@@@optimizer_trace.\n  */\n  virtual bool is_var_optimizer_trace() const { return false; }\n};\n\n\n/**\n  set_var_base descendant for assignments to the system variables.\n*/\nclass set_var :public set_var_base\n{\npublic:\n  sys_var *var; ///< system variable to be updated\n  Item *value;  ///< the expression that provides the new value of the variable\n  enum_var_type type;\n  union ///< temp storage to hold a value between sys_var::check and ::update\n  {\n    ulonglong ulonglong_value;          ///< for unsigned integer, set, enum sysvars\n    longlong longlong_value;            ///< for signed integer\n    double double_value;                ///< for Sys_var_double\n    plugin_ref plugin;                  ///< for Sys_var_plugin\n    plugin_ref *plugins;                ///< for Sys_var_pluginlist\n    Time_zone *time_zone;               ///< for Sys_var_tz\n    LEX_STRING string_value;            ///< for Sys_var_charptr and others\n    const void *ptr;                    ///< for Sys_var_struct\n  } save_result;\n  LEX_CSTRING base; /**< for structured variables, like keycache_name.variable_name */\n\n  set_var(THD *thd, enum_var_type type_arg, sys_var *var_arg,\n          const LEX_CSTRING *base_name_arg, Item *value_arg);\n  virtual bool is_system() { return 1; }\n  int check(THD *thd);\n  int update(THD *thd);\n  int light_check(THD *thd);\n  virtual bool is_var_optimizer_trace() const\n  {\n    extern sys_var *Sys_optimizer_trace_ptr;\n    return var == Sys_optimizer_trace_ptr;\n  }\n};\n\n\n/* User variables like @my_own_variable */\nclass set_var_user: public set_var_base\n{\n  Item_func_set_user_var *user_var_item;\npublic:\n  set_var_user(Item_func_set_user_var *item)\n    :user_var_item(item)\n  {}\n  int check(THD *thd);\n  int update(THD *thd);\n  int light_check(THD *thd);\n};\n\n/* For SET PASSWORD */\n\nclass set_var_password: public set_var_base\n{\n  LEX_USER *user;\npublic:\n  set_var_password(LEX_USER *user_arg) :user(user_arg)\n  {}\n  int check(THD *thd);\n  int update(THD *thd);\n};\n\n/* For SET ROLE */\n\nclass set_var_role: public set_var_base\n{\n  LEX_CSTRING role;\n  ulonglong access;\npublic:\n  set_var_role(LEX_CSTRING role_arg) : role(role_arg) {}\n  int check(THD *thd);\n  int update(THD *thd);\n};\n\n/* For SET DEFAULT ROLE */\n\nclass set_var_default_role: public set_var_base\n{\n  LEX_USER *user, *real_user;\n  LEX_CSTRING role;\npublic:\n  set_var_default_role(LEX_USER *user_arg, LEX_CSTRING role_arg) :\n    user(user_arg), role(role_arg) {}\n  int check(THD *thd);\n  int update(THD *thd);\n};\n\n/* For SET NAMES and SET CHARACTER SET */\n\nclass set_var_collation_client: public set_var_base\n{\n  CHARSET_INFO *character_set_client;\n  CHARSET_INFO *character_set_results;\n  CHARSET_INFO *collation_connection;\npublic:\n  set_var_collation_client(CHARSET_INFO *client_coll_arg,\n                           CHARSET_INFO *connection_coll_arg,\n                           CHARSET_INFO *result_coll_arg)\n    :character_set_client(client_coll_arg),\n     character_set_results(result_coll_arg),\n     collation_connection(connection_coll_arg)\n  {}\n  int check(THD *thd);\n  int update(THD *thd);\n};\n\n\n/* optional things, have_* variables */\nextern SHOW_COMP_OPTION have_csv, have_innodb;\nextern SHOW_COMP_OPTION have_ndbcluster, have_partitioning;\nextern SHOW_COMP_OPTION have_profiling;\n\nextern SHOW_COMP_OPTION have_ssl, have_symlink, have_dlopen;\nextern SHOW_COMP_OPTION have_query_cache;\nextern SHOW_COMP_OPTION have_geometry, have_rtree_keys;\nextern SHOW_COMP_OPTION have_crypt;\nextern SHOW_COMP_OPTION have_compress;\nextern SHOW_COMP_OPTION have_openssl;\n\n/*\n  Prototypes for helper functions\n*/\n\nSHOW_VAR* enumerate_sys_vars(THD *thd, bool sorted, enum enum_var_type type);\nint fill_sysvars(THD *thd, TABLE_LIST *tables, COND *cond);\n\nsys_var *find_sys_var(THD *thd, const char *str, size_t length= 0,\n                      bool throw_error= false);\nint sql_set_variables(THD *thd, List<set_var_base> *var_list, bool free);\n\n#define SYSVAR_AUTOSIZE(VAR,VAL)                        \\\n  do {                                                  \\\n    VAR= (VAL);                                         \\\n    set_sys_var_value_origin(&VAR, sys_var::AUTO);      \\\n  } while(0)\n\n#define SYSVAR_AUTOSIZE_IF_CHANGED(VAR,VAL,TYPE)        \\\n  do {                                                  \\\n    TYPE tmp= (VAL);                                    \\\n    if (VAR != tmp)                                     \\\n    {                                                   \\\n      VAR= (VAL);                                       \\\n      set_sys_var_value_origin(&VAR, sys_var::AUTO);    \\\n    }                                                   \\\n  } while(0)\n\nvoid set_sys_var_value_origin(void *ptr, enum sys_var::where here);\n\nenum sys_var::where get_sys_var_value_origin(void *ptr);\ninline bool IS_SYSVAR_AUTOSIZE(void *ptr)\n{\n  enum sys_var::where res= get_sys_var_value_origin(ptr);\n  return (res == sys_var::AUTO || res == sys_var::COMPILE_TIME);\n}\n\nbool fix_delay_key_write(sys_var *self, THD *thd, enum_var_type type);\n\nsql_mode_t expand_sql_mode(sql_mode_t sql_mode);\nconst char *sql_mode_string_representation(uint bit_number);\nbool sql_mode_string_representation(THD *thd, sql_mode_t sql_mode,\n                                    LEX_CSTRING *ls);\nint default_regex_flags_pcre(const THD *thd);\n\nextern sys_var *Sys_autocommit_ptr, *Sys_last_gtid_ptr,\n  *Sys_character_set_client_ptr, *Sys_character_set_connection_ptr,\n  *Sys_character_set_results_ptr;\n\nCHARSET_INFO *get_old_charset_by_name(const char *old_name);\n\nint sys_var_init();\nuint sys_var_elements();\nint sys_var_add_options(DYNAMIC_ARRAY *long_options, int parse_flags);\nvoid sys_var_end(void);\nbool check_has_super(sys_var *self, THD *thd, set_var *var);\nplugin_ref *resolve_engine_list(THD *thd, const char *str_arg, size_t str_arg_len,\n                                bool error_on_unknown_engine, bool temp_copy);\nvoid free_engine_list(plugin_ref *list);\nplugin_ref *copy_engine_list(plugin_ref *list);\nplugin_ref *temp_copy_engine_list(THD *thd, plugin_ref *list);\nchar *pretty_print_engine_list(THD *thd, plugin_ref *list);\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/sql/sql_udf.cc": "/* Copyright (c) 2000, 2012, Oracle and/or its affiliates.\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; version 2 of the License.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1335  USA */\n\n/* This implements 'user defined functions' */\n\n/*\n   Known bugs:\n  \n   Memory for functions is never freed!\n   Shared libraries are not closed before mysqld exits;\n     - This is because we can't be sure if some threads are using\n       a function.\n  \n   The bugs only affect applications that create and free a lot of\n   dynamic functions, so this shouldn't be a real problem.\n*/\n\n#ifdef USE_PRAGMA_IMPLEMENTATION\n#pragma implementation\t\t\t\t// gcc: Class implementation\n#endif\n\n#include \"mariadb.h\"\n#include \"sql_priv.h\"\n#include \"unireg.h\"\n#include \"sql_base.h\"                           // close_mysql_tables\n#include \"sql_parse.h\"                        // check_identifier_name\n#include \"sql_table.h\"                        // write_bin_log\n#include \"records.h\"          // init_read_record, end_read_record\n#include <my_pthread.h>\n#include \"lock.h\"                               // MYSQL_LOCK_IGNORE_TIMEOUT\n\n#ifdef HAVE_DLOPEN\nextern \"C\"\n{\n#include <stdarg.h>\n#include <hash.h>\n}\n\nstatic bool initialized = 0;\nstatic MEM_ROOT mem;\nstatic HASH udf_hash;\nstatic mysql_rwlock_t THR_LOCK_udf;\nstatic LEX_CSTRING MYSQL_FUNC_NAME= {STRING_WITH_LEN(\"func\") };\n\nstatic udf_func *add_udf(LEX_CSTRING *name, Item_result ret,\n                         const char *dl, Item_udftype typ);\nstatic void del_udf(udf_func *udf);\nstatic void *find_udf_dl(const char *dl);\n\nstatic const char *init_syms(udf_func *tmp, char *nm)\n{\n  char *end;\n\n  if (!((tmp->func= (Udf_func_any) dlsym(tmp->dlhandle, tmp->name.str))))\n    return tmp->name.str;\n\n  end=strmov(nm,tmp->name.str);\n\n  if (tmp->type == UDFTYPE_AGGREGATE)\n  {\n    (void)strmov(end, \"_clear\");\n    if (!((tmp->func_clear= (Udf_func_clear) dlsym(tmp->dlhandle, nm))))\n      return nm;\n    (void)strmov(end, \"_add\");\n    if (!((tmp->func_add= (Udf_func_add) dlsym(tmp->dlhandle, nm))))\n      return nm;\n    (void)strmov(end, \"_remove\");\n    tmp->func_remove= (Udf_func_add) dlsym(tmp->dlhandle, nm);\n  }\n\n  (void) strmov(end,\"_deinit\");\n  tmp->func_deinit= (Udf_func_deinit) dlsym(tmp->dlhandle, nm);\n\n  (void) strmov(end,\"_init\");\n  tmp->func_init= (Udf_func_init) dlsym(tmp->dlhandle, nm);\n\n  /*\n    to prefent loading \"udf\" from, e.g. libc.so\n    let's ensure that at least one auxiliary symbol is defined\n  */\n  if (!tmp->func_init && !tmp->func_deinit && tmp->type != UDFTYPE_AGGREGATE)\n  {\n    THD *thd= current_thd;\n    if (!opt_allow_suspicious_udfs)\n      return nm;\n    if (thd->variables.log_warnings)\n      sql_print_warning(ER_THD(thd, ER_CANT_FIND_DL_ENTRY), nm);\n  }\n  return 0;\n}\n\n\nextern \"C\" uchar* get_hash_key(const uchar *buff, size_t *length,\n\t\t\t      my_bool not_used __attribute__((unused)))\n{\n  udf_func *udf=(udf_func*) buff;\n  *length=(uint) udf->name.length;\n  return (uchar*) udf->name.str;\n}\n\n#ifdef HAVE_PSI_INTERFACE\nstatic PSI_rwlock_key key_rwlock_THR_LOCK_udf;\n\nstatic PSI_rwlock_info all_udf_rwlocks[]=\n{\n  { &key_rwlock_THR_LOCK_udf, \"THR_LOCK_udf\", PSI_FLAG_GLOBAL}\n};\n\nstatic void init_udf_psi_keys(void)\n{\n  const char* category= \"sql\";\n  int count;\n\n  if (PSI_server == NULL)\n    return;\n\n  count= array_elements(all_udf_rwlocks);\n  PSI_server->register_rwlock(category, all_udf_rwlocks, count);\n}\n#endif\n\n/*\n  Read all predeclared functions from mysql.func and accept all that\n  can be used.\n*/\n\nvoid udf_init()\n{\n  udf_func *tmp;\n  TABLE_LIST tables;\n  READ_RECORD read_record_info;\n  TABLE *table;\n  int error;\n  DBUG_ENTER(\"ufd_init\");\n\n  if (initialized || opt_noacl)\n    DBUG_VOID_RETURN;\n\n#ifdef HAVE_PSI_INTERFACE\n  init_udf_psi_keys();\n#endif\n\n  mysql_rwlock_init(key_rwlock_THR_LOCK_udf, &THR_LOCK_udf);\n\n  init_sql_alloc(&mem, \"udf\", UDF_ALLOC_BLOCK_SIZE, 0, MYF(0));\n  THD *new_thd = new THD(0);\n  if (!new_thd ||\n      my_hash_init(&udf_hash,system_charset_info,32,0,0,get_hash_key, NULL, 0))\n  {\n    sql_print_error(\"Can't allocate memory for udf structures\");\n    my_hash_free(&udf_hash);\n    free_root(&mem,MYF(0));\n    delete new_thd;\n    DBUG_VOID_RETURN;\n  }\n  initialized = 1;\n  new_thd->thread_stack= (char*) &new_thd;\n  new_thd->store_globals();\n  new_thd->set_db(&MYSQL_SCHEMA_NAME);\n\n  tables.init_one_table(&new_thd->db, &MYSQL_FUNC_NAME, 0, TL_READ);\n\n  if (open_and_lock_tables(new_thd, &tables, FALSE, MYSQL_LOCK_IGNORE_TIMEOUT))\n  {\n    DBUG_PRINT(\"error\",(\"Can't open udf table\"));\n    sql_print_error(\"Can't open the mysql.func table. Please \"\n                    \"run mysql_upgrade to create it.\");\n    goto end;\n  }\n\n  table= tables.table;\n  if (init_read_record(&read_record_info, new_thd, table, NULL, NULL, 1, 0,\n                       FALSE))\n  {\n    sql_print_error(\"Could not initialize init_read_record; udf's not \"\n                    \"loaded\");\n    goto end;\n  }\n\n  table->use_all_columns();\n  while (!(error= read_record_info.read_record()))\n  {\n    DBUG_PRINT(\"info\",(\"init udf record\"));\n    LEX_CSTRING name;\n    name.str=get_field(&mem, table->field[0]);\n    name.length = (uint) strlen(name.str);\n    char *dl_name= get_field(&mem, table->field[2]);\n    bool new_dl=0;\n    Item_udftype udftype=UDFTYPE_FUNCTION;\n    if (table->s->fields >= 4)\t\t\t// New func table\n      udftype=(Item_udftype) table->field[3]->val_int();\n\n    /*\n      Ensure that the .dll doesn't have a path\n      This is done to ensure that only approved dll from the system\n      directories are used (to make this even remotely secure).\n\n      On windows we must check both FN_LIBCHAR and '/'.\n    */\n    if (check_valid_path(dl_name, strlen(dl_name)) ||\n        check_string_char_length(&name, 0, NAME_CHAR_LEN,\n                                 system_charset_info, 1))\n    {\n      sql_print_error(\"Invalid row in mysql.func table for function '%.64s'\",\n                      name.str);\n      continue;\n    }\n\n    if (!(tmp= add_udf(&name,(Item_result) table->field[1]->val_int(),\n                       dl_name, udftype)))\n    {\n      sql_print_error(\"Can't alloc memory for udf function: '%.64s'\", name.str);\n      continue;\n    }\n\n    void *dl = find_udf_dl(tmp->dl);\n    if (dl == NULL)\n    {\n      char dlpath[FN_REFLEN];\n      strxnmov(dlpath, sizeof(dlpath) - 1, opt_plugin_dir, \"/\", tmp->dl, NullS);\n      (void) unpack_filename(dlpath, dlpath);\n      if (!(dl= dlopen(dlpath, RTLD_NOW)))\n      {\n\t/* Print warning to log */\n        sql_print_error(ER_THD(new_thd, ER_CANT_OPEN_LIBRARY),\n                        tmp->dl, errno, my_dlerror(dlpath));\n\t/* Keep the udf in the hash so that we can remove it later */\n\tcontinue;\n      }\n      new_dl=1;\n    }\n    tmp->dlhandle = dl;\n    {\n      char buf[SAFE_NAME_LEN+16];\n      const char *missing;\n      if ((missing= init_syms(tmp, buf)))\n      {\n        sql_print_error(ER_THD(new_thd, ER_CANT_FIND_DL_ENTRY), missing);\n        del_udf(tmp);\n        if (new_dl)\n          dlclose(dl);\n      }\n    }\n  }\n  if (unlikely(error > 0))\n    sql_print_error(\"Got unknown error: %d\", my_errno);\n  end_read_record(&read_record_info);\n  table->m_needs_reopen= TRUE;                  // Force close to free memory\n\nend:\n  close_mysql_tables(new_thd);\n  delete new_thd;\n  DBUG_VOID_RETURN;\n}\n\n\nvoid udf_free()\n{\n  /* close all shared libraries */\n  DBUG_ENTER(\"udf_free\");\n  if (opt_noacl)\n    DBUG_VOID_RETURN;\n  for (uint idx=0 ; idx < udf_hash.records ; idx++)\n  {\n    udf_func *udf=(udf_func*) my_hash_element(&udf_hash,idx);\n    if (udf->dlhandle)\t\t\t\t// Not closed before\n    {\n      /* Mark all versions using the same handler as closed */\n      for (uint j=idx+1 ;  j < udf_hash.records ; j++)\n      {\n\tudf_func *tmp=(udf_func*) my_hash_element(&udf_hash,j);\n\tif (udf->dlhandle == tmp->dlhandle)\n\t  tmp->dlhandle=0;\t\t\t// Already closed\n      }\n      dlclose(udf->dlhandle);\n    }\n  }\n  my_hash_free(&udf_hash);\n  free_root(&mem,MYF(0));\n  if (initialized)\n  {\n    initialized= 0;\n    mysql_rwlock_destroy(&THR_LOCK_udf);\n  }\n  DBUG_VOID_RETURN;\n}\n\n\nstatic void del_udf(udf_func *udf)\n{\n  DBUG_ENTER(\"del_udf\");\n  if (!--udf->usage_count)\n  {\n    my_hash_delete(&udf_hash,(uchar*) udf);\n    using_udf_functions=udf_hash.records != 0;\n  }\n  else\n  {\n    /*\n      The functions is in use ; Rename the functions instead of removing it.\n      The functions will be automaticly removed when the least threads\n      doesn't use it anymore\n    */\n    const char *name= udf->name.str;\n    size_t name_length=udf->name.length;\n    udf->name.str= \"*\";\n    udf->name.length=1;\n    my_hash_update(&udf_hash,(uchar*) udf,(uchar*) name,name_length);\n  }\n  DBUG_VOID_RETURN;\n}\n\n\nvoid free_udf(udf_func *udf)\n{\n  DBUG_ENTER(\"free_udf\");\n  \n  if (!initialized)\n    DBUG_VOID_RETURN;\n\n  mysql_rwlock_wrlock(&THR_LOCK_udf);\n  if (!--udf->usage_count)\n  {\n    /*\n      We come here when someone has deleted the udf function\n      while another thread still was using the udf\n    */\n    my_hash_delete(&udf_hash,(uchar*) udf);\n    using_udf_functions=udf_hash.records != 0;\n    if (!find_udf_dl(udf->dl))\n      dlclose(udf->dlhandle);\n  }\n  mysql_rwlock_unlock(&THR_LOCK_udf);\n  DBUG_VOID_RETURN;\n}\n\n\n/* This is only called if using_udf_functions != 0 */\n\nudf_func *find_udf(const char *name,size_t length,bool mark_used)\n{\n  udf_func *udf=0;\n  DBUG_ENTER(\"find_udf\");\n  DBUG_ASSERT(strlen(name) == length);\n\n  if (!initialized)\n    DBUG_RETURN(NULL);\n\n  DEBUG_SYNC(current_thd, \"find_udf_before_lock\");\n  /* TODO: This should be changed to reader locks someday! */\n  if (mark_used)\n    mysql_rwlock_wrlock(&THR_LOCK_udf);  /* Called during fix_fields */\n  else\n    mysql_rwlock_rdlock(&THR_LOCK_udf);  /* Called during parsing */\n\n  if ((udf=(udf_func*) my_hash_search(&udf_hash,(uchar*) name, length)))\n  {\n    if (!udf->dlhandle)\n      udf=0;\t\t\t\t\t// Could not be opened\n    else if (mark_used)\n      udf->usage_count++;\n  }\n  mysql_rwlock_unlock(&THR_LOCK_udf);\n  DBUG_RETURN(udf);\n}\n\n\nstatic void *find_udf_dl(const char *dl)\n{\n  DBUG_ENTER(\"find_udf_dl\");\n\n  /*\n    Because only the function name is hashed, we have to search trough\n    all rows to find the dl.\n  */\n  for (uint idx=0 ; idx < udf_hash.records ; idx++)\n  {\n    udf_func *udf=(udf_func*) my_hash_element(&udf_hash,idx);\n    if (!strcmp(dl, udf->dl) && udf->dlhandle != NULL)\n      DBUG_RETURN(udf->dlhandle);\n  }\n  DBUG_RETURN(0);\n}\n\n\n/* Assume that name && dl is already allocated */\n\nstatic udf_func *add_udf(LEX_CSTRING *name, Item_result ret, const char *dl,\n\t\t\t Item_udftype type)\n{\n  if (!name || !dl || !(uint) type || (uint) type > (uint) UDFTYPE_AGGREGATE)\n    return 0;\n  udf_func *tmp= (udf_func*) alloc_root(&mem, sizeof(udf_func));\n  if (!tmp)\n    return 0;\n  bzero((char*) tmp,sizeof(*tmp));\n  tmp->name = *name; //dup !!\n  tmp->dl = dl;\n  tmp->returns = ret;\n  tmp->type = type;\n  tmp->usage_count=1;\n  if (my_hash_insert(&udf_hash,(uchar*)  tmp))\n    return 0;\n  using_udf_functions=1;\n  return tmp;\n}\n\n/*\n  Drop user defined function.\n\n  @param thd    Thread handler.\n  @param udf    Existing udf_func pointer which is to be deleted.\n  @param table  mysql.func table reference (opened and locked)\n\n  Assumption\n\n  - udf is not null.\n  - table is already opened and locked\n*/\nstatic int mysql_drop_function_internal(THD *thd, udf_func *udf, TABLE *table)\n{\n  DBUG_ENTER(\"mysql_drop_function_internal\");\n\n  const char *exact_name_str= udf->name.str;\n  size_t exact_name_len= udf->name.length;\n\n  del_udf(udf);\n  /*\n    Close the handle if this was function that was found during boot or\n    CREATE FUNCTION and it's not in use by any other udf function\n  */\n  if (udf->dlhandle && !find_udf_dl(udf->dl))\n    dlclose(udf->dlhandle);\n\n  if (!table)\n    DBUG_RETURN(1);\n\n  table->use_all_columns();\n  table->field[0]->store(exact_name_str, exact_name_len, &my_charset_bin);\n  if (!table->file->ha_index_read_idx_map(table->record[0], 0,\n                                          (uchar*) table->field[0]->ptr,\n                                          HA_WHOLE_KEY,\n                                          HA_READ_KEY_EXACT))\n  {\n    int error;\n    if (unlikely((error= table->file->ha_delete_row(table->record[0]))))\n      table->file->print_error(error, MYF(0));\n  }\n  DBUG_RETURN(0);\n}\n\n\n/**\n  Create a user defined function. \n\n  @note Like implementations of other DDL/DML in MySQL, this function\n  relies on the caller to close the thread tables. This is done in the\n  end of dispatch_command().\n*/\n\nint mysql_create_function(THD *thd,udf_func *udf)\n{\n  int error;\n  void *dl=0;\n  bool new_dl=0;\n  TABLE *table;\n  TABLE_LIST tables;\n  udf_func *u_d;\n  DBUG_ENTER(\"mysql_create_function\");\n\n  if (!initialized)\n  {\n    if (opt_noacl)\n      my_error(ER_CANT_INITIALIZE_UDF, MYF(0),\n               udf->name.str,\n               \"UDFs are unavailable with the --skip-grant-tables option\");\n    else\n      my_message(ER_OUT_OF_RESOURCES, ER_THD(thd, ER_OUT_OF_RESOURCES),\n                 MYF(0));\n    DBUG_RETURN(1);\n  }\n\n  /*\n    Ensure that the .dll doesn't have a path\n    This is done to ensure that only approved dll from the system\n    directories are used (to make this even remotely secure).\n  */\n  if (check_valid_path(udf->dl, strlen(udf->dl)))\n  {\n    my_message(ER_UDF_NO_PATHS, ER_THD(thd, ER_UDF_NO_PATHS), MYF(0));\n    DBUG_RETURN(1);\n  }\n  if (check_ident_length(&udf->name))\n    DBUG_RETURN(1);\n\n  tables.init_one_table(&MYSQL_SCHEMA_NAME, &MYSQL_FUNC_NAME, 0, TL_WRITE);\n  table= open_ltable(thd, &tables, TL_WRITE, MYSQL_LOCK_IGNORE_TIMEOUT);\n\n  mysql_rwlock_wrlock(&THR_LOCK_udf);\n  DEBUG_SYNC(current_thd, \"mysql_create_function_after_lock\");\n  if ((u_d= (udf_func*) my_hash_search(&udf_hash, (uchar*) udf->name.str,\n                                                  udf->name.length)))\n  {\n    if (thd->lex->create_info.or_replace())\n    {\n      if (unlikely((error= mysql_drop_function_internal(thd, u_d, table))))\n        goto err;\n    }\n    else if (thd->lex->create_info.if_not_exists())\n    {\n      push_warning_printf(thd, Sql_condition::WARN_LEVEL_NOTE, ER_UDF_EXISTS,\n                          ER_THD(thd, ER_UDF_EXISTS), udf->name.str);\n\n      goto done;\n    }\n    else\n    {\n      my_error(ER_UDF_EXISTS, MYF(0), udf->name.str);\n      goto err;\n    }\n  }\n  if (!(dl = find_udf_dl(udf->dl)))\n  {\n    char dlpath[FN_REFLEN];\n    strxnmov(dlpath, sizeof(dlpath) - 1, opt_plugin_dir, \"/\", udf->dl, NullS);\n    (void) unpack_filename(dlpath, dlpath);\n\n    if (!(dl = dlopen(dlpath, RTLD_NOW)))\n    {\n      my_error(ER_CANT_OPEN_LIBRARY, MYF(0),\n               udf->dl, errno, my_dlerror(dlpath));\n      DBUG_PRINT(\"error\",(\"dlopen of %s failed, error: %d (%s)\",\n                          udf->dl, errno, dlerror()));\n      goto err;\n    }\n    new_dl=1;\n  }\n  udf->dlhandle=dl;\n  {\n    char buf[SAFE_NAME_LEN+16];\n    const char *missing;\n    if ((missing= init_syms(udf, buf)))\n    {\n      my_error(ER_CANT_FIND_DL_ENTRY, MYF(0), missing);\n      goto err;\n    }\n  }\n  udf->name.str= strdup_root(&mem,udf->name.str);\n  udf->dl= strdup_root(&mem,udf->dl);\n  if (!(u_d=add_udf(&udf->name,udf->returns,udf->dl,udf->type)))\n    goto err;\n  u_d->dlhandle= dl;\n  u_d->func= udf->func;\n  u_d->func_init= udf->func_init;\n  u_d->func_deinit= udf->func_deinit;\n  u_d->func_clear= udf->func_clear;\n  u_d->func_add= udf->func_add;\n  u_d->func_remove= udf->func_remove;\n\n  /* create entry in mysql.func table */\n\n  /* Allow creation of functions even if we can't open func table */\n  if (unlikely(!table))\n    goto err;\n  table->use_all_columns();\n  restore_record(table, s->default_values);\t// Default values for fields\n  table->field[0]->store(u_d->name.str, u_d->name.length, system_charset_info);\n  table->field[1]->store((longlong) u_d->returns, TRUE);\n  table->field[2]->store(u_d->dl,(uint) strlen(u_d->dl), system_charset_info);\n  if (table->s->fields >= 4)\t\t\t// If not old func format\n    table->field[3]->store((longlong) u_d->type, TRUE);\n  error= table->file->ha_write_row(table->record[0]);\n\n  if (unlikely(error))\n  {\n    my_error(ER_ERROR_ON_WRITE, MYF(0), \"mysql.func\", error);\n    del_udf(u_d);\n    goto err;\n  }\n\ndone:\n  mysql_rwlock_unlock(&THR_LOCK_udf);\n\n  /* Binlog the create function. */\n  if (unlikely(write_bin_log(thd, TRUE, thd->query(), thd->query_length())))\n    DBUG_RETURN(1);\n\n  DBUG_RETURN(0);\n\nerr:\n  if (new_dl)\n    dlclose(dl);\n  mysql_rwlock_unlock(&THR_LOCK_udf);\n  DBUG_RETURN(1);\n}\n\n\nint mysql_drop_function(THD *thd, const LEX_CSTRING *udf_name)\n{\n  TABLE *table;\n  TABLE_LIST tables;\n  udf_func *udf;\n  DBUG_ENTER(\"mysql_drop_function\");\n\n  if (!initialized)\n  {\n    if (opt_noacl)\n      my_error(ER_FUNCTION_NOT_DEFINED, MYF(0), udf_name->str);\n    else\n      my_message(ER_OUT_OF_RESOURCES, ER_THD(thd, ER_OUT_OF_RESOURCES),\n                 MYF(0));\n    DBUG_RETURN(1);\n  }\n\n  tables.init_one_table(&MYSQL_SCHEMA_NAME, &MYSQL_FUNC_NAME, 0, TL_WRITE);\n  table= open_ltable(thd, &tables, TL_WRITE, MYSQL_LOCK_IGNORE_TIMEOUT);\n\n  mysql_rwlock_wrlock(&THR_LOCK_udf);\n  DEBUG_SYNC(current_thd, \"mysql_drop_function_after_lock\");\n  if (!(udf= (udf_func*) my_hash_search(&udf_hash, (uchar*) udf_name->str,\n                                        (uint) udf_name->length)) )\n  {\n    if (thd->lex->check_exists)\n    {\n      push_warning_printf(thd, Sql_condition::WARN_LEVEL_NOTE,\n                          ER_FUNCTION_NOT_DEFINED,\n                          ER_THD(thd, ER_FUNCTION_NOT_DEFINED),\n                          udf_name->str);\n      goto done;\n    }\n\n    my_error(ER_FUNCTION_NOT_DEFINED, MYF(0), udf_name->str);\n    goto err;\n  }\n\n  if (mysql_drop_function_internal(thd, udf, table))\n    goto err;\n\ndone:\n  mysql_rwlock_unlock(&THR_LOCK_udf);\n\n  /*\n    Binlog the drop function. Keep the table open and locked\n    while binlogging, to avoid binlog inconsistency.\n  */\n  if (write_bin_log(thd, TRUE, thd->query(), thd->query_length()))\n    DBUG_RETURN(1);\n\n  DBUG_RETURN(0);\n\nerr:\n  mysql_rwlock_unlock(&THR_LOCK_udf);\n  DBUG_RETURN(1);\n}\n\n#endif /* HAVE_DLOPEN */\n",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/sql/sql_plugin.cc": "/*\n   Copyright (c) 2005, 2018, Oracle and/or its affiliates.\n   Copyright (c) 2010, 2018, MariaDB Corporation\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; version 2 of the License.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1335  USA */\n\n#include \"sql_plugin.h\"                         // SHOW_MY_BOOL\n#include \"sql_priv.h\"\n#include \"unireg.h\"\n#include \"sql_class.h\"                          // set_var.h: THD\n#include \"sys_vars_shared.h\"\n#include \"sql_locale.h\"\n#include \"sql_plugin.h\"\n#include \"sql_parse.h\"          // check_table_access\n#include \"sql_base.h\"                           // close_mysql_tables\n#include \"key.h\"                                // key_copy\n#include \"sql_table.h\"\n#include \"sql_show.h\"           // remove_status_vars, add_status_vars\n#include \"strfunc.h\"            // find_set\n#include \"sql_acl.h\"                       // *_ACL\n#include \"records.h\"          // init_read_record, end_read_record\n#include <my_pthread.h>\n#include <my_getopt.h>\n#include \"sql_audit.h\"\n#include <mysql/plugin_auth.h>\n#include \"lock.h\"                               // MYSQL_LOCK_IGNORE_TIMEOUT\n#include <mysql/plugin_auth.h>\n#include <mysql/plugin_password_validation.h>\n#include <mysql/plugin_encryption.h>\n#include \"sql_plugin_compat.h\"\n\n#ifdef HAVE_LINK_H\n#include <link.h>\n#endif\n\nextern struct st_maria_plugin *mysql_optional_plugins[];\nextern struct st_maria_plugin *mysql_mandatory_plugins[];\n\n/**\n  @note The order of the enumeration is critical.\n  @see construct_options\n*/\nconst char *global_plugin_typelib_names[]=\n  { \"OFF\", \"ON\", \"FORCE\", \"FORCE_PLUS_PERMANENT\", NULL };\nstatic TYPELIB global_plugin_typelib=\n  { array_elements(global_plugin_typelib_names)-1,\n    \"\", global_plugin_typelib_names, NULL };\n\nstatic I_List<i_string> opt_plugin_load_list;\nI_List<i_string> *opt_plugin_load_list_ptr= &opt_plugin_load_list;\nchar *opt_plugin_dir_ptr;\nchar opt_plugin_dir[FN_REFLEN];\nulong plugin_maturity;\n\nstatic LEX_CSTRING MYSQL_PLUGIN_NAME= {STRING_WITH_LEN(\"plugin\") };\n\n/*\n  not really needed now, this map will become essential when we add more\n  maturity levels. We cannot change existing maturity constants,\n  so the next value - even if it will be MariaDB_PLUGIN_MATURITY_VERY_BUGGY -\n  will inevitably be larger than MariaDB_PLUGIN_MATURITY_STABLE.\n  To be able to compare them we use this mapping array\n*/\nuint plugin_maturity_map[]=\n{ 0, 1, 2, 3, 4, 5, 6 };\n\n/*\n  When you add a new plugin type, add both a string and make sure that the\n  init and deinit array are correctly updated.\n*/\nconst LEX_CSTRING plugin_type_names[MYSQL_MAX_PLUGIN_TYPE_NUM]=\n{\n  { STRING_WITH_LEN(\"UDF\") },\n  { STRING_WITH_LEN(\"STORAGE ENGINE\") },\n  { STRING_WITH_LEN(\"FTPARSER\") },\n  { STRING_WITH_LEN(\"DAEMON\") },\n  { STRING_WITH_LEN(\"INFORMATION SCHEMA\") },\n  { STRING_WITH_LEN(\"AUDIT\") },\n  { STRING_WITH_LEN(\"REPLICATION\") },\n  { STRING_WITH_LEN(\"AUTHENTICATION\") },\n  { STRING_WITH_LEN(\"PASSWORD VALIDATION\") },\n  { STRING_WITH_LEN(\"ENCRYPTION\") }\n};\n\nextern int initialize_schema_table(st_plugin_int *plugin);\nextern int finalize_schema_table(st_plugin_int *plugin);\n\nextern int initialize_audit_plugin(st_plugin_int *plugin);\nextern int finalize_audit_plugin(st_plugin_int *plugin);\n\nextern int initialize_encryption_plugin(st_plugin_int *plugin);\nextern int finalize_encryption_plugin(st_plugin_int *plugin);\n\n/*\n  The number of elements in both plugin_type_initialize and\n  plugin_type_deinitialize should equal to the number of plugins\n  defined.\n*/\nplugin_type_init plugin_type_initialize[MYSQL_MAX_PLUGIN_TYPE_NUM]=\n{\n  0, ha_initialize_handlerton, 0, 0,initialize_schema_table,\n  initialize_audit_plugin, 0, 0, 0, initialize_encryption_plugin\n};\n\nplugin_type_init plugin_type_deinitialize[MYSQL_MAX_PLUGIN_TYPE_NUM]=\n{\n  0, ha_finalize_handlerton, 0, 0, finalize_schema_table,\n  finalize_audit_plugin, 0, 0, 0, finalize_encryption_plugin\n};\n\n/*\n  Defines in which order plugin types have to be initialized.\n  Essentially, we want to initialize MYSQL_KEY_MANAGEMENT_PLUGIN before\n  MYSQL_STORAGE_ENGINE_PLUGIN, and that before MYSQL_INFORMATION_SCHEMA_PLUGIN\n*/\nstatic int plugin_type_initialization_order[MYSQL_MAX_PLUGIN_TYPE_NUM]=\n{\n  MYSQL_DAEMON_PLUGIN,\n  MariaDB_ENCRYPTION_PLUGIN,\n  MYSQL_STORAGE_ENGINE_PLUGIN,\n  MYSQL_INFORMATION_SCHEMA_PLUGIN,\n  MYSQL_FTPARSER_PLUGIN,\n  MYSQL_AUTHENTICATION_PLUGIN,\n  MariaDB_PASSWORD_VALIDATION_PLUGIN,\n  MYSQL_AUDIT_PLUGIN,\n  MYSQL_REPLICATION_PLUGIN,\n  MYSQL_UDF_PLUGIN\n};\n\n#ifdef HAVE_DLOPEN\nstatic const char *plugin_interface_version_sym=\n                   \"_mysql_plugin_interface_version_\";\nstatic const char *sizeof_st_plugin_sym=\n                   \"_mysql_sizeof_struct_st_plugin_\";\nstatic const char *plugin_declarations_sym= \"_mysql_plugin_declarations_\";\nstatic int min_plugin_interface_version= MYSQL_PLUGIN_INTERFACE_VERSION & ~0xFF;\nstatic const char *maria_plugin_interface_version_sym=\n                   \"_maria_plugin_interface_version_\";\nstatic const char *maria_sizeof_st_plugin_sym=\n                   \"_maria_sizeof_struct_st_plugin_\";\nstatic const char *maria_plugin_declarations_sym=\n                   \"_maria_plugin_declarations_\";\nstatic int min_maria_plugin_interface_version=\n                   MARIA_PLUGIN_INTERFACE_VERSION & ~0xFF;\n#endif\n\n/* Note that 'int version' must be the first field of every plugin\n   sub-structure (plugin->info).\n*/\nstatic int min_plugin_info_interface_version[MYSQL_MAX_PLUGIN_TYPE_NUM]=\n{\n  0x0000,\n  MYSQL_HANDLERTON_INTERFACE_VERSION,\n  MYSQL_FTPARSER_INTERFACE_VERSION,\n  MYSQL_DAEMON_INTERFACE_VERSION,\n  MYSQL_INFORMATION_SCHEMA_INTERFACE_VERSION,\n  MYSQL_AUDIT_INTERFACE_VERSION,\n  MYSQL_REPLICATION_INTERFACE_VERSION,\n  MIN_AUTHENTICATION_INTERFACE_VERSION,\n  MariaDB_PASSWORD_VALIDATION_INTERFACE_VERSION,\n  MariaDB_ENCRYPTION_INTERFACE_VERSION\n};\nstatic int cur_plugin_info_interface_version[MYSQL_MAX_PLUGIN_TYPE_NUM]=\n{\n  0x0000, /* UDF: not implemented */\n  MYSQL_HANDLERTON_INTERFACE_VERSION,\n  MYSQL_FTPARSER_INTERFACE_VERSION,\n  MYSQL_DAEMON_INTERFACE_VERSION,\n  MYSQL_INFORMATION_SCHEMA_INTERFACE_VERSION,\n  MYSQL_AUDIT_INTERFACE_VERSION,\n  MYSQL_REPLICATION_INTERFACE_VERSION,\n  MYSQL_AUTHENTICATION_INTERFACE_VERSION,\n  MariaDB_PASSWORD_VALIDATION_INTERFACE_VERSION,\n  MariaDB_ENCRYPTION_INTERFACE_VERSION\n};\n\nstatic struct\n{\n  const char *plugin_name;\n  enum enum_plugin_load_option override;\n} override_plugin_load_policy[]={\n  /*\n    If the performance schema is compiled in,\n    treat the storage engine plugin as 'mandatory',\n    to suppress any plugin-level options such as '--performance-schema'.\n    This is specific to the performance schema, and is done on purpose:\n    the server-level option '--performance-schema' controls the overall\n    performance schema initialization, which consists of much more that\n    the underlying storage engine initialization.\n    See mysqld.cc, set_vars.cc.\n    Suppressing ways to interfere directly with the storage engine alone\n    prevents awkward situations where:\n    - the user wants the performance schema functionality, by using\n      '--enable-performance-schema' (the server option),\n    - yet disable explicitly a component needed for the functionality\n      to work, by using '--skip-performance-schema' (the plugin)\n  */\n  { \"performance_schema\", PLUGIN_FORCE }\n\n  /* we disable few other plugins by default */\n  ,{ \"feedback\", PLUGIN_OFF }\n};\n\n/* support for Services */\n\n#include \"sql_plugin_services.ic\"\n\n/*\n  A mutex LOCK_plugin must be acquired before accessing the\n  following variables/structures.\n  We are always manipulating ref count, so a rwlock here is unneccessary.\n*/\nmysql_mutex_t LOCK_plugin;\nstatic DYNAMIC_ARRAY plugin_dl_array;\nstatic DYNAMIC_ARRAY plugin_array;\nstatic HASH plugin_hash[MYSQL_MAX_PLUGIN_TYPE_NUM];\nstatic MEM_ROOT plugin_mem_root;\nstatic bool reap_needed= false;\nvolatile int global_plugin_version= 1;\n\nstatic bool initialized= 0;\nulong dlopen_count;\n\n\n/*\n  write-lock on LOCK_system_variables_hash is required before modifying\n  the following variables/structures\n*/\nstatic MEM_ROOT plugin_vars_mem_root;\nstatic size_t global_variables_dynamic_size= 0;\nstatic HASH bookmark_hash;\n\n\n/*\n  hidden part of opaque value passed to variable check functions.\n  Used to provide a object-like structure to non C++ consumers.\n*/\nstruct st_item_value_holder : public st_mysql_value\n{\n  Item *item;\n};\n\n\n/*\n  stored in bookmark_hash, this structure is never removed from the\n  hash and is used to mark a single offset for a thd local variable\n  even if plugins have been uninstalled and reinstalled, repeatedly.\n  This structure is allocated from plugin_mem_root.\n\n  The key format is as follows:\n    1 byte         - variable type code\n    name_len bytes - variable name\n    '\\0'           - end of key\n*/\nstruct st_bookmark\n{\n  uint name_len;\n  int offset;\n  uint version;\n  bool loaded;\n  char key[1];\n};\n\n\n/*\n  skeleton of a plugin variable - portion of structure common to all.\n*/\nstruct st_mysql_sys_var\n{\n  MYSQL_PLUGIN_VAR_HEADER;\n};\n\nenum install_status { INSTALL_GOOD, INSTALL_FAIL_WARN_OK, INSTALL_FAIL_NOT_OK };\n/*\n  sys_var class for access to all plugin variables visible to the user\n*/\nclass sys_var_pluginvar: public sys_var, public Sql_alloc\n{\npublic:\n  struct st_plugin_int *plugin;\n  struct st_mysql_sys_var *plugin_var;\n\n  sys_var_pluginvar(sys_var_chain *chain, const char *name_arg,\n                    st_plugin_int *p, st_mysql_sys_var *plugin_var_arg);\n  sys_var_pluginvar *cast_pluginvar() { return this; }\n  uchar* real_value_ptr(THD *thd, enum_var_type type);\n  TYPELIB* plugin_var_typelib(void);\n  uchar* do_value_ptr(THD *thd, enum_var_type type, const LEX_CSTRING *base);\n  uchar* session_value_ptr(THD *thd, const LEX_CSTRING *base)\n  { return do_value_ptr(thd, OPT_SESSION, base); }\n  uchar* global_value_ptr(THD *thd, const LEX_CSTRING *base)\n  { return do_value_ptr(thd, OPT_GLOBAL, base); }\n  uchar *default_value_ptr(THD *thd)\n  { return do_value_ptr(thd, OPT_DEFAULT, 0); }\n  bool do_check(THD *thd, set_var *var);\n  virtual void session_save_default(THD *thd, set_var *var) {}\n  virtual void global_save_default(THD *thd, set_var *var) {}\n  bool session_update(THD *thd, set_var *var);\n  bool global_update(THD *thd, set_var *var);\n  bool session_is_default(THD *thd);\n};\n\n\n/* prototypes */\nstatic void plugin_load(MEM_ROOT *tmp_root);\nstatic bool plugin_load_list(MEM_ROOT *, const char *);\nstatic int test_plugin_options(MEM_ROOT *, struct st_plugin_int *,\n                               int *, char **);\nstatic bool register_builtin(struct st_maria_plugin *, struct st_plugin_int *,\n                             struct st_plugin_int **);\nstatic void unlock_variables(THD *thd, struct system_variables *vars);\nstatic void cleanup_variables(struct system_variables *vars);\nstatic void plugin_vars_free_values(sys_var *vars);\nstatic void restore_ptr_backup(uint n, st_ptr_backup *backup);\nstatic void intern_plugin_unlock(LEX *lex, plugin_ref plugin);\nstatic void reap_plugins(void);\n\nbool plugin_is_forced(struct st_plugin_int *p)\n{\n  return p->load_option == PLUGIN_FORCE ||\n         p->load_option == PLUGIN_FORCE_PLUS_PERMANENT;\n}\n\n/**\n   Check if the provided path is valid in the sense that it does cause\n   a relative reference outside the directory.\n\n   @note Currently, this function only check if there are any\n   characters in FN_DIRSEP in the string, but it might change in the\n   future.\n\n   @code\n   check_valid_path(\"../foo.so\") -> true\n   check_valid_path(\"foo.so\") -> false\n   @endcode\n */\nbool check_valid_path(const char *path, size_t len)\n{\n  size_t prefix= my_strcspn(files_charset_info, path, path + len, FN_DIRSEP);\n  return  prefix < len;\n}\n\nstatic void fix_dl_name(MEM_ROOT *root, LEX_CSTRING *dl)\n{\n  const size_t so_ext_len= sizeof(SO_EXT) - 1;\n  if (my_strcasecmp(&my_charset_latin1, dl->str + dl->length - so_ext_len,\n                    SO_EXT))\n  {\n    char *s= (char*)alloc_root(root, dl->length + so_ext_len + 1);\n    memcpy(s, dl->str, dl->length);\n    strcpy(s + dl->length, SO_EXT);\n    dl->str= s;\n    dl->length+= so_ext_len;\n  }\n}\n\n\n/****************************************************************************\n  Value type thunks, allows the C world to play in the C++ world\n****************************************************************************/\n\nstatic int item_value_type(struct st_mysql_value *value)\n{\n  switch (((st_item_value_holder*)value)->item->result_type()) {\n  case INT_RESULT:\n    return MYSQL_VALUE_TYPE_INT;\n  case REAL_RESULT:\n    return MYSQL_VALUE_TYPE_REAL;\n  default:\n    return MYSQL_VALUE_TYPE_STRING;\n  }\n}\n\nstatic const char *item_val_str(struct st_mysql_value *value,\n                                char *buffer, int *length)\n{\n  String str(buffer, *length, system_charset_info), *res;\n  if (!(res= ((st_item_value_holder*)value)->item->val_str(&str)))\n    return NULL;\n  *length= res->length();\n  if (res->c_ptr_quick() == buffer)\n    return buffer;\n\n  /*\n    Lets be nice and create a temporary string since the\n    buffer was too small\n  */\n  return current_thd->strmake(res->ptr(), res->length());\n}\n\n\nstatic int item_val_int(struct st_mysql_value *value, long long *buf)\n{\n  Item *item= ((st_item_value_holder*)value)->item;\n  *buf= item->val_int();\n  if (item->is_null())\n    return 1;\n  return 0;\n}\n\nstatic int item_is_unsigned(struct st_mysql_value *value)\n{\n  Item *item= ((st_item_value_holder*)value)->item;\n  return item->unsigned_flag;\n}\n\nstatic int item_val_real(struct st_mysql_value *value, double *buf)\n{\n  Item *item= ((st_item_value_holder*)value)->item;\n  *buf= item->val_real();\n  if (item->is_null())\n    return 1;\n  return 0;\n}\n\n\n/****************************************************************************\n  Plugin support code\n****************************************************************************/\n\n#ifdef HAVE_DLOPEN\n\nstatic struct st_plugin_dl *plugin_dl_find(const LEX_CSTRING *dl)\n{\n  uint i;\n  struct st_plugin_dl *tmp;\n  DBUG_ENTER(\"plugin_dl_find\");\n  for (i= 0; i < plugin_dl_array.elements; i++)\n  {\n    tmp= *dynamic_element(&plugin_dl_array, i, struct st_plugin_dl **);\n    if (tmp->ref_count &&\n        ! my_strnncoll(files_charset_info,\n                       (const uchar *)dl->str, dl->length,\n                       (const uchar *)tmp->dl.str, tmp->dl.length))\n      DBUG_RETURN(tmp);\n  }\n  DBUG_RETURN(0);\n}\n\n\nstatic st_plugin_dl *plugin_dl_insert_or_reuse(struct st_plugin_dl *plugin_dl)\n{\n  uint i;\n  struct st_plugin_dl *tmp;\n  DBUG_ENTER(\"plugin_dl_insert_or_reuse\");\n  for (i= 0; i < plugin_dl_array.elements; i++)\n  {\n    tmp= *dynamic_element(&plugin_dl_array, i, struct st_plugin_dl **);\n    if (! tmp->ref_count)\n    {\n      memcpy(tmp, plugin_dl, sizeof(struct st_plugin_dl));\n      DBUG_RETURN(tmp);\n    }\n  }\n  if (insert_dynamic(&plugin_dl_array, (uchar*)&plugin_dl))\n    DBUG_RETURN(0);\n  tmp= *dynamic_element(&plugin_dl_array, plugin_dl_array.elements - 1,\n                        struct st_plugin_dl **)=\n      (struct st_plugin_dl *) memdup_root(&plugin_mem_root, (uchar*)plugin_dl,\n                                           sizeof(struct st_plugin_dl));\n  DBUG_RETURN(tmp);\n}\n#else\nstatic struct st_plugin_dl *plugin_dl_find(const LEX_STRING *)\n{\n  return 0;\n}\n#endif /* HAVE_DLOPEN */\n\n\nstatic void free_plugin_mem(struct st_plugin_dl *p)\n{\n#ifdef HAVE_DLOPEN\n  if (p->ptr_backup)\n  {\n    DBUG_ASSERT(p->nbackups);\n    DBUG_ASSERT(p->handle);\n    restore_ptr_backup(p->nbackups, p->ptr_backup);\n    my_free(p->ptr_backup);\n  }\n  if (p->handle)\n    dlclose(p->handle);\n#endif\n  my_free(const_cast<char*>(p->dl.str));\n  if (p->allocated)\n    my_free(p->plugins);\n}\n\n\n/**\n  Reads data from mysql plugin interface\n\n  @param plugin_dl       Structure where the data should be put\n  @param sym             Reverence on version info\n  @param dlpath          Path to the module\n  @param MyFlags         Where errors should be reported (0 or ME_ERROR_LOG)\n\n  @retval FALSE OK\n  @retval TRUE  ERROR\n*/\n\n#ifdef HAVE_DLOPEN\nstatic my_bool read_mysql_plugin_info(struct st_plugin_dl *plugin_dl,\n                                      void *sym, char *dlpath, myf MyFlags)\n{\n  DBUG_ENTER(\"read_maria_plugin_info\");\n  /* Determine interface version */\n  if (!sym)\n  {\n    my_error(ER_CANT_FIND_DL_ENTRY, MyFlags, plugin_interface_version_sym);\n    DBUG_RETURN(TRUE);\n  }\n  plugin_dl->mariaversion= 0;\n  plugin_dl->mysqlversion= *(int *)sym;\n  /* Versioning */\n  if (plugin_dl->mysqlversion < min_plugin_interface_version ||\n      (plugin_dl->mysqlversion >> 8) > (MYSQL_PLUGIN_INTERFACE_VERSION >> 8))\n  {\n    my_error(ER_CANT_OPEN_LIBRARY, MyFlags, dlpath, ENOEXEC,\n                 \"plugin interface version mismatch\");\n    DBUG_RETURN(TRUE);\n  }\n  /* Find plugin declarations */\n  if (!(sym= dlsym(plugin_dl->handle, plugin_declarations_sym)))\n  {\n    my_error(ER_CANT_FIND_DL_ENTRY, MyFlags, plugin_declarations_sym);\n    DBUG_RETURN(TRUE);\n  }\n\n  /* convert mysql declaration to maria one */\n  {\n    int i;\n    uint sizeof_st_plugin;\n    struct st_mysql_plugin *old;\n    struct st_maria_plugin *cur;\n    char *ptr= (char *)sym;\n\n    if ((sym= dlsym(plugin_dl->handle, sizeof_st_plugin_sym)))\n      sizeof_st_plugin= *(int *)sym;\n    else\n    {\n      DBUG_ASSERT(min_plugin_interface_version == 0);\n      sizeof_st_plugin= (int)offsetof(struct st_mysql_plugin, version);\n    }\n\n    for (i= 0;\n         ((struct st_mysql_plugin *)(ptr + i * sizeof_st_plugin))->info;\n         i++)\n      /* no op */;\n\n    cur= (struct st_maria_plugin*)\n          my_malloc((i + 1) * sizeof(struct st_maria_plugin),\n                    MYF(MY_ZEROFILL|MY_WME));\n    if (!cur)\n    {\n      my_error(ER_OUTOFMEMORY, MyFlags,\n                   static_cast<int>(plugin_dl->dl.length));\n      DBUG_RETURN(TRUE);\n    }\n    /*\n      All st_plugin fields not initialized in the plugin explicitly, are\n      set to 0. It matches C standard behaviour for struct initializers that\n      have less values than the struct definition.\n    */\n    for (i=0;\n         (old= (struct st_mysql_plugin *)(ptr + i * sizeof_st_plugin))->info;\n         i++)\n    {\n\n      cur[i].type= old->type;\n      cur[i].info= old->info;\n      cur[i].name= old->name;\n      cur[i].author= old->author;\n      cur[i].descr= old->descr;\n      cur[i].license= old->license;\n      cur[i].init= old->init;\n      cur[i].deinit= old->deinit;\n      cur[i].version= old->version;\n      cur[i].status_vars= old->status_vars;\n      cur[i].system_vars= old->system_vars;\n      /*\n        Something like this should be added to process\n        new mysql plugin versions:\n        if (plugin_dl->mysqlversion > 0x0101)\n        {\n           cur[i].newfield= CONSTANT_MEANS_UNKNOWN;\n        }\n        else\n        {\n           cur[i].newfield= old->newfield;\n        }\n      */\n      /* Maria only fields */\n      cur[i].version_info= \"Unknown\";\n      cur[i].maturity= MariaDB_PLUGIN_MATURITY_UNKNOWN;\n    }\n    plugin_dl->allocated= true;\n    plugin_dl->plugins= (struct st_maria_plugin *)cur;\n  }\n\n  DBUG_RETURN(FALSE);\n}\n\n\n/**\n  Reads data from maria plugin interface\n\n  @param plugin_dl       Structure where the data should be put\n  @param sym             Reverence on version info\n  @param dlpath          Path to the module\n  @param MyFlags         Where errors should be reported (0 or ME_ERROR_LOG)\n\n  @retval FALSE OK\n  @retval TRUE  ERROR\n*/\n\nstatic my_bool read_maria_plugin_info(struct st_plugin_dl *plugin_dl,\n                                      void *sym, char *dlpath, myf MyFlags)\n{\n  DBUG_ENTER(\"read_maria_plugin_info\");\n\n  /* Determine interface version */\n  if (!(sym))\n  {\n    /*\n      Actually this branch impossible because in case of absence of maria\n      version we try mysql version.\n    */\n    my_error(ER_CANT_FIND_DL_ENTRY, MyFlags,\n                 maria_plugin_interface_version_sym);\n    DBUG_RETURN(TRUE);\n  }\n  plugin_dl->mariaversion= *(int *)sym;\n  plugin_dl->mysqlversion= 0;\n  /* Versioning */\n  if (plugin_dl->mariaversion < min_maria_plugin_interface_version ||\n      (plugin_dl->mariaversion >> 8) > (MARIA_PLUGIN_INTERFACE_VERSION >> 8))\n  {\n    my_error(ER_CANT_OPEN_LIBRARY, MyFlags, dlpath, ENOEXEC,\n                 \"plugin interface version mismatch\");\n    DBUG_RETURN(TRUE);\n  }\n  /* Find plugin declarations */\n  if (!(sym= dlsym(plugin_dl->handle, maria_plugin_declarations_sym)))\n  {\n    my_error(ER_CANT_FIND_DL_ENTRY, MyFlags, maria_plugin_declarations_sym);\n    DBUG_RETURN(TRUE);\n  }\n  if (plugin_dl->mariaversion != MARIA_PLUGIN_INTERFACE_VERSION)\n  {\n    uint sizeof_st_plugin;\n    struct st_maria_plugin *old, *cur;\n    char *ptr= (char *)sym;\n\n    if ((sym= dlsym(plugin_dl->handle, maria_sizeof_st_plugin_sym)))\n      sizeof_st_plugin= *(int *)sym;\n    else\n    {\n      my_error(ER_CANT_FIND_DL_ENTRY, MyFlags, maria_sizeof_st_plugin_sym);\n      DBUG_RETURN(TRUE);\n    }\n\n    if (sizeof_st_plugin != sizeof(st_mysql_plugin))\n    {\n      int i;\n      for (i= 0;\n           ((struct st_maria_plugin *)(ptr + i * sizeof_st_plugin))->info;\n           i++)\n        /* no op */;\n\n      cur= (struct st_maria_plugin*)\n        my_malloc((i + 1) * sizeof(struct st_maria_plugin),\n                  MYF(MY_ZEROFILL|MY_WME));\n      if (!cur)\n      {\n        my_error(ER_OUTOFMEMORY, MyFlags,\n                     static_cast<int>(plugin_dl->dl.length));\n        DBUG_RETURN(TRUE);\n      }\n      /*\n        All st_plugin fields not initialized in the plugin explicitly, are\n        set to 0. It matches C standard behaviour for struct initializers that\n        have less values than the struct definition.\n      */\n      for (i=0;\n           (old= (struct st_maria_plugin *)(ptr + i * sizeof_st_plugin))->info;\n           i++)\n        memcpy(cur + i, old, MY_MIN(sizeof(cur[i]), sizeof_st_plugin));\n\n      sym= cur;\n      plugin_dl->allocated= true;\n    }\n    else\n      sym= ptr;\n  }\n  plugin_dl->plugins= (struct st_maria_plugin *)sym;\n\n  DBUG_RETURN(FALSE);\n}\n#endif /* HAVE_DLOPEN */\n\nstatic st_plugin_dl *plugin_dl_add(const LEX_CSTRING *dl, myf MyFlags)\n{\n#ifdef HAVE_DLOPEN\n  char dlpath[FN_REFLEN];\n  size_t plugin_dir_len,i;\n  uint dummy_errors;\n  struct st_plugin_dl *tmp= 0, plugin_dl;\n  void *sym;\n  st_ptr_backup tmp_backup[array_elements(list_of_services)];\n  DBUG_ENTER(\"plugin_dl_add\");\n  DBUG_PRINT(\"enter\", (\"dl->str: '%s', dl->length: %d\",\n                       dl->str, (int) dl->length));\n  mysql_mutex_assert_owner(&LOCK_plugin);\n  plugin_dir_len= strlen(opt_plugin_dir);\n  /*\n    Ensure that the dll doesn't have a path.\n    This is done to ensure that only approved libraries from the\n    plugin directory are used (to make this even remotely secure).\n  */\n  if (check_string_char_length((LEX_CSTRING *) dl, 0, NAME_CHAR_LEN,\n                               system_charset_info, 1) ||\n      check_valid_path(dl->str, dl->length) ||\n      plugin_dir_len + dl->length + 1 >= FN_REFLEN)\n  {\n    my_error(ER_UDF_NO_PATHS, MyFlags);\n    DBUG_RETURN(0);\n  }\n  /* If this dll is already loaded just increase ref_count. */\n  if ((tmp= plugin_dl_find(dl)))\n  {\n    tmp->ref_count++;\n    DBUG_RETURN(tmp);\n  }\n  bzero(&plugin_dl, sizeof(plugin_dl));\n  /* Compile dll path */\n  strxnmov(dlpath, sizeof(dlpath) - 1, opt_plugin_dir, \"/\", dl->str, NullS);\n  (void) unpack_filename(dlpath, dlpath);\n  plugin_dl.ref_count= 1;\n  /* Open new dll handle */\n  if (!(plugin_dl.handle= dlopen(dlpath, RTLD_NOW)))\n  {\n    my_error(ER_CANT_OPEN_LIBRARY, MyFlags, dlpath, errno, my_dlerror(dlpath));\n    goto ret;\n  }\n  dlopen_count++;\n\n#ifdef HAVE_LINK_H\n  if (global_system_variables.log_warnings > 2)\n  {\n    struct link_map *lm = (struct link_map*) plugin_dl.handle;\n    sql_print_information(\"Loaded '%s' with offset 0x%zx\", dl->str, (size_t)lm->l_addr);\n  }\n#endif\n\n  /* Checks which plugin interface present and reads info */\n  if (!(sym= dlsym(plugin_dl.handle, maria_plugin_interface_version_sym)))\n  {\n    if (read_mysql_plugin_info(&plugin_dl,\n                               dlsym(plugin_dl.handle,\n                                     plugin_interface_version_sym),\n                               dlpath,\n                               MyFlags))\n      goto ret;\n  }\n  else\n  {\n    if (read_maria_plugin_info(&plugin_dl, sym, dlpath, MyFlags))\n      goto ret;\n  }\n\n  /* link the services in */\n  for (i= 0; i < array_elements(list_of_services); i++)\n  {\n    if ((sym= dlsym(plugin_dl.handle, list_of_services[i].name)))\n    {\n      void **ptr= (void **)sym;\n      uint ver= (uint)(intptr)*ptr;\n      if (ver > list_of_services[i].version ||\n        (ver >> 8) < (list_of_services[i].version >> 8))\n      {\n        char buf[MYSQL_ERRMSG_SIZE];\n        my_snprintf(buf, sizeof(buf),\n                    \"service '%s' interface version mismatch\",\n                    list_of_services[i].name);\n        my_error(ER_CANT_OPEN_LIBRARY, MyFlags, dlpath, ENOEXEC, buf);\n        goto ret;\n      }\n      tmp_backup[plugin_dl.nbackups++].save(ptr);\n      *ptr= list_of_services[i].service;\n    }\n  }\n\n  if (plugin_dl.nbackups)\n  {\n    size_t bytes= plugin_dl.nbackups * sizeof(plugin_dl.ptr_backup[0]);\n    plugin_dl.ptr_backup= (st_ptr_backup *)my_malloc(bytes, MYF(0));\n    if (!plugin_dl.ptr_backup)\n    {\n      restore_ptr_backup(plugin_dl.nbackups, tmp_backup);\n      my_error(ER_OUTOFMEMORY, MyFlags, bytes);\n      goto ret;\n    }\n    memcpy(plugin_dl.ptr_backup, tmp_backup, bytes);\n  }\n\n  /* Duplicate and convert dll name */\n  plugin_dl.dl.length= dl->length * files_charset_info->mbmaxlen + 1;\n  if (! (plugin_dl.dl.str= (char*) my_malloc(plugin_dl.dl.length, MYF(0))))\n  {\n    my_error(ER_OUTOFMEMORY, MyFlags,\n                 static_cast<int>(plugin_dl.dl.length));\n    goto ret;\n  }\n  plugin_dl.dl.length= copy_and_convert((char*) plugin_dl.dl.str,\n                                        plugin_dl.dl.length,\n                                        files_charset_info, dl->str,\n                                        dl->length, system_charset_info,\n                                        &dummy_errors);\n  ((char*) plugin_dl.dl.str)[plugin_dl.dl.length]= 0;\n  /* Add this dll to array */\n  if (! (tmp= plugin_dl_insert_or_reuse(&plugin_dl)))\n  {\n    my_error(ER_OUTOFMEMORY, MyFlags,\n                 static_cast<int>(sizeof(struct st_plugin_dl)));\n    goto ret;\n  }\n\nret:\n  if (!tmp)\n    free_plugin_mem(&plugin_dl);\n\n  DBUG_RETURN(tmp);\n\n#else\n  DBUG_ENTER(\"plugin_dl_add\");\n  my_error(ER_FEATURE_DISABLED, MyFlags, \"plugin\", \"HAVE_DLOPEN\");\n  DBUG_RETURN(0);\n#endif\n}\n\n\nstatic void plugin_dl_del(struct st_plugin_dl *plugin_dl)\n{\n  DBUG_ENTER(\"plugin_dl_del\");\n\n  if (!plugin_dl)\n    DBUG_VOID_RETURN;\n\n  mysql_mutex_assert_owner(&LOCK_plugin);\n\n  /* Do not remove this element, unless no other plugin uses this dll. */\n  if (! --plugin_dl->ref_count)\n  {\n    free_plugin_mem(plugin_dl);\n    bzero(plugin_dl, sizeof(struct st_plugin_dl));\n  }\n\n  DBUG_VOID_RETURN;\n}\n\n\nstatic struct st_plugin_int *plugin_find_internal(const LEX_CSTRING *name,\n                                                  int type)\n{\n  uint i;\n  DBUG_ENTER(\"plugin_find_internal\");\n  if (! initialized)\n    DBUG_RETURN(0);\n\n  mysql_mutex_assert_owner(&LOCK_plugin);\n\n  if (type == MYSQL_ANY_PLUGIN)\n  {\n    for (i= 0; i < MYSQL_MAX_PLUGIN_TYPE_NUM; i++)\n    {\n      struct st_plugin_int *plugin= (st_plugin_int *)\n        my_hash_search(&plugin_hash[i], (const uchar *)name->str, name->length);\n      if (plugin)\n        DBUG_RETURN(plugin);\n    }\n  }\n  else\n    DBUG_RETURN((st_plugin_int *)\n        my_hash_search(&plugin_hash[type], (const uchar *)name->str,\n                       name->length));\n  DBUG_RETURN(0);\n}\n\n\nstatic SHOW_COMP_OPTION plugin_status(const LEX_CSTRING *name, int type)\n{\n  SHOW_COMP_OPTION rc= SHOW_OPTION_NO;\n  struct st_plugin_int *plugin;\n  DBUG_ENTER(\"plugin_is_ready\");\n  mysql_mutex_lock(&LOCK_plugin);\n  if ((plugin= plugin_find_internal(name, type)))\n  {\n    rc= SHOW_OPTION_DISABLED;\n    if (plugin->state == PLUGIN_IS_READY)\n      rc= SHOW_OPTION_YES;\n  }\n  mysql_mutex_unlock(&LOCK_plugin);\n  DBUG_RETURN(rc);\n}\n\n\nbool plugin_is_ready(const LEX_CSTRING *name, int type)\n{\n  bool rc= FALSE;\n  if (plugin_status(name, type) == SHOW_OPTION_YES)\n    rc= TRUE;\n  return rc;\n}\n\n\nSHOW_COMP_OPTION plugin_status(const char *name, size_t len, int type)\n{\n  LEX_CSTRING plugin_name= { name, len };\n  return plugin_status(&plugin_name, type);\n}\n\n\n/*\n  If LEX is passed non-NULL, an automatic unlock of the plugin will happen\n  in the LEX destructor.\n*/\nstatic plugin_ref intern_plugin_lock(LEX *lex, plugin_ref rc,\n                                     uint state_mask= PLUGIN_IS_READY |\n                                                      PLUGIN_IS_UNINITIALIZED |\n                                                      PLUGIN_IS_DELETED)\n{\n  st_plugin_int *pi= plugin_ref_to_int(rc);\n  DBUG_ENTER(\"intern_plugin_lock\");\n\n  mysql_mutex_assert_owner(&LOCK_plugin);\n\n  if (pi->state & state_mask)\n  {\n    plugin_ref plugin;\n#ifdef DBUG_OFF\n    /*\n      In optimized builds we don't do reference counting for built-in\n      (plugin->plugin_dl == 0) plugins.\n    */\n    if (!pi->plugin_dl)\n      DBUG_RETURN(pi);\n\n    plugin= pi;\n#else\n    /*\n      For debugging, we do an additional malloc which allows the\n      memory manager and/or valgrind to track locked references and\n      double unlocks to aid resolving reference counting problems.\n    */\n    if (!(plugin= (plugin_ref) my_malloc(sizeof(pi), MYF(MY_WME))))\n      DBUG_RETURN(NULL);\n\n    *plugin= pi;\n#endif\n    pi->ref_count++;\n    DBUG_PRINT(\"lock\",(\"thd: %p  plugin: \\\"%s\\\" LOCK ref_count: %d\",\n                       current_thd, pi->name.str, pi->ref_count));\n\n    if (lex)\n      insert_dynamic(&lex->plugins, (uchar*)&plugin);\n    DBUG_RETURN(plugin);\n  }\n  DBUG_RETURN(NULL);\n}\n\n\n/*\n  Notes on lifetime:\n\n  If THD is passed as non-NULL (and with a non-NULL thd->lex), an entry is made\n  in the thd->lex which will cause an automatic unlock of the plugin in the LEX\n  destructor. In this case, no manual unlock must be done.\n\n  Otherwise, when passing a NULL THD, the caller must arrange that plugin\n  unlock happens later.\n*/\nplugin_ref plugin_lock(THD *thd, plugin_ref ptr)\n{\n  LEX *lex= thd ? thd->lex : 0;\n  plugin_ref rc;\n  DBUG_ENTER(\"plugin_lock\");\n\n#ifdef DBUG_OFF\n  /*\n    In optimized builds we don't do reference counting for built-in\n    (plugin->plugin_dl == 0) plugins.\n\n    Note that we access plugin->plugin_dl outside of LOCK_plugin, and for\n    dynamic plugins a 'plugin' could correspond to plugin that was unloaded\n    meanwhile!  But because st_plugin_int is always allocated on\n    plugin_mem_root, the pointer can never be invalid - the memory is never\n    freed.\n    Of course, the memory that 'plugin' points to can be overwritten by\n    another plugin being loaded, but plugin->plugin_dl can never change\n    from zero to non-zero or vice versa.\n    That is, it's always safe to check for plugin->plugin_dl==0 even\n    without a mutex.\n  */\n  if (! plugin_dlib(ptr))\n  {\n    plugin_ref_to_int(ptr)->locks_total++;\n    DBUG_RETURN(ptr);\n  }\n#endif\n  mysql_mutex_lock(&LOCK_plugin);\n  plugin_ref_to_int(ptr)->locks_total++;\n  rc= intern_plugin_lock(lex, ptr);\n  mysql_mutex_unlock(&LOCK_plugin);\n  DBUG_RETURN(rc);\n}\n\n\n/*\n  Notes on lifetime:\n\n  If THD is passed as non-NULL (and with a non-NULL thd->lex), an entry is made\n  in the thd->lex which will cause an automatic unlock of the plugin in the LEX\n  destructor. In this case, no manual unlock must be done.\n\n  Otherwise, when passing a NULL THD, the caller must arrange that plugin\n  unlock happens later.\n*/\nplugin_ref plugin_lock_by_name(THD *thd, const LEX_CSTRING *name, int type)\n{\n  LEX *lex= thd ? thd->lex : 0;\n  plugin_ref rc= NULL;\n  st_plugin_int *plugin;\n  DBUG_ENTER(\"plugin_lock_by_name\");\n  mysql_mutex_lock(&LOCK_plugin);\n  if ((plugin= plugin_find_internal(name, type)))\n    rc= intern_plugin_lock(lex, plugin_int_to_ref(plugin));\n  mysql_mutex_unlock(&LOCK_plugin);\n  DBUG_RETURN(rc);\n}\n\n\nstatic st_plugin_int *plugin_insert_or_reuse(struct st_plugin_int *plugin)\n{\n  uint i;\n  struct st_plugin_int *tmp;\n  DBUG_ENTER(\"plugin_insert_or_reuse\");\n  for (i= 0; i < plugin_array.elements; i++)\n  {\n    tmp= *dynamic_element(&plugin_array, i, struct st_plugin_int **);\n    if (tmp->state == PLUGIN_IS_FREED)\n    {\n      memcpy(tmp, plugin, sizeof(struct st_plugin_int));\n      DBUG_RETURN(tmp);\n    }\n  }\n  if (insert_dynamic(&plugin_array, (uchar*)&plugin))\n    DBUG_RETURN(0);\n  tmp= *dynamic_element(&plugin_array, plugin_array.elements - 1,\n                        struct st_plugin_int **)=\n       (struct st_plugin_int *) memdup_root(&plugin_mem_root, (uchar*)plugin,\n                                            sizeof(struct st_plugin_int));\n  DBUG_RETURN(tmp);\n}\n\n\n/*\n  NOTE\n    Requires that a write-lock is held on LOCK_system_variables_hash\n*/\nstatic enum install_status plugin_add(MEM_ROOT *tmp_root, bool if_not_exists,\n                       const LEX_CSTRING *name, LEX_CSTRING *dl, myf MyFlags)\n{\n  struct st_plugin_int tmp, *maybe_dupe;\n  struct st_maria_plugin *plugin;\n  uint oks= 0, errs= 0, dupes= 0;\n  DBUG_ENTER(\"plugin_add\");\n  DBUG_PRINT(\"enter\", (\"name: %s  dl: %s\", name->str, dl->str));\n\n  if (name->str && plugin_find_internal(name, MYSQL_ANY_PLUGIN))\n  {\n    if (if_not_exists)\n      MyFlags|= ME_NOTE;\n    my_error(ER_PLUGIN_INSTALLED, MyFlags, name->str);\n    DBUG_RETURN(if_not_exists ? INSTALL_FAIL_WARN_OK : INSTALL_FAIL_NOT_OK);\n  }\n  /* Clear the whole struct to catch future extensions. */\n  bzero((char*) &tmp, sizeof(tmp));\n  fix_dl_name(tmp_root, dl);\n  if (! (tmp.plugin_dl= plugin_dl_add(dl, MyFlags)))\n    DBUG_RETURN(INSTALL_FAIL_NOT_OK);\n  /* Find plugin by name */\n  for (plugin= tmp.plugin_dl->plugins; plugin->info; plugin++)\n  {\n    tmp.name.str= (char *)plugin->name;\n    tmp.name.length= strlen(plugin->name);\n\n    if (plugin->type < 0 || plugin->type >= MYSQL_MAX_PLUGIN_TYPE_NUM)\n      continue; // invalid plugin type\n\n    if (plugin->type == MYSQL_UDF_PLUGIN ||\n        (plugin->type == MariaDB_PASSWORD_VALIDATION_PLUGIN &&\n         tmp.plugin_dl->mariaversion == 0))\n      continue; // unsupported plugin type\n\n    if (name->str && my_strnncoll(system_charset_info,\n                                  (const uchar *)name->str, name->length,\n                                  (const uchar *)tmp.name.str, tmp.name.length))\n      continue; // plugin name doesn't match\n\n    if (!name->str &&\n        (maybe_dupe= plugin_find_internal(&tmp.name, MYSQL_ANY_PLUGIN)))\n    {\n      if (plugin->name != maybe_dupe->plugin->name)\n      {\n        my_error(ER_UDF_EXISTS, MyFlags, plugin->name);\n        DBUG_RETURN(INSTALL_FAIL_NOT_OK);\n      }\n      dupes++;\n      continue; // already installed\n    }\n    struct st_plugin_int *tmp_plugin_ptr;\n    if (*(int*)plugin->info <\n        min_plugin_info_interface_version[plugin->type] ||\n        ((*(int*)plugin->info) >> 8) >\n        (cur_plugin_info_interface_version[plugin->type] >> 8))\n    {\n      char buf[256];\n      strxnmov(buf, sizeof(buf) - 1, \"API version for \",\n               plugin_type_names[plugin->type].str,\n               \" plugin \", tmp.name.str,\n               \" not supported by this version of the server\", NullS);\n      my_error(ER_CANT_OPEN_LIBRARY, MyFlags, dl->str, ENOEXEC, buf);\n      goto err;\n    }\n\n    if (plugin_maturity_map[plugin->maturity] < plugin_maturity)\n    {\n      char buf[256];\n      strxnmov(buf, sizeof(buf) - 1, \"Loading of \",\n               plugin_maturity_names[plugin->maturity],\n               \" plugin \", tmp.name.str,\n               \" is prohibited by --plugin-maturity=\",\n               plugin_maturity_names[plugin_maturity],\n               NullS);\n      my_error(ER_CANT_OPEN_LIBRARY, MyFlags, dl->str, EPERM, buf);\n      goto err;\n    }\n    else if (plugin_maturity_map[plugin->maturity] < SERVER_MATURITY_LEVEL)\n    {\n      sql_print_warning(\"Plugin '%s' is of maturity level %s while the server is %s\",\n        tmp.name.str,\n        plugin_maturity_names[plugin->maturity],\n        plugin_maturity_names[SERVER_MATURITY_LEVEL]);\n    }\n\n    tmp.plugin= plugin;\n    tmp.ref_count= 0;\n    tmp.state= PLUGIN_IS_UNINITIALIZED;\n    tmp.load_option= PLUGIN_ON;\n\n    if (!(tmp_plugin_ptr= plugin_insert_or_reuse(&tmp)))\n      goto err;\n    if (my_hash_insert(&plugin_hash[plugin->type], (uchar*)tmp_plugin_ptr))\n      tmp_plugin_ptr->state= PLUGIN_IS_FREED;\n    init_alloc_root(&tmp_plugin_ptr->mem_root, \"plugin\", 4096, 4096, MYF(0));\n\n    if (name->str)\n      DBUG_RETURN(INSTALL_GOOD); // all done\n\n    oks++;\n    tmp.plugin_dl->ref_count++;\n    continue; // otherwise - go on\n\nerr:\n    errs++;\n    if (name->str)\n      break;\n  }\n\n  DBUG_ASSERT(!name->str || !dupes); // dupes is ONLY for name->str == 0\n\n  if (errs == 0 && oks == 0 && !dupes) // no plugin was found\n    my_error(ER_CANT_FIND_DL_ENTRY, MyFlags, name->str);\n\n  plugin_dl_del(tmp.plugin_dl);\n  if (errs > 0 || oks + dupes == 0)\n    DBUG_RETURN(INSTALL_FAIL_NOT_OK);\n  DBUG_RETURN(INSTALL_GOOD);\n}\n\nstatic void plugin_variables_deinit(struct st_plugin_int *plugin)\n{\n\n  for (sys_var *var= plugin->system_vars; var; var= var->next)\n    (*var->test_load)= FALSE;\n  mysql_del_sys_var_chain(plugin->system_vars);\n}\n\nstatic void plugin_deinitialize(struct st_plugin_int *plugin, bool ref_check)\n{\n  /*\n    we don't want to hold the LOCK_plugin mutex as it may cause\n    deinitialization to deadlock if plugins have worker threads\n    with plugin locks\n  */\n  mysql_mutex_assert_not_owner(&LOCK_plugin);\n\n  if (plugin->plugin->status_vars)\n  {\n    /*\n      historical ndb behavior caused MySQL plugins to specify\n      status var names in full, with the plugin name prefix.\n      this was never fixed in MySQL.\n      MariaDB fixes that but supports MySQL style too.\n    */\n    SHOW_VAR *show_vars= plugin->plugin->status_vars;\n    SHOW_VAR tmp_array[2]= {\n      {plugin->plugin->name, (char*)plugin->plugin->status_vars, SHOW_ARRAY},\n      {0, 0, SHOW_UNDEF}\n    };\n    if (strncasecmp(show_vars->name, plugin->name.str, plugin->name.length))\n      show_vars= tmp_array;\n\n    remove_status_vars(show_vars);\n  }\n\n  if (plugin_type_deinitialize[plugin->plugin->type])\n  {\n    if ((*plugin_type_deinitialize[plugin->plugin->type])(plugin))\n    {\n      sql_print_error(\"Plugin '%s' of type %s failed deinitialization\",\n                      plugin->name.str, plugin_type_names[plugin->plugin->type].str);\n    }\n  }\n  else if (plugin->plugin->deinit)\n  {\n    DBUG_PRINT(\"info\", (\"Deinitializing plugin: '%s'\", plugin->name.str));\n    if (plugin->plugin->deinit(plugin))\n    {\n      DBUG_PRINT(\"warning\", (\"Plugin '%s' deinit function returned error.\",\n                             plugin->name.str));\n    }\n  }\n  plugin->state= PLUGIN_IS_UNINITIALIZED;\n\n  if (ref_check && plugin->ref_count)\n    sql_print_error(\"Plugin '%s' has ref_count=%d after deinitialization.\",\n                    plugin->name.str, plugin->ref_count);\n  plugin_variables_deinit(plugin);\n}\n\nstatic void plugin_del(struct st_plugin_int *plugin)\n{\n  DBUG_ENTER(\"plugin_del\");\n  mysql_mutex_assert_owner(&LOCK_plugin);\n  /* Free allocated strings before deleting the plugin. */\n  plugin_vars_free_values(plugin->system_vars);\n  restore_ptr_backup(plugin->nbackups, plugin->ptr_backup);\n  if (plugin->plugin_dl)\n  {\n    my_hash_delete(&plugin_hash[plugin->plugin->type], (uchar*)plugin);\n    plugin_dl_del(plugin->plugin_dl);\n    plugin->state= PLUGIN_IS_FREED;\n    free_root(&plugin->mem_root, MYF(0));\n  }\n  else\n    plugin->state= PLUGIN_IS_UNINITIALIZED;\n  DBUG_VOID_RETURN;\n}\n\nstatic void reap_plugins(void)\n{\n  uint count;\n  struct st_plugin_int *plugin, **reap, **list;\n\n  mysql_mutex_assert_owner(&LOCK_plugin);\n\n  if (!reap_needed)\n    return;\n\n  reap_needed= false;\n  count= plugin_array.elements;\n  reap= (struct st_plugin_int **)my_alloca(sizeof(plugin)*(count+1));\n  *(reap++)= NULL;\n\n  for (uint i=0; i < MYSQL_MAX_PLUGIN_TYPE_NUM; i++)\n  {\n    HASH *hash= plugin_hash + plugin_type_initialization_order[i];\n    for (uint j= 0; j < hash->records; j++)\n    {\n      plugin= (struct st_plugin_int *) my_hash_element(hash, j);\n      if (plugin->state == PLUGIN_IS_DELETED && !plugin->ref_count)\n      {\n        /* change the status flag to prevent reaping by another thread */\n        plugin->state= PLUGIN_IS_DYING;\n        *(reap++)= plugin;\n      }\n    }\n  }\n\n  mysql_mutex_unlock(&LOCK_plugin);\n\n  list= reap;\n  while ((plugin= *(--list)))\n      plugin_deinitialize(plugin, true);\n\n  mysql_mutex_lock(&LOCK_plugin);\n\n  while ((plugin= *(--reap)))\n    plugin_del(plugin);\n\n  my_afree(reap);\n}\n\nstatic void intern_plugin_unlock(LEX *lex, plugin_ref plugin)\n{\n  int i;\n  st_plugin_int *pi;\n  DBUG_ENTER(\"intern_plugin_unlock\");\n\n  mysql_mutex_assert_owner(&LOCK_plugin);\n\n  if (!plugin)\n    DBUG_VOID_RETURN;\n\n  pi= plugin_ref_to_int(plugin);\n\n#ifdef DBUG_OFF\n  if (!pi->plugin_dl)\n    DBUG_VOID_RETURN;\n#else\n  my_free(plugin);\n#endif\n\n  if (lex)\n  {\n    /*\n      Remove one instance of this plugin from the use list.\n      We are searching backwards so that plugins locked last\n      could be unlocked faster - optimizing for LIFO semantics.\n    */\n    for (i= lex->plugins.elements - 1; i >= 0; i--)\n      if (plugin == *dynamic_element(&lex->plugins, i, plugin_ref*))\n      {\n        delete_dynamic_element(&lex->plugins, i);\n        break;\n      }\n    DBUG_ASSERT(i >= 0);\n  }\n\n  DBUG_ASSERT(pi->ref_count);\n  pi->ref_count--;\n\n  DBUG_PRINT(\"lock\",(\"thd: %p  plugin: \\\"%s\\\" UNLOCK ref_count: %d\",\n                     current_thd, pi->name.str, pi->ref_count));\n\n  if (pi->state == PLUGIN_IS_DELETED && !pi->ref_count)\n    reap_needed= true;\n\n  DBUG_VOID_RETURN;\n}\n\n\nvoid plugin_unlock(THD *thd, plugin_ref plugin)\n{\n  LEX *lex= thd ? thd->lex : 0;\n  DBUG_ENTER(\"plugin_unlock\");\n  if (!plugin)\n    DBUG_VOID_RETURN;\n#ifdef DBUG_OFF\n  /* built-in plugins don't need ref counting */\n  if (!plugin_dlib(plugin))\n    DBUG_VOID_RETURN;\n#endif\n  mysql_mutex_lock(&LOCK_plugin);\n  intern_plugin_unlock(lex, plugin);\n  reap_plugins();\n  mysql_mutex_unlock(&LOCK_plugin);\n  DBUG_VOID_RETURN;\n}\n\n\nvoid plugin_unlock_list(THD *thd, plugin_ref *list, uint count)\n{\n  LEX *lex= thd ? thd->lex : 0;\n  DBUG_ENTER(\"plugin_unlock_list\");\n  if (count == 0)\n    DBUG_VOID_RETURN;\n\n  DBUG_ASSERT(list);\n  mysql_mutex_lock(&LOCK_plugin);\n  while (count--)\n    intern_plugin_unlock(lex, *list++);\n  reap_plugins();\n  mysql_mutex_unlock(&LOCK_plugin);\n  DBUG_VOID_RETURN;\n}\n\n\nstatic int plugin_initialize(MEM_ROOT *tmp_root, struct st_plugin_int *plugin,\n                             int *argc, char **argv, bool options_only)\n{\n  int ret= 1;\n  DBUG_ENTER(\"plugin_initialize\");\n\n  mysql_mutex_assert_owner(&LOCK_plugin);\n  uint state= plugin->state;\n  DBUG_ASSERT(state == PLUGIN_IS_UNINITIALIZED);\n\n  mysql_mutex_unlock(&LOCK_plugin);\n\n  mysql_prlock_wrlock(&LOCK_system_variables_hash);\n  if (test_plugin_options(tmp_root, plugin, argc, argv))\n    state= PLUGIN_IS_DISABLED;\n  mysql_prlock_unlock(&LOCK_system_variables_hash);\n\n  if (options_only || state == PLUGIN_IS_DISABLED)\n  {\n    ret= !options_only && plugin_is_forced(plugin);\n    state= PLUGIN_IS_DISABLED;\n    goto err;\n  }\n\n  if (plugin_type_initialize[plugin->plugin->type])\n  {\n    if ((*plugin_type_initialize[plugin->plugin->type])(plugin))\n    {\n      sql_print_error(\"Plugin '%s' registration as a %s failed.\",\n                      plugin->name.str, plugin_type_names[plugin->plugin->type].str);\n      goto err;\n    }\n  }\n  else if (plugin->plugin->init)\n  {\n    if (plugin->plugin->init(plugin))\n    {\n      sql_print_error(\"Plugin '%s' init function returned error.\",\n                      plugin->name.str);\n      goto err;\n    }\n  }\n  state= PLUGIN_IS_READY; // plugin->init() succeeded\n\n  if (plugin->plugin->status_vars)\n  {\n    /*\n      historical ndb behavior caused MySQL plugins to specify\n      status var names in full, with the plugin name prefix.\n      this was never fixed in MySQL.\n      MariaDB fixes that but supports MySQL style too.\n    */\n    SHOW_VAR *show_vars= plugin->plugin->status_vars;\n    SHOW_VAR tmp_array[2]= {\n      {plugin->plugin->name, (char*)plugin->plugin->status_vars, SHOW_ARRAY},\n      {0, 0, SHOW_UNDEF}\n    };\n    if (strncasecmp(show_vars->name, plugin->name.str, plugin->name.length))\n      show_vars= tmp_array;\n\n    if (add_status_vars(show_vars))\n      goto err;\n  }\n\n  ret= 0;\n\nerr:\n  if (ret)\n    plugin_variables_deinit(plugin);\n\n  mysql_mutex_lock(&LOCK_plugin);\n  plugin->state= state;\n\n  DBUG_RETURN(ret);\n}\n\n\nextern \"C\" uchar *get_plugin_hash_key(const uchar *, size_t *, my_bool);\nextern \"C\" uchar *get_bookmark_hash_key(const uchar *, size_t *, my_bool);\n\n\nuchar *get_plugin_hash_key(const uchar *buff, size_t *length,\n                           my_bool not_used __attribute__((unused)))\n{\n  struct st_plugin_int *plugin= (st_plugin_int *)buff;\n  *length= (uint)plugin->name.length;\n  return((uchar *)plugin->name.str);\n}\n\n\nuchar *get_bookmark_hash_key(const uchar *buff, size_t *length,\n                             my_bool not_used __attribute__((unused)))\n{\n  struct st_bookmark *var= (st_bookmark *)buff;\n  *length= var->name_len + 1;\n  return (uchar*) var->key;\n}\n\nstatic inline void convert_dash_to_underscore(char *str, size_t len)\n{\n  for (char *p= str; p <= str+len; p++)\n    if (*p == '-')\n      *p= '_';\n}\n\nstatic inline void convert_underscore_to_dash(char *str, size_t len)\n{\n  for (char *p= str; p <= str+len; p++)\n    if (*p == '_')\n      *p= '-';\n}\n\n#ifdef HAVE_PSI_INTERFACE\nstatic PSI_mutex_key key_LOCK_plugin;\n\nstatic PSI_mutex_info all_plugin_mutexes[]=\n{\n  { &key_LOCK_plugin, \"LOCK_plugin\", PSI_FLAG_GLOBAL}\n};\n\nstatic void init_plugin_psi_keys(void)\n{\n  const char* category= \"sql\";\n  int count;\n\n  if (PSI_server == NULL)\n    return;\n\n  count= array_elements(all_plugin_mutexes);\n  PSI_server->register_mutex(category, all_plugin_mutexes, count);\n}\n#endif /* HAVE_PSI_INTERFACE */\n\n/*\n  The logic is that we first load and initialize all compiled in plugins.\n  From there we load up the dynamic types (assuming we have not been told to\n  skip this part).\n\n  Finally we initialize everything, aka the dynamic that have yet to initialize.\n*/\nint plugin_init(int *argc, char **argv, int flags)\n{\n  uint i;\n  struct st_maria_plugin **builtins;\n  struct st_maria_plugin *plugin;\n  struct st_plugin_int tmp, *plugin_ptr, **reap;\n  MEM_ROOT tmp_root;\n  bool reaped_mandatory_plugin= false;\n  bool mandatory= true;\n  LEX_CSTRING MyISAM= { STRING_WITH_LEN(\"MyISAM\") };\n  DBUG_ENTER(\"plugin_init\");\n\n  if (initialized)\n    DBUG_RETURN(0);\n\n  dlopen_count =0;\n\n  init_alloc_root(&plugin_mem_root, \"plugin\", 4096, 4096, MYF(0));\n  init_alloc_root(&plugin_vars_mem_root, \"plugin_vars\", 4096, 4096, MYF(0));\n  init_alloc_root(&tmp_root, \"plugin_tmp\", 4096, 4096, MYF(0));\n\n  if (my_hash_init(&bookmark_hash, &my_charset_bin, 32, 0, 0,\n                   get_bookmark_hash_key, NULL, HASH_UNIQUE))\n      goto err;\n\n  /*\n    The 80 is from 2016-04-27 when we had 71 default plugins\n    Big enough to avoid many mallocs even in future\n  */\n  if (my_init_dynamic_array(&plugin_dl_array,\n                            sizeof(struct st_plugin_dl *), 16, 16, MYF(0)) ||\n      my_init_dynamic_array(&plugin_array,\n                            sizeof(struct st_plugin_int *), 80, 32, MYF(0)))\n    goto err;\n\n  for (i= 0; i < MYSQL_MAX_PLUGIN_TYPE_NUM; i++)\n  {\n    if (my_hash_init(&plugin_hash[i], system_charset_info, 32, 0, 0,\n                     get_plugin_hash_key, NULL, HASH_UNIQUE))\n      goto err;\n  }\n\n  /* prepare debug_sync service */\n  DBUG_ASSERT(strcmp(list_of_services[1].name, \"debug_sync_service\") == 0);\n  list_of_services[1].service= *(void**)&debug_sync_C_callback_ptr;\n\n  /* prepare encryption_keys service */\n  finalize_encryption_plugin(0);\n\n  mysql_mutex_lock(&LOCK_plugin);\n\n  initialized= 1;\n\n  /*\n    First we register builtin plugins\n  */\n  if (global_system_variables.log_warnings >= 9)\n    sql_print_information(\"Initializing built-in plugins\");\n\n  for (builtins= mysql_mandatory_plugins; *builtins || mandatory; builtins++)\n  {\n    if (!*builtins)\n    {\n      builtins= mysql_optional_plugins;\n      mandatory= false;\n      if (!*builtins)\n        break;\n    }\n    for (plugin= *builtins; plugin->info; plugin++)\n    {\n      if (opt_ignore_builtin_innodb &&\n          !my_strnncoll(&my_charset_latin1, (const uchar*) plugin->name,\n                        6, (const uchar*) \"InnoDB\", 6))\n        continue;\n\n      bzero(&tmp, sizeof(tmp));\n      tmp.plugin= plugin;\n      tmp.name.str= (char *)plugin->name;\n      tmp.name.length= strlen(plugin->name);\n      tmp.state= 0;\n      tmp.load_option= mandatory ? PLUGIN_FORCE : PLUGIN_ON;\n\n      for (i=0; i < array_elements(override_plugin_load_policy); i++)\n      {\n        if (!my_strcasecmp(&my_charset_latin1, plugin->name,\n                           override_plugin_load_policy[i].plugin_name))\n        {\n          tmp.load_option= override_plugin_load_policy[i].override;\n          break;\n        }\n      }\n\n      free_root(&tmp_root, MYF(MY_MARK_BLOCKS_FREE));\n      tmp.state= PLUGIN_IS_UNINITIALIZED;\n      if (register_builtin(plugin, &tmp, &plugin_ptr))\n        goto err_unlock;\n    }\n  }\n\n  /*\n    First, we initialize only MyISAM - that should almost always succeed\n    (almost always, because plugins can be loaded outside of the server, too).\n  */\n  plugin_ptr= plugin_find_internal(&MyISAM, MYSQL_STORAGE_ENGINE_PLUGIN);\n  DBUG_ASSERT(plugin_ptr || !mysql_mandatory_plugins[0]);\n  if (plugin_ptr)\n  {\n    DBUG_ASSERT(plugin_ptr->load_option == PLUGIN_FORCE);\n\n    if (plugin_initialize(&tmp_root, plugin_ptr, argc, argv, false))\n      goto err_unlock;\n\n    /*\n      set the global default storage engine variable so that it will\n      not be null in any child thread.\n    */\n    global_system_variables.table_plugin =\n      intern_plugin_lock(NULL, plugin_int_to_ref(plugin_ptr));\n    DBUG_SLOW_ASSERT(plugin_ptr->ref_count == 1);\n\n  }\n  mysql_mutex_unlock(&LOCK_plugin);\n\n  /* Register (not initialize!) all dynamic plugins */\n  if (!(flags & PLUGIN_INIT_SKIP_DYNAMIC_LOADING))\n  {\n    I_List_iterator<i_string> iter(opt_plugin_load_list);\n    i_string *item;\n    if (global_system_variables.log_warnings >= 9)\n      sql_print_information(\"Initializing plugins specified on the command line\");\n    while (NULL != (item= iter++))\n      plugin_load_list(&tmp_root, item->ptr);\n\n    if (!(flags & PLUGIN_INIT_SKIP_PLUGIN_TABLE))\n    {\n      char path[FN_REFLEN + 1];\n      build_table_filename(path, sizeof(path) - 1, \"mysql\", \"plugin\", reg_ext, 0);\n      char engine_name_buf[NAME_CHAR_LEN + 1];\n      LEX_CSTRING maybe_myisam= { engine_name_buf, 0 };\n      bool is_sequence;\n      Table_type frm_type= dd_frm_type(NULL, path, &maybe_myisam, &is_sequence);\n      /* if mysql.plugin table is MyISAM - load it right away */\n      if (frm_type == TABLE_TYPE_NORMAL && !strcasecmp(maybe_myisam.str, \"MyISAM\"))\n      {\n        plugin_load(&tmp_root);\n        flags|= PLUGIN_INIT_SKIP_PLUGIN_TABLE;\n      }\n    }\n  }\n\n  /*\n    Now we initialize all remaining plugins\n  */\n\n  mysql_mutex_lock(&LOCK_plugin);\n  reap= (st_plugin_int **) my_alloca((plugin_array.elements+1) * sizeof(void*));\n  *(reap++)= NULL;\n\n  for(;;)\n  {\n    for (i=0; i < MYSQL_MAX_PLUGIN_TYPE_NUM; i++)\n    {\n      HASH *hash= plugin_hash + plugin_type_initialization_order[i];\n      for (uint idx= 0; idx < hash->records; idx++)\n      {\n        plugin_ptr= (struct st_plugin_int *) my_hash_element(hash, idx);\n        if (plugin_ptr->state == PLUGIN_IS_UNINITIALIZED)\n        {\n          if (plugin_initialize(&tmp_root, plugin_ptr, argc, argv,\n                                (flags & PLUGIN_INIT_SKIP_INITIALIZATION)))\n          {\n            plugin_ptr->state= PLUGIN_IS_DYING;\n            *(reap++)= plugin_ptr;\n          }\n        }\n      }\n    }\n\n    /* load and init plugins from the plugin table (unless done already) */\n    if (flags & PLUGIN_INIT_SKIP_PLUGIN_TABLE)\n      break;\n\n    mysql_mutex_unlock(&LOCK_plugin);\n    plugin_load(&tmp_root);\n    flags|= PLUGIN_INIT_SKIP_PLUGIN_TABLE;\n    mysql_mutex_lock(&LOCK_plugin);\n  }\n\n  /*\n    Check if any plugins have to be reaped\n  */\n  while ((plugin_ptr= *(--reap)))\n  {\n    mysql_mutex_unlock(&LOCK_plugin);\n    if (plugin_is_forced(plugin_ptr))\n      reaped_mandatory_plugin= TRUE;\n    plugin_deinitialize(plugin_ptr, true);\n    mysql_mutex_lock(&LOCK_plugin);\n    plugin_del(plugin_ptr);\n  }\n\n  mysql_mutex_unlock(&LOCK_plugin);\n  my_afree(reap);\n  if (reaped_mandatory_plugin)\n    goto err;\n\n  free_root(&tmp_root, MYF(0));\n\n  DBUG_RETURN(0);\n\nerr_unlock:\n  mysql_mutex_unlock(&LOCK_plugin);\nerr:\n  free_root(&tmp_root, MYF(0));\n  DBUG_RETURN(1);\n}\n\n\nstatic bool register_builtin(struct st_maria_plugin *plugin,\n                             struct st_plugin_int *tmp,\n                             struct st_plugin_int **ptr)\n{\n  DBUG_ENTER(\"register_builtin\");\n  tmp->ref_count= 0;\n  tmp->plugin_dl= 0;\n\n  if (insert_dynamic(&plugin_array, (uchar*)&tmp))\n    DBUG_RETURN(1);\n\n  *ptr= *dynamic_element(&plugin_array, plugin_array.elements - 1,\n                         struct st_plugin_int **)=\n        (struct st_plugin_int *) memdup_root(&plugin_mem_root, (uchar*)tmp,\n                                             sizeof(struct st_plugin_int));\n\n  if (my_hash_insert(&plugin_hash[plugin->type],(uchar*) *ptr))\n    DBUG_RETURN(1);\n\n  DBUG_RETURN(0);\n}\n\n\n/*\n  called only by plugin_init()\n*/\nstatic void plugin_load(MEM_ROOT *tmp_root)\n{\n  TABLE_LIST tables;\n  TABLE *table;\n  READ_RECORD read_record_info;\n  int error;\n  THD *new_thd= new THD(0);\n  bool result;\n  DBUG_ENTER(\"plugin_load\");\n\n  if (global_system_variables.log_warnings >= 9)\n    sql_print_information(\"Initializing installed plugins\");\n\n  new_thd->thread_stack= (char*) &tables;\n  new_thd->store_globals();\n  new_thd->db= MYSQL_SCHEMA_NAME;\n  bzero((char*) &new_thd->net, sizeof(new_thd->net));\n  tables.init_one_table(&MYSQL_SCHEMA_NAME, &MYSQL_PLUGIN_NAME, 0, TL_READ);\n  tables.open_strategy= TABLE_LIST::OPEN_NORMAL;\n\n  result= open_and_lock_tables(new_thd, &tables, FALSE, MYSQL_LOCK_IGNORE_TIMEOUT);\n\n  table= tables.table;\n  if (result)\n  {\n    DBUG_PRINT(\"error\",(\"Can't open plugin table\"));\n    if (!opt_help)\n      sql_print_error(\"Could not open mysql.plugin table. \"\n                      \"Some plugins may be not loaded\");\n    else\n      sql_print_warning(\"Could not open mysql.plugin table. \"\n                        \"Some options may be missing from the help text\");\n    goto end;\n  }\n\n  if (init_read_record(&read_record_info, new_thd, table, NULL, NULL, 1, 0,\n                       FALSE))\n  {\n    sql_print_error(\"Could not initialize init_read_record; Plugins not \"\n                    \"loaded\");\n    goto end;\n  }\n  table->use_all_columns();\n  while (!(error= read_record_info.read_record()))\n  {\n    DBUG_PRINT(\"info\", (\"init plugin record\"));\n    String str_name, str_dl;\n    get_field(tmp_root, table->field[0], &str_name);\n    get_field(tmp_root, table->field[1], &str_dl);\n\n    LEX_CSTRING name= {str_name.ptr(), str_name.length()};\n    LEX_CSTRING dl=   {str_dl.ptr(), str_dl.length()};\n\n    if (!name.length || !dl.length)\n      continue;\n\n    /*\n      there're no other threads running yet, so we don't need a mutex.\n      but plugin_add() before is designed to work in multi-threaded\n      environment, and it uses mysql_mutex_assert_owner(), so we lock\n      the mutex here to satisfy the assert\n    */\n    mysql_mutex_lock(&LOCK_plugin);\n    plugin_add(tmp_root, false, &name, &dl, MYF(ME_ERROR_LOG));\n    free_root(tmp_root, MYF(MY_MARK_BLOCKS_FREE));\n    mysql_mutex_unlock(&LOCK_plugin);\n  }\n  if (unlikely(error > 0))\n    sql_print_error(ER_THD(new_thd, ER_GET_ERRNO), my_errno,\n                           table->file->table_type());\n  end_read_record(&read_record_info);\n  table->m_needs_reopen= TRUE;                  // Force close to free memory\n  close_mysql_tables(new_thd);\nend:\n  new_thd->db= null_clex_str;                 // Avoid free on thd->db\n  delete new_thd;\n  DBUG_VOID_RETURN;\n}\n\n\n/*\n  called only by plugin_init()\n*/\nstatic bool plugin_load_list(MEM_ROOT *tmp_root, const char *list)\n{\n  char buffer[FN_REFLEN];\n  LEX_CSTRING name= {buffer, 0}, dl= {NULL, 0}, *str= &name;\n  char *p= buffer;\n  DBUG_ENTER(\"plugin_load_list\");\n  while (list)\n  {\n    if (p == buffer + sizeof(buffer) - 1)\n    {\n      sql_print_error(\"plugin-load parameter too long\");\n      DBUG_RETURN(TRUE);\n    }\n\n    switch ((*(p++)= *(list++))) {\n    case '\\0':\n      list= NULL; /* terminate the loop */\n      /* fall through */\n    case ';':\n#ifndef __WIN__\n    case ':':     /* can't use this as delimiter as it may be drive letter */\n#endif\n      p[-1]= 0;\n      if (str == &name)  // load all plugins in named module\n      {\n        if (!name.length)\n        {\n          p--;    /* reset pointer */\n          continue;\n        }\n\n        dl= name;\n        mysql_mutex_lock(&LOCK_plugin);\n        free_root(tmp_root, MYF(MY_MARK_BLOCKS_FREE));\n        name.str= 0; // load everything\n        if (plugin_add(tmp_root, false, &name, &dl,\n                       MYF(ME_ERROR_LOG)) != INSTALL_GOOD)\n          goto error;\n      }\n      else\n      {\n        free_root(tmp_root, MYF(MY_MARK_BLOCKS_FREE));\n        mysql_mutex_lock(&LOCK_plugin);\n        if (plugin_add(tmp_root, false, &name, &dl,\n                       MYF(ME_ERROR_LOG)) != INSTALL_GOOD)\n          goto error;\n      }\n      mysql_mutex_unlock(&LOCK_plugin);\n      name.length= dl.length= 0;\n      dl.str= NULL; name.str= p= buffer;\n      str= &name;\n      continue;\n    case '=':\n    case '#':\n      if (str == &name)\n      {\n        p[-1]= 0;\n        str= &dl;\n        str->str= p;\n        continue;\n      }\n      /* fall through */\n    default:\n      str->length++;\n      continue;\n    }\n  }\n  DBUG_RETURN(FALSE);\nerror:\n  mysql_mutex_unlock(&LOCK_plugin);\n  if (name.str)\n    sql_print_error(\"Couldn't load plugin '%s' from '%s'.\",\n                    name.str, dl.str);\n  else\n    sql_print_error(\"Couldn't load plugins from '%s'.\", dl.str);\n  DBUG_RETURN(TRUE);\n}\n\n\nvoid plugin_shutdown(void)\n{\n  uint i, count= plugin_array.elements;\n  struct st_plugin_int **plugins, *plugin;\n  struct st_plugin_dl **dl;\n  DBUG_ENTER(\"plugin_shutdown\");\n\n  if (initialized)\n  {\n    if (opt_gtid_pos_auto_plugins)\n    {\n      free_engine_list(opt_gtid_pos_auto_plugins);\n      opt_gtid_pos_auto_plugins= NULL;\n    }\n\n    mysql_mutex_lock(&LOCK_plugin);\n\n    reap_needed= true;\n\n    /*\n      We want to shut down plugins in a reasonable order, this will\n      become important when we have plugins which depend upon each other.\n      Circular references cannot be reaped so they are forced afterwards.\n      TODO: Have an additional step here to notify all active plugins that\n      shutdown is requested to allow plugins to deinitialize in parallel.\n    */\n    while (reap_needed && (count= plugin_array.elements))\n    {\n      reap_plugins();\n      for (i= 0; i < count; i++)\n      {\n        plugin= *dynamic_element(&plugin_array, i, struct st_plugin_int **);\n        if (plugin->state == PLUGIN_IS_READY)\n        {\n          plugin->state= PLUGIN_IS_DELETED;\n          reap_needed= true;\n        }\n      }\n      if (!reap_needed)\n      {\n        /*\n          release any plugin references held.\n        */\n        unlock_variables(NULL, &global_system_variables);\n        unlock_variables(NULL, &max_system_variables);\n      }\n    }\n\n    plugins= (struct st_plugin_int **) my_alloca(sizeof(void*) * (count+1));\n\n    /*\n      If we have any plugins which did not die cleanly, we force shutdown\n    */\n    for (i= 0; i < count; i++)\n    {\n      plugins[i]= *dynamic_element(&plugin_array, i, struct st_plugin_int **);\n      /* change the state to ensure no reaping races */\n      if (plugins[i]->state == PLUGIN_IS_DELETED)\n        plugins[i]->state= PLUGIN_IS_DYING;\n    }\n    mysql_mutex_unlock(&LOCK_plugin);\n\n    /*\n      We loop through all plugins and call deinit() if they have one.\n    */\n    for (i= 0; i < count; i++)\n      if (!(plugins[i]->state & (PLUGIN_IS_UNINITIALIZED | PLUGIN_IS_FREED |\n                                 PLUGIN_IS_DISABLED)))\n      {\n        /*\n          We are forcing deinit on plugins so we don't want to do a ref_count\n          check until we have processed all the plugins.\n        */\n        plugin_deinitialize(plugins[i], false);\n      }\n\n    /*\n      It's perfectly safe not to lock LOCK_plugin, as there're no\n      concurrent threads anymore. But some functions called from here\n      use mysql_mutex_assert_owner(), so we lock the mutex to satisfy it\n    */\n    mysql_mutex_lock(&LOCK_plugin);\n\n    /*\n      We defer checking ref_counts until after all plugins are deinitialized\n      as some may have worker threads holding on to plugin references.\n    */\n    for (i= 0; i < count; i++)\n    {\n      if (plugins[i]->ref_count)\n        sql_print_error(\"Plugin '%s' has ref_count=%d after shutdown.\",\n                        plugins[i]->name.str, plugins[i]->ref_count);\n      if (plugins[i]->state & PLUGIN_IS_UNINITIALIZED ||\n          plugins[i]->state & PLUGIN_IS_DISABLED)\n        plugin_del(plugins[i]);\n    }\n\n    /*\n      Now we can deallocate all memory.\n    */\n\n    cleanup_variables(&global_system_variables);\n    cleanup_variables(&max_system_variables);\n    mysql_mutex_unlock(&LOCK_plugin);\n\n    initialized= 0;\n    mysql_mutex_destroy(&LOCK_plugin);\n\n    my_afree(plugins);\n  }\n\n  /* Dispose of the memory */\n\n  for (i= 0; i < MYSQL_MAX_PLUGIN_TYPE_NUM; i++)\n    my_hash_free(&plugin_hash[i]);\n  delete_dynamic(&plugin_array);\n\n  count= plugin_dl_array.elements;\n  dl= (struct st_plugin_dl **)my_alloca(sizeof(void*) * count);\n  for (i= 0; i < count; i++)\n    dl[i]= *dynamic_element(&plugin_dl_array, i, struct st_plugin_dl **);\n  for (i= 0; i < plugin_dl_array.elements; i++)\n    free_plugin_mem(dl[i]);\n  my_afree(dl);\n  delete_dynamic(&plugin_dl_array);\n\n  my_hash_free(&bookmark_hash);\n  free_root(&plugin_mem_root, MYF(0));\n  free_root(&plugin_vars_mem_root, MYF(0));\n\n  global_variables_dynamic_size= 0;\n\n  DBUG_VOID_RETURN;\n}\n\n/**\n  complete plugin installation (after plugin_add).\n\n  That is, initialize it, and update mysql.plugin table\n*/\nstatic bool finalize_install(THD *thd, TABLE *table, const LEX_CSTRING *name,\n                             int *argc, char **argv)\n{\n  struct st_plugin_int *tmp= plugin_find_internal(name, MYSQL_ANY_PLUGIN);\n  int error;\n  DBUG_ASSERT(tmp);\n  mysql_mutex_assert_owner(&LOCK_plugin); // because of tmp->state\n\n  if (tmp->state != PLUGIN_IS_UNINITIALIZED)\n  {\n    /* already installed */\n    return 0;\n  }\n  else\n  {\n    if (plugin_initialize(thd->mem_root, tmp, argc, argv, false))\n    {\n      my_error(ER_CANT_INITIALIZE_UDF, MYF(0), name->str,\n                   \"Plugin initialization function failed.\");\n      tmp->state= PLUGIN_IS_DELETED;\n      return 1;\n    }\n  }\n  if (tmp->state == PLUGIN_IS_DISABLED)\n  {\n    if (global_system_variables.log_warnings)\n      push_warning_printf(thd, Sql_condition::WARN_LEVEL_WARN,\n                          ER_CANT_INITIALIZE_UDF,\n                          ER_THD(thd, ER_CANT_INITIALIZE_UDF),\n                          name->str, \"Plugin is disabled\");\n  }\n\n  /*\n    We do not replicate the INSTALL PLUGIN statement. Disable binlogging\n    of the insert into the plugin table, so that it is not replicated in\n    row based mode.\n  */\n  tmp_disable_binlog(thd);\n  table->use_all_columns();\n  restore_record(table, s->default_values);\n  table->field[0]->store(name->str, name->length, system_charset_info);\n  table->field[1]->store(tmp->plugin_dl->dl.str, tmp->plugin_dl->dl.length,\n                         files_charset_info);\n  error= table->file->ha_write_row(table->record[0]);\n  reenable_binlog(thd);\n  if (unlikely(error))\n  {\n    table->file->print_error(error, MYF(0));\n    tmp->state= PLUGIN_IS_DELETED;\n    return 1;\n  }\n  return 0;\n}\n\nbool mysql_install_plugin(THD *thd, const LEX_CSTRING *name,\n                          const LEX_CSTRING *dl_arg)\n{\n  TABLE_LIST tables;\n  TABLE *table;\n  LEX_CSTRING dl= *dl_arg;\n  enum install_status error;\n  int argc=orig_argc;\n  char **argv=orig_argv;\n  unsigned long event_class_mask[MYSQL_AUDIT_CLASS_MASK_SIZE] =\n  { MYSQL_AUDIT_GENERAL_CLASSMASK };\n  DBUG_ENTER(\"mysql_install_plugin\");\n\n  tables.init_one_table(&MYSQL_SCHEMA_NAME, &MYSQL_PLUGIN_NAME, 0, TL_WRITE);\n  if (!opt_noacl && check_table_access(thd, INSERT_ACL, &tables, FALSE, 1, FALSE))\n    DBUG_RETURN(TRUE);\n  WSREP_TO_ISOLATION_BEGIN(WSREP_MYSQL_DB, NULL, NULL);\n\n  /* need to open before acquiring LOCK_plugin or it will deadlock */\n  if (! (table = open_ltable(thd, &tables, TL_WRITE,\n                             MYSQL_LOCK_IGNORE_TIMEOUT)))\n    DBUG_RETURN(TRUE);\n\n  if (my_load_defaults(MYSQL_CONFIG_NAME, load_default_groups, &argc, &argv, NULL))\n  {\n    my_error(ER_PLUGIN_IS_NOT_LOADED, MYF(0), name->str);\n    DBUG_RETURN(TRUE);\n  }\n\n  /*\n    Pre-acquire audit plugins for events that may potentially occur\n    during [UN]INSTALL PLUGIN.\n\n    When audit event is triggered, audit subsystem acquires interested\n    plugins by walking through plugin list. Evidently plugin list\n    iterator protects plugin list by acquiring LOCK_plugin, see\n    plugin_foreach_with_mask().\n\n    On the other hand [UN]INSTALL PLUGIN is acquiring LOCK_plugin\n    rather for a long time.\n\n    When audit event is triggered during [UN]INSTALL PLUGIN, plugin\n    list iterator acquires the same lock (within the same thread)\n    second time.\n\n    This hack should be removed when LOCK_plugin is fixed so it\n    protects only what it supposed to protect.\n\n    See also mysql_uninstall_plugin() and initialize_audit_plugin()\n  */\n  if (mysql_audit_general_enabled())\n    mysql_audit_acquire_plugins(thd, event_class_mask);\n\n  mysql_mutex_lock(&LOCK_plugin);\n  error= plugin_add(thd->mem_root, thd->lex->create_info.if_not_exists(),\n                    name, &dl, MYF(0));\n  if (unlikely(error != INSTALL_GOOD))\n    goto err;\n\n  if (name->str)\n    error= finalize_install(thd, table, name, &argc, argv)\n             ? INSTALL_FAIL_NOT_OK : INSTALL_GOOD;\n  else\n  {\n    st_plugin_dl *plugin_dl= plugin_dl_find(&dl);\n    struct st_maria_plugin *plugin;\n    for (plugin= plugin_dl->plugins; plugin->info; plugin++)\n    {\n      LEX_CSTRING str= { plugin->name, strlen(plugin->name) };\n      if (finalize_install(thd, table, &str, &argc, argv))\n        error= INSTALL_FAIL_NOT_OK;\n    }\n  }\n\n  if (unlikely(error != INSTALL_GOOD))\n  {\n    reap_needed= true;\n    reap_plugins();\n  }\nerr:\n  global_plugin_version++;\n  mysql_mutex_unlock(&LOCK_plugin);\n  if (argv)\n    free_defaults(argv);\n  DBUG_RETURN(error == INSTALL_FAIL_NOT_OK);\n#ifdef WITH_WSREP\nwsrep_error_label:\n  DBUG_RETURN(true);\n#endif\n}\n\n\nstatic bool do_uninstall(THD *thd, TABLE *table, const LEX_CSTRING *name)\n{\n  struct st_plugin_int *plugin;\n  mysql_mutex_assert_owner(&LOCK_plugin);\n\n  if (!(plugin= plugin_find_internal(name, MYSQL_ANY_PLUGIN)) ||\n      plugin->state & (PLUGIN_IS_UNINITIALIZED | PLUGIN_IS_DYING))\n  {\n    myf MyFlags= thd->lex->if_exists() ? ME_NOTE : 0;\n    my_error(ER_SP_DOES_NOT_EXIST, MyFlags, \"PLUGIN\", name->str);\n    return !MyFlags;\n  }\n  if (!plugin->plugin_dl)\n  {\n    my_error(ER_PLUGIN_DELETE_BUILTIN, MYF(0));\n    return 1;\n  }\n  if (plugin->load_option == PLUGIN_FORCE_PLUS_PERMANENT)\n  {\n    my_error(ER_PLUGIN_IS_PERMANENT, MYF(0), name->str);\n    return 1;\n  }\n\n  plugin->state= PLUGIN_IS_DELETED;\n  if (plugin->ref_count)\n    push_warning(thd, Sql_condition::WARN_LEVEL_WARN,\n                 WARN_PLUGIN_BUSY, ER_THD(thd, WARN_PLUGIN_BUSY));\n  else\n    reap_needed= true;\n\n  uchar user_key[MAX_KEY_LENGTH];\n  table->use_all_columns();\n  table->field[0]->store(name->str, name->length, system_charset_info);\n  key_copy(user_key, table->record[0], table->key_info,\n           table->key_info->key_length);\n  if (! table->file->ha_index_read_idx_map(table->record[0], 0, user_key,\n                                           HA_WHOLE_KEY, HA_READ_KEY_EXACT))\n  {\n    int error;\n    /*\n      We do not replicate the UNINSTALL PLUGIN statement. Disable binlogging\n      of the delete from the plugin table, so that it is not replicated in\n      row based mode.\n    */\n    tmp_disable_binlog(thd);\n    error= table->file->ha_delete_row(table->record[0]);\n    reenable_binlog(thd);\n    if (unlikely(error))\n    {\n      table->file->print_error(error, MYF(0));\n      return 1;\n    }\n  }\n  return 0;\n}\n\n\nbool mysql_uninstall_plugin(THD *thd, const LEX_CSTRING *name,\n                            const LEX_CSTRING *dl_arg)\n{\n  TABLE *table;\n  TABLE_LIST tables;\n  LEX_CSTRING dl= *dl_arg;\n  bool error= false;\n  unsigned long event_class_mask[MYSQL_AUDIT_CLASS_MASK_SIZE] =\n  { MYSQL_AUDIT_GENERAL_CLASSMASK };\n  DBUG_ENTER(\"mysql_uninstall_plugin\");\n\n  tables.init_one_table(&MYSQL_SCHEMA_NAME, &MYSQL_PLUGIN_NAME, 0, TL_WRITE);\n\n  if (!opt_noacl && check_table_access(thd, DELETE_ACL, &tables, FALSE, 1, FALSE))\n    DBUG_RETURN(TRUE);\n\n  WSREP_TO_ISOLATION_BEGIN(WSREP_MYSQL_DB, NULL, NULL);\n\n  /* need to open before acquiring LOCK_plugin or it will deadlock */\n  if (! (table= open_ltable(thd, &tables, TL_WRITE, MYSQL_LOCK_IGNORE_TIMEOUT)))\n    DBUG_RETURN(TRUE);\n\n  if (!table->key_info)\n  {\n    my_printf_error(ER_UNKNOWN_ERROR,\n                    \"The table %s.%s has no primary key. \"\n                    \"Please check the table definition and \"\n                    \"create the primary key accordingly.\", MYF(0),\n                    table->s->db.str, table->s->table_name.str);\n    DBUG_RETURN(TRUE);\n  }\n\n  /*\n    Pre-acquire audit plugins for events that may potentially occur\n    during [UN]INSTALL PLUGIN.\n\n    When audit event is triggered, audit subsystem acquires interested\n    plugins by walking through plugin list. Evidently plugin list\n    iterator protects plugin list by acquiring LOCK_plugin, see\n    plugin_foreach_with_mask().\n\n    On the other hand [UN]INSTALL PLUGIN is acquiring LOCK_plugin\n    rather for a long time.\n\n    When audit event is triggered during [UN]INSTALL PLUGIN, plugin\n    list iterator acquires the same lock (within the same thread)\n    second time.\n\n    This hack should be removed when LOCK_plugin is fixed so it\n    protects only what it supposed to protect.\n\n    See also mysql_install_plugin() and initialize_audit_plugin()\n  */\n  if (mysql_audit_general_enabled())\n    mysql_audit_acquire_plugins(thd, event_class_mask);\n\n  mysql_mutex_lock(&LOCK_plugin);\n\n  if (name->str)\n    error= do_uninstall(thd, table, name);\n  else\n  {\n    fix_dl_name(thd->mem_root, &dl);\n    st_plugin_dl *plugin_dl= plugin_dl_find(&dl);\n    if (plugin_dl)\n    {\n      for (struct st_maria_plugin *plugin= plugin_dl->plugins;\n           plugin->info; plugin++)\n      {\n        LEX_CSTRING str= { plugin->name, strlen(plugin->name) };\n        error|= do_uninstall(thd, table, &str);\n      }\n    }\n    else\n    {\n      myf MyFlags= thd->lex->if_exists() ? ME_NOTE : 0;\n      my_error(ER_SP_DOES_NOT_EXIST, MyFlags, \"SONAME\", dl.str);\n      error|= !MyFlags;\n    }\n  }\n  reap_plugins();\n\n  global_plugin_version++;\n  mysql_mutex_unlock(&LOCK_plugin);\n  DBUG_RETURN(error);\n#ifdef WITH_WSREP\nwsrep_error_label:\n  DBUG_RETURN(true);\n#endif\n}\n\n\nbool plugin_foreach_with_mask(THD *thd, plugin_foreach_func *func,\n                       int type, uint state_mask, void *arg)\n{\n  uint idx, total= 0;\n  struct st_plugin_int *plugin;\n  plugin_ref *plugins;\n  my_bool res= FALSE;\n  DBUG_ENTER(\"plugin_foreach_with_mask\");\n\n  if (!initialized)\n    DBUG_RETURN(FALSE);\n\n  mysql_mutex_lock(&LOCK_plugin);\n  /*\n    Do the alloca out here in case we do have a working alloca:\n    leaving the nested stack frame invalidates alloca allocation.\n  */\n  if (type == MYSQL_ANY_PLUGIN)\n  {\n    plugins= (plugin_ref*) my_alloca(plugin_array.elements * sizeof(plugin_ref));\n    for (idx= 0; idx < plugin_array.elements; idx++)\n    {\n      plugin= *dynamic_element(&plugin_array, idx, struct st_plugin_int **);\n      if ((plugins[total]= intern_plugin_lock(0, plugin_int_to_ref(plugin),\n                                              state_mask)))\n        total++;\n    }\n  }\n  else\n  {\n    HASH *hash= plugin_hash + type;\n    plugins= (plugin_ref*) my_alloca(hash->records * sizeof(plugin_ref));\n    for (idx= 0; idx < hash->records; idx++)\n    {\n      plugin= (struct st_plugin_int *) my_hash_element(hash, idx);\n      if ((plugins[total]= intern_plugin_lock(0, plugin_int_to_ref(plugin),\n                                              state_mask)))\n        total++;\n    }\n  }\n  mysql_mutex_unlock(&LOCK_plugin);\n\n  for (idx= 0; idx < total; idx++)\n  {\n    /* It will stop iterating on first engine error when \"func\" returns TRUE */\n    if ((res= func(thd, plugins[idx], arg)))\n        break;\n  }\n\n  plugin_unlock_list(0, plugins, total);\n  my_afree(plugins);\n  DBUG_RETURN(res);\n}\n\n\nstatic bool plugin_dl_foreach_internal(THD *thd, st_plugin_dl *plugin_dl,\n                                       st_maria_plugin *plug,\n                                       plugin_foreach_func *func, void *arg)\n{\n  for (; plug->name; plug++)\n  {\n    st_plugin_int tmp, *plugin;\n\n    tmp.name.str= const_cast<char*>(plug->name);\n    tmp.name.length= strlen(plug->name);\n    tmp.plugin= plug;\n    tmp.plugin_dl= plugin_dl;\n\n    mysql_mutex_lock(&LOCK_plugin);\n    if ((plugin= plugin_find_internal(&tmp.name, MYSQL_ANY_PLUGIN)) &&\n        plugin->plugin == plug)\n\n    {\n      tmp.state= plugin->state;\n      tmp.load_option= plugin->load_option;\n    }\n    else\n    {\n      tmp.state= PLUGIN_IS_FREED;\n      tmp.load_option= PLUGIN_OFF;\n    }\n    mysql_mutex_unlock(&LOCK_plugin);\n\n    plugin= &tmp;\n    if (func(thd, plugin_int_to_ref(plugin), arg))\n      return 1;\n  }\n  return 0;\n}\n\nbool plugin_dl_foreach(THD *thd, const LEX_CSTRING *dl,\n                       plugin_foreach_func *func, void *arg)\n{\n  bool err= 0;\n\n  if (dl)\n  {\n    mysql_mutex_lock(&LOCK_plugin);\n    st_plugin_dl *plugin_dl= plugin_dl_add(dl, MYF(0));\n    mysql_mutex_unlock(&LOCK_plugin);\n\n    if (!plugin_dl)\n      return 1;\n\n    err= plugin_dl_foreach_internal(thd, plugin_dl, plugin_dl->plugins,\n                                    func, arg);\n\n    mysql_mutex_lock(&LOCK_plugin);\n    plugin_dl_del(plugin_dl);\n    mysql_mutex_unlock(&LOCK_plugin);\n  }\n  else\n  {\n    struct st_maria_plugin **builtins;\n    for (builtins= mysql_mandatory_plugins; !err && *builtins; builtins++)\n      err= plugin_dl_foreach_internal(thd, 0, *builtins, func, arg);\n    for (builtins= mysql_optional_plugins; !err && *builtins; builtins++)\n      err= plugin_dl_foreach_internal(thd, 0, *builtins, func, arg);\n  }\n  return err;\n}\n\n\n/****************************************************************************\n  Internal type declarations for variables support\n****************************************************************************/\n\n#undef MYSQL_SYSVAR_NAME\n#define MYSQL_SYSVAR_NAME(name) name\n#define PLUGIN_VAR_TYPEMASK 0x7f\n#define BOOKMARK_MEMALLOC   0x80\n\nstatic inline char plugin_var_bookmark_key(uint flags)\n{\n  return (flags & PLUGIN_VAR_TYPEMASK) |\n         (flags & PLUGIN_VAR_MEMALLOC ? BOOKMARK_MEMALLOC : 0);\n}\n\n#define EXTRA_OPTIONS 3 /* options for: 'foo', 'plugin-foo' and NULL */\n\ntypedef DECLARE_MYSQL_SYSVAR_BASIC(sysvar_bool_t, my_bool);\ntypedef DECLARE_MYSQL_THDVAR_BASIC(thdvar_bool_t, my_bool);\ntypedef DECLARE_MYSQL_SYSVAR_BASIC(sysvar_str_t, char *);\ntypedef DECLARE_MYSQL_THDVAR_BASIC(thdvar_str_t, char *);\n\ntypedef DECLARE_MYSQL_SYSVAR_TYPELIB(sysvar_enum_t, unsigned long);\ntypedef DECLARE_MYSQL_THDVAR_TYPELIB(thdvar_enum_t, unsigned long);\ntypedef DECLARE_MYSQL_SYSVAR_TYPELIB(sysvar_set_t, ulonglong);\ntypedef DECLARE_MYSQL_THDVAR_TYPELIB(thdvar_set_t, ulonglong);\n\ntypedef DECLARE_MYSQL_SYSVAR_SIMPLE(sysvar_int_t, int);\ntypedef DECLARE_MYSQL_SYSVAR_SIMPLE(sysvar_long_t, long);\ntypedef DECLARE_MYSQL_SYSVAR_SIMPLE(sysvar_longlong_t, longlong);\ntypedef DECLARE_MYSQL_SYSVAR_SIMPLE(sysvar_uint_t, uint);\ntypedef DECLARE_MYSQL_SYSVAR_SIMPLE(sysvar_ulong_t, ulong);\ntypedef DECLARE_MYSQL_SYSVAR_SIMPLE(sysvar_ulonglong_t, ulonglong);\ntypedef DECLARE_MYSQL_SYSVAR_SIMPLE(sysvar_double_t, double);\n\ntypedef DECLARE_MYSQL_THDVAR_SIMPLE(thdvar_int_t, int);\ntypedef DECLARE_MYSQL_THDVAR_SIMPLE(thdvar_long_t, long);\ntypedef DECLARE_MYSQL_THDVAR_SIMPLE(thdvar_longlong_t, longlong);\ntypedef DECLARE_MYSQL_THDVAR_SIMPLE(thdvar_uint_t, uint);\ntypedef DECLARE_MYSQL_THDVAR_SIMPLE(thdvar_ulong_t, ulong);\ntypedef DECLARE_MYSQL_THDVAR_SIMPLE(thdvar_ulonglong_t, ulonglong);\ntypedef DECLARE_MYSQL_THDVAR_SIMPLE(thdvar_double_t, double);\n\n\n/****************************************************************************\n  default variable data check and update functions\n****************************************************************************/\n\nstatic int check_func_bool(THD *thd, struct st_mysql_sys_var *var,\n                           void *save, st_mysql_value *value)\n{\n  char buff[STRING_BUFFER_USUAL_SIZE];\n  const char *str;\n  int result, length;\n  long long tmp;\n\n  if (value->value_type(value) == MYSQL_VALUE_TYPE_STRING)\n  {\n    length= sizeof(buff);\n    if (!(str= value->val_str(value, buff, &length)) ||\n        (result= find_type(&bool_typelib, str, length, 1)-1) < 0)\n      goto err;\n  }\n  else\n  {\n    if (value->val_int(value, &tmp) < 0)\n      goto err;\n    if (tmp != 0 && tmp != 1)\n      goto err;\n    result= (int) tmp;\n  }\n  *(my_bool *) save= result ? 1 : 0;\n  return 0;\nerr:\n  return 1;\n}\n\n\nstatic int check_func_int(THD *thd, struct st_mysql_sys_var *var,\n                          void *save, st_mysql_value *value)\n{\n  my_bool fixed1, fixed2;\n  long long orig, val;\n  struct my_option options;\n  value->val_int(value, &orig);\n  val= orig;\n  plugin_opt_set_limits(&options, var);\n\n  if (var->flags & PLUGIN_VAR_UNSIGNED)\n  {\n    if ((fixed1= (!value->is_unsigned(value) && val < 0)))\n      val=0;\n    *(uint *)save= (uint) getopt_ull_limit_value((ulonglong) val, &options,\n                                                   &fixed2);\n  }\n  else\n  {\n    if ((fixed1= (value->is_unsigned(value) && val < 0)))\n      val=LONGLONG_MAX;\n    *(int *)save= (int) getopt_ll_limit_value(val, &options, &fixed2);\n  }\n\n  return throw_bounds_warning(thd, var->name, fixed1 || fixed2,\n                              value->is_unsigned(value), (longlong) orig);\n}\n\n\nstatic int check_func_long(THD *thd, struct st_mysql_sys_var *var,\n                          void *save, st_mysql_value *value)\n{\n  my_bool fixed1, fixed2;\n  long long orig, val;\n  struct my_option options;\n  value->val_int(value, &orig);\n  val= orig;\n  plugin_opt_set_limits(&options, var);\n\n  if (var->flags & PLUGIN_VAR_UNSIGNED)\n  {\n    if ((fixed1= (!value->is_unsigned(value) && val < 0)))\n      val=0;\n    *(ulong *)save= (ulong) getopt_ull_limit_value((ulonglong) val, &options,\n                                                   &fixed2);\n  }\n  else\n  {\n    if ((fixed1= (value->is_unsigned(value) && val < 0)))\n      val=LONGLONG_MAX;\n    *(long *)save= (long) getopt_ll_limit_value(val, &options, &fixed2);\n  }\n\n  return throw_bounds_warning(thd, var->name, fixed1 || fixed2,\n                              value->is_unsigned(value), (longlong) orig);\n}\n\n\nstatic int check_func_longlong(THD *thd, struct st_mysql_sys_var *var,\n                               void *save, st_mysql_value *value)\n{\n  my_bool fixed1, fixed2;\n  long long orig, val;\n  struct my_option options;\n  value->val_int(value, &orig);\n  val= orig;\n  plugin_opt_set_limits(&options, var);\n\n  if (var->flags & PLUGIN_VAR_UNSIGNED)\n  {\n    if ((fixed1= (!value->is_unsigned(value) && val < 0)))\n      val=0;\n    *(ulonglong *)save= getopt_ull_limit_value((ulonglong) val, &options,\n                                               &fixed2);\n  }\n  else\n  {\n    if ((fixed1= (value->is_unsigned(value) && val < 0)))\n      val=LONGLONG_MAX;\n    *(longlong *)save= getopt_ll_limit_value(val, &options, &fixed2);\n  }\n\n  return throw_bounds_warning(thd, var->name, fixed1 || fixed2,\n                              value->is_unsigned(value), (longlong) orig);\n}\n\nstatic int check_func_str(THD *thd, struct st_mysql_sys_var *var,\n                          void *save, st_mysql_value *value)\n{\n  char buff[STRING_BUFFER_USUAL_SIZE];\n  const char *str;\n  int length;\n\n  length= sizeof(buff);\n  if ((str= value->val_str(value, buff, &length)))\n    str= thd->strmake(str, length);\n  *(const char**)save= str;\n  return 0;\n}\n\n\nstatic int check_func_enum(THD *thd, struct st_mysql_sys_var *var,\n                           void *save, st_mysql_value *value)\n{\n  char buff[STRING_BUFFER_USUAL_SIZE];\n  const char *str;\n  TYPELIB *typelib;\n  long long tmp;\n  long result;\n  int length;\n\n  if (var->flags & PLUGIN_VAR_THDLOCAL)\n    typelib= ((thdvar_enum_t*) var)->typelib;\n  else\n    typelib= ((sysvar_enum_t*) var)->typelib;\n\n  if (value->value_type(value) == MYSQL_VALUE_TYPE_STRING)\n  {\n    length= sizeof(buff);\n    if (!(str= value->val_str(value, buff, &length)))\n      goto err;\n    if ((result= (long)find_type(typelib, str, length, 0) - 1) < 0)\n      goto err;\n  }\n  else\n  {\n    if (value->val_int(value, &tmp))\n      goto err;\n    if (tmp < 0 || tmp >= typelib->count)\n      goto err;\n    result= (long) tmp;\n  }\n  *(long*)save= result;\n  return 0;\nerr:\n  return 1;\n}\n\n\nstatic int check_func_set(THD *thd, struct st_mysql_sys_var *var,\n                          void *save, st_mysql_value *value)\n{\n  char buff[STRING_BUFFER_USUAL_SIZE], *error= 0;\n  const char *str;\n  TYPELIB *typelib;\n  ulonglong result;\n  uint error_len= 0;                            // init as only set on error\n  bool not_used;\n  int length;\n\n  if (var->flags & PLUGIN_VAR_THDLOCAL)\n    typelib= ((thdvar_set_t*) var)->typelib;\n  else\n    typelib= ((sysvar_set_t*)var)->typelib;\n\n  if (value->value_type(value) == MYSQL_VALUE_TYPE_STRING)\n  {\n    length= sizeof(buff);\n    if (!(str= value->val_str(value, buff, &length)))\n      goto err;\n    result= find_set(typelib, str, length, NULL,\n                     &error, &error_len, &not_used);\n    if (unlikely(error_len))\n      goto err;\n  }\n  else\n  {\n    if (value->val_int(value, (long long *)&result))\n      goto err;\n    if (unlikely((result >= (1ULL << typelib->count)) &&\n                 (typelib->count < sizeof(long)*8)))\n      goto err;\n  }\n  *(ulonglong*)save= result;\n  return 0;\nerr:\n  return 1;\n}\n\nstatic int check_func_double(THD *thd, struct st_mysql_sys_var *var,\n                             void *save, st_mysql_value *value)\n{\n  double v;\n  my_bool fixed;\n  struct my_option option;\n\n  value->val_real(value, &v);\n  plugin_opt_set_limits(&option, var);\n  *(double *) save= getopt_double_limit_value(v, &option, &fixed);\n\n  return throw_bounds_warning(thd, var->name, fixed, v);\n}\n\n\nstatic void update_func_bool(THD *thd, struct st_mysql_sys_var *var,\n                             void *tgt, const void *save)\n{\n  *(my_bool *) tgt= *(my_bool *) save ? 1 : 0;\n}\n\n\nstatic void update_func_int(THD *thd, struct st_mysql_sys_var *var,\n                             void *tgt, const void *save)\n{\n  *(int *)tgt= *(int *) save;\n}\n\n\nstatic void update_func_long(THD *thd, struct st_mysql_sys_var *var,\n                             void *tgt, const void *save)\n{\n  *(long *)tgt= *(long *) save;\n}\n\n\nstatic void update_func_longlong(THD *thd, struct st_mysql_sys_var *var,\n                             void *tgt, const void *save)\n{\n  *(longlong *)tgt= *(ulonglong *) save;\n}\n\n\nstatic void update_func_str(THD *thd, struct st_mysql_sys_var *var,\n                             void *tgt, const void *save)\n{\n  char *value= *(char**) save;\n  if (var->flags & PLUGIN_VAR_MEMALLOC)\n  {\n    char *old= *(char**) tgt;\n    if (value)\n      *(char**) tgt= my_strdup(value, MYF(0));\n    else\n      *(char**) tgt= 0;\n    my_free(old);\n  }\n  else\n    *(char**) tgt= value;\n}\n\nstatic void update_func_double(THD *thd, struct st_mysql_sys_var *var,\n                               void *tgt, const void *save)\n{\n  *(double *) tgt= *(double *) save;\n}\n\n/****************************************************************************\n  System Variables support\n****************************************************************************/\n\nsys_var *find_sys_var(THD *thd, const char *str, size_t length,\n                      bool throw_error)\n{\n  sys_var *var;\n  sys_var_pluginvar *pi;\n  DBUG_ENTER(\"find_sys_var\");\n  DBUG_PRINT(\"enter\", (\"var '%.*s'\", (int)length, str));\n\n  mysql_prlock_rdlock(&LOCK_system_variables_hash);\n  if ((var= intern_find_sys_var(str, length)) &&\n      (pi= var->cast_pluginvar()))\n  {\n    mysql_mutex_lock(&LOCK_plugin);\n    if (!intern_plugin_lock(thd ? thd->lex : 0, plugin_int_to_ref(pi->plugin),\n                            PLUGIN_IS_READY))\n      var= NULL; /* failed to lock it, it must be uninstalling */\n    mysql_mutex_unlock(&LOCK_plugin);\n  }\n  mysql_prlock_unlock(&LOCK_system_variables_hash);\n\n  if (unlikely(!throw_error && !var))\n    my_error(ER_UNKNOWN_SYSTEM_VARIABLE, MYF(0),\n             (int) (length ? length : strlen(str)), (char*) str);\n  DBUG_RETURN(var);\n}\n\n\n/*\n  called by register_var, construct_options and test_plugin_options.\n  Returns the 'bookmark' for the named variable.\n  LOCK_system_variables_hash should be at least read locked\n*/\nstatic st_bookmark *find_bookmark(const char *plugin, const char *name,\n                                  int flags)\n{\n  st_bookmark *result= NULL;\n  size_t namelen, length, pluginlen= 0;\n  char *varname, *p;\n\n  if (!(flags & PLUGIN_VAR_THDLOCAL))\n    return NULL;\n\n  namelen= strlen(name);\n  if (plugin)\n    pluginlen= strlen(plugin) + 1;\n  length= namelen + pluginlen + 2;\n  varname= (char*) my_alloca(length);\n\n  if (plugin)\n  {\n    strxmov(varname + 1, plugin, \"_\", name, NullS);\n    for (p= varname + 1; *p; p++)\n      if (*p == '-')\n        *p= '_';\n  }\n  else\n    memcpy(varname + 1, name, namelen + 1);\n\n  varname[0]= plugin_var_bookmark_key(flags);\n\n  result= (st_bookmark*) my_hash_search(&bookmark_hash,\n                                        (const uchar*) varname, length - 1);\n\n  my_afree(varname);\n  return result;\n}\n\n\nstatic size_t var_storage_size(int flags)\n{\n  switch (flags & PLUGIN_VAR_TYPEMASK) {\n  case PLUGIN_VAR_BOOL:         return sizeof(my_bool);\n  case PLUGIN_VAR_INT:          return sizeof(int);\n  case PLUGIN_VAR_LONG:         return sizeof(long);\n  case PLUGIN_VAR_ENUM:         return sizeof(long);\n  case PLUGIN_VAR_LONGLONG:     return sizeof(ulonglong);\n  case PLUGIN_VAR_SET:          return sizeof(ulonglong);\n  case PLUGIN_VAR_STR:          return sizeof(char*);\n  case PLUGIN_VAR_DOUBLE:       return sizeof(double);\n  default: DBUG_ASSERT(0);      return 0;\n  }\n}\n\n\n/*\n  returns a bookmark for thd-local variables, creating if neccessary.\n  returns null for non thd-local variables.\n  Requires that a write lock is obtained on LOCK_system_variables_hash\n*/\nstatic st_bookmark *register_var(const char *plugin, const char *name,\n                                 int flags)\n{\n  size_t length= strlen(plugin) + strlen(name) + 3, size, offset, new_size;\n  st_bookmark *result;\n  char *varname, *p;\n\n  DBUG_ASSERT(flags & PLUGIN_VAR_THDLOCAL);\n\n  size= var_storage_size(flags);\n  varname= ((char*) my_alloca(length));\n  strxmov(varname + 1, plugin, \"_\", name, NullS);\n  for (p= varname + 1; *p; p++)\n    if (*p == '-')\n      *p= '_';\n\n  if (!(result= find_bookmark(NULL, varname + 1, flags)))\n  {\n    result= (st_bookmark*) alloc_root(&plugin_vars_mem_root,\n                                      sizeof(struct st_bookmark) + length-1);\n    varname[0]= plugin_var_bookmark_key(flags);\n    memcpy(result->key, varname, length);\n    result->name_len= (uint)(length - 2);\n    result->offset= -1;\n\n    DBUG_ASSERT(size && !(size & (size-1))); /* must be power of 2 */\n\n    offset= global_system_variables.dynamic_variables_size;\n    offset= (offset + size - 1) & ~(size - 1);\n    result->offset= (int) offset;\n\n    new_size= (offset + size + 63) & ~63;\n\n    if (new_size > global_variables_dynamic_size)\n    {\n      global_system_variables.dynamic_variables_ptr= (char*)\n        my_realloc(global_system_variables.dynamic_variables_ptr, new_size,\n                   MYF(MY_WME | MY_FAE | MY_ALLOW_ZERO_PTR));\n      max_system_variables.dynamic_variables_ptr= (char*)\n        my_realloc(max_system_variables.dynamic_variables_ptr, new_size,\n                   MYF(MY_WME | MY_FAE | MY_ALLOW_ZERO_PTR));\n      /*\n        Clear the new variable value space. This is required for string\n        variables. If their value is non-NULL, it must point to a valid\n        string.\n      */\n      bzero(global_system_variables.dynamic_variables_ptr +\n            global_variables_dynamic_size,\n            new_size - global_variables_dynamic_size);\n      bzero(max_system_variables.dynamic_variables_ptr +\n            global_variables_dynamic_size,\n            new_size - global_variables_dynamic_size);\n      global_variables_dynamic_size= new_size;\n    }\n\n    global_system_variables.dynamic_variables_head= (uint)offset;\n    max_system_variables.dynamic_variables_head= (uint)offset;\n    global_system_variables.dynamic_variables_size= (uint)(offset + size);\n    max_system_variables.dynamic_variables_size= (uint)(offset + size);\n    global_system_variables.dynamic_variables_version++;\n    max_system_variables.dynamic_variables_version++;\n\n    result->version= global_system_variables.dynamic_variables_version;\n\n    /* this should succeed because we have already checked if a dup exists */\n    if (my_hash_insert(&bookmark_hash, (uchar*) result))\n    {\n      fprintf(stderr, \"failed to add placeholder to hash\");\n      DBUG_ASSERT(0);\n    }\n  }\n  my_afree(varname);\n  return result;\n}\n\n\nvoid sync_dynamic_session_variables(THD* thd, bool global_lock)\n{\n  uint idx;\n\n  thd->variables.dynamic_variables_ptr= (char*)\n    my_realloc(thd->variables.dynamic_variables_ptr,\n               global_variables_dynamic_size,\n               MYF(MY_WME | MY_FAE | MY_ALLOW_ZERO_PTR));\n\n  if (global_lock)\n    mysql_mutex_lock(&LOCK_global_system_variables);\n\n  mysql_mutex_assert_owner(&LOCK_global_system_variables);\n\n  memcpy(thd->variables.dynamic_variables_ptr +\n           thd->variables.dynamic_variables_size,\n         global_system_variables.dynamic_variables_ptr +\n           thd->variables.dynamic_variables_size,\n         global_system_variables.dynamic_variables_size -\n           thd->variables.dynamic_variables_size);\n\n  /*\n    now we need to iterate through any newly copied 'defaults'\n    and if it is a string type with MEMALLOC flag, we need to strdup\n  */\n  for (idx= 0; idx < bookmark_hash.records; idx++)\n  {\n    st_bookmark *v= (st_bookmark*) my_hash_element(&bookmark_hash,idx);\n\n    if (v->version <= thd->variables.dynamic_variables_version)\n      continue; /* already in thd->variables */\n\n    /* Here we do anything special that may be required of the data types */\n\n    if ((v->key[0] & PLUGIN_VAR_TYPEMASK) == PLUGIN_VAR_STR &&\n         v->key[0] & BOOKMARK_MEMALLOC)\n    {\n      char **pp= (char**) (thd->variables.dynamic_variables_ptr + v->offset);\n      if (*pp)\n        *pp= my_strdup(*pp, MYF(MY_WME|MY_FAE));\n    }\n  }\n\n  if (global_lock)\n    mysql_mutex_unlock(&LOCK_global_system_variables);\n\n  thd->variables.dynamic_variables_version=\n         global_system_variables.dynamic_variables_version;\n  thd->variables.dynamic_variables_head=\n         global_system_variables.dynamic_variables_head;\n  thd->variables.dynamic_variables_size=\n         global_system_variables.dynamic_variables_size;\n}\n\n\n/*\n  returns a pointer to the memory which holds the thd-local variable or\n  a pointer to the global variable if thd==null.\n  If required, will sync with global variables if the requested variable\n  has not yet been allocated in the current thread.\n*/\nstatic uchar *intern_sys_var_ptr(THD* thd, int offset, bool global_lock)\n{\n  DBUG_ENTER(\"intern_sys_var_ptr\");\n  DBUG_ASSERT(offset >= 0);\n  DBUG_ASSERT((uint)offset <= global_system_variables.dynamic_variables_head);\n\n  if (!thd)\n    DBUG_RETURN((uchar*) global_system_variables.dynamic_variables_ptr + offset);\n\n  /*\n    dynamic_variables_head points to the largest valid offset\n  */\n  if (!thd->variables.dynamic_variables_ptr ||\n      (uint)offset > thd->variables.dynamic_variables_head)\n  {\n    mysql_prlock_rdlock(&LOCK_system_variables_hash);\n    sync_dynamic_session_variables(thd, global_lock);\n    mysql_prlock_unlock(&LOCK_system_variables_hash);\n  }\n  DBUG_RETURN((uchar*)thd->variables.dynamic_variables_ptr + offset);\n}\n\n\n/**\n  For correctness and simplicity's sake, a pointer to a function\n  must be compatible with pointed-to type, that is, the return and\n  parameters types must be the same. Thus, a callback function is\n  defined for each scalar type. The functions are assigned in\n  construct_options to their respective types.\n*/\n\nstatic char *mysql_sys_var_char(THD* thd, int offset)\n{\n  return (char *) intern_sys_var_ptr(thd, offset, true);\n}\n\nstatic int *mysql_sys_var_int(THD* thd, int offset)\n{\n  return (int *) intern_sys_var_ptr(thd, offset, true);\n}\n\nstatic long *mysql_sys_var_long(THD* thd, int offset)\n{\n  return (long *) intern_sys_var_ptr(thd, offset, true);\n}\n\nstatic unsigned long *mysql_sys_var_ulong(THD* thd, int offset)\n{\n  return (unsigned long *) intern_sys_var_ptr(thd, offset, true);\n}\n\nstatic long long *mysql_sys_var_longlong(THD* thd, int offset)\n{\n  return (long long *) intern_sys_var_ptr(thd, offset, true);\n}\n\nstatic unsigned long long *mysql_sys_var_ulonglong(THD* thd, int offset)\n{\n  return (unsigned long long *) intern_sys_var_ptr(thd, offset, true);\n}\n\nstatic char **mysql_sys_var_str(THD* thd, int offset)\n{\n  return (char **) intern_sys_var_ptr(thd, offset, true);\n}\n\nstatic double *mysql_sys_var_double(THD* thd, int offset)\n{\n  return (double *) intern_sys_var_ptr(thd, offset, true);\n}\n\nvoid plugin_thdvar_init(THD *thd)\n{\n  plugin_ref old_table_plugin= thd->variables.table_plugin;\n  plugin_ref old_tmp_table_plugin= thd->variables.tmp_table_plugin;\n  plugin_ref old_enforced_table_plugin= thd->variables.enforced_table_plugin;\n  DBUG_ENTER(\"plugin_thdvar_init\");\n\n  // This function may be called many times per THD (e.g. on COM_CHANGE_USER)\n  thd->variables.table_plugin= NULL;\n  thd->variables.tmp_table_plugin= NULL;\n  thd->variables.enforced_table_plugin= NULL;\n  cleanup_variables(&thd->variables);\n\n  /* This and all other variable cleanups are here for COM_CHANGE_USER :( */\n#ifndef EMBEDDED_LIBRARY\n  thd->session_tracker.sysvars.deinit(thd);\n#endif\n\n  thd->variables= global_system_variables;\n\n  /* we are going to allocate these lazily */\n  thd->variables.dynamic_variables_version= 0;\n  thd->variables.dynamic_variables_size= 0;\n  thd->variables.dynamic_variables_ptr= 0;\n\n  mysql_mutex_lock(&LOCK_plugin);\n  thd->variables.table_plugin=\n      intern_plugin_lock(NULL, global_system_variables.table_plugin);\n  if (global_system_variables.tmp_table_plugin)\n    thd->variables.tmp_table_plugin=\n          intern_plugin_lock(NULL, global_system_variables.tmp_table_plugin);\n  if (global_system_variables.enforced_table_plugin)\n    thd->variables.enforced_table_plugin=\n          intern_plugin_lock(NULL, global_system_variables.enforced_table_plugin);\n  intern_plugin_unlock(NULL, old_table_plugin);\n  intern_plugin_unlock(NULL, old_tmp_table_plugin);\n  intern_plugin_unlock(NULL, old_enforced_table_plugin);\n  mysql_mutex_unlock(&LOCK_plugin);\n\n#ifndef EMBEDDED_LIBRARY\n  thd->session_tracker.sysvars.init(thd);\n#endif\n  DBUG_VOID_RETURN;\n}\n\n\n/*\n  Unlocks all system variables which hold a reference\n*/\nstatic void unlock_variables(THD *thd, struct system_variables *vars)\n{\n  intern_plugin_unlock(NULL, vars->table_plugin);\n  intern_plugin_unlock(NULL, vars->tmp_table_plugin);\n  intern_plugin_unlock(NULL, vars->enforced_table_plugin);\n  vars->table_plugin= vars->tmp_table_plugin= vars->enforced_table_plugin= NULL;\n}\n\n\n/*\n  Frees memory used by system variables\n\n  Unlike plugin_vars_free_values() it frees all variables of all plugins,\n  it's used on shutdown.\n*/\nstatic void cleanup_variables(struct system_variables *vars)\n{\n  st_bookmark *v;\n  uint idx;\n\n  mysql_prlock_rdlock(&LOCK_system_variables_hash);\n  for (idx= 0; idx < bookmark_hash.records; idx++)\n  {\n    v= (st_bookmark*) my_hash_element(&bookmark_hash, idx);\n\n    if (v->version > vars->dynamic_variables_version)\n      continue; /* not in vars */\n\n    DBUG_ASSERT((uint)v->offset <= vars->dynamic_variables_head);\n\n    /* free allocated strings (PLUGIN_VAR_STR | PLUGIN_VAR_MEMALLOC) */\n    if ((v->key[0] & PLUGIN_VAR_TYPEMASK) == PLUGIN_VAR_STR &&\n         v->key[0] & BOOKMARK_MEMALLOC)\n    {\n      char **ptr= (char**)(vars->dynamic_variables_ptr + v->offset);\n      my_free(*ptr);\n      *ptr= NULL;\n    }\n  }\n  mysql_prlock_unlock(&LOCK_system_variables_hash);\n\n  DBUG_ASSERT(vars->table_plugin == NULL);\n  DBUG_ASSERT(vars->tmp_table_plugin == NULL);\n  DBUG_ASSERT(vars->enforced_table_plugin == NULL);\n\n  my_free(vars->dynamic_variables_ptr);\n  vars->dynamic_variables_ptr= NULL;\n  vars->dynamic_variables_size= 0;\n  vars->dynamic_variables_version= 0;\n}\n\n\nvoid plugin_thdvar_cleanup(THD *thd)\n{\n  uint idx;\n  plugin_ref *list;\n  DBUG_ENTER(\"plugin_thdvar_cleanup\");\n\n#ifndef EMBEDDED_LIBRARY\n  thd->session_tracker.sysvars.deinit(thd);\n#endif\n\n  mysql_mutex_lock(&LOCK_plugin);\n\n  unlock_variables(thd, &thd->variables);\n  cleanup_variables(&thd->variables);\n\n  if ((idx= thd->lex->plugins.elements))\n  {\n    list= ((plugin_ref*) thd->lex->plugins.buffer) + idx - 1;\n    DBUG_PRINT(\"info\",(\"unlocking %d plugins\", idx));\n    while ((uchar*) list >= thd->lex->plugins.buffer)\n      intern_plugin_unlock(NULL, *list--);\n  }\n\n  reap_plugins();\n  mysql_mutex_unlock(&LOCK_plugin);\n\n  reset_dynamic(&thd->lex->plugins);\n\n  DBUG_VOID_RETURN;\n}\n\n\n/**\n  @brief Free values of thread variables of a plugin.\n\n  This must be called before a plugin is deleted. Otherwise its\n  variables are no longer accessible and the value space is lost. Note\n  that only string values with PLUGIN_VAR_MEMALLOC are allocated and\n  must be freed.\n\n  @param[in]        vars        Chain of system variables of a plugin\n*/\n\nstatic void plugin_vars_free_values(sys_var *vars)\n{\n  DBUG_ENTER(\"plugin_vars_free_values\");\n\n  for (sys_var *var= vars; var; var= var->next)\n  {\n    sys_var_pluginvar *piv= var->cast_pluginvar();\n    if (piv &&\n        ((piv->plugin_var->flags & PLUGIN_VAR_TYPEMASK) == PLUGIN_VAR_STR) &&\n        (piv->plugin_var->flags & PLUGIN_VAR_MEMALLOC))\n    {\n      /* Free the string from global_system_variables. */\n      char **valptr= (char**) piv->real_value_ptr(NULL, OPT_GLOBAL);\n      DBUG_PRINT(\"plugin\", (\"freeing value for: '%s'  addr: %p\",\n                            var->name.str, valptr));\n      my_free(*valptr);\n      *valptr= NULL;\n    }\n  }\n  DBUG_VOID_RETURN;\n}\n\nstatic SHOW_TYPE pluginvar_show_type(const st_mysql_sys_var *plugin_var)\n{\n  switch (plugin_var->flags & (PLUGIN_VAR_TYPEMASK | PLUGIN_VAR_UNSIGNED)) {\n  case PLUGIN_VAR_BOOL:\n    return SHOW_MY_BOOL;\n  case PLUGIN_VAR_INT:\n    return SHOW_SINT;\n  case PLUGIN_VAR_INT | PLUGIN_VAR_UNSIGNED:\n    return SHOW_UINT;\n  case PLUGIN_VAR_LONG:\n    return SHOW_SLONG;\n  case PLUGIN_VAR_LONG | PLUGIN_VAR_UNSIGNED:\n    return SHOW_ULONG;\n  case PLUGIN_VAR_LONGLONG:\n    return SHOW_SLONGLONG;\n  case PLUGIN_VAR_LONGLONG | PLUGIN_VAR_UNSIGNED:\n    return SHOW_ULONGLONG;\n  case PLUGIN_VAR_STR:\n    return SHOW_CHAR_PTR;\n  case PLUGIN_VAR_ENUM:\n  case PLUGIN_VAR_SET:\n    return SHOW_CHAR;\n  case PLUGIN_VAR_DOUBLE:\n    return SHOW_DOUBLE;\n  default:\n    DBUG_ASSERT(0);\n    return SHOW_UNDEF;\n  }\n}\n\n\nstatic int pluginvar_sysvar_flags(const st_mysql_sys_var *p)\n{\n  return (p->flags & PLUGIN_VAR_THDLOCAL ? sys_var::SESSION : sys_var::GLOBAL)\n       | (p->flags & PLUGIN_VAR_READONLY ? sys_var::READONLY : 0);\n}\n\nsys_var_pluginvar::sys_var_pluginvar(sys_var_chain *chain, const char *name_arg,\n        st_plugin_int *p, st_mysql_sys_var *pv)\n    : sys_var(chain, name_arg, pv->comment, pluginvar_sysvar_flags(pv),\n              0, pv->flags & PLUGIN_VAR_NOCMDOPT ? -1 : 0, NO_ARG,\n              pluginvar_show_type(pv), 0,\n              NULL, VARIABLE_NOT_IN_BINLOG, NULL, NULL, NULL),\n    plugin(p), plugin_var(pv)\n{\n  plugin_var->name= name_arg;\n  plugin_opt_set_limits(&option, pv);\n}\n\nuchar* sys_var_pluginvar::real_value_ptr(THD *thd, enum_var_type type)\n{\n  if (type == OPT_DEFAULT)\n  {\n    switch (plugin_var->flags & PLUGIN_VAR_TYPEMASK) {\n    case PLUGIN_VAR_BOOL:\n      thd->sys_var_tmp.my_bool_value= (my_bool)option.def_value;\n      return (uchar*) &thd->sys_var_tmp.my_bool_value;\n    case PLUGIN_VAR_INT:\n      thd->sys_var_tmp.int_value= (int)option.def_value;\n      return (uchar*) &thd->sys_var_tmp.int_value;\n    case PLUGIN_VAR_LONG:\n    case PLUGIN_VAR_ENUM:\n      thd->sys_var_tmp.long_value= (long)option.def_value;\n      return (uchar*) &thd->sys_var_tmp.long_value;\n    case PLUGIN_VAR_LONGLONG:\n    case PLUGIN_VAR_SET:\n      return (uchar*) &option.def_value;\n    case PLUGIN_VAR_STR:\n      thd->sys_var_tmp.ptr_value= (void*) option.def_value;\n      return (uchar*) &thd->sys_var_tmp.ptr_value;\n    case PLUGIN_VAR_DOUBLE:\n      thd->sys_var_tmp.double_value= getopt_ulonglong2double(option.def_value);\n      return (uchar*) &thd->sys_var_tmp.double_value;\n    default:\n      DBUG_ASSERT(0);\n    }\n  }\n\n  DBUG_ASSERT(thd || (type == OPT_GLOBAL));\n  if (plugin_var->flags & PLUGIN_VAR_THDLOCAL)\n  {\n    if (type == OPT_GLOBAL)\n      thd= NULL;\n\n    return intern_sys_var_ptr(thd, *(int*) (plugin_var+1), false);\n  }\n  return *(uchar**) (plugin_var+1);\n}\n\n\nbool sys_var_pluginvar::session_is_default(THD *thd)\n{\n  uchar *value= plugin_var->flags & PLUGIN_VAR_THDLOCAL\n                ? intern_sys_var_ptr(thd, *(int*) (plugin_var+1), true)\n                : *(uchar**) (plugin_var+1);\n\n    real_value_ptr(thd, OPT_SESSION);\n\n  switch (plugin_var->flags & PLUGIN_VAR_TYPEMASK) {\n  case PLUGIN_VAR_BOOL:\n    return option.def_value == *(my_bool*)value;\n  case PLUGIN_VAR_INT:\n    return option.def_value == *(int*)value;\n  case PLUGIN_VAR_LONG:\n  case PLUGIN_VAR_ENUM:\n    return option.def_value == *(long*)value;\n  case PLUGIN_VAR_LONGLONG:\n  case PLUGIN_VAR_SET:\n    return option.def_value == *(longlong*)value;\n  case PLUGIN_VAR_STR:\n    {\n      const char *a=(char*)option.def_value;\n      const char *b=(char*)value;\n      return (!a && !b) || (a && b && strcmp(a,b));\n    }\n  case PLUGIN_VAR_DOUBLE:\n    return getopt_ulonglong2double(option.def_value) == *(double*)value;\n  }\n  DBUG_ASSERT(0);\n  return 0;\n}\n\n\nTYPELIB* sys_var_pluginvar::plugin_var_typelib(void)\n{\n  switch (plugin_var->flags & (PLUGIN_VAR_TYPEMASK | PLUGIN_VAR_THDLOCAL)) {\n  case PLUGIN_VAR_ENUM:\n    return ((sysvar_enum_t *)plugin_var)->typelib;\n  case PLUGIN_VAR_SET:\n    return ((sysvar_set_t *)plugin_var)->typelib;\n  case PLUGIN_VAR_ENUM | PLUGIN_VAR_THDLOCAL:\n    return ((thdvar_enum_t *)plugin_var)->typelib;\n  case PLUGIN_VAR_SET | PLUGIN_VAR_THDLOCAL:\n    return ((thdvar_set_t *)plugin_var)->typelib;\n  default:\n    return NULL;\n  }\n  return NULL;\t/* Keep compiler happy */\n}\n\n\nuchar* sys_var_pluginvar::do_value_ptr(THD *thd, enum_var_type type,\n                                       const LEX_CSTRING *base)\n{\n  uchar* result;\n\n  result= real_value_ptr(thd, type);\n\n  if ((plugin_var->flags & PLUGIN_VAR_TYPEMASK) == PLUGIN_VAR_ENUM)\n    result= (uchar*) get_type(plugin_var_typelib(), *(ulong*)result);\n  else if ((plugin_var->flags & PLUGIN_VAR_TYPEMASK) == PLUGIN_VAR_SET)\n    result= (uchar*) set_to_string(thd, 0, *(ulonglong*) result,\n                                   plugin_var_typelib()->type_names);\n  return result;\n}\n\nbool sys_var_pluginvar::do_check(THD *thd, set_var *var)\n{\n  st_item_value_holder value;\n  DBUG_ASSERT(!is_readonly());\n  DBUG_ASSERT(plugin_var->check);\n\n  value.value_type= item_value_type;\n  value.val_str= item_val_str;\n  value.val_int= item_val_int;\n  value.val_real= item_val_real;\n  value.is_unsigned= item_is_unsigned;\n  value.item= var->value;\n\n  return plugin_var->check(thd, plugin_var, &var->save_result, &value);\n}\n\nbool sys_var_pluginvar::session_update(THD *thd, set_var *var)\n{\n  DBUG_ASSERT(!is_readonly());\n  DBUG_ASSERT(plugin_var->flags & PLUGIN_VAR_THDLOCAL);\n  DBUG_ASSERT(thd == current_thd);\n\n  mysql_mutex_lock(&LOCK_global_system_variables);\n  void *tgt= real_value_ptr(thd, OPT_SESSION);\n  const void *src= var->value ? (void*)&var->save_result\n                              : (void*)real_value_ptr(thd, OPT_GLOBAL);\n  mysql_mutex_unlock(&LOCK_global_system_variables);\n\n  plugin_var->update(thd, plugin_var, tgt, src);\n\n  return false;\n}\n\nstatic const void *var_def_ptr(st_mysql_sys_var *pv)\n{\n    switch (pv->flags & (PLUGIN_VAR_TYPEMASK | PLUGIN_VAR_THDLOCAL)) {\n    case PLUGIN_VAR_INT:\n      return &((sysvar_uint_t*) pv)->def_val;\n    case PLUGIN_VAR_LONG:\n      return &((sysvar_ulong_t*) pv)->def_val;\n    case PLUGIN_VAR_LONGLONG:\n      return &((sysvar_ulonglong_t*) pv)->def_val;\n    case PLUGIN_VAR_ENUM:\n      return &((sysvar_enum_t*) pv)->def_val;\n    case PLUGIN_VAR_SET:\n      return &((sysvar_set_t*) pv)->def_val;\n    case PLUGIN_VAR_BOOL:\n      return &((sysvar_bool_t*) pv)->def_val;\n    case PLUGIN_VAR_STR:\n      return &((sysvar_str_t*) pv)->def_val;\n    case PLUGIN_VAR_DOUBLE:\n      return &((sysvar_double_t*) pv)->def_val;\n    case PLUGIN_VAR_INT | PLUGIN_VAR_THDLOCAL:\n      return &((thdvar_uint_t*) pv)->def_val;\n    case PLUGIN_VAR_LONG | PLUGIN_VAR_THDLOCAL:\n      return &((thdvar_ulong_t*) pv)->def_val;\n    case PLUGIN_VAR_LONGLONG | PLUGIN_VAR_THDLOCAL:\n      return &((thdvar_ulonglong_t*) pv)->def_val;\n    case PLUGIN_VAR_ENUM | PLUGIN_VAR_THDLOCAL:\n      return &((thdvar_enum_t*) pv)->def_val;\n    case PLUGIN_VAR_SET | PLUGIN_VAR_THDLOCAL:\n      return &((thdvar_set_t*) pv)->def_val;\n    case PLUGIN_VAR_BOOL | PLUGIN_VAR_THDLOCAL:\n      return &((thdvar_bool_t*) pv)->def_val;\n    case PLUGIN_VAR_STR | PLUGIN_VAR_THDLOCAL:\n      return &((thdvar_str_t*) pv)->def_val;\n    case PLUGIN_VAR_DOUBLE | PLUGIN_VAR_THDLOCAL:\n      return &((thdvar_double_t*) pv)->def_val;\n    default:\n      DBUG_ASSERT(0);\n      return NULL;\n    }\n}\n\n\nbool sys_var_pluginvar::global_update(THD *thd, set_var *var)\n{\n  DBUG_ASSERT(!is_readonly());\n  mysql_mutex_assert_owner(&LOCK_global_system_variables);\n\n  void *tgt= real_value_ptr(thd, OPT_GLOBAL);\n  const void *src= &var->save_result;\n\n  if (!var->value)\n    src= var_def_ptr(plugin_var);\n\n  plugin_var->update(thd, plugin_var, tgt, src);\n  return false;\n}\n\n\n#define OPTION_SET_LIMITS(type, options, opt) \\\n  options->var_type= type; \\\n  options->def_value= (opt)->def_val; \\\n  options->min_value= (opt)->min_val; \\\n  options->max_value= (opt)->max_val; \\\n  options->block_size= (long) (opt)->blk_sz\n\n#define OPTION_SET_LIMITS_DOUBLE(options, opt) \\\n  options->var_type= GET_DOUBLE; \\\n  options->def_value= (longlong) getopt_double2ulonglong((opt)->def_val); \\\n  options->min_value= (longlong) getopt_double2ulonglong((opt)->min_val); \\\n  options->max_value= getopt_double2ulonglong((opt)->max_val); \\\n  options->block_size= (long) (opt)->blk_sz;\n\nvoid plugin_opt_set_limits(struct my_option *options,\n                           const struct st_mysql_sys_var *opt)\n{\n  options->sub_size= 0;\n\n  switch (opt->flags & (PLUGIN_VAR_TYPEMASK |\n                        PLUGIN_VAR_UNSIGNED | PLUGIN_VAR_THDLOCAL)) {\n  /* global system variables */\n  case PLUGIN_VAR_INT:\n    OPTION_SET_LIMITS(GET_INT, options, (sysvar_int_t*) opt);\n    break;\n  case PLUGIN_VAR_INT | PLUGIN_VAR_UNSIGNED:\n    OPTION_SET_LIMITS(GET_UINT, options, (sysvar_uint_t*) opt);\n    break;\n  case PLUGIN_VAR_LONG:\n    OPTION_SET_LIMITS(GET_LONG, options, (sysvar_long_t*) opt);\n    break;\n  case PLUGIN_VAR_LONG | PLUGIN_VAR_UNSIGNED:\n    OPTION_SET_LIMITS(GET_ULONG, options, (sysvar_ulong_t*) opt);\n    break;\n  case PLUGIN_VAR_LONGLONG:\n    OPTION_SET_LIMITS(GET_LL, options, (sysvar_longlong_t*) opt);\n    break;\n  case PLUGIN_VAR_LONGLONG | PLUGIN_VAR_UNSIGNED:\n    OPTION_SET_LIMITS(GET_ULL, options, (sysvar_ulonglong_t*) opt);\n    break;\n  case PLUGIN_VAR_ENUM:\n    options->var_type= GET_ENUM;\n    options->typelib= ((sysvar_enum_t*) opt)->typelib;\n    options->def_value= ((sysvar_enum_t*) opt)->def_val;\n    options->min_value= options->block_size= 0;\n    options->max_value= options->typelib->count - 1;\n    break;\n  case PLUGIN_VAR_SET:\n    options->var_type= GET_SET;\n    options->typelib= ((sysvar_set_t*) opt)->typelib;\n    options->def_value= ((sysvar_set_t*) opt)->def_val;\n    options->min_value= options->block_size= 0;\n    options->max_value= (1ULL << options->typelib->count) - 1;\n    break;\n  case PLUGIN_VAR_BOOL:\n    options->var_type= GET_BOOL;\n    options->def_value= ((sysvar_bool_t*) opt)->def_val;\n    options->typelib= &bool_typelib;\n    break;\n  case PLUGIN_VAR_STR:\n    options->var_type= ((opt->flags & PLUGIN_VAR_MEMALLOC) ?\n                        GET_STR_ALLOC : GET_STR);\n    options->def_value= (intptr) ((sysvar_str_t*) opt)->def_val;\n    break;\n  case PLUGIN_VAR_DOUBLE:\n    OPTION_SET_LIMITS_DOUBLE(options, (sysvar_double_t*) opt);\n    break;\n  /* threadlocal variables */\n  case PLUGIN_VAR_INT | PLUGIN_VAR_THDLOCAL:\n    OPTION_SET_LIMITS(GET_INT, options, (thdvar_int_t*) opt);\n    break;\n  case PLUGIN_VAR_INT | PLUGIN_VAR_UNSIGNED | PLUGIN_VAR_THDLOCAL:\n    OPTION_SET_LIMITS(GET_UINT, options, (thdvar_uint_t*) opt);\n    break;\n  case PLUGIN_VAR_LONG | PLUGIN_VAR_THDLOCAL:\n    OPTION_SET_LIMITS(GET_LONG, options, (thdvar_long_t*) opt);\n    break;\n  case PLUGIN_VAR_LONG | PLUGIN_VAR_UNSIGNED | PLUGIN_VAR_THDLOCAL:\n    OPTION_SET_LIMITS(GET_ULONG, options, (thdvar_ulong_t*) opt);\n    break;\n  case PLUGIN_VAR_LONGLONG | PLUGIN_VAR_THDLOCAL:\n    OPTION_SET_LIMITS(GET_LL, options, (thdvar_longlong_t*) opt);\n    break;\n  case PLUGIN_VAR_LONGLONG | PLUGIN_VAR_UNSIGNED | PLUGIN_VAR_THDLOCAL:\n    OPTION_SET_LIMITS(GET_ULL, options, (thdvar_ulonglong_t*) opt);\n    break;\n  case PLUGIN_VAR_DOUBLE | PLUGIN_VAR_THDLOCAL:\n    OPTION_SET_LIMITS_DOUBLE(options, (thdvar_double_t*) opt);\n    break;\n  case PLUGIN_VAR_ENUM | PLUGIN_VAR_THDLOCAL:\n    options->var_type= GET_ENUM;\n    options->typelib= ((thdvar_enum_t*) opt)->typelib;\n    options->def_value= ((thdvar_enum_t*) opt)->def_val;\n    options->min_value= options->block_size= 0;\n    options->max_value= options->typelib->count - 1;\n    break;\n  case PLUGIN_VAR_SET | PLUGIN_VAR_THDLOCAL:\n    options->var_type= GET_SET;\n    options->typelib= ((thdvar_set_t*) opt)->typelib;\n    options->def_value= ((thdvar_set_t*) opt)->def_val;\n    options->min_value= options->block_size= 0;\n    options->max_value= (1ULL << options->typelib->count) - 1;\n    break;\n  case PLUGIN_VAR_BOOL | PLUGIN_VAR_THDLOCAL:\n    options->var_type= GET_BOOL;\n    options->def_value= ((thdvar_bool_t*) opt)->def_val;\n    options->typelib= &bool_typelib;\n    break;\n  case PLUGIN_VAR_STR | PLUGIN_VAR_THDLOCAL:\n    options->var_type= ((opt->flags & PLUGIN_VAR_MEMALLOC) ?\n                        GET_STR_ALLOC : GET_STR);\n    options->def_value= (intptr) ((thdvar_str_t*) opt)->def_val;\n    break;\n  default:\n    DBUG_ASSERT(0);\n  }\n  options->arg_type= REQUIRED_ARG;\n  if (opt->flags & PLUGIN_VAR_NOCMDARG)\n    options->arg_type= NO_ARG;\n  if (opt->flags & PLUGIN_VAR_OPCMDARG)\n    options->arg_type= OPT_ARG;\n}\n\n/**\n  Creates a set of my_option objects associated with a specified plugin-\n  handle.\n\n  @param mem_root Memory allocator to be used.\n  @param tmp A pointer to a plugin handle\n  @param[out] options A pointer to a pre-allocated static array\n\n  The set is stored in the pre-allocated static array supplied to the function.\n  The size of the array is calculated as (number_of_plugin_varaibles*2+3). The\n  reason is that each option can have a prefix '--plugin-' in addtion to the\n  shorter form '--&lt;plugin-name&gt;'. There is also space allocated for\n  terminating NULL pointers.\n\n  @return\n    @retval -1 An error occurred\n    @retval 0 Success\n*/\n\nstatic int construct_options(MEM_ROOT *mem_root, struct st_plugin_int *tmp,\n                             my_option *options)\n{\n  const char *plugin_name= tmp->plugin->name;\n  const LEX_CSTRING plugin_dash = { STRING_WITH_LEN(\"plugin-\") };\n  size_t plugin_name_len= strlen(plugin_name);\n  size_t optnamelen;\n  const int max_comment_len= 255;\n  char *comment= (char *) alloc_root(mem_root, max_comment_len + 1);\n  char *optname;\n\n  int index= 0, UNINIT_VAR(offset);\n  st_mysql_sys_var *opt, **plugin_option;\n  st_bookmark *v;\n\n  /** Used to circumvent the const attribute on my_option::name */\n  char *plugin_name_ptr, *plugin_name_with_prefix_ptr;\n\n  DBUG_ENTER(\"construct_options\");\n\n  plugin_name_ptr= (char*) alloc_root(mem_root, plugin_name_len + 1);\n  strcpy(plugin_name_ptr, plugin_name);\n  my_casedn_str(&my_charset_latin1, plugin_name_ptr);\n  convert_underscore_to_dash(plugin_name_ptr, plugin_name_len);\n  plugin_name_with_prefix_ptr= (char*) alloc_root(mem_root,\n                                                  plugin_name_len +\n                                                  plugin_dash.length + 1);\n  strxmov(plugin_name_with_prefix_ptr, plugin_dash.str, plugin_name_ptr, NullS);\n\n  if (!plugin_is_forced(tmp))\n  {\n    /* support --skip-plugin-foo syntax */\n    options[0].name= plugin_name_ptr;\n    options[1].name= plugin_name_with_prefix_ptr;\n    options[0].id= options[1].id= 0;\n    options[0].var_type= options[1].var_type= GET_ENUM;\n    options[0].arg_type= options[1].arg_type= OPT_ARG;\n    options[0].def_value= options[1].def_value= 1; /* ON */\n    options[0].typelib= options[1].typelib= &global_plugin_typelib;\n\n    strxnmov(comment, max_comment_len, \"Enable or disable \", plugin_name,\n            \" plugin. One of: ON, OFF, FORCE (don't start if the plugin\"\n            \" fails to load), FORCE_PLUS_PERMANENT (like FORCE, but the\"\n            \" plugin can not be uninstalled).\", NullS);\n    options[0].comment= comment;\n    /*\n      Allocate temporary space for the value of the tristate.\n      This option will have a limited lifetime and is not used beyond\n      server initialization.\n      GET_ENUM value is an unsigned long integer.\n    */\n    options[0].value= options[1].value=\n                      (uchar **)alloc_root(mem_root, sizeof(ulong));\n    *((ulong*) options[0].value)= (ulong) options[0].def_value;\n\n    options+= 2;\n  }\n\n  /*\n    Two passes as the 2nd pass will take pointer addresses for use\n    by my_getopt and register_var() in the first pass uses realloc\n  */\n\n  for (plugin_option= tmp->plugin->system_vars;\n       plugin_option && *plugin_option; plugin_option++, index++)\n  {\n    opt= *plugin_option;\n\n    if (!opt->name)\n    {\n      sql_print_error(\"Missing variable name in plugin '%s'.\",\n                      plugin_name);\n      DBUG_RETURN(-1);\n    }\n\n    if (!(opt->flags & PLUGIN_VAR_THDLOCAL))\n      continue;\n    if (!(register_var(plugin_name_ptr, opt->name, opt->flags)))\n      continue;\n    switch (opt->flags & PLUGIN_VAR_TYPEMASK) {\n    case PLUGIN_VAR_BOOL:\n      ((thdvar_bool_t *) opt)->resolve= mysql_sys_var_char;\n      break;\n    case PLUGIN_VAR_INT:\n      ((thdvar_int_t *) opt)->resolve= mysql_sys_var_int;\n      break;\n    case PLUGIN_VAR_LONG:\n      ((thdvar_long_t *) opt)->resolve= mysql_sys_var_long;\n      break;\n    case PLUGIN_VAR_LONGLONG:\n      ((thdvar_longlong_t *) opt)->resolve= mysql_sys_var_longlong;\n      break;\n    case PLUGIN_VAR_STR:\n      ((thdvar_str_t *) opt)->resolve= mysql_sys_var_str;\n      break;\n    case PLUGIN_VAR_ENUM:\n      ((thdvar_enum_t *) opt)->resolve= mysql_sys_var_ulong;\n      break;\n    case PLUGIN_VAR_SET:\n      ((thdvar_set_t *) opt)->resolve= mysql_sys_var_ulonglong;\n      break;\n    case PLUGIN_VAR_DOUBLE:\n      ((thdvar_double_t *) opt)->resolve= mysql_sys_var_double;\n      break;\n    default:\n      sql_print_error(\"Unknown variable type code 0x%x in plugin '%s'.\",\n                      opt->flags, plugin_name);\n      DBUG_RETURN(-1);\n    };\n  }\n\n  for (plugin_option= tmp->plugin->system_vars;\n       plugin_option && *plugin_option; plugin_option++, index++)\n  {\n    switch ((opt= *plugin_option)->flags & PLUGIN_VAR_TYPEMASK) {\n    case PLUGIN_VAR_BOOL:\n      if (!opt->check)\n        opt->check= check_func_bool;\n      if (!opt->update)\n        opt->update= update_func_bool;\n      break;\n    case PLUGIN_VAR_INT:\n      if (!opt->check)\n        opt->check= check_func_int;\n      if (!opt->update)\n        opt->update= update_func_int;\n      break;\n    case PLUGIN_VAR_LONG:\n      if (!opt->check)\n        opt->check= check_func_long;\n      if (!opt->update)\n        opt->update= update_func_long;\n      break;\n    case PLUGIN_VAR_LONGLONG:\n      if (!opt->check)\n        opt->check= check_func_longlong;\n      if (!opt->update)\n        opt->update= update_func_longlong;\n      break;\n    case PLUGIN_VAR_STR:\n      if (!opt->check)\n        opt->check= check_func_str;\n      if (!opt->update)\n      {\n        opt->update= update_func_str;\n        if (!(opt->flags & (PLUGIN_VAR_MEMALLOC | PLUGIN_VAR_READONLY)))\n        {\n          opt->flags|= PLUGIN_VAR_READONLY;\n          sql_print_warning(\"Server variable %s of plugin %s was forced \"\n                            \"to be read-only: string variable without \"\n                            \"update_func and PLUGIN_VAR_MEMALLOC flag\",\n                            opt->name, plugin_name);\n        }\n      }\n      break;\n    case PLUGIN_VAR_ENUM:\n      if (!opt->check)\n        opt->check= check_func_enum;\n      if (!opt->update)\n        opt->update= update_func_long;\n      break;\n    case PLUGIN_VAR_SET:\n      if (!opt->check)\n        opt->check= check_func_set;\n      if (!opt->update)\n        opt->update= update_func_longlong;\n      break;\n    case PLUGIN_VAR_DOUBLE:\n      if (!opt->check)\n        opt->check= check_func_double;\n      if (!opt->update)\n        opt->update= update_func_double;\n      break;\n    default:\n      sql_print_error(\"Unknown variable type code 0x%x in plugin '%s'.\",\n                      opt->flags, plugin_name);\n      DBUG_RETURN(-1);\n    }\n\n    if ((opt->flags & (PLUGIN_VAR_NOCMDOPT | PLUGIN_VAR_THDLOCAL))\n                    == PLUGIN_VAR_NOCMDOPT)\n      continue;\n\n    if (!(opt->flags & PLUGIN_VAR_THDLOCAL))\n    {\n      optnamelen= strlen(opt->name);\n      optname= (char*) alloc_root(mem_root, plugin_name_len + optnamelen + 2);\n      strxmov(optname, plugin_name_ptr, \"-\", opt->name, NullS);\n      optnamelen= plugin_name_len + optnamelen + 1;\n    }\n    else\n    {\n      /* this should not fail because register_var should create entry */\n      if (!(v= find_bookmark(plugin_name_ptr, opt->name, opt->flags)))\n      {\n        sql_print_error(\"Thread local variable '%s' not allocated \"\n                        \"in plugin '%s'.\", opt->name, plugin_name);\n        DBUG_RETURN(-1);\n      }\n\n      *(int*)(opt + 1)= offset= v->offset;\n\n      if (opt->flags & PLUGIN_VAR_NOCMDOPT)\n      {\n        char *val= global_system_variables.dynamic_variables_ptr + offset;\n        if (((opt->flags & PLUGIN_VAR_TYPEMASK) == PLUGIN_VAR_STR) &&\n             (opt->flags & PLUGIN_VAR_MEMALLOC))\n        {\n          char *def_val= *(char**)var_def_ptr(opt);\n          *(char**)val= def_val ? my_strdup(def_val, MYF(0)) : NULL;\n        }\n        else\n          memcpy(val, var_def_ptr(opt), var_storage_size(opt->flags));\n        continue;\n      }\n\n      optname= (char*) memdup_root(mem_root, v->key + 1,\n                                   (optnamelen= v->name_len) + 1);\n    }\n\n    convert_underscore_to_dash(optname, optnamelen);\n\n    options->name= optname;\n    options->comment= opt->comment;\n    options->app_type= (opt->flags & PLUGIN_VAR_NOSYSVAR) ? NULL : opt;\n    options->id= 0;\n\n    plugin_opt_set_limits(options, opt);\n\n    if (opt->flags & PLUGIN_VAR_THDLOCAL)\n      options->value= options->u_max_value= (uchar**)\n        (global_system_variables.dynamic_variables_ptr + offset);\n    else\n      options->value= options->u_max_value= *(uchar***) (opt + 1);\n\n    char *option_name_ptr;\n    options[1]= options[0];\n    options[1].name= option_name_ptr= (char*) alloc_root(mem_root,\n                                                        plugin_dash.length +\n                                                        optnamelen + 1);\n    options[1].comment= 0; /* Hidden from the help text */\n    strxmov(option_name_ptr, plugin_dash.str, optname, NullS);\n\n    options+= 2;\n  }\n\n  DBUG_RETURN(0);\n}\n\n\nstatic my_option *construct_help_options(MEM_ROOT *mem_root,\n                                         struct st_plugin_int *p)\n{\n  st_mysql_sys_var **opt;\n  my_option *opts;\n  uint count= EXTRA_OPTIONS;\n  DBUG_ENTER(\"construct_help_options\");\n\n  for (opt= p->plugin->system_vars; opt && *opt; opt++, count+= 2)\n    ;\n\n  if (!(opts= (my_option*) alloc_root(mem_root, sizeof(my_option) * count)))\n    DBUG_RETURN(NULL);\n\n  bzero(opts, sizeof(my_option) * count);\n\n  /**\n    some plugin variables (those that don't have PLUGIN_VAR_NOSYSVAR flag)\n    have their names prefixed with the plugin name. Restore the names here\n    to get the correct (not double-prefixed) help text.\n    We won't need @@sysvars anymore and don't care about their proper names.\n  */\n  restore_ptr_backup(p->nbackups, p->ptr_backup);\n\n  if (construct_options(mem_root, p, opts))\n    DBUG_RETURN(NULL);\n\n  DBUG_RETURN(opts);\n}\n\nextern \"C\" my_bool mark_changed(int, const struct my_option *, char *);\nmy_bool mark_changed(int, const struct my_option *opt, char *)\n{\n  if (opt->app_type)\n  {\n    sys_var *var= (sys_var*) opt->app_type;\n    var->value_origin= sys_var::CONFIG;\n  }\n  return 0;\n}\n\n/**\n  It is always false to mark global plugin variable unloaded just to be\n  safe because we have no way now to know truth about them.\n\n  TODO: make correct mechanism for global plugin variables\n*/\nstatic bool static_unload= FALSE;\n\n/**\n  Create and register system variables supplied from the plugin and\n  assigns initial values from corresponding command line arguments.\n\n  @param tmp_root Temporary scratch space\n  @param[out] plugin Internal plugin structure\n  @param argc Number of command line arguments\n  @param argv Command line argument vector\n\n  The plugin will be updated with a policy on how to handle errors during\n  initialization.\n\n  @note Requires that a write-lock is held on LOCK_system_variables_hash\n\n  @return How initialization of the plugin should be handled.\n    @retval  0 Initialization should proceed.\n    @retval  1 Plugin is disabled.\n    @retval -1 An error has occurred.\n*/\n\nstatic int test_plugin_options(MEM_ROOT *tmp_root, struct st_plugin_int *tmp,\n                               int *argc, char **argv)\n{\n  struct sys_var_chain chain= { NULL, NULL };\n  bool disable_plugin;\n  enum_plugin_load_option plugin_load_option= tmp->load_option;\n\n  MEM_ROOT *mem_root= alloc_root_inited(&tmp->mem_root) ?\n                      &tmp->mem_root : &plugin_vars_mem_root;\n  st_mysql_sys_var **opt;\n  my_option *opts= NULL;\n  int error= 1;\n  struct st_bookmark *var;\n  size_t len=0, count= EXTRA_OPTIONS;\n  st_ptr_backup *tmp_backup= 0;\n  DBUG_ENTER(\"test_plugin_options\");\n  DBUG_ASSERT(tmp->plugin && tmp->name.str);\n\n  if (tmp->plugin->system_vars || (*argc > 1))\n  {\n    for (opt= tmp->plugin->system_vars; opt && *opt; opt++)\n    {\n      len++;\n      if (!((*opt)->flags & PLUGIN_VAR_NOCMDOPT))\n        count+= 2; /* --{plugin}-{optname} and --plugin-{plugin}-{optname} */\n    }\n\n    if (!(opts= (my_option*) alloc_root(tmp_root, sizeof(my_option) * count)))\n    {\n      sql_print_error(\"Out of memory for plugin '%s'.\", tmp->name.str);\n      DBUG_RETURN(-1);\n    }\n    bzero(opts, sizeof(my_option) * count);\n\n    if (construct_options(tmp_root, tmp, opts))\n    {\n      sql_print_error(\"Bad options for plugin '%s'.\", tmp->name.str);\n      DBUG_RETURN(-1);\n    }\n\n    if (tmp->plugin->system_vars)\n    {\n      tmp_backup= (st_ptr_backup *)my_alloca(len * sizeof(tmp_backup[0]));\n      DBUG_ASSERT(tmp->nbackups == 0);\n      DBUG_ASSERT(tmp->ptr_backup == 0);\n\n      for (opt= tmp->plugin->system_vars; *opt; opt++)\n      {\n        st_mysql_sys_var *o= *opt;\n        char *varname;\n        sys_var *v;\n\n        if (o->flags & PLUGIN_VAR_NOSYSVAR)\n          continue;\n\n        tmp_backup[tmp->nbackups++].save(&o->name);\n        if ((var= find_bookmark(tmp->name.str, o->name, o->flags)))\n        {\n          varname= var->key + 1;\n          var->loaded= TRUE;\n        }\n        else\n        {\n          var= NULL;\n          len= tmp->name.length + strlen(o->name) + 2;\n          varname= (char*) alloc_root(mem_root, len);\n          strxmov(varname, tmp->name.str, \"-\", o->name, NullS);\n          my_casedn_str(&my_charset_latin1, varname);\n          convert_dash_to_underscore(varname, len-1);\n        }\n        v= new (mem_root) sys_var_pluginvar(&chain, varname, tmp, o);\n        v->test_load= (var ? &var->loaded : &static_unload);\n        DBUG_ASSERT(static_unload == FALSE);\n\n        if (!(o->flags & PLUGIN_VAR_NOCMDOPT))\n        {\n          // update app_type, used for I_S.SYSTEM_VARIABLES\n          for (my_option *mo=opts; mo->name; mo++)\n            if (mo->app_type == o)\n              mo->app_type= v;\n        }\n      }\n\n      if (tmp->nbackups)\n      {\n        size_t bytes= tmp->nbackups * sizeof(tmp->ptr_backup[0]);\n        tmp->ptr_backup= (st_ptr_backup *)alloc_root(mem_root, bytes);\n        if (!tmp->ptr_backup)\n        {\n          restore_ptr_backup(tmp->nbackups, tmp_backup);\n          my_afree(tmp_backup);\n          goto err;\n        }\n        memcpy(tmp->ptr_backup, tmp_backup, bytes);\n      }\n      my_afree(tmp_backup);\n    }\n\n    /*\n      We adjust the default value to account for the hardcoded exceptions\n      we have set for the federated and ndbcluster storage engines.\n    */\n    if (!plugin_is_forced(tmp))\n      opts[0].def_value= opts[1].def_value= plugin_load_option;\n\n    error= handle_options(argc, &argv, opts, mark_changed);\n    (*argc)++; /* add back one for the program name */\n\n    if (unlikely(error))\n    {\n       sql_print_error(\"Parsing options for plugin '%s' failed.\",\n                       tmp->name.str);\n       goto err;\n    }\n    /*\n     Set plugin loading policy from option value. First element in the option\n     list is always the <plugin name> option value.\n    */\n    if (!plugin_is_forced(tmp))\n      plugin_load_option= (enum_plugin_load_option) *(ulong*) opts[0].value;\n  }\n\n  disable_plugin= (plugin_load_option == PLUGIN_OFF);\n  tmp->load_option= plugin_load_option;\n\n  error= 1;\n\n  /*\n    If the plugin is disabled it should not be initialized.\n  */\n  if (disable_plugin)\n  {\n    if (global_system_variables.log_warnings)\n      sql_print_information(\"Plugin '%s' is disabled.\",\n                            tmp->name.str);\n    goto err;\n  }\n\n  if (tmp->plugin->system_vars)\n  {\n    for (opt= tmp->plugin->system_vars; *opt; opt++)\n    {\n      /*\n        PLUGIN_VAR_STR command-line options without PLUGIN_VAR_MEMALLOC, point\n        directly to values in the argv[] array. For plugins started at the\n        server startup, argv[] array is allocated with load_defaults(), and\n        freed when the server is shut down.  But for plugins loaded with\n        INSTALL PLUGIN, the memory allocated with load_defaults() is freed with\n        free() at the end of mysql_install_plugin(). Which means we cannot\n        allow any pointers into that area.\n        Thus, for all plugins loaded after the server was started,\n        we copy string values to a plugin's memroot.\n      */\n      if (mysqld_server_started &&\n          (((*opt)->flags & (PLUGIN_VAR_TYPEMASK | PLUGIN_VAR_NOCMDOPT |\n                             PLUGIN_VAR_MEMALLOC)) == PLUGIN_VAR_STR))\n      {\n        sysvar_str_t* str= (sysvar_str_t *)*opt;\n        if (*str->value)\n          *str->value= strdup_root(mem_root, *str->value);\n      }\n    }\n\n    if (chain.first)\n    {\n      chain.last->next = NULL;\n      if (mysql_add_sys_var_chain(chain.first))\n      {\n        sql_print_error(\"Plugin '%s' has conflicting system variables\",\n                        tmp->name.str);\n        goto err;\n      }\n      tmp->system_vars= chain.first;\n    }\n  }\n\n  DBUG_RETURN(0);\n\nerr:\n  if (opts)\n    my_cleanup_options(opts);\n  DBUG_RETURN(error);\n}\n\n\n/****************************************************************************\n  Help Verbose text with Plugin System Variables\n****************************************************************************/\n\n\nvoid add_plugin_options(DYNAMIC_ARRAY *options, MEM_ROOT *mem_root)\n{\n  struct st_plugin_int *p;\n  my_option *opt;\n\n  if (!initialized)\n    return;\n\n  for (uint idx= 0; idx < plugin_array.elements; idx++)\n  {\n    p= *dynamic_element(&plugin_array, idx, struct st_plugin_int **);\n\n    if (!(opt= construct_help_options(mem_root, p)))\n      continue;\n\n    /* Only options with a non-NULL comment are displayed in help text */\n    for (;opt->name; opt++)\n      if (opt->comment)\n        insert_dynamic(options, (uchar*) opt);\n  }\n}\n\n\n/**\n  Returns a sys_var corresponding to a particular MYSQL_SYSVAR(...)\n*/\nsys_var *find_plugin_sysvar(st_plugin_int *plugin, st_mysql_sys_var *plugin_var)\n{\n  for (sys_var *var= plugin->system_vars; var; var= var->next)\n  {\n    sys_var_pluginvar *pvar=var->cast_pluginvar();\n    if (pvar->plugin_var == plugin_var)\n      return var;\n  }\n  return 0;\n}\n\n/*\n  On dlclose() we need to restore values of all symbols that we've modified in\n  the DSO. The reason is - the DSO might not actually be unloaded, so on the\n  next dlopen() these symbols will have old values, they won't be\n  reinitialized.\n\n  Perhaps, there can be many reason, why a DSO won't be unloaded. Strictly\n  speaking, it's implementation defined whether to unload an unused DSO or to\n  keep it in memory.\n\n  In particular, this happens for some plugins: In 2009 a new ELF stub was\n  introduced, see Ulrich Drepper's email \"Unique symbols for C++\"\n  http://www.redhat.com/archives/posix-c++-wg/2009-August/msg00002.html\n\n  DSO that has objects with this stub (STB_GNU_UNIQUE) cannot be unloaded\n  (this is mentioned in the email, see the url above).\n\n  These \"unique\" objects are, for example, static variables in templates,\n  in inline functions, in classes. So any DSO that uses them can\n  only be loaded once. And because Boost has them, any DSO that uses Boost\n  almost certainly cannot be unloaded.\n\n  To know whether a particular DSO has these objects, one can use\n\n    readelf -s /path/to/plugin.so|grep UNIQUE\n\n  There's nothing we can do about it, but to reset the DSO to its initial\n  state before dlclose().\n*/\nstatic void restore_ptr_backup(uint n, st_ptr_backup *backup)\n{\n  while (n--)\n    (backup++)->restore();\n}\n\n/****************************************************************************\n  thd specifics service, see include/mysql/service_thd_specifics.h\n****************************************************************************/\nstatic const int INVALID_THD_KEY= -1;\nstatic uint thd_key_no = 42;\n\nint thd_key_create(MYSQL_THD_KEY_T *key)\n{\n  int flags= PLUGIN_VAR_THDLOCAL | PLUGIN_VAR_STR |\n             PLUGIN_VAR_NOSYSVAR | PLUGIN_VAR_NOCMDOPT;\n  char namebuf[256];\n  snprintf(namebuf, sizeof(namebuf), \"%u\", thd_key_no++);\n  mysql_prlock_wrlock(&LOCK_system_variables_hash);\n  // non-letters in the name as an extra safety\n  st_bookmark *bookmark= register_var(\"\\a\\v\\a\\t\\a\\r\", namebuf, flags);\n  mysql_prlock_unlock(&LOCK_system_variables_hash);\n  if (bookmark)\n  {\n    *key= bookmark->offset;\n    return 0;\n  }\n  return ENOMEM;\n}\n\nvoid thd_key_delete(MYSQL_THD_KEY_T *key)\n{\n  *key= INVALID_THD_KEY;\n}\n\nvoid* thd_getspecific(MYSQL_THD thd, MYSQL_THD_KEY_T key)\n{\n  DBUG_ASSERT(key != INVALID_THD_KEY);\n  if (key == INVALID_THD_KEY || (!thd && !(thd= current_thd)))\n    return 0;\n\n  return *(void**)(intern_sys_var_ptr(thd, key, true));\n}\n\nint thd_setspecific(MYSQL_THD thd, MYSQL_THD_KEY_T key, void *value)\n{\n  DBUG_ASSERT(key != INVALID_THD_KEY);\n  if (key == INVALID_THD_KEY || (!thd && !(thd= current_thd)))\n    return EINVAL;\n  \n  memcpy(intern_sys_var_ptr(thd, key, true), &value, sizeof(void*));\n  return 0;\n}\n\nvoid plugin_mutex_init()\n{\n#ifdef HAVE_PSI_INTERFACE\n  init_plugin_psi_keys();\n#endif\n  mysql_mutex_init(key_LOCK_plugin, &LOCK_plugin, MY_MUTEX_INIT_FAST);\n}\n\n#ifdef WITH_WSREP\n\n/*\n  Placeholder for global_system_variables.table_plugin required during\n  initialization of startup wsrep threads.\n*/\nstatic st_plugin_int wsrep_dummy_plugin;\nstatic st_plugin_int *wsrep_dummy_plugin_ptr;\n\n/*\n  Initialize wsrep_dummy_plugin and assign it to\n  global_system_variables.table_plugin.\n*/\nvoid wsrep_plugins_pre_init()\n{\n  wsrep_dummy_plugin_ptr= &wsrep_dummy_plugin;\n  wsrep_dummy_plugin.state= PLUGIN_IS_DISABLED;\n  global_system_variables.table_plugin=\n    plugin_int_to_ref(wsrep_dummy_plugin_ptr);\n}\n\n/*\n  This function is intended to be called after the plugins and related\n  global system variables are initialized. It re-initializes some data\n  members of wsrep startup threads with correct values, as these value\n  were not available at the time these threads were created.\n*/\n\nmy_bool post_init_callback(THD *thd, void *)\n{\n  DBUG_ASSERT(!current_thd);\n  if (thd->wsrep_applier)\n  {\n    // Save options_bits as it will get overwritten in\n    // plugin_thdvar_init() (verified)\n    ulonglong option_bits_saved= thd->variables.option_bits;\n\n    set_current_thd(thd);\n    plugin_thdvar_init(thd);\n\n    // Restore option_bits\n    thd->variables.option_bits= option_bits_saved;\n  }\n  set_current_thd(0);\n  return 0;\n}\n\n\nvoid wsrep_plugins_post_init()\n{\n  mysql_mutex_lock(&LOCK_global_system_variables);\n  server_threads.iterate(post_init_callback);\n  mysql_mutex_unlock(&LOCK_global_system_variables);\n}\n#endif /* WITH_WSREP */\n",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysys/my_addr_resolve.c": "/* Copyright (C) 2011 Monty Program Ab\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; version 2 of the License.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1335  USA */\n\n#include \"mysys_priv.h\"\n#include <m_string.h>\n#include <my_sys.h>\n#include <my_stacktrace.h>\n\n/**\n  strip the path, leave the file name and the last dirname\n*/\nstatic const char *strip_path(const char *s) __attribute__((unused));\nstatic const char *strip_path(const char *s)\n{\n  const char *prev, *last;\n  for(prev= last= s; *s; s++)\n    if (*s == '/' || *s == '\\\\')\n    {\n      prev= last;\n      last= s + 1;\n    }\n  return prev;\n}\n\n/*\n  The following is very much single-threaded code and it's only supposed\n  to be used on shutdown or for a crash report\n  Or the caller should take care and use mutexes.\n\n  Also it does not free any its memory. For the same reason -\n  it's only used for crash reports or on shutdown when we already\n  have a memory leak.\n*/\n\n#ifdef HAVE_BFD_H\n#include <bfd.h>\nstatic bfd *bfdh= 0;\nstatic asymbol **symtable= 0;\n\n#if defined(HAVE_LINK_H) && defined(HAVE_DLOPEN)\n#include <link.h>\nstatic ElfW(Addr) offset= 0;\n#else\n#define offset 0\n#endif\n\n/**\n  finds a file name, a line number, and a function name corresponding to addr.\n\n  the function name is demangled.\n  the file name is stripped of its path, only the two last components are kept\n  the resolving logic is mostly based on addr2line of binutils-2.17\n\n  @return 0 on success, 1 on failure\n*/\nint my_addr_resolve(void *ptr, my_addr_loc *loc)\n{\n  bfd_vma addr= (intptr)ptr - offset;\n  asection *sec;\n\n  for (sec= bfdh->sections; sec; sec= sec->next)\n  {\n    bfd_vma start;\n\n    if ((bfd_get_section_flags(bfdh, sec) & SEC_ALLOC) == 0)\n      continue;\n\n    start = bfd_get_section_vma(bfdh, sec);\n    if (addr < start || addr >= start + bfd_get_section_size(sec))\n      continue;\n\n    if (bfd_find_nearest_line(bfdh, sec, symtable, addr - start,\n                              &loc->file, &loc->func, &loc->line))\n    {\n      if (loc->file)\n        loc->file= strip_path(loc->file);\n      else\n        loc->file= \"\";\n\n      if (loc->func)\n      {\n        const char *str= bfd_demangle(bfdh, loc->func, 3);\n        if (str)\n          loc->func= str;\n      }\n\n      return 0;\n    }\n  }\n  \n  return 1;\n}\n\nconst char *my_addr_resolve_init()\n{\n  if (!bfdh)\n  {\n    uint unused;\n    char **matching;\n\n#if defined(HAVE_LINK_H) && defined(HAVE_DLOPEN)\n    struct link_map *lm = (struct link_map*) dlopen(0, RTLD_NOW);\n    if (lm)\n      offset= lm->l_addr;\n#endif\n\n    bfdh= bfd_openr(my_progname, NULL);\n    if (!bfdh)\n      goto err;\n\n    if (bfd_check_format(bfdh, bfd_archive))\n      goto err;\n    if (!bfd_check_format_matches (bfdh, bfd_object, &matching))\n      goto err;\n\n    if (bfd_read_minisymbols(bfdh, FALSE, (void *)&symtable, &unused) < 0)\n      goto err;\n  }\n  return 0;\n\nerr:\n  return bfd_errmsg(bfd_get_error());\n}\n#elif defined(HAVE_LIBELF_H)\n/*\n  another possible implementation.\n*/\n#elif defined(MY_ADDR_RESOLVE_FORK)\n/*\n  yet another - just execute addr2line pipe the addresses to it, and parse the\n  output\n*/\n\n#include <m_string.h>\n#include <ctype.h>\n#include <sys/wait.h>\n\nstatic int in[2], out[2];\nstatic pid_t pid;\nstatic char addr2line_binary[1024];\nstatic char output[1024];\n\nint start_addr2line_fork(const char *binary_path)\n{\n\n  if (pid > 0)\n  {\n    /* Don't leak FDs */\n    close(in[1]);\n    close(out[0]);\n    /* Don't create zombie processes. */\n    waitpid(pid, NULL, 0);\n  }\n\n  if (pipe(in) < 0)\n    return 1;\n  if (pipe(out) < 0)\n    return 1;\n\n  pid = fork();\n  if (pid == -1)\n    return 1;\n\n  if (!pid) /* child */\n  {\n    dup2(in[0], 0);\n    dup2(out[1], 1);\n    close(in[0]);\n    close(in[1]);\n    close(out[0]);\n    close(out[1]);\n    execlp(\"addr2line\", \"addr2line\", \"-C\", \"-f\", \"-e\", binary_path, NULL);\n    exit(1);\n  }\n\n  close(in[0]);\n  close(out[1]);\n\n  return 0;\n}\n\nint my_addr_resolve(void *ptr, my_addr_loc *loc)\n{\n  char input[32];\n  size_t len;\n\n  ssize_t total_bytes_read = 0;\n  ssize_t extra_bytes_read = 0;\n  ssize_t parsed = 0;\n\n  fd_set set;\n  struct timeval timeout;\n\n  int filename_start = -1;\n  int line_number_start = -1;\n\n  Dl_info info;\n  void *offset;\n\n  if (!dladdr(ptr, &info))\n    return 1;\n\n  if (strcmp(addr2line_binary, info.dli_fname))\n  {\n    /* We use dli_fname in case the path is longer than the length of our static\n       string. We don't want to allocate anything dynamicaly here as we are in\n       a \"crashed\" state. */\n    if (start_addr2line_fork(info.dli_fname))\n    {\n      addr2line_binary[0] = '\\0';\n      return 2;\n    }\n    /* Save result for future comparisons. */\n    strnmov(addr2line_binary, info.dli_fname, sizeof(addr2line_binary));\n  }\n  offset = info.dli_fbase;\n  len= my_snprintf(input, sizeof(input), \"%08x\\n\", (ulonglong)(ptr - offset));\n  if (write(in[1], input, len) <= 0)\n    return 3;\n\n  FD_ZERO(&set);\n  FD_SET(out[0], &set);\n\n  /* 100 ms should be plenty of time for addr2line to issue a response. */\n  timeout.tv_sec = 0;\n  timeout.tv_usec = 100000;\n  /* Read in a loop till all the output from addr2line is complete. */\n  while (parsed == total_bytes_read &&\n         select(out[0] + 1, &set, NULL, NULL, &timeout) > 0)\n  {\n    extra_bytes_read= read(out[0], output + total_bytes_read,\n                           sizeof(output) - total_bytes_read);\n    if (extra_bytes_read < 0)\n      return 4;\n    /* Timeout or max bytes read. */\n    if (extra_bytes_read == 0)\n      break;\n\n    total_bytes_read += extra_bytes_read;\n\n    /* Go through the addr2line response and get the required data.\n       The response is structured in 2 lines. The first line contains the function\n       name, while the second one contains <filename>:<line number> */\n    for (; parsed < total_bytes_read; parsed++)\n    {\n      if (output[parsed] == '\\n')\n      {\n        filename_start = parsed + 1;\n        output[parsed] = '\\0';\n      }\n      if (filename_start != -1 && output[parsed] == ':')\n      {\n        line_number_start = parsed + 1;\n        output[parsed] = '\\0';\n        break;\n      }\n    }\n  }\n\n  /* Response is malformed. */\n  if (filename_start == -1 || line_number_start == -1)\n   return 5;\n\n  loc->func= output;\n  loc->file= output + filename_start;\n  loc->line= atoi(output + line_number_start);\n\n  /* Addr2line was unable to extract any meaningful information. */\n  if (strcmp(loc->file, \"??\") == 0)\n    return 6;\n\n  loc->file= strip_path(loc->file);\n\n  return 0;\n}\n\nconst char *my_addr_resolve_init()\n{\n  return 0;\n}\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/cmake/dtrace.cmake": "# Copyright (c) 2009, 2014, Oracle and/or its affiliates. All rights reserved.\n# \n# This program is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation; version 2 of the License.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1335  USA \n\nIF(CMAKE_SYSTEM_NAME MATCHES \"SunOS\" AND CMAKE_COMPILER_IS_GNUCXX\n  AND CMAKE_SIZEOF_VOID_P EQUAL 4)\n  IF(NOT DEFINED BUGGY_GCC_NO_DTRACE_MODULES)\n    EXECUTE_PROCESS(\n      COMMAND ${CMAKE_C_COMPILER} ${CMAKE_C_COMPILER_ARG1}  --version\n      OUTPUT_VARIABLE out)\n    IF(out MATCHES \"3.4.6\")\n     # This gcc causes crashes in dlopen() for dtraced shared libs,\n     # while standard shipped with Solaris10 3.4.3 is ok\n     SET(BUGGY_GCC_NO_DTRACE_MODULES 1 CACHE INTERNAL \"\")\n    ELSE()\n     SET(BUGGY_GCC_NO_DTRACE_MODULES 0 CACHE INTERNAL \"\")\n    ENDIF()\n  ENDIF()\nENDIF()\n\n# Check if OS supports DTrace\nMACRO(CHECK_DTRACE)\n FIND_PROGRAM(DTRACE dtrace)\n MARK_AS_ADVANCED(DTRACE)\n\n IF(CMAKE_C_COMPILER MATCHES \"ccache\" AND CMAKE_SYSTEM_NAME MATCHES \"Linux\")\n   # dtrace fails on fedora if  CC='ccache gcc' is used\n   SET(BUGGY_LINUX_DTRACE 1)\n ENDIF()\n\n # On FreeBSD, dtrace does not handle userland tracing yet\n IF(DTRACE AND NOT CMAKE_SYSTEM_NAME MATCHES \"FreeBSD\"\n     AND NOT BUGGY_GCC_NO_DTRACE_MODULES\n     AND NOT BUGGY_LINUX_DTRACE\n     AND NOT CMAKE_SYSTEM_NAME MATCHES \"SunOS\")\n   SET(ENABLE_DTRACE ON CACHE BOOL \"Enable dtrace\")\n ENDIF()\n # On GNU/Hurd, dtrace is not supported\n IF(DTRACE AND CMAKE_SYSTEM_NAME MATCHES \"GNU\")\n   SET(ENABLE_DTRACE OFF CACHE BOOL \"Disable dtrace\")\n ENDIF()\n SET(HAVE_DTRACE ${ENABLE_DTRACE})\n IF(CMAKE_SYSTEM_NAME MATCHES \"SunOS\")\n   IF(CMAKE_SIZEOF_VOID_P EQUAL 4)\n     SET(DTRACE_FLAGS -32 CACHE INTERNAL \"DTrace architecture flags\")\n   ELSE()\n     SET(DTRACE_FLAGS -64 CACHE INTERNAL \"DTrace architecture flags\")\n   ENDIF()\n ENDIF()\nENDMACRO()\n\nCHECK_DTRACE()\n\n# Produce a header file  with\n# DTrace macros\nMACRO (DTRACE_HEADER provider header header_no_dtrace)\n IF(ENABLE_DTRACE)\n ADD_CUSTOM_COMMAND(\n   OUTPUT  ${header} ${header_no_dtrace}\n   COMMAND ${DTRACE} -h -s ${provider} -o ${header}\n   COMMAND perl ${CMAKE_SOURCE_DIR}/scripts/dheadgen.pl -f ${provider} > ${header_no_dtrace}\n   DEPENDS ${provider}\n )\n ENDIF()\nENDMACRO()\n\n\n# Create provider headers\nIF(ENABLE_DTRACE)\n  CONFIGURE_FILE(${CMAKE_SOURCE_DIR}/include/probes_mysql.d.base \n    ${CMAKE_BINARY_DIR}/include/probes_mysql.d COPYONLY)\n  DTRACE_HEADER(\n   ${CMAKE_BINARY_DIR}/include/probes_mysql.d \n   ${CMAKE_BINARY_DIR}/include/probes_mysql_dtrace.h\n   ${CMAKE_BINARY_DIR}/include/probes_mysql_nodtrace.h\n  )\n  ADD_CUSTOM_TARGET(gen_dtrace_header\n  DEPENDS  \n  ${CMAKE_BINARY_DIR}/include/probes_mysql.d\n  ${CMAKE_BINARY_DIR}/include/probes_mysql_dtrace.h\n  ${CMAKE_BINARY_DIR}/include/probes_mysql_nodtrace.h\n  ) \nELSE()\n CONFIGURE_FILE(${CMAKE_SOURCE_DIR}/include/probes_mysql_nodtrace.h.in\n   ${CMAKE_BINARY_DIR}/include/probes_mysql_nodtrace.h COPYONLY)\nENDIF()\n\nFUNCTION(DTRACE_INSTRUMENT target)\n  IF(BUGGY_GCC_NO_DTRACE_MODULES)\n    GET_TARGET_PROPERTY(target_type ${target} TYPE)\n    IF(target_type MATCHES \"MODULE_LIBRARY\")\n      RETURN()\n    ENDIF()\n  ENDIF()\n  IF(ENABLE_DTRACE)\n    ADD_DEPENDENCIES(${target} gen_dtrace_header)\n\n    # Invoke dtrace to generate object file and link it together with target.\n    IF(CMAKE_SYSTEM_NAME MATCHES \"SunOS\")\n      SET(objdir ${CMAKE_CURRENT_BINARY_DIR}/CMakeFiles/${target}.dir)\n      SET(outfile ${objdir}/${target}_dtrace.o)\n      GET_TARGET_PROPERTY(target_type ${target} TYPE)\n      ADD_CUSTOM_COMMAND(\n        TARGET ${target} PRE_LINK \n        COMMAND ${CMAKE_COMMAND}\n          -DDTRACE=${DTRACE}\t  \n          -DOUTFILE=${outfile} \n          -DDFILE=${CMAKE_BINARY_DIR}/include/probes_mysql.d\n          -DDTRACE_FLAGS=${DTRACE_FLAGS}\n          -DDIRS=.\n          -DTYPE=${target_type}\n          -P ${CMAKE_SOURCE_DIR}/cmake/dtrace_prelink.cmake\n        WORKING_DIRECTORY ${objdir}\n      )\n    ELSEIF(CMAKE_SYSTEM_NAME MATCHES \"Linux\")\n      # dtrace on Linux runs gcc and uses flags from environment\n      SET(CFLAGS_SAVED $ENV{CFLAGS})\n      SET(ENV{CFLAGS} ${CMAKE_C_FLAGS})\n      SET(outfile \"${CMAKE_BINARY_DIR}/probes_mysql.o\")\n      # Systemtap object\n      EXECUTE_PROCESS(\n        COMMAND ${DTRACE} -G -s ${CMAKE_SOURCE_DIR}/include/probes_mysql.d.base\n        -o ${outfile}\n        )\n      SET(ENV{CFLAGS} ${CFLAGS_SAVED})\n    ENDIF()\n\n    # Do not try to extend the library if we have not built the .o file\n    IF(outfile)\n      # Add full  object path to linker flags\n      GET_TARGET_PROPERTY(target_type ${target} TYPE)\n      IF(NOT target_type MATCHES \"STATIC\")\n        SET_TARGET_PROPERTIES(${target} PROPERTIES LINK_FLAGS \"${outfile}\")\n      ELSE()\n        # For static library flags, add the object to the library.\n        # Note: DTrace probes in static libraries are  unusable currently \n        # (see explanation for DTRACE_INSTRUMENT_STATIC_LIBS below)\n        # but maybe one day this will be fixed.\n        GET_TARGET_PROPERTY(target_location ${target} LOCATION)\n        ADD_CUSTOM_COMMAND(\n          TARGET ${target} POST_BUILD\n          COMMAND ${CMAKE_AR} r  ${target_location} ${outfile}\n\t  COMMAND ${CMAKE_RANLIB} ${target_location}\n          )\n        # Used in DTRACE_INSTRUMENT_WITH_STATIC_LIBS\n        SET(TARGET_OBJECT_DIRECTORY_${target}  ${objdir} CACHE INTERNAL \"\")\n      ENDIF()\n    ENDIF()\n  ENDIF()\nENDFUNCTION()\n\n\n# Ugly workaround for Solaris' DTrace inability to use probes\n# from static libraries, discussed e.g in this thread\n# (http://opensolaris.org/jive/thread.jspa?messageID=432454)\n# We have to collect all object files that may be instrumented\n# and go into the mysqld (also those that come from in static libs)\n# run them again through dtrace -G to generate an ELF file that links\n# to mysqld.\nMACRO (DTRACE_INSTRUMENT_STATIC_LIBS target libs)\nIF(CMAKE_SYSTEM_NAME MATCHES \"SunOS\" AND ENABLE_DTRACE)\n  # Filter out non-static libraries in the list, if any\n  SET(static_libs)\n  FOREACH(lib ${libs})\n    GET_TARGET_PROPERTY(libtype ${lib} TYPE)\n    IF(libtype MATCHES STATIC_LIBRARY)\n      SET(static_libs ${static_libs} ${lib})\n    ENDIF()\n  ENDFOREACH()\n\n  FOREACH(lib ${static_libs})\n    SET(dirs ${dirs} ${TARGET_OBJECT_DIRECTORY_${lib}})\n  ENDFOREACH()\n\n  SET (obj ${CMAKE_CURRENT_BINARY_DIR}/${target}_dtrace_all.o)\n  ADD_CUSTOM_COMMAND(\n  OUTPUT ${obj}\n  DEPENDS ${static_libs}\n  COMMAND ${CMAKE_COMMAND}\n   -DDTRACE=${DTRACE}\t  \n   -DOUTFILE=${obj} \n   -DDFILE=${CMAKE_BINARY_DIR}/include/probes_mysql.d\n   -DDTRACE_FLAGS=${DTRACE_FLAGS}\n   \"-DDIRS=${dirs}\"\n   -DTYPE=MERGE\n   -P ${CMAKE_SOURCE_DIR}/cmake/dtrace_prelink.cmake\n   VERBATIM\n  )\n  ADD_CUSTOM_TARGET(${target}_dtrace_all  DEPENDS ${obj})\n  ADD_DEPENDENCIES(${target} ${target}_dtrace_all)\n  TARGET_LINK_LIBRARIES(${target} ${obj})\nENDIF()\nENDMACRO()\n",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/cmake/os/SunOS.cmake": "# Copyright (c) 2010, Oracle and/or its affiliates. All rights reserved.\n# \n# This program is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation; version 2 of the License.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1335  USA \n\nINCLUDE(CheckSymbolExists)\nINCLUDE(CheckCSourceRuns)\nINCLUDE(CheckCSourceCompiles) \n\n# Enable 64 bit file offsets\nSET(_FILE_OFFSET_BITS 64)\n\n# Legacy option, without it  my_pthread is having problems\nADD_DEFINITIONS(-DHAVE_RWLOCK_T)\n\n# On  Solaris, use of intrinsics will screw the lib search logic\n# Force using -lm, so rint etc are found.\nSET(LIBM m)\n\n# CMake defined -lthread as thread flag. This crashes in dlopen \n# when trying to load plugins workaround with -lpthread\nSET(CMAKE_THREADS_LIBS_INIT -lpthread CACHE INTERNAL \"\" FORCE)\n\n# Solaris specific large page support\nCHECK_SYMBOL_EXISTS(MHA_MAPSIZE_VA sys/mman.h  HAVE_DECL_MHA_MAPSIZE_VA)\nIF(HAVE_DECL_MHA_MAPSIZE_VA)\n SET(HAVE_SOLARIS_LARGE_PAGES 1)\n SET(HAVE_LARGE_PAGE_OPTION 1)\nENDIF()\n\n\n# Solaris atomics\nCHECK_C_SOURCE_RUNS(\n \"\n #include  <atomic.h>\n  int main()\n  {\n    int foo = -10; int bar = 10;\n    int64_t foo64 = -10; int64_t bar64 = 10;\n    if (atomic_add_int_nv((uint_t *)&foo, bar) || foo)\n      return -1;\n    bar = atomic_swap_uint((uint_t *)&foo, (uint_t)bar);\n    if (bar || foo != 10)\n     return -1;\n    bar = atomic_cas_uint((uint_t *)&bar, (uint_t)foo, 15);\n    if (bar)\n      return -1;\n    if (atomic_add_64_nv((volatile uint64_t *)&foo64, bar64) || foo64)\n      return -1;\n    bar64 = atomic_swap_64((volatile uint64_t *)&foo64, (uint64_t)bar64);\n    if (bar64 || foo64 != 10)\n      return -1;\n    bar64 = atomic_cas_64((volatile uint64_t *)&bar64, (uint_t)foo64, 15);\n    if (bar64)\n      return -1;\n    atomic_or_64((volatile uint64_t *)&bar64, 0);\n    return 0;\n  }\n\"  HAVE_SOLARIS_ATOMIC)\n\n\n# Check is special processor flag needs to be set on older GCC\n#that defaults to v8 sparc . Code here is taken from my_rdtsc.h\nIF(CMAKE_COMPILER_IS_GNUCC AND CMAKE_SIZEOF_VOID_P EQUAL 4\n  AND CMAKE_SYSTEM_PROCESSOR MATCHES \"sparc\")\n  SET(SOURCE\n  \"\n  int main()\n  {\n     long high\\;\n     long low\\;\n    __asm __volatile__ (\\\"rd %%tick,%1\\; srlx %1,32,%0\\\" : \\\"=r\\\" ( high), \\\"=r\\\" (low))\\;\n    return 0\\;\n  } \")\n  CHECK_C_SOURCE_COMPILES(${SOURCE}  HAVE_SPARC32_TICK)\n  IF(NOT HAVE_SPARC32_TICK)\n    SET(CMAKE_REQUIRED_FLAGS \"-mcpu=v9\")\n    CHECK_C_SOURCE_COMPILES(${SOURCE}  HAVE_SPARC32_TICK_WITH_V9)\n    SET(CMAKE_REQUIRED_FLAGS)\n    IF(HAVE_SPARC32_TICK_WITH_V9)\n      SET(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -mcpu=v9\")\n      SET(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -mcpu=v9\")\n    ENDIF()\n  ENDIF()\nENDIF()\n\nIF(CMAKE_CXX_COMPILER_ID MATCHES \"SunPro\")\n  # Unnamed structs and unions\n  SET(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -features=extensions\")\nENDIF()\n",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/wsrep-lib/src/thread_service_v1.hpp": "/*\n * Copyright (C) 2019 Codership Oy <info@codership.com>\n *\n * This file is part of wsrep-lib.\n *\n * Wsrep-lib is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 2 of the License, or\n * (at your option) any later version.\n *\n * Wsrep-lib is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with wsrep-lib.  If not, see <https://www.gnu.org/licenses/>.\n */\n\n#ifndef WSREP_THREAD_SERVICE_V1_HPP\n#define WSREP_THREAD_SERVICE_V1_HPP\n\nnamespace wsrep\n{\n    class thread_service;\n    /**\n     * Probe thread_service_v1 support in loaded library.\n     *\n     * @param dlh Handle returned by dlopen().\n     *\n     * @return Zero on success, non-zero system error code on failure.\n     */\n    int thread_service_v1_probe(void *dlh);\n\n    /**\n     * Initialize the thread service.\n     *\n     * @param dlh Handle returned by dlopen().\n     * @params thread_service Pointer to wsrep::thread_service implementation.\n     *\n     * @return Zero on success, non-zero system error code on failure.\n     */\n    int thread_service_v1_init(void* dlh,\n                               wsrep::thread_service* thread_service);\n}\n\n#endif // WSREP_THREAD_SERVICE_V1_HPP\n",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/wsrep-lib/wsrep-API/v26/wsrep_loader.c": "/* Copyright (C) 2009-2011 Codership Oy <info@codersihp.com>\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; version 2 of the License.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n\n/*! @file wsrep implementation loader */\n\n#include <dlfcn.h>\n#include <errno.h>\n#include <string.h>\n#include <stdio.h>\n\n#include \"wsrep_api.h\"\n\n// Logging stuff for the loader\nstatic const char* log_levels[] = {\"FATAL\", \"ERROR\", \"WARN\", \"INFO\", \"DEBUG\"};\n\nstatic void default_logger (wsrep_log_level_t lvl, const char* msg)\n{\n    fprintf (stderr, \"wsrep loader: [%s] %s\\n\", log_levels[lvl], msg);\n}\n\nstatic wsrep_log_cb_t logger = default_logger;\n\n/**************************************************************************\n * Library loader\n **************************************************************************/\n\nstatic int wsrep_check_iface_version(const char* found, const char* iface_ver)\n{\n    const size_t msg_len = 128;\n    char msg[128];\n\n    if (strcmp(found, iface_ver)) {\n        snprintf (msg, msg_len,\n                  \"provider interface version mismatch: need '%s', found '%s'\",\n                  iface_ver, found);\n        logger (WSREP_LOG_ERROR, msg);\n        return EINVAL;\n    }\n\n    return 0;\n}\n\nstatic int verify(const wsrep_t *wh, const char *iface_ver)\n{\n    char msg[128];\n    const size_t msg_len = sizeof(msg);\n\n#define VERIFY(_p) if (!(_p)) {                                       \\\n        snprintf(msg, msg_len, \"wsrep_load(): verify(): %s\\n\", # _p); \\\n        logger (WSREP_LOG_ERROR, msg);                                \\\n        return EINVAL;                                                \\\n    }\n\n    VERIFY(wh);\n    VERIFY(wh->version);\n\n    if (wsrep_check_iface_version(wh->version, iface_ver))\n        return EINVAL;\n\n    VERIFY(wh->init);\n    VERIFY(wh->options_set);\n    VERIFY(wh->options_get);\n    VERIFY(wh->enc_set_key);\n    VERIFY(wh->connect);\n    VERIFY(wh->disconnect);\n    VERIFY(wh->recv);\n    VERIFY(wh->assign_read_view);\n    VERIFY(wh->certify);\n    VERIFY(wh->commit_order_enter);\n    VERIFY(wh->commit_order_leave);\n    VERIFY(wh->release);\n    VERIFY(wh->replay_trx);\n    VERIFY(wh->abort_certification);\n    VERIFY(wh->append_key);\n    VERIFY(wh->append_data);\n    VERIFY(wh->free_connection);\n    VERIFY(wh->to_execute_start);\n    VERIFY(wh->to_execute_end);\n    VERIFY(wh->preordered_collect);\n    VERIFY(wh->preordered_commit);\n    VERIFY(wh->sst_sent);\n    VERIFY(wh->sst_received);\n    VERIFY(wh->stats_get);\n    VERIFY(wh->stats_free);\n    VERIFY(wh->stats_reset);\n    VERIFY(wh->pause);\n    VERIFY(wh->resume);\n    VERIFY(wh->desync);\n    VERIFY(wh->resync);\n    VERIFY(wh->lock);\n    VERIFY(wh->unlock);\n    VERIFY(wh->is_locked);\n    VERIFY(wh->provider_name);\n    VERIFY(wh->provider_version);\n    VERIFY(wh->provider_vendor);\n    VERIFY(wh->free);\n    return 0;\n}\n\ntypedef int (*wsrep_loader_fun)(wsrep_t*);\n\nstatic wsrep_loader_fun wsrep_dlf(void *dlh, const char *sym)\n{\n    union {\n        wsrep_loader_fun dlfun;\n        void *obj;\n    } alias;\n    alias.obj = dlsym(dlh, sym);\n    return alias.dlfun;\n}\n\nstatic int wsrep_check_version_symbol(void *dlh)\n{\n    char** dlversion = NULL;\n    dlversion = (char**) dlsym(dlh, \"wsrep_interface_version\");\n    if (dlversion == NULL)\n        return 0;\n    return wsrep_check_iface_version(*dlversion, WSREP_INTERFACE_VERSION);\n}\n\nextern int wsrep_dummy_loader(wsrep_t *w);\n\nint wsrep_load(const char *spec, wsrep_t **hptr, wsrep_log_cb_t log_cb)\n{\n    int ret = 0;\n    void *dlh = NULL;\n    wsrep_loader_fun dlfun;\n    char msg[1024];\n    const size_t msg_len = sizeof(msg) - 1;\n    msg[msg_len] = 0;\n\n    if (NULL != log_cb)\n        logger = log_cb;\n\n    if (!(spec && hptr))\n        return EINVAL;\n\n    snprintf (msg, msg_len,\n              \"wsrep_load(): loading provider library '%s'\", spec);\n    logger (WSREP_LOG_INFO, msg);\n\n    if (!(*hptr = malloc(sizeof(wsrep_t)))) {\n        logger (WSREP_LOG_FATAL, \"wsrep_load(): out of memory\");\n        return ENOMEM;\n    }\n\n    if (!spec || strcmp(spec, WSREP_NONE) == 0) {\n        if ((ret = wsrep_dummy_loader(*hptr)) != 0) {\n            free (*hptr);\n            *hptr = NULL;\n        }\n        return ret;\n    }\n\n    if (!(dlh = dlopen(spec, RTLD_NOW | RTLD_LOCAL))) {\n        snprintf(msg, msg_len, \"wsrep_load(): dlopen(): %s\", dlerror());\n        logger (WSREP_LOG_ERROR, msg);\n        ret = EINVAL;\n        goto out;\n    }\n\n    if (!(dlfun = wsrep_dlf(dlh, \"wsrep_loader\"))) {\n        ret = EINVAL;\n        goto out;\n    }\n\n    if (wsrep_check_version_symbol(dlh) != 0) {\n        ret = EINVAL;\n        goto out;\n    }\n\n    if ((ret = (*dlfun)(*hptr)) != 0) {\n        snprintf(msg, msg_len, \"wsrep_load(): loader failed: %s\",\n                 strerror(ret));\n        logger (WSREP_LOG_ERROR, msg);\n        goto out;\n    }\n\n    if ((ret = verify(*hptr, WSREP_INTERFACE_VERSION)) != 0) {\n        snprintf (msg, msg_len,\n                  \"wsrep_load(): interface version mismatch: my version %s, \"\n                  \"provider version %s\", WSREP_INTERFACE_VERSION,\n                  (*hptr)->version);\n        logger (WSREP_LOG_ERROR, msg);\n        goto out;\n    }\n\n    (*hptr)->dlh = dlh;\n\nout:\n    if (ret != 0) {\n        if (dlh) dlclose(dlh);\n        free(*hptr);\n        *hptr = NULL;\n    } else {\n        snprintf (msg, msg_len,\n                  \"wsrep_load(): %s %s by %s loaded successfully.\",\n                  (*hptr)->provider_name, (*hptr)->provider_version,\n                  (*hptr)->provider_vendor);\n        logger (WSREP_LOG_INFO, msg);\n    }\n\n    return ret;\n}\n\nvoid wsrep_unload(wsrep_t *hptr)\n{\n    if (!hptr) {\n        logger (WSREP_LOG_WARN, \"wsrep_unload(): null pointer.\");\n    } else {\n        if (hptr->free)\n            hptr->free(hptr);\n        if (hptr->dlh)\n            dlclose(hptr->dlh);\n        free(hptr);\n    }\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/wsrep-lib/wsrep-API/v26/wsrep_api.h": "/* Copyright (C) 2009-2013 Codership Oy <info@codership.com>\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; version 2 of the License.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License along\n   with this program; if not, write to the Free Software Foundation, Inc.,\n   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n\n/*!\n  @file wsrep API declaration.\n\n  HOW TO READ THIS FILE.\n\n  Due to C language rules this header layout doesn't lend itself to intuitive\n  reading. So here's the scoop: in the end this header declares two main types:\n\n  * struct wsrep_init_args\n\n  and\n\n  * struct wsrep\n\n  wsrep_init_args contains initialization parameters for wsrep provider like\n  names, addresses, etc. and pointers to callbacks. The callbacks will be called\n  by provider when it needs to do something application-specific, like log a\n  message or apply a writeset. It should be passed to init() call from\n  wsrep API. It is an application part of wsrep API contract.\n\n  struct wsrep is the interface to wsrep provider. It contains all wsrep API\n  calls. It is a provider part of wsrep API contract.\n\n  Finally, wsrep_load() method loads (dlopens) wsrep provider library. It is\n  defined in wsrep_loader.c unit and is part of libwsrep.a (which is not a\n  wsrep provider, but a convenience library).\n\n  wsrep_unload() does the reverse.\n\n*/\n#ifndef WSREP_H\n#define WSREP_H\n\n#include <stdint.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <time.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/**************************************************************************\n *                                                                        *\n *                       wsrep replication API                            *\n *                                                                        *\n **************************************************************************/\n\n#define WSREP_INTERFACE_VERSION \"26\"\n\n/*! Empty backend spec */\n#define WSREP_NONE \"none\"\n\n\n/*!\n * @brief log severity levels, passed as first argument to log handler\n */\ntypedef enum wsrep_log_level\n{\n    WSREP_LOG_FATAL, //!< Unrecoverable error, application must quit.\n    WSREP_LOG_ERROR, //!< Operation failed, must be repeated.\n    WSREP_LOG_WARN,  //!< Unexpected condition, but no operational failure.\n    WSREP_LOG_INFO,  //!< Informational message.\n    WSREP_LOG_DEBUG  //!< Debug message. Shows only of compiled with debug.\n} wsrep_log_level_t;\n\n/*!\n * @brief error log handler\n *\n *        All messages from wsrep provider are directed to this\n *        handler, if present.\n *\n * @param level   log level\n * @param message log message\n */\ntypedef void (*wsrep_log_cb_t)(wsrep_log_level_t, const char *);\n\n\n/*!\n *  Certain provider capabilities application may want to know about\n */\n#define WSREP_CAP_MULTI_MASTER          ( 1ULL << 0 )\n#define WSREP_CAP_CERTIFICATION         ( 1ULL << 1 )\n#define WSREP_CAP_PARALLEL_APPLYING     ( 1ULL << 2 )\n#define WSREP_CAP_TRX_REPLAY            ( 1ULL << 3 )\n#define WSREP_CAP_ISOLATION             ( 1ULL << 4 )\n#define WSREP_CAP_PAUSE                 ( 1ULL << 5 )\n#define WSREP_CAP_CAUSAL_READS          ( 1ULL << 6 )\n#define WSREP_CAP_CAUSAL_TRX            ( 1ULL << 7 )\n#define WSREP_CAP_INCREMENTAL_WRITESET  ( 1ULL << 8 )\n#define WSREP_CAP_SESSION_LOCKS         ( 1ULL << 9 )\n#define WSREP_CAP_DISTRIBUTED_LOCKS     ( 1ULL << 10 )\n#define WSREP_CAP_CONSISTENCY_CHECK     ( 1ULL << 11 )\n#define WSREP_CAP_UNORDERED             ( 1ULL << 12 )\n#define WSREP_CAP_ANNOTATION            ( 1ULL << 13 )\n#define WSREP_CAP_PREORDERED            ( 1ULL << 14 )\n#define WSREP_CAP_STREAMING             ( 1ULL << 15 )\n#define WSREP_CAP_SNAPSHOT              ( 1ULL << 16 )\n#define WSREP_CAP_NBO                   ( 1ULL << 17 )\n\ntypedef uint32_t wsrep_cap_t; //!< capabilities bitmask\n\n/*!\n * Writeset flags\n *\n * TRX_END      the writeset and all preceding writesets must be committed\n * ROLLBACK     all preceding writesets in a transaction must be rolled back\n * ISOLATION    the writeset must be applied AND committed in isolation\n * PA_UNSAFE    the writeset cannot be applied in parallel\n * COMMUTATIVE  the order in which the writeset is applied does not matter\n * NATIVE       the writeset contains another writeset in this provider format\n *\n * TRX_START    shall be set on the first trx fragment by provider\n * TRX_PREPARE  shall be set on the fragment which prepares the transaction\n *\n * Note that some of the flags are mutually exclusive (e.g. TRX_END and\n * ROLLBACK).\n */\n#define WSREP_FLAG_TRX_END              ( 1ULL << 0 )\n#define WSREP_FLAG_ROLLBACK             ( 1ULL << 1 )\n#define WSREP_FLAG_ISOLATION            ( 1ULL << 2 )\n#define WSREP_FLAG_PA_UNSAFE            ( 1ULL << 3 )\n#define WSREP_FLAG_COMMUTATIVE          ( 1ULL << 4 )\n#define WSREP_FLAG_NATIVE               ( 1ULL << 5 )\n#define WSREP_FLAG_TRX_START            ( 1ULL << 6 )\n#define WSREP_FLAG_TRX_PREPARE          ( 1ULL << 7 )\n#define WSREP_FLAG_SNAPSHOT             ( 1ULL << 8 )\n#define WSREP_FLAG_IMPLICIT_DEPS        ( 1ULL << 9 )\n\n#define WSREP_FLAGS_LAST                WSREP_FLAG_IMPLICIT_DEPS\n#define WSREP_FLAGS_MASK                ((WSREP_FLAGS_LAST << 1) - 1)\n\n\ntypedef uint64_t wsrep_trx_id_t;  //!< application transaction ID\ntypedef uint64_t wsrep_conn_id_t; //!< application connection ID\ntypedef int64_t  wsrep_seqno_t;   //!< sequence number of a writeset, etc.\n#ifdef __cplusplus\ntypedef bool     wsrep_bool_t;\n#else\ntypedef _Bool    wsrep_bool_t;    //!< should be the same as standard (C99) bool\n#endif /* __cplusplus */\n\n/*! undefined seqno */\n#define WSREP_SEQNO_UNDEFINED (-1)\n\n\n/*! wsrep provider status codes */\ntypedef enum wsrep_status\n{\n    WSREP_OK = 0,          //!< success\n    WSREP_WARNING,         //!< minor warning, error logged\n    WSREP_TRX_MISSING,     //!< transaction is not known by wsrep\n    WSREP_TRX_FAIL,        //!< transaction aborted, server can continue\n    WSREP_BF_ABORT,        //!< trx was victim of brute force abort\n    WSREP_SIZE_EXCEEDED,   //!< data exceeded maximum supported size\n    WSREP_CONN_FAIL,       //!< error in client connection, must abort\n    WSREP_NODE_FAIL,       //!< error in node state, wsrep must reinit\n    WSREP_FATAL,           //!< fatal error, server must abort\n    WSREP_NOT_IMPLEMENTED, //!< feature not implemented\n    WSREP_NOT_ALLOWED      //!< operation not allowed\n} wsrep_status_t;\n\n\n/*! wsrep callbacks status codes */\ntypedef enum wsrep_cb_status\n{\n    WSREP_CB_SUCCESS =  0, //!< success (as in \"not critical failure\")\n    WSREP_CB_FAILURE       //!< critical failure (consistency violation)\n    /* Technically, wsrep provider has no use for specific failure codes since\n     * there is nothing it can do about it but abort execution. Therefore any\n     * positive number shall indicate a critical failure. Optionally that value\n     * may be used by provider to come to a consensus about state consistency\n     * in a group of nodes. */\n} wsrep_cb_status_t;\n\n\n/*!\n * UUID type - for all unique IDs\n */\ntypedef union wsrep_uuid {\n    uint8_t data[16];\n    size_t  alignment;\n} wsrep_uuid_t;\n\n/*! Undefined UUID */\nstatic const wsrep_uuid_t WSREP_UUID_UNDEFINED = {{0,}};\n\n/*! UUID string representation length, terminating '\\0' not included */\n#define WSREP_UUID_STR_LEN 36\n\n/*!\n * Scan UUID from string\n * @return length of UUID string representation or negative error code\n */\nextern int\nwsrep_uuid_scan (const char* str, size_t str_len, wsrep_uuid_t* uuid);\n\n/*!\n * Print UUID to string\n * @return length of UUID string representation or negative error code\n */\nextern int\nwsrep_uuid_print (const wsrep_uuid_t* uuid, char* str, size_t str_len);\n\n/*!\n * @brief Compare two UUIDs\n *\n * Performs a byte by byte comparison of lhs and rhs.\n * Returns 0 if lhs and rhs match, otherwise -1 or 1 according to the\n * difference of the first byte that differs in lsh and rhs.\n *\n * @return -1, 0, 1 if lhs is respectively smaller, equal, or greater than rhs\n */\nextern int\nwsrep_uuid_compare (const wsrep_uuid_t* lhs, const wsrep_uuid_t* rhs);\n\n#define WSREP_MEMBER_NAME_LEN 32  //!< maximum logical member name length\n#define WSREP_INCOMING_LEN    256 //!< max Domain Name length + 0x00\n\n\n/*!\n * Global transaction identifier\n */\ntypedef struct wsrep_gtid\n{\n    wsrep_uuid_t  uuid;  /*!< History UUID */\n    wsrep_seqno_t seqno; /*!< Sequence number */\n} wsrep_gtid_t;\n\n/*! Undefined GTID */\nstatic const wsrep_gtid_t WSREP_GTID_UNDEFINED = {{{0, }}, -1};\n\n/*! Minimum number of bytes guaranteed to store GTID string representation,\n * terminating '\\0' not included (36 + 1 + 20) */\n#define WSREP_GTID_STR_LEN 57\n\n\n/*!\n * Scan GTID from string\n * @return length of GTID string representation or negative error code\n */\nextern int\nwsrep_gtid_scan(const char* str, size_t str_len, wsrep_gtid_t* gtid);\n\n/*!\n * Print GTID to string\n * @return length of GTID string representation or negative error code\n */\nextern int\nwsrep_gtid_print(const wsrep_gtid_t* gtid, char* str, size_t str_len);\n\n/*!\n * Source/server transaction ID (trx ID assigned at originating node)\n */\ntypedef struct wsrep_stid {\n    wsrep_uuid_t      node;    //!< source node ID\n    wsrep_trx_id_t    trx;     //!< local trx ID at source\n    wsrep_conn_id_t   conn;    //!< local connection ID at source\n} wsrep_stid_t;\n\n/*!\n * Transaction meta data\n */\ntypedef struct wsrep_trx_meta\n{\n    wsrep_gtid_t  gtid;       /*!< Global transaction identifier */\n    wsrep_stid_t  stid;       /*!< Source transaction identifier */\n    wsrep_seqno_t depends_on; /*!< Sequence number of the last transaction\n                                   this transaction may depend on */\n} wsrep_trx_meta_t;\n\n/*! Abstract data buffer structure */\ntypedef struct wsrep_buf\n{\n    const void* ptr; /*!< Pointer to data buffer */\n    size_t      len; /*!< Length of buffer */\n} wsrep_buf_t;\n\n/*! Transaction handle struct passed for wsrep transaction handling calls */\ntypedef struct wsrep_ws_handle\n{\n    wsrep_trx_id_t trx_id; //!< transaction ID\n    void*          opaque; //!< opaque provider transaction context data\n} wsrep_ws_handle_t;\n\n/*!\n * member status\n */\ntypedef enum wsrep_member_status {\n    WSREP_MEMBER_UNDEFINED, //!< undefined state\n    WSREP_MEMBER_JOINER,    //!< incomplete state, requested state transfer\n    WSREP_MEMBER_DONOR,     //!< complete state, donates state transfer\n    WSREP_MEMBER_JOINED,    //!< complete state\n    WSREP_MEMBER_SYNCED,    //!< complete state, synchronized with group\n    WSREP_MEMBER_ERROR,     //!< this and above is provider-specific error code\n    WSREP_MEMBER_MAX\n} wsrep_member_status_t;\n\n/*!\n * static information about a group member (some fields are tentative yet)\n */\ntypedef struct wsrep_member_info {\n    wsrep_uuid_t id;                           //!< group-wide unique member ID\n    char         name[WSREP_MEMBER_NAME_LEN];  //!< human-readable name\n    char         incoming[WSREP_INCOMING_LEN]; //!< address for client requests\n} wsrep_member_info_t;\n\n/*!\n * group status\n */\ntypedef enum wsrep_view_status {\n    WSREP_VIEW_PRIMARY,      //!< primary group configuration (quorum present)\n    WSREP_VIEW_NON_PRIMARY,  //!< non-primary group configuration (quorum lost)\n    WSREP_VIEW_DISCONNECTED, //!< not connected to group, retrying.\n    WSREP_VIEW_MAX\n} wsrep_view_status_t;\n\n/*!\n * view of the group\n */\ntypedef struct wsrep_view_info {\n    wsrep_gtid_t        state_id;  //!< global state ID\n    wsrep_seqno_t       view;      //!< global view number\n    wsrep_view_status_t status;    //!< view status\n    wsrep_cap_t         capabilities;//!< capabilities available in the view\n    int                 my_idx;    //!< index of this member in the view\n    int                 memb_num;  //!< number of members in the view\n    int                 proto_ver; //!< application protocol agreed on the view\n    wsrep_member_info_t members[1];//!< array of member information\n} wsrep_view_info_t;\n\n\n/*!\n * @brief connected to group\n *\n * This handler is called once the first primary view is seen.\n * The purpose of this call is to provide basic information only,\n * like node UUID and group UUID.\n */\ntypedef enum wsrep_cb_status (*wsrep_connected_cb_t) (\n    void*                    app_ctx,\n    const wsrep_view_info_t* view\n);\n\n\n/*!\n * @brief group view handler\n *\n * This handler is called in *total order* corresponding to the group\n * configuration change. It is to provide a vital information about\n * new group view.\n *\n * @param app_ctx     application context\n * @param recv_ctx    receiver context\n * @param view        new view on the group\n * @param state       current state\n * @param state_len   length of current state\n */\ntypedef enum wsrep_cb_status (*wsrep_view_cb_t) (\n    void*                     app_ctx,\n    void*                     recv_ctx,\n    const wsrep_view_info_t*  view,\n    const char*               state,\n    size_t                    state_len\n);\n\n\n/*!\n * Magic string to tell provider to engage into trivial (empty) state transfer.\n * No data will be passed, but the node shall be considered JOINED.\n * Should be passed in sst_req parameter of wsrep_sst_cb_t.\n */\n#define WSREP_STATE_TRANSFER_TRIVIAL \"trivial\"\n\n/*!\n * Magic string to tell provider not to engage in state transfer at all.\n * The member will stay in WSREP_MEMBER_UNDEFINED state but will keep on\n * receiving all writesets.\n * Should be passed in sst_req parameter of wsrep_sst_cb_t.\n */\n#define WSREP_STATE_TRANSFER_NONE \"none\"\n\n\n/*!\n * @brief Creates and returns State Snapshot Transfer request for provider.\n *\n * This handler is called whenever the node is found to miss some of events\n * from the cluster history (e.g. fresh node joining the cluster).\n * SST will be used if it is impossible (or impractically long) to replay\n * missing events, which may be not known in advance, so the node must always\n * be ready to accept full SST or abort in case event replay is impossible.\n *\n * Normally SST request is an opaque buffer that is passed to the\n * chosen SST donor node and must contain information sufficient for\n * donor to deliver SST (typically SST method and delivery address).\n * See above macros WSREP_STATE_TRANSFER_TRIVIAL and WSREP_STATE_TRANSFER_NONE\n * to modify the standard provider behavior.\n *\n * @note Currently it is assumed that sst_req is allocated using\n *       malloc()/calloc()/realloc() and it will be freed by\n *       wsrep provider.\n *\n * @param app_ctx     application context\n * @param sst_req     location to store SST request\n * @param sst_req_len location to store SST request length or error code,\n *                    value of 0 means no SST.\n */\ntypedef enum wsrep_cb_status (*wsrep_sst_request_cb_t) (\n    void*                     app_ctx,\n    void**                    sst_req,\n    size_t*                   sst_req_len\n);\n\n\n/*!\n * @brief apply callback\n *\n * This handler is called from wsrep library to apply replicated writeset\n * Must support brute force applying for multi-master operation\n *\n * @param recv_ctx  receiver context pointer provided by the application\n * @param ws_handle internal provider writeset handle\n * @param flags     WSREP_FLAG_... flags\n * @param data      data buffer containing the writeset\n * @param meta      transaction meta data of the writeset to be applied\n * @param exit_loop set to true to exit receive loop\n *\n * @return error code:\n * @retval 0 - success\n * @retval non-0 - application-specific error code\n */\ntypedef enum wsrep_cb_status (*wsrep_apply_cb_t) (\n    void*                    recv_ctx,\n    const wsrep_ws_handle_t* ws_handle,\n    uint32_t                 flags,\n    const wsrep_buf_t*       data,\n    const wsrep_trx_meta_t*  meta,\n    wsrep_bool_t*            exit_loop\n);\n\n\n/*!\n * @brief unordered callback\n *\n * This handler is called to execute unordered actions (actions that need not\n * to be executed in any particular order) attached to writeset.\n *\n * @param recv_ctx receiver context pointer provided by the application\n * @param data     data buffer containing the writeset\n */\ntypedef enum wsrep_cb_status (*wsrep_unordered_cb_t) (\n    void*              recv_ctx,\n    const wsrep_buf_t* data\n);\n\n\n/*!\n * @brief a callback to donate state snapshot\n *\n * This handler is called from wsrep library when it needs this node\n * to deliver state to a new cluster member.\n * No state changes will be committed for the duration of this call.\n * Wsrep implementation may provide internal state to be transmitted\n * to new cluster member for initial state.\n *\n * @param app_ctx   application context\n * @param recv_ctx  receiver context\n * @param str_msg   state transfer request message\n * @param gtid      current state ID on this node\n * @param state     current wsrep internal state buffer\n * @param bypass    bypass snapshot transfer, only transfer uuid:seqno pair\n */\ntypedef enum wsrep_cb_status (*wsrep_sst_donate_cb_t) (\n    void*               app_ctx,\n    void*               recv_ctx,\n    const wsrep_buf_t*  str_msg,\n    const wsrep_gtid_t* state_id,\n    const wsrep_buf_t*  state,\n    wsrep_bool_t        bypass\n);\n\n\n/*!\n * @brief a callback to signal application that wsrep state is synced\n *        with cluster\n *\n * This callback is called after wsrep library has got in sync with\n * rest of the cluster.\n *\n * @param app_ctx application context\n *\n * @return wsrep_cb_status enum\n */\ntypedef enum wsrep_cb_status (*wsrep_synced_cb_t) (void* app_ctx);\n\n\n/*\n * An opaque encryption key of arbitrary size - provided by the application\n * May contain not only the key, but also algorithm specification and the like.\n */\ntypedef wsrep_buf_t wsrep_enc_key_t;\n\n/*\n * Initialization vector/nonce. Given that most symmetric ciphers use 16 byte\n * blocks this can be made 32 bytes without much loss of generality.\n * Must be set by provider to start an encryption/decrytpion operation.\n */\ntypedef char wsrep_enc_iv_t[32];\n\n/*\n * Encryption context that should be sufficient to deterministically encrypt/\n * decrypt a data buffer either standalone or as part of a stream. May be used\n * passed in apply_cb() along with the encrypted replication events to\n * application as well.\n *\n * @param key    [in] can be a pointer to const since provider will have to keep\n *               the keys until the last writeset that uses the key is in the\n *               cache\n * @param iv     [in] initialization vector for the beginning of the new\n *               operation.\n * @param ctx    [in/out] ongoing operation context\n *               To initialize a new context the encrypt_cb() caller sets it to\n *               NULL, which signals the encryption of a new continuous buffer.\n *               In that case the callback allocates the new context (using\n *               supplied key and iv) and stores the pointer to it for\n *               processing subsequent data.\n *               The end of the operation is signaled by passing TRUE in the\n *               parameter `last` to the encryption callback, the callback then\n *               finishes any pending encryption and deallocates the context.\n */\ntypedef struct\n{\n    const wsrep_enc_key_t* key;\n    const wsrep_enc_iv_t*  iv;\n    void*                  ctx;\n}\nwsrep_enc_ctx_t;\n\n/*\n * Encryption direction\n */\ntypedef enum\n{\n    WSREP_ENC = 0, /* encryption */\n    WSREP_DEC = 1  /* decryption */\n}\nwsrep_enc_direction_t;\n\n/*\n * Encryption/decryption callback. Must be used by both provider and the\n * application to obtain identical results. Can be NULL for no encryption.\n *\n * @param app_ctx   application context\n * @param enc_ctx   current operation context\n * @param input     input data buffer\n * @param output    an output buffer, must be at least the size of the input\n *                  data plus unwritten bytes from the previous call(s). E.g. in\n *                  block mode, encryption/decryption operation will write data\n *                  to output in multiples of the algoritm block size. So a call\n *                  to encrypt a single byte won't normally write anything to\n *                  output waiting for the next input chunk. So on the next call\n *                  it may write one byte more than was given in the input.\n * @param direction of the operation (encryption/decryption)\n * @param last      true if this is the last buffer to encrypt in the stream.\n *                  In that case the callback shall write the remaining bytes of\n *                  the stream to output (if any) and deallocate ctx->ctx if\n *                  allocated previously\n *\n * @return          a number of bytes written to output or a negative error code.\n */\ntypedef int (*wsrep_encrypt_cb_t)\n(   \n    void*                 app_ctx,\n    wsrep_enc_ctx_t*      enc_ctx,\n    const wsrep_buf_t*    input,\n    void*                 output,\n    wsrep_enc_direction_t direction,\n    bool                  last\n);\n\n\n/*!\n * Initialization parameters for wsrep provider.\n */\nstruct wsrep_init_args\n{\n    void* app_ctx;             //!< Application context for callbacks\n\n    /* Configuration parameters */\n    const char* node_name;     //!< Symbolic name of this node (e.g. hostname)\n    const char* node_address;  //!< Address to be used by wsrep provider\n    const char* node_incoming; //!< Address for incoming client connections\n    const char* data_dir;      //!< Directory where wsrep files are kept if any\n    const char* options;       //!< Provider-specific configuration string\n    int         proto_ver;     //!< Max supported application protocol version\n\n    /* Application initial state information. */\n    const wsrep_gtid_t* state_id;    //!< Application state GTID\n    const wsrep_buf_t*  state;       //!< Initial state for wsrep provider\n\n    /* Application callbacks */\n    wsrep_log_cb_t         logger_cb;       //!< logging handler\n    wsrep_connected_cb_t   connected_cb;    //!< connected to group\n    wsrep_view_cb_t        view_cb;         //!< group view change handler\n    wsrep_sst_request_cb_t sst_request_cb;  //!< SST request creator\n    wsrep_encrypt_cb_t     encrypt_cb;      //!< Encryption callback\n\n    /* Applier callbacks */\n    wsrep_apply_cb_t       apply_cb;        //!< apply  callback\n    wsrep_unordered_cb_t   unordered_cb;    //!< callback for unordered actions\n\n    /* State Snapshot Transfer callbacks */\n    wsrep_sst_donate_cb_t  sst_donate_cb;   //!< donate SST\n    wsrep_synced_cb_t      synced_cb;       //!< synced with group\n};\n\n\n/*! Type of the stats variable value in struct wsrep_status_var */\ntypedef enum wsrep_var_type\n{\n    WSREP_VAR_STRING, //!< pointer to null-terminated string\n    WSREP_VAR_INT64,  //!< int64_t\n    WSREP_VAR_DOUBLE  //!< double\n}\nwsrep_var_type_t;\n\n/*! Generalized stats variable representation */\nstruct wsrep_stats_var\n{\n    const char*      name;     //!< variable name\n    wsrep_var_type_t type;     //!< variable value type\n    union {\n        int64_t     _int64;\n        double      _double;\n        const char* _string;\n    } value;                   //!< variable value\n};\n\n\n/*! Key struct used to pass certification keys for transaction handling calls.\n *  A key consists of zero or more key parts. */\ntypedef struct wsrep_key\n{\n    const wsrep_buf_t* key_parts;     /*!< Array of key parts  */\n    size_t             key_parts_num; /*!< Number of key parts */\n} wsrep_key_t;\n\n/*! Key type:\n *  EXCLUSIVE conflicts with any key type\n *  SEMI      reserved. If not supported, should be interpreted as EXCLUSIVE\n *  SHARED    conflicts only with EXCLUSIVE keys */\ntypedef enum wsrep_key_type\n{\n    WSREP_KEY_SHARED = 0,\n    WSREP_KEY_REFERENCE,\n    WSREP_KEY_UPDATE,\n    WSREP_KEY_EXCLUSIVE\n} wsrep_key_type_t;\n\n/*! Data type:\n *  ORDERED    state modification event that should be applied and committed\n *             in order.\n *  UNORDERED  some action that does not modify state and execution of which is\n *             optional and does not need to happen in order.\n *  ANNOTATION (human readable) writeset annotation. */\ntypedef enum wsrep_data_type\n{\n    WSREP_DATA_ORDERED = 0,\n    WSREP_DATA_UNORDERED,\n    WSREP_DATA_ANNOTATION\n} wsrep_data_type_t;\n\n\n/*!\n * @brief Helper method to reset trx writeset handle state when trx id changes\n *\n * Instead of passing wsrep_ws_handle_t directly to wsrep calls,\n * wrapping handle with this call offloads bookkeeping from\n * application.\n */\nstatic inline wsrep_ws_handle_t* wsrep_ws_handle_for_trx(\n    wsrep_ws_handle_t* ws_handle,\n    wsrep_trx_id_t     trx_id)\n{\n    if (ws_handle->trx_id != trx_id)\n    {\n        ws_handle->trx_id = trx_id;\n        ws_handle->opaque = NULL;\n    }\n    return ws_handle;\n}\n\n\n/*!\n *  A handle for processing preordered actions.\n *  Must be initialized to WSREP_PO_INITIALIZER before use.\n */\ntypedef struct wsrep_po_handle { void* opaque; } wsrep_po_handle_t;\n\nstatic const wsrep_po_handle_t WSREP_PO_INITIALIZER = { NULL };\n\n\ntypedef struct wsrep_st wsrep_t;\n/*!\n * wsrep interface for dynamically loadable libraries\n */\nstruct wsrep_st {\n\n    const char *version; //!< interface version string\n\n  /*!\n   * @brief Initializes wsrep provider\n   *\n   * @param wsrep provider handle\n   * @param args  wsrep initialization parameters\n   */\n    wsrep_status_t (*init)   (wsrep_t*                      wsrep,\n                              const struct wsrep_init_args* args);\n\n  /*!\n   * @brief Returns provider capabilities bitmap\n   *\n   * Note that these are potential provider capabilities. Provider will\n   * offer only capabilities supported by all members in the view\n   * (see wsrep_view_info).\n   *\n   * @param wsrep provider handle\n   */\n    wsrep_cap_t    (*capabilities) (wsrep_t* wsrep);\n\n  /*!\n   * @brief Passes provider-specific configuration string to provider.\n   *\n   * @param wsrep provider handle\n   * @param conf  configuration string\n   *\n   * @retval WSREP_OK      configuration string was parsed successfully\n   * @retval WSREP_WARNING could not parse configuration string, no action taken\n   */\n    wsrep_status_t (*options_set) (wsrep_t* wsrep, const char* conf);\n\n  /*!\n   * @brief Returns provider-specific string with current configuration values.\n   *\n   * @param wsrep provider handle\n   *\n   * @return a dynamically allocated string with current configuration\n   *         parameter values\n   */\n    char*          (*options_get) (wsrep_t* wsrep);\n\n  /*!\n   * @brief A call to set/rotate the key in provider.\n   *\n   * This may happen asynchronously and so is a best effort operation.\n   * Some buffers may still be encrypted with a previous key.\n   *\n   * @param a key object for the encryption callback\n   *\n   * return success or an error code\n   */\n    wsrep_status_t (*enc_set_key)(wsrep_t* wsrep, const wsrep_enc_key_t* key);\n\n  /*!\n   * @brief Opens connection to cluster\n   *\n   * Returns when either node is ready to operate as a part of the cluster\n   * or fails to reach operating status.\n   *\n   * @param wsrep        provider handle\n   * @param cluster_name unique symbolic cluster name\n   * @param cluster_url  URL-like cluster address (backend://address)\n   * @param state_donor  name of the node to be asked for state transfer.\n   * @param bootstrap    a flag to request initialization of a new wsrep\n   *                     service rather then a connection to the existing one.\n   *                     cluster_url may still carry important initialization\n   *                     parameters, like backend spec and/or listen address.\n   */\n    wsrep_status_t (*connect) (wsrep_t*     wsrep,\n                               const char*  cluster_name,\n                               const char*  cluster_url,\n                               const char*  state_donor,\n                               wsrep_bool_t bootstrap);\n\n  /*!\n   * @brief Closes connection to cluster.\n   *\n   * If state_uuid and/or state_seqno is not NULL, will store final state\n   * in there.\n   *\n   * @param wsrep this  wsrep handler\n   */\n    wsrep_status_t (*disconnect)(wsrep_t* wsrep);\n\n  /*!\n   * @brief start receiving replication events\n   *\n   * This function never returns\n   *\n   * @param wsrep provider handle\n   * @param recv_ctx receiver context\n   */\n    wsrep_status_t (*recv)(wsrep_t* wsrep, void* recv_ctx);\n\n  /*!\n   * @brief Tells provider that a given writeset has a read view associated\n   *        with it.\n   *\n   * @param wsrep  provider handle\n   * @param handle writeset handle\n   * @param rv     read view GTID established by the caller or if NULL,\n   *               provider will infer it internally.\n   */\n    wsrep_status_t (*assign_read_view)(wsrep_t*            wsrep,\n                                       wsrep_ws_handle_t*  handle,\n                                       const wsrep_gtid_t* rv);\n\n  /*!\n   * @brief Certifies transaction with provider.\n   *\n   * Must be called before transaction commit. Returns success code, which\n   * caller must check.\n   *\n   * In case of WSREP_OK, transaction can proceed to commit.\n   * Otherwise transaction must rollback.\n   *\n   * In case of a failure there are two conceptually different situations:\n   * - the writeset was not ordered. In that case meta struct shall contain\n   *   undefined GTID: WSREP_UUID_UNDEFINED:WSREP_SEQNO_UNDEFINED.\n   * - the writeset was successfully ordered, but failed certification.\n   *   In this case meta struct shall contain a valid GTID.\n   *\n   * Regardless of the return code, if meta struct contains a valid GTID\n   * the commit order critical section must be entered with that GTID.\n   *\n   * @param wsrep      provider handle\n   * @param conn_id    connection ID\n   * @param ws_handle  writeset of committing transaction\n   * @param flags      fine tuning the replication WSREP_FLAG_*\n   * @param meta       transaction meta data\n   *\n   * @retval WSREP_OK         writeset successfully certified, can commit\n   * @retval WSREP_TRX_FAIL   must rollback transaction\n   * @retval WSREP_CONN_FAIL  must close client connection\n   * @retval WSREP_NODE_FAIL  must close all connections and reinit\n   */\n    wsrep_status_t (*certify)(wsrep_t*                wsrep,\n                              wsrep_conn_id_t         conn_id,\n                              wsrep_ws_handle_t*      ws_handle,\n                              uint32_t                flags,\n                              wsrep_trx_meta_t*       meta);\n\n  /*!\n   * @brief Enters commit order critical section.\n   *\n   * Anything executed between this call and commit_order_leave() will be\n   * executed in provider enforced order.\n   *\n   * @param wsrep      provider handle\n   * @param ws_handle  internal provider writeset handle\n   * @param meta       transaction meta data\n   *\n   * @retval WSREP_OK         commit order entered successfully\n   * @retval WSREP_NODE_FAIL  must close all connections and reinit\n   */\n    wsrep_status_t (*commit_order_enter)(wsrep_t*                 wsrep,\n                                         const wsrep_ws_handle_t* ws_handle,\n                                         const wsrep_trx_meta_t*  meta);\n\n  /*!\n   * @brief Leaves commit order critical section\n   *\n   * Anything executed between commit_order_enter() and this call will be\n   * executed in provider enforced order.\n   *\n   * @param wsrep      provider handle\n   * @param ws_handle  internal provider writeset handle\n   * @param meta       transaction meta data\n   * @param error      buffer containing error info (null/empty for no error)\n   *\n   * @retval WSREP_OK         commit order left successfully\n   * @retval WSREP_NODE_FAIL  must close all connections and reinit\n   */\n    wsrep_status_t (*commit_order_leave)(wsrep_t*                 wsrep,\n                                         const wsrep_ws_handle_t* ws_handle,\n                                         const wsrep_trx_meta_t*  meta,\n                                         const wsrep_buf_t*       error);\n\n  /*!\n   * @brief Releases resources after transaction commit/rollback.\n   *\n   * Ends total order critical section.\n   *\n   * @param wsrep      provider handle\n   * @param ws_handle  writeset of committing transaction\n   * @retval WSREP_OK  release succeeded\n   */\n    wsrep_status_t (*release) (wsrep_t*            wsrep,\n                               wsrep_ws_handle_t*  ws_handle);\n\n  /*!\n   * @brief Replay trx as a slave writeset\n   *\n   * If local trx has been aborted by brute force, and it has already\n   * replicated before this abort, we must try if we can apply it as\n   * slave trx. Note that slave nodes see only trx writesets and certification\n   * test based on write set content can be different to DBMS lock conflicts.\n   *\n   * @param wsrep      provider handle\n   * @param ws_handle  writeset of committing transaction\n   * @param trx_ctx    transaction context\n   *\n   * @retval WSREP_OK         cluster commit succeeded\n   * @retval WSREP_TRX_FAIL   must rollback transaction\n   * @retval WSREP_BF_ABORT   brute force abort happened after trx replicated\n   *                          must rollback transaction and try to replay\n   * @retval WSREP_CONN_FAIL  must close client connection\n   * @retval WSREP_NODE_FAIL  must close all connections and reinit\n   */\n    wsrep_status_t (*replay_trx)(wsrep_t*                  wsrep,\n                                 const wsrep_ws_handle_t*  ws_handle,\n                                 void*                     trx_ctx);\n\n  /*!\n   * @brief Abort certify() call of another thread.\n   *\n   * It is possible, that some high-priority transaction needs to abort\n   * another transaction which is in certify() call waiting for resources.\n   *\n   * The kill routine checks that abort is not attempted against a transaction\n   * which is front of the caller (in total order).\n   *\n   * If the abort was successful, the victim sequence number is stored\n   * into location pointed by the victim_seqno.\n   *\n   * @param wsrep      provider handle\n   * @param bf_seqno   seqno of brute force trx, running this cancel\n   * @param victim_trx transaction to be aborted, and which is committing\n   * @param victim_seqno seqno of the victim transaction if assigned\n   *\n   * @retval WSREP_OK          abort succeeded\n   * @retval WSREP_NOT_ALLOWED the provider declined the abort request\n   * @retval WSREP_TRX_MISSING the victim_trx was missing\n   * @retval WSREP_WARNING     abort failed\n   */\n    wsrep_status_t (*abort_certification)(wsrep_t*       wsrep,\n                                          wsrep_seqno_t  bf_seqno,\n                                          wsrep_trx_id_t victim_trx,\n                                          wsrep_seqno_t* victim_seqno);\n\n  /*!\n   * @brief Send a rollback fragment on behalf of trx\n   *\n   * @param wsrep  provider handle\n   * @param trx    transaction to be rolled back\n   * @param data   data to append to the fragment\n   *\n   * @retval WSREP_OK rollback fragment sent successfully\n   */\n    wsrep_status_t (*rollback)(wsrep_t*           wsrep,\n                               wsrep_trx_id_t     trx,\n                               const wsrep_buf_t* data);\n\n  /*!\n   * @brief Appends a row reference to transaction writeset\n   *\n   * Both copy flag and key_type can be ignored by provider (key type\n   * interpreted as WSREP_KEY_EXCLUSIVE).\n   *\n   * @param wsrep      provider handle\n   * @param ws_handle  writeset handle\n   * @param keys       array of keys\n   * @param count      length of the array of keys\n   * @param type       type of the key\n   * @param copy       can be set to FALSE if keys persist through commit.\n   */\n    wsrep_status_t (*append_key)(wsrep_t*            wsrep,\n                                 wsrep_ws_handle_t*  ws_handle,\n                                 const wsrep_key_t*  keys,\n                                 size_t              count,\n                                 enum wsrep_key_type type,\n                                 wsrep_bool_t        copy);\n\n  /*!\n   * @brief Appends data to transaction writeset\n   *\n   * This method can be called any time before commit and it\n   * appends a number of data buffers to transaction writeset.\n   *\n   * Both copy and unordered flags can be ignored by provider.\n   *\n   * @param wsrep      provider handle\n   * @param ws_handle  writeset handle\n   * @param data       array of data buffers\n   * @param count      buffer count\n   * @param type       type of data\n   * @param copy       can be set to FALSE if data persists through commit.\n   */\n    wsrep_status_t (*append_data)(wsrep_t*             wsrep,\n                                  wsrep_ws_handle_t*   ws_handle,\n                                  const wsrep_buf_t*   data,\n                                  size_t               count,\n                                  enum wsrep_data_type type,\n                                  wsrep_bool_t         copy);\n\n  /*!\n   * @brief Blocks until the given GTID is committed\n   *\n   * This call will block the caller until the given GTID\n   * is guaranteed to be committed, or until a timeout occurs.\n   * The timeout value is given in parameter tout, if tout is -1,\n   * then the global causal read timeout applies.\n   *\n   * If no pointer upto is provided the call will block until\n   * causal ordering with all possible preceding writes in the\n   * cluster is guaranteed.\n   *\n   * If pointer to gtid is non-null, the call stores the global\n   * transaction ID of the last transaction which is guaranteed\n   * to be committed when the call returns.\n   *\n   * @param wsrep  provider handle\n   * @param upto   gtid to wait upto\n   * @param tout   timeout in seconds\n   *               -1 wait for global causal read timeout\n   * @param gtid   location to store GTID\n   */\n    wsrep_status_t (*sync_wait)(wsrep_t*      wsrep,\n                                wsrep_gtid_t* upto,\n                                int           tout,\n                                wsrep_gtid_t* gtid);\n\n  /*!\n   * @brief Returns the last committed gtid\n   *\n   * @param gtid location to store GTID\n   */\n    wsrep_status_t (*last_committed_id)(wsrep_t*      wsrep,\n                                        wsrep_gtid_t* gtid);\n\n  /*!\n   * @brief Clears allocated connection context.\n   *\n   * Whenever a new connection ID is passed to wsrep provider through\n   * any of the API calls, a connection context is allocated for this\n   * connection. This call is to explicitly notify provider of connection\n   * closing.\n   *\n   * @param wsrep       provider handle\n   * @param conn_id     connection ID\n   * @param query       the 'set database' query\n   * @param query_len   length of query (does not end with 0)\n   */\n    wsrep_status_t (*free_connection)(wsrep_t*        wsrep,\n                                      wsrep_conn_id_t conn_id);\n\n  /*!\n   * @brief Replicates a query and starts \"total order isolation\" section.\n   *\n   * Regular mode:\n   *\n   * Replicates the action spec and returns success code, which caller must\n   * check. Total order isolation continues until to_execute_end() is called.\n   * Regular \"total order isolation\" is achieved by calling to_execute_start()\n   * with WSREP_FLAG_TRX_START and WSREP_FLAG_TRX_END set.\n   *\n   * Two-phase mode:\n   *\n   * In this mode a query execution is split in two phases. The first phase is\n   * acquiring total order isolation to access critical section and the\n   * second phase is to release acquired resources in total order.\n   *\n   * To start the first phase the call is made with WSREP_FLAG_TRX_START set.\n   * The action is replicated and success code is returned. The total order\n   * isolation continues until to_execute_end() is called. However, the provider\n   * will keep the reference to the operation for conflict resolution purposes.\n   *\n   * The second phase is started with WSREP_FLAG_TRX_END set. Provider\n   * returns once it has achieved total ordering isolation for second phase.\n   * Total order isolation continues until to_execute_end() is called.\n   * All references to the operation are cleared by provider before\n   * call to to_execute_end() returns.\n   *\n   * @param wsrep       provider handle\n   * @param conn_id     connection ID\n   * @param keys        array of keys\n   * @param keys_num    length of the array of keys\n   * @param action      action buffer array to be executed\n   * @param count       action buffer count\n   * @param flags       flags\n   * @param meta        transaction meta data\n   *\n   * @retval WSREP_OK         cluster commit succeeded\n   * @retval WSREP_CONN_FAIL  must close client connection\n   * @retval WSREP_NODE_FAIL  must close all connections and reinit\n   */\n    wsrep_status_t (*to_execute_start)(wsrep_t*           wsrep,\n                                       wsrep_conn_id_t    conn_id,\n                                       const wsrep_key_t* keys,\n                                       size_t             keys_num,\n                                       const wsrep_buf_t* action,\n                                       size_t             count,\n                                       uint32_t           flags,\n                                       wsrep_trx_meta_t*  meta);\n\n  /*!\n   * @brief Ends the total order isolation section.\n   *\n   * Marks the end of total order isolation. TO locks are freed\n   * and other transactions are free to commit from this point on.\n   *\n   * @param wsrep   provider handle\n   * @param conn_id connection ID\n   * @param error   error information about TOI operation (empty for no error)\n   *\n   * @retval WSREP_OK         cluster commit succeeded\n   * @retval WSREP_CONN_FAIL  must close client connection\n   * @retval WSREP_NODE_FAIL  must close all connections and reinit\n   */\n    wsrep_status_t (*to_execute_end)(wsrep_t*           wsrep,\n                                     wsrep_conn_id_t    conn_id,\n                                     const wsrep_buf_t* error);\n\n\n  /*!\n   * @brief Collects preordered replication events into a writeset.\n   *\n   * @param wsrep   wsrep provider handle\n   * @param handle  a handle associated with a given writeset\n   * @param data    an array of data buffers.\n   * @param count   length of data buffer array.\n   * @param copy    whether provider needs to make a copy of events.\n   *\n   * @retval WSREP_OK         cluster-wide commit succeeded\n   * @retval WSREP_TRX_FAIL   operation failed (e.g. trx size exceeded limit)\n   * @retval WSREP_NODE_FAIL  must close all connections and reinit\n   */\n    wsrep_status_t (*preordered_collect) (wsrep_t*           wsrep,\n                                          wsrep_po_handle_t* handle,\n                                          const wsrep_buf_t* data,\n                                          size_t             count,\n                                          wsrep_bool_t       copy);\n\n  /*!\n   * @brief \"Commits\" preordered writeset to cluster.\n   *\n   * The contract is that the writeset will be committed in the same (partial)\n   * order this method was called. Frees resources associated with the writeset\n   * handle and reinitializes the handle.\n   *\n   * @param wsrep     wsrep provider handle\n   * @param po_handle a handle associated with a given writeset\n   * @param source_id ID of the event producer, also serves as the partial order\n   *                  or stream ID - events with different source_ids won't be\n   *                  ordered with respect to each other.\n   * @param flags     WSREP_FLAG_... flags\n   * @param pa_range  the number of preceding events this event can be processed\n   *                  in parallel with. A value of 0 means strict serial\n   *                  processing. Note: commits always happen in wsrep order.\n   * @param commit    'true'  to commit writeset to cluster (replicate) or\n   *                  'false' to rollback (cancel) the writeset.\n   *\n   * @retval WSREP_OK         cluster-wide commit succeeded\n   * @retval WSREP_TRX_FAIL   operation failed (e.g. NON-PRIMARY component)\n   * @retval WSREP_NODE_FAIL  must close all connections and reinit\n   */\n    wsrep_status_t (*preordered_commit)  (wsrep_t*             wsrep,\n                                          wsrep_po_handle_t*   handle,\n                                          const wsrep_uuid_t*  source_id,\n                                          uint32_t             flags,\n                                          int                  pa_range,\n                                          wsrep_bool_t         commit);\n\n  /*!\n   * @brief Signals to wsrep provider that state snapshot has been sent to\n   *        joiner.\n   *\n   * @param wsrep    provider handle\n   * @param state_id state ID\n   * @param rcode    0 or negative error code of the operation.\n   */\n    wsrep_status_t (*sst_sent)(wsrep_t*            wsrep,\n                               const wsrep_gtid_t* state_id,\n                               int                 rcode);\n\n  /*!\n   * @brief Signals to wsrep provider that new state snapshot has been received.\n   *        May deadlock if called from sst_prepare_cb.\n   *\n   * @param wsrep     provider handle\n   * @param state_id  state ID\n   * @param state     initial state provided by SST donor\n   * @param rcode     0 or negative error code of the operation.\n   */\n    wsrep_status_t (*sst_received)(wsrep_t*            wsrep,\n                                   const wsrep_gtid_t* state_id,\n                                   const wsrep_buf_t*  state,\n                                   int                 rcode);\n\n\n  /*!\n   * @brief Generate request for consistent snapshot.\n   *\n   * If successful, this call will generate internally SST request\n   * which in turn triggers calling SST donate callback on the nodes\n   * specified in donor_spec. If donor_spec is null, callback is\n   * called only locally. This call will block until sst_sent is called\n   * from callback.\n   *\n   * @param wsrep      provider handle\n   * @param msg        context message for SST donate callback\n   * @param msg_len    length of context message\n   * @param donor_spec list of snapshot donors\n   */\n    wsrep_status_t (*snapshot)(wsrep_t*           wsrep,\n                               const wsrep_buf_t* msg,\n                               const char*        donor_spec);\n\n  /*!\n   * @brief Returns an array of status variables.\n   *        Array is terminated by Null variable name.\n   *\n   * @param wsrep provider handle\n   * @return array of struct wsrep_status_var.\n   */\n    struct wsrep_stats_var* (*stats_get) (wsrep_t* wsrep);\n\n  /*!\n   * @brief Release resources that might be associated with the array.\n   *\n   * @param wsrep     provider handle.\n   * @param var_array array returned by stats_get().\n   */\n    void (*stats_free) (wsrep_t* wsrep, struct wsrep_stats_var* var_array);\n\n  /*!\n   * @brief Reset some stats variables to inital value, provider-dependent.\n   *\n   * @param wsrep provider handle.\n   */\n    void (*stats_reset) (wsrep_t* wsrep);\n\n  /*!\n   * @brief Pauses writeset applying/committing.\n   *\n   * @return global sequence number of the paused state or negative error code.\n   */\n    wsrep_seqno_t (*pause) (wsrep_t* wsrep);\n\n  /*!\n   * @brief Resumes writeset applying/committing.\n   */\n    wsrep_status_t (*resume) (wsrep_t* wsrep);\n\n  /*!\n   * @brief Desynchronize from cluster\n   *\n   * Effectively turns off flow control for this node, allowing it\n   * to fall behind the cluster.\n   */\n    wsrep_status_t (*desync) (wsrep_t* wsrep);\n\n  /*!\n   * @brief Request to resynchronize with cluster.\n   *\n   * Effectively turns on flow control. Asynchronous - actual synchronization\n   * event to be delivered via sync_cb.\n   */\n    wsrep_status_t (*resync) (wsrep_t* wsrep);\n\n  /*!\n   * @brief Acquire global named lock\n   *\n   * @param wsrep  wsrep provider handle\n   * @param name   lock name\n   * @param shared shared or exclusive lock\n   * @param owner  64-bit owner ID\n   * @param tout   timeout in nanoseconds.\n   *               0 - return immediately, -1 wait forever.\n   * @return          wsrep status or negative error code\n   * @retval -EDEADLK lock was already acquired by this thread\n   * @retval -EBUSY   lock was busy\n   */\n    wsrep_status_t (*lock) (wsrep_t* wsrep,\n                            const char* name, wsrep_bool_t shared,\n                            uint64_t owner, int64_t tout);\n\n  /*!\n   * @brief Release global named lock\n   *\n   * @param wsrep   wsrep provider handle\n   * @param name    lock name\n   * @param owner   64-bit owner ID\n   * @return        wsrep status or negative error code\n   * @retval -EPERM lock does not belong to this owner\n   */\n    wsrep_status_t (*unlock) (wsrep_t* wsrep, const char* name, uint64_t owner);\n\n  /*!\n   * @brief Check if global named lock is locked\n   *\n   * @param wsrep wsrep provider handle\n   * @param name  lock name\n   * @param owner if not NULL will contain 64-bit owner ID\n   * @param node  if not NULL will contain owner's node UUID\n   * @return true if lock is locked\n   */\n    wsrep_bool_t (*is_locked) (wsrep_t* wsrep, const char* name, uint64_t* conn,\n                               wsrep_uuid_t* node);\n\n  /*!\n   * wsrep provider name\n   */\n    const char* provider_name;\n\n  /*!\n   * wsrep provider version\n   */\n    const char* provider_version;\n\n  /*!\n   * wsrep provider vendor name\n   */\n    const char* provider_vendor;\n\n  /*!\n   * @brief Frees allocated resources before unloading the library.\n   * @param wsrep provider handle\n   */\n    void (*free)(wsrep_t* wsrep);\n\n    void *dlh;    //!< reserved for future use\n    void *ctx;    //!< reserved for implementation private context\n};\n\n\n/*!\n *\n * @brief Loads wsrep library\n *\n * @param spec   path to wsrep library. If NULL or WSREP_NONE initializes dummy\n *               pass-through implementation.\n * @param hptr   wsrep handle\n * @param log_cb callback to handle loader messages. Otherwise writes to stderr.\n *\n * @return zero on success, errno on failure\n */\nint wsrep_load(const char* spec, wsrep_t** hptr, wsrep_log_cb_t log_cb);\n\n/*!\n * @brief Unloads wsrep library and frees associated resources\n *\n * @param hptr wsrep handler pointer\n */\nvoid wsrep_unload(wsrep_t* hptr);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* WSREP_H */\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/spider/mysql-test/spider/bugfix/r/cp932_column.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/spider/mysql-test/spider/bugfix/t/cp932_column.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/rocksdb/rocksdb/WINDOWS_PORT.md",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/rocksdb/rocksdb/docs/static/favicon.png",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/rocksdb/rocksdb/docs/static/og_image.png",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/rocksdb/rocksdb/docs/static/images/pcache-filelayout.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/rocksdb/rocksdb/docs/static/images/pcache-blockindex.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/rocksdb/rocksdb/docs/static/images/pcache-readiopath.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/rocksdb/rocksdb/docs/static/images/Resize-of-20140327_200754-300x225.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/rocksdb/rocksdb/docs/static/images/pcache-writeiopath.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/rocksdb/rocksdb/docs/static/images/pcache-fileindex.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/rocksdb/rocksdb/docs/static/images/pcache-tieredstorage.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/rocksdb/rocksdb/docs/static/images/tree_example1.png",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/rocksdb/rocksdb/docs/static/images/binaryseek.png",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/rocksdb/rocksdb/docs/static/images/compaction/l0-l1-contend.png",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/rocksdb/rocksdb/docs/static/images/compaction/l1-l2-contend.png",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/rocksdb/rocksdb/docs/static/images/compaction/part-range-old.png",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/rocksdb/rocksdb/docs/static/images/compaction/full-range.png",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/rocksdb/rocksdb/docs/static/images/delrange/delrange_collapsed.png",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/rocksdb/rocksdb/docs/static/images/delrange/delrange_sst_blocks.png",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/rocksdb/rocksdb/docs/static/images/delrange/delrange_write_path.png",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/rocksdb/rocksdb/docs/static/images/delrange/delrange_key_schema.png",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/rocksdb/rocksdb/docs/static/images/delrange/delrange_uncollapsed.png",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/rocksdb/rocksdb/docs/static/images/data-block-hash-index/perf-cache-miss.png",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/rocksdb/rocksdb/docs/static/images/data-block-hash-index/hash-index-data-structure.png",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/rocksdb/rocksdb/docs/static/images/data-block-hash-index/block-format-binary-seek.png",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/rocksdb/rocksdb/docs/static/images/data-block-hash-index/block-format-hash-index.png",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/rocksdb/rocksdb/docs/static/images/data-block-hash-index/perf-throughput.png",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/rocksdb/rocksdb/docs/static/images/rate-limiter/write-KBps-series.png",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/rocksdb/rocksdb/docs/static/images/rate-limiter/write-KBps-cdf.png",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/rocksdb/rocksdb/docs/static/images/rate-limiter/auto-tuned-write-KBps-series.png",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/rocksdb/rocksdb/docs/static/fonts/LatoLatin-Regular.woff",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/rocksdb/rocksdb/docs/static/fonts/LatoLatin-Black.woff",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/rocksdb/rocksdb/docs/static/fonts/LatoLatin-BlackItalic.woff2",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/rocksdb/rocksdb/docs/static/fonts/LatoLatin-Regular.woff2",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/rocksdb/rocksdb/docs/static/fonts/LatoLatin-Italic.woff",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/rocksdb/rocksdb/docs/static/fonts/LatoLatin-Italic.woff2",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/rocksdb/rocksdb/docs/static/fonts/LatoLatin-Light.woff",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/rocksdb/rocksdb/docs/static/fonts/LatoLatin-BlackItalic.woff",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/rocksdb/rocksdb/docs/static/fonts/LatoLatin-Light.woff2",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/rocksdb/rocksdb/docs/static/fonts/LatoLatin-Black.woff2",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/mroonga/mysql-test/mroonga/storage/r/column_multibyte_cp932.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/mroonga/mysql-test/mroonga/storage/r/alter_table_enable_keys_fulltext_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/mroonga/mysql-test/mroonga/storage/r/function_snippet_eucjpms.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/mroonga/mysql-test/mroonga/storage/r/function_snippet_cp932.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/mroonga/mysql-test/mroonga/storage/r/optimization_order_limit_optimized_cp932.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/mroonga/mysql-test/mroonga/storage/r/fulltext_charset_eucjpms.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/mroonga/mysql-test/mroonga/storage/r/alter_table_disable_keys_fulltext_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/mroonga/mysql-test/mroonga/storage/r/fulltext_charset_cp932.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/mroonga/mysql-test/mroonga/storage/r/alter_table_add_column_multibyte_cp932.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/mroonga/mysql-test/mroonga/storage/t/alter_table_enable_keys_fulltext_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/mroonga/mysql-test/mroonga/storage/t/alter_table_disable_keys_fulltext_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/mroonga/mysql-test/mroonga/storage/t/optimization_order_limit_optimized_cp932.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/mroonga/mysql-test/mroonga/storage/t/column_multibyte_cp932.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/mroonga/mysql-test/mroonga/storage/t/fulltext_charset_cp932.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/mroonga/mysql-test/mroonga/storage/t/function_snippet_cp932.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/mroonga/mysql-test/mroonga/storage/t/function_snippet_eucjpms.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/mroonga/mysql-test/mroonga/storage/t/alter_table_add_column_multibyte_cp932.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/mroonga/mysql-test/mroonga/storage/t/fulltext_charset_eucjpms.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/mroonga/mysql-test/mroonga/wrapper/r/column_multibyte_cp932.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/mroonga/mysql-test/mroonga/wrapper/r/fulltext_charset_eucjpms.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/mroonga/mysql-test/mroonga/wrapper/r/fulltext_charset_cp932.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/mroonga/mysql-test/mroonga/wrapper/r/alter_table_add_column_multibyte_cp932.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/mroonga/mysql-test/mroonga/wrapper/t/column_multibyte_cp932.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/mroonga/mysql-test/mroonga/wrapper/t/fulltext_charset_cp932.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/mroonga/mysql-test/mroonga/wrapper/t/alter_table_add_column_multibyte_cp932.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/mroonga/mysql-test/mroonga/wrapper/t/fulltext_charset_eucjpms.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/mroonga/vendor/groonga/benchmark/fixtures/geo-select/format_2010.html",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/mroonga/vendor/groonga/benchmark/fixtures/geo-select/13_2010.CSV.xz",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/mroonga/vendor/groonga/examples/dictionary/html/css/smoothness/images/ui-icons_cd0a0a_256x240.png",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/mroonga/vendor/groonga/examples/dictionary/html/css/smoothness/images/ui-icons_2e83ff_256x240.png",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/mroonga/vendor/groonga/examples/dictionary/html/css/smoothness/images/ui-bg_glass_55_fbf9ee_1x400.png",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/mroonga/vendor/groonga/examples/dictionary/html/css/smoothness/images/ui-bg_glass_95_fef1ec_1x400.png",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/mroonga/vendor/groonga/examples/dictionary/html/css/smoothness/images/ui-icons_888888_256x240.png",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/mroonga/vendor/groonga/examples/dictionary/html/css/smoothness/images/ui-bg_highlight-soft_75_cccccc_1x100.png",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/mroonga/vendor/groonga/examples/dictionary/html/css/smoothness/images/ui-bg_glass_75_dadada_1x400.png",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/mroonga/vendor/groonga/examples/dictionary/html/css/smoothness/images/ui-bg_flat_0_aaaaaa_40x100.png",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/mroonga/vendor/groonga/examples/dictionary/html/css/smoothness/images/ui-bg_flat_75_ffffff_40x100.png",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/mroonga/vendor/groonga/examples/dictionary/html/css/smoothness/images/ui-icons_222222_256x240.png",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/mroonga/vendor/groonga/examples/dictionary/html/css/smoothness/images/ui-bg_glass_65_ffffff_1x400.png",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/mroonga/vendor/groonga/examples/dictionary/html/css/smoothness/images/ui-icons_454545_256x240.png",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/mroonga/vendor/groonga/examples/dictionary/html/css/smoothness/images/ui-bg_glass_75_e6e6e6_1x400.png",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/connect/frmsg2.h",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/connect/domdoc.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/connect/JavaWrappers.jar",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/connect/frmsg1.h",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/connect/frids.h",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/connect/frcas.h",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/connect/frmsg.h",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/connect/mysql-test/connect/std_data/cp1251.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/connect/mysql-test/connect/std_data/biblio.json",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/connect/mysql-test/connect/std_data/Mongo3.jar",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/connect/mysql-test/connect/std_data/mdev9949.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/connect/mysql-test/connect/std_data/JavaWrappers.jar",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/connect/mysql-test/connect/std_data/bib0.json",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/connect/mysql-test/connect/std_data/contacts.xls",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/connect/mysql-test/connect/std_data/JdbcMariaDB.jar",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/connect/mysql-test/connect/std_data/test.sqlite3",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/connect/mysql-test/connect/std_data/Testbal.dat",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/connect/mysql-test/connect/std_data/Mongo2.jar",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/connect/mysql-test/connect/std_data/latin1.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/connect/mysql-test/connect/std_data/nocs.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/connect/mysql-test/connect/r/xml_zip.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/connect/mysql-test/connect/r/jdbc_postgresql.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/connect/mysql-test/connect/r/json.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/connect/mysql-test/connect/r/xml2_zip.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/tokudb/PerconaFT/ft/tests/upgrade.data/upgrade-recovery-logs-28-clean/log000000000000.tokulog28",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/tokudb/PerconaFT/ft/tests/upgrade.data/upgrade-recovery-logs-25-dirty/log000000000000.tokulog25",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/tokudb/PerconaFT/ft/tests/upgrade.data/upgrade-recovery-logs-24-clean/log000000000000.tokulog24",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/tokudb/PerconaFT/ft/tests/upgrade.data/upgrade-recovery-logs-26-clean/log000000000000.tokulog26",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/tokudb/PerconaFT/ft/tests/upgrade.data/upgrade-recovery-logs-28-dirty/log000000000000.tokulog28",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/tokudb/PerconaFT/ft/tests/upgrade.data/upgrade-recovery-logs-25-clean/log000000000000.tokulog25",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/tokudb/PerconaFT/ft/tests/upgrade.data/upgrade-recovery-logs-26-dirty/log000000000000.tokulog26",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/tokudb/PerconaFT/ft/tests/upgrade.data/upgrade-recovery-logs-29-clean/log000000000000.tokulog29",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/tokudb/PerconaFT/ft/tests/upgrade.data/upgrade-recovery-logs-27-dirty/log000000000000.tokulog27",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/tokudb/PerconaFT/ft/tests/upgrade.data/upgrade-recovery-logs-27-clean/log000000000000.tokulog27",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/tokudb/PerconaFT/ft/tests/upgrade.data/upgrade-recovery-logs-29-dirty/log000000000000.tokulog29",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/tokudb/PerconaFT/ft/tests/upgrade.data/upgrade-recovery-logs-24-dirty/log000000000000.tokulog24",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/tokudb/mysql-test/tokudb_bugs/std_data/leak172_t2.data",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/tokudb/mysql-test/tokudb/r/type_set.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/tokudb/mysql-test/tokudb/r/ctype_collate.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/tokudb/mysql-test/tokudb/r/type_decimal.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/tokudb/mysql-test/tokudb/r/ctype_cp1250_ch.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/tokudb/mysql-test/tokudb/r/type_enum.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/tokudb/mysql-test/tokudb/t/type_set.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/tokudb/mysql-test/tokudb/t/ctype_collate.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/tokudb/mysql-test/tokudb/t/ctype_cp1250_ch.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/tokudb/mysql-test/tokudb/t/type_decimal.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/storage/tokudb/mysql-test/tokudb/t/type_enum.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/sql-bench/server-cfg.sh",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/sql-bench/crash-me.sh",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/sql-bench/limits/mysql-4.0.cfg",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/sql-bench/limits/mysql-4.1.cfg",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/sql-bench/Comments/postgres.benchmark",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/strings/string.doc",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/strings/ctype-latin1.c",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/strings/ctype-czech.c",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/tests/fork2_test.pl",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/tests/function.tst",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/tests/function.res",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/plugin/handler_socket/regtest/test_01_lib/test04.expected",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/win/packaging/WixUIDialogBmp.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/win/packaging/WixUIBannerBmp.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/win/upgrade_wizard/res/upgrade.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/wolfssl.rc",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/IDE/Renesas/cs+/Projects/t4_demo/README_jp.txt",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/cyassl/ctaocrypt/tfm.h",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/rsa3072.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/client-ecc-cert.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/server-cert.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/client-cert-ext.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/ca-key.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/server-ecc.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/test-degenerate.p7b",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/ecc-key.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/ca-cert-chain.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/ecc-keyPkcs8Enc.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/rsa2048.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/server-key.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/ca-cert.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/client-cert.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/server-ecc-rsa.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/server-ecc384-cert.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/ca-ecc-key.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/server-ecc-self.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/server-keyPkcs8Enc.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/dsa3072.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/ecc-rsa-server.p12",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/ecc-privkeyPkcs8.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/ecc-keyPub.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/dh2048.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/ecc-keyPkcs8.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/ca-ecc384-cert.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/ntru-key.raw",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/client-key.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/dh3072.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/server-keyPkcs8.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/server-ecc384-key.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/server-cert-chain.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/client-ecc384-key.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/dsa2048.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/test-ber-exp02-05-2022.p7b",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/ca-ecc384-key.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/ecc-client-key.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/ecc-client-keyPub.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/test-servercert.p12",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/ca-ecc-cert.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/server-ecc-comp.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/client-keyPub.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/client-ecc384-cert.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/intermediate/server-int-ecc-cert.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/intermediate/ca-int-key.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/intermediate/client-chain.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/intermediate/ca-int-cert.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/intermediate/client-int-ecc-cert.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/intermediate/ca-int-ecc-cert.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/intermediate/ca-int-ecc-key.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/intermediate/client-int-cert.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/intermediate/client-chain-ecc.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/intermediate/server-chain-ecc.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/intermediate/server-int-cert.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/intermediate/server-chain.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/1024/server-cert.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/1024/ca-key.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/1024/server-key.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/1024/ca-cert.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/1024/client-cert.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/1024/dsa1024.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/1024/rsa1024.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/1024/client-key.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/1024/dh1024.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/1024/client-keyPub.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/ed25519/server-ed25519-key.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/ed25519/ca-ed25519.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/ed25519/ca-ed25519-priv.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/ed25519/root-ed25519-priv.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/ed25519/ca-ed25519-key.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/ed25519/server-ed25519.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/ed25519/root-ed25519.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/ed25519/client-ed25519.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/ed25519/client-ed25519-priv.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/ed25519/client-ed25519-key.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/ed25519/server-ed25519-priv.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/ed25519/root-ed25519-key.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/test/server-badaltnull.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/test/server-badcnnull.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/test/server-goodaltwild.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/test/cert-ext-ia.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/test/server-goodalt.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/test/cert-ext-ns.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/test/dh1024.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/test/server-goodcnwild.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/test/server-cert-rsa-badsig.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/test/server-cert-ecc-badsig.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/test/server-localhost.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/test/cert-ext-nc.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/test/server-badaltname.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/test/dh512.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/test/server-badcn.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/test/server-goodcn.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/test/server-garbage.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/test/expired/expired-cert.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/certs/test/expired/expired-ca.der",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/wolfcrypt/src/port/caam/caam_doc.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/scripts/testsuite.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/scripts/sniffer-ipv6.pcap",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/extra/wolfssl/wolfssl/doc/images/wolfssl_logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/debian/po/da.po",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/mdev17909#P#p20181029.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/bug37631.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/bug49823.CSM",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/corrupt-relay-bin.000624",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/host_old.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/mdev17909.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/binlog_before_20574.bin",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/mysql56datetime.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/old_table-323.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/bug49823.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/14897.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/loaddata6.dat",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/mdev17909#P#p20181128.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/mysql56timestamp.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/mdev11084.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/bug11747416_32228_binlog.000001",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/mdev-4645-binlog_group_id_checksum.binlog",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/binlog-header.binlog",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/cluster_7022_table.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/bug16266.000001",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/mariadb-5.5-binlog.000001",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/t917689.ARZ",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/mdev5029_1.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/long_table_name.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/vcol_autoinc.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/mysql56timestamp.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/mysql56time.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/bug47205.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/vcol_autoinc.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/mdev11084.part1.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/bug48265.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/master-bin.000001",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/bug47142_master-bin.000001",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/mysql56time.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/mdev5029_2.MAI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/bug46565.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/bug48633.ARZ",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/bad_row_type.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/bug47012.ARM",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/mdev-4645-binlog_checksum.binlog",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/bad_row_type.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/mdev-4645-binlog_group_id.binlog",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/mysql56time.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/mysql56datetime.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/bug19371.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/mdev5029_2.MAD",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/mdev11084.part1.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/mdev5029_2.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/corrupt_t1#P#p1.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/mysql57_virtual.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/bug48633.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/mdev6020-mysql-bin.000001",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/long_table_name.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/host_old.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/bug47012.ARZ",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/cluster_7022_table.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/bug48633.ARM",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/bug33029-slave-relay-bin.000001",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/binlog_savepoint.000001",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/mdev-4645-binlog_none.binlog",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/bug36055.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/trunc_binlog.000001",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/mysql57_virtual.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/mysql56timestamp.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/binlog_transaction.000001",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/bug47012.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/bug37631.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/mysql56datetime.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/corrupt_t1.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/bug36055.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/bug19371.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/bug40482-bin.000001",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/long_table_name.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/bug36055.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/bug19371.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/vchar.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/bug46565.ARZ",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/parts/t1_will_crash#P#p6_2.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/parts/t1_will_crash#P#p6_3.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/parts/t1TIMESTAMP.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/parts/t1_will_crash#P#p1_first_1024.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/parts/t1.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/parts/t1_will_crash#P#p2.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/parts/t1_blackhole.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/parts/t1_will_crash#P#p3.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/parts/t1_will_crash#P#p6.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/parts/t1_will_crash#P#p2.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/parts/t1_will_crash#P#p4.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/ctype_upgrade/maria050533_xxx_croatian_ci.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/ctype_upgrade/maria100004_xxx_croatian_ci.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/ctype_upgrade/mysql050614_xxx_croatian_ci.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/ctype_upgrade/maria050533_xxx_croatian_ci.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/ctype_upgrade/maria050313_utf8_croatian_ci.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/ctype_upgrade/maria050313_ucs2_croatian_ci_def.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/ctype_upgrade/maria050533_xxx_croatian_ci.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/ctype_upgrade/maria100004_xxx_croatian_ci.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/ctype_upgrade/mysql050614_xxx_croatian_ci.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/ctype_upgrade/maria100004_xxx_croatian_ci.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/ctype_upgrade/maria050313_utf8_croatian_ci.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/ctype_upgrade/maria050313_ucs2_croatian_ci_def.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/ctype_upgrade/maria050313_ucs2_croatian_ci_def.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/ctype_upgrade/maria050313_utf8_croatian_ci.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/ctype_upgrade/mysql050614_xxx_croatian_ci.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/mysql5613mysql/time_zone_leap_second.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/mysql5613mysql/user.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/mysql5613mysql/servers.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/mysql5613mysql/time_zone_transition_type.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/mysql5613mysql/time_zone_leap_second.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/mysql5613mysql/func.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/mysql5613mysql/proc.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/mysql5613mysql/proxies_priv.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/mysql5613mysql/time_zone_transition.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/mysql5613mysql/proc.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/mysql5613mysql/db.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/mysql5613mysql/db.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/mysql5613mysql/columns_priv.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/mysql5613mysql/event.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/mysql5613mysql/servers.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/mysql5613mysql/event.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/mysql5613mysql/user.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/mysql5613mysql/time_zone.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/mysql5613mysql/tables_priv.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/mysql5613mysql/plugin.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/mysql5613mysql/proxies_priv.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/mysql5613mysql/tables_priv.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/mysql5613mysql/func.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/mysql5613mysql/time_zone_name.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/mysql5613mysql/procs_priv.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/mysql5613mysql/time_zone_transition_type.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/mysql5613mysql/plugin.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/mysql5613mysql/time_zone_name.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/mysql5613mysql/procs_priv.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/mysql5613mysql/user.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/mysql5613mysql/db.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/mysql5613mysql/time_zone_transition.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/mysql5613mysql/proxies_priv.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/mysql5613mysql/time_zone.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/mysql5613mysql/columns_priv.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/temporal_upgrade/mysql050614_temporal1.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/temporal_upgrade/mysql050614_temporal0.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/temporal_upgrade/mysql050614_temporal0.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/temporal_upgrade/mysql050614_temporal0.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/temporal_upgrade/mysql050614_temporal1.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/vcol_upgrade/maria100226_char_to_vchar_virtual.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/vcol_upgrade/maria100226_char_to_vchar_virtual.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/vcol_upgrade/maria100226_char_to_vchar_stored.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/vcol_upgrade/maria100226_char_to_vchar_stored.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/vcol_upgrade/maria100226_char_to_vchar_virtual.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/vcol_upgrade/maria100226_char_to_vchar_stored.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/loaddata/mdev9842.txt",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/loaddata/mdev9823.utf8mb4.txt",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/loaddata/mdev9874.xml",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/loaddata/mdev8711.txt",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/loaddata/mdev9823.ujis.txt",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/loaddata/mdev-11079.txt",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/rpl/mysql-5.7.11-stm-temporal-round-binlog.000001",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/rpl/mysql-8.0.13-stm-temporal-round-binlog.000001",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/mysql_upgrade/event.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/mysql_upgrade/event.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/old_decimal/t1dec102.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/old_decimal/t1dec102.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/old_decimal/t1dec102.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/frm/t1.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/std_data/frm/mdev16518.frm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/type_set.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/ctype_big5.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/ctype_latin1.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/ctype_big5.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/alias.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/ctype_ucs.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/ctype_utf8.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/ctype_utf8mb4_innodb.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/sp.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/ctype_utf8mb4_heap.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/ctype_ucs.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/mysql_cp932.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/type_set.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/subselect2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/errors.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/show_check.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/cast.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/ctype_collate.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/fulltext.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/warnings.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/ctype_utf8mb4.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/mysqldump.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/subselect2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/show_explain.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/query_cache.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/sp.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/ctype_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/func_like.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/ctype_gbk.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/cast.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/ctype_latin1_de.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/warnings.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/ctype_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/query_cache.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/long_unique_bugs.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/func_json.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/errors.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/ctype_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/date_formats.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/ddl_i18n_koi8r.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/binary.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/mysqltest.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/events_bugs.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/binary.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/ctype_many.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/mysql_cp932.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/bug13633383.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/ctype_recoding.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/func_gconcat.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/alias.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/func_like.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/ctype_latin2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/rowid_order_innodb.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/fulltext.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/ctype_cp1251.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/ctype_latin1_de.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/events_1.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/func_test.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/type_decimal.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/explain.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/func_in.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/ctype_latin1.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/ctype_utf8mb4_myisam.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/ctype_collate.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/ctype_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/log_tables.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/ctype_utf8.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/func_in.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/ctype_utf8mb4.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/ctype_tis620.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/fulltext_left_join.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/func_test.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/ctype_recoding.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/explain.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/mysqldump.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/show_check.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/ctype_tis620.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/outfile_loaddata.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/ctype_cp1250_ch.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/ddl_i18n_koi8r.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/mysqltest.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/alter_table.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/events_bugs.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/ctype_cp932_binlog_stm.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/ctype_many.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/ctype_cp1250_ch.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/type_decimal.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/signal.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/default.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/default.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/ddl_i18n_utf8.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/alter_table.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/func_des_encrypt.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/log_tables.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/grant.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/type_enum.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/func_gconcat.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/ctype_cp1251.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/mysqlbinlog.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/show_explain.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/events_1.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/ctype_filesystem-master.opt",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/ddl_i18n_utf8.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/grant.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/main/type_enum.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/lib/My/SafeProcess/safe_kill_win.cc",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/include/ctype_E05C.inc",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/include/ctype_utf8mb4.inc",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/perfschema/r/misc.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/perfschema/r/statement_digest_charset.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/perfschema/t/statement_digest_charset.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/innodb_fts/r/fulltext.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/innodb_fts/t/fulltext.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/innodb_fts/t/fulltext_left_join.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/gcol/r/gcol_supported_sql_funcs_myisam.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/gcol/r/gcol_supported_sql_funcs_innodb.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/galera/r/query_cache.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/rpl/include/rpl_charset.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/rpl/include/rpl_row_annotate.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/rpl/r/rpl_row_annotate_do.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/rpl/r/rpl_row_annotate_dont.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/rpl/r/rpl_charset_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/rpl/r/rpl_charset.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/rpl/r/rpl_set_charset.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/rpl/r/rpl_parallel_charset.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/rpl/t/rpl_row_mysqlbinlog.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/rpl/t/rpl_set_charset.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/rpl/t/rpl_charset_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/rpl/t/rpl_temporary.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/rpl/t/rpl_parallel_charset.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/binlog/std_data/update-partial-row.binlog",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/binlog/std_data/write-full-row.binlog",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/binlog/std_data/ver_5_1-telco.001",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/binlog/std_data/ver_5_1_17.001",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/binlog/std_data/bug32407.001",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/binlog/std_data/write-partial-row.binlog",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/binlog/std_data/ver_trunk_row_v2.001",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/binlog/std_data/ver_5_1_23.001",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/binlog/std_data/update-full-row.binlog",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/binlog/std_data/binlog_old_version_4_1.000001",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/binlog/include/ctype_cp932.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/binlog/include/binlog_mysqlbinlog-cp932.inc",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/binlog/r/binlog_stm_ctype_cp932.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/binlog/r/binlog_row_ctype_cp932.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/binlog/r/binlog_mysqlbinlog_row_innodb.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/binlog/r/binlog_mysqlbinlog_row_myisam.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/binlog/r/binlog_mysqlbinlog_row.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/funcs_1/lib/DataGen_local.pl",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/funcs_1/r/memory_func_view.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/funcs_1/r/innodb_func_view.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/funcs_1/r/myisam_func_view.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/std_data/jisx0208_ucs2.dat",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/std_data/jisx0212_ucs2.dat",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/std_data/jisx0208_sjis2.dat",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/std_data/jisx0201_sjis.dat",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/std_data/jisx0208_ujis.dat",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/std_data/jisx0208_sjis.dat",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/std_data/jisx0208_sjis3.dat",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/std_data/jisx0201_ujis.dat",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/std_data/jisx0212_ujis.dat",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/std_data/jisx0201_ucs2.dat",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/include/trim_sjis.inc",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_rtrim_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_join_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_create_tbl_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_alter_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_join_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_create_db_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_trim_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_join_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_charset_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_create_tbl_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_ps_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_reverse_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_substring_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_insert_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_replace_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_replace_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_trim_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_substring_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_charlength_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_subquery_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_reverse_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_select_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_length_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_where_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_subquery_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_create_db_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_convert_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_insert_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_like_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_union_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_convert_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_right_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_trim_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_reverse_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_substring_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_subquery_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_update_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_alter_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_enum_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_like_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_replace_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_left_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_update_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_instr_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_alter_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_convert_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_length_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_ps_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_like_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_locate_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_charlength_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_rtrim_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_enum_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_right_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_create_db_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_enum_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_lpad_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_charlength_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_left_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_charset_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_rpad_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_left_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_locate_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_charset_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_lpad_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_ltrim_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_select_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_rtrim_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_select_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_where_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_lpad_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_create_tbl_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_update_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_locate_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_instr_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_where_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_rpad_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_instr_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_insert_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_ltrim_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_rpad_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_length_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_right_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/r/jp_ltrim_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_rpad_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_ps_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_left_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_alter_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_create_tbl_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_ps_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_charset_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_create_db_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_insert_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_join_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_enum_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_charlength_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_instr_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_update_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_substring_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_subquery_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_reverse_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_locate_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_create_tbl_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_locate_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_create_tbl_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_where_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_insert_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_join_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_union_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_instr_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_substring_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_subquery_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_convert_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_replace_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_like_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_left_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_select_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_enum_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_enum_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_join_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_length_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_insert_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_select_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_length_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_right_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_reverse_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_instr_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_alter_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_convert_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_subquery_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_charlength_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_rtrim_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_charset_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_convert_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_ltrim_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_like_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_where_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_lpad_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_create_db_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_lpad_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_rpad_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_like_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_right_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_locate_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_length_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_right_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_select_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_reverse_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_update_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_left_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_rtrim_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_charset_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_ltrim_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_rpad_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_rtrim_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_ltrim_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_trim_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_where_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_trim_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_replace_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_create_db_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_substring_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_lpad_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_charlength_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_replace_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_alter_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/jp/t/jp_update_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/maria/locking.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/maria/locking.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/encryption/t/filekeys-data.enc",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/mariabackup/filekeys-data.enc",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/engines/funcs/r/jp_comment_index.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/engines/funcs/r/jp_comment_column.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/engines/funcs/r/jp_comment_table.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/engines/funcs/r/jp_comment_older_compatibility1.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/engines/funcs/t/jp_comment_column.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/engines/funcs/t/jp_comment_older_compatibility1.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/engines/funcs/t/rpl_temporary.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/engines/funcs/t/jp_comment_index.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/engines/funcs/t/jp_comment_table.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/engines/iuds/r/strings_charsets_update_delete.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/engines/iuds/r/type_bit_iuds.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/json/r/json_no_table.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/sys_vars/r/sql_big_tables_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/sys_vars/r/collation_database_func.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/sys_vars/r/sql_log_bin_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/sys_vars/r/sql_quote_show_create_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/sys_vars/r/character_set_results_func.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/sys_vars/r/sql_warnings_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/sys_vars/r/collation_server_func.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/sys_vars/r/max_seeks_for_key_func.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/sys_vars/r/pseudo_slave_mode_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/sys_vars/r/sql_buffer_result_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/sys_vars/r/sql_big_selects_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/sys_vars/r/collation_connection_func.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/sys_vars/r/sql_low_priority_updates_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/sys_vars/r/innodb_table_locks_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/sys_vars/r/sql_notes_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/sys_vars/r/character_set_connection_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/sys_vars/r/character_set_client_func.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/sys_vars/r/query_cache_wlock_invalidate_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/sys_vars/r/character_set_client_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/sys_vars/r/sql_safe_updates_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/sys_vars/r/sql_log_off_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/sys_vars/r/foreign_key_checks_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/sys_vars/t/sql_log_bin_basic.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/sys_vars/t/sql_warnings_basic.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/sys_vars/t/sql_log_off_basic.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/sys_vars/t/sql_notes_basic.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/sys_vars/t/character_set_results_func.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/sys_vars/t/sql_buffer_result_basic.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/sys_vars/t/max_seeks_for_key_func.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/sys_vars/t/character_set_client_func.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/sys_vars/t/sql_safe_updates_basic.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/sys_vars/t/character_set_connection_basic.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/sys_vars/t/sql_big_selects_basic.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/sys_vars/t/collation_database_func.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/sys_vars/t/foreign_key_checks_basic.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/sys_vars/t/sql_quote_show_create_basic.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/sys_vars/t/innodb_table_locks_basic.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/sys_vars/t/collation_server_func.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/sys_vars/t/pseudo_slave_mode_basic.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/sys_vars/t/query_cache_wlock_invalidate_basic.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/sys_vars/t/collation_connection_func.test",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysql-test/suite/csv/csv.result",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/libmariadb/zlib/zlib.3.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/libmariadb/win/packaging/WixUIDialogBmp.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/libmariadb/win/packaging/WixUIBannerBmp.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/sql/MSG00001.bin",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/mysys/my_win_popen.cc",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/wsrep-lib/wsrep-API/v26/wsrep.xcf",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/libmysqld/libmysqld.rc",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/libmysqld/examples/builder-sample/emb_samples.dfm",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/libmysqld/examples/builder-sample/snapshot.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/libmysqld/examples/builder-sample/images/logo.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/libmysqld/examples/builder-sample/images/mysql.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/libmysqld/examples/builder-sample/images/db.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/libmysqld/examples/builder-sample/images/net.ico",
        "/tmp/vanessa/spack-stage/spack-stage-mariadb-10.4.12-hska6techf4f2aosldlmauwalfljnnt4/spack-src/libmysqld/examples/builder-sample/images/find.ico"
    ],
    "total_files": 27958
}