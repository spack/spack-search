{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-1806-jfy2xqqajla63otfimdjjjto2gmevqp7/spack-src/src/OSspecific/POSIX/POSIX.C": "/*---------------------------------------------------------------------------*\\\n  =========                 |\n  \\\\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox\n   \\\\    /   O peration     |\n    \\\\  /    A nd           | Copyright (C) 2011-2017 OpenFOAM Foundation\n     \\\\/     M anipulation  | Copyright (C) 2016-2018 OpenCFD Ltd.\n-------------------------------------------------------------------------------\nLicense\n    This file is part of OpenFOAM.\n\n    OpenFOAM is free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n    for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.\n\nDescription\n    POSIX versions of the functions declared in OSspecific.H\n\n\\*---------------------------------------------------------------------------*/\n\n#ifdef solarisGcc\n    #define _SYS_VNODE_H\n#endif\n\n#include \"OSspecific.H\"\n#include \"POSIX.H\"\n#include \"foamVersion.H\"\n#include \"fileName.H\"\n#include \"fileStat.H\"\n#include \"timer.H\"\n#include \"IFstream.H\"\n#include \"DynamicList.H\"\n#include \"CStringList.H\"\n#include \"SubList.H\"\n#include \"IOstreams.H\"\n#include \"Pstream.H\"\n\n#include <fstream>\n#include <cstdlib>\n#include <cctype>\n\n#include <stdio.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <pwd.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <dlfcn.h>\n\n#ifdef darwin\n    #include <mach-o/dyld.h>\n#else\n    #include <link.h>\n#endif\n\n\n// * * * * * * * * * * * * * * Static Data Members * * * * * * * * * * * * * //\n\nnamespace Foam\n{\n    defineTypeNameAndDebug(POSIX, 0);\n}\n\n\n// * * * * * * * * * * * * * * * Local Functions * * * * * * * * * * * * * * //\n\n// Like fileName \"/\" global operator, but retain any invalid characters\nstatic inline Foam::fileName fileNameConcat\n(\n    const std::string& a,\n    const std::string& b\n)\n{\n    if (a.size())\n    {\n        if (b.size())\n        {\n            // Two non-empty strings: can concatenate\n            return Foam::fileName((a + '/' + b), false);\n        }\n\n        return Foam::fileName(a, false);\n    }\n\n    // Or, if the first string is empty\n\n    if (b.size())\n    {\n        return Foam::fileName(b, false);\n    }\n\n    // Both strings are empty\n    return Foam::fileName();\n}\n\n\n// After a fork in system(), before the exec() do the following\n// - close stdin when executing in background (daemon-like)\n// - redirect stdout to stderr when infoDetailLevel == 0\nstatic inline void redirects(const bool bg)\n{\n    if (bg)\n    {\n        // Close stdin(0) - unchecked return value\n        (void) ::close(STDIN_FILENO);\n    }\n\n    // Redirect stdout(1) to stderr(2) '1>&2'\n    if (Foam::infoDetailLevel == 0)\n    {\n        // This is correct.  1>&2 means dup2(2, 1);\n        (void) ::dup2(STDERR_FILENO, STDOUT_FILENO);\n    }\n}\n\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //\n\npid_t Foam::pid()\n{\n    return ::getpid();\n}\n\n\npid_t Foam::ppid()\n{\n    return ::getppid();\n}\n\n\npid_t Foam::pgid()\n{\n    return ::getpgrp();\n}\n\n\nbool Foam::env(const std::string& envName)\n{\n    // An empty envName => always false\n    return !envName.empty() && ::getenv(envName.c_str()) != nullptr;\n}\n\n\nFoam::string Foam::getEnv(const std::string& envName)\n{\n    // Ignore an empty envName => always \"\"\n    char* env = envName.empty() ? nullptr : ::getenv(envName.c_str());\n\n    if (env)\n    {\n        return string(env);\n    }\n\n    // Return null-constructed string rather than string::null\n    // to avoid cyclic dependencies in the construction of globals\n    return string();\n}\n\n\nbool Foam::setEnv\n(\n    const word& envName,\n    const std::string& value,\n    const bool overwrite\n)\n{\n    // Ignore an empty envName => always false\n    return\n    (\n        !envName.empty()\n     && ::setenv(envName.c_str(), value.c_str(), overwrite) == 0\n    );\n}\n\n\nFoam::string Foam::hostName(bool full)\n{\n    char buf[128];\n    ::gethostname(buf, sizeof(buf));\n\n    // implementation as per hostname from net-tools\n    if (full)\n    {\n        struct hostent *hp = ::gethostbyname(buf);\n        if (hp)\n        {\n            return hp->h_name;\n        }\n    }\n\n    return buf;\n}\n\n\nFoam::string Foam::domainName()\n{\n    char buf[128];\n    ::gethostname(buf, sizeof(buf));\n\n    // implementation as per hostname from net-tools\n    struct hostent *hp = ::gethostbyname(buf);\n    if (hp)\n    {\n        char *p = ::strchr(hp->h_name, '.');\n        if (p)\n        {\n            ++p;\n            return p;\n        }\n    }\n\n    return string::null;\n}\n\n\nFoam::string Foam::userName()\n{\n    struct passwd* pw = ::getpwuid(::getuid());\n    if (pw != nullptr)\n    {\n        return pw->pw_name;\n    }\n\n    return string();\n}\n\n\nbool Foam::isAdministrator()\n{\n    return (::geteuid() == 0);\n}\n\n\nFoam::fileName Foam::home()\n{\n    char* env = ::getenv(\"HOME\");\n    if (env)\n    {\n        return fileName(env);\n    }\n\n    struct passwd* pw = ::getpwuid(::getuid());\n    if (pw)\n    {\n        return pw->pw_dir;\n    }\n\n    return fileName();\n}\n\n\nFoam::fileName Foam::home(const std::string& userName)\n{\n    // An empty userName => same as home()\n    if (userName.empty())\n    {\n        return Foam::home();\n    }\n\n    struct passwd* pw = ::getpwnam(userName.c_str());\n    if (pw)\n    {\n        return pw->pw_dir;\n    }\n\n    return fileName();\n}\n\n\nFoam::fileName Foam::cwd()\n{\n    label pathLengthLimit = POSIX::pathLengthChunk;\n    List<char> path(pathLengthLimit);\n\n    // Resize path if getcwd fails with an ERANGE error\n    while (pathLengthLimit == path.size())\n    {\n        if (::getcwd(path.data(), path.size()))\n        {\n            return path.data();\n        }\n        else if (errno == ERANGE)\n        {\n            // Increment path length up to the pathLengthMax limit\n            if\n            (\n                (pathLengthLimit += POSIX::pathLengthChunk)\n             >= POSIX::pathLengthMax\n            )\n            {\n                FatalErrorInFunction\n                    << \"Attempt to increase path length beyond limit of \"\n                    << POSIX::pathLengthMax\n                    << exit(FatalError);\n            }\n\n            path.setSize(pathLengthLimit);\n        }\n        else\n        {\n            break;\n        }\n    }\n\n    FatalErrorInFunction\n        << \"Couldn't get the current working directory\"\n        << exit(FatalError);\n\n    return fileName::null;\n}\n\n\nbool Foam::chDir(const fileName& dir)\n{\n    // Ignore an empty dir name => always false\n    return !dir.empty() && ::chdir(dir.c_str()) == 0;\n}\n\n\nbool Foam::mkDir(const fileName& pathName, mode_t mode)\n{\n    if (POSIX::debug)\n    {\n        Pout<< FUNCTION_NAME << \" : pathName:\" << pathName << \" mode:\" << mode\n            << endl;\n        if ((POSIX::debug & 2) && !Pstream::master())\n        {\n            error::printStack(Pout);\n        }\n    }\n\n    // empty names are meaningless\n    if (pathName.empty())\n    {\n        return false;\n    }\n\n    // Construct path directory if does not exist\n    if (::mkdir(pathName.c_str(), mode) == 0)\n    {\n        // Directory made OK so return true\n        return true;\n    }\n    else\n    {\n        switch (errno)\n        {\n            case EPERM:\n            {\n                FatalErrorInFunction\n                    << \"The filesystem containing \" << pathName\n                    << \" does not support the creation of directories.\"\n                    << exit(FatalError);\n\n                return false;\n            }\n\n            case EEXIST:\n            {\n                // Directory already exists so simply return true\n                return true;\n            }\n\n            case EFAULT:\n            {\n                FatalErrorInFunction\n                    << \"\" << pathName\n                    << \" points outside your accessible address space.\"\n                    << exit(FatalError);\n\n                return false;\n            }\n\n            case EACCES:\n            {\n                FatalErrorInFunction\n                    << \"The parent directory does not allow write \"\n                       \"permission to the process,\"<< nl\n                    << \"or one of the directories in \" << pathName\n                    << \" did not allow search (execute) permission.\"\n                    << exit(FatalError);\n\n                return false;\n            }\n\n            case ENAMETOOLONG:\n            {\n                FatalErrorInFunction\n                    << \"\" << pathName << \" is too long.\"\n                    << exit(FatalError);\n\n                return false;\n            }\n\n            case ENOENT:\n            {\n                // Part of the path does not exist so try to create it\n                if (pathName.path().size() && mkDir(pathName.path(), mode))\n                {\n                    return mkDir(pathName, mode);\n                }\n                else\n                {\n                    FatalErrorInFunction\n                        << \"Couldn't create directory \" << pathName\n                        << exit(FatalError);\n\n                    return false;\n                }\n            }\n\n            case ENOTDIR:\n            {\n                FatalErrorInFunction\n                    << \"A component used as a directory in \" << pathName\n                    << \" is not, in fact, a directory.\"\n                    << exit(FatalError);\n\n                return false;\n            }\n\n            case ENOMEM:\n            {\n                FatalErrorInFunction\n                    << \"Insufficient kernel memory was available to make \"\n                       \"directory \" << pathName << '.'\n                    << exit(FatalError);\n\n                return false;\n            }\n\n            case EROFS:\n            {\n                FatalErrorInFunction\n                    << \"\" << pathName\n                    << \" refers to a file on a read-only filesystem.\"\n                    << exit(FatalError);\n\n                return false;\n            }\n\n            case ELOOP:\n            {\n                FatalErrorInFunction\n                    << \"Too many symbolic links were encountered in resolving \"\n                    << pathName << '.'\n                    << exit(FatalError);\n\n                return false;\n            }\n\n            case ENOSPC:\n            {\n                FatalErrorInFunction\n                    << \"The device containing \" << pathName\n                    << \" has no room for the new directory or \"\n                    << \"the user's disk quota is exhausted.\"\n                    << exit(FatalError);\n\n                return false;\n            }\n\n            default:\n            {\n                FatalErrorInFunction\n                    << \"Couldn't create directory \" << pathName\n                    << exit(FatalError);\n\n                return false;\n            }\n        }\n    }\n}\n\n\nbool Foam::chMod(const fileName& name, const mode_t m)\n{\n    if (POSIX::debug)\n    {\n        Pout<< FUNCTION_NAME << \" : name:\" << name << endl;\n        if ((POSIX::debug & 2) && !Pstream::master())\n        {\n            error::printStack(Pout);\n        }\n    }\n\n    // Ignore an empty name => always false\n    return !name.empty() && ::chmod(name.c_str(), m) == 0;\n}\n\n\nmode_t Foam::mode(const fileName& name, const bool followLink)\n{\n    if (POSIX::debug)\n    {\n        Pout<< FUNCTION_NAME << \" : name:\" << name << endl;\n        if ((POSIX::debug & 2) && !Pstream::master())\n        {\n            error::printStack(Pout);\n        }\n    }\n\n    // Ignore an empty name => always 0\n    if (!name.empty())\n    {\n        fileStat fileStatus(name, followLink);\n        if (fileStatus.isValid())\n        {\n            return fileStatus.status().st_mode;\n        }\n    }\n\n    return 0;\n}\n\n\nFoam::fileName::Type Foam::type(const fileName& name, const bool followLink)\n{\n    // Ignore an empty name => always UNDEFINED\n    if (name.empty())\n    {\n        return fileName::UNDEFINED;\n    }\n\n    if (POSIX::debug)\n    {\n        Pout<< FUNCTION_NAME << \" : name:\" << name << endl;\n    }\n\n    mode_t m = mode(name, followLink);\n\n    if (S_ISREG(m))\n    {\n        return fileName::FILE;\n    }\n    else if (S_ISLNK(m))\n    {\n        return fileName::LINK;\n    }\n    else if (S_ISDIR(m))\n    {\n        return fileName::DIRECTORY;\n    }\n\n    return fileName::UNDEFINED;\n}\n\n\nbool Foam::exists\n(\n    const fileName& name,\n    const bool checkGzip,\n    const bool followLink\n)\n{\n    if (POSIX::debug)\n    {\n        Pout<< FUNCTION_NAME << \" : name:\" << name << \" checkGzip:\" << checkGzip\n            << endl;\n        if ((POSIX::debug & 2) && !Pstream::master())\n        {\n            error::printStack(Pout);\n        }\n    }\n\n    // Ignore an empty name => always false\n    return\n    (\n        !name.empty()\n     && (mode(name, followLink) || isFile(name, checkGzip, followLink))\n    );\n}\n\n\nbool Foam::isDir(const fileName& name, const bool followLink)\n{\n    if (POSIX::debug)\n    {\n        Pout<< FUNCTION_NAME << \" : name:\" << name << endl;\n        if ((POSIX::debug & 2) && !Pstream::master())\n        {\n            error::printStack(Pout);\n        }\n    }\n\n    // Ignore an empty name => always false\n    return !name.empty() && S_ISDIR(mode(name, followLink));\n}\n\n\nbool Foam::isFile\n(\n    const fileName& name,\n    const bool checkGzip,\n    const bool followLink\n)\n{\n    if (POSIX::debug)\n    {\n        Pout<< FUNCTION_NAME << \" : name:\" << name << \" checkGzip:\" << checkGzip\n            << endl;\n        if ((POSIX::debug & 2) && !Pstream::master())\n        {\n            error::printStack(Pout);\n        }\n    }\n\n    // Ignore an empty name => always false\n    return\n    (\n        !name.empty()\n     && (\n            S_ISREG(mode(name, followLink))\n         || (checkGzip && S_ISREG(mode(name + \".gz\", followLink)))\n        )\n    );\n}\n\n\noff_t Foam::fileSize(const fileName& name, const bool followLink)\n{\n    if (POSIX::debug)\n    {\n        Pout<< FUNCTION_NAME << \" : name:\" << name << endl;\n        if ((POSIX::debug & 2) && !Pstream::master())\n        {\n            error::printStack(Pout);\n        }\n    }\n\n    // Ignore an empty name\n    if (!name.empty())\n    {\n        fileStat fileStatus(name, followLink);\n        if (fileStatus.isValid())\n        {\n            return fileStatus.status().st_size;\n        }\n    }\n\n    return -1;\n}\n\n\ntime_t Foam::lastModified(const fileName& name, const bool followLink)\n{\n    if (POSIX::debug)\n    {\n        Pout<< FUNCTION_NAME << \" : name:\" << name << endl;\n        if ((POSIX::debug & 2) && !Pstream::master())\n        {\n            error::printStack(Pout);\n        }\n    }\n\n    // Ignore an empty name\n    return name.empty() ? 0 : fileStat(name, followLink).modTime();\n}\n\n\ndouble Foam::highResLastModified(const fileName& name, const bool followLink)\n{\n    if (POSIX::debug)\n    {\n        Pout<< FUNCTION_NAME << \" : name:\" << name << endl;\n        if ((POSIX::debug & 2) && !Pstream::master())\n        {\n            error::printStack(Pout);\n        }\n    }\n\n    // Ignore an empty name\n    return name.empty() ? 0 : fileStat(name, followLink).dmodTime();\n}\n\n\nFoam::fileNameList Foam::readDir\n(\n    const fileName& directory,\n    const fileName::Type type,\n    const bool filtergz,\n    const bool followLink\n)\n{\n    // Initial filename list size and the increment when resizing the list\n    static const int maxNnames = 100;\n\n    // Basic sanity: cannot strip '.gz' from directory names\n    const bool stripgz = filtergz && (type != fileName::DIRECTORY);\n    const word extgz(\"gz\");\n\n    fileNameList dirEntries;\n\n    // Open directory and set the structure pointer\n    // Do not attempt to open an empty directory name\n    DIR *source;\n    if\n    (\n        directory.empty()\n     || (source = ::opendir(directory.c_str())) == nullptr\n    )\n    {\n        if (POSIX::debug)\n        {\n            InfoInFunction\n                << \"cannot open directory \" << directory << endl;\n        }\n\n        return dirEntries;\n    }\n\n    if (POSIX::debug)\n    {\n        // InfoInFunction\n        Pout<< FUNCTION_NAME << \" : reading directory \" << directory << endl;\n        if ((POSIX::debug & 2) && !Pstream::master())\n        {\n            error::printStack(Pout);\n        }\n    }\n\n    label nFailed = 0;     // Entries with invalid characters\n    label nEntries = 0;    // Number of selected entries\n    dirEntries.setSize(maxNnames);\n\n    // Read and parse all the entries in the directory\n    for (struct dirent *list; (list = ::readdir(source)) != nullptr; /*nil*/)\n    {\n        const std::string item(list->d_name);\n\n        // Ignore files/directories beginning with \".\"\n        // These are the \".\", \"..\" directories and any hidden files/dirs\n        if (item.empty() || item[0] == '.')\n        {\n            continue;\n        }\n\n        // Validate filename without spaces, quotes, etc in the name.\n        // No duplicate slashes to strip - dirent will not have them anyhow.\n\n        const fileName name(fileName::validate(item));\n        if (name != item)\n        {\n            ++nFailed;\n        }\n        else if\n        (\n            (type == fileName::DIRECTORY)\n         || (type == fileName::FILE && !fileName::isBackup(name))\n        )\n        {\n            if ((directory/name).type(followLink) == type)\n            {\n                if (nEntries >= dirEntries.size())\n                {\n                    dirEntries.setSize(dirEntries.size() + maxNnames);\n                }\n\n                if (stripgz && name.hasExt(extgz))\n                {\n                    dirEntries[nEntries++] = name.lessExt();\n                }\n                else\n                {\n                    dirEntries[nEntries++] = name;\n                }\n            }\n        }\n    }\n    ::closedir(source);\n\n    // Finalize the length of the entries list\n    dirEntries.setSize(nEntries);\n\n    if (nFailed && POSIX::debug)\n    {\n        std::cerr\n            << \"Foam::readDir() : reading directory \" << directory << nl\n            << nFailed << \" entries with invalid characters in their name\"\n            << std::endl;\n    }\n\n    return dirEntries;\n}\n\n\nbool Foam::cp(const fileName& src, const fileName& dest, const bool followLink)\n{\n    if (POSIX::debug)\n    {\n        Pout<< FUNCTION_NAME << \" : src:\" << src << \" dest:\" << dest << endl;\n        if ((POSIX::debug & 2) && !Pstream::master())\n        {\n            error::printStack(Pout);\n        }\n    }\n\n    // Make sure source exists - this also handles an empty source name\n    if (!exists(src))\n    {\n        return false;\n    }\n\n    const fileName::Type srcType = src.type(followLink);\n\n    fileName destFile(dest);\n\n    // Check type of source file.\n    if (srcType == fileName::FILE)\n    {\n        // If dest is a directory, create the destination file name.\n        if (destFile.type() == fileName::DIRECTORY)\n        {\n            destFile = destFile/src.name();\n        }\n\n        // Make sure the destination directory exists.\n        if (!isDir(destFile.path()) && !mkDir(destFile.path()))\n        {\n            return false;\n        }\n\n        // Open and check streams.\n        std::ifstream srcStream(src);\n        if (!srcStream)\n        {\n            return false;\n        }\n\n        std::ofstream destStream(destFile);\n        if (!destStream)\n        {\n            return false;\n        }\n\n        // Copy character data.\n        char ch;\n        while (srcStream.get(ch))\n        {\n            destStream.put(ch);\n        }\n\n        // Final check.\n        if (!srcStream.eof() || !destStream)\n        {\n            return false;\n        }\n    }\n    else if (srcType == fileName::LINK)\n    {\n        // If dest is a directory, create the destination file name.\n        if (destFile.type() == fileName::DIRECTORY)\n        {\n            destFile = destFile/src.name();\n        }\n\n        // Make sure the destination directory exists.\n        if (!isDir(destFile.path()) && !mkDir(destFile.path()))\n        {\n            return false;\n        }\n\n        ln(src, destFile);\n    }\n    else if (srcType == fileName::DIRECTORY)\n    {\n        // If dest is a directory, create the destination file name.\n        if (destFile.type() == fileName::DIRECTORY)\n        {\n            destFile = destFile/src.components().last();\n        }\n\n        // Make sure the destination directory exists.\n        if (!isDir(destFile) && !mkDir(destFile))\n        {\n            return false;\n        }\n\n        char* realSrcPath = realpath(src.c_str(), nullptr);\n        char* realDestPath = realpath(destFile.c_str(), nullptr);\n        const bool samePath = strcmp(realSrcPath, realDestPath) == 0;\n\n        if (POSIX::debug && samePath)\n        {\n            InfoInFunction\n                << \"Attempt to copy \" << realSrcPath << \" to itself\" << endl;\n        }\n\n        if (realSrcPath)\n        {\n            free(realSrcPath);\n        }\n\n        if (realDestPath)\n        {\n            free(realDestPath);\n        }\n\n        // Do not copy over self when src is actually a link to dest\n        if (samePath)\n        {\n            return false;\n        }\n\n        // Copy files\n        fileNameList files = readDir(src, fileName::FILE, false, followLink);\n        for (const fileName& item : files)\n        {\n            if (POSIX::debug)\n            {\n                InfoInFunction\n                    << \"Copying : \" << src/item\n                    << \" to \" << destFile/item << endl;\n            }\n\n            // File to file.\n            cp(src/item, destFile/item, followLink);\n        }\n\n        // Copy sub directories.\n        fileNameList dirs = readDir\n        (\n            src,\n            fileName::DIRECTORY,\n            false,\n            followLink\n        );\n\n        for (const fileName& item : dirs)\n        {\n            if (POSIX::debug)\n            {\n                InfoInFunction\n                    << \"Copying : \" << src/item\n                    << \" to \" << destFile << endl;\n            }\n\n            // Dir to Dir.\n            cp(src/item, destFile, followLink);\n        }\n    }\n    else\n    {\n        return false;\n    }\n\n    return true;\n}\n\n\nbool Foam::ln(const fileName& src, const fileName& dst)\n{\n    if (POSIX::debug)\n    {\n        //InfoInFunction\n        Pout<< FUNCTION_NAME\n            << \" : Create softlink from : \" << src << \" to \" << dst << endl;\n        if ((POSIX::debug & 2) && !Pstream::master())\n        {\n            error::printStack(Pout);\n        }\n    }\n\n    if (src.empty())\n    {\n        WarningInFunction\n            << \"source name is empty: not linking.\" << endl;\n        return false;\n    }\n\n    if (dst.empty())\n    {\n        WarningInFunction\n            << \"destination name is empty: not linking.\" << endl;\n        return false;\n    }\n\n    if (exists(dst))\n    {\n        WarningInFunction\n            << \"destination \" << dst << \" already exists. Not linking.\"\n            << endl;\n        return false;\n    }\n\n    if (src.isAbsolute() && !exists(src))\n    {\n        WarningInFunction\n            << \"source \" << src << \" does not exist.\" << endl;\n        return false;\n    }\n\n    if (::symlink(src.c_str(), dst.c_str()) == 0)\n    {\n        return true;\n    }\n\n    WarningInFunction\n        << \"symlink from \" << src << \" to \" << dst << \" failed.\" << endl;\n    return false;\n}\n\n\nbool Foam::mv(const fileName& src, const fileName& dst, const bool followLink)\n{\n    if (POSIX::debug)\n    {\n        //InfoInFunction\n        Pout<< FUNCTION_NAME << \" : Move : \" << src << \" to \" << dst << endl;\n        if ((POSIX::debug & 2) && !Pstream::master())\n        {\n            error::printStack(Pout);\n        }\n    }\n\n    // Ignore an empty names => always false\n    if (src.empty() || dst.empty())\n    {\n        return false;\n    }\n\n    if\n    (\n        dst.type() == fileName::DIRECTORY\n     && src.type(followLink) != fileName::DIRECTORY\n    )\n    {\n        const fileName dstName(dst/src.name());\n\n        return ::rename(src.c_str(), dstName.c_str()) == 0;\n    }\n    else\n    {\n        return ::rename(src.c_str(), dst.c_str()) == 0;\n    }\n}\n\n\nbool Foam::mvBak(const fileName& src, const std::string& ext)\n{\n    if (POSIX::debug)\n    {\n        //InfoInFunction\n        Pout<< FUNCTION_NAME\n            << \" : moving : \" << src << \" to extension \" << ext << endl;\n        if ((POSIX::debug & 2) && !Pstream::master())\n        {\n            error::printStack(Pout);\n        }\n    }\n\n    // Ignore an empty name or extension => always false\n    if (src.empty() || ext.empty())\n    {\n        return false;\n    }\n\n    if (exists(src, false))\n    {\n        const int maxIndex = 99;\n        char index[3];\n\n        for (int n = 0; n <= maxIndex; ++n)\n        {\n            fileName dstName(src + \".\" + ext);\n            if (n)\n            {\n                ::sprintf(index, \"%02d\", n);\n                dstName += index;\n            }\n\n            // avoid overwriting existing files, except for the last\n            // possible index where we have no choice\n            if (!exists(dstName, false) || n == maxIndex)\n            {\n                return ::rename(src.c_str(), dstName.c_str()) == 0;\n            }\n        }\n    }\n\n    // fallthrough: nothing to do\n    return false;\n}\n\n\nbool Foam::rm(const fileName& file)\n{\n    if (POSIX::debug)\n    {\n        //InfoInFunction\n        Pout<< FUNCTION_NAME << \" : Removing : \" << file << endl;\n        if ((POSIX::debug & 2) && !Pstream::master())\n        {\n            error::printStack(Pout);\n        }\n    }\n\n    // Ignore an empty name => always false\n    if (file.empty())\n    {\n        return false;\n    }\n\n    // Try returning plain file name; if not there, try with .gz\n    if (::remove(file.c_str()) == 0)\n    {\n        return true;\n    }\n    else\n    {\n        return ::remove(string(file + \".gz\").c_str()) == 0;\n    }\n}\n\n\nbool Foam::rmDir(const fileName& directory, const bool silent)\n{\n    // Open directory and set the structure pointer\n    // Do not attempt to open an empty directory name\n    DIR *source;\n    if\n    (\n        directory.empty()\n     || (source = ::opendir(directory.c_str())) == nullptr\n    )\n    {\n        if (!silent)\n        {\n            WarningInFunction\n                << \"cannot open directory \" << directory << endl;\n        }\n\n        return false;\n    }\n\n    if (POSIX::debug)\n    {\n        //InfoInFunction\n        Pout<< FUNCTION_NAME << \" : removing directory \" << directory << endl;\n        if ((POSIX::debug & 2) && !Pstream::master())\n        {\n            error::printStack(Pout);\n        }\n    }\n\n    // Process each directory entry, counting any errors encountered\n    label nErrors = 0;\n    for (struct dirent *list; (list = ::readdir(source)) != nullptr; /*nil*/)\n    {\n        const std::string item(list->d_name);\n\n        // Ignore \".\" and \"..\" directories\n        if (item.empty() || item == \".\" || item == \"..\")\n        {\n            continue;\n        }\n\n        // Allow invalid characters (spaces, quotes, etc),\n        // otherwise we cannot subdirs with these types of names.\n        // -> const fileName path = directory/name; <-\n\n        const fileName path(fileNameConcat(directory, item));\n\n        if (path.type(false) == fileName::DIRECTORY)\n        {\n            if (!rmDir(path, true))  // Only report errors at the top-level\n            {\n                ++nErrors;\n            }\n        }\n        else\n        {\n            if (!rm(path))\n            {\n                ++nErrors;\n            }\n        }\n    }\n\n    if (nErrors)\n    {\n        if (!silent)\n        {\n            WarningInFunction\n                << \"failed to remove directory \" << directory << nl\n                << \"could not remove \" << nErrors << \" sub-entries\" << endl;\n        }\n    }\n    else\n    {\n        if (!rm(directory))\n        {\n            ++nErrors;\n            if (!silent)\n            {\n                WarningInFunction\n                    << \"failed to remove directory \" << directory << endl;\n            }\n        }\n    }\n\n    // clean up\n    ::closedir(source);\n    return !nErrors;\n}\n\n\nunsigned int Foam::sleep(const unsigned int sec)\n{\n    return ::sleep(sec);\n}\n\n\nvoid Foam::fdClose(const int fd)\n{\n    if (close(fd) != 0)\n    {\n        FatalErrorInFunction\n            << \"close error on \" << fd << endl\n            << abort(FatalError);\n    }\n}\n\n\nbool Foam::ping\n(\n    const std::string& destName,\n    const label destPort,\n    const label timeOut\n)\n{\n    struct hostent *hostPtr;\n    volatile int sockfd;\n    struct sockaddr_in destAddr;      // will hold the destination addr\n    u_int addr;\n\n    if ((hostPtr = ::gethostbyname(destName.c_str())) == nullptr)\n    {\n        FatalErrorInFunction\n            << \"gethostbyname error \" << h_errno << \" for host \" << destName\n            << abort(FatalError);\n    }\n\n    // Get first of the SLL of addresses\n    addr = (reinterpret_cast<struct in_addr*>(*(hostPtr->h_addr_list)))->s_addr;\n\n    // Allocate socket\n    sockfd = ::socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd < 0)\n    {\n        FatalErrorInFunction\n            << \"socket error\"\n            << abort(FatalError);\n    }\n\n    // Fill sockaddr_in structure with dest address and port\n    memset(reinterpret_cast<char *>(&destAddr), '\\0', sizeof(destAddr));\n    destAddr.sin_family = AF_INET;\n    destAddr.sin_port = htons(ushort(destPort));\n    destAddr.sin_addr.s_addr = addr;\n\n\n    timer myTimer(timeOut);\n\n    if (timedOut(myTimer))\n    {\n        // Setjmp from timer jumps back to here\n        fdClose(sockfd);\n        return false;\n    }\n\n    if\n    (\n        ::connect\n        (\n            sockfd,\n            reinterpret_cast<struct sockaddr*>(&destAddr),\n            sizeof(struct sockaddr)\n        ) != 0\n    )\n    {\n        // Connection refused. Check if network was actually used or not.\n\n        int connectErr = errno;\n\n        fdClose(sockfd);\n\n        if (connectErr == ECONNREFUSED)\n        {\n            return true;\n        }\n        //perror(\"connect\");\n\n        return false;\n    }\n\n    fdClose(sockfd);\n\n    return true;\n}\n\n\nbool Foam::ping(const std::string& host, const label timeOut)\n{\n    return ping(host, 222, timeOut) || ping(host, 22, timeOut);\n}\n\n\nnamespace Foam\n{\n//! \\cond fileScope\nstatic int waitpid(const pid_t pid)\n{\n    // child status, return code from the exec etc.\n    int status = 0;\n\n    // in parent - blocking wait\n    // modest treatment of signals (in child)\n    // treat 'stopped' like exit (suspend/continue)\n\n    while (true)\n    {\n        pid_t wpid = ::waitpid(pid, &status, WUNTRACED);\n\n        if (wpid == -1)\n        {\n            FatalErrorInFunction\n                << \"some error occurred in child\"\n                << exit(FatalError);\n            break;\n        }\n\n        if (WIFEXITED(status))\n        {\n            // child exited, get its return status\n            return WEXITSTATUS(status);\n        }\n\n        if (WIFSIGNALED(status))\n        {\n            // child terminated by some signal\n            return WTERMSIG(status);\n        }\n\n        if (WIFSTOPPED(status))\n        {\n            // child stopped by some signal\n            return WSTOPSIG(status);\n        }\n\n        FatalErrorInFunction\n            << \"programming error, status from waitpid() not handled: \"\n            << status\n            << exit(FatalError);\n    }\n\n    return -1;  // should not happen\n}\n//! \\endcond\n}\n\n\nint Foam::system(const std::string& command, const bool bg)\n{\n    if (command.empty())\n    {\n        // Treat an empty command as a successful no-op.\n        // From 'man sh' POSIX (man sh):\n        //   \"If the command_string operand is an empty string,\n        //    sh shall exit with a zero exit status.\"\n        return 0;\n    }\n\n    const pid_t child_pid = ::vfork();   // NB: vfork, not fork!\n\n    if (child_pid == -1)\n    {\n        FatalErrorInFunction\n            << \"vfork() failed for system command \" << command\n            << exit(FatalError);\n\n        return -1;  // fallback error value\n    }\n    else if (child_pid == 0)\n    {\n        // In child\n\n        // Close or redirect file descriptors\n        redirects(bg);\n\n        // execl uses the current environ\n        (void) ::execl\n        (\n            \"/bin/sh\",          // Path of the shell\n            \"sh\",               // Command-name (name for the shell)\n            \"-c\",               // Read commands from command_string operand\n            command.c_str(),    // Command string\n            reinterpret_cast<char*>(0)\n        );\n\n        // Obviously failed, since exec should not return\n        FatalErrorInFunction\n            << \"exec failed: \" << command\n            << exit(FatalError);\n\n        return -1;  // fallback error value\n    }\n\n\n    // In parent\n    // - started as background process, or blocking wait for the child\n\n    return (bg ? 0 : waitpid(child_pid));\n}\n\n\nint Foam::system(const CStringList& command, const bool bg)\n{\n    if (command.empty())\n    {\n        // Treat an empty command as a successful no-op.\n        // For consistency with POSIX (man sh) behaviour for (sh -c command),\n        // which is what is mostly being replicated here.\n        return 0;\n    }\n\n    // NB: use vfork, not fork!\n    // vfork behaves more like a thread and avoids copy-on-write problems\n    // triggered by fork.\n    // The normal system() command has a fork buried in it that causes\n    // issues with infiniband and openmpi etc.\n\n    const pid_t child_pid = ::vfork();\n\n    if (child_pid == -1)\n    {\n        FatalErrorInFunction\n            << \"vfork() failed for system command \" << command[0]\n            << exit(FatalError);\n\n        return -1;  // fallback error value\n    }\n    else if (child_pid == 0)\n    {\n        // In child\n\n        // Close or redirect file descriptors\n        redirects(bg);\n\n        // execvp searches the path, uses the current environ\n        (void) ::execvp(command[0], command.strings());\n\n        // Obviously failed, since exec should not return\n        FatalErrorInFunction\n            << \"exec(\" << command[0] << \", ...) failed\"\n            << exit(FatalError);\n\n        return -1;  // fallback error value\n    }\n\n\n    // In parent\n    // - started as background process, or blocking wait for the child\n\n    return (bg ? 0 : waitpid(child_pid));\n}\n\n\nint Foam::system(const Foam::UList<Foam::string>& command, const bool bg)\n{\n    if (command.empty())\n    {\n        // Treat an empty command as a successful no-op.\n        return 0;\n    }\n\n    // Make a deep copy as C-strings\n    const CStringList cmd(command);\n    return Foam::system(cmd, bg);\n}\n\n\nvoid* Foam::dlOpen(const fileName& lib, const bool check)\n{\n    if (POSIX::debug)\n    {\n        std::cout<< \"dlOpen(const fileName&)\"\n            << \" : dlopen of \" << lib << std::endl;\n    }\n    void* handle = ::dlopen(lib.c_str(), RTLD_LAZY|RTLD_GLOBAL);\n\n    #ifdef darwin\n    // Re-try \"libXX.so\" as \"libXX.dylib\"\n    if (!handle && lib.hasExt(\"so\"))\n    {\n        const fileName dylib(lib.lessExt().ext(\"dylib\"));\n        handle = ::dlopen(dylib.c_str(), RTLD_LAZY|RTLD_GLOBAL);\n    }\n    #endif\n\n    if (!handle && check)\n    {\n        WarningInFunction\n            << \"dlopen error : \" << ::dlerror()\n            << endl;\n    }\n\n    if (POSIX::debug)\n    {\n        std::cout\n            << \"dlOpen(const fileName&)\"\n            << \" : dlopen of \" << lib\n            << \" handle \" << handle << std::endl;\n    }\n\n    return handle;\n}\n\n\nbool Foam::dlClose(void* handle)\n{\n    if (POSIX::debug)\n    {\n        std::cout\n            << \"dlClose(void*)\"\n            << \" : dlclose of handle \" << handle << std::endl;\n    }\n    return ::dlclose(handle) == 0;\n}\n\n\nvoid* Foam::dlSym(void* handle, const std::string& symbol)\n{\n    if (POSIX::debug)\n    {\n        std::cout\n            << \"dlSym(void*, const std::string&)\"\n            << \" : dlsym of \" << symbol << std::endl;\n    }\n    // clear any old errors - see manpage dlopen\n    (void) ::dlerror();\n\n    // get address of symbol\n    void* fun = ::dlsym(handle, symbol.c_str());\n\n    // find error (if any)\n    char *error = ::dlerror();\n\n    if (error)\n    {\n        WarningInFunction\n            << \"Cannot lookup symbol \" << symbol << \" : \" << error\n            << endl;\n    }\n\n    return fun;\n}\n\n\nbool Foam::dlSymFound(void* handle, const std::string& symbol)\n{\n    if (handle && !symbol.empty())\n    {\n        if (POSIX::debug)\n        {\n            std::cout\n                << \"dlSymFound(void*, const std::string&)\"\n                << \" : dlsym of \" << symbol << std::endl;\n        }\n\n        // clear any old errors - see manpage dlopen\n        (void) ::dlerror();\n\n        // get address of symbol\n        (void) ::dlsym(handle, symbol.c_str());\n\n        // symbol can be found if there was no error\n        return !::dlerror();\n    }\n\n    return false;\n}\n\n\n#ifndef darwin\nstatic int collectLibsCallback\n(\n    struct dl_phdr_info *info,\n    size_t size,\n    void *data\n)\n{\n    Foam::DynamicList<Foam::fileName>* ptr =\n        reinterpret_cast<Foam::DynamicList<Foam::fileName>*>(data);\n    ptr->append(info->dlpi_name);\n    return 0;\n}\n#endif\n\n\nFoam::fileNameList Foam::dlLoaded()\n{\n    DynamicList<fileName> libs;\n    #ifdef darwin\n    for (uint32_t i=0; i < _dyld_image_count(); ++i)\n    {\n       libs.append(_dyld_get_image_name(i));\n    }\n    #else\n    dl_iterate_phdr(collectLibsCallback, &libs);\n    #endif\n\n    if (POSIX::debug)\n    {\n        std::cout\n            << \"dlLoaded()\"\n            << \" : determined loaded libraries :\" << libs.size() << std::endl;\n    }\n    return libs;\n}\n\n\n// ************************************************************************* //\n",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-1806-jfy2xqqajla63otfimdjjjto2gmevqp7/spack-src/src/OpenFOAM/include/OSspecific.H": "/*---------------------------------------------------------------------------*\\\n  =========                 |\n  \\\\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox\n   \\\\    /   O peration     |\n    \\\\  /    A nd           | Copyright (C) 2011-2017 OpenFOAM Foundation\n     \\\\/     M anipulation  | Copyright (C) 2016-2018 OpenCFD Ltd.\n-------------------------------------------------------------------------------\nLicense\n    This file is part of OpenFOAM.\n\n    OpenFOAM is free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n    for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.\n\nInNamespace\n    Foam\n\nDescription\n    Functions used by OpenFOAM that are specific to POSIX compliant\n    operating systems and need to be replaced or emulated on other systems.\n\nSourceFiles\n    POSIX.C\n\n\\*---------------------------------------------------------------------------*/\n\n#ifndef OSspecific_H\n#define OSspecific_H\n\n#include \"fileNameList.H\"\n#include \"stringList.H\"\n\n#include <sys/types.h>\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //\n\nnamespace Foam\n{\n\n// Forward declarations\nclass CStringList;\n\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //\n\n//- Return the PID of this process\npid_t pid();\n\n//- Return the parent PID of this process\npid_t ppid();\n\n//- Return the group PID of this process\npid_t pgid();\n\n//- True if environment variable of given name is defined.\n//  Using an empty name is a no-op and always returns false.\nbool env(const std::string& envName);\n\n//- Get environment value for given envName.\n//  Return string() if the environment is undefined or envName is empty.\nstring getEnv(const std::string& envName);\n\n//- Set an environment variable, return true on success.\n//  Using an empty name is a no-op and always returns false.\nbool setEnv(const word& name, const std::string& value, const bool overwrite);\n\n//- Return the system's host name, as per hostname(1)\n//  Optionally with the full name (as per the '-f' option)\nstring hostName(const bool full=false);\n\n//- Return the system's domain name, as per hostname(1) with the '-d' option\nstring domainName();\n\n//- Return the user's login name\nstring userName();\n\n//- Is the current user the administrator (root)\nbool isAdministrator();\n\n//- Return home directory path name for the current user\nfileName home();\n\n//- Return home directory path name for a particular user\nfileName home(const std::string& userName);\n\n//- Return current working directory path name\nfileName cwd();\n\n//- Change current directory to the one specified and return true on success.\n//  Using an empty name is a no-op and always returns false.\nbool chDir(const fileName& dir);\n\n//- Make a directory and return an error if it could not be created\n//  and does not already exist.\n//  Using an empty pathName is a no-op and always returns false.\nbool mkDir(const fileName& pathName, mode_t mode=0777);\n\n//- Set the file/directory mode, return true on success.\n//  Using an empty name is a no-op and always returns false.\nbool chMod(const fileName& name, const mode_t mode);\n\n//- Return the file mode, normally following symbolic links\n//  Using an empty name is a no-op and always returns 0.\nmode_t mode(const fileName& name, const bool followLink=true);\n\n//- Return the file type: DIRECTORY or FILE, normally following symbolic links\n//  Using an empty name is a no-op and always returns UNDEFINED.\nfileName::Type type(const fileName& name, const bool followLink=true);\n\n//- Does the name exist (as DIRECTORY or FILE) in the file system?\n//  Optionally enable/disable check for gzip file.\n//  Using an empty name is a no-op and always returns false.\nbool exists\n(\n    const fileName& name,\n    const bool checkGzip=true,\n    const bool followLink=true\n);\n\n//- Does the name exist as a DIRECTORY in the file system?\n//  Using an empty name is a no-op and always returns false.\nbool isDir(const fileName& name, const bool followLink=true);\n\n//- Does the name exist as a FILE in the file system?\n//  Optionally enable/disable check for gzip file.\n//  Using an empty name is a no-op and always returns false.\nbool isFile\n(\n    const fileName& name,\n    const bool checkGzip=true,\n    const bool followLink=true\n);\n\n//- Return size of file or -1 on failure (normally follows symbolic links).\n//  Using an empty name is a no-op and always returns -1.\noff_t fileSize(const fileName& name, const bool followLink=true);\n\n//- Return time of last file modification (normally follows symbolic links).\n//  Using an empty name is a no-op and always returns 0.\ntime_t lastModified(const fileName& name, const bool followLink=true);\n\n//- Return time of last file modification\n//  Using an empty name is a no-op and always returns 0.\ndouble highResLastModified(const fileName&, const bool followLink = true);\n\n//- Read a directory and return the entries as a fileName List.\n//  Using an empty directory name returns an empty list.\nfileNameList readDir\n(\n    const fileName& directory,\n    const fileName::Type type=fileName::FILE,\n    const bool filtergz=true,\n    const bool followLink=true\n);\n\n//- Copy the source to the destination (recursively if necessary).\n//  An empty source name is a no-op and always returns false.\nbool cp(const fileName& src, const fileName& dst, const bool followLink=true);\n\n//- Create a softlink. dst should not exist. Returns true if successful.\n//  An empty source or destination name is a no-op that always returns false,\n//  but also produces a warning.\nbool ln(const fileName& src, const fileName& dst);\n\n//- Rename src to dst.\n//  An empty source or destination name is a no-op that always returns false.\nbool mv\n(\n    const fileName& src,\n    const fileName& dst,\n    const bool followLink=false\n);\n\n//- Rename to a corresponding backup file\n//  If the backup file already exists, attempt with \"01\" .. \"99\" suffix\n//  An empty name or extension is a no-op that always returns false.\nbool mvBak(const fileName& src, const std::string& ext = \"bak\");\n\n//- Remove a file (or its gz equivalent), returning true if successful.\n//  An empty name is a no-op that always returns false.\nbool rm(const fileName& file);\n\n//- Remove a dirctory and its contents (optionally silencing warnings)\n//  An empty directory name is a no-op that always returns false,\n//  but also produces a warning.\nbool rmDir(const fileName& directory, const bool silent=false);\n\n//- Sleep for the specified number of seconds\nunsigned int sleep(const unsigned int sec);\n\n//- Close file descriptor\nvoid fdClose(const int fd);\n\n//- Check if machine is up by pinging given port\nbool ping(const std::string& destName, const label port, const label timeOut);\n\n//- Check if machine is up by pinging port 22 (ssh) and 222 (rsh)\nbool ping(const std::string& host, const label timeOut=10);\n\n//- Execute the specified command via the shell.\n//  Uses vfork/execl internally.\n//  When Foam::infoDetailLevel is zero, redirects stdout to stderr.\n//\n//  Where possible, use the list version instead.\n//\n//  \\param bg return immediately to parent process instead of waiting\n//      for the child. Can be used (with moderation) to create background\n//      processes.\n//\n//  \\note treats an empty command as a successful no-op.\n//      When Foam::infoDetailLevel is zero, redirects stdout to stderr.\nint system(const std::string& command, const bool bg = false);\n\n//- Execute the specified command with arguments.\n//  Uses vfork/execvp internally\n//  When Foam::infoDetailLevel is zero, redirects stdout to stderr.\n//\n//  \\param bg return immediately to parent process instead of waiting\n//      for the child. Can be used (with moderation) to create background\n//      processes.\n//\n//  \\note treats an empty command as a successful no-op.\nint system(const UList<string>& command, const bool bg = false);\n\n//- Execute the specified command with arguments.\n//  Uses vfork/execvp internally\n//  When Foam::infoDetailLevel is zero, redirects stdout to stderr.\n//\n//  \\param bg return immediately to parent process instead of waiting\n//      for the child. Can be used (with moderation) to create background\n//      processes.\n//\n//  \\note treats an empty command as a successful no-op.\nint system(const CStringList& command, const bool bg = false);\n\n//- Open a shared library and return handle to library.\n//  Print error message if library cannot be loaded (suppress with check=true)\nvoid* dlOpen(const fileName& lib, const bool check = true);\n\n//- Close a dlopened library using handle. Return true if successful\nbool dlClose(void* handle);\n\n//- Lookup a symbol in a dlopened library using handle to library\nvoid* dlSym(void* handle, const std::string& symbol);\n\n//- Report if symbol in a dlopened library could be found.\n//  Using a null handle or an empty symbol name is a no-op and always\n//  returns false.\nbool dlSymFound(void* handle, const std::string& symbol);\n\n//- Return all loaded libraries\nfileNameList dlLoaded();\n\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //\n\n} // End namespace Foam\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //\n\n#endif\n\n// ************************************************************************* //\n",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-1806-jfy2xqqajla63otfimdjjjto2gmevqp7/spack-src/src/OpenFOAM/db/dynamicLibrary/dynamicCode/dynamicCode.C": "/*---------------------------------------------------------------------------*\\\n  =========                 |\n  \\\\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox\n   \\\\    /   O peration     |\n    \\\\  /    A nd           | Copyright (C) 2011-2016 OpenFOAM Foundation\n     \\\\/     M anipulation  | Copyright (C) 2016-2018 OpenCFD Ltd.\n-------------------------------------------------------------------------------\nLicense\n    This file is part of OpenFOAM.\n\n    OpenFOAM is free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n    for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.\n\n\\*---------------------------------------------------------------------------*/\n\n#include \"dynamicCode.H\"\n#include \"dynamicCodeContext.H\"\n#include \"stringOps.H\"\n#include \"Fstream.H\"\n#include \"IOstreams.H\"\n#include \"OSspecific.H\"\n#include \"etcFiles.H\"\n#include \"dictionary.H\"\n\n// * * * * * * * * * * * * * * Static Data Members * * * * * * * * * * * * * //\n\nint Foam::dynamicCode::allowSystemOperations\n(\n    Foam::debug::infoSwitch(\"allowSystemOperations\", 0)\n);\n\n\nconst Foam::word Foam::dynamicCode::codeTemplateEnvName\n    = \"FOAM_CODE_TEMPLATES\";\n\nconst Foam::fileName Foam::dynamicCode::codeTemplateDirName\n    = \"codeTemplates/dynamicCode\";\n\nconst char* const Foam::dynamicCode::libTargetRoot =\n    \"LIB = $(PWD)/../platforms/$(WM_OPTIONS)/lib/lib\";\n\nconst char* const Foam::dynamicCode::topDirName = \"dynamicCode\";\n\n\n// * * * * * * * * * * * * * Static Member Functions * * * * * * * * * * * * //\n\nvoid Foam::dynamicCode::checkSecurity\n(\n    const char* title,\n    const dictionary& dict\n)\n{\n    if (isAdministrator())\n    {\n        FatalIOErrorInFunction(dict)\n            << \"This code should not be executed by someone with administrator\"\n            << \" rights due to security reasons.\" << nl\n            << \"(it writes a shared library which then gets loaded \"\n            << \"using dlopen)\"\n            << exit(FatalIOError);\n    }\n\n    if (!allowSystemOperations)\n    {\n        FatalIOErrorInFunction(dict)\n            << \"Loading a shared library using case-supplied code is not\"\n            << \" enabled by default\" << nl\n            << \"because of security issues. If you trust the code you can\"\n            << \" enable this\" << nl\n            << \"facility be adding to the InfoSwitches setting in the system\"\n            << \" controlDict:\" << nl << nl\n            << \"    allowSystemOperations 1\" << nl << nl\n            << \"The system controlDict is either\" << nl << nl\n            << \"    ~/.OpenFOAM/$WM_PROJECT_VERSION/controlDict\" << nl << nl\n            << \"or\" << nl << nl\n            << \"    $WM_PROJECT_DIR/etc/controlDict\" << nl\n            << endl\n            << exit(FatalIOError);\n    }\n}\n\n\nFoam::word Foam::dynamicCode::libraryBaseName(const fileName& libPath)\n{\n    word libName(libPath.nameLessExt());\n    libName.removeStart(\"lib\");  // Remove leading 'lib' from name\n    return libName;\n}\n\n\n// * * * * * * * * * * * * Protected Member Functions  * * * * * * * * * * * //\n\nvoid Foam::dynamicCode::copyAndFilter\n(\n    ISstream& is,\n    OSstream& os,\n    const HashTable<string>& mapping\n)\n{\n    if (!is.good())\n    {\n        FatalErrorInFunction\n            << \"Failed opening for reading \" << is.name()\n            << exit(FatalError);\n    }\n\n    if (!os.good())\n    {\n        FatalErrorInFunction\n            << \"Failed writing \" << os.name()\n            << exit(FatalError);\n    }\n\n    // Copy file while rewriting $VARS and ${VARS}\n    string line;\n    do\n    {\n        is.getLine(line);\n\n        // Expand according to mapping.\n        // Expanding according to env variables might cause too many\n        // surprises\n        stringOps::inplaceExpand(line, mapping);\n        os.writeQuoted(line, false) << nl;\n    }\n    while (is.good());\n}\n\n\nbool Foam::dynamicCode::resolveTemplates\n(\n    const UList<fileName>& templateNames,\n    DynamicList<fileName>& resolvedFiles,\n    DynamicList<fileName>& badFiles\n)\n{\n    // Try to get template from FOAM_CODESTREAM_TEMPLATES\n    const fileName templateDir(Foam::getEnv(codeTemplateEnvName));\n\n    bool allOkay = true;\n    forAll(templateNames, fileI)\n    {\n        const fileName& templateName = templateNames[fileI];\n\n        fileName file;\n        if (!templateDir.empty() && isDir(templateDir))\n        {\n            file = templateDir/templateName;\n            if (!isFile(file, false))\n            {\n                file.clear();\n            }\n        }\n\n        // Not found - fallback to ~OpenFOAM expansion\n        if (file.empty())\n        {\n            file = findEtcFile(codeTemplateDirName/templateName);\n        }\n\n        if (file.empty())\n        {\n            badFiles.append(templateName);\n            allOkay = false;\n        }\n        else\n        {\n            resolvedFiles.append(file);\n        }\n    }\n\n    return allOkay;\n}\n\n\nbool Foam::dynamicCode::writeCommentSHA1(Ostream& os) const\n{\n    const bool hasSHA1 = filterVars_.found(\"SHA1sum\");\n\n    if (hasSHA1)\n    {\n        os  << \"/* dynamicCode:\\n * SHA1 = \";\n        os.writeQuoted(filterVars_[\"SHA1sum\"], false) << \"\\n */\\n\";\n    }\n\n    return hasSHA1;\n}\n\n\nbool Foam::dynamicCode::createMakeFiles() const\n{\n    // Create Make/files\n    if (compileFiles_.empty())\n    {\n        return false;\n    }\n\n    const fileName dstFile(this->codePath()/\"Make/files\");\n\n    // Create dir\n    mkDir(dstFile.path());\n\n    OFstream os(dstFile);\n    //Debug: Info << \"Writing to \" << dstFile << endl;\n    if (!os.good())\n    {\n        FatalErrorInFunction\n            << \"Failed writing \" << dstFile\n            << exit(FatalError);\n    }\n\n    writeCommentSHA1(os);\n\n    // Write compile files\n    forAll(compileFiles_, fileI)\n    {\n        os.writeQuoted(compileFiles_[fileI], false) << nl;\n    }\n\n    os  << nl\n        << libTargetRoot << codeName_.c_str() << nl;\n\n    return true;\n}\n\n\nbool Foam::dynamicCode::createMakeOptions() const\n{\n    // Create Make/options\n    if (compileFiles_.empty() || makeOptions_.empty())\n    {\n        return false;\n    }\n\n    const fileName dstFile(this->codePath()/\"Make/options\");\n\n    // Create dir\n    mkDir(dstFile.path());\n\n    OFstream os(dstFile);\n    //Debug: Info<< \"Writing to \" << dstFile << endl;\n    if (!os.good())\n    {\n        FatalErrorInFunction\n            << \"Failed writing \" << dstFile\n            << exit(FatalError);\n    }\n\n    writeCommentSHA1(os);\n    os.writeQuoted(makeOptions_, false) << nl;\n\n    return true;\n}\n\n\nbool Foam::dynamicCode::writeDigest(const SHA1Digest& sha1) const\n{\n    const fileName file = digestFile();\n    mkDir(file.path());\n\n    OFstream os(file);\n    sha1.write(os, true) << nl;\n\n    return os.good();\n}\n\n\nbool Foam::dynamicCode::writeDigest(const std::string& sha1) const\n{\n    const fileName file = digestFile();\n    mkDir(file.path());\n\n    OFstream os(file);\n    os  << '_';\n    os.writeQuoted(sha1, false) << nl;\n\n    return os.good();\n}\n\n\n// * * * * * * * * * * * * * * * * Constructors  * * * * * * * * * * * * * * //\n\nFoam::dynamicCode::dynamicCode(const word& codeName, const word& codeDirName)\n:\n    codeRoot_(stringOps::expand(\"$FOAM_CASE\")/topDirName),\n    libSubDir_(stringOps::expand(\"platforms/$WM_OPTIONS/lib\")),\n    codeName_(codeName),\n    codeDirName_(codeDirName)\n{\n    if (codeDirName_.empty())\n    {\n        codeDirName_ = codeName_;\n    }\n\n    clear();\n}\n\n\n// * * * * * * * * * * * * * * * Member Functions  * * * * * * * * * * * * * //\n\nFoam::fileName Foam::dynamicCode::codeRelPath() const\n{\n    return topDirName/codeDirName_;\n}\n\n\nFoam::fileName Foam::dynamicCode::libRelPath() const\n{\n    #ifdef darwin\n    return codeRelPath()/libSubDir_/\"lib\" + codeName_ + \".dylib\";\n    #else\n    return codeRelPath()/libSubDir_/\"lib\" + codeName_ + \".so\";\n    #endif\n}\n\n\nvoid Foam::dynamicCode::clear()\n{\n    compileFiles_.clear();\n    copyFiles_.clear();\n    createFiles_.clear();\n    filterVars_.clear();\n    filterVars_.set(\"typeName\", codeName_);\n    filterVars_.set(\"SHA1sum\", SHA1Digest().str());\n\n    // Provide default Make/options\n    makeOptions_ =\n        \"EXE_INC = -g\\n\"\n        \"\\n\\nLIB_LIBS = \";\n}\n\n\nvoid Foam::dynamicCode::reset\n(\n    const dynamicCodeContext& context\n)\n{\n    clear();\n    setFilterContext(context);\n}\n\n\nvoid Foam::dynamicCode::addCompileFile(const fileName& name)\n{\n    compileFiles_.append(name);\n}\n\n\nvoid Foam::dynamicCode::addCopyFile(const fileName& name)\n{\n    copyFiles_.append(name);\n}\n\n\nvoid Foam::dynamicCode::addCreateFile\n(\n    const fileName& name,\n    const string& contents\n)\n{\n    createFiles_.append(fileAndContent(name, contents));\n}\n\n\nvoid Foam::dynamicCode::setFilterContext\n(\n    const dynamicCodeContext& context\n)\n{\n    filterVars_.set(\"localCode\", context.localCode());\n    filterVars_.set(\"code\", context.code());\n    filterVars_.set(\"codeInclude\", context.include());\n    filterVars_.set(\"SHA1sum\", context.sha1().str());\n}\n\n\nvoid Foam::dynamicCode::setFilterVariable\n(\n    const word& key,\n    const std::string& value\n)\n{\n    filterVars_.set(key, value);\n}\n\n\nvoid Foam::dynamicCode::setMakeOptions(const std::string& content)\n{\n    makeOptions_ = content;\n}\n\n\nbool Foam::dynamicCode::copyOrCreateFiles(const bool verbose) const\n{\n    if (verbose)\n    {\n        DetailInfo\n            << \"Creating new library in \" << this->libRelPath() << endl;\n    }\n\n    const label nFiles = compileFiles_.size() + copyFiles_.size();\n\n    DynamicList<fileName> resolvedFiles(nFiles);\n    DynamicList<fileName> badFiles(nFiles);\n\n    // Resolve template, or add to bad-files\n    resolveTemplates(compileFiles_, resolvedFiles, badFiles);\n    resolveTemplates(copyFiles_, resolvedFiles, badFiles);\n\n    if (!badFiles.empty())\n    {\n        FatalErrorInFunction\n            << \"Could not find the code template(s): \"\n            << badFiles << nl\n            << \"Under the $\" << codeTemplateEnvName\n            << \" directory or via via the ~OpenFOAM/\"\n            << codeTemplateDirName << \" expansion\"\n            << exit(FatalError);\n    }\n\n\n\n    // Create dir\n    const fileName outputDir = this->codePath();\n\n    // Create dir\n    mkDir(outputDir);\n\n    // Copy/filter files\n    forAll(resolvedFiles, fileI)\n    {\n        const fileName& srcFile = resolvedFiles[fileI];\n        const fileName  dstFile(outputDir/srcFile.name());\n\n        IFstream is(srcFile);\n        //Debug: Info<< \"Reading from \" << is.name() << endl;\n        if (!is.good())\n        {\n            FatalErrorInFunction\n                << \"Failed opening \" << srcFile\n                << exit(FatalError);\n        }\n\n        OFstream os(dstFile);\n        //Debug: Info<< \"Writing to \" << dstFile.name() << endl;\n        if (!os.good())\n        {\n            FatalErrorInFunction\n                << \"Failed writing \" << dstFile\n                << exit(FatalError);\n        }\n\n        // Copy lines while expanding variables\n        copyAndFilter(is, os, filterVars_);\n    }\n\n\n    // Create files:\n    forAll(createFiles_, fileI)\n    {\n        const fileName dstFile\n        (\n            outputDir/stringOps::expand(createFiles_[fileI].first())\n        );\n\n        mkDir(dstFile.path());\n        OFstream os(dstFile);\n        //Debug: Info<< \"Writing to \" << createFiles_[fileI].first() << endl;\n        if (!os.good())\n        {\n            FatalErrorInFunction\n                << \"Failed writing \" << dstFile\n                << exit(FatalError);\n        }\n        os.writeQuoted(createFiles_[fileI].second(), false) << nl;\n    }\n\n\n    // Create Make/files + Make/options\n    createMakeFiles();\n    createMakeOptions();\n\n    writeDigest(filterVars_[\"SHA1sum\"]);\n\n    return true;\n}\n\n\nbool Foam::dynamicCode::wmakeLibso() const\n{\n    stringList cmd({\"wmake\", \"-s\", \"libso\", this->codePath()});\n\n    // NOTE: could also resolve wmake command explicitly\n    //   cmd[0] = stringOps::expand(\"$WM_PROJECT_DIR/wmake/wmake\");\n\n    // This can take a bit longer, so report that we are starting wmake\n\n    if (Foam::infoDetailLevel > 0)\n    {\n        Info<< \"Invoking wmake libso \" << this->codePath().c_str() << endl;\n    }\n    else\n    {\n        // Even with details turned off, we want some feedback\n        Serr\n            << \"Invoking wmake libso \" << this->codePath().c_str() << endl;\n    }\n\n    if (Foam::system(cmd) == 0)\n    {\n        return true;\n    }\n\n    return false;\n}\n\n\nbool Foam::dynamicCode::upToDate(const SHA1Digest& sha1) const\n{\n    const fileName file = digestFile();\n\n    if (!exists(file, false) || SHA1Digest(IFstream(file)()) != sha1)\n    {\n        return false;\n    }\n\n    return true;\n}\n\n\nbool Foam::dynamicCode::upToDate(const dynamicCodeContext& context) const\n{\n    return upToDate(context.sha1());\n}\n\n\n// ************************************************************************* //\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-1806-jfy2xqqajla63otfimdjjjto2gmevqp7/spack-src/applications/utilities/mesh/conversion/kivaToFoam/kiva3v-valves.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-1806-jfy2xqqajla63otfimdjjjto2gmevqp7/spack-src/src/meshTools/momentOfInertia/volInt.ps.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-1806-jfy2xqqajla63otfimdjjjto2gmevqp7/spack-src/tutorials/incompressible/pimpleFoam/LES/channel395/0/p.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-1806-jfy2xqqajla63otfimdjjjto2gmevqp7/spack-src/tutorials/incompressible/pimpleFoam/LES/channel395/0/B.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-1806-jfy2xqqajla63otfimdjjjto2gmevqp7/spack-src/tutorials/incompressible/pimpleFoam/LES/channel395/0/nuTilda.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-1806-jfy2xqqajla63otfimdjjjto2gmevqp7/spack-src/tutorials/incompressible/pimpleFoam/LES/channel395/0/U.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-1806-jfy2xqqajla63otfimdjjjto2gmevqp7/spack-src/tutorials/incompressible/pimpleFoam/LES/channel395/0/nut.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-1806-jfy2xqqajla63otfimdjjjto2gmevqp7/spack-src/tutorials/incompressible/pimpleFoam/LES/channel395/0/k.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-1806-jfy2xqqajla63otfimdjjjto2gmevqp7/spack-src/tutorials/incompressible/simpleFoam/windAroundBuildings/constant/triSurface/buildings.obj.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-1806-jfy2xqqajla63otfimdjjjto2gmevqp7/spack-src/tutorials/incompressible/lumpedPointMotion/building/files/response.txt.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-1806-jfy2xqqajla63otfimdjjjto2gmevqp7/spack-src/tutorials/multiphase/driftFluxFoam/RAS/tank3D/constant/polyMesh/cells.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-1806-jfy2xqqajla63otfimdjjjto2gmevqp7/spack-src/tutorials/multiphase/driftFluxFoam/RAS/tank3D/constant/polyMesh/neighbour.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-1806-jfy2xqqajla63otfimdjjjto2gmevqp7/spack-src/tutorials/multiphase/driftFluxFoam/RAS/tank3D/constant/polyMesh/faces.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-1806-jfy2xqqajla63otfimdjjjto2gmevqp7/spack-src/tutorials/multiphase/driftFluxFoam/RAS/tank3D/constant/polyMesh/points.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-1806-jfy2xqqajla63otfimdjjjto2gmevqp7/spack-src/tutorials/multiphase/driftFluxFoam/RAS/tank3D/constant/polyMesh/owner.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-1806-jfy2xqqajla63otfimdjjjto2gmevqp7/spack-src/tutorials/resources/geometry/bullet.stl.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-1806-jfy2xqqajla63otfimdjjjto2gmevqp7/spack-src/tutorials/resources/geometry/propellerTip.obj.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-1806-jfy2xqqajla63otfimdjjjto2gmevqp7/spack-src/tutorials/resources/geometry/wigley-scaled-oriented.stl.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-1806-jfy2xqqajla63otfimdjjjto2gmevqp7/spack-src/tutorials/resources/geometry/motorBike-passenger-helmet.obj.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-1806-jfy2xqqajla63otfimdjjjto2gmevqp7/spack-src/tutorials/resources/geometry/membrane-membrane.stl.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-1806-jfy2xqqajla63otfimdjjjto2gmevqp7/spack-src/tutorials/resources/geometry/wigley.stl.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-1806-jfy2xqqajla63otfimdjjjto2gmevqp7/spack-src/tutorials/resources/geometry/DTC-scaled.stl.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-1806-jfy2xqqajla63otfimdjjjto2gmevqp7/spack-src/tutorials/resources/geometry/flange.stl.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-1806-jfy2xqqajla63otfimdjjjto2gmevqp7/spack-src/tutorials/resources/geometry/blob.stl.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-1806-jfy2xqqajla63otfimdjjjto2gmevqp7/spack-src/tutorials/resources/geometry/motorBike.obj.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-1806-jfy2xqqajla63otfimdjjjto2gmevqp7/spack-src/tutorials/resources/geometry/cyclone.stl.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-1806-jfy2xqqajla63otfimdjjjto2gmevqp7/spack-src/tutorials/resources/geometry/membrane-boundaries.stl.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-1806-jfy2xqqajla63otfimdjjjto2gmevqp7/spack-src/tutorials/resources/geometry/nacaAirfoil/nacaAirfoil.vrt.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-1806-jfy2xqqajla63otfimdjjjto2gmevqp7/spack-src/tutorials/resources/geometry/nacaAirfoil/nacaAirfoil.bnd.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-1806-jfy2xqqajla63otfimdjjjto2gmevqp7/spack-src/tutorials/resources/geometry/nacaAirfoil/nacaAirfoil.cel.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-1806-jfy2xqqajla63otfimdjjjto2gmevqp7/spack-src/tutorials/mesh/moveDynamicMesh/SnakeRiverCanyon/constant/triSurface/AcrossRiver.stl.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-1806-jfy2xqqajla63otfimdjjjto2gmevqp7/spack-src/tutorials/mesh/moveDynamicMesh/SnakeRiverCanyon/constant/triSurface/ACROSSCYN.JPG",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-1806-jfy2xqqajla63otfimdjjjto2gmevqp7/spack-src/doc/Doxygen/OpenFOAMlogo.png",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-1806-jfy2xqqajla63otfimdjjjto2gmevqp7/spack-src/modules/cfmesh/userGuide/User Guide - cfMesh v1.1.pdf"
    ],
    "total_files": 11471
}