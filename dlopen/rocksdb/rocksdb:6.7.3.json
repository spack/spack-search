{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.7.3-khbmb5qn57yoolwr4iwp4m6rv7ofvpit/spack-src/env/env_posix.cc": "//  Copyright (c) 2011-present, Facebook, Inc.  All rights reserved.\n//  This source code is licensed under both the GPLv2 (found in the\n//  COPYING file in the root directory) and Apache 2.0 License\n//  (found in the LICENSE.Apache file in the root directory).\n//\n// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file. See the AUTHORS file for names of contributors\n#include <dirent.h>\n#ifndef ROCKSDB_NO_DYNAMIC_EXTENSION\n#include <dlfcn.h>\n#endif\n#include <errno.h>\n#include <fcntl.h>\n\n#if defined(OS_LINUX)\n#include <linux/fs.h>\n#endif\n#if defined(ROCKSDB_IOURING_PRESENT)\n#include <liburing.h>\n#endif\n#include <pthread.h>\n#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/ioctl.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#if defined(OS_LINUX) || defined(OS_SOLARIS) || defined(OS_ANDROID)\n#include <sys/statfs.h>\n#include <sys/syscall.h>\n#include <sys/sysmacros.h>\n#endif\n#include <sys/statvfs.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#if defined(ROCKSDB_IOURING_PRESENT)\n#include <sys/uio.h>\n#endif\n#include <time.h>\n#include <algorithm>\n// Get nano time includes\n#if defined(OS_LINUX) || defined(OS_FREEBSD)\n#elif defined(__MACH__)\n#include <Availability.h>\n#include <mach/clock.h>\n#include <mach/mach.h>\n#else\n#include <chrono>\n#endif\n#include <deque>\n#include <set>\n#include <vector>\n\n#include \"env/composite_env_wrapper.h\"\n#include \"env/io_posix.h\"\n#include \"logging/logging.h\"\n#include \"logging/posix_logger.h\"\n#include \"monitoring/iostats_context_imp.h\"\n#include \"monitoring/thread_status_updater.h\"\n#include \"port/port.h\"\n#include \"rocksdb/options.h\"\n#include \"rocksdb/slice.h\"\n#include \"test_util/sync_point.h\"\n#include \"util/coding.h\"\n#include \"util/compression_context_cache.h\"\n#include \"util/random.h\"\n#include \"util/string_util.h\"\n#include \"util/thread_local.h\"\n#include \"util/threadpool_imp.h\"\n\n#if !defined(TMPFS_MAGIC)\n#define TMPFS_MAGIC 0x01021994\n#endif\n#if !defined(XFS_SUPER_MAGIC)\n#define XFS_SUPER_MAGIC 0x58465342\n#endif\n#if !defined(EXT4_SUPER_MAGIC)\n#define EXT4_SUPER_MAGIC 0xEF53\n#endif\n\nnamespace rocksdb {\n#if defined(OS_WIN)\nstatic const std::string kSharedLibExt = \".dll\";\nstatic const char kPathSeparator = ';';\n#else\nstatic const char kPathSeparator = ':';\n#if defined(OS_MACOSX)\nstatic const std::string kSharedLibExt = \".dylib\";\n#else\nstatic const std::string kSharedLibExt = \".so\";\n#endif\n#endif\n\nnamespace {\n\nThreadStatusUpdater* CreateThreadStatusUpdater() {\n  return new ThreadStatusUpdater();\n}\n\n#ifndef ROCKSDB_NO_DYNAMIC_EXTENSION\nclass PosixDynamicLibrary : public DynamicLibrary {\n public:\n  PosixDynamicLibrary(const std::string& name, void* handle)\n      : name_(name), handle_(handle) {}\n  ~PosixDynamicLibrary() override { dlclose(handle_); }\n\n  Status LoadSymbol(const std::string& sym_name, void** func) override {\n    assert(nullptr != func);\n    dlerror();  // Clear any old error\n    *func = dlsym(handle_, sym_name.c_str());\n    if (*func != nullptr) {\n      return Status::OK();\n    } else {\n      char* err = dlerror();\n      return Status::NotFound(\"Error finding symbol: \" + sym_name, err);\n    }\n  }\n\n  const char* Name() const override { return name_.c_str(); }\n\n private:\n  std::string name_;\n  void* handle_;\n};\n#endif  // !ROCKSDB_NO_DYNAMIC_EXTENSION\n\nclass PosixEnv : public CompositeEnvWrapper {\n public:\n  PosixEnv();\n\n  ~PosixEnv() override {\n    for (const auto tid : threads_to_join_) {\n      pthread_join(tid, nullptr);\n    }\n    for (int pool_id = 0; pool_id < Env::Priority::TOTAL; ++pool_id) {\n      thread_pools_[pool_id].JoinAllThreads();\n    }\n    // Delete the thread_status_updater_ only when the current Env is not\n    // Env::Default().  This is to avoid the free-after-use error when\n    // Env::Default() is destructed while some other child threads are\n    // still trying to update thread status.\n    if (this != Env::Default()) {\n      delete thread_status_updater_;\n    }\n  }\n\n  void SetFD_CLOEXEC(int fd, const EnvOptions* options) {\n    if ((options == nullptr || options->set_fd_cloexec) && fd > 0) {\n      fcntl(fd, F_SETFD, fcntl(fd, F_GETFD) | FD_CLOEXEC);\n    }\n  }\n\n#ifndef ROCKSDB_NO_DYNAMIC_EXTENSION\n  // Loads the named library into the result.\n  // If the input name is empty, the current executable is loaded\n  // On *nix systems, a \"lib\" prefix is added to the name if one is not supplied\n  // Comparably, the appropriate shared library extension is added to the name\n  // if not supplied. If search_path is not specified, the shared library will\n  // be loaded using the default path (LD_LIBRARY_PATH) If search_path is\n  // specified, the shared library will be searched for in the directories\n  // provided by the search path\n  Status LoadLibrary(const std::string& name, const std::string& path,\n                     std::shared_ptr<DynamicLibrary>* result) override {\n    Status status;\n    assert(result != nullptr);\n    if (name.empty()) {\n      void* hndl = dlopen(NULL, RTLD_NOW);\n      if (hndl != nullptr) {\n        result->reset(new PosixDynamicLibrary(name, hndl));\n        return Status::OK();\n      }\n    } else {\n      std::string library_name = name;\n      if (library_name.find(kSharedLibExt) == std::string::npos) {\n        library_name = library_name + kSharedLibExt;\n      }\n#if !defined(OS_WIN)\n      if (library_name.find('/') == std::string::npos &&\n          library_name.compare(0, 3, \"lib\") != 0) {\n        library_name = \"lib\" + library_name;\n      }\n#endif\n      if (path.empty()) {\n        void* hndl = dlopen(library_name.c_str(), RTLD_NOW);\n        if (hndl != nullptr) {\n          result->reset(new PosixDynamicLibrary(library_name, hndl));\n          return Status::OK();\n        }\n      } else {\n        std::string local_path;\n        std::stringstream ss(path);\n        while (getline(ss, local_path, kPathSeparator)) {\n          if (!path.empty()) {\n            std::string full_name = local_path + \"/\" + library_name;\n            void* hndl = dlopen(full_name.c_str(), RTLD_NOW);\n            if (hndl != nullptr) {\n              result->reset(new PosixDynamicLibrary(full_name, hndl));\n              return Status::OK();\n            }\n          }\n        }\n      }\n    }\n    return Status::IOError(\n        IOErrorMsg(\"Failed to open shared library: xs\", name), dlerror());\n  }\n#endif  // !ROCKSDB_NO_DYNAMIC_EXTENSION\n\n  void Schedule(void (*function)(void* arg1), void* arg, Priority pri = LOW,\n                void* tag = nullptr,\n                void (*unschedFunction)(void* arg) = nullptr) override;\n\n  int UnSchedule(void* arg, Priority pri) override;\n\n  void StartThread(void (*function)(void* arg), void* arg) override;\n\n  void WaitForJoin() override;\n\n  unsigned int GetThreadPoolQueueLen(Priority pri = LOW) const override;\n\n  Status GetTestDirectory(std::string* result) override {\n    const char* env = getenv(\"TEST_TMPDIR\");\n    if (env && env[0] != '\\0') {\n      *result = env;\n    } else {\n      char buf[100];\n      snprintf(buf, sizeof(buf), \"/tmp/rocksdbtest-%d\", int(geteuid()));\n      *result = buf;\n    }\n    // Directory may already exist\n    CreateDir(*result);\n    return Status::OK();\n  }\n\n  Status GetThreadList(std::vector<ThreadStatus>* thread_list) override {\n    assert(thread_status_updater_);\n    return thread_status_updater_->GetThreadList(thread_list);\n  }\n\n  static uint64_t gettid(pthread_t tid) {\n    uint64_t thread_id = 0;\n    memcpy(&thread_id, &tid, std::min(sizeof(thread_id), sizeof(tid)));\n    return thread_id;\n  }\n\n  static uint64_t gettid() {\n    pthread_t tid = pthread_self();\n    return gettid(tid);\n  }\n\n  uint64_t GetThreadID() const override { return gettid(pthread_self()); }\n\n  Status NewLogger(const std::string& fname,\n                   std::shared_ptr<Logger>* result) override {\n    FILE* f;\n    {\n      IOSTATS_TIMER_GUARD(open_nanos);\n      f = fopen(fname.c_str(),\n                \"w\"\n#ifdef __GLIBC_PREREQ\n#if __GLIBC_PREREQ(2, 7)\n                \"e\"  // glibc extension to enable O_CLOEXEC\n#endif\n#endif\n      );\n    }\n    if (f == nullptr) {\n      result->reset();\n      return IOError(\"when fopen a file for new logger\", fname, errno);\n    } else {\n      int fd = fileno(f);\n#ifdef ROCKSDB_FALLOCATE_PRESENT\n      fallocate(fd, FALLOC_FL_KEEP_SIZE, 0, 4 * 1024);\n#endif\n      SetFD_CLOEXEC(fd, nullptr);\n      result->reset(new PosixLogger(f, &PosixEnv::gettid, this));\n      return Status::OK();\n    }\n  }\n\n  uint64_t NowMicros() override {\n    struct timeval tv;\n    gettimeofday(&tv, nullptr);\n    return static_cast<uint64_t>(tv.tv_sec) * 1000000 + tv.tv_usec;\n  }\n\n  uint64_t NowNanos() override {\n#if defined(OS_LINUX) || defined(OS_FREEBSD) || defined(OS_AIX)\n    struct timespec ts;\n    clock_gettime(CLOCK_MONOTONIC, &ts);\n    return static_cast<uint64_t>(ts.tv_sec) * 1000000000 + ts.tv_nsec;\n#elif defined(OS_SOLARIS)\n    return gethrtime();\n#elif defined(__MACH__)\n    clock_serv_t cclock;\n    mach_timespec_t ts;\n    host_get_clock_service(mach_host_self(), CALENDAR_CLOCK, &cclock);\n    clock_get_time(cclock, &ts);\n    mach_port_deallocate(mach_task_self(), cclock);\n    return static_cast<uint64_t>(ts.tv_sec) * 1000000000 + ts.tv_nsec;\n#else\n    return std::chrono::duration_cast<std::chrono::nanoseconds>(\n       std::chrono::steady_clock::now().time_since_epoch()).count();\n#endif\n  }\n\n  uint64_t NowCPUNanos() override {\n#if defined(OS_LINUX) || defined(OS_FREEBSD) || defined(OS_AIX) || \\\n    (defined(__MACH__) && defined(__MAC_10_12))\n    struct timespec ts;\n    clock_gettime(CLOCK_THREAD_CPUTIME_ID, &ts);\n    return static_cast<uint64_t>(ts.tv_sec) * 1000000000 + ts.tv_nsec;\n#endif\n    return 0;\n  }\n\n  void SleepForMicroseconds(int micros) override { usleep(micros); }\n\n  Status GetHostName(char* name, uint64_t len) override {\n    int ret = gethostname(name, static_cast<size_t>(len));\n    if (ret < 0) {\n      if (errno == EFAULT || errno == EINVAL) {\n        return Status::InvalidArgument(strerror(errno));\n      } else {\n        return IOError(\"GetHostName\", name, errno);\n      }\n    }\n    return Status::OK();\n  }\n\n  Status GetCurrentTime(int64_t* unix_time) override {\n    time_t ret = time(nullptr);\n    if (ret == (time_t) -1) {\n      return IOError(\"GetCurrentTime\", \"\", errno);\n    }\n    *unix_time = (int64_t) ret;\n    return Status::OK();\n  }\n\n  ThreadStatusUpdater* GetThreadStatusUpdater() const override {\n    return Env::GetThreadStatusUpdater();\n  }\n\n  std::string GenerateUniqueId() override { return Env::GenerateUniqueId(); }\n\n  // Allow increasing the number of worker threads.\n  void SetBackgroundThreads(int num, Priority pri) override {\n    assert(pri >= Priority::BOTTOM && pri <= Priority::HIGH);\n    thread_pools_[pri].SetBackgroundThreads(num);\n  }\n\n  int GetBackgroundThreads(Priority pri) override {\n    assert(pri >= Priority::BOTTOM && pri <= Priority::HIGH);\n    return thread_pools_[pri].GetBackgroundThreads();\n  }\n\n  Status SetAllowNonOwnerAccess(bool allow_non_owner_access) override {\n    allow_non_owner_access_ = allow_non_owner_access;\n    return Status::OK();\n  }\n\n  // Allow increasing the number of worker threads.\n  void IncBackgroundThreadsIfNeeded(int num, Priority pri) override {\n    assert(pri >= Priority::BOTTOM && pri <= Priority::HIGH);\n    thread_pools_[pri].IncBackgroundThreadsIfNeeded(num);\n  }\n\n  void LowerThreadPoolIOPriority(Priority pool = LOW) override {\n    assert(pool >= Priority::BOTTOM && pool <= Priority::HIGH);\n#ifdef OS_LINUX\n    thread_pools_[pool].LowerIOPriority();\n#else\n    (void)pool;\n#endif\n  }\n\n  void LowerThreadPoolCPUPriority(Priority pool = LOW) override {\n    assert(pool >= Priority::BOTTOM && pool <= Priority::HIGH);\n#ifdef OS_LINUX\n    thread_pools_[pool].LowerCPUPriority();\n#else\n    (void)pool;\n#endif\n  }\n\n  std::string TimeToString(uint64_t secondsSince1970) override {\n    const time_t seconds = (time_t)secondsSince1970;\n    struct tm t;\n    int maxsize = 64;\n    std::string dummy;\n    dummy.reserve(maxsize);\n    dummy.resize(maxsize);\n    char* p = &dummy[0];\n    localtime_r(&seconds, &t);\n    snprintf(p, maxsize,\n             \"%04d/%02d/%02d-%02d:%02d:%02d \",\n             t.tm_year + 1900,\n             t.tm_mon + 1,\n             t.tm_mday,\n             t.tm_hour,\n             t.tm_min,\n             t.tm_sec);\n    return dummy;\n  }\n\n private:\n  std::vector<ThreadPoolImpl> thread_pools_;\n  pthread_mutex_t mu_;\n  std::vector<pthread_t> threads_to_join_;\n  // If true, allow non owner read access for db files. Otherwise, non-owner\n  //  has no access to db files.\n  bool allow_non_owner_access_;\n};\n\nPosixEnv::PosixEnv()\n    : CompositeEnvWrapper(this, FileSystem::Default().get()),\n      thread_pools_(Priority::TOTAL),\n      allow_non_owner_access_(true) {\n  ThreadPoolImpl::PthreadCall(\"mutex_init\", pthread_mutex_init(&mu_, nullptr));\n  for (int pool_id = 0; pool_id < Env::Priority::TOTAL; ++pool_id) {\n    thread_pools_[pool_id].SetThreadPriority(\n        static_cast<Env::Priority>(pool_id));\n    // This allows later initializing the thread-local-env of each thread.\n    thread_pools_[pool_id].SetHostEnv(this);\n  }\n  thread_status_updater_ = CreateThreadStatusUpdater();\n}\n\nvoid PosixEnv::Schedule(void (*function)(void* arg1), void* arg, Priority pri,\n                        void* tag, void (*unschedFunction)(void* arg)) {\n  assert(pri >= Priority::BOTTOM && pri <= Priority::HIGH);\n  thread_pools_[pri].Schedule(function, arg, tag, unschedFunction);\n}\n\nint PosixEnv::UnSchedule(void* arg, Priority pri) {\n  return thread_pools_[pri].UnSchedule(arg);\n}\n\nunsigned int PosixEnv::GetThreadPoolQueueLen(Priority pri) const {\n  assert(pri >= Priority::BOTTOM && pri <= Priority::HIGH);\n  return thread_pools_[pri].GetQueueLen();\n}\n\nstruct StartThreadState {\n  void (*user_function)(void*);\n  void* arg;\n};\n\nstatic void* StartThreadWrapper(void* arg) {\n  StartThreadState* state = reinterpret_cast<StartThreadState*>(arg);\n  state->user_function(state->arg);\n  delete state;\n  return nullptr;\n}\n\nvoid PosixEnv::StartThread(void (*function)(void* arg), void* arg) {\n  pthread_t t;\n  StartThreadState* state = new StartThreadState;\n  state->user_function = function;\n  state->arg = arg;\n  ThreadPoolImpl::PthreadCall(\n      \"start thread\", pthread_create(&t, nullptr, &StartThreadWrapper, state));\n  ThreadPoolImpl::PthreadCall(\"lock\", pthread_mutex_lock(&mu_));\n  threads_to_join_.push_back(t);\n  ThreadPoolImpl::PthreadCall(\"unlock\", pthread_mutex_unlock(&mu_));\n}\n\nvoid PosixEnv::WaitForJoin() {\n  for (const auto tid : threads_to_join_) {\n    pthread_join(tid, nullptr);\n  }\n  threads_to_join_.clear();\n}\n\n}  // namespace\n\nstd::string Env::GenerateUniqueId() {\n  std::string uuid_file = \"/proc/sys/kernel/random/uuid\";\n\n  Status s = FileExists(uuid_file);\n  if (s.ok()) {\n    std::string uuid;\n    s = ReadFileToString(this, uuid_file, &uuid);\n    if (s.ok()) {\n      return uuid;\n    }\n  }\n  // Could not read uuid_file - generate uuid using \"nanos-random\"\n  Random64 r(time(nullptr));\n  uint64_t random_uuid_portion =\n    r.Uniform(std::numeric_limits<uint64_t>::max());\n  uint64_t nanos_uuid_portion = NowNanos();\n  char uuid2[200];\n  snprintf(uuid2,\n           200,\n           \"%lx-%lx\",\n           (unsigned long)nanos_uuid_portion,\n           (unsigned long)random_uuid_portion);\n  return uuid2;\n}\n\n//\n// Default Posix Env\n//\nEnv* Env::Default() {\n  // The following function call initializes the singletons of ThreadLocalPtr\n  // right before the static default_env.  This guarantees default_env will\n  // always being destructed before the ThreadLocalPtr singletons get\n  // destructed as C++ guarantees that the destructions of static variables\n  // is in the reverse order of their constructions.\n  //\n  // Since static members are destructed in the reverse order\n  // of their construction, having this call here guarantees that\n  // the destructor of static PosixEnv will go first, then the\n  // the singletons of ThreadLocalPtr.\n  ThreadLocalPtr::InitSingletons();\n  CompressionContextCache::InitSingleton();\n  INIT_SYNC_POINT_SINGLETONS();\n  static PosixEnv default_env;\n  static CompositeEnvWrapper composite_env(&default_env,\n                                           FileSystem::Default().get());\n  return &composite_env;\n}\n\n}  // namespace rocksdb\n",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.7.3-khbmb5qn57yoolwr4iwp4m6rv7ofvpit/spack-src/port/jemalloc_helper.h": "//  Copyright (c) 2011-present, Facebook, Inc.  All rights reserved.\n//  This source code is licensed under both the GPLv2 (found in the\n//  COPYING file in the root directory) and Apache 2.0 License\n//  (found in the LICENSE.Apache file in the root directory).\n\n#pragma once\n\n#if defined(__clang__)\n// glibc's `posix_memalign()` declaration specifies `throw()` while clang's\n// declaration does not. There is a hack in clang to make its re-declaration\n// compatible with glibc's if they are declared consecutively. That hack breaks\n// if yet another `posix_memalign()` declaration comes between glibc's and\n// clang's declarations. Include \"mm_malloc.h\" here ensures glibc's and clang's\n// declarations both come before \"jemalloc.h\"'s `posix_memalign()` declaration.\n//\n// This problem could also be avoided if \"jemalloc.h\"'s `posix_memalign()`\n// declaration did not specify `throw()` when built with clang.\n#include <mm_malloc.h>\n#endif\n\n#ifdef ROCKSDB_JEMALLOC\n#ifdef __FreeBSD__\n#include <malloc_np.h>\n#else\n#define JEMALLOC_MANGLE\n#include <jemalloc/jemalloc.h>\n#endif\n\n#ifndef JEMALLOC_CXX_THROW\n#define JEMALLOC_CXX_THROW\n#endif\n\n#if defined(OS_WIN) && defined(_MSC_VER)\n\n// MSVC does not have weak symbol support. As long as ROCKSDB_JEMALLOC is\n// defined, Jemalloc memory allocator is used.\nstatic inline bool HasJemalloc() { return true; }\n\n#else\n\n// Declare non-standard jemalloc APIs as weak symbols. We can null-check these\n// symbols to detect whether jemalloc is linked with the binary.\nextern \"C\" void* mallocx(size_t, int) __attribute__((__weak__));\nextern \"C\" void* rallocx(void*, size_t, int) __attribute__((__weak__));\nextern \"C\" size_t xallocx(void*, size_t, size_t, int) __attribute__((__weak__));\nextern \"C\" size_t sallocx(const void*, int) __attribute__((__weak__));\nextern \"C\" void dallocx(void*, int) __attribute__((__weak__));\nextern \"C\" void sdallocx(void*, size_t, int) __attribute__((__weak__));\nextern \"C\" size_t nallocx(size_t, int) __attribute__((__weak__));\nextern \"C\" int mallctl(const char*, void*, size_t*, void*, size_t)\n    __attribute__((__weak__));\nextern \"C\" int mallctlnametomib(const char*, size_t*, size_t*)\n    __attribute__((__weak__));\nextern \"C\" int mallctlbymib(const size_t*, size_t, void*, size_t*, void*,\n                            size_t) __attribute__((__weak__));\nextern \"C\" void malloc_stats_print(void (*)(void*, const char*), void*,\n                                   const char*) __attribute__((__weak__));\nextern \"C\" size_t malloc_usable_size(JEMALLOC_USABLE_SIZE_CONST void*)\n    JEMALLOC_CXX_THROW __attribute__((__weak__));\n\n// Check if Jemalloc is linked with the binary. Note the main program might be\n// using a different memory allocator even this method return true.\n// It is loosely based on folly::usingJEMalloc(), minus the check that actually\n// allocate memory and see if it is through jemalloc, to handle the dlopen()\n// case:\n// https://github.com/facebook/folly/blob/76cf8b5841fb33137cfbf8b224f0226437c855bc/folly/memory/Malloc.h#L147\nstatic inline bool HasJemalloc() {\n  return mallocx != nullptr && rallocx != nullptr && xallocx != nullptr &&\n         sallocx != nullptr && dallocx != nullptr && sdallocx != nullptr &&\n         nallocx != nullptr && mallctl != nullptr &&\n         mallctlnametomib != nullptr && mallctlbymib != nullptr &&\n         malloc_stats_print != nullptr && malloc_usable_size != nullptr;\n}\n\n#endif\n\n#endif  // ROCKSDB_JEMALLOC\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.7.3-khbmb5qn57yoolwr4iwp4m6rv7ofvpit/spack-src/WINDOWS_PORT.md",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.7.3-khbmb5qn57yoolwr4iwp4m6rv7ofvpit/spack-src/docs/static/favicon.png",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.7.3-khbmb5qn57yoolwr4iwp4m6rv7ofvpit/spack-src/docs/static/og_image.png",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.7.3-khbmb5qn57yoolwr4iwp4m6rv7ofvpit/spack-src/docs/static/images/pcache-filelayout.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.7.3-khbmb5qn57yoolwr4iwp4m6rv7ofvpit/spack-src/docs/static/images/pcache-blockindex.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.7.3-khbmb5qn57yoolwr4iwp4m6rv7ofvpit/spack-src/docs/static/images/pcache-readiopath.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.7.3-khbmb5qn57yoolwr4iwp4m6rv7ofvpit/spack-src/docs/static/images/Resize-of-20140327_200754-300x225.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.7.3-khbmb5qn57yoolwr4iwp4m6rv7ofvpit/spack-src/docs/static/images/pcache-writeiopath.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.7.3-khbmb5qn57yoolwr4iwp4m6rv7ofvpit/spack-src/docs/static/images/pcache-fileindex.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.7.3-khbmb5qn57yoolwr4iwp4m6rv7ofvpit/spack-src/docs/static/images/bloom_fp_vs_bpk.png",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.7.3-khbmb5qn57yoolwr4iwp4m6rv7ofvpit/spack-src/docs/static/images/pcache-tieredstorage.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.7.3-khbmb5qn57yoolwr4iwp4m6rv7ofvpit/spack-src/docs/static/images/tree_example1.png",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.7.3-khbmb5qn57yoolwr4iwp4m6rv7ofvpit/spack-src/docs/static/images/binaryseek.png",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.7.3-khbmb5qn57yoolwr4iwp4m6rv7ofvpit/spack-src/docs/static/images/compaction/l0-l1-contend.png",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.7.3-khbmb5qn57yoolwr4iwp4m6rv7ofvpit/spack-src/docs/static/images/compaction/l1-l2-contend.png",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.7.3-khbmb5qn57yoolwr4iwp4m6rv7ofvpit/spack-src/docs/static/images/compaction/part-range-old.png",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.7.3-khbmb5qn57yoolwr4iwp4m6rv7ofvpit/spack-src/docs/static/images/compaction/full-range.png",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.7.3-khbmb5qn57yoolwr4iwp4m6rv7ofvpit/spack-src/docs/static/images/delrange/delrange_collapsed.png",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.7.3-khbmb5qn57yoolwr4iwp4m6rv7ofvpit/spack-src/docs/static/images/delrange/delrange_sst_blocks.png",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.7.3-khbmb5qn57yoolwr4iwp4m6rv7ofvpit/spack-src/docs/static/images/delrange/delrange_write_path.png",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.7.3-khbmb5qn57yoolwr4iwp4m6rv7ofvpit/spack-src/docs/static/images/delrange/delrange_key_schema.png",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.7.3-khbmb5qn57yoolwr4iwp4m6rv7ofvpit/spack-src/docs/static/images/delrange/delrange_uncollapsed.png",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.7.3-khbmb5qn57yoolwr4iwp4m6rv7ofvpit/spack-src/docs/static/images/data-block-hash-index/perf-cache-miss.png",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.7.3-khbmb5qn57yoolwr4iwp4m6rv7ofvpit/spack-src/docs/static/images/data-block-hash-index/hash-index-data-structure.png",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.7.3-khbmb5qn57yoolwr4iwp4m6rv7ofvpit/spack-src/docs/static/images/data-block-hash-index/block-format-binary-seek.png",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.7.3-khbmb5qn57yoolwr4iwp4m6rv7ofvpit/spack-src/docs/static/images/data-block-hash-index/block-format-hash-index.png",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.7.3-khbmb5qn57yoolwr4iwp4m6rv7ofvpit/spack-src/docs/static/images/data-block-hash-index/perf-throughput.png",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.7.3-khbmb5qn57yoolwr4iwp4m6rv7ofvpit/spack-src/docs/static/images/rate-limiter/write-KBps-series.png",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.7.3-khbmb5qn57yoolwr4iwp4m6rv7ofvpit/spack-src/docs/static/images/rate-limiter/write-KBps-cdf.png",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.7.3-khbmb5qn57yoolwr4iwp4m6rv7ofvpit/spack-src/docs/static/images/rate-limiter/auto-tuned-write-KBps-series.png",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.7.3-khbmb5qn57yoolwr4iwp4m6rv7ofvpit/spack-src/docs/static/fonts/LatoLatin-Regular.woff",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.7.3-khbmb5qn57yoolwr4iwp4m6rv7ofvpit/spack-src/docs/static/fonts/LatoLatin-Black.woff",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.7.3-khbmb5qn57yoolwr4iwp4m6rv7ofvpit/spack-src/docs/static/fonts/LatoLatin-BlackItalic.woff2",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.7.3-khbmb5qn57yoolwr4iwp4m6rv7ofvpit/spack-src/docs/static/fonts/LatoLatin-Regular.woff2",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.7.3-khbmb5qn57yoolwr4iwp4m6rv7ofvpit/spack-src/docs/static/fonts/LatoLatin-Italic.woff",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.7.3-khbmb5qn57yoolwr4iwp4m6rv7ofvpit/spack-src/docs/static/fonts/LatoLatin-Italic.woff2",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.7.3-khbmb5qn57yoolwr4iwp4m6rv7ofvpit/spack-src/docs/static/fonts/LatoLatin-Light.woff",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.7.3-khbmb5qn57yoolwr4iwp4m6rv7ofvpit/spack-src/docs/static/fonts/LatoLatin-BlackItalic.woff",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.7.3-khbmb5qn57yoolwr4iwp4m6rv7ofvpit/spack-src/docs/static/fonts/LatoLatin-Light.woff2",
        "/tmp/vanessa/spack-stage/spack-stage-rocksdb-6.7.3-khbmb5qn57yoolwr4iwp4m6rv7ofvpit/spack-src/docs/static/fonts/LatoLatin-Black.woff2"
    ],
    "total_files": 1539
}