{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/configure.cmake": "# Copyright (c) 2009, 2019, Oracle and/or its affiliates. All rights reserved.\n# \n# This program is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License, version 2.0,\n# as published by the Free Software Foundation.\n#\n# This program is also distributed with certain software (including\n# but not limited to OpenSSL) that is licensed under separate terms,\n# as designated in a particular file or component or in included license\n# documentation.  The authors of MySQL hereby grant you an additional\n# permission to link the program and your derivative works with the\n# separately licensed software that they have included with MySQL.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License, version 2.0, for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA\n#\n\nINCLUDE (CheckCSourceCompiles)\nINCLUDE (CheckCXXSourceCompiles)\nINCLUDE (CheckStructHasMember)\nINCLUDE (CheckLibraryExists)\nINCLUDE (CheckFunctionExists)\nINCLUDE (CheckCCompilerFlag)\nINCLUDE (CheckCSourceRuns)\nINCLUDE (CheckCXXSourceRuns)\nINCLUDE (CheckSymbolExists)\n\n\n# System type affects version_compile_os variable \nIF(NOT SYSTEM_TYPE)\n  IF(PLATFORM)\n    SET(SYSTEM_TYPE ${PLATFORM})\n  ELSE()\n    SET(SYSTEM_TYPE ${CMAKE_SYSTEM_NAME})\n  ENDIF()\nENDIF()\n\n# Same for structs, setting HAVE_STRUCT_<name> instead\nFUNCTION(MY_CHECK_STRUCT_SIZE type defbase)\n  CHECK_TYPE_SIZE(\"struct ${type}\" SIZEOF_${defbase})\n  IF(SIZEOF_${defbase})\n    SET(HAVE_STRUCT_${defbase} 1 PARENT_SCOPE)\n  ENDIF()\nENDFUNCTION()\n\n# Searches function in libraries\n# if function is found, sets output parameter result to the name of the library\n# if function is found in libc, result will be empty \nFUNCTION(MY_SEARCH_LIBS func libs result)\n  IF(${${result}})\n    # Library is already found or was predefined\n    RETURN()\n  ENDIF()\n  CHECK_FUNCTION_EXISTS(${func} HAVE_${func}_IN_LIBC)\n  IF(HAVE_${func}_IN_LIBC)\n    SET(${result} \"\" PARENT_SCOPE)\n    RETURN()\n  ENDIF()\n  FOREACH(lib  ${libs})\n    CHECK_LIBRARY_EXISTS(${lib} ${func} \"\" HAVE_${func}_IN_${lib}) \n    IF(HAVE_${func}_IN_${lib})\n      SET(${result} ${lib} PARENT_SCOPE)\n      SET(HAVE_${result} 1 PARENT_SCOPE)\n      RETURN()\n    ENDIF()\n  ENDFOREACH()\nENDFUNCTION()\n\n# Find out which libraries to use.\n\n# Figure out threading library\n# Defines CMAKE_USE_PTHREADS_INIT and CMAKE_THREAD_LIBS_INIT.\nFIND_PACKAGE (Threads)\n\nIF(UNIX)\n  IF(FREEBSD)\n    MYSQL_CHECK_PKGCONFIG()\n    PKG_CHECK_MODULES(LIBUNWIND libunwind)\n  ENDIF()\n  MY_SEARCH_LIBS(floor m LIBM)\n  IF(NOT LIBM)\n    MY_SEARCH_LIBS(__infinity m LIBM)\n  ENDIF()\n  IF(NOT LIBM)\n    MY_SEARCH_LIBS(log m LIBM)\n  ENDIF()\n  MY_SEARCH_LIBS(gethostbyname_r  \"nsl_r;nsl\" LIBNSL)\n  MY_SEARCH_LIBS(bind \"bind;socket\" LIBBIND)\n  MY_SEARCH_LIBS(crypt crypt LIBCRYPT)\n  MY_SEARCH_LIBS(setsockopt socket LIBSOCKET)\n  MY_SEARCH_LIBS(dlopen dl LIBDL)\n  # HAVE_dlopen_IN_LIBC\n  IF(NOT LIBDL)\n    MY_SEARCH_LIBS(dlsym dl LIBDL)\n  ENDIF()\n  MY_SEARCH_LIBS(sched_yield rt LIBRT)\n  IF(NOT LIBRT)\n    MY_SEARCH_LIBS(clock_gettime rt LIBRT)\n  ENDIF()\n  MY_SEARCH_LIBS(timer_create rt LIBRT)\n  MY_SEARCH_LIBS(atomic_thread_fence atomic LIBATOMIC)\n  MY_SEARCH_LIBS(backtrace execinfo LIBEXECINFO)\n\n  LIST(APPEND CMAKE_REQUIRED_LIBRARIES\n    ${LIBM} ${LIBNSL} ${LIBBIND} ${LIBCRYPT} ${LIBSOCKET} ${LIBDL}\n    ${CMAKE_THREAD_LIBS_INIT} ${LIBRT} ${LIBATOMIC} ${LIBEXECINFO}\n  )\n  # Need explicit pthread for gcc -fsanitize=address\n  IF(CMAKE_C_FLAGS MATCHES \"-fsanitize=\")\n    SET(CMAKE_REQUIRED_LIBRARIES ${CMAKE_REQUIRED_LIBRARIES} pthread)\n  ENDIF()\n\n  # https://bugs.llvm.org/show_bug.cgi?id=16404\n  IF(LINUX AND HAVE_UBSAN AND MY_COMPILER_IS_CLANG)\n    SET(CMAKE_EXE_LINKER_FLAGS_DEBUG\n      \"${CMAKE_EXE_LINKER_FLAGS_DEBUG} -rtlib=compiler-rt -lgcc_s\")\n    SET(CMAKE_EXE_LINKER_FLAGS_RELWITHDEBINFO\n      \"${CMAKE_EXE_LINKER_FLAGS_RELWITHDEBINFO} -rtlib=compiler-rt -lgcc_s\")\n  ENDIF()\n\n  IF(WITH_ASAN)\n    SET(CMAKE_REQUIRED_FLAGS \"${CMAKE_REQUIRED_FLAGS} -fsanitize=address\")\n  ENDIF()\n\n  IF(WITH_ASAN OR WITH_LSAN OR WITH_TSAN)\n    IF(CMAKE_USE_PTHREADS_INIT AND NOT CMAKE_THREAD_LIBS_INIT)\n      MESSAGE(STATUS \"No CMAKE_THREAD_LIBS_INIT ??\")\n      SET(CMAKE_THREAD_LIBS_INIT \"-lpthread\")\n    ENDIF()\n  ENDIF()\n\n  LIST(LENGTH CMAKE_REQUIRED_LIBRARIES required_libs_length)\n  IF(${required_libs_length} GREATER 0)\n    LIST(REMOVE_DUPLICATES CMAKE_REQUIRED_LIBRARIES)\n  ENDIF()  \n  LINK_LIBRARIES(${CMAKE_THREAD_LIBS_INIT})\n  \n  OPTION(WITH_LIBWRAP \"Compile with tcp wrappers support\" OFF)\n  IF(WITH_LIBWRAP)\n    SET(SAVE_CMAKE_REQUIRED_LIBRARIES ${CMAKE_REQUIRED_LIBRARIES})\n    SET(CMAKE_REQUIRED_LIBRARIES ${CMAKE_REQUIRED_LIBRARIES} wrap)\n    CHECK_C_SOURCE_COMPILES(\n    \"\n    #include <tcpd.h>\n    int allow_severity = 0;\n    int deny_severity  = 0;\n    int main()\n    {\n      hosts_access(0);\n    }\"\n    HAVE_LIBWRAP)\n\n    IF(HAVE_LIBWRAP)\n      CHECK_CXX_SOURCE_COMPILES(\n      \"\n      #include <tcpd.h>\n      int main()\n      {\n        struct request_info req;\n        if (req.sink)\n          (req.sink)(req.fd);\n      }\"\n      HAVE_LIBWRAP_PROTOTYPES)\n    ENDIF()\n\n    SET(CMAKE_REQUIRED_LIBRARIES ${SAVE_CMAKE_REQUIRED_LIBRARIES})\n    IF(HAVE_LIBWRAP)\n      SET(LIBWRAP \"wrap\")\n    ELSE()\n      MESSAGE(FATAL_ERROR \n      \"WITH_LIBWRAP is defined, but can not find a working libwrap. \"\n      \"Make sure both the header files (tcpd.h) \"\n      \"and the library (libwrap) are installed.\")\n    ENDIF()\n  ENDIF()\nENDIF()\n\n#\n# Tests for header files\n#\nINCLUDE (CheckIncludeFiles)\n\nIF(FREEBSD)\n  # On FreeBSD some includes, e.g. sasl/sasl.h, is in /usr/local/include\n  LIST(APPEND CMAKE_REQUIRED_INCLUDES \"/usr/local/include\")\nENDIF()\n\nCHECK_INCLUDE_FILES (alloca.h HAVE_ALLOCA_H)\nCHECK_INCLUDE_FILES (arpa/inet.h HAVE_ARPA_INET_H)\nCHECK_INCLUDE_FILES (dlfcn.h HAVE_DLFCN_H)\nCHECK_INCLUDE_FILES (endian.h HAVE_ENDIAN_H)\nCHECK_INCLUDE_FILES (execinfo.h HAVE_EXECINFO_H)\nCHECK_INCLUDE_FILES (fpu_control.h HAVE_FPU_CONTROL_H)\nCHECK_INCLUDE_FILES (grp.h HAVE_GRP_H)\nCHECK_INCLUDE_FILES (langinfo.h HAVE_LANGINFO_H)\nCHECK_INCLUDE_FILES (malloc.h HAVE_MALLOC_H)\nCHECK_INCLUDE_FILES (netinet/in.h HAVE_NETINET_IN_H)\nCHECK_INCLUDE_FILES (poll.h HAVE_POLL_H)\nCHECK_INCLUDE_FILES (pwd.h HAVE_PWD_H)\nCHECK_INCLUDE_FILES (strings.h HAVE_STRINGS_H) # Used by NDB\nCHECK_INCLUDE_FILES (sys/ioctl.h HAVE_SYS_IOCTL_H)\nCHECK_INCLUDE_FILES (sys/mman.h HAVE_SYS_MMAN_H)\nCHECK_INCLUDE_FILES (sys/prctl.h HAVE_SYS_PRCTL_H)\nCHECK_INCLUDE_FILES (sys/resource.h HAVE_SYS_RESOURCE_H)\nCHECK_INCLUDE_FILES (sys/select.h HAVE_SYS_SELECT_H)\nCHECK_INCLUDE_FILES (sys/socket.h HAVE_SYS_SOCKET_H)\nCHECK_INCLUDE_FILES (\"curses.h;term.h\" HAVE_TERM_H)\nCHECK_INCLUDE_FILES (termios.h HAVE_TERMIOS_H)\nCHECK_INCLUDE_FILES (termio.h HAVE_TERMIO_H)\nCHECK_INCLUDE_FILES (unistd.h HAVE_UNISTD_H)\nCHECK_INCLUDE_FILES (sys/wait.h HAVE_SYS_WAIT_H)\nCHECK_INCLUDE_FILES (sys/param.h HAVE_SYS_PARAM_H) # Used by NDB/libevent\nCHECK_INCLUDE_FILES (fnmatch.h HAVE_FNMATCH_H)\nCHECK_INCLUDE_FILES (sys/un.h HAVE_SYS_UN_H)\n# Cyrus SASL 2.1.26 on Solaris 11.4 has a bug that requires sys/types.h\n# to be included before checking if sasl/sasl.h exists\nCHECK_INCLUDE_FILES (\"sys/types.h;sasl/sasl.h\" HAVE_SASL_SASL_H)\n\n#\n# Tests for functions\n#\nIF(WITH_ASAN)\n  CHECK_SYMBOL_EXISTS (__lsan_do_recoverable_leak_check\n    \"sanitizer/lsan_interface.h\" HAVE_LSAN_DO_RECOVERABLE_LEAK_CHECK)\nENDIF()\nCHECK_FUNCTION_EXISTS (_aligned_malloc HAVE_ALIGNED_MALLOC)\nCHECK_FUNCTION_EXISTS (backtrace HAVE_BACKTRACE)\nCHECK_FUNCTION_EXISTS (index HAVE_INDEX)\nCHECK_FUNCTION_EXISTS (chown HAVE_CHOWN)\nCHECK_FUNCTION_EXISTS (cuserid HAVE_CUSERID)\nCHECK_FUNCTION_EXISTS (directio HAVE_DIRECTIO)\nCHECK_FUNCTION_EXISTS (ftruncate HAVE_FTRUNCATE)\nCHECK_FUNCTION_EXISTS (fchmod HAVE_FCHMOD)\nCHECK_FUNCTION_EXISTS (fcntl HAVE_FCNTL)\nCHECK_FUNCTION_EXISTS (fdatasync HAVE_FDATASYNC)\nCHECK_SYMBOL_EXISTS(fdatasync \"unistd.h\" HAVE_DECL_FDATASYNC)\nCHECK_FUNCTION_EXISTS (fedisableexcept HAVE_FEDISABLEEXCEPT)\nCHECK_FUNCTION_EXISTS (fsync HAVE_FSYNC)\nCHECK_FUNCTION_EXISTS (gethrtime HAVE_GETHRTIME)\nCHECK_FUNCTION_EXISTS (getpass HAVE_GETPASS)\nCHECK_FUNCTION_EXISTS (getpassphrase HAVE_GETPASSPHRASE)\nCHECK_FUNCTION_EXISTS (getpwnam HAVE_GETPWNAM)\nCHECK_FUNCTION_EXISTS (getpwuid HAVE_GETPWUID)\nCHECK_FUNCTION_EXISTS (getrusage HAVE_GETRUSAGE)\nCHECK_FUNCTION_EXISTS (initgroups HAVE_INITGROUPS)\nCHECK_FUNCTION_EXISTS (issetugid HAVE_ISSETUGID)\nCHECK_FUNCTION_EXISTS (getuid HAVE_GETUID)\nCHECK_FUNCTION_EXISTS (geteuid HAVE_GETEUID)\nCHECK_FUNCTION_EXISTS (getgid HAVE_GETGID)\nCHECK_FUNCTION_EXISTS (getegid HAVE_GETEGID)\nCHECK_FUNCTION_EXISTS (madvise HAVE_MADVISE)\nCHECK_FUNCTION_EXISTS (malloc_info HAVE_MALLOC_INFO)\nCHECK_FUNCTION_EXISTS (mlock HAVE_MLOCK)\nCHECK_FUNCTION_EXISTS (mlockall HAVE_MLOCKALL)\nCHECK_FUNCTION_EXISTS (mmap64 HAVE_MMAP64)\nCHECK_FUNCTION_EXISTS (poll HAVE_POLL)\nCHECK_FUNCTION_EXISTS (posix_fallocate HAVE_POSIX_FALLOCATE)\nCHECK_FUNCTION_EXISTS (posix_memalign HAVE_POSIX_MEMALIGN)\nCHECK_FUNCTION_EXISTS (pthread_condattr_setclock HAVE_PTHREAD_CONDATTR_SETCLOCK)\nCHECK_FUNCTION_EXISTS (pthread_getaffinity_np HAVE_PTHREAD_GETAFFINITY_NP)\nCHECK_FUNCTION_EXISTS (pthread_sigmask HAVE_PTHREAD_SIGMASK)\nCHECK_FUNCTION_EXISTS (sleep HAVE_SLEEP)\nCHECK_FUNCTION_EXISTS (stpcpy HAVE_STPCPY)\nCHECK_FUNCTION_EXISTS (stpncpy HAVE_STPNCPY)\nCHECK_FUNCTION_EXISTS (strlcpy HAVE_STRLCPY)\nCHECK_FUNCTION_EXISTS (strndup HAVE_STRNDUP) # Used by libbinlogevents\nCHECK_FUNCTION_EXISTS (strlcat HAVE_STRLCAT)\nCHECK_FUNCTION_EXISTS (strsignal HAVE_STRSIGNAL)\nCHECK_FUNCTION_EXISTS (tell HAVE_TELL)\nCHECK_FUNCTION_EXISTS (vasprintf HAVE_VASPRINTF)\nCHECK_FUNCTION_EXISTS (memalign HAVE_MEMALIGN)\nCHECK_FUNCTION_EXISTS (nl_langinfo HAVE_NL_LANGINFO)\nCHECK_FUNCTION_EXISTS (ntohll HAVE_HTONLL)\nCHECK_FUNCTION_EXISTS (memset_s HAVE_MEMSET_S)\n\nCHECK_FUNCTION_EXISTS (epoll_create HAVE_EPOLL)\n\n#--------------------------------------------------------------------\n# Support for WL#2373 (Use cycle counter for timing)\n#--------------------------------------------------------------------\n\nCHECK_INCLUDE_FILES(sys/time.h HAVE_SYS_TIME_H)\nCHECK_INCLUDE_FILES(sys/times.h HAVE_SYS_TIMES_H)\n\nCHECK_FUNCTION_EXISTS(times HAVE_TIMES)\nCHECK_FUNCTION_EXISTS(gettimeofday HAVE_GETTIMEOFDAY)\n\n\n#\n# Tests for symbols\n#\n\nCHECK_SYMBOL_EXISTS(lrand48 \"stdlib.h\" HAVE_LRAND48)\nCHECK_SYMBOL_EXISTS(TIOCGWINSZ \"sys/ioctl.h\" GWINSZ_IN_SYS_IOCTL)\nCHECK_SYMBOL_EXISTS(FIONREAD \"sys/ioctl.h\" FIONREAD_IN_SYS_IOCTL)\nCHECK_SYMBOL_EXISTS(FIONREAD \"sys/filio.h\" FIONREAD_IN_SYS_FILIO)\nCHECK_SYMBOL_EXISTS(MADV_DONTDUMP \"sys/mman.h\" HAVE_MADV_DONTDUMP)\nCHECK_CXX_SOURCE_COMPILES(\n\"#include <sys/types.h>\n #include <sys/stat.h>\n #include <fcntl.h>\nint main() {\n  long long int foo = O_TMPFILE;\n}\" HAVE_O_TMPFILE)\n\n# The results of these four checks are only needed here, not in code.\nCHECK_FUNCTION_EXISTS (timer_create HAVE_TIMER_CREATE)\nCHECK_FUNCTION_EXISTS (timer_settime HAVE_TIMER_SETTIME)\nCHECK_FUNCTION_EXISTS (kqueue HAVE_KQUEUE)\n\n# Check whether the setns() API function supported by a target platform\nCHECK_C_SOURCE_RUNS(\"\n#ifndef _GNU_SOURCE\n#define _GNU_SOURCE\n#endif\n#include <sched.h>\nint main()\n{\n  (void)setns(0, 0);\n  return 0;\n}\" HAVE_SETNS)\n\nCHECK_SYMBOL_EXISTS(EVFILT_TIMER \"sys/types.h;sys/event.h;sys/time.h\" HAVE_EVFILT_TIMER)\nIF(HAVE_KQUEUE AND HAVE_EVFILT_TIMER)\n  SET(HAVE_KQUEUE_TIMERS 1 CACHE INTERNAL \"Have kqueue timer-related filter\")\nELSEIF(HAVE_TIMER_CREATE AND HAVE_TIMER_SETTIME)\n  SET(HAVE_POSIX_TIMERS 1 CACHE INTERNAL \"Have POSIX timer-related functions\")\nENDIF()\n\nIF(NOT HAVE_POSIX_TIMERS AND NOT HAVE_KQUEUE_TIMERS AND NOT WIN32)\n  MESSAGE(FATAL_ERROR \"No mysys timer support detected!\")\nENDIF()\n\n#\n# Test for endianess\n#\nINCLUDE(TestBigEndian)\nTEST_BIG_ENDIAN(WORDS_BIGENDIAN)\n\n# The header for glibc versions less than 2.9 will not\n# have the endian conversion macros defined.\nIF(HAVE_ENDIAN_H)\n  CHECK_SYMBOL_EXISTS(le64toh endian.h HAVE_LE64TOH)\n  CHECK_SYMBOL_EXISTS(le32toh endian.h HAVE_LE32TOH)\n  CHECK_SYMBOL_EXISTS(le16toh endian.h HAVE_LE16TOH)\n  CHECK_SYMBOL_EXISTS(htole64 endian.h HAVE_HTOLE64)\n  CHECK_SYMBOL_EXISTS(htole32 endian.h HAVE_HTOLE32)\n  CHECK_SYMBOL_EXISTS(htole16 endian.h HAVE_HTOLE16)\n  IF(HAVE_LE32TOH AND HAVE_LE16TOH AND HAVE_LE64TOH AND\n      HAVE_HTOLE64 AND HAVE_HTOLE32 AND HAVE_HTOLE16)\n    # Used by libbinlogevents and libmysqlgcs.\n    SET(HAVE_ENDIAN_CONVERSION_MACROS 1)\n  ENDIF()\nENDIF()\n\n#\n# Tests for type sizes (and presence)\n#\nINCLUDE (CheckTypeSize)\n\nLIST(APPEND CMAKE_REQUIRED_DEFINITIONS\n  -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64\n  -D__STDC_LIMIT_MACROS -D__STDC_CONSTANT_MACROS -D__STDC_FORMAT_MACROS\n  )\n\nIF(SOLARIS)\n  LIST(APPEND CMAKE_REQUIRED_DEFINITIONS\n    -D_POSIX_PTHREAD_SEMANTICS -D_REENTRANT -D_PTHREADS\n    )\nENDIF()\n\nSET(CMAKE_EXTRA_INCLUDE_FILES stdint.h stdio.h sys/types.h time.h)\n\nCHECK_TYPE_SIZE(\"void *\"    SIZEOF_VOIDP)\nCHECK_TYPE_SIZE(\"char *\"    SIZEOF_CHARP)\nCHECK_TYPE_SIZE(\"long\"      SIZEOF_LONG)\nCHECK_TYPE_SIZE(\"short\"     SIZEOF_SHORT)\nCHECK_TYPE_SIZE(\"int\"       SIZEOF_INT)\nCHECK_TYPE_SIZE(\"long long\" SIZEOF_LONG_LONG)\nCHECK_TYPE_SIZE(\"time_t\"    SIZEOF_TIME_T)\n\nCHECK_STRUCT_HAS_MEMBER(\"struct tm\"\n tm_gmtoff \"time.h\" HAVE_TM_GMTOFF)\n\n# If finds the size of a type, set SIZEOF_<type> and HAVE_<type>\nFUNCTION(MY_CHECK_TYPE_SIZE type defbase)\n  CHECK_TYPE_SIZE(\"${type}\" SIZEOF_${defbase})\n  IF(SIZEOF_${defbase})\n    SET(HAVE_${defbase} 1 PARENT_SCOPE)\n  ENDIF()\nENDFUNCTION()\n\n# We are only interested in presence for these\nMY_CHECK_TYPE_SIZE(ulong ULONG)\nMY_CHECK_TYPE_SIZE(u_int32_t U_INT32_T)\n\n# Support for tagging symbols with __attribute__((visibility(\"hidden\")))\nMY_CHECK_CXX_COMPILER_FLAG(\"-fvisibility=hidden\" HAVE_VISIBILITY_HIDDEN)\n\n#\n# Code tests\n#\n\nCHECK_C_SOURCE_RUNS(\"\n#include <time.h>\nint main()\n{\n  struct timespec ts;\n  return clock_gettime(CLOCK_MONOTONIC, &ts);\n}\" HAVE_CLOCK_GETTIME)\n\nCHECK_C_SOURCE_RUNS(\"\n#include <time.h>\nint main()\n{\n  struct timespec ts;\n  return clock_gettime(CLOCK_REALTIME, &ts);\n}\" HAVE_CLOCK_REALTIME)\n\nIF(NOT STACK_DIRECTION)\n  IF(CMAKE_CROSSCOMPILING)\n   MESSAGE(FATAL_ERROR \n   \"STACK_DIRECTION is not defined.  Please specify -DSTACK_DIRECTION=1 \"\n   \"or -DSTACK_DIRECTION=-1 when calling cmake.\")\n  ELSE()\n    TRY_RUN(STACKDIR_RUN_RESULT STACKDIR_COMPILE_RESULT    \n     ${CMAKE_BINARY_DIR} \n     ${CMAKE_SOURCE_DIR}/cmake/stack_direction.c\n     )\n     # Test program returns 0 (down) or 1 (up).\n     # Convert to -1 or 1\n     IF(STACKDIR_RUN_RESULT EQUAL 0)\n       SET(STACK_DIRECTION -1 CACHE INTERNAL \"Stack grows direction\")\n     ELSE()\n       SET(STACK_DIRECTION 1 CACHE INTERNAL \"Stack grows direction\")\n     ENDIF()\n     MESSAGE(STATUS \"Checking stack direction : ${STACK_DIRECTION}\")\n   ENDIF()\nENDIF()\n\nCHECK_INCLUDE_FILES(\"time.h;sys/time.h\" TIME_WITH_SYS_TIME)\nCHECK_SYMBOL_EXISTS(O_NONBLOCK \"unistd.h;fcntl.h\" HAVE_FCNTL_NONBLOCK)\nIF(NOT HAVE_FCNTL_NONBLOCK)\n SET(NO_FCNTL_NONBLOCK 1)\nENDIF()\n\nIF(NOT CMAKE_CROSSCOMPILING AND NOT MSVC)\n  STRING(TOLOWER ${CMAKE_SYSTEM_PROCESSOR}  processor)\n  IF(processor MATCHES \"86\" OR\n      processor MATCHES \"amd64\" OR\n      processor MATCHES \"x64\")\n    IF(NOT SOLARIS)\n      # The loader in some Solaris versions has a bug due to which it refuses to\n      # start a binary that has been compiled by GCC and uses __asm__(\"pause\")\n      # with the error:\n      # $ ./mysqld\n      # ld.so.1: mysqld: fatal: hardware capability unsupported: 0x2000 [ PAUSE ]\n      # Killed\n      # $\n      # Even though the CPU does have support for the instruction.\n      # Binaries that have been compiled by GCC and use __asm__(\"pause\")\n      # on a non-buggy Solaris get flagged with a \"uses pause\" flag and\n      # thus they are unusable if copied on buggy Solaris version. To\n      # circumvent this we explicitly disable __asm__(\"pause\") when\n      # compiling on Solaris. Subsequently the tests here will enable\n      # HAVE_FAKE_PAUSE_INSTRUCTION which will use __asm__(\"rep; nop\")\n      # which currently generates the same code as __asm__(\"pause\") - 0xf3 0x90\n      # but without flagging the binary as \"uses pause\".\n      CHECK_C_SOURCE_RUNS(\"\n      int main()\n      {\n        __asm__ __volatile__ (\\\"pause\\\");\n        return 0;\n      }\"  HAVE_PAUSE_INSTRUCTION)\n    ENDIF()\n  ENDIF()\n  IF (NOT HAVE_PAUSE_INSTRUCTION)\n    CHECK_C_SOURCE_COMPILES(\"\n    int main()\n    {\n     __asm__ __volatile__ (\\\"rep; nop\\\");\n     return 0;\n    }\n   \" HAVE_FAKE_PAUSE_INSTRUCTION)\n  ENDIF()\n  IF (NOT HAVE_PAUSE_INSTRUCTION)\n    CHECK_C_SOURCE_COMPILES(\"\n    int main()\n    {\n     __asm__ __volatile__ (\\\"or 1,1,1\\\");\n     __asm__ __volatile__ (\\\"or 2,2,2\\\");\n     return 0;\n    }\n    \" HAVE_HMT_PRIORITY_INSTRUCTION)\n  ENDIF()\nENDIF()\n  \nINCLUDE (CheckIncludeFileCXX)\nCHECK_INCLUDE_FILE_CXX(cxxabi.h HAVE_CXXABI_H)\nIF(HAVE_CXXABI_H)\nCHECK_CXX_SOURCE_COMPILES(\"\n #include <cxxabi.h>\n int main(int argc, char **argv) \n  {\n    char *foo= 0; int bar= 0;\n    foo= abi::__cxa_demangle(foo, foo, 0, &bar);\n    return 0;\n  }\"\n  HAVE_ABI_CXA_DEMANGLE)\nENDIF()\n\nCHECK_C_SOURCE_COMPILES(\"\nint main()\n{\n  __builtin_unreachable();\n  return 0;\n}\" HAVE_BUILTIN_UNREACHABLE)\n\nCHECK_C_SOURCE_COMPILES(\"\nint main()\n{\n  long l= 0;\n  __builtin_expect(l, 0);\n  return 0;\n}\" HAVE_BUILTIN_EXPECT)\n\n# Only check for __builtin_stpcpy() if stpcpy() is available.\n# Oracle Developer Studio requires <string.h> to be included in order\n# to use __builtin_stpcpy.\nIF(HAVE_STPCPY)\n  CHECK_SYMBOL_EXISTS(__builtin_stpcpy \"string.h\" HAVE_BUILTIN_STPCPY)\nENDIF()\n\nCHECK_CXX_SOURCE_COMPILES(\"\n  int main()\n  {\n    int foo= -10; int bar= 10;\n    long long int foo64= -10; long long int bar64= 10;\n    if (!__sync_fetch_and_add(&foo, bar) || foo)\n      return -1;\n    bar= __sync_lock_test_and_set(&foo, bar);\n    if (bar || foo != 10)\n      return -1;\n    bar= __sync_val_compare_and_swap(&bar, foo, 15);\n    if (bar)\n      return -1;\n    if (!__sync_fetch_and_add(&foo64, bar64) || foo64)\n      return -1;\n    bar64= __sync_lock_test_and_set(&foo64, bar64);\n    if (bar64 || foo64 != 10)\n      return -1;\n    bar64= __sync_val_compare_and_swap(&bar64, foo, 15);\n    if (bar64)\n      return -1;\n    return 0;\n  }\"\n  HAVE_GCC_SYNC_BUILTINS)\n\nIF(WITH_VALGRIND)\n  SET(VALGRIND_HEADERS \"valgrind/memcheck.h;valgrind/valgrind.h\")\n  CHECK_INCLUDE_FILES(\"${VALGRIND_HEADERS}\" HAVE_VALGRIND_HEADERS)\n  IF(HAVE_VALGRIND_HEADERS)\n    SET(HAVE_VALGRIND 1)\n  ELSE()\n    MESSAGE(FATAL_ERROR \"Unable to find Valgrind header files ${VALGRIND_HEADERS}. Make sure you have them in your include path.\")\n  ENDIF()\nENDIF()\n\n# Check for gettid() system call\nCHECK_C_SOURCE_COMPILES(\"\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <unistd.h>\nint main(int ac, char **av)\n{\n  unsigned long long tid = syscall(SYS_gettid);\n  return (tid != 0 ? 0 : 1);\n}\"\nHAVE_SYS_GETTID)\n\n# Check for pthread_getthreadid_np()\nCHECK_C_SOURCE_COMPILES(\"\n#include <pthread_np.h>\nint main(int ac, char **av)\n{\n  unsigned long long tid = pthread_getthreadid_np();\n  return (tid != 0 ? 0 : 1);\n}\"\nHAVE_PTHREAD_GETTHREADID_NP)\n\n# Check for pthread_threadid_np()\nCHECK_C_SOURCE_COMPILES(\"\n#include <pthread.h>\nint main(int ac, char **av)\n{\n  unsigned long long tid64;\n  pthread_threadid_np(NULL, &tid64);\n  return (tid64 != 0 ? 0 : 1);\n}\"\nHAVE_PTHREAD_THREADID_NP)\n\n# Check for pthread_self() returning an integer type\nCHECK_C_SOURCE_COMPILES(\"\n#include <sys/types.h>\n#include <pthread.h>\nint main(int ac, char **av)\n{\n  unsigned long long tid = pthread_self();\n  return (tid != 0 ? 0 : 1);\n}\"\nHAVE_INTEGER_PTHREAD_SELF\nFAIL_REGEX \"warning: incompatible pointer to integer conversion\"\n)\n\n#--------------------------------------------------------------------\n# Check for IPv6 support\n#--------------------------------------------------------------------\nCHECK_INCLUDE_FILE(netinet/in6.h HAVE_NETINET_IN6_H) # Used by libevent (never true)\nMY_CHECK_STRUCT_SIZE(\"in6_addr\" IN6_ADDR) # Used by libevent\n\nIF(UNIX)\n  SET(CMAKE_EXTRA_INCLUDE_FILES sys/types.h netinet/in.h sys/socket.h)\n  IF(HAVE_NETINET_IN6_H)\n    SET(CMAKE_EXTRA_INCLUDE_FILES ${CMAKE_EXTRA_INCLUDE_FILES} netinet/in6.h)\n  ENDIF()\nELSEIF(WIN32)\n  SET(CMAKE_EXTRA_INCLUDE_FILES ${CMAKE_EXTRA_INCLUDE_FILES} winsock2.h ws2ipdef.h)\nENDIF()\n\n#\n# Check if struct sockaddr_in::sin_len is available.\n#\n\nCHECK_STRUCT_HAS_MEMBER(\"struct sockaddr_in\" sin_len\n  \"${CMAKE_EXTRA_INCLUDE_FILES}\" HAVE_SOCKADDR_IN_SIN_LEN)\n\n#\n# Check if struct sockaddr_in6::sin6_len is available.\n#\n\nCHECK_STRUCT_HAS_MEMBER(\"struct sockaddr_in6\" sin6_len\n  \"${CMAKE_EXTRA_INCLUDE_FILES}\" HAVE_SOCKADDR_IN6_SIN6_LEN)\n\nSET(CMAKE_EXTRA_INCLUDE_FILES)\n\nCHECK_INCLUDE_FILES(numa.h HAVE_NUMA_H)\nCHECK_INCLUDE_FILES(numaif.h HAVE_NUMAIF_H)\n\nIF(HAVE_NUMA_H AND HAVE_NUMAIF_H)\n  SET(SAVE_CMAKE_REQUIRED_LIBRARIES ${CMAKE_REQUIRED_LIBRARIES})\n  SET(CMAKE_REQUIRED_LIBRARIES ${CMAKE_REQUIRED_LIBRARIES} numa)\n  CHECK_C_SOURCE_COMPILES(\n    \"\n    #include <numa.h>\n    #include <numaif.h>\n    int main()\n    {\n       struct bitmask *all_nodes= numa_all_nodes_ptr;\n       set_mempolicy(MPOL_DEFAULT, 0, 0);\n       return all_nodes != NULL;\n    }\"\n    HAVE_LIBNUMA)\n  SET(CMAKE_REQUIRED_LIBRARIES ${SAVE_CMAKE_REQUIRED_LIBRARIES})\nELSE()\n  SET(HAVE_LIBNUMA 0)\nENDIF()\n\nIF(NOT HAVE_LIBNUMA)\n  MESSAGE(STATUS \"NUMA library missing or required version not available\")\nENDIF()\n\nIF(HAVE_LIBNUMA AND HAVE_NUMA_H AND HAVE_NUMAIF_H)\n  OPTION(WITH_NUMA \"Explicitly set NUMA memory allocation policy\" ON)\nELSE()\n  OPTION(WITH_NUMA \"Explicitly set NUMA memory allocation policy\" OFF)\nENDIF()\n\nIF(WITH_NUMA AND NOT HAVE_LIBNUMA)\n  # Forget it in cache, abort the build.\n  UNSET(WITH_NUMA CACHE)\n  MESSAGE(FATAL_ERROR \"Could not find numa headers/libraries\")\nENDIF()\n\nIF(HAVE_LIBNUMA AND NOT WITH_NUMA)\n  SET(HAVE_LIBNUMA 0)\n  MESSAGE(STATUS \"Disabling NUMA on user's request\")\nENDIF()\n",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/src/common/portlib/NdbNuma.cpp": "/*\n   Copyright (c) 2010, 2016, Oracle and/or its affiliates. All rights reserved.\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License, version 2.0,\n   as published by the Free Software Foundation.\n\n   This program is also distributed with certain software (including\n   but not limited to OpenSSL) that is licensed under separate terms,\n   as designated in a particular file or component or in included license\n   documentation.  The authors of MySQL hereby grant you an additional\n   permission to link the program and your derivative works with the\n   separately licensed software that they have included with MySQL.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License, version 2.0, for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA\n*/\n\n#include <NdbNuma.h>\n#include <ndb_global.h>\n\n#ifdef TEST_NDBNUMA\nstatic int NDB_TRACE_NUMA = 0;\n#else\n#define NDB_TRACE_NUMA (false)\n#endif\n\n#if defined HAVE_DLFCN_H && defined HAVE_DLOPEN\n#include <dlfcn.h>\n\n/**\n * Load libnuma using dlopen, not have to put link dependency on it...\n * - handle fact that there are 2 versions of libnuma...\n *   use existance of symbol \"numa_all_nodes_ptr\" to use v2 abi\n */\nstruct bitmask;\nextern \"C\"\n{\n  typedef int (* fun0)(void);\n  typedef void (* fun1)(struct bitmask*);\n  typedef void (* fun2)(int);\n  typedef int (* fun3)(int node, unsigned long * bug, int buflen);\n  typedef bitmask * (* fun4)();\n  typedef void (* fun5)(struct bitmask*);\n  typedef bitmask * (* fun6)(struct bitmask*);\n};\n\nclass NdbNuma\n{\npublic:\n  NdbNuma() { handle = 0;}\n  ~NdbNuma() { if (handle) dlclose(handle); }\n\n  int open();\n  int build_cputonodemap();\n\n  void * handle;\n  fun0 numa_available;\n\n  fun0 numa_max_node;\n  fun0 numa_max_possible_node;\n  fun1 numa_set_interleave_mask;\n  fun2 numa_set_strict;\n  fun3 numa_node_to_cpus;\n  fun4 numa_allocate_nodemask;\n  fun5 numa_bitmask_free;\n  fun6 numa_bitmask_setall;\n\n  struct bitmask * numa_all_nodes;\n  struct bitmask * numa_all_nodes_ptr;\n};\n\nstatic\nvoid*\nmy_dlopen(const char * name)\n{\n  void * p = dlopen(name, RTLD_LAZY);\n  if (NDB_TRACE_NUMA)\n  {\n    if (p == 0)\n      printf(\"info: failed to load %s\\n\", name);\n    else\n      printf(\"info: loaded %s\\n\", name);\n  }\n  return p;\n}\n\nstatic\nvoid*\nmy_dlsym(void * handle, const char * name)\n{\n  void * p = dlsym(handle, name);\n  if (NDB_TRACE_NUMA)\n  {\n    if (p != 0)\n    {\n      printf(\"info: %s OK\\n\", name);\n    }\n    else\n    {\n      printf(\"info: %s NOT FOUND\\n\", name);\n    }\n  }\n  return p;\n}\n\nint\nNdbNuma::open()\n{\n  handle = my_dlopen(\"libnuma.so\");\n  if (handle == 0)\n  {\n    handle = my_dlopen(\"libnuma.so.1\");\n  }\n  if (handle == 0)\n  {\n    return -1;\n  }\n\n  numa_available = (fun0)my_dlsym(handle, \"numa_available\");\n  if (numa_available == 0)\n  {\n    goto fail;\n  }\n\n  if ((* numa_available)() == -1)\n  {\n    if (NDB_TRACE_NUMA)\n    {\n      printf(\"info: numa_available() returns -1 => no numa support\\n\");\n    }\n    goto fail;\n  }\n\n  numa_max_node = (fun0)my_dlsym(handle, \"numa_max_node\");\n  numa_set_interleave_mask = (fun1)my_dlsym(handle, \"numa_set_interleave_mask\");\n  numa_set_strict = (fun2)my_dlsym(handle, \"numa_set_strict\");\n  numa_node_to_cpus = (fun3)my_dlsym(handle, \"numa_node_to_cpus\");\n  numa_all_nodes = (struct bitmask*)my_dlsym(handle, \"numa_all_nodes\");\n  numa_all_nodes_ptr = (struct bitmask*)my_dlsym(handle, \"numa_all_nodes_ptr\");\n  numa_allocate_nodemask = (fun4)my_dlsym(handle, \"numa_allocate_nodemask\");\n  numa_bitmask_free = (fun5)my_dlsym(handle, \"numa_bitmask_free\");\n  numa_bitmask_setall = (fun6)my_dlsym(handle, \"numa_bitmask_setall\");\n\n\n  return 0;\nfail:\n  dlclose(handle);\n  handle = 0;\n  return -1;\n}\n\nstatic\nbool\nbit_is_set(unsigned long * mask, int bit)\n{\n  int n = bit / (8 * sizeof(unsigned long));\n  int b = bit % (8 * sizeof(unsigned long));\n  return (mask[n] & (1UL << b)) != 0;\n}\n\nint\nNdbNuma::build_cputonodemap()\n{\n  int len = 512;\n  unsigned long * buf = (unsigned long*)malloc(len);\n  if (buf == 0)\n    return -1;\n\n  int m = (* numa_max_node)();\n  for (int i = 0; i <= m; i++)\n  {\nretry:\n    int r = (* numa_node_to_cpus)(i, buf, len);\n    if (r == -1)\n    {\n      if (errno != ERANGE)\n        goto fail;\n\n      len = len + 512;\n      if (len > 4096)\n        goto fail;\n\n      void * p = realloc(buf, len);\n      if (p == 0)\n        goto fail;\n\n      buf = (unsigned long*)p;\n      goto retry;\n    }\n    printf(\"node %d cpu(s): \", i);\n    for (int j = 0; j<8*len;j++)\n      if (bit_is_set(buf, j))\n        printf(\"%d \", j);\n    printf(\"\\n\");\n  }\n  free(buf);\n  return 0;\nfail:\n  free(buf);\n  return -1;\n}\n\nextern \"C\"\nint\nNdbNuma_setInterleaved()\n{\n  NdbNuma numa;\n  if (numa.open() == -1)\n    return -1;\n\n  if (numa.numa_set_interleave_mask == 0)\n    return -1;\n\n  if (numa.numa_all_nodes_ptr != 0)\n  {\n    /**\n     * libnuma v2\n     */\n    if (numa.numa_allocate_nodemask != 0 &&\n        numa.numa_bitmask_setall != 0 &&\n        numa.numa_bitmask_free != 0)\n    {\n      struct bitmask * bm = (* numa.numa_allocate_nodemask)();\n      if (bm != 0)\n      {\n        (* numa.numa_bitmask_setall)(bm);\n        (* numa.numa_set_interleave_mask)(bm);\n        (* numa.numa_bitmask_free)(bm);\n      }\n      else\n      {\n        return -1;\n      }\n    }\n    else\n    {\n      return -1;\n    }\n  }\n  else if (numa.numa_all_nodes != 0)\n  {\n    /**\n     * libnuma v1\n     */\n    (* numa.numa_set_interleave_mask)(numa.numa_all_nodes);\n  }\n  else\n  {\n    return -1;\n  }\n\n  return 0;\n}\n\n#else\nextern \"C\"\nint\nNdbNuma_setInterleaved()\n{\n  return -1;\n}\n#endif\n\n#ifdef TEST_NDBNUMA\n#include <NdbTap.hpp>\n\nTAPTEST(SetInterleaved)\n{\n  NDB_TRACE_NUMA = 1;\n  NdbNuma_setInterleaved();\n  return 1; // OK\n}\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/memcache/extra/memcached/daemon/memcached.c": "/* -*- Mode: C; tab-width: 4; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/*\n *  memcached - memory caching daemon\n *\n *       http://www.danga.com/memcached/\n *\n *  Copyright 2003 Danga Interactive, Inc.  All rights reserved.\n *\n *  Use and distribution licensed under the BSD license.  See\n *  the LICENSE file for full text.\n *\n *  Authors:\n *      Anatoly Vorobey <mellon@pobox.com>\n *      Brad Fitzpatrick <brad@danga.com>\n */\n#include \"config.h\"\n#include \"memcached.h\"\n#include \"memcached/extension_loggers.h\"\n#include \"utilities/engine_loader.h\"\n\n#include <signal.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <time.h>\n#include <assert.h>\n#include <limits.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <stddef.h>\n\nstatic inline void item_set_cas(const void *cookie, item *it, uint64_t cas) {\n    settings.engine.v1->item_set_cas(settings.engine.v0, cookie, it, cas);\n}\n\n/* The item must always be called \"it\" */\n#define SLAB_GUTS(conn, thread_stats, slab_op, thread_op) \\\n    thread_stats->slab_stats[info.clsid].slab_op++;\n\n#define THREAD_GUTS(conn, thread_stats, slab_op, thread_op) \\\n    thread_stats->thread_op++;\n\n#define THREAD_GUTS2(conn, thread_stats, slab_op, thread_op) \\\n    thread_stats->slab_op++; \\\n    thread_stats->thread_op++;\n\n#define SLAB_THREAD_GUTS(conn, thread_stats, slab_op, thread_op) \\\n    SLAB_GUTS(conn, thread_stats, slab_op, thread_op) \\\n    THREAD_GUTS(conn, thread_stats, slab_op, thread_op)\n\n#define STATS_INCR1(GUTS, conn, slab_op, thread_op, key, nkey) { \\\n    struct independent_stats *independent_stats = get_independent_stats(conn); \\\n    struct thread_stats *thread_stats = \\\n        &independent_stats->thread_stats[conn->thread->index]; \\\n    topkeys_t *topkeys = independent_stats->topkeys; \\\n    pthread_mutex_lock(&thread_stats->mutex); \\\n    GUTS(conn, thread_stats, slab_op, thread_op); \\\n    pthread_mutex_unlock(&thread_stats->mutex); \\\n    TK(topkeys, slab_op, key, nkey, current_time); \\\n}\n\n#define STATS_INCR(conn, op, key, nkey) \\\n    STATS_INCR1(THREAD_GUTS, conn, op, op, key, nkey)\n\n#define SLAB_INCR(conn, op, key, nkey) \\\n    STATS_INCR1(SLAB_GUTS, conn, op, op, key, nkey)\n\n#define STATS_TWO(conn, slab_op, thread_op, key, nkey) \\\n    STATS_INCR1(THREAD_GUTS2, conn, slab_op, thread_op, key, nkey)\n\n#define SLAB_TWO(conn, slab_op, thread_op, key, nkey) \\\n    STATS_INCR1(SLAB_THREAD_GUTS, conn, slab_op, thread_op, key, nkey)\n\n#define STATS_HIT(conn, op, key, nkey) \\\n    SLAB_TWO(conn, op##_hits, cmd_##op, key, nkey)\n\n#define STATS_MISS(conn, op, key, nkey) \\\n    STATS_TWO(conn, op##_misses, cmd_##op, key, nkey)\n\n#define STATS_NOKEY(conn, op) { \\\n    struct thread_stats *thread_stats = \\\n        get_thread_stats(conn); \\\n    pthread_mutex_lock(&thread_stats->mutex); \\\n    thread_stats->op++; \\\n    pthread_mutex_unlock(&thread_stats->mutex); \\\n}\n\n#define STATS_NOKEY2(conn, op1, op2) { \\\n    struct thread_stats *thread_stats = \\\n        get_thread_stats(conn); \\\n    pthread_mutex_lock(&thread_stats->mutex); \\\n    thread_stats->op1++; \\\n    thread_stats->op2++; \\\n    pthread_mutex_unlock(&thread_stats->mutex); \\\n}\n\n#define STATS_ADD(conn, op, amt) { \\\n    struct thread_stats *thread_stats = \\\n        get_thread_stats(conn); \\\n    pthread_mutex_lock(&thread_stats->mutex); \\\n    thread_stats->op += amt; \\\n    pthread_mutex_unlock(&thread_stats->mutex); \\\n}\n\nvolatile sig_atomic_t memcached_shutdown;\n\n/*\n * We keep the current time of day in a global variable that's updated by a\n * timer event. This saves us a bunch of time() system calls (we really only\n * need to get the time once a second, whereas there can be tens of thousands\n * of requests a second) and allows us to use server-start-relative timestamps\n * rather than absolute UNIX timestamps, a space savings on systems where\n * sizeof(time_t) > sizeof(unsigned int).\n */\nvolatile rel_time_t current_time;\n\n/*\n * forward declarations\n */\nstatic SOCKET new_socket(struct addrinfo *ai);\nstatic int try_read_command(conn *c);\nstatic inline struct independent_stats *get_independent_stats(conn *c);\nstatic inline struct thread_stats *get_thread_stats(conn *c);\nstatic void register_callback(ENGINE_HANDLE *eh,\n                              ENGINE_EVENT_TYPE type,\n                              EVENT_CALLBACK cb, const void *cb_data);\n\n\nenum try_read_result {\n    READ_DATA_RECEIVED,\n    READ_NO_DATA_RECEIVED,\n    READ_ERROR,            /** an error occurred (on the socket) (or client closed connection) */\n    READ_MEMORY_ERROR      /** failed to allocate more memory */\n};\n\nstatic enum try_read_result try_read_network(conn *c);\nstatic enum try_read_result try_read_udp(conn *c);\n\n/* stats */\nstatic void stats_init(void);\nstatic void server_stats(ADD_STAT add_stats, conn *c, bool aggregate);\nstatic void process_stat_settings(ADD_STAT add_stats, void *c);\n\n\n/* defaults */\nstatic void settings_init(void);\n\n/* event handling, network IO */\nstatic void event_handler(const int fd, const short which, void *arg);\nstatic void complete_nread(conn *c);\nstatic char *process_command(conn *c, char *command);\nstatic void write_and_free(conn *c, char *buf, int bytes);\nstatic int ensure_iov_space(conn *c);\nstatic int add_iov(conn *c, const void *buf, int len);\nstatic int add_msghdr(conn *c);\n\n\n/* time handling */\nstatic void set_current_time(void);  /* update the global variable holding\n                              global 32-bit seconds-since-start time\n                              (to avoid 64 bit time_t) */\n\n/** exported globals **/\nstruct stats stats;\nstruct settings settings;\nstatic time_t process_started;     /* when the process was started */\n\n/** file scope variables **/\nstatic conn *listen_conn = NULL;\nstatic struct event_base *main_base;\nstatic struct independent_stats *default_independent_stats;\n\nstatic struct engine_event_handler *engine_event_handlers[MAX_ENGINE_EVENT_TYPE + 1];\n\nenum transmit_result {\n    TRANSMIT_COMPLETE,   /** All done writing. */\n    TRANSMIT_INCOMPLETE, /** More data remaining to write. */\n    TRANSMIT_SOFT_ERROR, /** Can't write any more right now. */\n    TRANSMIT_HARD_ERROR  /** Can't write (c->state is set to conn_closing) */\n};\n\nstatic enum transmit_result transmit(conn *c);\n\n#define REALTIME_MAXDELTA 60*60*24*30\n\n// Perform all callbacks of a given type for the given connection.\nstatic void perform_callbacks(ENGINE_EVENT_TYPE type,\n                              const void *data,\n                              const void *c) {\n    for (struct engine_event_handler *h = engine_event_handlers[type];\n         h; h = h->next) {\n        h->cb(c, type, data, h->cb_data);\n    }\n}\n\n/*\n * given time value that's either unix time or delta from current unix time,\n * return unix time. Use the fact that delta can't exceed one month\n * (and real time value can't be that low).\n */\nstatic rel_time_t realtime(const time_t exptime) {\n    /* no. of seconds in 30 days - largest possible delta exptime */\n\n    if (exptime == 0) return 0; /* 0 means never expire */\n\n    if (exptime > REALTIME_MAXDELTA) {\n        /* if item expiration is at/before the server started, give it an\n           expiration time of 1 second after the server started.\n           (because 0 means don't expire).  without this, we'd\n           underflow and wrap around to some large value way in the\n           future, effectively making items expiring in the past\n           really expiring never */\n        if (exptime <= process_started)\n            return (rel_time_t)1;\n        return (rel_time_t)(exptime - process_started);\n    } else {\n        return (rel_time_t)(exptime + current_time);\n    }\n}\n\n/**\n * Convert the relative time to an absolute time (relative to EPOC ;) )\n */\nstatic time_t abstime(const rel_time_t exptime)\n{\n    return process_started + exptime;\n}\n\nstatic void stats_init(void) {\n    stats.daemon_conns = 0;\n    stats.rejected_conns = 0;\n    stats.curr_conns = stats.total_conns = stats.conn_structs = 0;\n\n    stats_prefix_init();\n}\n\nstatic void stats_reset(const void *cookie) {\n    struct conn *conn = (struct conn*)cookie;\n    STATS_LOCK();\n    stats.rejected_conns = 0;\n    stats.total_conns = 0;\n    stats_prefix_clear();\n    STATS_UNLOCK();\n    threadlocal_stats_reset(get_independent_stats(conn)->thread_stats);\n    settings.engine.v1->reset_stats(settings.engine.v0, cookie);\n}\n\nstatic void settings_init(void) {\n    settings.use_cas = true;\n    settings.access = 0700;\n    settings.port = 11211;\n    settings.udpport = 11211;\n    /* By default this string should be NULL for getaddrinfo() */\n    settings.inter = NULL;\n    settings.maxbytes = 64 * 1024 * 1024; /* default is 64MB */\n    settings.maxconns = 1000;         /* to limit connections-related memory to about 5MB */\n    settings.verbose = 0;\n    settings.oldest_live = 0;\n    settings.evict_to_free = 1;       /* push old items out of cache when memory runs out */\n    settings.socketpath = NULL;       /* by default, not using a unix socket */\n    settings.factor = 1.25;\n    settings.chunk_size = 48;         /* space for a modest key and value */\n    settings.num_threads = 4;         /* N workers */\n    settings.num_threads_per_udp = 0;\n    settings.prefix_delimiter = ':';\n    settings.detail_enabled = 0;\n    settings.allow_detailed = true;\n    settings.reqs_per_event = DEFAULT_REQS_PER_EVENT;\n    settings.backlog = 1024;\n    settings.binding_protocol = negotiating_prot;\n    settings.item_size_max = 1024 * 1024; /* The famous 1MB upper limit. */\n    settings.topkeys = 0;\n    settings.require_sasl = false;\n    settings.extensions.logger = get_stderr_logger();\n}\n\n/*\n * Adds a message header to a connection.\n *\n * Returns 0 on success, -1 on out-of-memory.\n */\nstatic int add_msghdr(conn *c)\n{\n    struct msghdr *msg;\n\n    assert(c != NULL);\n\n    if (c->msgsize == c->msgused) {\n        msg = realloc(c->msglist, c->msgsize * 2 * sizeof(struct msghdr));\n        if (! msg)\n            return -1;\n        c->msglist = msg;\n        c->msgsize *= 2;\n    }\n\n    msg = c->msglist + c->msgused;\n\n    /* this wipes msg_iovlen, msg_control, msg_controllen, and\n       msg_flags, the last 3 of which aren't defined on solaris: */\n    memset(msg, 0, sizeof(struct msghdr));\n\n    msg->msg_iov = &c->iov[c->iovused];\n\n    if (c->request_addr_size > 0) {\n        msg->msg_name = &c->request_addr;\n        msg->msg_namelen = c->request_addr_size;\n    }\n\n    c->msgbytes = 0;\n    c->msgused++;\n\n    if (IS_UDP(c->transport)) {\n        /* Leave room for the UDP header, which we'll fill in later. */\n        return add_iov(c, NULL, UDP_HEADER_SIZE);\n    }\n\n    return 0;\n}\n\nstatic const char *prot_text(enum protocol prot) {\n    const char *rv = \"unknown\";\n    switch(prot) {\n        case ascii_prot:\n            rv = \"ascii\";\n            break;\n        case binary_prot:\n            rv = \"binary\";\n            break;\n        case negotiating_prot:\n            rv = \"auto-negotiate\";\n            break;\n    }\n    return rv;\n}\n\nstruct {\n    pthread_mutex_t mutex;\n    bool disabled;\n    ssize_t count;\n    uint64_t num_disable;\n} listen_state = { .mutex = PTHREAD_MUTEX_INITIALIZER };\n\nstatic bool is_listen_disabled(void) {\n    bool ret;\n    pthread_mutex_lock(&listen_state.mutex);\n    ret = listen_state.disabled;\n    pthread_mutex_unlock(&listen_state.mutex);\n    return ret;\n}\n\nstatic uint64_t get_listen_disabled_num(void) {\n    uint64_t ret;\n    pthread_mutex_lock(&listen_state.mutex);\n    ret = listen_state.num_disable;\n    pthread_mutex_unlock(&listen_state.mutex);\n    return ret;\n}\n\nstatic void disable_listen(void) {\n    conn *next;\n    pthread_mutex_lock(&listen_state.mutex);\n    listen_state.disabled = true;\n    listen_state.count = 10;\n    ++listen_state.num_disable;\n    pthread_mutex_unlock(&listen_state.mutex);\n\n    for (next = listen_conn; next; next = next->next) {\n        update_event(next, 0);\n        if (listen(next->sfd, 1) != 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                            \"listen() failed\",\n                                            strerror(errno));\n        }\n    }\n}\n\nvoid safe_close(SOCKET sfd) {\n    if (sfd != INVALID_SOCKET) {\n        int rval;\n        while ((rval = closesocket(sfd)) == SOCKET_ERROR &&\n               (errno == EINTR || errno == EAGAIN)) {\n            /* go ahead and retry */\n        }\n\n        if (rval == SOCKET_ERROR) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                            \"Failed to close socket %d (%s)!!\\n\", (int)sfd,\n                                            strerror(errno));\n        } else {\n            STATS_LOCK();\n            stats.curr_conns--;\n            STATS_UNLOCK();\n\n            if (is_listen_disabled()) {\n                notify_dispatcher();\n            }\n        }\n    }\n}\n\n/*\n * Free list management for connections.\n */\ncache_t *conn_cache;      /* suffix cache */\n\n/**\n * Reset all of the dynamic buffers used by a connection back to their\n * default sizes. The strategy for resizing the buffers is to allocate a\n * new one of the correct size and free the old one if the allocation succeeds\n * instead of using realloc to change the buffer size (because realloc may\n * not shrink the buffers, and will also copy the memory). If the allocation\n * fails the buffer will be unchanged.\n *\n * @param c the connection to resize the buffers for\n * @return true if all allocations succeeded, false if one or more of the\n *         allocations failed.\n */\nstatic bool conn_reset_buffersize(conn *c) {\n    bool ret = true;\n\n    if (c->rsize != DATA_BUFFER_SIZE) {\n        void *ptr = malloc(DATA_BUFFER_SIZE);\n        if (ptr != NULL) {\n            free(c->rbuf);\n            c->rbuf = ptr;\n            c->rsize = DATA_BUFFER_SIZE;\n        } else {\n            ret = false;\n        }\n    }\n\n    if (c->wsize != DATA_BUFFER_SIZE) {\n        void *ptr = malloc(DATA_BUFFER_SIZE);\n        if (ptr != NULL) {\n            free(c->wbuf);\n            c->wbuf = ptr;\n            c->wsize = DATA_BUFFER_SIZE;\n        } else {\n            ret = false;\n        }\n    }\n\n    if (c->isize != ITEM_LIST_INITIAL) {\n        void *ptr = malloc(sizeof(item *) * ITEM_LIST_INITIAL);\n        if (ptr != NULL) {\n            free(c->ilist);\n            c->ilist = ptr;\n            c->isize = ITEM_LIST_INITIAL;\n        } else {\n            ret = false;\n        }\n    }\n\n    if (c->suffixsize != SUFFIX_LIST_INITIAL) {\n        void *ptr = malloc(sizeof(char *) * SUFFIX_LIST_INITIAL);\n        if (ptr != NULL) {\n            free(c->suffixlist);\n            c->suffixlist = ptr;\n            c->suffixsize = SUFFIX_LIST_INITIAL;\n        } else {\n            ret = false;\n        }\n    }\n\n    if (c->iovsize != IOV_LIST_INITIAL) {\n        void *ptr = malloc(sizeof(struct iovec) * IOV_LIST_INITIAL);\n        if (ptr != NULL) {\n            free(c->iov);\n            c->iov = ptr;\n            c->iovsize = IOV_LIST_INITIAL;\n        } else {\n            ret = false;\n        }\n    }\n\n    if (c->msgsize != MSG_LIST_INITIAL) {\n        void *ptr = malloc(sizeof(struct msghdr) * MSG_LIST_INITIAL);\n        if (ptr != NULL) {\n            free(c->msglist);\n            c->msglist = ptr;\n            c->msgsize = MSG_LIST_INITIAL;\n        } else {\n            ret = false;\n        }\n    }\n\n    return ret;\n}\n\n/**\n * Constructor for all memory allocations of connection objects. Initialize\n * all members and allocate the transfer buffers.\n *\n * @param buffer The memory allocated by the object cache\n * @param unused1 not used\n * @param unused2 not used\n * @return 0 on success, 1 if we failed to allocate memory\n */\nstatic int conn_constructor(void *buffer, void *unused1, int unused2) {\n    conn *c = buffer;\n    memset(c, 0, sizeof(*c));\n    MEMCACHED_CONN_CREATE(c);\n    (void)unused1; (void)unused2;\n\n    if (!conn_reset_buffersize(c)) {\n        free(c->rbuf);\n        free(c->wbuf);\n        free(c->ilist);\n        free(c->suffixlist);\n        free(c->iov);\n        free(c->msglist);\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING,\n                                        NULL,\n                                        \"Failed to allocate buffers for connection\\n\");\n        return 1;\n    }\n\n    STATS_LOCK();\n    stats.conn_structs++;\n    STATS_UNLOCK();\n\n    return 0;\n}\n\n/**\n * Destructor for all connection objects. Release all allocated resources.\n *\n * @param buffer The memory allocated by the objec cache\n * @param unused not used\n */\nstatic void conn_destructor(void *buffer, void *unused) {\n    conn *c = buffer;\n    free(c->rbuf);\n    free(c->wbuf);\n    free(c->ilist);\n    free(c->suffixlist);\n    free(c->iov);\n    free(c->msglist);\n\n    STATS_LOCK();\n    stats.conn_structs--;\n    STATS_UNLOCK();\n    (void)unused;\n}\n\nconn *conn_new(const SOCKET sfd, STATE_FUNC init_state,\n               const int event_flags,\n               const int read_buffer_size, enum network_transport transport,\n               struct event_base *base, struct timeval *timeout) {\n    conn *c = cache_alloc(conn_cache);\n    if (c == NULL) {\n        return NULL;\n    }\n\n    assert(c->thread == NULL);\n\n    if (c->rsize < read_buffer_size) {\n        void *mem = malloc(read_buffer_size);\n        if (mem) {\n            c->rsize = read_buffer_size;\n            free(c->rbuf);\n            c->rbuf = mem;\n        } else {\n            assert(c->thread == NULL);\n            cache_free(conn_cache, c);\n            return NULL;\n        }\n    }\n\n    c->transport = transport;\n    c->protocol = settings.binding_protocol;\n\n    if (IS_UDP(transport)) {\n        c->request_addr_size = sizeof(c->request_addr);\n    } else {\n        c->request_addr_size = 0;\n    }\n\n    if (settings.verbose > 1) {\n        if (init_state == conn_listening) {\n            settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                            \"<%d server listening (%s)\\n\", sfd,\n                                            prot_text(c->protocol));\n        } else if (IS_UDP(transport)) {\n            settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                            \"<%d server listening (udp)\\n\", sfd);\n        } else if (c->protocol == negotiating_prot) {\n            settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                            \"<%d new auto-negotiating client connection\\n\",\n                                            sfd);\n        } else if (c->protocol == ascii_prot) {\n            settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                            \"<%d new ascii client connection.\\n\", sfd);\n        } else if (c->protocol == binary_prot) {\n            settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                            \"<%d new binary client connection.\\n\", sfd);\n        } else {\n            settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                            \"<%d new unknown (%d) client connection\\n\",\n                                            sfd, c->protocol);\n            assert(false);\n        }\n    }\n\n    c->sfd = sfd;\n    c->state = init_state;\n    c->rlbytes = 0;\n    c->cmd = -1;\n    c->ascii_cmd = NULL;\n    c->rbytes = c->wbytes = 0;\n    c->wcurr = c->wbuf;\n    c->rcurr = c->rbuf;\n    c->ritem = 0;\n    c->icurr = c->ilist;\n    c->suffixcurr = c->suffixlist;\n    c->ileft = 0;\n    c->suffixleft = 0;\n    c->iovused = 0;\n    c->msgcurr = 0;\n    c->msgused = 0;\n    c->next = NULL;\n    c->list_state = 0;\n\n    c->write_and_go = init_state;\n    c->write_and_free = 0;\n    c->item = 0;\n\n    c->noreply = false;\n\n    event_set(&c->event, sfd, event_flags, event_handler, (void *)c);\n    event_base_set(base, &c->event);\n    c->ev_flags = event_flags;\n\n    if (!register_event(c, timeout)) {\n        assert(c->thread == NULL);\n        cache_free(conn_cache, c);\n        return NULL;\n    }\n\n    STATS_LOCK();\n    stats.total_conns++;\n    STATS_UNLOCK();\n\n    c->aiostat = ENGINE_SUCCESS;\n    c->ewouldblock = false;\n    c->refcount = 1;\n\n    MEMCACHED_CONN_ALLOCATE(c->sfd);\n\n    perform_callbacks(ON_CONNECT, NULL, c);\n\n    return c;\n}\n\nstatic void conn_cleanup(conn *c) {\n    assert(c != NULL);\n\n    if (c->item) {\n        settings.engine.v1->release(settings.engine.v0, c, c->item);\n        c->item = 0;\n    }\n\n    if (c->ileft != 0) {\n        for (; c->ileft > 0; c->ileft--,c->icurr++) {\n            settings.engine.v1->release(settings.engine.v0, c, *(c->icurr));\n        }\n    }\n\n    if (c->suffixleft != 0) {\n        for (; c->suffixleft > 0; c->suffixleft--, c->suffixcurr++) {\n            cache_free(c->thread->suffix_cache, *(c->suffixcurr));\n        }\n    }\n\n    if (c->write_and_free) {\n        free(c->write_and_free);\n        c->write_and_free = 0;\n    }\n\n    if (c->sasl_conn) {\n        sasl_dispose(&c->sasl_conn);\n        c->sasl_conn = NULL;\n    }\n\n    c->engine_storage = NULL;\n    c->tap_iterator = NULL;\n    c->thread = NULL;\n    assert(c->next == NULL);\n    c->ascii_cmd = NULL;\n    c->sfd = INVALID_SOCKET;\n}\n\nvoid conn_close(conn *c) {\n    assert(c != NULL);\n    assert(c->sfd == INVALID_SOCKET);\n\n    if (c->ascii_cmd != NULL) {\n        c->ascii_cmd->abort(c->ascii_cmd, c);\n    }\n\n    assert(c->thread);\n    LOCK_THREAD(c->thread);\n    /* remove from pending-io list */\n    if (settings.verbose > 1 && list_contains(c->thread->pending_io, c)) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                        \"Current connection was in the pending-io list.. Nuking it\\n\");\n    }\n    c->thread->pending_io = list_remove(c->thread->pending_io, c);\n    c->thread->pending_close = list_remove(c->thread->pending_close, c);\n    UNLOCK_THREAD(c->thread);\n\n    conn_cleanup(c);\n\n    /*\n     * The contract with the object cache is that we should return the\n     * object in a constructed state. Reset the buffers to the default\n     * size\n     */\n    conn_reset_buffersize(c);\n    assert(c->thread == NULL);\n    cache_free(conn_cache, c);\n}\n\n/*\n * Shrinks a connection's buffers if they're too big.  This prevents\n * periodic large \"get\" requests from permanently chewing lots of server\n * memory.\n *\n * This should only be called in between requests since it can wipe output\n * buffers!\n */\nstatic void conn_shrink(conn *c) {\n    assert(c != NULL);\n\n    if (IS_UDP(c->transport))\n        return;\n\n    if (c->rsize > READ_BUFFER_HIGHWAT && c->rbytes < DATA_BUFFER_SIZE) {\n        char *newbuf;\n\n        if (c->rcurr != c->rbuf)\n            memmove(c->rbuf, c->rcurr, (size_t)c->rbytes);\n\n        newbuf = (char *)realloc((void *)c->rbuf, DATA_BUFFER_SIZE);\n\n        if (newbuf) {\n            c->rbuf = newbuf;\n            c->rsize = DATA_BUFFER_SIZE;\n        }\n        /* TODO check other branch... */\n        c->rcurr = c->rbuf;\n    }\n\n    if (c->isize > ITEM_LIST_HIGHWAT) {\n        item **newbuf = (item**) realloc((void *)c->ilist, ITEM_LIST_INITIAL * sizeof(c->ilist[0]));\n        if (newbuf) {\n            c->ilist = newbuf;\n            c->isize = ITEM_LIST_INITIAL;\n        }\n    /* TODO check error condition? */\n    }\n\n    if (c->msgsize > MSG_LIST_HIGHWAT) {\n        struct msghdr *newbuf = (struct msghdr *) realloc((void *)c->msglist, MSG_LIST_INITIAL * sizeof(c->msglist[0]));\n        if (newbuf) {\n            c->msglist = newbuf;\n            c->msgsize = MSG_LIST_INITIAL;\n        }\n    /* TODO check error condition? */\n    }\n\n    if (c->iovsize > IOV_LIST_HIGHWAT) {\n        struct iovec *newbuf = (struct iovec *) realloc((void *)c->iov, IOV_LIST_INITIAL * sizeof(c->iov[0]));\n        if (newbuf) {\n            c->iov = newbuf;\n            c->iovsize = IOV_LIST_INITIAL;\n        }\n    /* TODO check return value */\n    }\n}\n\n/**\n * Convert a state name to a human readable form.\n */\nconst char *state_text(STATE_FUNC state) {\n    if (state == conn_listening) {\n        return \"conn_listening\";\n    } else if (state == conn_new_cmd) {\n        return \"conn_new_cmd\";\n    } else if (state == conn_waiting) {\n        return \"conn_waiting\";\n    } else if (state == conn_read) {\n        return \"conn_read\";\n    } else if (state == conn_parse_cmd) {\n        return \"conn_parse_cmd\";\n    } else if (state == conn_write) {\n        return \"conn_write\";\n    } else if (state == conn_nread) {\n        return \"conn_nread\";\n    } else if (state == conn_swallow) {\n        return \"conn_swallow\";\n    } else if (state == conn_closing) {\n        return \"conn_closing\";\n    } else if (state == conn_mwrite) {\n        return \"conn_mwrite\";\n    } else if (state == conn_ship_log) {\n        return \"conn_ship_log\";\n    } else if (state == conn_add_tap_client) {\n        return \"conn_add_tap_client\";\n    } else if (state == conn_setup_tap_stream) {\n        return \"conn_setup_tap_stream\";\n    } else if (state == conn_pending_close) {\n        return \"conn_pending_close\";\n    } else if (state == conn_immediate_close) {\n        return \"conn_immediate_close\";\n    } else {\n        return \"Unknown\";\n    }\n}\n\n/*\n * Sets a connection's current state in the state machine. Any special\n * processing that needs to happen on certain state transitions can\n * happen here.\n */\nvoid conn_set_state(conn *c, STATE_FUNC state) {\n    assert(c != NULL);\n\n    if (state != c->state) {\n        /*\n         * The connections in the \"tap thread\" behaves differently than\n         * normal connections because they operate in a full duplex mode.\n         * New messages may appear from both sides, so we can't block on\n         * read from the nework / engine\n         */\n        if (c->thread == tap_thread) {\n            if (state == conn_waiting) {\n                c->which = EV_WRITE;\n                state = conn_ship_log;\n            }\n        }\n\n        if (settings.verbose > 2 || c->state == conn_closing\n            || c->state == conn_add_tap_client) {\n            settings.extensions.logger->log(EXTENSION_LOG_DETAIL, c,\n                                            \"%d: going from %s to %s\\n\",\n                                            c->sfd, state_text(c->state),\n                                            state_text(state));\n        }\n\n        if (state == conn_write || state == conn_mwrite) {\n            MEMCACHED_PROCESS_COMMAND_END(c->sfd, c->wbuf, c->wbytes);\n        }\n\n        c->state = state;\n    }\n}\n\n/*\n * Ensures that there is room for another struct iovec in a connection's\n * iov list.\n *\n * Returns 0 on success, -1 on out-of-memory.\n */\nstatic int ensure_iov_space(conn *c) {\n    assert(c != NULL);\n\n    if (c->iovused >= c->iovsize) {\n        int i, iovnum;\n        struct iovec *new_iov = (struct iovec *)realloc(c->iov,\n                                (c->iovsize * 2) * sizeof(struct iovec));\n        if (! new_iov)\n            return -1;\n        c->iov = new_iov;\n        c->iovsize *= 2;\n\n        /* Point all the msghdr structures at the new list. */\n        for (i = 0, iovnum = 0; i < c->msgused; i++) {\n            c->msglist[i].msg_iov = &c->iov[iovnum];\n            iovnum += c->msglist[i].msg_iovlen;\n        }\n    }\n\n    return 0;\n}\n\n\n/*\n * Adds data to the list of pending data that will be written out to a\n * connection.\n *\n * Returns 0 on success, -1 on out-of-memory.\n */\n\nstatic int add_iov(conn *c, const void *buf, int len) {\n    struct msghdr *m;\n    int leftover;\n    bool limit_to_mtu;\n\n    assert(c != NULL);\n\n    do {\n        m = &c->msglist[c->msgused - 1];\n\n        /*\n         * Limit UDP packets, and the first payloads of TCP replies, to\n         * UDP_MAX_PAYLOAD_SIZE bytes.\n         */\n        limit_to_mtu = IS_UDP(c->transport) || (1 == c->msgused);\n\n        /* We may need to start a new msghdr if this one is full. */\n        if (m->msg_iovlen == IOV_MAX ||\n            (limit_to_mtu && c->msgbytes >= UDP_MAX_PAYLOAD_SIZE)) {\n            add_msghdr(c);\n            m = &c->msglist[c->msgused - 1];\n        }\n\n        if (ensure_iov_space(c) != 0)\n            return -1;\n\n        /* If the fragment is too big to fit in the datagram, split it up */\n        if (limit_to_mtu && len + c->msgbytes > UDP_MAX_PAYLOAD_SIZE) {\n            leftover = len + c->msgbytes - UDP_MAX_PAYLOAD_SIZE;\n            len -= leftover;\n        } else {\n            leftover = 0;\n        }\n\n        m = &c->msglist[c->msgused - 1];\n        m->msg_iov[m->msg_iovlen].iov_base = (void *)buf;\n        m->msg_iov[m->msg_iovlen].iov_len = len;\n\n        c->msgbytes += len;\n        c->iovused++;\n        m->msg_iovlen++;\n\n        buf = ((char *)buf) + len;\n        len = leftover;\n    } while (leftover > 0);\n\n    return 0;\n}\n\n\n/*\n * Constructs a set of UDP headers and attaches them to the outgoing messages.\n */\nstatic int build_udp_headers(conn *c) {\n    int i;\n    unsigned char *hdr;\n\n    assert(c != NULL);\n\n    if (c->msgused > c->hdrsize) {\n        void *new_hdrbuf;\n        if (c->hdrbuf)\n            new_hdrbuf = realloc(c->hdrbuf, c->msgused * 2 * UDP_HEADER_SIZE);\n        else\n            new_hdrbuf = malloc(c->msgused * 2 * UDP_HEADER_SIZE);\n        if (! new_hdrbuf)\n            return -1;\n        c->hdrbuf = (unsigned char *)new_hdrbuf;\n        c->hdrsize = c->msgused * 2;\n    }\n\n    hdr = c->hdrbuf;\n    for (i = 0; i < c->msgused; i++) {\n        c->msglist[i].msg_iov[0].iov_base = (void*)hdr;\n        c->msglist[i].msg_iov[0].iov_len = UDP_HEADER_SIZE;\n        *hdr++ = c->request_id / 256;\n        *hdr++ = c->request_id % 256;\n        *hdr++ = i / 256;\n        *hdr++ = i % 256;\n        *hdr++ = c->msgused / 256;\n        *hdr++ = c->msgused % 256;\n        *hdr++ = 0;\n        *hdr++ = 0;\n        assert((void *) hdr == (caddr_t)c->msglist[i].msg_iov[0].iov_base + UDP_HEADER_SIZE);\n    }\n\n    return 0;\n}\n\n\nstatic void out_string(conn *c, const char *str) {\n    size_t len;\n\n    assert(c != NULL);\n\n    if (c->noreply) {\n        if (settings.verbose > 1) {\n            settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                            \">%d NOREPLY %s\\n\", c->sfd, str);\n        }\n        c->noreply = false;\n        if (c->sbytes > 0) {\n            conn_set_state(c, conn_swallow);\n        } else {\n            conn_set_state(c, conn_new_cmd);\n        }\n        return;\n    }\n\n    if (settings.verbose > 1) {\n        settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                        \">%d %s\\n\", c->sfd, str);\n    }\n\n    /* Nuke a partial output... */\n    c->msgcurr = 0;\n    c->msgused = 0;\n    c->iovused = 0;\n    add_msghdr(c);\n\n    len = strlen(str);\n    if ((len + 2) > c->wsize) {\n        /* ought to be always enough. just fail for simplicity */\n        str = \"SERVER_ERROR output line too long\";\n        len = strlen(str);\n    }\n\n    memcpy(c->wbuf, str, len);\n    memcpy(c->wbuf + len, \"\\r\\n\", 2);\n    c->wbytes = len + 2;\n    c->wcurr = c->wbuf;\n\n    conn_set_state(c, conn_write);\n\n    if (c->sbytes > 0) {\n        c->write_and_go = conn_swallow;\n    } else {\n        c->write_and_go = conn_new_cmd;\n    }\n\n    return;\n}\n\n/*\n * we get here after reading the value in set/add/replace commands. The command\n * has been stored in c->cmd, and the item is ready in c->item.\n */\nstatic void complete_update_ascii(conn *c) {\n    assert(c != NULL);\n\n    item *it = c->item;\n    item_info info = { .nvalue = 1 };\n    if (!settings.engine.v1->get_item_info(settings.engine.v0, c, it, &info)) {\n        settings.engine.v1->release(settings.engine.v0, c, it);\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                        \"%d: Failed to get item info\\n\",\n                                        c->sfd);\n        out_string(c, \"SERVER_ERROR failed to get item details\");\n        return;\n    }\n\n    c->sbytes = 2; // swallow \\r\\n\n    ENGINE_ERROR_CODE ret = c->aiostat;\n    c->aiostat = ENGINE_SUCCESS;\n    if (ret == ENGINE_SUCCESS) {\n        ret = settings.engine.v1->store(settings.engine.v0, c, it, &c->cas,\n                                        c->store_op, 0);\n    }\n\n#ifdef ENABLE_DTRACE\n    switch (c->store_op) {\n    case OPERATION_ADD:\n        MEMCACHED_COMMAND_ADD(c->sfd, info.key, info.nkey,\n                              (ret == ENGINE_SUCCESS) ? info.nbytes : -1, c->cas);\n        break;\n    case OPERATION_REPLACE:\n        MEMCACHED_COMMAND_REPLACE(c->sfd, info.key, info.nkey,\n                                  (ret == ENGINE_SUCCESS) ? info.nbytes : -1, c->cas);\n        break;\n    case OPERATION_APPEND:\n        MEMCACHED_COMMAND_APPEND(c->sfd, info.key, info.nkey,\n                                 (ret == ENGINE_SUCCESS) ? info.nbytes : -1, c->cas);\n        break;\n    case OPERATION_PREPEND:\n        MEMCACHED_COMMAND_PREPEND(c->sfd, info.key, info.nkey,\n                                  (ret == ENGINE_SUCCESS) ? info.nbytes : -1, c->cas);\n        break;\n    case OPERATION_SET:\n        MEMCACHED_COMMAND_SET(c->sfd, info.key, info.nkey,\n                              (ret == ENGINE_SUCCESS) ? info.nbytes : -1, c->cas);\n        break;\n    case OPERATION_CAS:\n        MEMCACHED_COMMAND_CAS(c->sfd, info.key, info.nkey, info.nbytes, c->cas);\n        break;\n    }\n#endif\n\n    switch (ret) {\n    case ENGINE_SUCCESS:\n        out_string(c, \"STORED\");\n        break;\n    case ENGINE_KEY_EEXISTS:\n        out_string(c, \"EXISTS\");\n        break;\n    case ENGINE_KEY_ENOENT:\n        out_string(c, \"NOT_FOUND\");\n        break;\n    case ENGINE_NOT_STORED:\n        out_string(c, \"NOT_STORED\");\n        break;\n    case ENGINE_DISCONNECT:\n        c->state = conn_closing;\n        break;\n    case ENGINE_ENOTSUP:\n        out_string(c, \"SERVER_ERROR not supported\");\n        break;\n    case ENGINE_ENOMEM:\n        out_string(c, \"SERVER_ERROR out of memory\");\n        break;\n    case ENGINE_TMPFAIL:\n        out_string(c, \"SERVER_ERROR temporary failure\");\n        break;\n    case ENGINE_EINVAL:\n        out_string(c, \"CLIENT_ERROR invalid arguments\");\n        break;\n    case ENGINE_E2BIG:\n        out_string(c, \"CLIENT_ERROR value too big\");\n        break;\n    case ENGINE_EACCESS:\n        out_string(c, \"CLIENT_ERROR access control violation\");\n        break;\n    case ENGINE_NOT_MY_VBUCKET:\n        out_string(c, \"SERVER_ERROR not my vbucket\");\n        break;\n    case ENGINE_FAILED:\n        out_string(c, \"SERVER_ERROR failure\");\n        break;\n    case ENGINE_EWOULDBLOCK:\n        c->ewouldblock = true;\n        break;\n    case ENGINE_WANT_MORE:\n        assert(false);\n        c->state = conn_closing;\n        break;\n\n    default:\n        out_string(c, \"SERVER_ERROR internal\");\n    }\n\n    if (c->store_op == OPERATION_CAS) {\n        switch (ret) {\n        case ENGINE_SUCCESS:\n            SLAB_INCR(c, cas_hits, info.key, info.nkey);\n            break;\n        case ENGINE_KEY_EEXISTS:\n            SLAB_INCR(c, cas_badval, info.key, info.nkey);\n            break;\n        case ENGINE_KEY_ENOENT:\n            STATS_NOKEY(c, cas_misses);\n            break;\n        default:\n            ;\n        }\n    } else {\n        SLAB_INCR(c, cmd_set, info.key, info.nkey);\n    }\n\n    if (!c->ewouldblock) {\n        /* release the c->item reference */\n        settings.engine.v1->release(settings.engine.v0, c, c->item);\n        c->item = 0;\n    }\n}\n\n/**\n * get a pointer to the start of the request struct for the current command\n */\nstatic void* binary_get_request(conn *c) {\n    char *ret = c->rcurr;\n    ret -= (sizeof(c->binary_header) + c->binary_header.request.keylen +\n            c->binary_header.request.extlen);\n\n    assert(ret >= c->rbuf);\n    return ret;\n}\n\n/**\n * get a pointer to the key in this request\n */\nstatic char* binary_get_key(conn *c) {\n    return c->rcurr - (c->binary_header.request.keylen);\n}\n\n/**\n * Insert a key into a buffer, but replace all non-printable characters\n * with a '.'.\n *\n * @param dest where to store the output\n * @param destsz size of destination buffer\n * @param prefix string to insert before the data\n * @param client the client we are serving\n * @param from_client set to true if this data is from the client\n * @param key the key to add to the buffer\n * @param nkey the number of bytes in the key\n * @return number of bytes in dest if success, -1 otherwise\n */\nstatic ssize_t key_to_printable_buffer(char *dest, size_t destsz,\n                                       int client, bool from_client,\n                                       const char *prefix,\n                                       const char *key,\n                                       size_t nkey)\n{\n    ssize_t nw = snprintf(dest, destsz, \"%c%d %s \", from_client ? '>' : '<',\n                          client, prefix);\n    size_t ii;\n    char *ptr = dest + nw;\n    if (nw == -1) {\n        return -1;\n    }\n\n    destsz -= nw;\n    if (nkey > destsz) {\n        nkey = destsz;\n    }\n\n    for (ii = 0; ii < nkey; ++ii, ++key, ++ptr) {\n        if (isgraph(*key)) {\n            *ptr = *key;\n        } else {\n            *ptr = '.';\n        }\n    }\n\n    *ptr = '\\0';\n    return ptr - dest;\n}\n\n/**\n * Convert a byte array to a text string\n *\n * @param dest where to store the output\n * @param destsz size of destination buffer\n * @param prefix string to insert before the data\n * @param client the client we are serving\n * @param from_client set to true if this data is from the client\n * @param data the data to add to the buffer\n * @param size the number of bytes in data to print\n * @return number of bytes in dest if success, -1 otherwise\n */\nstatic ssize_t bytes_to_output_string(char *dest, size_t destsz,\n                                      int client, bool from_client,\n                                      const char *prefix,\n                                      const char *data,\n                                      size_t size)\n{\n    ssize_t nw = snprintf(dest, destsz, \"%c%d %s\", from_client ? '>' : '<',\n                          client, prefix);\n    size_t ii;\n    ssize_t offset = nw;\n    if (nw == -1) {\n        return -1;\n    }\n\n    for (ii = 0; ii < size; ++ii) {\n        if (ii % 4 == 0) {\n            if ((nw = snprintf(dest + offset, destsz - offset, \"\\n%c%d  \",\n                               from_client ? '>' : '<', client)) == -1) {\n                return  -1;\n            }\n            offset += nw;\n        }\n        if ((nw = snprintf(dest + offset, destsz - offset,\n                           \" 0x%02x\", (unsigned char)data[ii])) == -1) {\n            return -1;\n        }\n        offset += nw;\n    }\n\n    if ((nw = snprintf(dest + offset, destsz - offset, \"\\n\")) == -1) {\n        return -1;\n    }\n\n    return offset + nw;\n}\n\nstatic void add_bin_header(conn *c, uint16_t err, uint8_t hdr_len, uint16_t key_len, uint32_t body_len) {\n    protocol_binary_response_header* header;\n\n    assert(c);\n\n    c->msgcurr = 0;\n    c->msgused = 0;\n    c->iovused = 0;\n    if (add_msghdr(c) != 0) {\n        /* XXX:  out_string is inappropriate here */\n        out_string(c, \"SERVER_ERROR out of memory\");\n        return;\n    }\n\n    header = (protocol_binary_response_header *)c->wbuf;\n\n    header->response.magic = (uint8_t)PROTOCOL_BINARY_RES;\n    header->response.opcode = c->binary_header.request.opcode;\n    header->response.keylen = (uint16_t)htons(key_len);\n\n    header->response.extlen = (uint8_t)hdr_len;\n    header->response.datatype = (uint8_t)PROTOCOL_BINARY_RAW_BYTES;\n    header->response.status = (uint16_t)htons(err);\n\n    header->response.bodylen = htonl(body_len);\n    header->response.opaque = c->opaque;\n    header->response.cas = htonll(c->cas);\n\n    if (settings.verbose > 1) {\n        char buffer[1024];\n        if (bytes_to_output_string(buffer, sizeof(buffer), c->sfd, false,\n                                   \"Writing bin response:\",\n                                   (const char*)header->bytes,\n                                   sizeof(header->bytes)) != -1) {\n            settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                            \"%s\", buffer);\n        }\n    }\n\n    add_iov(c, c->wbuf, sizeof(header->response));\n}\n\n/**\n * Convert an error code generated from the storage engine to the corresponding\n * error code used by the protocol layer.\n * @param e the error code as used in the engine\n * @return the error code as used by the protocol layer\n */\nstatic protocol_binary_response_status engine_error_2_protocol_error(ENGINE_ERROR_CODE e) {\n    protocol_binary_response_status ret;\n\n    switch (e) {\n    case ENGINE_SUCCESS:\n        return PROTOCOL_BINARY_RESPONSE_SUCCESS;\n    case ENGINE_KEY_ENOENT:\n        return PROTOCOL_BINARY_RESPONSE_KEY_ENOENT;\n    case ENGINE_KEY_EEXISTS:\n        return PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS;\n    case ENGINE_ENOMEM:\n        return PROTOCOL_BINARY_RESPONSE_ENOMEM;\n    case ENGINE_TMPFAIL:\n        return PROTOCOL_BINARY_RESPONSE_ETMPFAIL;\n    case ENGINE_NOT_STORED:\n        return PROTOCOL_BINARY_RESPONSE_NOT_STORED;\n    case ENGINE_EINVAL:\n        return PROTOCOL_BINARY_RESPONSE_EINVAL;\n    case ENGINE_ENOTSUP:\n        return PROTOCOL_BINARY_RESPONSE_NOT_SUPPORTED;\n    case ENGINE_E2BIG:\n        return PROTOCOL_BINARY_RESPONSE_E2BIG;\n    case ENGINE_NOT_MY_VBUCKET:\n        return PROTOCOL_BINARY_RESPONSE_NOT_MY_VBUCKET;\n    case ENGINE_ERANGE:\n        return PROTOCOL_BINARY_RESPONSE_ERANGE;\n    default:\n        ret = PROTOCOL_BINARY_RESPONSE_EINTERNAL;\n    }\n\n    return ret;\n}\n\nstatic void write_bin_packet(conn *c, protocol_binary_response_status err, int swallow) {\n    ssize_t len;\n    char buffer[1024] = { [sizeof(buffer) - 1] = '\\0' };\n\n    switch (err) {\n    case PROTOCOL_BINARY_RESPONSE_SUCCESS:\n        len = 0;\n        break;\n    case PROTOCOL_BINARY_RESPONSE_ENOMEM:\n        len = snprintf(buffer, sizeof(buffer), \"Out of memory\");\n        break;\n    case PROTOCOL_BINARY_RESPONSE_ETMPFAIL:\n        len = snprintf(buffer, sizeof(buffer), \"Temporary failure\");\n        break;\n    case PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND:\n        len = snprintf(buffer, sizeof(buffer), \"Unknown command\");\n        break;\n    case PROTOCOL_BINARY_RESPONSE_KEY_ENOENT:\n        len = snprintf(buffer, sizeof(buffer), \"Not found\");\n        break;\n    case PROTOCOL_BINARY_RESPONSE_EINVAL:\n        len = snprintf(buffer, sizeof(buffer), \"Invalid arguments\");\n        break;\n    case PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS:\n        len = snprintf(buffer, sizeof(buffer), \"Data exists for key\");\n        break;\n    case PROTOCOL_BINARY_RESPONSE_E2BIG:\n        len = snprintf(buffer, sizeof(buffer), \"Too large\");\n        break;\n    case PROTOCOL_BINARY_RESPONSE_DELTA_BADVAL:\n        len = snprintf(buffer, sizeof(buffer),\n                       \"Non-numeric server-side value for incr or decr\");\n        break;\n    case PROTOCOL_BINARY_RESPONSE_NOT_STORED:\n        len = snprintf(buffer, sizeof(buffer), \"Not stored\");\n        break;\n    case PROTOCOL_BINARY_RESPONSE_AUTH_ERROR:\n        len = snprintf(buffer, sizeof(buffer), \"Auth failure\");\n        break;\n    case PROTOCOL_BINARY_RESPONSE_NOT_SUPPORTED:\n        len = snprintf(buffer, sizeof(buffer), \"Not supported\");\n        break;\n    case PROTOCOL_BINARY_RESPONSE_NOT_MY_VBUCKET:\n        len = snprintf(buffer, sizeof(buffer),\n                       \"I'm not responsible for this vbucket\");\n        break;\n\n    default:\n        len = snprintf(buffer, sizeof(buffer), \"UNHANDLED ERROR (%d)\", err);\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                        \">%d UNHANDLED ERROR: %d\\n\", c->sfd, err);\n    }\n\n    /* Allow the engine to pass extra error information */\n    if (settings.engine.v1->errinfo != NULL) {\n        size_t elen = settings.engine.v1->errinfo(settings.engine.v0, c, buffer + len + 2,\n                                                  sizeof(buffer) - len - 3);\n\n        if (elen > 0) {\n            memcpy(buffer + len, \": \", 2);\n            len += elen + 2;\n        }\n    }\n\n    if (err != PROTOCOL_BINARY_RESPONSE_SUCCESS && settings.verbose > 1) {\n        settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                        \">%d Writing an error: %s\\n\", c->sfd,\n                                        buffer);\n    }\n\n    add_bin_header(c, err, 0, 0, len);\n    if (len > 0) {\n        add_iov(c, buffer, len);\n    }\n    conn_set_state(c, conn_mwrite);\n    if (swallow > 0) {\n        c->sbytes = swallow;\n        c->write_and_go = conn_swallow;\n    } else {\n        c->write_and_go = conn_new_cmd;\n    }\n}\n\n/* Form and send a response to a command over the binary protocol */\nstatic void write_bin_response(conn *c, const void *d, int hlen, int keylen, int dlen) {\n    if (!c->noreply || c->cmd == PROTOCOL_BINARY_CMD_GET ||\n        c->cmd == PROTOCOL_BINARY_CMD_GETK) {\n        add_bin_header(c, 0, hlen, keylen, dlen);\n        if(dlen > 0) {\n            add_iov(c, d, dlen);\n        }\n        conn_set_state(c, conn_mwrite);\n        c->write_and_go = conn_new_cmd;\n    } else {\n        conn_set_state(c, conn_new_cmd);\n    }\n}\n\n\nstatic void complete_incr_bin(conn *c) {\n    protocol_binary_response_incr* rsp = (protocol_binary_response_incr*)c->wbuf;\n    protocol_binary_request_incr* req = binary_get_request(c);\n\n    assert(c != NULL);\n    assert(c->wsize >= sizeof(*rsp));\n\n    /* fix byteorder in the request */\n    uint64_t delta = ntohll(req->message.body.delta);\n    uint64_t initial = ntohll(req->message.body.initial);\n    rel_time_t expiration = ntohl(req->message.body.expiration);\n    char *key = binary_get_key(c);\n    size_t nkey = c->binary_header.request.keylen;\n    bool incr = (c->cmd == PROTOCOL_BINARY_CMD_INCREMENT ||\n                 c->cmd == PROTOCOL_BINARY_CMD_INCREMENTQ);\n\n    if (settings.verbose > 1) {\n        char buffer[1024];\n        ssize_t nw;\n        nw = key_to_printable_buffer(buffer, sizeof(buffer), c->sfd, true,\n                                     incr ? \"INCR\" : \"DECR\", key, nkey);\n        if (nw != -1) {\n            if (snprintf(buffer + nw, sizeof(buffer) - nw,\n                         \" %\" PRIu64 \", %\" PRIu64 \", %\" PRIu64 \"\\n\",\n                         delta, initial, (uint64_t)expiration) != -1) {\n                settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c, \"%s\",\n                                                buffer);\n            }\n        }\n    }\n\n    ENGINE_ERROR_CODE ret = c->aiostat;\n    c->aiostat = ENGINE_SUCCESS;\n    if (ret == ENGINE_SUCCESS) {\n        ret = settings.engine.v1->arithmetic(settings.engine.v0,\n                                             c, key, nkey, incr,\n                                             req->message.body.expiration != 0xffffffff,\n                                             delta, initial, expiration,\n                                             &c->cas,\n                                             &rsp->message.body.value,\n                                             c->binary_header.request.vbucket);\n    }\n\n    switch (ret) {\n    case ENGINE_SUCCESS:\n        rsp->message.body.value = htonll(rsp->message.body.value);\n        write_bin_response(c, &rsp->message.body, 0, 0,\n                           sizeof (rsp->message.body.value));\n        if (incr) {\n            STATS_INCR(c, incr_hits, key, nkey);\n        } else {\n            STATS_INCR(c, decr_hits, key, nkey);\n        }\n        break;\n    case ENGINE_KEY_EEXISTS:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS, 0);\n        break;\n    case ENGINE_KEY_ENOENT:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, 0);\n        if (c->cmd == PROTOCOL_BINARY_CMD_INCREMENT) {\n            STATS_INCR(c, incr_misses, key, nkey);\n        } else {\n            STATS_INCR(c, decr_misses, key, nkey);\n        }\n        break;\n    case ENGINE_ENOMEM:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, 0);\n        break;\n    case ENGINE_TMPFAIL:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_ETMPFAIL, 0);\n        break;\n    case ENGINE_EINVAL:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_DELTA_BADVAL, 0);\n        break;\n    case ENGINE_NOT_STORED:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_NOT_STORED, 0);\n        break;\n    case ENGINE_DISCONNECT:\n        c->state = conn_closing;\n        break;\n    case ENGINE_ENOTSUP:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_NOT_SUPPORTED, 0);\n        break;\n    case ENGINE_NOT_MY_VBUCKET:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_NOT_MY_VBUCKET, 0);\n        break;\n    case ENGINE_EWOULDBLOCK:\n        c->ewouldblock = true;\n        break;\n    default:\n        abort();\n    }\n}\n\nstatic void complete_update_bin(conn *c) {\n    protocol_binary_response_status eno = PROTOCOL_BINARY_RESPONSE_EINVAL;\n    assert(c != NULL);\n\n    item *it = c->item;\n    item_info info = { .nvalue = 1 };\n    if (!settings.engine.v1->get_item_info(settings.engine.v0, c, it, &info)) {\n        settings.engine.v1->release(settings.engine.v0, c, it);\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                        \"%d: Failed to get item info\\n\",\n                                        c->sfd);\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_EINTERNAL, 0);\n        return;\n    }\n\n    ENGINE_ERROR_CODE ret = c->aiostat;\n    c->aiostat = ENGINE_SUCCESS;\n    if (ret == ENGINE_SUCCESS) {\n        ret = settings.engine.v1->store(settings.engine.v0, c,\n                                        it, &c->cas, c->store_op,\n                                        c->binary_header.request.vbucket);\n    }\n\n#ifdef ENABLE_DTRACE\n    switch (c->cmd) {\n    case OPERATION_ADD:\n        MEMCACHED_COMMAND_ADD(c->sfd, info.key, info.nkey,\n                              (ret == ENGINE_SUCCESS) ? info.nbytes : -1, c->cas);\n        break;\n    case OPERATION_REPLACE:\n        MEMCACHED_COMMAND_REPLACE(c->sfd, info.key, info.nkey,\n                                  (ret == ENGINE_SUCCESS) ? info.nbytes : -1, c->cas);\n        break;\n    case OPERATION_APPEND:\n        MEMCACHED_COMMAND_APPEND(c->sfd, info.key, info.nkey,\n                                 (ret == ENGINE_SUCCESS) ? info.nbytes : -1, c->cas);\n        break;\n    case OPERATION_PREPEND:\n        MEMCACHED_COMMAND_PREPEND(c->sfd, info.key, info.nkey,\n                                  (ret == ENGINE_SUCCESS) ? info.nbytes : -1, c->cas);\n        break;\n    case OPERATION_SET:\n        MEMCACHED_COMMAND_SET(c->sfd, info.key, info.nkey,\n                              (ret == ENGINE_SUCCESS) ? info.nbytes : -1, c->cas);\n        break;\n    }\n#endif\n\n    switch (ret) {\n    case ENGINE_SUCCESS:\n        /* Stored */\n        write_bin_response(c, NULL, 0, 0, 0);\n        break;\n    case ENGINE_KEY_EEXISTS:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS, 0);\n        break;\n    case ENGINE_KEY_ENOENT:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, 0);\n        break;\n    case ENGINE_ENOMEM:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, 0);\n        break;\n    case ENGINE_TMPFAIL:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_ETMPFAIL, 0);\n        break;\n    case ENGINE_EWOULDBLOCK:\n        c->ewouldblock = true;\n        break;\n    case ENGINE_DISCONNECT:\n        c->state = conn_closing;\n        break;\n    case ENGINE_ENOTSUP:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_NOT_SUPPORTED, 0);\n        break;\n    case ENGINE_NOT_MY_VBUCKET:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_NOT_MY_VBUCKET, 0);\n        break;\n    default:\n        if (c->store_op == OPERATION_ADD) {\n            eno = PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS;\n        } else if(c->store_op == OPERATION_REPLACE) {\n            eno = PROTOCOL_BINARY_RESPONSE_KEY_ENOENT;\n        } else {\n            eno = PROTOCOL_BINARY_RESPONSE_NOT_STORED;\n        }\n        write_bin_packet(c, eno, 0);\n    }\n\n    if (c->store_op == OPERATION_CAS) {\n        switch (ret) {\n        case ENGINE_SUCCESS:\n            SLAB_INCR(c, cas_hits, info.key, info.nkey);\n            break;\n        case ENGINE_KEY_EEXISTS:\n            SLAB_INCR(c, cas_badval, info.key, info.nkey);\n            break;\n        case ENGINE_KEY_ENOENT:\n            STATS_NOKEY(c, cas_misses);\n            break;\n        default:\n            ;\n        }\n    } else {\n        SLAB_INCR(c, cmd_set, info.key, info.nkey);\n    }\n\n    if (!c->ewouldblock) {\n        /* release the c->item reference */\n        settings.engine.v1->release(settings.engine.v0, c, c->item);\n        c->item = 0;\n    }\n}\n\nstatic void process_bin_get(conn *c) {\n    item *it;\n\n    protocol_binary_response_get* rsp = (protocol_binary_response_get*)c->wbuf;\n    char* key = binary_get_key(c);\n    size_t nkey = c->binary_header.request.keylen;\n\n    if (settings.verbose > 1) {\n        char buffer[1024];\n        if (key_to_printable_buffer(buffer, sizeof(buffer), c->sfd, true,\n                                    \"GET\", key, nkey) != -1) {\n            settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c, \"%s\\n\",\n                                            buffer);\n        }\n    }\n\n    ENGINE_ERROR_CODE ret = c->aiostat;\n    c->aiostat = ENGINE_SUCCESS;\n    if (ret == ENGINE_SUCCESS) {\n        ret = settings.engine.v1->get(settings.engine.v0, c, &it, key, nkey,\n                                      c->binary_header.request.vbucket);\n    }\n\n    uint16_t keylen;\n    uint32_t bodylen;\n    item_info info = { .nvalue = 1 };\n\n    switch (ret) {\n    case ENGINE_SUCCESS:\n        if (!settings.engine.v1->get_item_info(settings.engine.v0, c, it, &info)) {\n            settings.engine.v1->release(settings.engine.v0, c, it);\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                            \"%d: Failed to get item info\\n\",\n                                            c->sfd);\n            write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_EINTERNAL, 0);\n            break;\n        }\n\n        keylen = 0;\n        bodylen = sizeof(rsp->message.body) + info.nbytes;\n\n        STATS_HIT(c, get, key, nkey);\n\n        if (c->cmd == PROTOCOL_BINARY_CMD_GETK) {\n            bodylen += nkey;\n            keylen = nkey;\n        }\n        add_bin_header(c, 0, sizeof(rsp->message.body), keylen, bodylen);\n        rsp->message.header.response.cas = htonll(info.cas);\n\n        // add the flags\n        rsp->message.body.flags = info.flags;\n        add_iov(c, &rsp->message.body, sizeof(rsp->message.body));\n\n        if (c->cmd == PROTOCOL_BINARY_CMD_GETK) {\n            add_iov(c, info.key, nkey);\n        }\n\n        add_iov(c, info.value[0].iov_base, info.value[0].iov_len);\n        conn_set_state(c, conn_mwrite);\n        /* Remember this item so we can garbage collect it later */\n        c->item = it;\n        break;\n    case ENGINE_KEY_ENOENT:\n        STATS_MISS(c, get, key, nkey);\n\n        MEMCACHED_COMMAND_GET(c->sfd, key, nkey, -1, 0);\n\n        if (c->noreply) {\n            conn_set_state(c, conn_new_cmd);\n        } else {\n            if (c->cmd == PROTOCOL_BINARY_CMD_GETK) {\n                char *ofs = c->wbuf + sizeof(protocol_binary_response_header);\n                add_bin_header(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT,\n                               0, nkey, nkey);\n                memcpy(ofs, key, nkey);\n                add_iov(c, ofs, nkey);\n                conn_set_state(c, conn_mwrite);\n            } else {\n                write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, 0);\n            }\n        }\n        break;\n    case ENGINE_EWOULDBLOCK:\n        c->ewouldblock = true;\n        break;\n    case ENGINE_DISCONNECT:\n        c->state = conn_closing;\n        break;\n    case ENGINE_ENOTSUP:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_NOT_SUPPORTED, 0);\n        break;\n    case ENGINE_NOT_MY_VBUCKET:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_NOT_MY_VBUCKET, 0);\n        break;\n    case ENGINE_TMPFAIL:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_ETMPFAIL, 0);\n        break;\n\n    default:\n        /* @todo add proper error handling! */\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                        \"Unknown error code: %d\\n\", ret);\n        abort();\n    }\n\n    if (settings.detail_enabled && ret != ENGINE_EWOULDBLOCK) {\n        stats_prefix_record_get(key, nkey, ret == ENGINE_SUCCESS);\n    }\n}\n\nstatic void append_bin_stats(const char *key, const uint16_t klen,\n                             const char *val, const uint32_t vlen,\n                             conn *c) {\n    char *buf = c->dynamic_buffer.buffer + c->dynamic_buffer.offset;\n    uint32_t bodylen = klen + vlen;\n    protocol_binary_response_header header = {\n        .response.magic = (uint8_t)PROTOCOL_BINARY_RES,\n        .response.opcode = PROTOCOL_BINARY_CMD_STAT,\n        .response.keylen = (uint16_t)htons(klen),\n        .response.datatype = (uint8_t)PROTOCOL_BINARY_RAW_BYTES,\n        .response.bodylen = htonl(bodylen),\n        .response.opaque = c->opaque\n    };\n\n    memcpy(buf, header.bytes, sizeof(header.response));\n    buf += sizeof(header.response);\n\n    if (klen > 0) {\n        memcpy(buf, key, klen);\n        buf += klen;\n\n        if (vlen > 0) {\n            memcpy(buf, val, vlen);\n        }\n    }\n\n    c->dynamic_buffer.offset += sizeof(header.response) + bodylen;\n}\n\n/**\n * Append a key-value pair to the stats output buffer. This function assumes\n * that the output buffer is big enough (it will be if you call it through\n * append_stats)\n */\nstatic void append_ascii_stats(const char *key, const uint16_t klen,\n                               const char *val, const uint32_t vlen,\n                               conn *c) {\n    char *pos = c->dynamic_buffer.buffer + c->dynamic_buffer.offset;\n    uint32_t nbytes = 5; /* \"END\\r\\n\" or \"STAT \" */\n\n    if (klen == 0 && vlen == 0) {\n        memcpy(pos, \"END\\r\\n\", 5);\n    } else {\n        memcpy(pos, \"STAT \", 5);\n        memcpy(pos + nbytes, key, klen);\n        nbytes += klen;\n        if (vlen != 0) {\n            pos[nbytes] = ' ';\n            ++nbytes;\n            memcpy(pos + nbytes, val, vlen);\n            nbytes += vlen;\n        }\n        memcpy(pos + nbytes, \"\\r\\n\", 2);\n        nbytes += 2;\n    }\n\n    c->dynamic_buffer.offset += nbytes;\n}\n\nstatic bool grow_dynamic_buffer(conn *c, size_t needed) {\n    size_t nsize = c->dynamic_buffer.size;\n    size_t available = nsize - c->dynamic_buffer.offset;\n    bool rv = true;\n\n    /* Special case: No buffer -- need to allocate fresh */\n    if (c->dynamic_buffer.buffer == NULL) {\n        nsize = 1024;\n        available = c->dynamic_buffer.size = c->dynamic_buffer.offset = 0;\n    }\n\n    while (needed > available) {\n        assert(nsize > 0);\n        nsize = nsize << 1;\n        available = nsize - c->dynamic_buffer.offset;\n    }\n\n    if (nsize != c->dynamic_buffer.size) {\n        char *ptr = realloc(c->dynamic_buffer.buffer, nsize);\n        if (ptr) {\n            c->dynamic_buffer.buffer = ptr;\n            c->dynamic_buffer.size = nsize;\n        } else {\n            rv = false;\n        }\n    }\n\n    return rv;\n}\n\nstatic void append_stats(const char *key, const uint16_t klen,\n                         const char *val, const uint32_t vlen,\n                         const void *cookie)\n{\n    /* value without a key is invalid */\n    if (klen == 0 && vlen > 0) {\n        return ;\n    }\n\n    conn *c = (conn*)cookie;\n\n    if (c->protocol == binary_prot) {\n        size_t needed = vlen + klen + sizeof(protocol_binary_response_header);\n        if (!grow_dynamic_buffer(c, needed)) {\n            return ;\n        }\n        append_bin_stats(key, klen, val, vlen, c);\n    } else {\n        size_t needed = vlen + klen + 10; // 10 == \"STAT = \\r\\n\"\n        if (!grow_dynamic_buffer(c, needed)) {\n            return ;\n        }\n        append_ascii_stats(key, klen, val, vlen, c);\n    }\n\n    assert(c->dynamic_buffer.offset <= c->dynamic_buffer.size);\n}\n\nstatic void process_bin_stat(conn *c) {\n    char *subcommand = binary_get_key(c);\n    size_t nkey = c->binary_header.request.keylen;\n\n    if (settings.verbose > 1) {\n        char buffer[1024];\n        if (key_to_printable_buffer(buffer, sizeof(buffer), c->sfd, true,\n                                    \"STATS\", subcommand, nkey) != -1) {\n            settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c, \"%s\\n\",\n                                            buffer);\n        }\n    }\n\n    ENGINE_ERROR_CODE ret = c->aiostat;\n    c->aiostat = ENGINE_SUCCESS;\n    c->ewouldblock = false;\n\n    if (ret == ENGINE_SUCCESS) {\n        if (nkey == 0) {\n            /* request all statistics */\n            ret = settings.engine.v1->get_stats(settings.engine.v0, c, NULL, 0, append_stats);\n            if (ret == ENGINE_SUCCESS) {\n                server_stats(&append_stats, c, false);\n            }\n        } else if (strncmp(subcommand, \"reset\", 5) == 0) {\n            stats_reset(c);\n            settings.engine.v1->reset_stats(settings.engine.v0, c);\n        } else if (strncmp(subcommand, \"settings\", 8) == 0) {\n            process_stat_settings(&append_stats, c);\n        } else if (strncmp(subcommand, \"detail\", 6) == 0) {\n            char *subcmd_pos = subcommand + 6;\n            if (settings.allow_detailed) {\n                if (strncmp(subcmd_pos, \" dump\", 5) == 0) {\n                    int len;\n                    char *dump_buf = stats_prefix_dump(&len);\n                    if (dump_buf == NULL || len <= 0) {\n                        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, 0);\n                        return ;\n                    } else {\n                        append_stats(\"detailed\", strlen(\"detailed\"), dump_buf, len, c);\n                        free(dump_buf);\n                    }\n                } else if (strncmp(subcmd_pos, \" on\", 3) == 0) {\n                    settings.detail_enabled = 1;\n                } else if (strncmp(subcmd_pos, \" off\", 4) == 0) {\n                    settings.detail_enabled = 0;\n                } else {\n                    write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, 0);\n                    return;\n                }\n            } else {\n                write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, 0);\n                return;\n            }\n        } else if (strncmp(subcommand, \"aggregate\", 9) == 0) {\n            server_stats(&append_stats, c, true);\n        } else if (strncmp(subcommand, \"topkeys\", 7) == 0) {\n            topkeys_t *tk = get_independent_stats(c)->topkeys;\n            if (tk != NULL) {\n                topkeys_stats(tk, c, current_time, append_stats);\n            } else {\n                write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, 0);\n                return;\n            }\n        } else {\n            ret = settings.engine.v1->get_stats(settings.engine.v0, c,\n                                                subcommand, nkey,\n                                                append_stats);\n        }\n    }\n\n    switch (ret) {\n    case ENGINE_SUCCESS:\n        append_stats(NULL, 0, NULL, 0, c);\n        write_and_free(c, c->dynamic_buffer.buffer, c->dynamic_buffer.offset);\n        c->dynamic_buffer.buffer = NULL;\n        break;\n    case ENGINE_ENOMEM:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, 0);\n        break;\n    case ENGINE_TMPFAIL:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_ETMPFAIL, 0);\n        break;\n    case ENGINE_KEY_ENOENT:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, 0);\n        break;\n    case ENGINE_DISCONNECT:\n        c->state = conn_closing;\n        break;\n    case ENGINE_ENOTSUP:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_NOT_SUPPORTED, 0);\n        break;\n    case ENGINE_EWOULDBLOCK:\n        c->ewouldblock = true;\n        break;\n    default:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_EINVAL, 0);\n    }\n}\n\nstatic void bin_read_chunk(conn *c, enum bin_substates next_substate, uint32_t chunk) {\n    assert(c);\n    c->substate = next_substate;\n    c->rlbytes = chunk;\n\n    /* Ok... do we have room for everything in our buffer? */\n    ptrdiff_t offset = c->rcurr + sizeof(protocol_binary_request_header) - c->rbuf;\n    if (c->rlbytes > c->rsize - offset) {\n        size_t nsize = c->rsize;\n        size_t size = c->rlbytes + sizeof(protocol_binary_request_header);\n\n        while (size > nsize) {\n            nsize *= 2;\n        }\n\n        if (nsize != c->rsize) {\n            char *newm;\n            if (settings.verbose > 1) {\n                settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                        \"%d: Need to grow buffer from %lu to %lu\\n\",\n                        c->sfd, (unsigned long)c->rsize, (unsigned long)nsize);\n            }\n            newm = realloc(c->rbuf, nsize);\n            if (newm == NULL) {\n                if (settings.verbose) {\n                    settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                            \"%d: Failed to grow buffer.. closing connection\\n\",\n                            c->sfd);\n                }\n                conn_set_state(c, conn_closing);\n                return;\n            }\n\n            c->rbuf= newm;\n            /* rcurr should point to the same offset in the packet */\n            c->rcurr = c->rbuf + offset - sizeof(protocol_binary_request_header);\n            c->rsize = nsize;\n        }\n        if (c->rbuf != c->rcurr) {\n            memmove(c->rbuf, c->rcurr, c->rbytes);\n            c->rcurr = c->rbuf;\n            if (settings.verbose > 1) {\n                settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                                \"%d: Repack input buffer\\n\",\n                                                c->sfd);\n            }\n        }\n    }\n\n    /* preserve the header in the buffer.. */\n    c->ritem = c->rcurr + sizeof(protocol_binary_request_header);\n    conn_set_state(c, conn_nread);\n}\n\nstatic void bin_read_key(conn *c, enum bin_substates next_substate, int extra) {\n    bin_read_chunk(c, next_substate, c->keylen + extra);\n}\n\n\n/* Just write an error message and disconnect the client */\nstatic void handle_binary_protocol_error(conn *c) {\n    write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_EINVAL, 0);\n    if (settings.verbose) {\n        settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                \"%d: Protocol error (opcode %02x), close connection\\n\",\n                c->sfd, c->binary_header.request.opcode);\n    }\n    c->write_and_go = conn_closing;\n}\n\nstatic void init_sasl_conn(conn *c) {\n    assert(c);\n    if (!c->sasl_conn) {\n        int result=sasl_server_new(\"memcached\",\n                                   NULL, NULL, NULL, NULL,\n                                   NULL, 0, &c->sasl_conn);\n        if (result != SASL_OK) {\n            if (settings.verbose) {\n                settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                         \"%d: Failed to initialize SASL conn.\\n\",\n                         c->sfd);\n            }\n            c->sasl_conn = NULL;\n        }\n    }\n}\n\nstatic void get_auth_data(const void *cookie, auth_data_t *data) {\n    conn *c = (conn*)cookie;\n    if (c->sasl_conn) {\n        sasl_getprop(c->sasl_conn, SASL_USERNAME, (void*)&data->username);\n#ifdef ENABLE_ISASL\n        sasl_getprop(c->sasl_conn, ISASL_CONFIG, (void*)&data->config);\n#endif\n    }\n    (void)(data);\n}\n\n#ifdef SASL_ENABLED\nstatic void bin_list_sasl_mechs(conn *c) {\n    init_sasl_conn(c);\n    const char *result_string = NULL;\n    unsigned int string_length = 0;\n    int result=sasl_listmech(c->sasl_conn, NULL,\n                             \"\",   /* What to prepend the string with */\n                             \" \",  /* What to separate mechanisms with */\n                             \"\",   /* What to append to the string */\n                             &result_string, &string_length,\n                             NULL);\n    if (result != SASL_OK) {\n        /* Perhaps there's a better error for this... */\n        if (settings.verbose) {\n            settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                     \"%d: Failed to list SASL mechanisms.\\n\",\n                     c->sfd);\n        }\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_AUTH_ERROR, 0);\n        return;\n    }\n    write_bin_response(c, (char*)result_string, 0, 0, string_length);\n}\n#endif\n\nstruct sasl_tmp {\n    int ksize;\n    int vsize;\n    char data[]; /* data + ksize == value */\n};\n\nstatic void process_bin_sasl_auth(conn *c) {\n    assert(c->binary_header.request.extlen == 0);\n\n    int nkey = c->binary_header.request.keylen;\n    int vlen = c->binary_header.request.bodylen - nkey;\n\n    if (nkey > MAX_SASL_MECH_LEN) {\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_EINVAL, vlen);\n        c->write_and_go = conn_swallow;\n        return;\n    }\n\n    char *key = binary_get_key(c);\n    assert(key);\n\n    size_t buffer_size = sizeof(struct sasl_tmp) + nkey + vlen + 2;\n    struct sasl_tmp *data = calloc(sizeof(struct sasl_tmp) + buffer_size, 1);\n    if (!data) {\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, vlen);\n        c->write_and_go = conn_swallow;\n        return;\n    }\n\n    data->ksize = nkey;\n    data->vsize = vlen;\n    memcpy(data->data, key, nkey);\n\n    c->item = data;\n    c->ritem = data->data + nkey;\n    c->rlbytes = vlen;\n    conn_set_state(c, conn_nread);\n    c->substate = bin_reading_sasl_auth_data;\n}\n\nstatic void process_bin_complete_sasl_auth(conn *c) {\n    const char *out = NULL;\n    unsigned int outlen = 0;\n\n    assert(c->item);\n    init_sasl_conn(c);\n\n    int nkey = c->binary_header.request.keylen;\n    int vlen = c->binary_header.request.bodylen - nkey;\n\n    struct sasl_tmp *stmp = c->item;\n    char mech[nkey+1];\n    memcpy(mech, stmp->data, nkey);\n    mech[nkey] = 0x00;\n\n    if (settings.verbose) {\n        settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                \"%d: mech: ``%s'' with %d bytes of data\\n\", c->sfd, mech, vlen);\n    }\n\n    const char *challenge = vlen == 0 ? NULL : (stmp->data + nkey);\n\n    int result=-1;\n\n    switch (c->cmd) {\n    case PROTOCOL_BINARY_CMD_SASL_AUTH:\n        result = sasl_server_start(c->sasl_conn, mech,\n                                   challenge, vlen,\n                                   &out, &outlen);\n        break;\n    case PROTOCOL_BINARY_CMD_SASL_STEP:\n        result = sasl_server_step(c->sasl_conn,\n                                  challenge, vlen,\n                                  &out, &outlen);\n        break;\n    default:\n        assert(false); /* CMD should be one of the above */\n        /* This code is pretty much impossible, but makes the compiler\n           happier */\n        if (settings.verbose) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                    \"%d: Unhandled command %d with challenge %s\\n\",\n                    c->sfd, c->cmd, challenge);\n        }\n        break;\n    }\n\n    free(c->item);\n    c->item = NULL;\n    c->ritem = NULL;\n\n    if (settings.verbose) {\n        settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                                        \"%d: sasl result code:  %d\\n\",\n                                        c->sfd, result);\n    }\n\n    switch(result) {\n    case SASL_OK:\n        write_bin_response(c, \"Authenticated\", 0, 0, strlen(\"Authenticated\"));\n        auth_data_t data;\n        get_auth_data(c, &data);\n        perform_callbacks(ON_AUTH, (const void*)&data, c);\n        STATS_NOKEY(c, auth_cmds);\n        break;\n    case SASL_CONTINUE:\n        add_bin_header(c, PROTOCOL_BINARY_RESPONSE_AUTH_CONTINUE, 0, 0, outlen);\n        if(outlen > 0) {\n            add_iov(c, out, outlen);\n        }\n        conn_set_state(c, conn_mwrite);\n        c->write_and_go = conn_new_cmd;\n        break;\n    default:\n        if (settings.verbose) {\n            settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                                            \"%d: Unknown sasl response:  %d\\n\",\n                                            c->sfd, result);\n        }\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_AUTH_ERROR, 0);\n        STATS_NOKEY2(c, auth_cmds, auth_errors);\n    }\n}\n\nstatic bool authenticated(conn *c) {\n    bool rv = false;\n\n    switch (c->cmd) {\n    case PROTOCOL_BINARY_CMD_SASL_LIST_MECHS: /* FALLTHROUGH */\n    case PROTOCOL_BINARY_CMD_SASL_AUTH:       /* FALLTHROUGH */\n    case PROTOCOL_BINARY_CMD_SASL_STEP:       /* FALLTHROUGH */\n    case PROTOCOL_BINARY_CMD_VERSION:         /* FALLTHROUGH */\n        rv = true;\n        break;\n    default:\n        if (c->sasl_conn) {\n            const void *uname = NULL;\n            sasl_getprop(c->sasl_conn, SASL_USERNAME, &uname);\n            rv = uname != NULL;\n        }\n    }\n\n    if (settings.verbose > 1) {\n        settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                \"%d: authenticated() in cmd 0x%02x is %s\\n\",\n                c->sfd, c->cmd, rv ? \"true\" : \"false\");\n    }\n\n    return rv;\n}\n\nstatic bool binary_response_handler(const void *key, uint16_t keylen,\n                                    const void *ext, uint8_t extlen,\n                                    const void *body, uint32_t bodylen,\n                                    uint8_t datatype, uint16_t status,\n                                    uint64_t cas, const void *cookie)\n{\n    conn *c = (conn*)cookie;\n    /* Look at append_bin_stats */\n    size_t needed = keylen + extlen + bodylen + sizeof(protocol_binary_response_header);\n    if (!grow_dynamic_buffer(c, needed)) {\n        if (settings.verbose > 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                    \"<%d ERROR: Failed to allocate memory for response\\n\",\n                    c->sfd);\n        }\n        return false;\n    }\n\n    char *buf = c->dynamic_buffer.buffer + c->dynamic_buffer.offset;\n    protocol_binary_response_header header = {\n        .response.magic = (uint8_t)PROTOCOL_BINARY_RES,\n        .response.opcode = c->binary_header.request.opcode,\n        .response.keylen = (uint16_t)htons(keylen),\n        .response.extlen = extlen,\n        .response.datatype = datatype,\n        .response.status = (uint16_t)htons(status),\n        .response.bodylen = htonl(bodylen + keylen + extlen),\n        .response.opaque = c->opaque,\n        .response.cas = htonll(cas),\n    };\n\n    memcpy(buf, header.bytes, sizeof(header.response));\n    buf += sizeof(header.response);\n\n    if (extlen > 0) {\n        memcpy(buf, ext, extlen);\n        buf += extlen;\n    }\n\n    if (keylen > 0) {\n        memcpy(buf, key, keylen);\n        buf += keylen;\n    }\n\n    if (bodylen > 0) {\n        memcpy(buf, body, bodylen);\n    }\n\n    c->dynamic_buffer.offset += needed;\n\n    return true;\n}\n\n/**\n * Tap stats (these are only used by the tap thread, so they don't need\n * to be in the threadlocal struct right now...\n */\nstruct tap_cmd_stats {\n    uint64_t connect;\n    uint64_t mutation;\n    uint64_t checkpoint_start;\n    uint64_t checkpoint_end;\n    uint64_t delete;\n    uint64_t flush;\n    uint64_t opaque;\n    uint64_t vbucket_set;\n};\n\nstruct tap_stats {\n    pthread_mutex_t mutex;\n    struct tap_cmd_stats sent;\n    struct tap_cmd_stats received;\n} tap_stats = { .mutex = PTHREAD_MUTEX_INITIALIZER };\n\nstatic void ship_tap_log(conn *c) {\n    assert(c->thread->type == TAP);\n    c->msgcurr = 0;\n    c->msgused = 0;\n    c->iovused = 0;\n    if (add_msghdr(c) != 0) {\n        if (settings.verbose) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                            \"%d: Failed to create output headers. Shutting down tap connection\\n\", c->sfd);\n        }\n        conn_set_state(c, conn_closing);\n        return ;\n    }\n    /* @todo add check for buffer overflow of c->wbuf) */\n    c->wcurr = c->wbuf;\n\n    bool more_data = true;\n    bool send_data = false;\n    bool disconnect = false;\n\n    item *it;\n    uint32_t bodylen;\n    int ii = 0;\n    c->icurr = c->ilist;\n    do {\n        /* @todo fixme! */\n        if (ii++ == 10) {\n            break;\n        }\n\n        void *engine;\n        uint16_t nengine;\n        uint8_t ttl;\n        uint16_t tap_flags;\n        uint32_t seqno;\n        uint16_t vbucket;\n\n        tap_event_t event = c->tap_iterator(settings.engine.v0, c, &it,\n                                            &engine, &nengine, &ttl,\n                                            &tap_flags, &seqno, &vbucket);\n        union {\n            protocol_binary_request_tap_mutation mutation;\n            protocol_binary_request_tap_delete delete;\n            protocol_binary_request_tap_flush flush;\n            protocol_binary_request_tap_opaque opaque;\n            protocol_binary_request_noop noop;\n        } msg = {\n            .mutation.message.header.request.magic = (uint8_t)PROTOCOL_BINARY_REQ,\n        };\n\n        msg.opaque.message.header.request.opaque = htonl(seqno);\n        msg.opaque.message.body.tap.enginespecific_length = htons(nengine);\n        msg.opaque.message.body.tap.ttl = ttl;\n        msg.opaque.message.body.tap.flags = htons(tap_flags);\n        msg.opaque.message.header.request.extlen = 8;\n        msg.opaque.message.header.request.vbucket = htons(vbucket);\n        item_info info = { .nvalue = 1 };\n\n        switch (event) {\n        case TAP_NOOP :\n            send_data = true;\n            msg.noop.message.header.request.opcode = PROTOCOL_BINARY_CMD_NOOP;\n            msg.noop.message.header.request.extlen = 0;\n            msg.noop.message.header.request.bodylen = htonl(0);\n            memcpy(c->wcurr, msg.noop.bytes, sizeof(msg.noop.bytes));\n            add_iov(c, c->wcurr, sizeof(msg.noop.bytes));\n            c->wcurr += sizeof(msg.noop.bytes);\n            c->wbytes += sizeof(msg.noop.bytes);\n            break;\n        case TAP_PAUSE :\n            more_data = false;\n            break;\n        case TAP_CHECKPOINT_START:\n        case TAP_CHECKPOINT_END:\n        case TAP_MUTATION:\n            if (!settings.engine.v1->get_item_info(settings.engine.v0, c, it, &info)) {\n                settings.engine.v1->release(settings.engine.v0, c, it);\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                                \"%d: Failed to get item info\\n\", c->sfd);\n                break;\n            }\n            send_data = true;\n            c->ilist[c->ileft++] = it;\n\n            if (event == TAP_CHECKPOINT_START) {\n                msg.mutation.message.header.request.opcode =\n                    PROTOCOL_BINARY_CMD_TAP_CHECKPOINT_START;\n                pthread_mutex_lock(&tap_stats.mutex);\n                tap_stats.sent.checkpoint_start++;\n                pthread_mutex_unlock(&tap_stats.mutex);\n            } else if (event == TAP_CHECKPOINT_END) {\n                msg.mutation.message.header.request.opcode =\n                    PROTOCOL_BINARY_CMD_TAP_CHECKPOINT_END;\n                pthread_mutex_lock(&tap_stats.mutex);\n                tap_stats.sent.checkpoint_end++;\n                pthread_mutex_unlock(&tap_stats.mutex);\n            } else if (event == TAP_MUTATION) {\n                msg.mutation.message.header.request.opcode = PROTOCOL_BINARY_CMD_TAP_MUTATION;\n                pthread_mutex_lock(&tap_stats.mutex);\n                tap_stats.sent.mutation++;\n                pthread_mutex_unlock(&tap_stats.mutex);\n            }\n\n            msg.mutation.message.header.request.cas = htonll(info.cas);\n            msg.mutation.message.header.request.keylen = htons(info.nkey);\n            msg.mutation.message.header.request.extlen = 16;\n\n            bodylen = 16 + info.nkey + nengine;\n            if ((tap_flags & TAP_FLAG_NO_VALUE) == 0) {\n                bodylen += info.nbytes;\n            }\n            msg.mutation.message.header.request.bodylen = htonl(bodylen);\n            msg.mutation.message.body.item.flags = htonl(info.flags);\n            msg.mutation.message.body.item.expiration = htonl(info.exptime);\n            msg.mutation.message.body.tap.enginespecific_length = htons(nengine);\n            msg.mutation.message.body.tap.ttl = ttl;\n            msg.mutation.message.body.tap.flags = htons(tap_flags);\n            memcpy(c->wcurr, msg.mutation.bytes, sizeof(msg.mutation.bytes));\n\n            add_iov(c, c->wcurr, sizeof(msg.mutation.bytes));\n            c->wcurr += sizeof(msg.mutation.bytes);\n            c->wbytes += sizeof(msg.mutation.bytes);\n\n            if (nengine > 0) {\n                memcpy(c->wcurr, engine, nengine);\n                add_iov(c, c->wcurr, nengine);\n                c->wcurr += nengine;\n                c->wbytes += nengine;\n            }\n\n            add_iov(c, info.key, info.nkey);\n            if ((tap_flags & TAP_FLAG_NO_VALUE) == 0) {\n                add_iov(c, info.value[0].iov_base, info.value[0].iov_len);\n            }\n\n            break;\n        case TAP_DELETION:\n            /* This is a delete */\n            if (!settings.engine.v1->get_item_info(settings.engine.v0, c, it, &info)) {\n                settings.engine.v1->release(settings.engine.v0, c, it);\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                                \"%d: Failed to get item info\\n\", c->sfd);\n                break;\n            }\n            send_data = true;\n            c->ilist[c->ileft++] = it;\n            msg.delete.message.header.request.opcode = PROTOCOL_BINARY_CMD_TAP_DELETE;\n            msg.delete.message.header.request.cas = htonll(info.cas);\n            msg.delete.message.header.request.keylen = htons(info.nkey);\n\n            bodylen = 8 + info.nkey + nengine;\n            if ((tap_flags & TAP_FLAG_NO_VALUE) == 0) {\n                bodylen += info.nbytes;\n            }\n            msg.delete.message.header.request.bodylen = htonl(bodylen);\n\n            memcpy(c->wcurr, msg.delete.bytes, sizeof(msg.delete.bytes));\n            add_iov(c, c->wcurr, sizeof(msg.delete.bytes));\n            c->wcurr += sizeof(msg.delete.bytes);\n            c->wbytes += sizeof(msg.delete.bytes);\n\n            if (nengine > 0) {\n                memcpy(c->wcurr, engine, nengine);\n                add_iov(c, c->wcurr, nengine);\n                c->wcurr += nengine;\n                c->wbytes += nengine;\n            }\n\n            add_iov(c, info.key, info.nkey);\n            if ((tap_flags & TAP_FLAG_NO_VALUE) == 0) {\n                add_iov(c, info.value[0].iov_base, info.value[0].iov_len);\n            }\n\n            pthread_mutex_lock(&tap_stats.mutex);\n            tap_stats.sent.delete++;\n            pthread_mutex_unlock(&tap_stats.mutex);\n            break;\n\n        case TAP_DISCONNECT:\n            disconnect = true;\n            more_data = false;\n            break;\n        case TAP_VBUCKET_SET:\n        case TAP_FLUSH:\n        case TAP_OPAQUE:\n            send_data = true;\n\n            if (event == TAP_OPAQUE) {\n                msg.flush.message.header.request.opcode = PROTOCOL_BINARY_CMD_TAP_OPAQUE;\n                pthread_mutex_lock(&tap_stats.mutex);\n                tap_stats.sent.opaque++;\n                pthread_mutex_unlock(&tap_stats.mutex);\n\n            } else if (event == TAP_FLUSH) {\n                msg.flush.message.header.request.opcode = PROTOCOL_BINARY_CMD_TAP_FLUSH;\n                pthread_mutex_lock(&tap_stats.mutex);\n                tap_stats.sent.flush++;\n                pthread_mutex_unlock(&tap_stats.mutex);\n            } else if (event == TAP_VBUCKET_SET) {\n                msg.flush.message.header.request.opcode = PROTOCOL_BINARY_CMD_TAP_VBUCKET_SET;\n                msg.flush.message.body.tap.flags = htons(tap_flags);\n                pthread_mutex_lock(&tap_stats.mutex);\n                tap_stats.sent.vbucket_set++;\n                pthread_mutex_unlock(&tap_stats.mutex);\n            }\n\n            msg.flush.message.header.request.bodylen = htonl(8 + nengine);\n            memcpy(c->wcurr, msg.flush.bytes, sizeof(msg.flush.bytes));\n            add_iov(c, c->wcurr, sizeof(msg.flush.bytes));\n            c->wcurr += sizeof(msg.flush.bytes);\n            c->wbytes += sizeof(msg.flush.bytes);\n            if (nengine > 0) {\n                memcpy(c->wcurr, engine, nengine);\n                add_iov(c, c->wcurr, nengine);\n                c->wcurr += nengine;\n                c->wbytes += nengine;\n            }\n            break;\n        default:\n            abort();\n        }\n    } while (more_data);\n\n    c->ewouldblock = false;\n    if (send_data) {\n        conn_set_state(c, conn_mwrite);\n        if (disconnect) {\n            c->write_and_go = conn_closing;\n        } else {\n            c->write_and_go = conn_ship_log;\n        }\n    } else {\n        if (disconnect) {\n            conn_set_state(c, conn_closing);\n        } else {\n            /* No more items to ship to the slave at this time.. suspend.. */\n            if (settings.verbose > 1) {\n                settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                                \"%d: No more items in tap log.. waiting\\n\",\n                                                c->sfd);\n            }\n            c->ewouldblock = true;\n        }\n    }\n}\n\n\nstatic ENGINE_ERROR_CODE default_unknown_command(EXTENSION_BINARY_PROTOCOL_DESCRIPTOR *descriptor,\n                                                 ENGINE_HANDLE* handle,\n                                                 const void* cookie,\n                                                 protocol_binary_request_header *request,\n                                                 ADD_RESPONSE response)\n{\n    (void)(descriptor);\n    return settings.engine.v1->unknown_command(handle, cookie, request, response);\n}\n\nstruct request_lookup {\n    EXTENSION_BINARY_PROTOCOL_DESCRIPTOR *descriptor;\n    BINARY_COMMAND_CALLBACK callback;\n};\n\nstatic struct request_lookup request_handlers[0x100];\n\nstatic void initialize_binary_lookup_map(void) {\n    for (int ii = 0; ii < 0x100; ++ii) {\n        request_handlers[ii].descriptor = NULL;\n        request_handlers[ii].callback = default_unknown_command;\n    }\n}\n\nstatic void setup_binary_lookup_cmd(EXTENSION_BINARY_PROTOCOL_DESCRIPTOR *descriptor,\n                                    uint8_t cmd,\n                                    BINARY_COMMAND_CALLBACK new_handler) {\n    request_handlers[cmd].descriptor = descriptor;\n    request_handlers[cmd].callback = new_handler;\n}\n\nstatic void process_bin_unknown_packet(conn *c) {\n    void *packet = c->rcurr - (c->binary_header.request.bodylen +\n                               sizeof(c->binary_header));\n\n    ENGINE_ERROR_CODE ret = c->aiostat;\n    c->aiostat = ENGINE_SUCCESS;\n    c->ewouldblock = false;\n\n    if (ret == ENGINE_SUCCESS) {\n        struct request_lookup *rq = request_handlers + c->binary_header.request.opcode;\n        ret = rq->callback(rq->descriptor, settings.engine.v0, c, packet,\n                           binary_response_handler);\n    }\n\n    switch (ret) {\n    case ENGINE_SUCCESS:\n        if (c->dynamic_buffer.buffer != NULL) {\n            write_and_free(c, c->dynamic_buffer.buffer, c->dynamic_buffer.offset);\n            c->dynamic_buffer.buffer = NULL;\n        } else {\n            conn_set_state(c, conn_new_cmd);\n        }\n        break;\n    case ENGINE_EWOULDBLOCK:\n        c->ewouldblock = true;\n        break;\n    case ENGINE_DISCONNECT:\n        conn_set_state(c, conn_closing);\n        break;\n    default:\n        // Release the dynamic buffer.. it may be partial..\n        free(c->dynamic_buffer.buffer);\n        c->dynamic_buffer.buffer = NULL;\n        write_bin_packet(c, engine_error_2_protocol_error(ret), 0);\n    }\n}\n\nstatic void process_bin_tap_connect(conn *c) {\n    char *packet = (c->rcurr - (c->binary_header.request.bodylen +\n                                sizeof(c->binary_header)));\n    protocol_binary_request_tap_connect *req = (void*)packet;\n    const char *key = packet + sizeof(req->bytes);\n    const char *data = key + c->binary_header.request.keylen;\n    uint32_t flags = 0;\n    size_t ndata = c->binary_header.request.bodylen -\n        c->binary_header.request.extlen -\n        c->binary_header.request.keylen;\n\n    if (c->binary_header.request.extlen == 4) {\n        flags = ntohl(req->message.body.flags);\n\n        if (flags & TAP_CONNECT_FLAG_BACKFILL) {\n            /* the userdata has to be at least 8 bytes! */\n            if (ndata < 8) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                                \"%d: ERROR: Invalid tap connect message\\n\",\n                                                c->sfd);\n                conn_set_state(c, conn_closing);\n                return ;\n            }\n        }\n    } else {\n        data -= 4;\n        key -= 4;\n    }\n\n    if (settings.verbose && c->binary_header.request.keylen > 0) {\n        char buffer[1024];\n        unsigned int len = c->binary_header.request.keylen;\n        if (len >= sizeof(buffer)) {\n            len = sizeof(buffer) - 1;\n        }\n        memcpy(buffer, key, len);\n        buffer[len] = '\\0';\n        settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                        \"%d: Trying to connect with named tap connection: <%s>\\n\",\n                                        c->sfd, buffer);\n    }\n\n    TAP_ITERATOR iterator = settings.engine.v1->get_tap_iterator(\n        settings.engine.v0, c, key, c->binary_header.request.keylen,\n        flags, data, ndata);\n\n    if (iterator == NULL) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                        \"%d: FATAL: The engine does not support tap\\n\",\n                                        c->sfd);\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_NOT_SUPPORTED, 0);\n        c->write_and_go = conn_closing;\n    } else {\n        c->tap_iterator = iterator;\n        c->which = EV_WRITE;\n        conn_set_state(c, conn_ship_log);\n    }\n}\n\nstatic void process_bin_tap_packet(tap_event_t event, conn *c) {\n    assert(c != NULL);\n    char *packet = (c->rcurr - (c->binary_header.request.bodylen +\n                                sizeof(c->binary_header)));\n    protocol_binary_request_tap_no_extras *tap = (void*)packet;\n    uint16_t nengine = ntohs(tap->message.body.tap.enginespecific_length);\n    uint16_t tap_flags = ntohs(tap->message.body.tap.flags);\n    uint32_t seqno = ntohl(tap->message.header.request.opaque);\n    uint8_t ttl = tap->message.body.tap.ttl;\n    char *engine_specific = packet + sizeof(tap->bytes);\n    char *key = engine_specific + nengine;\n    uint16_t nkey = c->binary_header.request.keylen;\n    char *data = key + nkey;\n    uint32_t flags = 0;\n    uint32_t exptime = 0;\n    uint32_t ndata = c->binary_header.request.bodylen - nengine - nkey - 8;\n    ENGINE_ERROR_CODE ret = c->aiostat;\n\n    if (ttl == 0) {\n        ret = ENGINE_EINVAL;\n    } else {\n        if (event == TAP_MUTATION || event == TAP_CHECKPOINT_START ||\n            event == TAP_CHECKPOINT_END) {\n            protocol_binary_request_tap_mutation *mutation = (void*)tap;\n            flags = ntohl(mutation->message.body.item.flags);\n            exptime = ntohl(mutation->message.body.item.expiration);\n            key += 8;\n            data += 8;\n            ndata -= 8;\n        }\n\n        if (ret == ENGINE_SUCCESS) {\n            ret = settings.engine.v1->tap_notify(settings.engine.v0, c,\n                                                 engine_specific, nengine,\n                                                 ttl - 1, tap_flags,\n                                                 event, seqno,\n                                                 key, nkey,\n                                                 flags, exptime,\n                                                 ntohll(tap->message.header.request.cas),\n                                                 data, ndata,\n                                                 c->binary_header.request.vbucket);\n        }\n    }\n\n    switch (ret) {\n    case ENGINE_DISCONNECT:\n        conn_set_state(c, conn_closing);\n        break;\n    case ENGINE_EWOULDBLOCK:\n        c->ewouldblock = true;\n        break;\n    default:\n        if ((tap_flags & TAP_FLAG_ACK) || (ret != ENGINE_SUCCESS)) {\n            write_bin_packet(c, engine_error_2_protocol_error(ret), 0);\n        } else {\n            conn_set_state(c, conn_new_cmd);\n        }\n    }\n}\n\nstatic void process_bin_tap_ack(conn *c) {\n    assert(c != NULL);\n    char *packet = (c->rcurr - (c->binary_header.request.bodylen +\n                                sizeof(c->binary_header)));\n    protocol_binary_response_no_extras *rsp = (void*)packet;\n    uint32_t seqno = ntohl(rsp->message.header.response.opaque);\n    uint16_t status = ntohs(rsp->message.header.response.status);\n    char *key = packet + sizeof(rsp->bytes);\n\n    ENGINE_ERROR_CODE ret = ENGINE_DISCONNECT;\n    if (settings.engine.v1->tap_notify != NULL) {\n        ret = settings.engine.v1->tap_notify(settings.engine.v0, c, NULL, 0, 0, status,\n                                             TAP_ACK, seqno, key,\n                                             c->binary_header.request.keylen, 0, 0,\n                                             0, NULL, 0, 0);\n    }\n\n    if (ret == ENGINE_DISCONNECT) {\n        conn_set_state(c, conn_closing);\n    } else {\n        conn_set_state(c, conn_ship_log);\n    }\n}\n\n/**\n * We received a noop response.. just ignore it\n */\nstatic void process_bin_noop_response(conn *c) {\n    assert(c != NULL);\n    conn_set_state(c, conn_new_cmd);\n}\n\nstatic void process_bin_verbosity(conn *c) {\n    char *packet = (c->rcurr - (c->binary_header.request.bodylen +\n                                sizeof(c->binary_header)));\n    protocol_binary_request_verbosity *req = (void*)packet;\n    uint32_t level = (uint32_t)ntohl(req->message.body.level);\n    if (level > MAX_VERBOSITY_LEVEL) {\n        level = MAX_VERBOSITY_LEVEL;\n    }\n    settings.verbose = (int)level;\n    perform_callbacks(ON_LOG_LEVEL, NULL, NULL);\n    write_bin_response(c, NULL, 0, 0, 0);\n}\n\nstatic void process_bin_packet(conn *c) {\n    /* @todo this should be an array of funciton pointers and call through */\n    switch (c->binary_header.request.opcode) {\n    case PROTOCOL_BINARY_CMD_TAP_CONNECT:\n        pthread_mutex_lock(&tap_stats.mutex);\n        tap_stats.received.connect++;\n        pthread_mutex_unlock(&tap_stats.mutex);\n        conn_set_state(c, conn_add_tap_client);\n        break;\n    case PROTOCOL_BINARY_CMD_TAP_MUTATION:\n        pthread_mutex_lock(&tap_stats.mutex);\n        tap_stats.received.mutation++;\n        pthread_mutex_unlock(&tap_stats.mutex);\n        process_bin_tap_packet(TAP_MUTATION, c);\n        break;\n    case PROTOCOL_BINARY_CMD_TAP_CHECKPOINT_START:\n        pthread_mutex_lock(&tap_stats.mutex);\n        tap_stats.received.checkpoint_start++;\n        pthread_mutex_unlock(&tap_stats.mutex);\n        process_bin_tap_packet(TAP_CHECKPOINT_START, c);\n        break;\n    case PROTOCOL_BINARY_CMD_TAP_CHECKPOINT_END:\n        pthread_mutex_lock(&tap_stats.mutex);\n        tap_stats.received.checkpoint_end++;\n        pthread_mutex_unlock(&tap_stats.mutex);\n        process_bin_tap_packet(TAP_CHECKPOINT_END, c);\n        break;\n    case PROTOCOL_BINARY_CMD_TAP_DELETE:\n        pthread_mutex_lock(&tap_stats.mutex);\n        tap_stats.received.delete++;\n        pthread_mutex_unlock(&tap_stats.mutex);\n        process_bin_tap_packet(TAP_DELETION, c);\n        break;\n    case PROTOCOL_BINARY_CMD_TAP_FLUSH:\n        pthread_mutex_lock(&tap_stats.mutex);\n        tap_stats.received.flush++;\n        pthread_mutex_unlock(&tap_stats.mutex);\n        process_bin_tap_packet(TAP_FLUSH, c);\n        break;\n    case PROTOCOL_BINARY_CMD_TAP_OPAQUE:\n        pthread_mutex_lock(&tap_stats.mutex);\n        tap_stats.received.opaque++;\n        pthread_mutex_unlock(&tap_stats.mutex);\n        process_bin_tap_packet(TAP_OPAQUE, c);\n        break;\n    case PROTOCOL_BINARY_CMD_TAP_VBUCKET_SET:\n        pthread_mutex_lock(&tap_stats.mutex);\n        tap_stats.received.vbucket_set++;\n        pthread_mutex_unlock(&tap_stats.mutex);\n        process_bin_tap_packet(TAP_VBUCKET_SET, c);\n        break;\n    case PROTOCOL_BINARY_CMD_VERBOSITY:\n        process_bin_verbosity(c);\n        break;\n    default:\n        process_bin_unknown_packet(c);\n    }\n}\n\ntypedef void (*RESPONSE_HANDLER)(conn*);\n/**\n * A map between the response packets op-code and the function to handle\n * the response message.\n */\nstatic RESPONSE_HANDLER response_handlers[256] = {\n    [PROTOCOL_BINARY_CMD_NOOP] = process_bin_noop_response,\n    [PROTOCOL_BINARY_CMD_TAP_MUTATION] = process_bin_tap_ack,\n    [PROTOCOL_BINARY_CMD_TAP_DELETE] = process_bin_tap_ack,\n    [PROTOCOL_BINARY_CMD_TAP_FLUSH] = process_bin_tap_ack,\n    [PROTOCOL_BINARY_CMD_TAP_OPAQUE] = process_bin_tap_ack,\n    [PROTOCOL_BINARY_CMD_TAP_VBUCKET_SET] = process_bin_tap_ack,\n    [PROTOCOL_BINARY_CMD_TAP_CHECKPOINT_START] = process_bin_tap_ack,\n    [PROTOCOL_BINARY_CMD_TAP_CHECKPOINT_END] = process_bin_tap_ack\n};\n\nstatic void dispatch_bin_command(conn *c) {\n    int protocol_error = 0;\n\n    int extlen = c->binary_header.request.extlen;\n    uint16_t keylen = c->binary_header.request.keylen;\n    uint32_t bodylen = c->binary_header.request.bodylen;\n\n    if (settings.require_sasl && !authenticated(c)) {\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_AUTH_ERROR, 0);\n        c->write_and_go = conn_closing;\n        return;\n    }\n\n    MEMCACHED_PROCESS_COMMAND_START(c->sfd, c->rcurr, c->rbytes);\n    c->noreply = true;\n\n    /* binprot supports 16bit keys, but internals are still 8bit */\n    if (keylen > KEY_MAX_LENGTH) {\n        handle_binary_protocol_error(c);\n        return;\n    }\n\n    switch (c->cmd) {\n    case PROTOCOL_BINARY_CMD_SETQ:\n        c->cmd = PROTOCOL_BINARY_CMD_SET;\n        break;\n    case PROTOCOL_BINARY_CMD_ADDQ:\n        c->cmd = PROTOCOL_BINARY_CMD_ADD;\n        break;\n    case PROTOCOL_BINARY_CMD_REPLACEQ:\n        c->cmd = PROTOCOL_BINARY_CMD_REPLACE;\n        break;\n    case PROTOCOL_BINARY_CMD_DELETEQ:\n        c->cmd = PROTOCOL_BINARY_CMD_DELETE;\n        break;\n    case PROTOCOL_BINARY_CMD_INCREMENTQ:\n        c->cmd = PROTOCOL_BINARY_CMD_INCREMENT;\n        break;\n    case PROTOCOL_BINARY_CMD_DECREMENTQ:\n        c->cmd = PROTOCOL_BINARY_CMD_DECREMENT;\n        break;\n    case PROTOCOL_BINARY_CMD_QUITQ:\n        c->cmd = PROTOCOL_BINARY_CMD_QUIT;\n        break;\n    case PROTOCOL_BINARY_CMD_FLUSHQ:\n        c->cmd = PROTOCOL_BINARY_CMD_FLUSH;\n        break;\n    case PROTOCOL_BINARY_CMD_APPENDQ:\n        c->cmd = PROTOCOL_BINARY_CMD_APPEND;\n        break;\n    case PROTOCOL_BINARY_CMD_PREPENDQ:\n        c->cmd = PROTOCOL_BINARY_CMD_PREPEND;\n        break;\n    case PROTOCOL_BINARY_CMD_GETQ:\n        c->cmd = PROTOCOL_BINARY_CMD_GET;\n        break;\n    case PROTOCOL_BINARY_CMD_GETKQ:\n        c->cmd = PROTOCOL_BINARY_CMD_GETK;\n        break;\n    default:\n        c->noreply = false;\n    }\n\n    switch (c->cmd) {\n        case PROTOCOL_BINARY_CMD_VERSION:\n            if (extlen == 0 && keylen == 0 && bodylen == 0) {\n                write_bin_response(c, VERSION, 0, 0, strlen(VERSION));\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_FLUSH:\n            if (keylen == 0 && bodylen == extlen && (extlen == 0 || extlen == 4)) {\n                bin_read_key(c, bin_read_flush_exptime, extlen);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_NOOP:\n            if (extlen == 0 && keylen == 0 && bodylen == 0) {\n                write_bin_response(c, NULL, 0, 0, 0);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_SET: /* FALLTHROUGH */\n        case PROTOCOL_BINARY_CMD_ADD: /* FALLTHROUGH */\n        case PROTOCOL_BINARY_CMD_REPLACE:\n            if (extlen == 8 && keylen != 0 && bodylen >= (keylen + 8)) {\n                bin_read_key(c, bin_reading_set_header, 8);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_GETQ:  /* FALLTHROUGH */\n        case PROTOCOL_BINARY_CMD_GET:   /* FALLTHROUGH */\n        case PROTOCOL_BINARY_CMD_GETKQ: /* FALLTHROUGH */\n        case PROTOCOL_BINARY_CMD_GETK:\n            if (extlen == 0 && bodylen == keylen && keylen > 0) {\n                bin_read_key(c, bin_reading_get_key, 0);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_DELETE:\n            if (keylen > 0 && extlen == 0 && bodylen == keylen) {\n                bin_read_key(c, bin_reading_del_header, extlen);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_INCREMENT:\n        case PROTOCOL_BINARY_CMD_DECREMENT:\n            if (keylen > 0 && extlen == 20 && bodylen == (keylen + extlen)) {\n                bin_read_key(c, bin_reading_incr_header, 20);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_APPEND:\n        case PROTOCOL_BINARY_CMD_PREPEND:\n            if (keylen > 0 && extlen == 0) {\n                bin_read_key(c, bin_reading_set_header, 0);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_STAT:\n            if (extlen == 0) {\n                bin_read_key(c, bin_reading_stat, 0);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_QUIT:\n            if (keylen == 0 && extlen == 0 && bodylen == 0) {\n                write_bin_response(c, NULL, 0, 0, 0);\n                c->write_and_go = conn_closing;\n                if (c->noreply) {\n                    conn_set_state(c, conn_closing);\n                }\n            } else {\n                protocol_error = 1;\n            }\n            break;\n       case PROTOCOL_BINARY_CMD_TAP_CONNECT:\n            if (settings.engine.v1->get_tap_iterator == NULL) {\n                write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_NOT_SUPPORTED, bodylen);\n            } else {\n                bin_read_chunk(c, bin_reading_packet,\n                               c->binary_header.request.bodylen);\n            }\n            break;\n       case PROTOCOL_BINARY_CMD_TAP_MUTATION:\n       case PROTOCOL_BINARY_CMD_TAP_CHECKPOINT_START:\n       case PROTOCOL_BINARY_CMD_TAP_CHECKPOINT_END:\n       case PROTOCOL_BINARY_CMD_TAP_DELETE:\n       case PROTOCOL_BINARY_CMD_TAP_FLUSH:\n       case PROTOCOL_BINARY_CMD_TAP_OPAQUE:\n       case PROTOCOL_BINARY_CMD_TAP_VBUCKET_SET:\n            if (settings.engine.v1->tap_notify == NULL) {\n                write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_NOT_SUPPORTED, bodylen);\n            } else {\n                bin_read_chunk(c, bin_reading_packet, c->binary_header.request.bodylen);\n            }\n            break;\n#ifdef SASL_ENABLED\n        case PROTOCOL_BINARY_CMD_SASL_LIST_MECHS:\n            if (extlen == 0 && keylen == 0 && bodylen == 0) {\n                bin_list_sasl_mechs(c);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_SASL_AUTH:\n        case PROTOCOL_BINARY_CMD_SASL_STEP:\n            if (extlen == 0 && keylen != 0) {\n                bin_read_key(c, bin_reading_sasl_auth, 0);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n#endif\n        case PROTOCOL_BINARY_CMD_VERBOSITY:\n            if (extlen == 4 && keylen == 0 && bodylen == 4) {\n                bin_read_chunk(c, bin_reading_packet,\n                               c->binary_header.request.bodylen);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        default:\n            if (settings.engine.v1->unknown_command == NULL) {\n                write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND,\n                                bodylen);\n            } else {\n                bin_read_chunk(c, bin_reading_packet, c->binary_header.request.bodylen);\n            }\n    }\n\n    if (protocol_error)\n        handle_binary_protocol_error(c);\n}\n\nstatic void process_bin_update(conn *c) {\n    char *key;\n    uint16_t nkey;\n    uint32_t vlen;\n    item *it;\n    protocol_binary_request_set* req = binary_get_request(c);\n\n    assert(c != NULL);\n\n    key = binary_get_key(c);\n    nkey = c->binary_header.request.keylen;\n\n    /* fix byteorder in the request */\n    req->message.body.flags = req->message.body.flags;\n    rel_time_t expiration = ntohl(req->message.body.expiration);\n\n    vlen = c->binary_header.request.bodylen - (nkey + c->binary_header.request.extlen);\n\n    if (settings.verbose > 1) {\n        char buffer[1024];\n        const char *prefix;\n        if (c->cmd == PROTOCOL_BINARY_CMD_ADD) {\n            prefix = \"ADD\";\n        } else if (c->cmd == PROTOCOL_BINARY_CMD_SET) {\n            prefix = \"SET\";\n        } else {\n            prefix = \"REPLACE\";\n        }\n\n        size_t nw;\n        nw = key_to_printable_buffer(buffer, sizeof(buffer), c->sfd, true,\n                                     prefix, key, nkey);\n\n        if (nw != -1) {\n            if (snprintf(buffer + nw, sizeof(buffer) - nw,\n                         \" Value len is %d\\n\", vlen)) {\n                settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c, \"%s\",\n                                                buffer);\n            }\n        }\n    }\n\n    if (settings.detail_enabled) {\n        stats_prefix_record_set(key, nkey);\n    }\n\n    ENGINE_ERROR_CODE ret = c->aiostat;\n    c->aiostat = ENGINE_SUCCESS;\n    c->ewouldblock = false;\n    item_info info = { .nvalue = 1 };\n\n    if (ret == ENGINE_SUCCESS) {\n        ret = settings.engine.v1->allocate(settings.engine.v0, c,\n                                           &it, key, nkey,\n                                           vlen,\n                                           req->message.body.flags,\n                                           expiration);\n        if (ret == ENGINE_SUCCESS && !settings.engine.v1->get_item_info(settings.engine.v0,\n                                                                        c, it, &info)) {\n            settings.engine.v1->release(settings.engine.v0, c, it);\n            write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_EINTERNAL, 0);\n            return;\n        }\n    }\n\n    switch (ret) {\n    case ENGINE_SUCCESS:\n        item_set_cas(c, it, c->binary_header.request.cas);\n\n        switch (c->cmd) {\n        case PROTOCOL_BINARY_CMD_ADD:\n            c->store_op = OPERATION_ADD;\n            break;\n        case PROTOCOL_BINARY_CMD_SET:\n            c->store_op = OPERATION_SET;\n            break;\n        case PROTOCOL_BINARY_CMD_REPLACE:\n            c->store_op = OPERATION_REPLACE;\n            break;\n        default:\n            assert(0);\n        }\n\n        if (c->binary_header.request.cas != 0) {\n            c->store_op = OPERATION_CAS;\n        }\n\n        c->item = it;\n        c->ritem = info.value[0].iov_base;\n        c->rlbytes = vlen;\n        conn_set_state(c, conn_nread);\n        c->substate = bin_read_set_value;\n        break;\n    case ENGINE_EWOULDBLOCK:\n        c->ewouldblock = true;\n        break;\n    case ENGINE_DISCONNECT:\n        c->state = conn_closing;\n        break;\n    default:\n        if (ret == ENGINE_E2BIG) {\n            write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_E2BIG, vlen);\n        } else {\n            write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, vlen);\n        }\n\n        /*\n         * Avoid stale data persisting in cache because we failed alloc.\n         * Unacceptable for SET (but only if cas matches).\n         * Anywhere else too?\n         */\n        if (c->cmd == PROTOCOL_BINARY_CMD_SET) {\n            /* @todo fix this for the ASYNC interface! */\n            settings.engine.v1->remove(settings.engine.v0, c, key, nkey,\n                                       ntohll(req->message.header.request.cas),\n                                       c->binary_header.request.vbucket);\n        }\n\n        /* swallow the data line */\n        c->write_and_go = conn_swallow;\n    }\n}\n\nstatic void process_bin_append_prepend(conn *c) {\n    char *key;\n    int nkey;\n    int vlen;\n    item *it;\n\n    assert(c != NULL);\n\n    key = binary_get_key(c);\n    nkey = c->binary_header.request.keylen;\n    vlen = c->binary_header.request.bodylen - nkey;\n\n    if (settings.verbose > 1) {\n        settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                        \"Value len is %d\\n\", vlen);\n    }\n\n    if (settings.detail_enabled) {\n        stats_prefix_record_set(key, nkey);\n    }\n\n    ENGINE_ERROR_CODE ret = c->aiostat;\n    c->aiostat = ENGINE_SUCCESS;\n    c->ewouldblock = false;\n    item_info info = { .nvalue = 1 };\n\n    if (ret == ENGINE_SUCCESS) {\n        ret = settings.engine.v1->allocate(settings.engine.v0, c,\n                                           &it, key, nkey,\n                                           vlen, 0, 0);\n        if (ret == ENGINE_SUCCESS && !settings.engine.v1->get_item_info(settings.engine.v0,\n                                                                        c, it, &info)) {\n            settings.engine.v1->release(settings.engine.v0, c, it);\n            write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_EINTERNAL, 0);\n            return;\n        }\n    }\n\n    switch (ret) {\n    case ENGINE_SUCCESS:\n        item_set_cas(c, it, c->binary_header.request.cas);\n\n        switch (c->cmd) {\n        case PROTOCOL_BINARY_CMD_APPEND:\n            c->store_op = OPERATION_APPEND;\n            break;\n        case PROTOCOL_BINARY_CMD_PREPEND:\n            c->store_op = OPERATION_PREPEND;\n            break;\n        default:\n            assert(0);\n        }\n\n        c->item = it;\n        c->ritem = info.value[0].iov_base;\n        c->rlbytes = vlen;\n        conn_set_state(c, conn_nread);\n        c->substate = bin_read_set_value;\n        break;\n    case ENGINE_EWOULDBLOCK:\n        c->ewouldblock = true;\n        break;\n    case ENGINE_DISCONNECT:\n        c->state = conn_closing;\n        break;\n    default:\n        if (ret == ENGINE_E2BIG) {\n            write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_E2BIG, vlen);\n        } else {\n            write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, vlen);\n        }\n        /* swallow the data line */\n        c->write_and_go = conn_swallow;\n    }\n}\n\nstatic void process_bin_flush(conn *c) {\n    time_t exptime = 0;\n    protocol_binary_request_flush* req = binary_get_request(c);\n\n    if (c->binary_header.request.extlen == sizeof(req->message.body)) {\n        exptime = ntohl(req->message.body.expiration);\n    }\n\n    if (settings.verbose > 1) {\n        settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                        \"%d: flush %ld\", c->sfd,\n                                        (long)exptime);\n    }\n\n    ENGINE_ERROR_CODE ret;\n    ret = settings.engine.v1->flush(settings.engine.v0, c, exptime);\n\n    if (ret == ENGINE_SUCCESS) {\n        write_bin_response(c, NULL, 0, 0, 0);\n    } else if (ret == ENGINE_ENOTSUP) {\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_NOT_SUPPORTED, 0);\n    } else {\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_EINVAL, 0);\n    }\n    STATS_NOKEY(c, cmd_flush);\n}\n\nstatic void process_bin_delete(conn *c) {\n    protocol_binary_request_delete* req = binary_get_request(c);\n\n    char* key = binary_get_key(c);\n    size_t nkey = c->binary_header.request.keylen;\n\n    assert(c != NULL);\n\n    if (settings.verbose > 1) {\n        char buffer[1024];\n        if (key_to_printable_buffer(buffer, sizeof(buffer), c->sfd, true,\n                                    \"DELETE\", key, nkey) != -1) {\n            settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c, \"%s\\n\",\n                                            buffer);\n        }\n    }\n\n    ENGINE_ERROR_CODE ret = c->aiostat;\n    c->aiostat = ENGINE_SUCCESS;\n    c->ewouldblock = false;\n\n    if (ret == ENGINE_SUCCESS) {\n        if (settings.detail_enabled) {\n            stats_prefix_record_delete(key, nkey);\n        }\n        ret = settings.engine.v1->remove(settings.engine.v0, c, key, nkey,\n                                         ntohll(req->message.header.request.cas),\n                                         c->binary_header.request.vbucket);\n    }\n\n    /* For some reason the SLAB_INCR tries to access this... */\n    item_info info = { .nvalue = 1 };\n    switch (ret) {\n    case ENGINE_SUCCESS:\n        write_bin_response(c, NULL, 0, 0, 0);\n        SLAB_INCR(c, delete_hits, key, nkey);\n        break;\n    case ENGINE_KEY_EEXISTS:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS, 0);\n        break;\n    case ENGINE_KEY_ENOENT:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, 0);\n        STATS_INCR(c, delete_misses, key, nkey);\n        break;\n    case ENGINE_NOT_MY_VBUCKET:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_NOT_MY_VBUCKET, 0);\n        break;\n    case ENGINE_EWOULDBLOCK:\n        c->ewouldblock = true;\n        break;\n    default:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_EINVAL, 0);\n    }\n}\n\nstatic void complete_nread_binary(conn *c) {\n    assert(c != NULL);\n    assert(c->cmd >= 0);\n\n    switch(c->substate) {\n    case bin_reading_set_header:\n        if (c->cmd == PROTOCOL_BINARY_CMD_APPEND ||\n                c->cmd == PROTOCOL_BINARY_CMD_PREPEND) {\n            process_bin_append_prepend(c);\n        } else {\n            process_bin_update(c);\n        }\n        break;\n    case bin_read_set_value:\n        complete_update_bin(c);\n        break;\n    case bin_reading_get_key:\n        process_bin_get(c);\n        break;\n    case bin_reading_stat:\n        process_bin_stat(c);\n        break;\n    case bin_reading_del_header:\n        process_bin_delete(c);\n        break;\n    case bin_reading_incr_header:\n        complete_incr_bin(c);\n        break;\n    case bin_read_flush_exptime:\n        process_bin_flush(c);\n        break;\n    case bin_reading_sasl_auth:\n        process_bin_sasl_auth(c);\n        break;\n    case bin_reading_sasl_auth_data:\n        process_bin_complete_sasl_auth(c);\n        break;\n    case bin_reading_packet:\n        if (c->binary_header.request.magic == PROTOCOL_BINARY_RES) {\n            RESPONSE_HANDLER handler;\n            handler = response_handlers[c->binary_header.request.opcode];\n            if (handler) {\n                handler(c);\n            } else {\n                settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                       \"%d: ERROR: Unsupported response packet received: %u\\n\",\n                        c->sfd, (unsigned int)c->binary_header.request.opcode);\n                conn_set_state(c, conn_closing);\n            }\n        } else {\n            process_bin_packet(c);\n        }\n        break;\n    default:\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                \"Not handling substate %d\\n\", c->substate);\n        abort();\n    }\n}\n\nstatic void reset_cmd_handler(conn *c) {\n    c->sbytes = 0;\n    c->ascii_cmd = NULL;\n    c->cmd = -1;\n    c->substate = bin_no_state;\n    if(c->item != NULL) {\n        settings.engine.v1->release(settings.engine.v0, c, c->item);\n        c->item = NULL;\n    }\n    conn_shrink(c);\n    if (c->rbytes > 0) {\n        conn_set_state(c, conn_parse_cmd);\n    } else {\n        conn_set_state(c, conn_waiting);\n    }\n}\n\nstatic ENGINE_ERROR_CODE ascii_response_handler(const void *cookie,\n                                                int nbytes,\n                                                const char *dta)\n{\n    conn *c = (conn*)cookie;\n    char *buf;\n    if (!grow_dynamic_buffer(c, nbytes)) {\n        if (settings.verbose > 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                    \"<%d ERROR: Failed to allocate memory for response\\n\",\n                    c->sfd);\n        }\n        return ENGINE_ENOMEM;\n    }\n\n    buf = c->dynamic_buffer.buffer + c->dynamic_buffer.offset;\n    memcpy(buf, dta, nbytes);\n    c->dynamic_buffer.offset += nbytes;\n\n    return ENGINE_SUCCESS;\n}\n\nstatic void complete_nread_ascii(conn *c) {\n    if (c->ascii_cmd != NULL) {\n        c->ewouldblock = false;\n        switch (c->ascii_cmd->execute(c->ascii_cmd->cookie, c, 0, NULL,\n                                      ascii_response_handler)) {\n        case ENGINE_SUCCESS:\n            if (c->dynamic_buffer.buffer != NULL) {\n                write_and_free(c, c->dynamic_buffer.buffer,\n                               c->dynamic_buffer.offset);\n                c->dynamic_buffer.buffer = NULL;\n            } else {\n                conn_set_state(c, conn_new_cmd);\n            }\n            break;\n        case ENGINE_EWOULDBLOCK:\n            c->ewouldblock = true;\n            break;\n        case ENGINE_DISCONNECT:\n        default:\n            conn_set_state(c, conn_closing);\n        }\n    } else {\n        complete_update_ascii(c);\n    }\n}\n\nstatic void complete_nread(conn *c) {\n    assert(c != NULL);\n    assert(c->protocol == ascii_prot\n           || c->protocol == binary_prot);\n\n    if (c->protocol == ascii_prot) {\n        complete_nread_ascii(c);\n    } else if (c->protocol == binary_prot) {\n        complete_nread_binary(c);\n    }\n}\n\n#define COMMAND_TOKEN 0\n#define SUBCOMMAND_TOKEN 1\n#define KEY_TOKEN 1\n\n#define MAX_TOKENS 30\n\n/*\n * Tokenize the command string by replacing whitespace with '\\0' and update\n * the token array tokens with pointer to start of each token and length.\n * Returns total number of tokens.  The last valid token is the terminal\n * token (value points to the first unprocessed character of the string and\n * length zero).\n *\n * Usage example:\n *\n *  while(tokenize_command(command, ncommand, tokens, max_tokens) > 0) {\n *      for(int ix = 0; tokens[ix].length != 0; ix++) {\n *          ...\n *      }\n *      ncommand = tokens[ix].value - command;\n *      command  = tokens[ix].value;\n *   }\n */\nstatic size_t tokenize_command(char *command, token_t *tokens, const size_t max_tokens) {\n    char *s, *e;\n    size_t ntokens = 0;\n\n    assert(command != NULL && tokens != NULL && max_tokens > 1);\n\n    for (s = e = command; ntokens < max_tokens - 1; ++e) {\n        if (*e == ' ') {\n            if (s != e) {\n                tokens[ntokens].value = s;\n                tokens[ntokens].length = e - s;\n                ntokens++;\n                *e = '\\0';\n            }\n            s = e + 1;\n        }\n        else if (*e == '\\0') {\n            if (s != e) {\n                tokens[ntokens].value = s;\n                tokens[ntokens].length = e - s;\n                ntokens++;\n            }\n\n            break; /* string end */\n        }\n    }\n\n    /*\n     * If we scanned the whole string, the terminal value pointer is null,\n     * otherwise it is the first unprocessed character.\n     */\n    tokens[ntokens].value =  *e == '\\0' ? NULL : e;\n    tokens[ntokens].length = 0;\n    ntokens++;\n\n    return ntokens;\n}\n\nstatic void detokenize(token_t *tokens, int ntokens, char **out, int *nbytes) {\n    int i, nb;\n    char *buf, *p;\n\n    nb = ntokens; // account for spaces, which is ntokens-1, plus the null\n    for (i = 0; i < ntokens; ++i) {\n        nb += tokens[i].length;\n    }\n\n    buf = malloc(nb * sizeof(char));\n    if (buf != NULL) {\n        p = buf;\n        for (i = 0; i < ntokens; ++i) {\n            memcpy(p, tokens[i].value, tokens[i].length);\n            p += tokens[i].length;\n            *p = ' ';\n            p++;\n        }\n        buf[nb - 1] = '\\0';\n        *nbytes = nb - 1;\n        *out = buf;\n    }\n}\n\n\n/* set up a connection to write a buffer then free it, used for stats */\nstatic void write_and_free(conn *c, char *buf, int bytes) {\n    if (buf) {\n        c->write_and_free = buf;\n        c->wcurr = buf;\n        c->wbytes = bytes;\n        conn_set_state(c, conn_write);\n        c->write_and_go = conn_new_cmd;\n    } else {\n        out_string(c, \"SERVER_ERROR out of memory writing stats\");\n    }\n}\n\nstatic inline bool set_noreply_maybe(conn *c, token_t *tokens, size_t ntokens)\n{\n    int noreply_index = ntokens - 2;\n\n    /*\n      NOTE: this function is not the first place where we are going to\n      send the reply.  We could send it instead from process_command()\n      if the request line has wrong number of tokens.  However parsing\n      malformed line for \"noreply\" option is not reliable anyway, so\n      it can't be helped.\n    */\n    if (tokens[noreply_index].value\n        && strcmp(tokens[noreply_index].value, \"noreply\") == 0) {\n        c->noreply = true;\n    }\n    return c->noreply;\n}\n\nvoid append_stat(const char *name, ADD_STAT add_stats, conn *c,\n                 const char *fmt, ...) {\n    char val_str[STAT_VAL_LEN];\n    int vlen;\n    va_list ap;\n\n    assert(name);\n    assert(add_stats);\n    assert(c);\n    assert(fmt);\n\n    va_start(ap, fmt);\n    vlen = vsnprintf(val_str, sizeof(val_str) - 1, fmt, ap);\n    va_end(ap);\n\n    add_stats(name, strlen(name), val_str, vlen, c);\n}\n\ninline static void process_stats_detail(conn *c, const char *command) {\n    assert(c != NULL);\n\n    if (settings.allow_detailed) {\n        if (strcmp(command, \"on\") == 0) {\n            settings.detail_enabled = 1;\n            out_string(c, \"OK\");\n        }\n        else if (strcmp(command, \"off\") == 0) {\n            settings.detail_enabled = 0;\n            out_string(c, \"OK\");\n        }\n        else if (strcmp(command, \"dump\") == 0) {\n            int len;\n            char *stats = stats_prefix_dump(&len);\n            write_and_free(c, stats, len);\n        }\n        else {\n            out_string(c, \"CLIENT_ERROR usage: stats detail on|off|dump\");\n        }\n    }\n    else {\n        out_string(c, \"CLIENT_ERROR detailed stats disabled\");\n    }\n}\n\nstatic void aggregate_callback(void *in, void *out) {\n    struct thread_stats *out_thread_stats = out;\n    struct independent_stats *in_independent_stats = in;\n    threadlocal_stats_aggregate(in_independent_stats->thread_stats,\n                                out_thread_stats);\n}\n\n/* return server specific stats only */\nstatic void server_stats(ADD_STAT add_stats, conn *c, bool aggregate) {\n    pid_t pid = getpid();\n    rel_time_t now = current_time;\n\n    struct thread_stats thread_stats;\n    threadlocal_stats_clear(&thread_stats);\n\n    if (aggregate && settings.engine.v1->aggregate_stats != NULL) {\n        settings.engine.v1->aggregate_stats(settings.engine.v0,\n                                            (const void *)c,\n                                            aggregate_callback,\n                                            &thread_stats);\n    } else {\n        threadlocal_stats_aggregate(get_independent_stats(c)->thread_stats,\n                                    &thread_stats);\n    }\n\n    struct slab_stats slab_stats;\n    slab_stats_aggregate(&thread_stats, &slab_stats);\n\n#ifndef __WIN32__\n    struct rusage usage;\n    getrusage(RUSAGE_SELF, &usage);\n#endif\n\n    STATS_LOCK();\n\n    APPEND_STAT(\"pid\", \"%lu\", (long)pid);\n    APPEND_STAT(\"uptime\", \"%u\", now);\n    APPEND_STAT(\"time\", \"%ld\", now + (long)process_started);\n    APPEND_STAT(\"version\", \"%s\", VERSION);\n    APPEND_STAT(\"libevent\", \"%s\", event_get_version());\n    APPEND_STAT(\"pointer_size\", \"%d\", (int)(8 * sizeof(void *)));\n\n#ifndef __WIN32__\n    append_stat(\"rusage_user\", add_stats, c, \"%ld.%06ld\",\n                (long)usage.ru_utime.tv_sec,\n                (long)usage.ru_utime.tv_usec);\n    append_stat(\"rusage_system\", add_stats, c, \"%ld.%06ld\",\n                (long)usage.ru_stime.tv_sec,\n                (long)usage.ru_stime.tv_usec);\n#endif\n\n    APPEND_STAT(\"daemon_connections\", \"%u\", stats.daemon_conns);\n    APPEND_STAT(\"curr_connections\", \"%u\", stats.curr_conns);\n    APPEND_STAT(\"total_connections\", \"%u\", stats.total_conns);\n    APPEND_STAT(\"connection_structures\", \"%u\", stats.conn_structs);\n    APPEND_STAT(\"cmd_get\", \"%\"PRIu64, thread_stats.cmd_get);\n    APPEND_STAT(\"cmd_set\", \"%\"PRIu64, slab_stats.cmd_set);\n    APPEND_STAT(\"cmd_flush\", \"%\"PRIu64, thread_stats.cmd_flush);\n    APPEND_STAT(\"auth_cmds\", \"%\"PRIu64, thread_stats.auth_cmds);\n    APPEND_STAT(\"auth_errors\", \"%\"PRIu64, thread_stats.auth_errors);\n    APPEND_STAT(\"get_hits\", \"%\"PRIu64, slab_stats.get_hits);\n    APPEND_STAT(\"get_misses\", \"%\"PRIu64, thread_stats.get_misses);\n    APPEND_STAT(\"delete_misses\", \"%\"PRIu64, thread_stats.delete_misses);\n    APPEND_STAT(\"delete_hits\", \"%\"PRIu64, slab_stats.delete_hits);\n    APPEND_STAT(\"incr_misses\", \"%\"PRIu64, thread_stats.incr_misses);\n    APPEND_STAT(\"incr_hits\", \"%\"PRIu64, thread_stats.incr_hits);\n    APPEND_STAT(\"decr_misses\", \"%\"PRIu64, thread_stats.decr_misses);\n    APPEND_STAT(\"decr_hits\", \"%\"PRIu64, thread_stats.decr_hits);\n    APPEND_STAT(\"cas_misses\", \"%\"PRIu64, thread_stats.cas_misses);\n    APPEND_STAT(\"cas_hits\", \"%\"PRIu64, slab_stats.cas_hits);\n    APPEND_STAT(\"cas_badval\", \"%\"PRIu64, slab_stats.cas_badval);\n    APPEND_STAT(\"bytes_read\", \"%\"PRIu64, thread_stats.bytes_read);\n    APPEND_STAT(\"bytes_written\", \"%\"PRIu64, thread_stats.bytes_written);\n    APPEND_STAT(\"limit_maxbytes\", \"%\"PRIu64, settings.maxbytes);\n    APPEND_STAT(\"accepting_conns\", \"%u\",  is_listen_disabled() ? 0 : 1);\n    APPEND_STAT(\"listen_disabled_num\", \"%\"PRIu64, get_listen_disabled_num());\n    APPEND_STAT(\"rejected_conns\", \"%\" PRIu64, (unsigned long long)stats.rejected_conns);\n    APPEND_STAT(\"threads\", \"%d\", settings.num_threads);\n    APPEND_STAT(\"conn_yields\", \"%\" PRIu64, (unsigned long long)thread_stats.conn_yields);\n    STATS_UNLOCK();\n\n    /*\n     * Add tap stats (only if non-zero)\n     */\n    struct tap_stats ts;\n    pthread_mutex_lock(&tap_stats.mutex);\n    ts = tap_stats;\n    pthread_mutex_unlock(&tap_stats.mutex);\n\n    if (ts.sent.connect) {\n        APPEND_STAT(\"tap_connect_sent\", \"%\"PRIu64, ts.sent.connect);\n    }\n    if (ts.sent.mutation) {\n        APPEND_STAT(\"tap_mutation_sent\", \"%\"PRIu64, ts.sent.mutation);\n    }\n    if (ts.sent.checkpoint_start) {\n        APPEND_STAT(\"tap_checkpoint_start_sent\", \"%\"PRIu64, ts.sent.checkpoint_start);\n    }\n    if (ts.sent.checkpoint_end) {\n        APPEND_STAT(\"tap_checkpoint_end_sent\", \"%\"PRIu64, ts.sent.checkpoint_end);\n    }\n    if (ts.sent.delete) {\n        APPEND_STAT(\"tap_delete_sent\", \"%\"PRIu64, ts.sent.delete);\n    }\n    if (ts.sent.flush) {\n        APPEND_STAT(\"tap_flush_sent\", \"%\"PRIu64, ts.sent.flush);\n    }\n    if (ts.sent.opaque) {\n        APPEND_STAT(\"tap_opaque_sent\", \"%\"PRIu64, ts.sent.opaque);\n    }\n    if (ts.sent.vbucket_set) {\n        APPEND_STAT(\"tap_vbucket_set_sent\", \"%\"PRIu64,\n                    ts.sent.vbucket_set);\n    }\n    if (ts.received.connect) {\n        APPEND_STAT(\"tap_connect_received\", \"%\"PRIu64, ts.received.connect);\n    }\n    if (ts.received.mutation) {\n        APPEND_STAT(\"tap_mutation_received\", \"%\"PRIu64, ts.received.mutation);\n    }\n    if (ts.received.checkpoint_start) {\n        APPEND_STAT(\"tap_checkpoint_start_received\", \"%\"PRIu64, ts.received.checkpoint_start);\n    }\n    if (ts.received.checkpoint_end) {\n        APPEND_STAT(\"tap_checkpoint_end_received\", \"%\"PRIu64, ts.received.checkpoint_end);\n    }\n    if (ts.received.delete) {\n        APPEND_STAT(\"tap_delete_received\", \"%\"PRIu64, ts.received.delete);\n    }\n    if (ts.received.flush) {\n        APPEND_STAT(\"tap_flush_received\", \"%\"PRIu64, ts.received.flush);\n    }\n    if (ts.received.opaque) {\n        APPEND_STAT(\"tap_opaque_received\", \"%\"PRIu64, ts.received.opaque);\n    }\n    if (ts.received.vbucket_set) {\n        APPEND_STAT(\"tap_vbucket_set_received\", \"%\"PRIu64,\n                    ts.received.vbucket_set);\n    }\n}\n\nstatic void process_stat_settings(ADD_STAT add_stats, void *c) {\n    assert(add_stats);\n    APPEND_STAT(\"maxbytes\", \"%u\", (unsigned int)settings.maxbytes);\n    APPEND_STAT(\"maxconns\", \"%d\", settings.maxconns);\n    APPEND_STAT(\"tcpport\", \"%d\", settings.port);\n    APPEND_STAT(\"udpport\", \"%d\", settings.udpport);\n    APPEND_STAT(\"inter\", \"%s\", settings.inter ? settings.inter : \"NULL\");\n    APPEND_STAT(\"verbosity\", \"%d\", settings.verbose);\n    APPEND_STAT(\"oldest\", \"%lu\", (unsigned long)settings.oldest_live);\n    APPEND_STAT(\"evictions\", \"%s\", settings.evict_to_free ? \"on\" : \"off\");\n    APPEND_STAT(\"domain_socket\", \"%s\",\n                settings.socketpath ? settings.socketpath : \"NULL\");\n    APPEND_STAT(\"umask\", \"%o\", settings.access);\n    APPEND_STAT(\"growth_factor\", \"%.2f\", settings.factor);\n    APPEND_STAT(\"chunk_size\", \"%d\", settings.chunk_size);\n    APPEND_STAT(\"num_threads\", \"%d\", settings.num_threads);\n    APPEND_STAT(\"num_threads_per_udp\", \"%d\", settings.num_threads_per_udp);\n    APPEND_STAT(\"stat_key_prefix\", \"%c\", settings.prefix_delimiter);\n    APPEND_STAT(\"detail_enabled\", \"%s\",\n                settings.detail_enabled ? \"yes\" : \"no\");\n    APPEND_STAT(\"allow_detailed\", \"%s\",\n                settings.allow_detailed ? \"yes\" : \"no\");\n    APPEND_STAT(\"reqs_per_event\", \"%d\", settings.reqs_per_event);\n    APPEND_STAT(\"reqs_per_tap_event\", \"%d\", settings.reqs_per_tap_event);\n    APPEND_STAT(\"cas_enabled\", \"%s\", settings.use_cas ? \"yes\" : \"no\");\n    APPEND_STAT(\"tcp_backlog\", \"%d\", settings.backlog);\n    APPEND_STAT(\"binding_protocol\", \"%s\",\n                prot_text(settings.binding_protocol));\n#ifdef SASL_ENABLED\n    APPEND_STAT(\"auth_enabled_sasl\", \"%s\", \"yes\");\n#else\n    APPEND_STAT(\"auth_enabled_sasl\", \"%s\", \"no\");\n#endif\n\n#ifdef ENABLE_ISASL\n    APPEND_STAT(\"auth_sasl_engine\", \"%s\", \"isasl\");\n#elif defined(ENABLE_SASL)\n    APPEND_STAT(\"auth_sasl_engine\", \"%s\", \"cyrus\");\n#else\n    APPEND_STAT(\"auth_sasl_engine\", \"%s\", \"none\");\n#endif\n    APPEND_STAT(\"auth_required_sasl\", \"%s\", settings.require_sasl ? \"yes\" : \"no\");\n    APPEND_STAT(\"item_size_max\", \"%d\", settings.item_size_max);\n    APPEND_STAT(\"topkeys\", \"%d\", settings.topkeys);\n\n    for (EXTENSION_DAEMON_DESCRIPTOR *ptr = settings.extensions.daemons;\n         ptr != NULL;\n         ptr = ptr->next) {\n        APPEND_STAT(\"extension\", \"%s\", ptr->get_name());\n    }\n\n    APPEND_STAT(\"logger\", \"%s\", settings.extensions.logger->get_name());\n\n    for (EXTENSION_ASCII_PROTOCOL_DESCRIPTOR *ptr = settings.extensions.ascii;\n         ptr != NULL;\n         ptr = ptr->next) {\n        APPEND_STAT(\"ascii_extension\", \"%s\", ptr->get_name(ptr->cookie));\n    }\n\n    for (EXTENSION_BINARY_PROTOCOL_DESCRIPTOR *ptr = settings.extensions.binary;\n         ptr != NULL;\n         ptr = ptr->next) {\n        APPEND_STAT(\"binary_extension\", \"%s\", ptr->get_name());\n    }\n}\n\nstatic char *process_stat(conn *c, token_t *tokens, const size_t ntokens) {\n    const char *subcommand = tokens[SUBCOMMAND_TOKEN].value;\n    c->dynamic_buffer.offset = 0;\n\n    if (ntokens == 2) {\n        ENGINE_ERROR_CODE ret = c->aiostat;\n        c->aiostat = ENGINE_SUCCESS;\n        c->ewouldblock = false;\n        if (ret == ENGINE_SUCCESS) {\n            server_stats(&append_stats, c, false);\n            ret = settings.engine.v1->get_stats(settings.engine.v0, c,\n                                                NULL, 0, &append_stats);\n            if (ret == ENGINE_EWOULDBLOCK) {\n                c->ewouldblock = true;\n                return c->rcurr + 5;\n            }\n        }\n    } else if (strcmp(subcommand, \"reset\") == 0) {\n        stats_reset(c);\n        out_string(c, \"RESET\");\n        return NULL;\n    } else if (strcmp(subcommand, \"detail\") == 0) {\n        /* NOTE: how to tackle detail with binary? */\n        if (ntokens < 4) {\n            process_stats_detail(c, \"\");  /* outputs the error message */\n        } else {\n            process_stats_detail(c, tokens[2].value);\n        }\n        /* Output already generated */\n        return NULL;\n    } else if (strcmp(subcommand, \"settings\") == 0) {\n        process_stat_settings(&append_stats, c);\n    } else if (strcmp(subcommand, \"cachedump\") == 0) {\n        char *buf = NULL;\n        unsigned int bytes = 0, id, limit = 0;\n\n        if (ntokens < 5) {\n            out_string(c, \"CLIENT_ERROR bad command line\");\n            return NULL;\n        }\n\n        if (!safe_strtoul(tokens[2].value, &id) ||\n            !safe_strtoul(tokens[3].value, &limit)) {\n            out_string(c, \"CLIENT_ERROR bad command line format\");\n            return NULL;\n        }\n\n        if (id >= POWER_LARGEST) {\n            out_string(c, \"CLIENT_ERROR Illegal slab id\");\n            return NULL;\n        }\n\n#ifdef FUTURE\n        buf = item_cachedump(id, limit, &bytes);\n#endif\n        write_and_free(c, buf, bytes);\n        return NULL;\n    } else if (strcmp(subcommand, \"aggregate\") == 0) {\n        server_stats(&append_stats, c, true);\n    } else if (strcmp(subcommand, \"topkeys\") == 0) {\n        topkeys_t *tk = get_independent_stats(c)->topkeys;\n        if (tk != NULL) {\n            topkeys_stats(tk, c, current_time, append_stats);\n        } else {\n            out_string(c, \"ERROR\");\n            return NULL;\n        }\n    } else {\n        /* getting here means that the subcommand is either engine specific or\n           is invalid. query the engine and see. */\n        ENGINE_ERROR_CODE ret = c->aiostat;\n        c->aiostat = ENGINE_SUCCESS;\n        c->ewouldblock = false;\n        if (ret == ENGINE_SUCCESS) {\n            char *buf = NULL;\n            int nb = -1;\n            detokenize(&tokens[1], ntokens - 2, &buf, &nb);\n            ret = settings.engine.v1->get_stats(settings.engine.v0, c, buf,\n                                                nb, append_stats);\n            free(buf);\n        }\n\n        switch (ret) {\n        case ENGINE_SUCCESS:\n            append_stats(NULL, 0, NULL, 0, c);\n            write_and_free(c, c->dynamic_buffer.buffer, c->dynamic_buffer.offset);\n            c->dynamic_buffer.buffer = NULL;\n            break;\n        case ENGINE_ENOMEM:\n            out_string(c, \"SERVER_ERROR out of memory writing stats\");\n            break;\n        case ENGINE_DISCONNECT:\n            c->state = conn_closing;\n            break;\n        case ENGINE_ENOTSUP:\n            out_string(c, \"SERVER_ERROR not supported\");\n            break;\n        case ENGINE_EWOULDBLOCK:\n            c->ewouldblock = true;\n            return tokens[SUBCOMMAND_TOKEN].value;\n        default:\n            out_string(c, \"ERROR\");\n            break;\n        }\n\n        return NULL;\n    }\n\n    /* append terminator and start the transfer */\n    append_stats(NULL, 0, NULL, 0, c);\n\n    if (c->dynamic_buffer.buffer == NULL) {\n        out_string(c, \"SERVER_ERROR out of memory writing stats\");\n    } else {\n        write_and_free(c, c->dynamic_buffer.buffer, c->dynamic_buffer.offset);\n        c->dynamic_buffer.buffer = NULL;\n    }\n\n    return NULL;\n}\n\n/**\n * Get a suffix buffer and insert it into the list of used suffix buffers\n * @param c the connection object\n * @return a pointer to a new suffix buffer or NULL if allocation failed\n */\nstatic char *get_suffix_buffer(conn *c) {\n    if (c->suffixleft == c->suffixsize) {\n        char **new_suffix_list;\n        size_t sz = sizeof(char*) * c->suffixsize * 2;\n\n        new_suffix_list = realloc(c->suffixlist, sz);\n        if (new_suffix_list) {\n            c->suffixsize *= 2;\n            c->suffixlist = new_suffix_list;\n        } else {\n            if (settings.verbose > 1) {\n                settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                        \"=%d Failed to resize suffix buffer\\n\", c->sfd);\n            }\n\n            return NULL;\n        }\n    }\n\n    char *suffix = cache_alloc(c->thread->suffix_cache);\n    if (suffix != NULL) {\n        *(c->suffixlist + c->suffixleft) = suffix;\n        ++c->suffixleft;\n    }\n\n    return suffix;\n}\n\n/* ntokens is overwritten here... shrug.. */\nstatic inline char* process_get_command(conn *c, token_t *tokens, size_t ntokens, bool return_cas) {\n    char *key;\n    size_t nkey;\n    int i = c->ileft;\n    item *it;\n    token_t *key_token = &tokens[KEY_TOKEN];\n    assert(c != NULL);\n\n    do {\n        while(key_token->length != 0) {\n\n            key = key_token->value;\n            nkey = key_token->length;\n\n            if(nkey > KEY_MAX_LENGTH) {\n                out_string(c, \"CLIENT_ERROR bad command line format\");\n                return NULL;\n            }\n\n            ENGINE_ERROR_CODE ret = c->aiostat;\n            c->aiostat = ENGINE_SUCCESS;\n\n            if (ret == ENGINE_SUCCESS) {\n                ret = settings.engine.v1->get(settings.engine.v0, c, &it, key, nkey, 0);\n            }\n\n            switch (ret) {\n            case ENGINE_EWOULDBLOCK:\n                c->ewouldblock = true;\n                c->ileft = i;\n                return key;\n\n            case ENGINE_SUCCESS:\n                break;\n            case ENGINE_KEY_ENOENT:\n            default:\n                it = NULL;\n                break;\n            }\n\n            if (settings.detail_enabled) {\n                stats_prefix_record_get(key, nkey, NULL != it);\n            }\n\n            if (it) {\n                item_info info = { .nvalue = 1 };\n                if (!settings.engine.v1->get_item_info(settings.engine.v0, c, it,\n                                                       &info)) {\n                    settings.engine.v1->release(settings.engine.v0, c, it);\n                    out_string(c, \"SERVER_ERROR error getting item data\");\n                    break;\n                }\n\n                if (i >= c->isize) {\n                    item **new_list = realloc(c->ilist, sizeof(item *) * c->isize * 2);\n                    if (new_list) {\n                        c->isize *= 2;\n                        c->ilist = new_list;\n                    } else {\n                        settings.engine.v1->release(settings.engine.v0, c, it);\n                        break;\n                    }\n                }\n\n                /* Rebuild the suffix */\n                char *suffix = get_suffix_buffer(c);\n                if (suffix == NULL) {\n                    out_string(c, \"SERVER_ERROR out of memory rebuilding suffix\");\n                    settings.engine.v1->release(settings.engine.v0, c, it);\n                    return NULL;\n                }\n                int suffix_len = snprintf(suffix, SUFFIX_SIZE,\n                                          \" %u %u\\r\\n\", htonl(info.flags),\n                                          info.nbytes);\n\n                /*\n                 * Construct the response. Each hit adds three elements to the\n                 * outgoing data list:\n                 *   \"VALUE \"\n                 *   key\n                 *   \" \" + flags + \" \" + data length + \"\\r\\n\" + data (with \\r\\n)\n                 */\n\n                MEMCACHED_COMMAND_GET(c->sfd, info.key, info.nkey,\n                                      info.nbytes, info.cas);\n                if (return_cas)\n                {\n\n                  char *cas = get_suffix_buffer(c);\n                  if (cas == NULL) {\n                    out_string(c, \"SERVER_ERROR out of memory making CAS suffix\");\n                    settings.engine.v1->release(settings.engine.v0, c, it);\n                    return NULL;\n                  }\n                  int cas_len = snprintf(cas, SUFFIX_SIZE, \" %\"PRIu64\"\\r\\n\",\n                                         info.cas);\n                  if (add_iov(c, \"VALUE \", 6) != 0 ||\n                      add_iov(c, info.key, info.nkey) != 0 ||\n                      add_iov(c, suffix, suffix_len - 2) != 0 ||\n                      add_iov(c, cas, cas_len) != 0 ||\n                      add_iov(c, info.value[0].iov_base, info.value[0].iov_len) != 0 ||\n                      add_iov(c, \"\\r\\n\", 2) != 0)\n                      {\n                          settings.engine.v1->release(settings.engine.v0, c, it);\n                          break;\n                      }\n                }\n                else\n                {\n                  if (add_iov(c, \"VALUE \", 6) != 0 ||\n                      add_iov(c, info.key, info.nkey) != 0 ||\n                      add_iov(c, suffix, suffix_len) != 0 ||\n                      add_iov(c, info.value[0].iov_base, info.value[0].iov_len) != 0 ||\n                      add_iov(c, \"\\r\\n\", 2) != 0)\n                      {\n                          settings.engine.v1->release(settings.engine.v0, c, it);\n                          break;\n                      }\n                }\n\n\n                if (settings.verbose > 1) {\n                    settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                                    \">%d sending key %s\\n\",\n                                                    c->sfd, info.key);\n                }\n\n                /* item_get() has incremented it->refcount for us */\n                STATS_HIT(c, get, key, nkey);\n                *(c->ilist + i) = it;\n                i++;\n\n            } else {\n                STATS_MISS(c, get, key, nkey);\n                MEMCACHED_COMMAND_GET(c->sfd, key, nkey, -1, 0);\n            }\n\n            key_token++;\n        }\n\n        /*\n         * If the command string hasn't been fully processed, get the next set\n         * of tokens.\n         */\n        if(key_token->value != NULL) {\n            ntokens = tokenize_command(key_token->value, tokens, MAX_TOKENS);\n            key_token = tokens;\n        }\n\n    } while(key_token->value != NULL);\n\n    c->icurr = c->ilist;\n    c->ileft = i;\n    c->suffixcurr = c->suffixlist;\n\n    if (settings.verbose > 1) {\n        settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                        \">%d END\\n\", c->sfd);\n    }\n\n    /*\n        If the loop was terminated because of out-of-memory, it is not\n        reliable to add END\\r\\n to the buffer, because it might not end\n        in \\r\\n. So we send SERVER_ERROR instead.\n    */\n    if (key_token->value != NULL || add_iov(c, \"END\\r\\n\", 5) != 0\n        || (IS_UDP(c->transport) && build_udp_headers(c) != 0)) {\n        out_string(c, \"SERVER_ERROR out of memory writing get response\");\n    }\n    else {\n        conn_set_state(c, conn_mwrite);\n        c->msgcurr = 0;\n    }\n\n    return NULL;\n}\n\nstatic void process_update_command(conn *c, token_t *tokens, const size_t ntokens, ENGINE_STORE_OPERATION store_op, bool handle_cas) {\n    char *key;\n    size_t nkey;\n    unsigned int flags;\n    int32_t exptime_int = 0;\n    time_t exptime;\n    int vlen;\n    uint64_t req_cas_id=0;\n    item *it;\n\n    assert(c != NULL);\n\n    set_noreply_maybe(c, tokens, ntokens);\n\n    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {\n        out_string(c, \"CLIENT_ERROR bad command line format\");\n        return;\n    }\n\n    key = tokens[KEY_TOKEN].value;\n    nkey = tokens[KEY_TOKEN].length;\n\n    if (! (safe_strtoul(tokens[2].value, (uint32_t *)&flags)\n           && safe_strtol(tokens[3].value, &exptime_int)\n           && safe_strtol(tokens[4].value, (int32_t *)&vlen))) {\n        out_string(c, \"CLIENT_ERROR bad command line format\");\n        return;\n    }\n\n    /* Ubuntu 8.04 breaks when I pass exptime to safe_strtol */\n    exptime = exptime_int;\n\n    // does cas value exist?\n    if (handle_cas) {\n        if (!safe_strtoull(tokens[5].value, &req_cas_id)) {\n            out_string(c, \"CLIENT_ERROR bad command line format\");\n            return;\n        }\n    }\n\n    if (vlen < 0) {\n        out_string(c, \"CLIENT_ERROR bad command line format\");\n        return;\n    }\n\n    if (settings.detail_enabled) {\n        stats_prefix_record_set(key, nkey);\n    }\n\n    ENGINE_ERROR_CODE ret = c->aiostat;\n    c->aiostat = ENGINE_SUCCESS;\n    c->ewouldblock = false;\n\n    if (ret == ENGINE_SUCCESS) {\n        ret = settings.engine.v1->allocate(settings.engine.v0, c,\n                                           &it, key, nkey,\n                                           vlen, htonl(flags), exptime);\n    }\n\n    item_info info = { .nvalue = 1 };\n    switch (ret) {\n    case ENGINE_SUCCESS:\n        item_set_cas(c, it, req_cas_id);\n        if (!settings.engine.v1->get_item_info(settings.engine.v0, c, it, &info)) {\n            settings.engine.v1->release(settings.engine.v0, c, it);\n            out_string(c, \"SERVER_ERROR error getting item data\");\n            break;\n        }\n        c->item = it;\n        c->ritem = info.value[0].iov_base;\n        c->rlbytes = vlen;\n        c->store_op = store_op;\n        conn_set_state(c, conn_nread);\n        break;\n    case ENGINE_EWOULDBLOCK:\n        c->ewouldblock = true;\n        break;\n    case ENGINE_DISCONNECT:\n        c->state = conn_closing;\n        break;\n    default:\n        if (ret == ENGINE_E2BIG) {\n            out_string(c, \"SERVER_ERROR object too large for cache\");\n        } else {\n            out_string(c, \"SERVER_ERROR out of memory storing object\");\n        }\n        /* swallow the data line */\n        c->write_and_go = conn_swallow;\n        c->sbytes = vlen + 2;\n\n        /* Avoid stale data persisting in cache because we failed alloc.\n         * Unacceptable for SET. Anywhere else too? */\n        if (store_op == OPERATION_SET) {\n            settings.engine.v1->remove(settings.engine.v0, c, key, nkey, 0, 0);\n        }\n    }\n}\n\nstatic char* process_arithmetic_command(conn *c, token_t *tokens, const size_t ntokens, const bool incr) {\n\n    uint64_t delta;\n    char *key;\n    size_t nkey;\n\n    assert(c != NULL);\n\n    set_noreply_maybe(c, tokens, ntokens);\n\n    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {\n        out_string(c, \"CLIENT_ERROR bad command line format\");\n        return NULL;\n    }\n\n    key = tokens[KEY_TOKEN].value;\n    nkey = tokens[KEY_TOKEN].length;\n\n    if (!safe_strtoull(tokens[2].value, &delta)) {\n        out_string(c, \"CLIENT_ERROR invalid numeric delta argument\");\n        return NULL;\n    }\n\n    ENGINE_ERROR_CODE ret = c->aiostat;\n    c->aiostat = ENGINE_SUCCESS;\n    uint64_t cas;\n    uint64_t result;\n    if (ret == ENGINE_SUCCESS) {\n        ret = settings.engine.v1->arithmetic(settings.engine.v0, c, key, nkey,\n                                             incr, false, delta, 0, 0, &cas,\n                                             &result, 0);\n    }\n\n    char temp[INCR_MAX_STORAGE_LEN];\n    switch (ret) {\n    case ENGINE_SUCCESS:\n        if (incr) {\n            STATS_INCR(c, incr_hits, key, nkey);\n        } else {\n            STATS_INCR(c, decr_hits, key, nkey);\n        }\n        snprintf(temp, sizeof(temp), \"%\"PRIu64, result);\n        out_string(c, temp);\n        break;\n    case ENGINE_KEY_ENOENT:\n        if (incr) {\n            STATS_INCR(c, incr_misses, key, nkey);\n        } else {\n            STATS_INCR(c, decr_misses, key, nkey);\n        }\n        out_string(c, \"NOT_FOUND\");\n        break;\n    case ENGINE_ENOMEM:\n        out_string(c, \"SERVER_ERROR out of memory\");\n        break;\n    case ENGINE_TMPFAIL:\n        out_string(c, \"SERVER_ERROR temporary failure\");\n        break;\n    case ENGINE_EINVAL:\n        out_string(c, \"CLIENT_ERROR cannot increment or decrement non-numeric value\");\n        break;\n    case ENGINE_NOT_STORED:\n        out_string(c, \"SERVER_ERROR failed to store item\");\n        break;\n    case ENGINE_DISCONNECT:\n        c->state = conn_closing;\n        break;\n    case ENGINE_ENOTSUP:\n        out_string(c, \"SERVER_ERROR not supported\");\n        break;\n    case ENGINE_EWOULDBLOCK:\n        c->ewouldblock = true;\n        return key;\n    default:\n        abort();\n    }\n\n    return NULL;\n}\n\nstatic char *process_delete_command(conn *c, token_t *tokens,\n                                    const size_t ntokens) {\n    char *key;\n    size_t nkey;\n\n    assert(c != NULL);\n\n    if (ntokens > 3) {\n        bool hold_is_zero = strcmp(tokens[KEY_TOKEN+1].value, \"0\") == 0;\n        bool sets_noreply = set_noreply_maybe(c, tokens, ntokens);\n        bool valid = (ntokens == 4 && (hold_is_zero || sets_noreply))\n            || (ntokens == 5 && hold_is_zero && sets_noreply);\n        if (!valid) {\n            out_string(c, \"CLIENT_ERROR bad command line format.  \"\n                       \"Usage: delete <key> [noreply]\");\n            return NULL;\n        }\n    }\n\n    key = tokens[KEY_TOKEN].value;\n    nkey = tokens[KEY_TOKEN].length;\n\n    if (nkey > KEY_MAX_LENGTH) {\n        out_string(c, \"CLIENT_ERROR bad command line format\");\n        return NULL;\n    }\n\n    ENGINE_ERROR_CODE ret = c->aiostat;\n    c->aiostat = ENGINE_SUCCESS;\n    c->ewouldblock = false;\n    if (ret == ENGINE_SUCCESS) {\n        ret = settings.engine.v1->remove(settings.engine.v0, c,\n                                         key, nkey, 0, 0);\n    }\n\n    /* For some reason the SLAB_INCR tries to access this... */\n    item_info info = { .nvalue = 1 };\n    switch (ret) {\n    case ENGINE_SUCCESS:\n        out_string(c, \"DELETED\");\n        SLAB_INCR(c, delete_hits, key, nkey);\n        break;\n    case ENGINE_EWOULDBLOCK:\n        c->ewouldblock = true;\n        return key;\n    case ENGINE_TMPFAIL:\n        out_string(c, \"SERVER_ERROR temporary failure\");\n        break;\n    default:\n        out_string(c, \"NOT_FOUND\");\n        STATS_INCR(c, delete_misses, key, nkey);\n    }\n\n    if (ret != ENGINE_EWOULDBLOCK && settings.detail_enabled) {\n        stats_prefix_record_delete(key, nkey);\n    }\n    return NULL;\n}\n\nstatic void process_verbosity_command(conn *c, token_t *tokens, const size_t ntokens) {\n    unsigned int level;\n\n    assert(c != NULL);\n\n    set_noreply_maybe(c, tokens, ntokens);\n    if (c->noreply && ntokens == 3) {\n        /* \"verbosity noreply\" is not according to the correct syntax */\n        c->noreply = false;\n        out_string(c, \"ERROR\");\n        return;\n    }\n\n    if (safe_strtoul(tokens[1].value, &level)) {\n        settings.verbose = level > MAX_VERBOSITY_LEVEL ? MAX_VERBOSITY_LEVEL : level;\n        perform_callbacks(ON_LOG_LEVEL, NULL, NULL);\n        out_string(c, \"OK\");\n    } else {\n        out_string(c, \"ERROR\");\n    }\n}\n\nstatic char* process_command(conn *c, char *command) {\n\n    token_t tokens[MAX_TOKENS];\n    size_t ntokens;\n    int comm;\n    char *ret = NULL;\n\n    assert(c != NULL);\n\n    MEMCACHED_PROCESS_COMMAND_START(c->sfd, c->rcurr, c->rbytes);\n\n    if (settings.verbose > 1) {\n        settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                        \"<%d %s\\n\", c->sfd, command);\n    }\n\n    /*\n     * for commands set/add/replace, we build an item and read the data\n     * directly into it, then continue in nread_complete().\n     */\n\n    if (c->ewouldblock) {\n        /*\n         * If we are retrying after the engine has completed a pending io for\n         * this command, skip add_msghdr() etc and clear the ewouldblock flag.\n         */\n        c->ewouldblock = false;\n    } else {\n        c->msgcurr = 0;\n        c->msgused = 0;\n        c->iovused = 0;\n        if (add_msghdr(c) != 0) {\n            out_string(c, \"SERVER_ERROR out of memory preparing response\");\n            return NULL;\n        }\n    }\n\n    ntokens = tokenize_command(command, tokens, MAX_TOKENS);\n    if (ntokens >= 3 &&\n        ((strcmp(tokens[COMMAND_TOKEN].value, \"get\") == 0) ||\n         (strcmp(tokens[COMMAND_TOKEN].value, \"bget\") == 0))) {\n\n        ret = process_get_command(c, tokens, ntokens, false);\n\n    } else if ((ntokens == 6 || ntokens == 7) &&\n               ((strcmp(tokens[COMMAND_TOKEN].value, \"add\") == 0 && (comm = (int)OPERATION_ADD)) ||\n                (strcmp(tokens[COMMAND_TOKEN].value, \"set\") == 0 && (comm = (int)OPERATION_SET)) ||\n                (strcmp(tokens[COMMAND_TOKEN].value, \"replace\") == 0 && (comm = (int)OPERATION_REPLACE)) ||\n                (strcmp(tokens[COMMAND_TOKEN].value, \"prepend\") == 0 && (comm = (int)OPERATION_PREPEND)) ||\n                (strcmp(tokens[COMMAND_TOKEN].value, \"append\") == 0 && (comm = (int)OPERATION_APPEND)) )) {\n\n        process_update_command(c, tokens, ntokens, (ENGINE_STORE_OPERATION)comm, false);\n\n    } else if ((ntokens == 7 || ntokens == 8) && (strcmp(tokens[COMMAND_TOKEN].value, \"cas\") == 0 && (comm = (int)OPERATION_CAS))) {\n\n        process_update_command(c, tokens, ntokens, (ENGINE_STORE_OPERATION)comm, true);\n\n    } else if ((ntokens == 4 || ntokens == 5) && (strcmp(tokens[COMMAND_TOKEN].value, \"incr\") == 0)) {\n\n        ret = process_arithmetic_command(c, tokens, ntokens, 1);\n\n    } else if (ntokens >= 3 && (strcmp(tokens[COMMAND_TOKEN].value, \"gets\") == 0)) {\n\n        ret = process_get_command(c, tokens, ntokens, true);\n\n    } else if ((ntokens == 4 || ntokens == 5) && (strcmp(tokens[COMMAND_TOKEN].value, \"decr\") == 0)) {\n\n        ret = process_arithmetic_command(c, tokens, ntokens, 0);\n\n    } else if (ntokens >= 3 && ntokens <= 5 && (strcmp(tokens[COMMAND_TOKEN].value, \"delete\") == 0)) {\n\n        ret = process_delete_command(c, tokens, ntokens);\n\n    } else if (ntokens >= 2 && (strcmp(tokens[COMMAND_TOKEN].value, \"stats\") == 0)) {\n\n        ret = process_stat(c, tokens, ntokens);\n\n    } else if (ntokens >= 2 && ntokens <= 4 && (strcmp(tokens[COMMAND_TOKEN].value, \"flush_all\") == 0)) {\n        time_t exptime;\n\n        set_noreply_maybe(c, tokens, ntokens);\n\n        if (ntokens == (c->noreply ? 3 : 2)) {\n            exptime = 0;\n        } else {\n            exptime = strtol(tokens[1].value, NULL, 10);\n            if(errno == ERANGE) {\n                out_string(c, \"CLIENT_ERROR bad command line format\");\n                return NULL;\n            }\n        }\n\n        ENGINE_ERROR_CODE ret = c->aiostat;\n        c->aiostat = ENGINE_SUCCESS;\n        c->ewouldblock = false;\n        if (ret == ENGINE_SUCCESS) {\n            ret = settings.engine.v1->flush(settings.engine.v0, c, exptime);\n        }\n\n        switch (ret) {\n        case  ENGINE_SUCCESS:\n            out_string(c, \"OK\");\n            break;\n        case ENGINE_ENOTSUP:\n            out_string(c, \"SERVER_ERROR not supported\");\n            break;\n        case ENGINE_EWOULDBLOCK:\n            c->ewouldblock = true;\n            return c->rcurr + 9;\n        default:\n            out_string(c, \"SERVER_ERROR failed to flush cache\");\n        }\n\n        if (ret != ENGINE_EWOULDBLOCK) {\n            STATS_NOKEY(c, cmd_flush);\n        }\n        return NULL;\n\n    } else if (ntokens == 2 && (strcmp(tokens[COMMAND_TOKEN].value, \"version\") == 0)) {\n\n        out_string(c, \"VERSION \" VERSION);\n\n    } else if (ntokens == 2 && (strcmp(tokens[COMMAND_TOKEN].value, \"quit\") == 0)) {\n\n        conn_set_state(c, conn_closing);\n\n    } else if ((ntokens == 3 || ntokens == 4) && (strcmp(tokens[COMMAND_TOKEN].value, \"verbosity\") == 0)) {\n        process_verbosity_command(c, tokens, ntokens);\n    } else if (settings.extensions.ascii != NULL) {\n        EXTENSION_ASCII_PROTOCOL_DESCRIPTOR *cmd;\n        size_t nbytes = 0;\n        char *ptr;\n\n        if (ntokens > 0) {\n            if (ntokens == MAX_TOKENS) {\n                out_string(c, \"ERROR too many arguments\");\n                return NULL;\n            }\n\n            if (tokens[ntokens - 1].length == 0) {\n                --ntokens;\n            }\n        }\n\n        for (cmd = settings.extensions.ascii; cmd != NULL; cmd = cmd->next) {\n            if (cmd->accept(cmd->cookie, c, ntokens, tokens, &nbytes, &ptr)) {\n                break;\n            }\n        }\n\n        if (cmd == NULL) {\n            out_string(c, \"ERROR unknown command\");\n        } else if (nbytes == 0) {\n            switch (cmd->execute(cmd->cookie, c, ntokens, tokens,\n                                 ascii_response_handler)) {\n            case ENGINE_SUCCESS:\n                if (c->dynamic_buffer.buffer != NULL) {\n                    write_and_free(c, c->dynamic_buffer.buffer,\n                                   c->dynamic_buffer.offset);\n                    c->dynamic_buffer.buffer = NULL;\n                } else {\n                    conn_set_state(c, conn_new_cmd);\n                }\n                break;\n            case ENGINE_EWOULDBLOCK:\n                c->ewouldblock = true;\n                ret = tokens[KEY_TOKEN].value;;\n                break;\n            case ENGINE_DISCONNECT:\n            default:\n                conn_set_state(c, conn_closing);\n\n            }\n        } else {\n            c->rlbytes = nbytes;\n            c->ritem = ptr;\n            c->ascii_cmd = cmd;\n            /* NOT SUPPORTED YET! */\n            conn_set_state(c, conn_nread);\n        }\n    } else {\n        out_string(c, \"ERROR\");\n    }\n    return ret;\n}\n\n/*\n * if we have a complete line in the buffer, process it.\n */\nstatic int try_read_command(conn *c) {\n    assert(c != NULL);\n    assert(c->rcurr <= (c->rbuf + c->rsize));\n    assert(c->rbytes > 0);\n\n    if (c->protocol == negotiating_prot || c->transport == udp_transport)  {\n        if ((unsigned char)c->rbuf[0] == (unsigned char)PROTOCOL_BINARY_REQ) {\n            c->protocol = binary_prot;\n        } else {\n            c->protocol = ascii_prot;\n        }\n\n        if (settings.verbose > 1) {\n            settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                    \"%d: Client using the %s protocol\\n\", c->sfd,\n                    prot_text(c->protocol));\n        }\n    }\n\n    if (c->protocol == binary_prot) {\n        /* Do we have the complete packet header? */\n        if (c->rbytes < sizeof(c->binary_header)) {\n            /* need more data! */\n            return 0;\n        } else {\n#ifdef NEED_ALIGN\n            if (((long)(c->rcurr)) % 8 != 0) {\n                /* must realign input buffer */\n                memmove(c->rbuf, c->rcurr, c->rbytes);\n                c->rcurr = c->rbuf;\n                if (settings.verbose > 1) {\n                    settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                             \"%d: Realign input buffer\\n\", c->sfd);\n                }\n            }\n#endif\n            protocol_binary_request_header* req;\n            req = (protocol_binary_request_header*)c->rcurr;\n\n            if (settings.verbose > 1) {\n                /* Dump the packet before we convert it to host order */\n                char buffer[1024];\n                ssize_t nw;\n                nw = bytes_to_output_string(buffer, sizeof(buffer), c->sfd,\n                                            true, \"Read binary protocol data:\",\n                                            (const char*)req->bytes,\n                                            sizeof(req->bytes));\n                if (nw != -1) {\n                    settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                                    \"%s\", buffer);\n                }\n            }\n\n            c->binary_header = *req;\n            c->binary_header.request.keylen = ntohs(req->request.keylen);\n            c->binary_header.request.bodylen = ntohl(req->request.bodylen);\n            c->binary_header.request.vbucket = ntohs(req->request.vbucket);\n            c->binary_header.request.cas = ntohll(req->request.cas);\n\n\n            if (c->binary_header.request.magic != PROTOCOL_BINARY_REQ &&\n                !(c->binary_header.request.magic == PROTOCOL_BINARY_RES &&\n                  response_handlers[c->binary_header.request.opcode])) {\n                if (settings.verbose) {\n                    if (c->binary_header.request.magic != PROTOCOL_BINARY_RES) {\n                        settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                              \"%d: Invalid magic:  %x\\n\", c->sfd,\n                              c->binary_header.request.magic);\n                    } else {\n                        settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                              \"%d: ERROR: Unsupported response packet received: %u\\n\",\n                              c->sfd, (unsigned int)c->binary_header.request.opcode);\n\n                    }\n                }\n                conn_set_state(c, conn_closing);\n                return -1;\n            }\n\n            c->msgcurr = 0;\n            c->msgused = 0;\n            c->iovused = 0;\n            if (add_msghdr(c) != 0) {\n                out_string(c, \"SERVER_ERROR out of memory\");\n                return 0;\n            }\n\n            c->cmd = c->binary_header.request.opcode;\n            c->keylen = c->binary_header.request.keylen;\n            c->opaque = c->binary_header.request.opaque;\n            /* clear the returned cas value */\n            c->cas = 0;\n\n            dispatch_bin_command(c);\n\n            c->rbytes -= sizeof(c->binary_header);\n            c->rcurr += sizeof(c->binary_header);\n        }\n    } else {\n        char *el, *cont, *left, lb;\n\n        if (c->rbytes == 0) {\n            return 0;\n        }\n\n        el = memchr(c->rcurr, '\\n', c->rbytes);\n        if (!el) {\n            if (c->rbytes > 1024) {\n                /*\n                 * We didn't have a '\\n' in the first k. This _has_ to be a\n                 * large multiget, if not we should just nuke the connection.\n                 */\n                char *ptr = c->rcurr;\n                while (*ptr == ' ') { /* ignore leading whitespaces */\n                    ++ptr;\n                }\n\n                if (ptr - c->rcurr > 100 ||\n                    (strncmp(ptr, \"get \", 4) && strncmp(ptr, \"gets \", 5))) {\n\n                    conn_set_state(c, conn_closing);\n                    return 1;\n                }\n            }\n\n            return 0;\n        }\n        cont = el + 1;\n        if ((el - c->rcurr) > 1 && *(el - 1) == '\\r') {\n            el--;\n        }\n        lb = *el;\n        *el = '\\0';\n\n        assert(cont <= (c->rcurr + c->rbytes));\n\n        LIBEVENT_THREAD *thread = c->thread;\n        LOCK_THREAD(thread);\n        left = process_command(c, c->rcurr);\n        if (c->ewouldblock) {\n            unregister_event(c);\n        }\n        UNLOCK_THREAD(thread);\n\n        if (left != NULL) {\n            /*\n             * We have not processed the entire command. This happens\n             * when the engine returns ENGINE_EWOULDBLOCK for one of the\n             * keys in a get/gets request.\n             */\n            assert (left <= el);\n\n            int count = strlen(c->rcurr);\n            if ((c->rcurr + count) == left) {\n                // Retry the entire command\n                cont = c->rcurr;\n            } else {\n                left -= (count + 1);\n                cont = left;\n                assert(cont >= c->rcurr);\n                if (cont > c->rcurr) {\n                    memmove(cont, c->rcurr, count);\n                }\n            }\n\n            /* de-tokenize the command */\n            while ((left = memchr(left, '\\0', el - left)) != NULL) {\n                *left = ' ';\n            }\n            *el = lb;\n        }\n\n        c->rbytes -= (cont - c->rcurr);\n        c->rcurr = cont;\n\n        assert(c->rcurr <= (c->rbuf + c->rsize));\n    }\n\n    return 1;\n}\n\n/*\n * read a UDP request.\n */\nstatic enum try_read_result try_read_udp(conn *c) {\n    int res;\n\n    assert(c != NULL);\n\n    c->request_addr_size = sizeof(c->request_addr);\n    res = recvfrom(c->sfd, c->rbuf, c->rsize,\n                   0, (struct sockaddr *)&c->request_addr, &c->request_addr_size);\n    if (res > 8) {\n        unsigned char *buf = (unsigned char *)c->rbuf;\n        STATS_ADD(c, bytes_read, res);\n\n        /* Beginning of UDP packet is the request ID; save it. */\n        c->request_id = buf[0] * 256 + buf[1];\n\n        /* If this is a multi-packet request, drop it. */\n        if (buf[4] != 0 || buf[5] != 1) {\n            out_string(c, \"SERVER_ERROR multi-packet request not supported\");\n            return READ_NO_DATA_RECEIVED;\n        }\n\n        /* Don't care about any of the rest of the header. */\n        res -= 8;\n        memmove(c->rbuf, c->rbuf + 8, res);\n\n        c->rbytes += res;\n        c->rcurr = c->rbuf;\n        return READ_DATA_RECEIVED;\n    }\n    return READ_NO_DATA_RECEIVED;\n}\n\n/*\n * read from network as much as we can, handle buffer overflow and connection\n * close.\n * before reading, move the remaining incomplete fragment of a command\n * (if any) to the beginning of the buffer.\n *\n * To protect us from someone flooding a connection with bogus data causing\n * the connection to eat up all available memory, break out and start looking\n * at the data I've got after a number of reallocs...\n *\n * @return enum try_read_result\n */\nstatic enum try_read_result try_read_network(conn *c) {\n    enum try_read_result gotdata = READ_NO_DATA_RECEIVED;\n    int res;\n    int num_allocs = 0;\n    assert(c != NULL);\n\n    if (c->rcurr != c->rbuf) {\n        if (c->rbytes != 0) /* otherwise there's nothing to copy */\n            memmove(c->rbuf, c->rcurr, c->rbytes);\n        c->rcurr = c->rbuf;\n    }\n\n    while (1) {\n        if (c->rbytes >= c->rsize) {\n            if (num_allocs == 4) {\n                return gotdata;\n            }\n            ++num_allocs;\n            char *new_rbuf = realloc(c->rbuf, c->rsize * 2);\n            if (!new_rbuf) {\n                if (settings.verbose > 0) {\n                 settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                          \"Couldn't realloc input buffer\\n\");\n                }\n                c->rbytes = 0; /* ignore what we read */\n                out_string(c, \"SERVER_ERROR out of memory reading request\");\n                c->write_and_go = conn_closing;\n                return READ_MEMORY_ERROR;\n            }\n            c->rcurr = c->rbuf = new_rbuf;\n            c->rsize *= 2;\n        }\n\n        int avail = c->rsize - c->rbytes;\n        res = recv(c->sfd, c->rbuf + c->rbytes, avail, 0);\n        if (res > 0) {\n            STATS_ADD(c, bytes_read, res);\n            gotdata = READ_DATA_RECEIVED;\n            c->rbytes += res;\n            if (res == avail) {\n                continue;\n            } else {\n                break;\n            }\n        }\n        if (res == 0) {\n            return READ_ERROR;\n        }\n        if (res == -1) {\n            if (errno == EAGAIN || errno == EWOULDBLOCK) {\n                break;\n            }\n            return READ_ERROR;\n        }\n    }\n    return gotdata;\n}\n\nbool register_event(conn *c, struct timeval *timeout) {\n    assert(!c->registered_in_libevent);\n\n    if (event_add(&c->event, timeout) == -1) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING,\n                                        NULL,\n                                        \"Failed to add connection to libevent: %s\",\n                                        strerror(errno));\n        return false;\n    }\n\n    c->registered_in_libevent = true;\n\n    return true;\n}\n\nbool unregister_event(conn *c) {\n    assert(c->registered_in_libevent);\n\n    if (event_del(&c->event) == -1) {\n        return false;\n    }\n\n    c->registered_in_libevent = false;\n\n    return true;\n}\n\n\nbool update_event(conn *c, const int new_flags) {\n    assert(c != NULL);\n\n    struct event_base *base = c->event.ev_base;\n    if (c->ev_flags == new_flags)\n        return true;\n\n    settings.extensions.logger->log(EXTENSION_LOG_DEBUG, NULL,\n                                    \"Updated event for %d to read=%s, write=%s\\n\",\n                                    c->sfd, (new_flags & EV_READ ? \"yes\" : \"no\"),\n                                    (new_flags & EV_WRITE ? \"yes\" : \"no\"));\n\n    if (!unregister_event(c)) {\n        return false;\n    }\n\n    event_set(&c->event, c->sfd, new_flags, event_handler, (void *)c);\n    event_base_set(base, &c->event);\n    c->ev_flags = new_flags;\n\n    return register_event(c, NULL);\n}\n\n/*\n * Transmit the next chunk of data from our list of msgbuf structures.\n *\n * Returns:\n *   TRANSMIT_COMPLETE   All done writing.\n *   TRANSMIT_INCOMPLETE More data remaining to write.\n *   TRANSMIT_SOFT_ERROR Can't write any more right now.\n *   TRANSMIT_HARD_ERROR Can't write (c->state is set to conn_closing)\n */\nstatic enum transmit_result transmit(conn *c) {\n    assert(c != NULL);\n\n    if (c->msgcurr < c->msgused &&\n            c->msglist[c->msgcurr].msg_iovlen == 0) {\n        /* Finished writing the current msg; advance to the next. */\n        c->msgcurr++;\n    }\n    if (c->msgcurr < c->msgused) {\n        ssize_t res;\n        struct msghdr *m = &c->msglist[c->msgcurr];\n\n        res = sendmsg(c->sfd, m, 0);\n        if (res > 0) {\n            STATS_ADD(c, bytes_written, res);\n\n            /* We've written some of the data. Remove the completed\n               iovec entries from the list of pending writes. */\n            while (m->msg_iovlen > 0 && res >= m->msg_iov->iov_len) {\n                res -= m->msg_iov->iov_len;\n                m->msg_iovlen--;\n                m->msg_iov++;\n            }\n\n            /* Might have written just part of the last iovec entry;\n               adjust it so the next write will do the rest. */\n            if (res > 0) {\n                m->msg_iov->iov_base = (caddr_t)m->msg_iov->iov_base + res;\n                m->msg_iov->iov_len -= res;\n            }\n            return TRANSMIT_INCOMPLETE;\n        }\n        if (res == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n            if (!update_event(c, EV_WRITE | EV_PERSIST)) {\n                if (settings.verbose > 0) {\n                    settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                            \"Couldn't update event\\n\");\n                }\n                conn_set_state(c, conn_closing);\n                return TRANSMIT_HARD_ERROR;\n            }\n            return TRANSMIT_SOFT_ERROR;\n        }\n        /* if res == 0 or res == -1 and error is not EAGAIN or EWOULDBLOCK,\n           we have a real error, on which we close the connection */\n        if (settings.verbose > 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                            \"Failed to write, and not due to blocking: %s\",\n                                            strerror(errno));\n        }\n\n        if (IS_UDP(c->transport))\n            conn_set_state(c, conn_read);\n        else\n            conn_set_state(c, conn_closing);\n        return TRANSMIT_HARD_ERROR;\n    } else {\n        return TRANSMIT_COMPLETE;\n    }\n}\n\nbool conn_listening(conn *c)\n{\n    int sfd;\n    struct sockaddr_storage addr;\n    socklen_t addrlen = sizeof(addr);\n\n    if ((sfd = accept(c->sfd, (struct sockaddr *)&addr, &addrlen)) == -1) {\n        if (errno == EMFILE) {\n            if (settings.verbose > 0) {\n                settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                                                \"Too many open connections\\n\");\n            }\n            disable_listen();\n        } else if (errno != EAGAIN && errno != EWOULDBLOCK) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                            \"Failed to accept new client: %s\\n\",\n                                            strerror(errno));\n        }\n\n        return false;\n    }\n\n    STATS_LOCK();\n    int curr_conns = ++stats.curr_conns;\n    STATS_UNLOCK();\n\n    if (curr_conns >= settings.maxconns) {\n        STATS_LOCK();\n        ++stats.rejected_conns;\n        STATS_UNLOCK();\n\n        if (settings.verbose > 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                                            \"Too many open connections\\n\");\n        }\n\n        safe_close(sfd);\n        return false;\n    }\n\n    if (evutil_make_socket_nonblocking(sfd) == -1) {\n        safe_close(sfd);\n        return false;\n    }\n\n    dispatch_conn_new(sfd, conn_new_cmd, EV_READ | EV_PERSIST,\n                      DATA_BUFFER_SIZE, tcp_transport);\n\n    return false;\n}\n\n/**\n * Ship tap log to the other end. This state differs with all other states\n * in the way that it support full duplex dialog. We're listening to both read\n * and write events from libevent most of the time. If a read event occurs we\n * switch to the conn_read state to read and execute the input message (that would\n * be an ack message from the other side). If a write event occurs we continue to\n * send tap log to the other end.\n * @param c the tap connection to drive\n * @return true if we should continue to process work for this connection, false\n *              if we should start processing events for other connections.\n */\nbool conn_ship_log(conn *c) {\n    bool cont = false;\n\n    if (c->sfd == INVALID_SOCKET) {\n        return false;\n    }\n\n    short mask = EV_READ | EV_PERSIST | EV_WRITE;\n\n    if (c->which & EV_READ || c->rbytes > 0) {\n        if (c->rbytes > 0) {\n            if (try_read_command(c) == 0) {\n                conn_set_state(c, conn_read);\n            }\n        } else {\n            conn_set_state(c, conn_read);\n        }\n\n        // we're going to process something.. let's proceed\n        cont = true;\n\n        // We have a finite number of messages in the input queue\n        // so let's process all of them instead of backing off after\n        // reading a subset of them.\n        // Why? Because we've got every time we're calling ship_tap_log\n        // we try to send a chunk of items.. This means that if we end\n        // up in a situation where we're receiving a burst of nack messages\n        // we'll only process a subset of messages in our input queue,\n        // and it will slowly grow..\n        c->nevents = settings.reqs_per_tap_event;\n    } else if (c->which & EV_WRITE) {\n        --c->nevents;\n        if (c->nevents >= 0) {\n            LOCK_THREAD(c->thread);\n            c->ewouldblock = false;\n            ship_tap_log(c);\n            if (c->ewouldblock) {\n                mask = EV_READ | EV_PERSIST;\n            } else {\n                cont = true;\n            }\n            UNLOCK_THREAD(c->thread);\n        }\n    }\n\n    if (!update_event(c, mask)) {\n        if (settings.verbose > 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_INFO,\n                                            c, \"Couldn't update event\\n\");\n        }\n        conn_set_state(c, conn_closing);\n    }\n\n    return cont;\n}\n\nbool conn_waiting(conn *c) {\n    if (!update_event(c, EV_READ | EV_PERSIST)) {\n        if (settings.verbose > 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                                            \"Couldn't update event\\n\");\n        }\n        conn_set_state(c, conn_closing);\n        return true;\n    }\n    conn_set_state(c, conn_read);\n    return false;\n}\n\nbool conn_read(conn *c) {\n    int res = IS_UDP(c->transport) ? try_read_udp(c) : try_read_network(c);\n    switch (res) {\n    case READ_NO_DATA_RECEIVED:\n        conn_set_state(c, conn_waiting);\n        break;\n    case READ_DATA_RECEIVED:\n        conn_set_state(c, conn_parse_cmd);\n        break;\n    case READ_ERROR:\n        conn_set_state(c, conn_closing);\n        break;\n    case READ_MEMORY_ERROR: /* Failed to allocate more memory */\n        /* State already set by try_read_network */\n        break;\n    }\n\n    return true;\n}\n\nbool conn_parse_cmd(conn *c) {\n    if (try_read_command(c) == 0) {\n        /* wee need more data! */\n        conn_set_state(c, conn_waiting);\n    }\n\n    return !c->ewouldblock;\n}\n\nbool conn_new_cmd(conn *c) {\n    /* Only process nreqs at a time to avoid starving other connections */\n    --c->nevents;\n    if (c->nevents >= 0) {\n        reset_cmd_handler(c);\n    } else {\n        STATS_NOKEY(c, conn_yields);\n        if (c->rbytes > 0) {\n            /* We have already read in data into the input buffer,\n               so libevent will most likely not signal read events\n               on the socket (unless more data is available. As a\n               hack we should just put in a request to write data,\n               because that should be possible ;-)\n            */\n            if (!update_event(c, EV_WRITE | EV_PERSIST)) {\n                if (settings.verbose > 0) {\n                    settings.extensions.logger->log(EXTENSION_LOG_INFO,\n                                                    c, \"Couldn't update event\\n\");\n                }\n                conn_set_state(c, conn_closing);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    return true;\n}\n\n\nbool conn_swallow(conn *c) {\n    ssize_t res;\n    /* we are reading sbytes and throwing them away */\n    if (c->sbytes == 0) {\n        conn_set_state(c, conn_new_cmd);\n        return true;\n    }\n\n    /* first check if we have leftovers in the conn_read buffer */\n    if (c->rbytes > 0) {\n        uint32_t tocopy = c->rbytes > c->sbytes ? c->sbytes : c->rbytes;\n        c->sbytes -= tocopy;\n        c->rcurr += tocopy;\n        c->rbytes -= tocopy;\n        return true;\n    }\n\n    /*  now try reading from the socket */\n    res = recv(c->sfd, c->rbuf, c->rsize > c->sbytes ? c->sbytes : c->rsize, 0);\n    if (res > 0) {\n        STATS_ADD(c, bytes_read, res);\n        c->sbytes -= res;\n        return true;\n    }\n    if (res == 0) { /* end of stream */\n        conn_set_state(c, conn_closing);\n        return true;\n    }\n    if (res == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n        if (!update_event(c, EV_READ | EV_PERSIST)) {\n            if (settings.verbose > 0) {\n                settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                                                \"Couldn't update event\\n\");\n            }\n            conn_set_state(c, conn_closing);\n            return true;\n        }\n        return false;\n    }\n\n    if (errno != ENOTCONN && errno != ECONNRESET) {\n        /* otherwise we have a real error, on which we close the connection */\n        settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                                        \"Failed to read, and not due to blocking (%s)\\n\",\n                                        strerror(errno));\n    }\n\n    conn_set_state(c, conn_closing);\n\n    return true;\n\n}\n\nbool conn_nread(conn *c) {\n    ssize_t res;\n\n    if (c->rlbytes == 0) {\n        LIBEVENT_THREAD *t = c->thread;\n        LOCK_THREAD(t);\n        bool block = c->ewouldblock = false;\n        complete_nread(c);\n        UNLOCK_THREAD(t);\n        /* Breaking this into two, as complete_nread may have\n           moved us to a different thread */\n        t = c->thread;\n        LOCK_THREAD(t);\n        if (c->ewouldblock) {\n            unregister_event(c);\n            block = true;\n        }\n        UNLOCK_THREAD(t);\n        return !block;\n    }\n    /* first check if we have leftovers in the conn_read buffer */\n    if (c->rbytes > 0) {\n        uint32_t tocopy = c->rbytes > c->rlbytes ? c->rlbytes : c->rbytes;\n        if (c->ritem != c->rcurr) {\n            memmove(c->ritem, c->rcurr, tocopy);\n        }\n        c->ritem += tocopy;\n        c->rlbytes -= tocopy;\n        c->rcurr += tocopy;\n        c->rbytes -= tocopy;\n        if (c->rlbytes == 0) {\n            return true;\n        }\n    }\n\n    /*  now try reading from the socket */\n    res = recv(c->sfd, c->ritem, c->rlbytes, 0);\n    if (res > 0) {\n        STATS_ADD(c, bytes_read, res);\n        if (c->rcurr == c->ritem) {\n            c->rcurr += res;\n        }\n        c->ritem += res;\n        c->rlbytes -= res;\n        return true;\n    }\n    if (res == 0) { /* end of stream */\n        conn_set_state(c, conn_closing);\n        return true;\n    }\n\n    if (res == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n        if (!update_event(c, EV_READ | EV_PERSIST)) {\n            if (settings.verbose > 0) {\n                settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                                                \"Couldn't update event\\n\");\n            }\n            conn_set_state(c, conn_closing);\n            return true;\n        }\n        return false;\n    }\n\n    if (errno != ENOTCONN && errno != ECONNRESET) {\n        /* otherwise we have a real error, on which we close the connection */\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                        \"Failed to read, and not due to blocking:\\n\"\n                                        \"errno: %d %s \\n\"\n                                        \"rcurr=%lx ritem=%lx rbuf=%lx rlbytes=%d rsize=%d\\n\",\n                                        errno, strerror(errno),\n                                        (long)c->rcurr, (long)c->ritem, (long)c->rbuf,\n                                        (int)c->rlbytes, (int)c->rsize);\n    }\n    conn_set_state(c, conn_closing);\n    return true;\n}\n\nbool conn_write(conn *c) {\n    /*\n     * We want to write out a simple response. If we haven't already,\n     * assemble it into a msgbuf list (this will be a single-entry\n     * list for TCP or a two-entry list for UDP).\n     */\n    if (c->iovused == 0 || (IS_UDP(c->transport) && c->iovused == 1)) {\n        if (add_iov(c, c->wcurr, c->wbytes) != 0) {\n            if (settings.verbose > 0) {\n                settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                                                \"Couldn't build response\\n\");\n            }\n            conn_set_state(c, conn_closing);\n            return true;\n        }\n    }\n\n    return conn_mwrite(c);\n}\n\nbool conn_mwrite(conn *c) {\n    if (IS_UDP(c->transport) && c->msgcurr == 0 && build_udp_headers(c) != 0) {\n        if (settings.verbose > 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                                            \"Failed to build UDP headers\\n\");\n        }\n        conn_set_state(c, conn_closing);\n        return true;\n    }\n\n    switch (transmit(c)) {\n    case TRANSMIT_COMPLETE:\n        if (c->state == conn_mwrite) {\n            while (c->ileft > 0) {\n                item *it = *(c->icurr);\n                settings.engine.v1->release(settings.engine.v0, c, it);\n                c->icurr++;\n                c->ileft--;\n            }\n            while (c->suffixleft > 0) {\n                char *suffix = *(c->suffixcurr);\n                cache_free(c->thread->suffix_cache, suffix);\n                c->suffixcurr++;\n                c->suffixleft--;\n            }\n            /* XXX:  I don't know why this wasn't the general case */\n            if(c->protocol == binary_prot) {\n                conn_set_state(c, c->write_and_go);\n            } else {\n                conn_set_state(c, conn_new_cmd);\n            }\n        } else if (c->state == conn_write) {\n            if (c->write_and_free) {\n                free(c->write_and_free);\n                c->write_and_free = 0;\n            }\n            conn_set_state(c, c->write_and_go);\n        } else {\n            if (settings.verbose > 0) {\n                settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                                                \"Unexpected state %d\\n\", c->state);\n            }\n            conn_set_state(c, conn_closing);\n        }\n        break;\n\n    case TRANSMIT_INCOMPLETE:\n    case TRANSMIT_HARD_ERROR:\n        break;                   /* Continue in state machine. */\n\n    case TRANSMIT_SOFT_ERROR:\n        return false;\n    }\n\n    return true;\n}\n\nbool conn_pending_close(conn *c) {\n    assert(c->sfd == INVALID_SOCKET);\n    settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                    \"Awaiting clients to release the cookie (pending close for %p)\",\n                                    (void*)c);\n    LOCK_THREAD(c->thread);\n    c->thread->pending_io = list_remove(c->thread->pending_io, c);\n    if (!list_contains(c->thread->pending_close, c)) {\n        enlist_conn(c, &c->thread->pending_close);\n    }\n    UNLOCK_THREAD(c->thread);\n\n    /*\n     * tell the tap connection that we're disconnecting it now,\n     * but give it a grace period\n     */\n    perform_callbacks(ON_DISCONNECT, NULL, c);\n\n    /*\n     * disconnect callback may have changed the state for the object\n     * so we might complete the disconnect now\n     */\n    return c->state != conn_pending_close;\n}\n\nbool conn_immediate_close(conn *c) {\n    settings.extensions.logger->log(EXTENSION_LOG_DETAIL, c,\n                                    \"Immediate close of %p\",\n                                    (void*)c);\n    perform_callbacks(ON_DISCONNECT, NULL, c);\n    conn_close(c);\n\n    return false;\n}\n\nbool conn_closing(conn *c) {\n    if (IS_UDP(c->transport)) {\n        conn_cleanup(c);\n        return false;\n    }\n\n    // We don't want any network notifications anymore..\n    unregister_event(c);\n    safe_close(c->sfd);\n    c->sfd = INVALID_SOCKET;\n\n    if (c->refcount > 1) {\n        conn_set_state(c, conn_pending_close);\n    } else {\n        conn_set_state(c, conn_immediate_close);\n    }\n    return true;\n}\n\nbool conn_add_tap_client(conn *c) {\n    LIBEVENT_THREAD *tp = tap_thread;\n    LIBEVENT_THREAD *orig_thread = c->thread;\n\n    assert(orig_thread);\n    assert(orig_thread != tp);\n\n    c->ewouldblock = true;\n\n    unregister_event(c);\n\n    LOCK_THREAD(orig_thread);\n    /* Clean out the lists */\n    orig_thread->pending_io = list_remove(orig_thread->pending_io, c);\n    orig_thread->pending_close = list_remove(orig_thread->pending_close, c);\n\n    LOCK_THREAD(tp);\n    c->ev_flags = 0;\n    conn_set_state(c, conn_setup_tap_stream);\n    settings.extensions.logger->log(EXTENSION_LOG_DEBUG, NULL,\n                                    \"Moving %d conn from %p to %p\\n\",\n                                    c->sfd, c->thread, tp);\n    c->thread = tp;\n    c->event.ev_base = tp->base;\n    assert(c->next == NULL);\n    assert(c->list_state == 0);\n    enlist_conn(c, &tp->pending_io);\n\n    UNLOCK_THREAD(tp);\n\n    UNLOCK_THREAD(orig_thread);\n\n    notify_thread(tp);\n\n    return false;\n}\n\nbool conn_setup_tap_stream(conn *c) {\n    process_bin_tap_connect(c);\n    return true;\n}\n\nvoid event_handler(const int fd, const short which, void *arg) {\n    conn *c;\n\n    c = (conn *)arg;\n    assert(c != NULL);\n\n    if (memcached_shutdown) {\n        event_base_loopbreak(c->event.ev_base);\n        return ;\n    }\n\n    c->which = which;\n\n    /* sanity */\n    if (fd != c->sfd) {\n        if (c->sfd != INVALID_SOCKET) {\n            settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                    \"Catastrophic: event fd doesn't match conn fd!\\n\");\n        }\n        unregister_event(c);\n        if (c->sfd != INVALID_SOCKET && c->thread != NULL) {\n            conn_close(c);\n        }\n        return;\n    }\n\n    perform_callbacks(ON_SWITCH_CONN, c, c);\n\n    c->nevents = settings.reqs_per_event;\n    if (c->state == conn_ship_log) {\n        c->nevents = settings.reqs_per_tap_event;\n    }\n\n    LIBEVENT_THREAD *thr = c->thread;\n\n    // Do we have pending closes?\n    const size_t max_items = 256;\n    conn *pending_close[max_items];\n    size_t n_pending_close = 0;\n    if (thr != NULL) {\n        LOCK_THREAD(thr);\n        if (thr->pending_close && thr->last_checked != current_time) {\n            assert(!has_cycle(thr->pending_close));\n            thr->last_checked = current_time;\n\n            n_pending_close = list_to_array(pending_close, max_items,\n                                            &thr->pending_close);\n        }\n        UNLOCK_THREAD(thr);\n    }\n\n    if (settings.verbose) {\n        do {\n            settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                            \"%d - Running task: (%s)\\n\",\n                                            c->sfd, state_text(c->state));\n        } while (c->state(c));\n    } else {\n        while (c->state(c)) {\n            /* empty */\n        }\n    }\n\n    /* Close any connections pending close */\n    if (n_pending_close > 0) {\n        for (size_t i = 0; i < n_pending_close; ++i) {\n            conn *ce = pending_close[i];\n            if (ce->refcount == 1) {\n                settings.extensions.logger->log(EXTENSION_LOG_DEBUG, NULL,\n                                                \"OK, time to nuke: %p\\n\",\n                                                (void*)ce);\n                conn_close(ce);\n                pending_close[i] = NULL;\n            } else {\n                LOCK_THREAD(ce->thread);\n                enlist_conn(ce, &ce->thread->pending_close);\n                UNLOCK_THREAD(ce->thread);\n            }\n        }\n    }\n\n    if (thr != NULL) {\n        LOCK_THREAD(thr);\n        finalize_list(pending_close, n_pending_close);\n        UNLOCK_THREAD(thr);\n    }\n}\n\nstatic void dispatch_event_handler(int fd, short which, void *arg) {\n    char buffer[80];\n    ssize_t nr = recv(fd, buffer, sizeof(buffer), 0);\n\n    (void)(which);\n    (void)(arg);\n    if (nr != -1 && is_listen_disabled()) {\n        bool enable = false;\n        pthread_mutex_lock(&listen_state.mutex);\n        listen_state.count -= nr;\n        if (listen_state.count <= 0) {\n            enable = true;\n            listen_state.disabled = false;\n        }\n        pthread_mutex_unlock(&listen_state.mutex);\n        if (enable) {\n            conn *next;\n            for (next = listen_conn; next; next = next->next) {\n                update_event(next, EV_READ | EV_PERSIST);\n                if (listen(next->sfd, settings.backlog) != 0) {\n                    settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                                    \"listen() failed\",\n                                                    strerror(errno));\n                }\n            }\n        }\n    }\n}\n\n\n\nstatic SOCKET new_socket(struct addrinfo *ai) {\n    SOCKET sfd;\n\n    sfd = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);\n    if (sfd == INVALID_SOCKET) {\n        return INVALID_SOCKET;\n    }\n\n    if (evutil_make_socket_nonblocking(sfd) == -1) {\n        safe_close(sfd);\n        return INVALID_SOCKET;\n    }\n\n    return sfd;\n}\n\n\n/*\n * Sets a socket's send buffer size to the maximum allowed by the system.\n */\nstatic void maximize_sndbuf(const int sfd) {\n    socklen_t intsize = sizeof(int);\n    int last_good = 0;\n    int min, max, avg;\n    int old_size;\n\n    /* Start with the default size. */\n    if (getsockopt(sfd, SOL_SOCKET, SO_SNDBUF, (void *)&old_size, &intsize) != 0) {\n        if (settings.verbose > 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                            \"getsockopt(SO_SNDBUF): %s\",\n                                            strerror(errno));\n        }\n\n        return;\n    }\n\n    /* Binary-search for the real maximum. */\n    min = old_size;\n    max = MAX_SENDBUF_SIZE;\n\n    while (min <= max) {\n        avg = ((unsigned int)(min + max)) / 2;\n        if (setsockopt(sfd, SOL_SOCKET, SO_SNDBUF, (void *)&avg, intsize) == 0) {\n            last_good = avg;\n            min = avg + 1;\n        } else {\n            max = avg - 1;\n        }\n    }\n\n    if (settings.verbose > 1) {\n        settings.extensions.logger->log(EXTENSION_LOG_DEBUG, NULL,\n                 \"<%d send buffer was %d, now %d\\n\", sfd, old_size, last_good);\n    }\n}\n\n\n\n/**\n * Create a socket and bind it to a specific port number\n * @param interface the interface to bind to\n * @param port the port number to bind to\n * @param transport the transport protocol (TCP / UDP)\n * @param portnumber_file A filepointer to write the port numbers to\n *        when they are successfully added to the list of ports we\n *        listen on.\n */\nstatic int server_socket(const char *interface,\n                         int port,\n                         enum network_transport transport,\n                         FILE *portnumber_file) {\n    int sfd;\n    struct linger ling = {0, 0};\n    struct addrinfo *ai;\n    struct addrinfo *next;\n    struct addrinfo hints = { .ai_flags = AI_PASSIVE,\n                              .ai_family = AF_UNSPEC };\n    char port_buf[NI_MAXSERV];\n    int error;\n    int success = 0;\n    int flags =1;\n\n    hints.ai_socktype = IS_UDP(transport) ? SOCK_DGRAM : SOCK_STREAM;\n\n    if (port == -1) {\n        port = 0;\n    }\n    snprintf(port_buf, sizeof(port_buf), \"%d\", port);\n    error= getaddrinfo(interface, port_buf, &hints, &ai);\n    if (error != 0) {\n        if (error != EAI_SYSTEM) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                     \"getaddrinfo(): %s\\n\", gai_strerror(error));\n        } else {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                     \"getaddrinfo(): %s\\n\", strerror(error));\n        }\n        return 1;\n    }\n\n    for (next= ai; next; next= next->ai_next) {\n        conn *listen_conn_add;\n        if ((sfd = new_socket(next)) == INVALID_SOCKET) {\n            /* getaddrinfo can return \"junk\" addresses,\n             * we make sure at least one works before erroring.\n             */\n            continue;\n        }\n\n#ifdef IPV6_V6ONLY\n        if (next->ai_family == AF_INET6) {\n            error = setsockopt(sfd, IPPROTO_IPV6, IPV6_V6ONLY, (char *) &flags, sizeof(flags));\n            if (error != 0) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                                \"setsockopt(IPV6_V6ONLY): %s\",\n                                                strerror(errno));\n                safe_close(sfd);\n                continue;\n            }\n        }\n#endif\n\n        setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flags, sizeof(flags));\n        if (IS_UDP(transport)) {\n            maximize_sndbuf(sfd);\n        } else {\n            error = setsockopt(sfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flags, sizeof(flags));\n            if (error != 0) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                                \"setsockopt(SO_KEEPALIVE): %s\",\n                                                strerror(errno));\n            }\n\n            error = setsockopt(sfd, SOL_SOCKET, SO_LINGER, (void *)&ling, sizeof(ling));\n            if (error != 0) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                                \"setsockopt(SO_LINGER): %s\",\n                                                strerror(errno));\n            }\n\n            error = setsockopt(sfd, IPPROTO_TCP, TCP_NODELAY, (void *)&flags, sizeof(flags));\n            if (error != 0) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                                \"setsockopt(TCP_NODELAY): %s\",\n                                                strerror(errno));\n            }\n        }\n\n        if (bind(sfd, next->ai_addr, next->ai_addrlen) == SOCKET_ERROR) {\n            if (errno != EADDRINUSE) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                                \"bind(): %s\",\n                                                strerror(errno));\n                safe_close(sfd);\n                freeaddrinfo(ai);\n                return 1;\n            }\n            safe_close(sfd);\n            continue;\n        } else {\n            success++;\n            if (!IS_UDP(transport) && listen(sfd, settings.backlog) == SOCKET_ERROR) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                                \"listen(): %s\",\n                                                strerror(errno));\n                safe_close(sfd);\n                freeaddrinfo(ai);\n                return 1;\n            }\n            if (portnumber_file != NULL &&\n                (next->ai_addr->sa_family == AF_INET ||\n                 next->ai_addr->sa_family == AF_INET6)) {\n                union {\n                    struct sockaddr_in in;\n                    struct sockaddr_in6 in6;\n                } my_sockaddr;\n                socklen_t len = sizeof(my_sockaddr);\n                if (getsockname(sfd, (struct sockaddr*)&my_sockaddr, &len)==0) {\n                    if (next->ai_addr->sa_family == AF_INET) {\n                        fprintf(portnumber_file, \"%s INET: %u\\n\",\n                                IS_UDP(transport) ? \"UDP\" : \"TCP\",\n                                ntohs(my_sockaddr.in.sin_port));\n                    } else {\n                        fprintf(portnumber_file, \"%s INET6: %u\\n\",\n                                IS_UDP(transport) ? \"UDP\" : \"TCP\",\n                                ntohs(my_sockaddr.in6.sin6_port));\n                    }\n                }\n            }\n        }\n\n        if (IS_UDP(transport)) {\n            int c;\n\n            for (c = 0; c < settings.num_threads_per_udp; c++) {\n                /* this is guaranteed to hit all threads because we round-robin */\n                dispatch_conn_new(sfd, conn_read, EV_READ | EV_PERSIST,\n                                  UDP_READ_BUFFER_SIZE, transport);\n                STATS_LOCK();\n                ++stats.curr_conns;\n                ++stats.daemon_conns;\n                STATS_UNLOCK();\n            }\n        } else {\n            if (!(listen_conn_add = conn_new(sfd, conn_listening,\n                                             EV_READ | EV_PERSIST, 1,\n                                             transport, main_base, NULL))) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                        \"failed to create listening connection\\n\");\n                exit(EXIT_FAILURE);\n            }\n            listen_conn_add->next = listen_conn;\n            listen_conn = listen_conn_add;\n            STATS_LOCK();\n            ++stats.curr_conns;\n            ++stats.daemon_conns;\n            STATS_UNLOCK();\n        }\n    }\n\n    freeaddrinfo(ai);\n\n    /* Return zero iff we detected no errors in starting up connections */\n    return success == 0;\n}\n\nstatic int server_sockets(int port, enum network_transport transport,\n                          FILE *portnumber_file) {\n    if (settings.inter == NULL) {\n        return server_socket(settings.inter, port, transport, portnumber_file);\n    } else {\n        // tokenize them and bind to each one of them..\n        char *b;\n        int ret = 0;\n        char *list = strdup(settings.inter);\n\n        if (list == NULL) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                            \"Failed to allocate memory for parsing server interface string\\n\");\n            return 1;\n        }\n        for (char *p = strtok_r(list, \";,\", &b);\n             p != NULL;\n             p = strtok_r(NULL, \";,\", &b)) {\n            int the_port = port;\n\n            char *s = strchr(p, ':');\n            if (s != NULL) {\n                *s = '\\0';\n                ++s;\n                if (!safe_strtol(s, &the_port)) {\n                    settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                                    \"Invalid port number: \\\"%s\\\"\", s);\n                    return 1;\n                }\n            }\n            if (strcmp(p, \"*\") == 0) {\n                p = NULL;\n            }\n            ret |= server_socket(p, the_port, transport, portnumber_file);\n        }\n        free(list);\n        return ret;\n    }\n}\n\nstatic int new_socket_unix(void) {\n    int sfd;\n\n    if ((sfd = socket(AF_UNIX, SOCK_STREAM, 0)) == INVALID_SOCKET) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                        \"socket(AF_UNIX, SOCK_STREAM, 0): %s\",\n                                        strerror(errno));\n        return INVALID_SOCKET;\n    }\n\n    if (evutil_make_socket_nonblocking(sfd) == -1) {\n        safe_close(sfd);\n        return INVALID_SOCKET;\n    }\n    return sfd;\n}\n\n/* this will probably not work on windows */\nstatic int server_socket_unix(const char *path, int access_mask) {\n    int sfd;\n    struct linger ling = {0, 0};\n    struct sockaddr_un addr;\n    struct stat tstat;\n    int flags =1;\n    int old_umask;\n\n    if (!path) {\n        return 1;\n    }\n\n    if ((sfd = new_socket_unix()) == -1) {\n        return 1;\n    }\n\n    /*\n     * Clean up a previous socket file if we left it around\n     */\n    if (lstat(path, &tstat) == 0) {\n        if (S_ISSOCK(tstat.st_mode))\n            unlink(path);\n    }\n\n    setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flags, sizeof(flags));\n    setsockopt(sfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flags, sizeof(flags));\n    setsockopt(sfd, SOL_SOCKET, SO_LINGER, (void *)&ling, sizeof(ling));\n\n    /*\n     * the memset call clears nonstandard fields in some impementations\n     * that otherwise mess things up.\n     */\n    memset(&addr, 0, sizeof(addr));\n\n    addr.sun_family = AF_UNIX;\n    strncpy(addr.sun_path, path, sizeof(addr.sun_path) - 1);\n    assert(strcmp(addr.sun_path, path) == 0);\n    old_umask = umask( ~(access_mask&0777));\n    if (bind(sfd, (struct sockaddr *)&addr, sizeof(addr)) == -1) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                        \"bind(): %s\",\n                                        strerror(errno));\n        safe_close(sfd);\n        umask(old_umask);\n        return 1;\n    }\n    umask(old_umask);\n    if (listen(sfd, settings.backlog) == -1) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                        \"listen(): %s\",\n                                        strerror(errno));\n        safe_close(sfd);\n        return 1;\n    }\n    if (!(listen_conn = conn_new(sfd, conn_listening,\n                                 EV_READ | EV_PERSIST, 1,\n                                 local_transport, main_base, NULL))) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                 \"failed to create listening connection\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    STATS_LOCK();\n    ++stats.daemon_conns;\n    STATS_UNLOCK();\n\n    return 0;\n}\n\nstatic struct event clockevent;\n\n/* time-sensitive callers can call it by hand with this, outside the normal ever-1-second timer */\nstatic void set_current_time(void) {\n    struct timeval timer;\n\n    gettimeofday(&timer, NULL);\n    current_time = (rel_time_t) (timer.tv_sec - process_started);\n}\n\nstatic void clock_handler(const int fd, const short which, void *arg) {\n    struct timeval t = {.tv_sec = 1, .tv_usec = 0};\n    static bool initialized = false;\n\n    (void)(fd);\n    (void)(which);\n    (void)(arg);\n\n    if (memcached_shutdown) {\n        event_base_loopbreak(main_base);\n        return ;\n    }\n\n    if (initialized) {\n        /* only delete the event if it's actually there. */\n        evtimer_del(&clockevent);\n    } else {\n        initialized = true;\n    }\n\n    evtimer_set(&clockevent, clock_handler, 0);\n    event_base_set(main_base, &clockevent);\n    evtimer_add(&clockevent, &t);\n\n    set_current_time();\n}\n\nstatic void usage(void) {\n    printf(PACKAGE \" \" VERSION \"\\n\");\n    printf(\"-p <num>      TCP port number to listen on (default: 11211)\\n\"\n           \"-U <num>      UDP port number to listen on (default: 11211, 0 is off)\\n\"\n           \"-s <file>     UNIX socket path to listen on (disables network support)\\n\"\n           \"-a <mask>     access mask for UNIX socket, in octal (default: 0700)\\n\"\n           \"-l <addr>     interface to listen on (default: INADDR_ANY, all addresses)\\n\"\n           \"              <addr> may be specified as host:port. If you don't specify\\n\"\n           \"              a port number, the value you specified with -p or -U is\\n\"\n           \"              used. You may specify multiple addresses separated by comma\\n\"\n           \"              or by using -l multiple times\\n\"\n           \"-d            run as a daemon\\n\"\n           \"-r            maximize core file limit\\n\"\n           \"-u <username> assume identity of <username> (only when run as root)\\n\"\n           \"-m <num>      max memory to use for items in megabytes (default: 64 MB)\\n\"\n           \"-M            return error on memory exhausted (rather than removing items)\\n\"\n           \"-c <num>      max simultaneous connections (default: 1000)\\n\"\n           \"-k            lock down all paged memory.  Note that there is a\\n\"\n           \"              limit on how much memory you may lock.  Trying to\\n\"\n           \"              allocate more than that would fail, so be sure you\\n\"\n           \"              set the limit correctly for the user you started\\n\"\n           \"              the daemon with (not for -u <username> user;\\n\"\n           \"              under sh this is done with 'ulimit -S -l NUM_KB').\\n\"\n           \"-v            verbose (print errors/warnings while in event loop)\\n\"\n           \"-vv           very verbose (also print client commands/reponses)\\n\"\n           \"-vvv          extremely verbose (also print internal state transitions)\\n\"\n           \"-h            print this help and exit\\n\"\n           \"-i            print memcached and libevent license\\n\"\n           \"-P <file>     save PID in <file>, only used with -d option\\n\"\n           \"-f <factor>   chunk size growth factor (default: 1.25)\\n\"\n           \"-n <bytes>    minimum space allocated for key+value+flags (default: 48)\\n\");\n    printf(\"-L            Try to use large memory pages (if available). Increasing\\n\"\n           \"              the memory page size could reduce the number of TLB misses\\n\"\n           \"              and improve the performance. In order to get large pages\\n\"\n           \"              from the OS, memcached will allocate the total item-cache\\n\"\n           \"              in one large chunk.\\n\");\n    printf(\"-D <char>     Use <char> as the delimiter between key prefixes and IDs.\\n\"\n           \"              This is used for per-prefix stats reporting. The default is\\n\"\n           \"              \\\":\\\" (colon). If this option is specified, stats collection\\n\"\n           \"              is turned on automatically; if not, then it may be turned on\\n\"\n           \"              by sending the \\\"stats detail on\\\" command to the server.\\n\");\n    printf(\"-t <num>      number of threads to use (default: 4)\\n\");\n    printf(\"-R            Maximum number of requests per event, limits the number of\\n\"\n           \"              requests process for a given connection to prevent \\n\"\n           \"              starvation (default: 20)\\n\");\n    printf(\"-C            Disable use of CAS\\n\");\n    printf(\"-b            Set the backlog queue limit (default: 1024)\\n\");\n    printf(\"-B            Binding protocol - one of ascii, binary, or auto (default)\\n\");\n    printf(\"-I            Override the size of each slab page. Adjusts max item size\\n\"\n           \"              (default: 1mb, min: 1k, max: 128m)\\n\");\n    printf(\"-q            Disable detailed stats commands\\n\");\n#ifdef SASL_ENABLED\n    printf(\"-S            Require SASL authentication\\n\");\n#endif\n    printf(\"-X module,cfg Load the module and initialize it with the config\\n\");\n    printf(\"-E engine     Load engine as the storage engine\\n\");\n    printf(\"-e config     Pass config as configuration options to the storage engine\\n\");\n    printf(\"\\nEnvironment variables:\\n\"\n           \"MEMCACHED_PORT_FILENAME   File to write port information to\\n\"\n           \"MEMCACHED_TOP_KEYS        Number of top keys to keep track of\\n\"\n           \"MEMCACHED_REQS_TAP_EVENT  Similar to -R but for tap_ship_log\\n\");\n}\n\nstatic void usage_license(void) {\n    printf(PACKAGE \" \" VERSION \"\\n\\n\");\n    printf(\n    \"Copyright (c) 2003, Danga Interactive, Inc. <http://www.danga.com/>\\n\"\n    \"All rights reserved.\\n\"\n    \"\\n\"\n    \"Redistribution and use in source and binary forms, with or without\\n\"\n    \"modification, are permitted provided that the following conditions are\\n\"\n    \"met:\\n\"\n    \"\\n\"\n    \"    * Redistributions of source code must retain the above copyright\\n\"\n    \"notice, this list of conditions and the following disclaimer.\\n\"\n    \"\\n\"\n    \"    * Redistributions in binary form must reproduce the above\\n\"\n    \"copyright notice, this list of conditions and the following disclaimer\\n\"\n    \"in the documentation and/or other materials provided with the\\n\"\n    \"distribution.\\n\"\n    \"\\n\"\n    \"    * Neither the name of the Danga Interactive nor the names of its\\n\"\n    \"contributors may be used to endorse or promote products derived from\\n\"\n    \"this software without specific prior written permission.\\n\"\n    \"\\n\"\n    \"THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\\n\"\n    \"\\\"AS IS\\\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\\n\"\n    \"LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\\n\"\n    \"A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\\n\"\n    \"OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\\n\"\n    \"SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\\n\"\n    \"LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\\n\"\n    \"DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\\n\"\n    \"THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\\n\"\n    \"(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\\n\"\n    \"OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n\"\n    \"\\n\"\n    \"\\n\"\n    \"This product includes software developed by Niels Provos.\\n\"\n    \"\\n\"\n    \"[ libevent ]\\n\"\n    \"\\n\"\n    \"Copyright 2000-2003 Niels Provos <provos@citi.umich.edu>\\n\"\n    \"All rights reserved.\\n\"\n    \"\\n\"\n    \"Redistribution and use in source and binary forms, with or without\\n\"\n    \"modification, are permitted provided that the following conditions\\n\"\n    \"are met:\\n\"\n    \"1. Redistributions of source code must retain the above copyright\\n\"\n    \"   notice, this list of conditions and the following disclaimer.\\n\"\n    \"2. Redistributions in binary form must reproduce the above copyright\\n\"\n    \"   notice, this list of conditions and the following disclaimer in the\\n\"\n    \"   documentation and/or other materials provided with the distribution.\\n\"\n    \"3. All advertising materials mentioning features or use of this software\\n\"\n    \"   must display the following acknowledgement:\\n\"\n    \"      This product includes software developed by Niels Provos.\\n\"\n    \"4. The name of the author may not be used to endorse or promote products\\n\"\n    \"   derived from this software without specific prior written permission.\\n\"\n    \"\\n\"\n    \"THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\\n\"\n    \"IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\\n\"\n    \"OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\\n\"\n    \"IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\\n\"\n    \"INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\\n\"\n    \"NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\\n\"\n    \"DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\\n\"\n    \"THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\\n\"\n    \"(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\\n\"\n    \"THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n\"\n    );\n\n    return;\n}\n\nstatic void save_pid(const char *pid_file) {\n    FILE *fp;\n\n    if (access(pid_file, F_OK) == 0) {\n        if ((fp = fopen(pid_file, \"r\")) != NULL) {\n            char buffer[1024];\n            if (fgets(buffer, sizeof(buffer), fp) != NULL) {\n                unsigned int pid;\n                if (safe_strtoul(buffer, &pid) && kill((pid_t)pid, 0) == 0) {\n                    settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                               \"WARNING: The pid file contained the following (running) pid: %u\\n\", pid);\n                }\n            }\n            fclose(fp);\n        }\n    }\n\n    if ((fp = fopen(pid_file, \"w\")) == NULL) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                 \"Could not open the pid file %s for writing: %s\\n\",\n                 pid_file, strerror(errno));\n        return;\n    }\n\n    fprintf(fp,\"%ld\\n\", (long)getpid());\n    if (fclose(fp) == -1) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"Could not close the pid file %s: %s\\n\",\n                pid_file, strerror(errno));\n    }\n}\n\nstatic void remove_pidfile(const char *pid_file) {\n    if (pid_file != NULL) {\n        if (unlink(pid_file) != 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                    \"Could not remove the pid file %s: %s\\n\",\n                    pid_file, strerror(errno));\n        }\n    }\n}\n\n#ifndef HAVE_SIGIGNORE\nstatic int sigignore(int sig) {\n    struct sigaction sa = { .sa_handler = SIG_IGN, .sa_flags = 0 };\n\n    if (sigemptyset(&sa.sa_mask) == -1 || sigaction(sig, &sa, 0) == -1) {\n        return -1;\n    }\n    return 0;\n}\n#endif /* !HAVE_SIGIGNORE */\n\nstatic void sigterm_handler(int sig) {\n    assert(sig == SIGTERM || sig == SIGINT);\n    memcached_shutdown = 1;\n}\n\nstatic int install_sigterm_handler(void) {\n    struct sigaction sa = {.sa_handler = sigterm_handler, .sa_flags = 0};\n\n    if (sigemptyset(&sa.sa_mask) == -1 || sigaction(SIGTERM, &sa, 0) == -1 ||\n        sigaction(SIGINT, &sa, 0) == -1) {\n        return -1;\n    }\n\n    return 0;\n}\n\n/*\n * On systems that supports multiple page sizes we may reduce the\n * number of TLB-misses by using the biggest available page size\n */\nstatic int enable_large_pages(void) {\n#if defined(HAVE_GETPAGESIZES) && defined(HAVE_MEMCNTL)\n    int ret = -1;\n    size_t sizes[32];\n    int avail = getpagesizes(sizes, 32);\n    if (avail != -1) {\n        size_t max = sizes[0];\n        struct memcntl_mha arg = {0};\n        int ii;\n\n        for (ii = 1; ii < avail; ++ii) {\n            if (max < sizes[ii]) {\n                max = sizes[ii];\n            }\n        }\n\n        arg.mha_flags   = 0;\n        arg.mha_pagesize = max;\n        arg.mha_cmd = MHA_MAPSIZE_BSSBRK;\n\n        if (memcntl(0, 0, MC_HAT_ADVISE, (caddr_t)&arg, 0, 0) == -1) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                  \"Failed to set large pages: %s\\nWill use default page size\\n\",\n                  strerror(errno));\n        } else {\n            ret = 0;\n        }\n    } else {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n          \"Failed to get supported pagesizes: %s\\nWill use default page size\\n\",\n          strerror(errno));\n    }\n\n    return ret;\n#else\n    return 0;\n#endif\n}\n\nstatic const char* get_server_version(void) {\n    return VERSION;\n}\n\nstatic void store_engine_specific(const void *cookie,\n                                  void *engine_data) {\n    conn *c = (conn*)cookie;\n    c->engine_storage = engine_data;\n}\n\nstatic void *get_engine_specific(const void *cookie) {\n    conn *c = (conn*)cookie;\n    return c->engine_storage;\n}\n\nstatic int get_socket_fd(const void *cookie) {\n    conn *c = (conn *)cookie;\n    return c->sfd;\n}\n\nstatic ENGINE_ERROR_CODE reserve_cookie(const void *cookie) {\n    conn *c = (conn *)cookie;\n    ++c->refcount;\n    return ENGINE_SUCCESS;\n}\n\nstatic ENGINE_ERROR_CODE release_cookie(const void *cookie) {\n    conn *c = (conn *)cookie;\n    --c->refcount;\n    return ENGINE_SUCCESS;\n}\n\nstatic int num_independent_stats(void) {\n    return settings.num_threads + 1;\n}\n\nstatic void *new_independent_stats(void) {\n    int ii;\n    int nrecords = num_independent_stats();\n    struct independent_stats *independent_stats = calloc(sizeof(independent_stats) + sizeof(struct thread_stats) * nrecords, 1);\n    if (settings.topkeys > 0)\n        independent_stats->topkeys = topkeys_init(settings.topkeys);\n    for (ii = 0; ii < nrecords; ii++)\n        pthread_mutex_init(&independent_stats->thread_stats[ii].mutex, NULL);\n    return independent_stats;\n}\n\nstatic void release_independent_stats(void *stats) {\n    int ii;\n    int nrecords = num_independent_stats();\n    struct independent_stats *independent_stats = stats;\n    if (independent_stats->topkeys)\n        topkeys_free(independent_stats->topkeys);\n    for (ii = 0; ii < nrecords; ii++)\n        pthread_mutex_destroy(&independent_stats->thread_stats[ii].mutex);\n    free(independent_stats);\n}\n\nstatic inline struct independent_stats *get_independent_stats(conn *c) {\n    struct independent_stats *independent_stats;\n    if (settings.engine.v1->get_stats_struct != NULL) {\n        independent_stats = settings.engine.v1->get_stats_struct(settings.engine.v0, (const void *)c);\n        if (independent_stats == NULL)\n            independent_stats = default_independent_stats;\n    } else {\n        independent_stats = default_independent_stats;\n    }\n    return independent_stats;\n}\n\nstatic inline struct thread_stats *get_thread_stats(conn *c) {\n    struct independent_stats *independent_stats = get_independent_stats(c);\n    assert(c->thread->index < num_independent_stats());\n    return &independent_stats->thread_stats[c->thread->index];\n}\n\nstatic void register_callback(ENGINE_HANDLE *eh,\n                              ENGINE_EVENT_TYPE type,\n                              EVENT_CALLBACK cb, const void *cb_data) {\n    struct engine_event_handler *h =\n        calloc(sizeof(struct engine_event_handler), 1);\n\n    assert(h);\n    h->cb = cb;\n    h->cb_data = cb_data;\n    h->next = engine_event_handlers[type];\n    engine_event_handlers[type] = h;\n    (void)(eh); /* unused */\n}\n\nstatic rel_time_t get_current_time(void)\n{\n    return current_time;\n}\n\nstatic void count_eviction(const void *cookie, const void *key, const int nkey) {\n    topkeys_t *tk = get_independent_stats((conn*)cookie)->topkeys;\n    TK(tk, evictions, key, nkey, get_current_time());\n}\n\n/**\n * To make it easy for engine implementors that doesn't want to care about\n * writing their own incr/decr code, they can just set the arithmetic function\n * to NULL and use this implementation. It is not efficient, due to the fact\n * that it does multiple calls through the interface (get and then cas store).\n * If you don't care, feel free to use it..\n */\nstatic ENGINE_ERROR_CODE internal_arithmetic(ENGINE_HANDLE* handle,\n                                             const void* cookie,\n                                             const void* key,\n                                             const int nkey,\n                                             const bool increment,\n                                             const bool create,\n                                             const uint64_t delta,\n                                             const uint64_t initial,\n                                             const rel_time_t exptime,\n                                             uint64_t *cas,\n                                             uint64_t *result,\n                                             uint16_t vbucket)\n{\n    ENGINE_HANDLE_V1 *e = (ENGINE_HANDLE_V1*)handle;\n\n    item *it = NULL;\n\n    ENGINE_ERROR_CODE ret;\n    ret = e->get(handle, cookie, &it, key, nkey, vbucket);\n\n    if (ret == ENGINE_SUCCESS) {\n        item_info info = { .nvalue = 1 };\n\n        if (!e->get_item_info(handle, cookie, it, &info)) {\n            e->release(handle, cookie, it);\n            return ENGINE_FAILED;\n        }\n\n        char value[80];\n\n        if (info.value[0].iov_len > (sizeof(value) - 1)) {\n            e->release(handle, cookie, it);\n            return ENGINE_EINVAL;\n        }\n\n        memcpy(value, info.value[0].iov_base, info.value[0].iov_len);\n        value[info.value[0].iov_len] = '\\0';\n\n        uint64_t val;\n        if (!safe_strtoull(value, &val)) {\n            e->release(handle, cookie, it);\n            return ENGINE_EINVAL;\n        }\n\n        if (increment) {\n            val += delta;\n        } else {\n            if (delta > val) {\n                val = 0;\n            } else {\n                val -= delta;\n            }\n        }\n\n        size_t nb = snprintf(value, sizeof(value), \"%\"PRIu64, val);\n        *result = val;\n        item *nit = NULL;\n        if (e->allocate(handle, cookie, &nit, key,\n                        nkey, nb, info.flags, info.exptime) != ENGINE_SUCCESS) {\n            e->release(handle, cookie, it);\n            return ENGINE_ENOMEM;\n        }\n\n        item_info i2 = { .nvalue = 1 };\n        if (!e->get_item_info(handle, cookie, nit, &i2)) {\n            e->release(handle, cookie, it);\n            e->release(handle, cookie, nit);\n            return ENGINE_FAILED;\n        }\n\n        memcpy(i2.value[0].iov_base, value, nb);\n        e->item_set_cas(handle, cookie, nit, info.cas);\n        ret = e->store(handle, cookie, nit, cas, OPERATION_CAS, vbucket);\n        e->release(handle, cookie, it);\n        e->release(handle, cookie, nit);\n    } else if (ret == ENGINE_KEY_ENOENT && create) {\n        char value[80];\n        size_t nb = snprintf(value, sizeof(value), \"%\"PRIu64\"\\r\\n\", initial);\n        *result = initial;\n        if (e->allocate(handle, cookie, &it, key, nkey, nb, 0, exptime) != ENGINE_SUCCESS) {\n            e->release(handle, cookie, it);\n            return ENGINE_ENOMEM;\n        }\n\n        item_info info = { .nvalue = 1 };\n        if (!e->get_item_info(handle, cookie, it, &info)) {\n            e->release(handle, cookie, it);\n            return ENGINE_FAILED;\n        }\n\n        memcpy(info.value[0].iov_base, value, nb);\n        ret = e->store(handle, cookie, it, cas, OPERATION_CAS, vbucket);\n        e->release(handle, cookie, it);\n    }\n\n    /* We had a race condition.. just call ourself recursively to retry */\n    if (ret == ENGINE_KEY_EEXISTS) {\n        return internal_arithmetic(handle, cookie, key, nkey, increment, create, delta,\n                                   initial, exptime, cas, result, vbucket);\n    }\n\n    return ret;\n}\n\n/**\n * Register an extension if it's not already registered\n *\n * @param type the type of the extension to register\n * @param extension the extension to register\n * @return true if success, false otherwise\n */\nstatic bool register_extension(extension_type_t type, void *extension)\n{\n    if (extension == NULL) {\n        return false;\n    }\n\n    switch (type) {\n    case EXTENSION_DAEMON:\n        for (EXTENSION_DAEMON_DESCRIPTOR *ptr = settings.extensions.daemons;\n             ptr != NULL;\n             ptr = ptr->next) {\n            if (ptr == extension) {\n                return false;\n            }\n        }\n        ((EXTENSION_DAEMON_DESCRIPTOR *)(extension))->next = settings.extensions.daemons;\n        settings.extensions.daemons = extension;\n        return true;\n    case EXTENSION_LOGGER:\n        settings.extensions.logger = extension;\n        return true;\n    case EXTENSION_ASCII_PROTOCOL:\n        if (settings.extensions.ascii != NULL) {\n            EXTENSION_ASCII_PROTOCOL_DESCRIPTOR *last;\n            for (last = settings.extensions.ascii; last->next != NULL;\n                 last = last->next) {\n                if (last == extension) {\n                    return false;\n                }\n            }\n            if (last == extension) {\n                return false;\n            }\n            last->next = extension;\n            last->next->next = NULL;\n        } else {\n            settings.extensions.ascii = extension;\n            settings.extensions.ascii->next = NULL;\n        }\n        return true;\n\n    case EXTENSION_BINARY_PROTOCOL:\n        if (settings.extensions.binary != NULL) {\n            EXTENSION_BINARY_PROTOCOL_DESCRIPTOR *last;\n            for (last = settings.extensions.binary; last->next != NULL;\n                 last = last->next) {\n                if (last == extension) {\n                    return false;\n                }\n            }\n            if (last == extension) {\n                return false;\n            }\n            last->next = extension;\n            last->next->next = NULL;\n        } else {\n            settings.extensions.binary = extension;\n            settings.extensions.binary->next = NULL;\n        }\n\n        ((EXTENSION_BINARY_PROTOCOL_DESCRIPTOR*)extension)->setup(setup_binary_lookup_cmd);\n        return true;\n\n    default:\n        return false;\n    }\n}\n\n/**\n * Unregister an extension\n *\n * @param type the type of the extension to remove\n * @param extension the extension to remove\n */\nstatic void unregister_extension(extension_type_t type, void *extension)\n{\n    switch (type) {\n    case EXTENSION_DAEMON:\n        {\n            EXTENSION_DAEMON_DESCRIPTOR *prev = NULL;\n            EXTENSION_DAEMON_DESCRIPTOR *ptr = settings.extensions.daemons;\n\n            while (ptr != NULL && ptr != extension) {\n                prev = ptr;\n                ptr = ptr->next;\n            }\n\n            if (ptr != NULL && prev != NULL) {\n                prev->next = ptr->next;\n            }\n\n            if (settings.extensions.daemons == ptr) {\n                settings.extensions.daemons = ptr->next;\n            }\n        }\n        break;\n    case EXTENSION_LOGGER:\n        if (settings.extensions.logger == extension) {\n            if (get_stderr_logger() == extension) {\n                settings.extensions.logger = get_null_logger();\n            } else {\n                settings.extensions.logger = get_stderr_logger();\n            }\n        }\n        break;\n    case EXTENSION_ASCII_PROTOCOL:\n        {\n            EXTENSION_ASCII_PROTOCOL_DESCRIPTOR *prev = NULL;\n            EXTENSION_ASCII_PROTOCOL_DESCRIPTOR *ptr = settings.extensions.ascii;\n\n            while (ptr != NULL && ptr != extension) {\n                prev = ptr;\n                ptr = ptr->next;\n            }\n\n            if (ptr != NULL && prev != NULL) {\n                prev->next = ptr->next;\n            }\n\n            if (settings.extensions.ascii == ptr) {\n                settings.extensions.ascii = ptr->next;\n            }\n        }\n        break;\n\n\n    case EXTENSION_BINARY_PROTOCOL:\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                        \"You can't unregister a binary command handler!\");\n        abort();\n        break;\n\n    default:\n        ;\n    }\n\n}\n\n/**\n * Get the named extension\n */\nstatic void* get_extension(extension_type_t type)\n{\n    switch (type) {\n    case EXTENSION_DAEMON:\n        return settings.extensions.daemons;\n\n    case EXTENSION_LOGGER:\n        return settings.extensions.logger;\n\n    case EXTENSION_ASCII_PROTOCOL:\n        return settings.extensions.ascii;\n\n    case EXTENSION_BINARY_PROTOCOL:\n        return settings.extensions.binary;\n\n    default:\n        return NULL;\n    }\n}\n\nstatic void shutdown_server(void) {\n    memcached_shutdown = 1;\n}\n\nstatic EXTENSION_LOGGER_DESCRIPTOR* get_logger(void)\n{\n    return settings.extensions.logger;\n}\n\nstatic EXTENSION_LOG_LEVEL get_log_level(void)\n{\n    EXTENSION_LOG_LEVEL ret;\n    switch (settings.verbose) {\n    case 0: ret = EXTENSION_LOG_WARNING; break;\n    case 1: ret = EXTENSION_LOG_INFO; break;\n    case 2: ret = EXTENSION_LOG_DEBUG; break;\n    default:\n        ret = EXTENSION_LOG_DETAIL;\n    }\n    return ret;\n}\n\nstatic void set_log_level(EXTENSION_LOG_LEVEL severity)\n{\n    switch (severity) {\n    case EXTENSION_LOG_WARNING: settings.verbose = 0; break;\n    case EXTENSION_LOG_INFO: settings.verbose = 1; break;\n    case EXTENSION_LOG_DEBUG: settings.verbose = 2; break;\n    default:\n        settings.verbose = 3;\n    }\n}\n\nstatic void get_config_append_stats(const char *key, const uint16_t klen,\n                                    const char *val, const uint32_t vlen,\n                                    const void *cookie)\n{\n    if (klen == 0  || vlen == 0) {\n        return ;\n    }\n\n    char *pos = (char*)cookie;\n    size_t nbytes = strlen(pos);\n\n    if ((nbytes + klen + vlen + 3) > 1024) {\n        // Not enough size in the buffer..\n        return;\n    }\n\n    memcpy(pos + nbytes, key, klen);\n    nbytes += klen;\n    pos[nbytes] = '=';\n    ++nbytes;\n    memcpy(pos + nbytes, val, vlen);\n    nbytes += vlen;\n    memcpy(pos + nbytes, \";\", 2);\n}\n\nstatic bool get_config(struct config_item items[]) {\n    char config[1024];\n    config[0] = '\\0';\n    process_stat_settings(get_config_append_stats, config);\n    int rval = parse_config(config, items, NULL);\n    return rval >= 0;\n}\n\n/**\n * Callback the engines may call to get the public server interface\n * @return pointer to a structure containing the interface. The client should\n *         know the layout and perform the proper casts.\n */\nstatic SERVER_HANDLE_V1 *get_server_api(void)\n{\n    static SERVER_CORE_API core_api = {\n        .server_version = get_server_version,\n        .hash = hash,\n        .realtime = realtime,\n        .abstime = abstime,\n        .get_current_time = get_current_time,\n        .parse_config = parse_config,\n        .shutdown = shutdown_server,\n        .get_config = get_config\n    };\n\n    static SERVER_COOKIE_API server_cookie_api = {\n        .get_auth_data = get_auth_data,\n        .store_engine_specific = store_engine_specific,\n        .get_engine_specific = get_engine_specific,\n        .get_socket_fd = get_socket_fd,\n        .notify_io_complete = notify_io_complete,\n        .reserve = reserve_cookie,\n        .release = release_cookie\n    };\n\n    static SERVER_STAT_API server_stat_api = {\n        .new_stats = new_independent_stats,\n        .release_stats = release_independent_stats,\n        .evicting = count_eviction\n    };\n\n    static SERVER_LOG_API server_log_api = {\n        .get_logger = get_logger,\n        .get_level = get_log_level,\n        .set_level = set_log_level\n    };\n\n    static SERVER_EXTENSION_API extension_api = {\n        .register_extension = register_extension,\n        .unregister_extension = unregister_extension,\n        .get_extension = get_extension\n    };\n\n    static SERVER_CALLBACK_API callback_api = {\n        .register_callback = register_callback,\n        .perform_callbacks = perform_callbacks,\n    };\n\n    static SERVER_HANDLE_V1 rv = {\n        .interface = 1,\n        .core = &core_api,\n        .stat = &server_stat_api,\n        .extension = &extension_api,\n        .callback = &callback_api,\n        .log = &server_log_api,\n        .cookie = &server_cookie_api\n    };\n\n    if (rv.engine == NULL) {\n        rv.engine = settings.engine.v0;\n    }\n\n    return &rv;\n}\n\n/**\n * Load a shared object and initialize all the extensions in there.\n *\n * @param soname the name of the shared object (may not be NULL)\n * @param config optional configuration parameters\n * @return true if success, false otherwise\n */\nstatic bool load_extension(const char *soname, const char *config) {\n    if (soname == NULL) {\n        return false;\n    }\n\n    /* Hack to remove the warning from C99 */\n    union my_hack {\n        MEMCACHED_EXTENSIONS_INITIALIZE initialize;\n        void* voidptr;\n    } funky = {.initialize = NULL };\n\n    void *handle = dlopen(soname, RTLD_NOW | RTLD_LOCAL);\n    if (handle == NULL) {\n        const char *msg = dlerror();\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"Failed to open library \\\"%s\\\": %s\\n\",\n                soname, msg ? msg : \"unknown error\");\n        return false;\n    }\n\n    void *symbol = dlsym(handle, \"memcached_extensions_initialize\");\n    if (symbol == NULL) {\n        const char *msg = dlerror();\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"Could not find symbol \\\"memcached_extensions_initialize\\\" in %s: %s\\n\",\n                soname, msg ? msg : \"unknown error\");\n        return false;\n    }\n    funky.voidptr = symbol;\n\n    EXTENSION_ERROR_CODE error = (*funky.initialize)(config, get_server_api);\n\n    if (error != EXTENSION_SUCCESS) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"Failed to initalize extensions from %s. Error code: %d\\n\",\n                soname, error);\n        dlclose(handle);\n        return false;\n    }\n\n    if (settings.verbose > 0) {\n        settings.extensions.logger->log(EXTENSION_LOG_INFO, NULL,\n                \"Loaded extensions from: %s\\n\", soname);\n    }\n\n    return true;\n}\n\n/**\n * Do basic sanity check of the runtime environment\n * @return true if no errors found, false if we can't use this env\n */\nstatic bool sanitycheck(void) {\n    /* One of our biggest problems is old and bogus libevents */\n    const char *ever = event_get_version();\n    if (ever != NULL) {\n        if (strncmp(ever, \"1.\", 2) == 0) {\n            /* Require at least 1.3 (that's still a couple of years old) */\n            if ((ever[2] == '1' || ever[2] == '2') && !isdigit(ever[3])) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                        \"You are using libevent %s.\\nPlease upgrade to\"\n                        \" a more recent version (1.3 or newer)\\n\",\n                        event_get_version());\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n\nint main (int argc, char **argv) {\n    int c;\n    bool lock_memory = false;\n    bool do_daemonize = false;\n    int maxcore = 0;\n    char *username = NULL;\n    char *pid_file = NULL;\n    struct passwd *pw;\n    struct rlimit rlim;\n    char unit = '\\0';\n    int size_max = 0;\n\n    bool protocol_specified = false;\n    bool tcp_specified = false;\n    bool udp_specified = false;\n\n    const char *engine = \"default_engine.so\";\n    const char *engine_config = NULL;\n    char old_options[1024] = { [0] = '\\0' };\n    char *old_opts = old_options;\n\n    /* make the time we started always be 2 seconds before we really\n       did, so time(0) - time.started is never zero.  if so, things\n       like 'settings.oldest_live' which act as booleans as well as\n       values are now false in boolean context... */\n    process_started = time(0) - 2;\n    set_current_time();\n\n    /* Initialize the socket subsystem */\n    initialize_sockets();\n\n    /* init settings */\n    settings_init();\n\n    initialize_binary_lookup_map();\n\n    if (memcached_initialize_stderr_logger(get_server_api) != EXTENSION_SUCCESS) {\n        fprintf(stderr, \"Failed to initialize log system\\n\");\n        return EX_OSERR;\n    }\n\n    if (!sanitycheck()) {\n        return EX_OSERR;\n    }\n\n    /* process arguments */\n    while (-1 != (c = getopt(argc, argv,\n          \"a:\"  /* access mask for unix socket */\n          \"p:\"  /* TCP port number to listen on */\n          \"s:\"  /* unix socket path to listen on */\n          \"U:\"  /* UDP port number to listen on */\n          \"m:\"  /* max memory to use for items in megabytes */\n          \"M\"   /* return error on memory exhausted */\n          \"c:\"  /* max simultaneous connections */\n          \"k\"   /* lock down all paged memory */\n          \"hi\"  /* help, licence info */\n          \"r\"   /* maximize core file limit */\n          \"v\"   /* verbose */\n          \"d\"   /* daemon mode */\n          \"l:\"  /* interface to listen on */\n          \"u:\"  /* user identity to run as */\n          \"P:\"  /* save PID in file */\n          \"f:\"  /* factor? */\n          \"n:\"  /* minimum space allocated for key+value+flags */\n          \"t:\"  /* threads */\n          \"D:\"  /* prefix delimiter? */\n          \"L\"   /* Large memory pages */\n          \"R:\"  /* max requests per event */\n          \"C\"   /* Disable use of CAS */\n          \"b:\"  /* backlog queue limit */\n          \"B:\"  /* Binding protocol */\n          \"I:\"  /* Max item size */\n          \"S\"   /* Sasl ON */\n          \"E:\"  /* Engine to load */\n          \"e:\"  /* Engine options */\n          \"q\"   /* Disallow detailed stats */\n          \"X:\"  /* Load extension */\n        ))) {\n        switch (c) {\n        case 'a':\n            /* access for unix domain socket, as octal mask (like chmod)*/\n            settings.access= strtol(optarg,NULL,8);\n            break;\n\n        case 'U':\n            settings.udpport = atoi(optarg);\n            udp_specified = true;\n            break;\n        case 'p':\n            settings.port = atoi(optarg);\n            tcp_specified = true;\n            break;\n        case 's':\n            settings.socketpath = optarg;\n            break;\n        case 'm':\n            settings.maxbytes = ((size_t)atoi(optarg)) * 1024 * 1024;\n             old_opts += sprintf(old_opts, \"cache_size=%lu;\",\n                                 (unsigned long)settings.maxbytes);\n           break;\n        case 'M':\n            settings.evict_to_free = 0;\n            old_opts += sprintf(old_opts, \"eviction=false;\");\n            break;\n        case 'c':\n            settings.maxconns = atoi(optarg);\n            break;\n        case 'h':\n            usage();\n            exit(EXIT_SUCCESS);\n        case 'i':\n            usage_license();\n            exit(EXIT_SUCCESS);\n        case 'k':\n            lock_memory = true;\n            break;\n        case 'v':\n            settings.verbose++;\n            perform_callbacks(ON_LOG_LEVEL, NULL, NULL);\n            break;\n        case 'l':\n            if (settings.inter != NULL) {\n                size_t len = strlen(settings.inter) + strlen(optarg) + 2;\n                char *p = malloc(len);\n                if (p == NULL) {\n                    settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                                    \"Failed to allocate memory\\n\");\n                    return 1;\n                }\n                snprintf(p, len, \"%s,%s\", settings.inter, optarg);\n                free(settings.inter);\n                settings.inter = p;\n            } else {\n                settings.inter= strdup(optarg);\n            }\n            break;\n        case 'd':\n            do_daemonize = true;\n            break;\n        case 'r':\n            maxcore = 1;\n            break;\n        case 'R':\n            settings.reqs_per_event = atoi(optarg);\n            if (settings.reqs_per_event <= 0) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                      \"Number of requests per event must be greater than 0\\n\");\n                return 1;\n            }\n            break;\n        case 'u':\n            username = optarg;\n            break;\n        case 'P':\n            pid_file = optarg;\n            break;\n        case 'f':\n            settings.factor = atof(optarg);\n            if (settings.factor <= 1.0) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                        \"Factor must be greater than 1\\n\");\n                return 1;\n            }\n             old_opts += sprintf(old_opts, \"factor=%f;\",\n                                 settings.factor);\n           break;\n        case 'n':\n            settings.chunk_size = atoi(optarg);\n            if (settings.chunk_size == 0) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                        \"Chunk size must be greater than 0\\n\");\n                return 1;\n            }\n            old_opts += sprintf(old_opts, \"chunk_size=%u;\",\n                                settings.chunk_size);\n            break;\n        case 't':\n            settings.num_threads = atoi(optarg);\n            if (settings.num_threads <= 0) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                        \"Number of threads must be greater than 0\\n\");\n                return 1;\n            }\n            /* There're other problems when you get above 64 threads.\n             * In the future we should portably detect # of cores for the\n             * default.\n             */\n            if (settings.num_threads > 64) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                        \"WARNING: Setting a high number of worker\"\n                        \"threads is not recommended.\\n\"\n                        \" Set this value to the number of cores in\"\n                        \" your machine or less.\\n\");\n            }\n            break;\n        case 'D':\n            settings.prefix_delimiter = optarg[0];\n            settings.detail_enabled = 1;\n            break;\n        case 'L' :\n            if (enable_large_pages() == 0) {\n                old_opts += sprintf(old_opts, \"preallocate=true;\");\n            }\n            break;\n        case 'C' :\n            settings.use_cas = false;\n            break;\n        case 'b' :\n            settings.backlog = atoi(optarg);\n            break;\n        case 'B':\n            protocol_specified = true;\n            if (strcmp(optarg, \"auto\") == 0) {\n                settings.binding_protocol = negotiating_prot;\n            } else if (strcmp(optarg, \"binary\") == 0) {\n                settings.binding_protocol = binary_prot;\n            } else if (strcmp(optarg, \"ascii\") == 0) {\n                settings.binding_protocol = ascii_prot;\n            } else {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                        \"Invalid value for binding protocol: %s\\n\"\n                        \" -- should be one of auto, binary, or ascii\\n\", optarg);\n                exit(EX_USAGE);\n            }\n            break;\n        case 'I':\n            unit = optarg[strlen(optarg)-1];\n            if (unit == 'k' || unit == 'm' ||\n                unit == 'K' || unit == 'M') {\n                optarg[strlen(optarg)-1] = '\\0';\n                size_max = atoi(optarg);\n                if (unit == 'k' || unit == 'K')\n                    size_max *= 1024;\n                if (unit == 'm' || unit == 'M')\n                    size_max *= 1024 * 1024;\n                settings.item_size_max = size_max;\n            } else {\n                settings.item_size_max = atoi(optarg);\n            }\n            if (settings.item_size_max < 1024) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                        \"Item max size cannot be less than 1024 bytes.\\n\");\n                return 1;\n            }\n            if (settings.item_size_max > 1024 * 1024 * 128) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                        \"Cannot set item size limit higher than 128 mb.\\n\");\n                return 1;\n            }\n            if (settings.item_size_max > 1024 * 1024) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                    \"WARNING: Setting item max size above 1MB is not\"\n                    \" recommended!\\n\"\n                    \" Raising this limit increases the minimum memory requirements\\n\"\n                    \" and will decrease your memory efficiency.\\n\"\n                );\n            }\n#ifndef __WIN32__\n            old_opts += sprintf(old_opts, \"item_size_max=%zu;\",\n                                settings.item_size_max);\n#else\n            old_opts += sprintf(old_opts, \"item_size_max=%lu;\", (long unsigned)\n                                settings.item_size_max);\n#endif\n            break;\n        case 'E':\n            engine = optarg;\n            break;\n        case 'e':\n            engine_config = optarg;\n            break;\n        case 'q':\n            settings.allow_detailed = false;\n            break;\n        case 'S': /* set Sasl authentication to true. Default is false */\n#ifndef SASL_ENABLED\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                    \"This server is not built with SASL support.\\n\");\n            exit(EX_USAGE);\n#else\n            settings.require_sasl = true;\n#endif\n            break;\n        case 'X' :\n            {\n                char *ptr = strchr(optarg, ',');\n                if (ptr != NULL) {\n                    *ptr = '\\0';\n                    ++ptr;\n                }\n                if (!load_extension(optarg, ptr)) {\n                    exit(EXIT_FAILURE);\n                }\n                if (ptr != NULL) {\n                    *(ptr - 1) = ',';\n                }\n            }\n            break;\n        default:\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                    \"Illegal argument \\\"%c\\\"\\n\", c);\n            return 1;\n        }\n    }\n\n    /*\n     * Use one workerthread to serve each UDP port if the user specified\n     * multiple ports\n     */\n    if (settings.inter != NULL && strchr(settings.inter, ',')) {\n        settings.num_threads_per_udp = 1;\n    } else {\n        settings.num_threads_per_udp = settings.num_threads;\n    }\n\n    if (getenv(\"MEMCACHED_REQS_TAP_EVENT\") != NULL) {\n        settings.reqs_per_tap_event = atoi(getenv(\"MEMCACHED_REQS_TAP_EVENT\"));\n    }\n\n    if (settings.reqs_per_tap_event <= 0) {\n        settings.reqs_per_tap_event = DEFAULT_REQS_PER_TAP_EVENT;\n    }\n\n\n    if (install_sigterm_handler() != 0) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                        \"Failed to install SIGTERM handler\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    char *topkeys_env = getenv(\"MEMCACHED_TOP_KEYS\");\n    if (topkeys_env != NULL) {\n        settings.topkeys = atoi(topkeys_env);\n        if (settings.topkeys < 0) {\n            settings.topkeys = 0;\n        }\n    }\n\n    if (settings.require_sasl) {\n        if (!protocol_specified) {\n            settings.binding_protocol = binary_prot;\n        } else {\n            if (settings.binding_protocol == negotiating_prot) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                        \"ERROR: You cannot use auto-negotiating protocol while requiring SASL.\\n\");\n                exit(EX_USAGE);\n            }\n            if (settings.binding_protocol == ascii_prot) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                        \"ERROR: You cannot use only ASCII protocol while requiring SASL.\\n\");\n                exit(EX_USAGE);\n            }\n        }\n    }\n\n    if (tcp_specified && !udp_specified) {\n        settings.udpport = settings.port;\n    } else if (udp_specified && !tcp_specified) {\n        settings.port = settings.udpport;\n    }\n\n    if (engine_config != NULL && strlen(old_options) > 0) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"ERROR: You can't mix -e with the old options\\n\");\n        return EX_USAGE;\n    } else if (engine_config == NULL && strlen(old_options) > 0) {\n        engine_config = old_options;\n    }\n\n    if (maxcore != 0) {\n        struct rlimit rlim_new;\n        /*\n         * First try raising to infinity; if that fails, try bringing\n         * the soft limit to the hard.\n         */\n        if (getrlimit(RLIMIT_CORE, &rlim) == 0) {\n            rlim_new.rlim_cur = rlim_new.rlim_max = RLIM_INFINITY;\n            if (setrlimit(RLIMIT_CORE, &rlim_new)!= 0) {\n                /* failed. try raising just to the old max */\n                rlim_new.rlim_cur = rlim_new.rlim_max = rlim.rlim_max;\n                (void)setrlimit(RLIMIT_CORE, &rlim_new);\n            }\n        }\n        /*\n         * getrlimit again to see what we ended up with. Only fail if\n         * the soft limit ends up 0, because then no core files will be\n         * created at all.\n         */\n\n        if ((getrlimit(RLIMIT_CORE, &rlim) != 0) || rlim.rlim_cur == 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                    \"failed to ensure corefile creation\\n\");\n            exit(EX_OSERR);\n        }\n    }\n\n    /*\n     * If needed, increase rlimits to allow as many connections\n     * as needed.\n     */\n\n    if (getrlimit(RLIMIT_NOFILE, &rlim) != 0) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"failed to getrlimit number of files\\n\");\n        exit(EX_OSERR);\n    } else {\n        unsigned int maxfiles = settings.maxconns + (3 * (settings.num_threads + 2));\n        int syslimit = rlim.rlim_cur;\n        if (rlim.rlim_cur < maxfiles) {\n            rlim.rlim_cur = maxfiles;\n        }\n        if (rlim.rlim_max < rlim.rlim_cur) {\n            rlim.rlim_max = rlim.rlim_cur;\n        }\n        if (setrlimit(RLIMIT_NOFILE, &rlim) != 0) {\n            const char *fmt;\n            fmt = \"WARNING: maxconns cannot be set to (%d) connections due to \"\n                \"system\\nresouce restrictions. Increase the number of file \"\n                \"descriptors allowed\\nto the memcached user process or start \"\n                \"memcached as root (remember\\nto use the -u parameter).\\n\"\n                \"The maximum number of connections is set to %d.\\n\";\n            int req = settings.maxconns;\n            settings.maxconns = syslimit - (3 * (settings.num_threads + 2));\n            if (settings.maxconns < 0) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                         \"failed to set rlimit for open files. Try starting as\"\n                         \" root or requesting smaller maxconns value.\\n\");\n                exit(EX_OSERR);\n            }\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                            fmt, req, settings.maxconns);\n        }\n    }\n\n    /* Sanity check for the connection structures */\n    int nfiles = 0;\n    if (settings.port != 0) {\n        nfiles += 2;\n    }\n    if (settings.udpport != 0) {\n        nfiles += settings.num_threads * 2;\n    }\n\n    if (settings.maxconns <= nfiles) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"Configuratioin error. \\n\"\n                \"You specified %d connections, but the system will use at \"\n                \"least %d\\nconnection structures to start.\\n\",\n                settings.maxconns, nfiles);\n        exit(EX_USAGE);\n    }\n\n    /* lose root privileges if we have them */\n    if (getuid() == 0 || geteuid() == 0) {\n        if (username == 0 || *username == '\\0') {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                    \"can't run as root without the -u switch\\n\");\n            exit(EX_USAGE);\n        }\n        if ((pw = getpwnam(username)) == 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                    \"can't find the user %s to switch to\\n\", username);\n            exit(EX_NOUSER);\n        }\n        if (setgid(pw->pw_gid) < 0 || setuid(pw->pw_uid) < 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                    \"failed to assume identity of user %s: %s\\n\", username,\n                    strerror(errno));\n            exit(EX_OSERR);\n        }\n    }\n\n#ifdef SASL_ENABLED\n    init_sasl();\n#endif /* SASL */\n\n    /* daemonize if requested */\n    /* if we want to ensure our ability to dump core, don't chdir to / */\n    if (do_daemonize) {\n        if (sigignore(SIGHUP) == -1) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                    \"Failed to ignore SIGHUP: \", strerror(errno));\n        }\n        if (daemonize(maxcore, settings.verbose) == -1) {\n             settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                    \"failed to daemon() in order to daemonize\\n\");\n            exit(EXIT_FAILURE);\n        }\n    }\n\n    /* lock paged memory if needed */\n    if (lock_memory) {\n#ifdef HAVE_MLOCKALL\n        int res = mlockall(MCL_CURRENT | MCL_FUTURE);\n        if (res != 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                    \"warning: -k invalid, mlockall() failed: %s\\n\",\n                    strerror(errno));\n        }\n#else\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"warning: -k invalid, mlockall() not supported on this platform.  proceeding without.\\n\");\n#endif\n    }\n\n    /* initialize main thread libevent instance */\n    main_base = event_init();\n\n    /* Load the storage engine */\n    ENGINE_HANDLE *engine_handle = NULL;\n    if (!load_engine(engine,get_server_api,settings.extensions.logger,&engine_handle)) {\n        /* Error already reported */\n        exit(EXIT_FAILURE);\n    }\n\n    if (!init_engine(engine_handle,engine_config,settings.extensions.logger)) {\n        return false;\n    }\n\n    if (settings.verbose > 0) {\n        log_engine_details(engine_handle,settings.extensions.logger);\n    }\n    settings.engine.v1 = (ENGINE_HANDLE_V1 *) engine_handle;\n\n    if (settings.engine.v1->arithmetic == NULL) {\n        settings.engine.v1->arithmetic = internal_arithmetic;\n    }\n\n    /* initialize other stuff */\n    stats_init();\n\n    if (!(conn_cache = cache_create(\"conn\", sizeof(conn), sizeof(void*),\n                                    conn_constructor, conn_destructor))) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"Failed to create connection cache\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    default_independent_stats = new_independent_stats();\n\n#ifndef __WIN32__\n    /*\n     * ignore SIGPIPE signals; we can use errno == EPIPE if we\n     * need that information\n     */\n    if (sigignore(SIGPIPE) == -1) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"failed to ignore SIGPIPE; sigaction\");\n        exit(EX_OSERR);\n    }\n#endif\n\n    /* start up worker threads if MT mode */\n    thread_init(settings.num_threads, main_base, dispatch_event_handler);\n\n    /* initialise clock event */\n    clock_handler(0, 0, 0);\n\n    /* create unix mode sockets after dropping privileges */\n    if (settings.socketpath != NULL) {\n        if (server_socket_unix(settings.socketpath,settings.access)) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                            \"failed to listen on UNIX socket \\\"%s\\\": %s\",\n                                            settings.socketpath, strerror(errno));\n            exit(EX_OSERR);\n        }\n    }\n\n    /* create the listening socket, bind it, and init */\n    if (settings.socketpath == NULL) {\n        int udp_port;\n\n        const char *portnumber_filename = getenv(\"MEMCACHED_PORT_FILENAME\");\n        char temp_portnumber_filename[PATH_MAX];\n        FILE *portnumber_file = NULL;\n\n        if (portnumber_filename != NULL) {\n            snprintf(temp_portnumber_filename,\n                     sizeof(temp_portnumber_filename),\n                     \"%s.lck\", portnumber_filename);\n\n            portnumber_file = fopen(temp_portnumber_filename, \"a\");\n            if (portnumber_file == NULL) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                        \"Failed to open \\\"%s\\\": %s\\n\",\n                        temp_portnumber_filename, strerror(errno));\n            }\n        }\n\n        if (settings.port && server_sockets(settings.port, tcp_transport,\n                                            portnumber_file)) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                            \"failed to listen on TCP port %d: %s\",\n                                            settings.port, strerror(errno));\n            exit(EX_OSERR);\n        }\n\n        /*\n         * initialization order: first create the listening sockets\n         * (may need root on low ports), then drop root if needed,\n         * then daemonise if needed, then init libevent (in some cases\n         * descriptors created by libevent wouldn't survive forking).\n         */\n        udp_port = settings.udpport ? settings.udpport : settings.port;\n\n        /* create the UDP listening socket and bind it */\n        if (settings.udpport && server_sockets(udp_port, udp_transport,\n                                               portnumber_file)) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                            \"failed to listen on UDP port %d: %s\",\n                                            settings.port, strerror(errno));\n            exit(EX_OSERR);\n        }\n\n        if (portnumber_file) {\n            fclose(portnumber_file);\n            rename(temp_portnumber_filename, portnumber_filename);\n        }\n    }\n\n    if (pid_file != NULL) {\n        save_pid(pid_file);\n    }\n\n    /* Drop privileges no longer needed */\n    drop_privileges();\n\n    if (!memcached_shutdown) {\n        /* enter the event loop */\n        event_base_loop(main_base, 0);\n    }\n\n    if (settings.verbose) {\n        settings.extensions.logger->log(EXTENSION_LOG_INFO, NULL,\n                                        \"Initiating shutdown\\n\");\n    }\n    threads_shutdown();\n\n    settings.engine.v1->destroy(settings.engine.v0, false);\n\n    /* remove the PID file if we're a daemon */\n    if (do_daemonize)\n        remove_pidfile(pid_file);\n    /* Clean up strdup() call for bind() address */\n    if (settings.inter)\n      free(settings.inter);\n\n    return EXIT_SUCCESS;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/memcache/extra/memcached/utilities/engine_loader.c": "/* -*- Mode: C; tab-width: 4; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n#include \"config.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include \"utilities/engine_loader.h\"\n#include <memcached/types.h>\n\nstatic const char * const feature_descriptions[] = {\n    \"compare and swap\",\n    \"persistent storage\",\n    \"secondary engine\",\n    \"access control\",\n    \"multi tenancy\",\n    \"LRU\"\n};\n\nvoid *handle = NULL;\n\nbool load_engine(const char *soname,\n                 SERVER_HANDLE_V1 *(*get_server_api)(void),\n                 EXTENSION_LOGGER_DESCRIPTOR *logger,\n                 ENGINE_HANDLE **engine_handle)\n{\n    ENGINE_HANDLE *engine = NULL;\n    /* Hack to remove the warning from C99 */\n    union my_hack {\n        CREATE_INSTANCE create;\n        void* voidptr;\n    } my_create = {.create = NULL };\n\n    handle = dlopen(soname, RTLD_NOW | RTLD_LOCAL);\n    if (handle == NULL) {\n        const char *msg = dlerror();\n        logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"Failed to open library \\\"%s\\\": %s\\n\",\n                soname ? soname : \"self\",\n                msg ? msg : \"unknown error\");\n        return false;\n    }\n\n    void *symbol = dlsym(handle, \"create_instance\");\n    if (symbol == NULL) {\n        logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"Could not find symbol \\\"create_instance\\\" in %s: %s\\n\",\n                soname ? soname : \"self\",\n                dlerror());\n        return false;\n    }\n    my_create.voidptr = symbol;\n\n    /* request a instance with protocol version 1 */\n    ENGINE_ERROR_CODE error = (*my_create.create)(1, get_server_api, &engine);\n\n    if (error != ENGINE_SUCCESS || engine == NULL) {\n        logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"Failed to create instance. Error code: %d\\n\", error);\n        dlclose(handle);\n        return false;\n    }\n    *engine_handle = engine;\n    return true;\n}\n\nbool init_engine(ENGINE_HANDLE * engine,\n                 const char *config_str,\n                 EXTENSION_LOGGER_DESCRIPTOR *logger)\n{\n    ENGINE_HANDLE_V1 *engine_v1 = NULL;\n\n    if (handle == NULL) {\n        logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"Failed to initialize engine, engine must fist be loaded.\");\n        return false;\n    }\n\n    if (engine->interface == 1) {\n        engine_v1 = (ENGINE_HANDLE_V1*)engine;\n\n        // validate that the required engine interface is implemented:\n        if (engine_v1->get_info == NULL || engine_v1->initialize == NULL ||\n            engine_v1->destroy == NULL || engine_v1->allocate == NULL ||\n            engine_v1->remove == NULL || engine_v1->release == NULL ||\n            engine_v1->get == NULL || engine_v1->store == NULL ||\n            engine_v1->flush == NULL ||\n            engine_v1->get_stats == NULL || engine_v1->reset_stats == NULL ||\n            engine_v1->item_set_cas == NULL ||\n            engine_v1->get_item_info == NULL)\n        {\n            logger->log(EXTENSION_LOG_WARNING, NULL,\n                        \"Failed to initialize engine; it does not implement the engine interface.\");\n            return false;\n        }\n\n        ENGINE_ERROR_CODE error = engine_v1->initialize(engine,config_str);\n        if (error != ENGINE_SUCCESS) {\n            engine_v1->destroy(engine, false);\n            logger->log(EXTENSION_LOG_WARNING, NULL,\n                    \"Failed to initialize instance. Error code: %d\\n\",\n                    error);\n            dlclose(handle);\n            return false;\n        }\n    } else {\n        logger->log(EXTENSION_LOG_WARNING, NULL,\n                 \"Unsupported interface level\\n\");\n        dlclose(handle);\n        return false;\n    }\n    return true;\n}\n\nvoid log_engine_details(ENGINE_HANDLE * engine,\n                        EXTENSION_LOGGER_DESCRIPTOR *logger)\n{\n    ENGINE_HANDLE_V1 *engine_v1 = (ENGINE_HANDLE_V1*)engine;\n    const engine_info *info;\n    info = engine_v1->get_info(engine);\n    if (info) {\n        char message[4096];\n        ssize_t nw = snprintf(message, sizeof(message), \"Loaded engine: %s\\n\",\n                                        info->description ?\n                                        info->description : \"Unknown\");\n        if (nw == -1) {\n            return;\n        }\n        ssize_t offset = nw;\n        bool comma = false;\n\n        if (info->num_features > 0) {\n            nw = snprintf(message + offset, sizeof(message) - offset,\n                          \"Supplying the following features: \");\n            if (nw == -1) {\n                return;\n            }\n            offset += nw;\n            for (int ii = 0; ii < info->num_features; ++ii) {\n                if (info->features[ii].description != NULL) {\n                    nw = snprintf(message + offset, sizeof(message) - offset,\n                                  \"%s%s\", comma ? \", \" : \"\",\n                                  info->features[ii].description);\n                } else {\n                    if (info->features[ii].feature <= LAST_REGISTERED_ENGINE_FEATURE) {\n                        nw = snprintf(message + offset, sizeof(message) - offset,\n                                      \"%s%s\", comma ? \", \" : \"\",\n                                      feature_descriptions[info->features[ii].feature]);\n                    } else {\n                        nw = snprintf(message + offset, sizeof(message) - offset,\n                                      \"%sUnknown feature: %d\", comma ? \", \" : \"\",\n                                      info->features[ii].feature);\n                    }\n                }\n                comma = true;\n                if (nw == -1) {\n                    return;\n                }\n                offset += nw;\n            }\n        }\n        logger->log(EXTENSION_LOG_INFO, NULL, \"%s\\n\", message);\n    } else {\n        logger->log(EXTENSION_LOG_INFO, NULL,\n                                        \"Loaded engine: Unknown\\n\");\n    }\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/memcache/extra/memcached/programs/engine_testapp.c": "/* -*- Mode: C; tab-width: 4; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n#include \"config.h\"\n#include <assert.h>\n#include <dlfcn.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <signal.h>\n#include <pthread.h>\n#include \"utilities/engine_loader.h\"\n#include <memcached/engine_testapp.h>\n#include <memcached/extension_loggers.h>\n#include <mock_server.h>\n\nstruct mock_engine {\n    ENGINE_HANDLE_V1 me;\n    ENGINE_HANDLE_V1 *the_engine;\n    TAP_ITERATOR iterator;\n};\n\n#ifndef WIN32\nstatic sig_atomic_t alarmed;\n\nstatic void alarm_handler(int sig) {\n    alarmed = 1;\n}\n#endif\n\nstatic inline struct mock_engine* get_handle(ENGINE_HANDLE* handle) {\n    return (struct mock_engine*)handle;\n}\n\nstatic tap_event_t mock_tap_iterator(ENGINE_HANDLE* handle,\n                                     const void *cookie, item **itm,\n                                     void **es, uint16_t *nes, uint8_t *ttl,\n                                     uint16_t *flags, uint32_t *seqno,\n                                     uint16_t *vbucket) {\n   struct mock_engine *me = get_handle(handle);\n   return me->iterator((ENGINE_HANDLE*)me->the_engine, cookie, itm, es, nes,\n                       ttl, flags, seqno, vbucket);\n}\n\nstatic const engine_info* mock_get_info(ENGINE_HANDLE* handle) {\n    struct mock_engine *me = get_handle(handle);\n    return me->the_engine->get_info((ENGINE_HANDLE*)me->the_engine);\n}\n\nstatic ENGINE_ERROR_CODE mock_initialize(ENGINE_HANDLE* handle,\n                                         const char* config_str) {\n    struct mock_engine *me = get_handle(handle);\n    return me->the_engine->initialize((ENGINE_HANDLE*)me->the_engine, config_str);\n}\n\nstatic void mock_destroy(ENGINE_HANDLE* handle, const bool force) {\n    struct mock_engine *me = get_handle(handle);\n    me->the_engine->destroy((ENGINE_HANDLE*)me->the_engine, force);\n}\n\nstatic ENGINE_ERROR_CODE mock_allocate(ENGINE_HANDLE* handle,\n                                       const void* cookie,\n                                       item **item,\n                                       const void* key,\n                                       const size_t nkey,\n                                       const size_t nbytes,\n                                       const int flags,\n                                       const rel_time_t exptime) {\n    struct mock_engine *me = get_handle(handle);\n    struct mock_connstruct *c = (void*)cookie;\n    if (c == NULL) {\n        c = (void*)create_mock_cookie();\n    }\n\n    c->nblocks = 0;\n    ENGINE_ERROR_CODE ret = ENGINE_SUCCESS;\n    pthread_mutex_lock(&c->mutex);\n    while (ret == ENGINE_SUCCESS &&\n           (ret = me->the_engine->allocate((ENGINE_HANDLE*)me->the_engine, c,\n                                           item, key, nkey,\n                                           nbytes, flags,\n                                           exptime)) == ENGINE_EWOULDBLOCK &&\n           c->handle_ewouldblock)\n    {\n        ++c->nblocks;\n        pthread_cond_wait(&c->cond, &c->mutex);\n        ret = c->status;\n    }\n    pthread_mutex_unlock(&c->mutex);\n\n    if (c != cookie) {\n        destroy_mock_cookie(c);\n    }\n\n    return ret;\n}\n\nstatic ENGINE_ERROR_CODE mock_remove(ENGINE_HANDLE* handle,\n                                     const void* cookie,\n                                     const void* key,\n                                     const size_t nkey,\n                                     uint64_t cas,\n                                     uint16_t vbucket)\n{\n    struct mock_engine *me = get_handle(handle);\n    struct mock_connstruct *c = (void*)cookie;\n    if (c == NULL) {\n        c = (void*)create_mock_cookie();\n    }\n\n    c->nblocks = 0;\n    ENGINE_ERROR_CODE ret = ENGINE_SUCCESS;\n    pthread_mutex_lock(&c->mutex);\n    while (ret == ENGINE_SUCCESS &&\n           (ret = me->the_engine->remove((ENGINE_HANDLE*)me->the_engine, c, key,\n                                         nkey, cas, vbucket)) == ENGINE_EWOULDBLOCK &&\n           c->handle_ewouldblock)\n    {\n        ++c->nblocks;\n        pthread_cond_wait(&c->cond, &c->mutex);\n        ret = c->status;\n    }\n    pthread_mutex_unlock(&c->mutex);\n\n    if (c != cookie) {\n        destroy_mock_cookie(c);\n    }\n\n    return ret;\n}\n\nstatic void mock_release(ENGINE_HANDLE* handle,\n                         const void *cookie,\n                         item* item) {\n    struct mock_engine *me = get_handle(handle);\n    me->the_engine->release((ENGINE_HANDLE*)me->the_engine, cookie, item);\n}\n\nstatic ENGINE_ERROR_CODE mock_get(ENGINE_HANDLE* handle,\n                                  const void* cookie,\n                                  item** item,\n                                  const void* key,\n                                  const int nkey,\n                                  uint16_t vbucket) {\n    struct mock_engine *me = get_handle(handle);\n    struct mock_connstruct *c = (void*)cookie;\n    if (c == NULL) {\n        c = (void*)create_mock_cookie();\n    }\n\n    c->nblocks = 0;\n    ENGINE_ERROR_CODE ret = ENGINE_SUCCESS;\n    pthread_mutex_lock(&c->mutex);\n    while (ret == ENGINE_SUCCESS &&\n           (ret = me->the_engine->get((ENGINE_HANDLE*)me->the_engine, c, item,\n                                      key, nkey, vbucket)) == ENGINE_EWOULDBLOCK &&\n           c->handle_ewouldblock)\n    {\n        ++c->nblocks;\n        pthread_cond_wait(&c->cond, &c->mutex);\n        ret = c->status;\n    }\n    pthread_mutex_unlock(&c->mutex);\n\n    if (c != cookie) {\n        destroy_mock_cookie(c);\n    }\n\n    return ret;\n}\n\nstatic ENGINE_ERROR_CODE mock_get_stats(ENGINE_HANDLE* handle,\n                                        const void* cookie,\n                                        const char* stat_key,\n                                        int nkey,\n                                        ADD_STAT add_stat)\n{\n    struct mock_engine *me = get_handle(handle);\n    struct mock_connstruct *c = (void*)cookie;\n    if (c == NULL) {\n        c = (void*)create_mock_cookie();\n    }\n\n    c->nblocks = 0;\n    ENGINE_ERROR_CODE ret = ENGINE_SUCCESS;\n    pthread_mutex_lock(&c->mutex);\n    while (ret == ENGINE_SUCCESS &&\n           (ret = me->the_engine->get_stats((ENGINE_HANDLE*)me->the_engine, c, stat_key,\n                                            nkey, add_stat)) == ENGINE_EWOULDBLOCK &&\n           c->handle_ewouldblock)\n    {\n        ++c->nblocks;\n        pthread_cond_wait(&c->cond, &c->mutex);\n        ret = c->status;\n    }\n    pthread_mutex_unlock(&c->mutex);\n\n    if (c != cookie) {\n        destroy_mock_cookie(c);\n    }\n\n    return ret;\n}\n\nstatic ENGINE_ERROR_CODE mock_store(ENGINE_HANDLE* handle,\n                                    const void *cookie,\n                                    item* item,\n                                    uint64_t *cas,\n                                    ENGINE_STORE_OPERATION operation,\n                                    uint16_t vbucket) {\n    struct mock_engine *me = get_handle(handle);\n    struct mock_connstruct *c = (void*)cookie;\n    if (c == NULL) {\n        c = (void*)create_mock_cookie();\n    }\n\n    c->nblocks = 0;\n    ENGINE_ERROR_CODE ret = ENGINE_SUCCESS;\n    pthread_mutex_lock(&c->mutex);\n    while (ret == ENGINE_SUCCESS &&\n           (ret = me->the_engine->store((ENGINE_HANDLE*)me->the_engine, c, item, cas,\n                                        operation, vbucket)) == ENGINE_EWOULDBLOCK &&\n           c->handle_ewouldblock)\n    {\n        ++c->nblocks;\n        pthread_cond_wait(&c->cond, &c->mutex);\n        ret = c->status;\n    }\n    pthread_mutex_unlock(&c->mutex);\n\n    if (c != cookie) {\n        destroy_mock_cookie(c);\n    }\n\n    return ret;\n}\n\nstatic ENGINE_ERROR_CODE mock_arithmetic(ENGINE_HANDLE* handle,\n                                         const void* cookie,\n                                         const void* key,\n                                         const int nkey,\n                                         const bool increment,\n                                         const bool create,\n                                         const uint64_t delta,\n                                         const uint64_t initial,\n                                         const rel_time_t exptime,\n                                         uint64_t *cas,\n                                         uint64_t *result,\n                                         uint16_t vbucket) {\n    struct mock_engine *me = get_handle(handle);\n    struct mock_connstruct *c = (void*)cookie;\n    if (c == NULL) {\n        c = (void*)create_mock_cookie();\n    }\n\n    c->nblocks = 0;\n    ENGINE_ERROR_CODE ret = ENGINE_SUCCESS;\n    pthread_mutex_lock(&c->mutex);\n    while (ret == ENGINE_SUCCESS &&\n           (ret = me->the_engine->arithmetic((ENGINE_HANDLE*)me->the_engine, c, key,\n                                             nkey, increment, create,\n                                             delta, initial, exptime,\n                                             cas, result, vbucket)) == ENGINE_EWOULDBLOCK &&\n           c->handle_ewouldblock)\n    {\n        ++c->nblocks;\n        pthread_cond_wait(&c->cond, &c->mutex);\n        ret = c->status;\n    }\n    pthread_mutex_unlock(&c->mutex);\n\n    if (c != cookie) {\n        destroy_mock_cookie(c);\n    }\n\n    return ret;\n}\n\nstatic ENGINE_ERROR_CODE mock_flush(ENGINE_HANDLE* handle,\n                                    const void* cookie, time_t when) {\n    struct mock_engine *me = get_handle(handle);\n    struct mock_connstruct *c = (void*)cookie;\n    if (c == NULL) {\n        c = (void*)create_mock_cookie();\n    }\n\n    c->nblocks = 0;\n    ENGINE_ERROR_CODE ret = ENGINE_SUCCESS;\n    pthread_mutex_lock(&c->mutex);\n    while (ret == ENGINE_SUCCESS &&\n           (ret = me->the_engine->flush((ENGINE_HANDLE*)me->the_engine, c, when)) == ENGINE_EWOULDBLOCK &&\n           c->handle_ewouldblock)\n    {\n        ++c->nblocks;\n        pthread_cond_wait(&c->cond, &c->mutex);\n        ret = c->status;\n    }\n    pthread_mutex_unlock(&c->mutex);\n\n    if (c != cookie) {\n        destroy_mock_cookie(c);\n    }\n\n    return ret;\n}\n\nstatic void mock_reset_stats(ENGINE_HANDLE* handle, const void *cookie) {\n    struct mock_engine *me = get_handle(handle);\n    me->the_engine->reset_stats((ENGINE_HANDLE*)me->the_engine, cookie);\n}\n\nstatic ENGINE_ERROR_CODE mock_unknown_command(ENGINE_HANDLE* handle,\n                                              const void* cookie,\n                                              protocol_binary_request_header *request,\n                                              ADD_RESPONSE response)\n{\n    struct mock_engine *me = get_handle(handle);\n    struct mock_connstruct *c = (void*)cookie;\n    if (c == NULL) {\n        c = (void*)create_mock_cookie();\n    }\n\n    c->nblocks = 0;\n    ENGINE_ERROR_CODE ret = ENGINE_SUCCESS;\n    pthread_mutex_lock(&c->mutex);\n    while (ret == ENGINE_SUCCESS &&\n           (ret = me->the_engine->unknown_command((ENGINE_HANDLE*)me->the_engine, c,\n                                                  request, response)) == ENGINE_EWOULDBLOCK &&\n           c->handle_ewouldblock)\n    {\n        ++c->nblocks;\n        pthread_cond_wait(&c->cond, &c->mutex);\n        ret = c->status;\n    }\n    pthread_mutex_unlock(&c->mutex);\n\n    if (c != cookie) {\n        destroy_mock_cookie(c);\n    }\n\n    return ret;\n}\n\nstatic void mock_item_set_cas(ENGINE_HANDLE *handle, const void *cookie,\n                              item* item, uint64_t val)\n{\n    struct mock_engine *me = get_handle(handle);\n    me->the_engine->item_set_cas((ENGINE_HANDLE*)me->the_engine, cookie, item, val);\n}\n\n\nstatic bool mock_get_item_info(ENGINE_HANDLE *handle, const void *cookie,\n                               const item* item, item_info *item_info)\n{\n    struct mock_engine *me = get_handle(handle);\n    return me->the_engine->get_item_info((ENGINE_HANDLE*)me->the_engine,\n                                         cookie, item, item_info);\n}\n\nstatic void *mock_get_stats_struct(ENGINE_HANDLE* handle, const void* cookie)\n{\n    struct mock_engine *me = get_handle(handle);\n    return me->the_engine->get_stats_struct((ENGINE_HANDLE*)me->the_engine, cookie);\n}\n\nstatic ENGINE_ERROR_CODE mock_aggregate_stats(ENGINE_HANDLE* handle,\n                                              const void* cookie,\n                                              void (*callback)(void*, void*),\n                                              void *vptr)\n{\n    struct mock_engine *me = get_handle(handle);\n    struct mock_connstruct *c = (void*)cookie;\n    if (c == NULL) {\n        c = (void*)create_mock_cookie();\n    }\n\n    c->nblocks = 0;\n    ENGINE_ERROR_CODE ret = ENGINE_SUCCESS;\n    pthread_mutex_lock(&c->mutex);\n    while (ret == ENGINE_SUCCESS &&\n           (ret = me->the_engine->aggregate_stats((ENGINE_HANDLE*)me->the_engine, c,\n                                                  callback, vptr)) == ENGINE_EWOULDBLOCK &&\n           c->handle_ewouldblock)\n    {\n        ++c->nblocks;\n        pthread_cond_wait(&c->cond, &c->mutex);\n        ret = c->status;\n    }\n    pthread_mutex_unlock(&c->mutex);\n\n    if (c != cookie) {\n        destroy_mock_cookie(c);\n    }\n\n    return ret;\n}\n\nstatic ENGINE_ERROR_CODE mock_tap_notify(ENGINE_HANDLE* handle,\n                                        const void *cookie,\n                                        void *engine_specific,\n                                        uint16_t nengine,\n                                        uint8_t ttl,\n                                        uint16_t tap_flags,\n                                        tap_event_t tap_event,\n                                        uint32_t tap_seqno,\n                                        const void *key,\n                                        size_t nkey,\n                                        uint32_t flags,\n                                        uint32_t exptime,\n                                        uint64_t cas,\n                                        const void *data,\n                                        size_t ndata,\n                                         uint16_t vbucket) {\n\n    struct mock_engine *me = get_handle(handle);\n    struct mock_connstruct *c = (void*)cookie;\n    if (c == NULL) {\n        c = (void*)create_mock_cookie();\n    }\n\n    c->nblocks = 0;\n    ENGINE_ERROR_CODE ret = ENGINE_SUCCESS;\n    pthread_mutex_lock(&c->mutex);\n    while (ret == ENGINE_SUCCESS &&\n           (ret = me->the_engine->tap_notify((ENGINE_HANDLE*)me->the_engine, c,\n                                             engine_specific, nengine, ttl, tap_flags,\n                                             tap_event, tap_seqno, key, nkey, flags,\n                                             exptime, cas, data, ndata, vbucket)) == ENGINE_EWOULDBLOCK &&\n           c->handle_ewouldblock)\n    {\n        ++c->nblocks;\n        pthread_cond_wait(&c->cond, &c->mutex);\n        ret = c->status;\n    }\n    pthread_mutex_unlock(&c->mutex);\n\n    if (c != cookie) {\n        destroy_mock_cookie(c);\n    }\n\n    return ret;\n}\n\n\nstatic TAP_ITERATOR mock_get_tap_iterator(ENGINE_HANDLE* handle, const void* cookie,\n                                           const void* client, size_t nclient,\n                                           uint32_t flags,\n                                           const void* userdata, size_t nuserdata) {\n    struct mock_engine *me = get_handle(handle);\n    me->iterator = me->the_engine->get_tap_iterator((ENGINE_HANDLE*)me->the_engine, cookie,\n                                                    client, nclient, flags, userdata, nuserdata);\n    return (me->iterator != NULL) ? mock_tap_iterator : NULL;\n}\n\nstatic size_t mock_errinfo(ENGINE_HANDLE *handle, const void* cookie,\n                           char *buffer, size_t buffsz) {\n    struct mock_engine *me = get_handle(handle);\n    return me->the_engine->errinfo((ENGINE_HANDLE*)me->the_engine, cookie,\n                                   buffer, buffsz);\n}\n\n\nstruct mock_engine default_mock_engine = {\n    .me = {\n        .interface = {\n            .interface = 1\n        },\n        .get_info = mock_get_info,\n        .initialize = mock_initialize,\n        .destroy = mock_destroy,\n        .allocate = mock_allocate,\n        .remove = mock_remove,\n        .release = mock_release,\n        .get = mock_get,\n        .store = mock_store,\n        .arithmetic = mock_arithmetic,\n        .flush = mock_flush,\n        .get_stats = mock_get_stats,\n        .reset_stats = mock_reset_stats,\n        .get_stats_struct = mock_get_stats_struct,\n        .aggregate_stats = mock_aggregate_stats,\n        .unknown_command = mock_unknown_command,\n        .tap_notify = mock_tap_notify,\n        .get_tap_iterator = mock_get_tap_iterator,\n        .item_set_cas = mock_item_set_cas,\n        .get_item_info = mock_get_item_info,\n        .errinfo = mock_errinfo\n    }\n};\nstruct mock_engine mock_engine;\n\nEXTENSION_LOGGER_DESCRIPTOR *logger_descriptor = NULL;\nstatic ENGINE_HANDLE *handle = NULL;\nstatic ENGINE_HANDLE_V1 *handle_v1 = NULL;\n\nstatic void usage(void) {\n    printf(\"\\n\");\n    printf(\"engine_testapp -E <path_to_engine_lib> -T <path_to_testlib>\\n\");\n    printf(\"               [-e <engine_config>] [-h]\\n\");\n    printf(\"\\n\");\n    printf(\"-E <path_to_engine_lib>      Path to the engine library file. The\\n\");\n    printf(\"                             engine library file is a library file\\n\");\n    printf(\"                             (.so or .dll) that the contains the \\n\");\n    printf(\"                             implementation of the engine being\\n\");\n    printf(\"                             tested.\\n\");\n    printf(\"\\n\");\n    printf(\"-T <path_to_testlib>         Path to the test library file. The test\\n\");\n    printf(\"                             library file is a library file (.so or\\n\");\n    printf(\"                             .dll) that contains the set of tests\\n\");\n    printf(\"                             to be executed.\\n\");\n    printf(\"\\n\");\n    printf(\"-t <timeout>                 Maximum time to run a test.\\n\");\n    printf(\"-e <engine_config>           Engine configuration string passed to\\n\");\n    printf(\"                             the engine.\\n\");\n    printf(\"-q                           Only print errors.\");\n    printf(\"-.                           Print a . for each executed test.\");\n    printf(\"\\n\");\n    printf(\"-h                           Prints this usage text.\\n\");\n    printf(\"\\n\");\n}\n\nstatic int report_test(const char *name, enum test_result r, bool quiet) {\n    int rc = 0;\n    char *msg = NULL;\n    bool color_enabled = getenv(\"TESTAPP_ENABLE_COLOR\") != NULL;\n    int color = 0;\n    char color_str[8] = { 0 };\n    char *reset_color = \"\\033[m\";\n    switch(r) {\n    case SUCCESS:\n        msg=\"OK\";\n        color = 32;\n        break;\n    case SKIPPED:\n        msg=\"SKIPPED\";\n        color = 32;\n        break;\n    case FAIL:\n        color = 31;\n        msg=\"FAIL\";\n        rc = 1;\n        break;\n    case DIED:\n        color = 31;\n        msg = \"DIED\";\n        rc = 1;\n        break;\n    case TIMEOUT:\n        color = 31;\n        msg = \"TIMED OUT\";\n        rc = 1;\n        break;\n    case CORE:\n        color = 31;\n        msg = \"CORE DUMPED\";\n        rc = 1;\n        break;\n    case PENDING:\n        color = 33;\n        msg = \"PENDING\";\n        break;\n    }\n    assert(msg);\n    if (color_enabled) {\n        snprintf(color_str, sizeof(color_str), \"\\033[%dm\", color);\n    }\n    if (quiet) {\n        if (r != SUCCESS) {\n            printf(\"%s:  %s%s%s\\n\", name, color_str, msg,\n                   color_enabled ? reset_color : \"\");\n            fflush(stdout);\n        }\n    } else {\n        printf(\"%s%s%s\\n\", color_str, msg, color_enabled ? reset_color : \"\");\n    }\n    return rc;\n}\n\nstatic ENGINE_HANDLE_V1 *start_your_engines(const char *engine, const char* cfg, bool engine_init) {\n\n    init_mock_server(handle);\n    if (!load_engine(engine, &get_mock_server_api, logger_descriptor, &handle)) {\n        fprintf(stderr, \"Failed to load engine %s.\\n\", engine);\n        return NULL;\n    }\n\n    if (engine_init) {\n        if(!init_engine(handle, cfg, logger_descriptor)) {\n            fprintf(stderr, \"Failed to init engine %s with config %s.\\n\", engine, cfg);\n            return NULL;\n        }\n    }\n\n    mock_engine = default_mock_engine;\n    handle_v1 = mock_engine.the_engine = (ENGINE_HANDLE_V1*)handle;\n    handle = (ENGINE_HANDLE*)&mock_engine.me;\n    handle_v1 = &mock_engine.me;\n\n    // Reset all members that aren't set (to allow the users to write\n    // testcases to verify that they initialize them..\n    assert(mock_engine.me.interface.interface == mock_engine.the_engine->interface.interface);\n\n    if (mock_engine.the_engine->get_stats_struct == NULL) {\n        mock_engine.me.get_stats_struct = NULL;\n    }\n    if (mock_engine.the_engine->aggregate_stats == NULL) {\n        mock_engine.me.aggregate_stats = NULL;\n    }\n    if (mock_engine.the_engine->unknown_command == NULL) {\n        mock_engine.me.unknown_command = NULL;\n    }\n    if (mock_engine.the_engine->tap_notify == NULL) {\n        mock_engine.me.tap_notify = NULL;\n    }\n    if (mock_engine.the_engine->get_tap_iterator == NULL) {\n        mock_engine.me.get_tap_iterator = NULL;\n    }\n    if (mock_engine.the_engine->errinfo == NULL) {\n        mock_engine.me.errinfo = NULL;\n    }\n\n    return &mock_engine.me;\n}\n\nstatic void destroy_engine(bool force) {\n    if (handle_v1) {\n        handle_v1->destroy(handle, force);\n        handle_v1 = NULL;\n        handle = NULL;\n    }\n}\n\nstatic void reload_engine(ENGINE_HANDLE **h, ENGINE_HANDLE_V1 **h1,\n                          const char* engine, const char *cfg, bool init, bool force) {\n    destroy_engine(force);\n    handle_v1 = start_your_engines(engine, cfg, init);\n    handle = (ENGINE_HANDLE*)(handle_v1);\n    *h1 = handle_v1;\n    *h = handle;\n}\n\nstatic engine_test_t* current_testcase;\n\nstatic const engine_test_t* get_current_testcase(void)\n{\n    return current_testcase;\n}\n\n\nstatic enum test_result run_test(engine_test_t test, const char *engine, const char *default_cfg) {\n    enum test_result ret = PENDING;\n    if (test.tfun != NULL) {\n#if !defined(USE_GCOV) && !defined(WIN32)\n        pid_t pid = fork();\n        if (pid == 0) {\n#endif\n            current_testcase = &test;\n            if (test.prepare != NULL) {\n                if ((ret = test.prepare(&test)) == SUCCESS) {\n                    ret = PENDING;\n                }\n            }\n\n            if (ret == PENDING) {\n                /* Start the engines and go */\n                start_your_engines(engine, test.cfg ? test.cfg : default_cfg, true);\n                if (test.test_setup != NULL) {\n                    if (!test.test_setup(handle, handle_v1)) {\n                        fprintf(stderr, \"Failed to run setup for test %s\\n\", test.name);\n#if !defined(USE_GCOV) && !defined(WIN32)\n                        exit((int)ret);\n#else\n                        return FAIL;\n#endif\n                    }\n                }\n                ret = test.tfun(handle, handle_v1);\n                if (test.test_teardown != NULL) {\n                    if (!test.test_teardown(handle, handle_v1)) {\n                        fprintf(stderr, \"WARNING: Failed to run teardown for test %s\\n\", test.name);\n                    }\n                }\n                destroy_engine(false);\n\n                if (test.cleanup) {\n                    test.cleanup(&test, ret);\n                }\n            }\n#if !defined(USE_GCOV) && !defined(WIN32)\n            exit((int)ret);\n        } else if (pid == (pid_t)-1) {\n            ret = FAIL;\n        } else {\n            int rc;\n            while (alarmed == 0 && waitpid(pid, &rc, 0) == (pid_t)-1) {\n                if (errno != EINTR) {\n                    abort();\n                }\n            }\n\n            if (alarmed) {\n                kill(pid, 9);\n                ret = TIMEOUT;\n            } else if (WIFEXITED(rc)) {\n                ret = (enum test_result)WEXITSTATUS(rc);\n            } else if (WIFSIGNALED(rc) && WCOREDUMP(rc)) {\n                ret = CORE;\n            } else {\n                ret = DIED;\n            }\n        }\n#endif\n    }\n\n    return ret;\n}\n\nstatic void setup_alarm_handler() {\n#ifndef WIN32\n    struct sigaction sig_handler;\n\n    sig_handler.sa_handler = alarm_handler;\n    sig_handler.sa_flags = 0;\n\n    sigaction(SIGALRM, &sig_handler, NULL);\n#endif\n}\n\nstatic void set_test_timeout(int timeout) {\n#ifndef WIN32\n    alarm(timeout);\n#endif\n}\n\nstatic void clear_test_timeout() {\n#ifndef WIN32\n    alarm(0);\n    alarmed = 0;\n#endif\n}\n\nint main(int argc, char **argv) {\n    int c, exitcode = 0, num_cases = 0, timeout = 0;\n    bool quiet = false;\n    bool dot = false;\n    const char *engine = NULL;\n    const char *engine_args = NULL;\n    const char *test_suite = NULL;\n    const char *test_case = NULL;\n    engine_test_t *testcases = NULL;\n    logger_descriptor = get_null_logger();\n\n    /* Hack to remove the warning from C99 */\n    union {\n        GET_TESTS get_tests;\n        void* voidptr;\n    } my_get_test = {.get_tests = NULL };\n\n    /* Hack to remove the warning from C99 */\n    union {\n        SETUP_SUITE setup_suite;\n        void* voidptr;\n    } my_setup_suite = {.setup_suite = NULL };\n\n    /* Hack to remove the warning from C99 */\n    union {\n        TEARDOWN_SUITE teardown_suite;\n        void* voidptr;\n    } my_teardown_suite = {.teardown_suite = NULL };\n\n\n    /* Use unbuffered stdio */\n    setbuf(stdout, NULL);\n    setbuf(stderr, NULL);\n\n    setup_alarm_handler();\n\n    /* process arguments */\n    while (-1 != (c = getopt(argc, argv,\n          \"h\"  /* usage */\n          \"E:\" /* Engine to load */\n          \"e:\" /* Engine options */\n          \"T:\" /* Library with tests to load */\n          \"t:\" /* Timeout */\n          \"q\"  /* Be more quiet (only report failures) */\n          \".\"  /* dot mode. */\n          \"n:\"  /* test case to run */\n        ))) {\n        switch (c) {\n        case 'E':\n            engine = optarg;\n            break;\n        case 'e':\n            engine_args = optarg;\n            break;\n        case 'h':\n            usage();\n            return 0;\n        case 'T':\n            test_suite = optarg;\n            break;\n        case 't':\n            timeout = atoi(optarg);\n            break;\n        case 'n':\n            test_case = optarg;\n            break;\n        case 'q':\n            quiet = true;\n            break;\n        case '.':\n            dot = true;\n            break;\n        default:\n            fprintf(stderr, \"Illegal argument \\\"%c\\\"\\n\", c);\n            return 1;\n        }\n    }\n\n    //validate args\n    if (engine == NULL) {\n        fprintf(stderr, \"You must provide a path to the storage engine library.\\n\");\n        return 1;\n    }\n\n    if (test_suite == NULL) {\n        fprintf(stderr, \"You must provide a path to the testsuite library.\\n\");\n        return 1;\n    }\n\n    //load test_suite\n    void* handle = dlopen(test_suite, RTLD_NOW | RTLD_LOCAL);\n    if (handle == NULL) {\n        const char *msg = dlerror();\n        fprintf(stderr, \"Failed to load testsuite %s: %s\\n\", test_suite, msg ? msg : \"unknown error\");\n        return 1;\n    }\n\n    //get the test cases\n    void *symbol = dlsym(handle, \"get_tests\");\n    if (symbol == NULL) {\n        const char *msg = dlerror();\n        fprintf(stderr, \"Could not find get_tests function in testsuite %s: %s\\n\", test_suite, msg ? msg : \"unknown error\");\n        return 1;\n    }\n    my_get_test.voidptr = symbol;\n    testcases = (*my_get_test.get_tests)();\n\n    //set up the suite if needed\n    struct test_harness harness = { .default_engine_cfg = engine_args,\n                                    .engine_path = engine,\n                                    .reload_engine = reload_engine,\n                                    .start_engine = start_your_engines,\n                                    .create_cookie = create_mock_cookie,\n                                    .destroy_cookie = destroy_mock_cookie,\n                                    .set_ewouldblock_handling = mock_set_ewouldblock_handling,\n                                    .lock_cookie = lock_mock_cookie,\n                                    .unlock_cookie = unlock_mock_cookie,\n                                    .waitfor_cookie = waitfor_mock_cookie,\n                                    .time_travel = mock_time_travel,\n                                    .get_current_testcase = get_current_testcase };\n    symbol = dlsym(handle, \"setup_suite\");\n    if (symbol != NULL) {\n        my_setup_suite.voidptr = symbol;\n        if (!(*my_setup_suite.setup_suite)(&harness)) {\n            fprintf(stderr, \"Failed to set up test suite %s \\n\", test_suite);\n            return 1;\n        }\n    }\n\n\n    for (num_cases = 0; testcases[num_cases].name; num_cases++) {\n        /* Just counting */\n    }\n\n    if (!quiet) {\n        printf(\"1..%d\\n\", num_cases);\n    }\n\n    int i;\n    bool need_newline = false;\n    for (i = 0; testcases[i].name; i++) {\n        if (test_case != NULL && strcmp(test_case, testcases[i].name) != 0)\n            continue;\n        if (!quiet) {\n            printf(\"Running %s... \", testcases[i].name);\n            fflush(stdout);\n        } else if(dot) {\n            printf(\".\");\n            need_newline = true;\n            /* Add a newline every few tests */\n            if ((i+1) % 70 == 0) {\n                printf(\"\\n\");\n                need_newline = false;\n            }\n        }\n        set_test_timeout(timeout);\n        exitcode += report_test(testcases[i].name,\n                                run_test(testcases[i], engine, engine_args),\n                                quiet);\n        clear_test_timeout();\n    }\n\n    if (need_newline) {\n        printf(\"\\n\");\n    }\n\n    //tear down the suite if needed\n    symbol = dlsym(handle, \"teardown_suite\");\n    if (symbol != NULL) {\n        my_teardown_suite.voidptr = symbol;\n        if (!(*my_teardown_suite.teardown_suite)()) {\n            fprintf(stderr, \"Failed to teardown up test suite %s \\n\", test_suite);\n        }\n    }\n\n    printf(\"# Passed %d of %d tests\\n\", num_cases - exitcode, num_cases);\n\n    return exitcode;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/memcache/extra/memcached/win32/dlfcn.h": "#ifndef DLFCN_H\n#define DLFCN_H\nvoid* dlopen(const char* path, int mode);\nvoid* dlsym(void* handle, const char* symbol);\nint dlclose(void* handle);\nconst char *dlerror(void);\n\n#define RTLD_LAZY 1\n#define RTLD_LOCAL 2\n\n#define RTLD_NOW 0x00002\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/memcache/extra/memcached/win32/dlfcn.c": "/* -*- Mode: C; tab-width: 4; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n#include <stdio.h>\n#include <windows.h>\n#include <dlfcn.h>\n#include <stdbool.h>\n\n/*\n * Keep track if the user tried to call dlopen(NULL, xx) to be able to give a sane\n * error message\n */\nstatic bool self = false;\n\nvoid* dlopen(const char* path, int mode) {\n    if (path == NULL) {\n        // We don't support opening ourself\n        self = true;\n        return NULL;\n    }\n\n    void* handle = LoadLibrary(path);\n    if (handle == NULL) {\n        char *buf = malloc(strlen(path) + 20);\n        sprintf(buf, \"%s.dll\", path);\n        handle = LoadLibrary(buf);\n        free(buf);\n    }\n\n    return handle;\n}\n\nvoid* dlsym(void* handle, const char* symbol) {\n    return GetProcAddress(handle, symbol);\n}\n\nint dlclose(void* handle) {\n    // dlclose returns zero on success.\n    // FreeLibrary returns nonzero on success.\n    return FreeLibrary(handle) != 0;\n}\n\nstatic char dlerror_buf[200];\n\nconst char *dlerror(void) {\n    if (self) {\n        return \"not supported\";\n    }\n\n    DWORD err = GetLastError();\n    LPVOID error_msg;\n    if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |\n                      FORMAT_MESSAGE_FROM_SYSTEM |\n                      FORMAT_MESSAGE_IGNORE_INSERTS,\n                      NULL, err, 0, (LPTSTR)&error_msg, 0, NULL) != 0) {\n        strncpy(dlerror_buf, error_msg, sizeof(dlerror_buf));\n        dlerror_buf[sizeof(dlerror_buf) - 1] = '\\0';\n        LocalFree(error_msg);\n    } else {\n        return \"Failed to get error message\";\n    }\n\n    return dlerror_buf;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/router/src/plugin_info/src/library_file.cc": "/*\n  Copyright (c) 2017, 2018, Oracle and/or its affiliates. All rights reserved.\n\n  This program is free software; you can redistribute it and/or modify\n  it under the terms of the GNU General Public License, version 2.0,\n  as published by the Free Software Foundation.\n\n  This program is also distributed with certain software (including\n  but not limited to OpenSSL) that is licensed under separate terms,\n  as designated in a particular file or component or in included license\n  documentation.  The authors of MySQL hereby grant you an additional\n  permission to link the program and your derivative works with the\n  separately licensed software that they have included with MySQL.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program; if not, write to the Free Software\n  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n*/\n\n#include \"library_file.h\"\n\n#include \"my_config.h\"\n\n#include <stdexcept>\n\n#ifndef _WIN32\n#include <dlfcn.h>\n#include <unistd.h>\n#else\n#include <Windows.h>\n#include \"mysql/harness/filesystem.h\"\n#endif\n\n#define USE_DLCLOSE 1\n\n// disable dlclose() when built with lsan\n//\n// clang has __has_feature(address_sanitizer)\n// gcc has __SANITIZE_ADDRESS__\n#if defined(__has_feature)\n#if __has_feature(address_sanitizer)\n#undef USE_DLCLOSE\n#define USE_DLCLOSE 0\n#endif\n#endif\n\n#if defined(__SANITIZE_ADDRESS__) && __SANITIZE_ADDRESS__ == 1\n#undef USE_DLCLOSE\n#define USE_DLCLOSE 0\n#endif\n\n// dlopen/dlclose work differently on Alpine\n#if defined(LINUX_ALPINE)\n#undef USE_DLCLOSE\n#define USE_DLCLOSE 0\n#endif\n\nstruct Library_file::Library_file_impl {\n#ifndef _WIN32\n  void *handle;\n#else\n  HMODULE handle;\n#endif\n};\n\n#ifdef _WIN32\nnamespace {\nvoid throw_current_error(const std::string &prefix) {\n  char buffer[512];\n  FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_MAX_WIDTH_MASK,\n                nullptr, GetLastError(), LANG_NEUTRAL, buffer, sizeof(buffer),\n                nullptr);\n  throw std::runtime_error(prefix + buffer);\n}\n}  // namespace\n#endif\n\nLibrary_file::Library_file(const std::string &file_name,\n                           const std::string &plugin_name)\n    : impl_(new Library_file_impl()),\n      plugin_name_(plugin_name),\n      file_name_(file_name) {\n#ifndef _WIN32\n  impl_->handle = dlopen(file_name.c_str(), RTLD_LOCAL | RTLD_LAZY);\n  if (impl_->handle == nullptr) {\n    throw std::runtime_error(\"Could not load plugin file: \" + file_name +\n                             \". Error: \" + dlerror());\n  }\n#else\n  mysql_harness::Path lib_file(file_name);\n  // we need to do this so all the dlls that plugin library needs could be found\n  auto res = SetCurrentDirectory(lib_file.dirname().c_str());\n  if (!res) {\n    throw_current_error(\"Could not switch directory to \" +\n                        lib_file.dirname().str() + \": \");\n  }\n  impl_->handle = LoadLibrary(lib_file.real_path().c_str());\n  if (impl_->handle == nullptr) {\n    throw_current_error(\"Could not load plugin file: \" + file_name + \". \");\n  }\n#endif\n}\n\nuint32_t Library_file::get_abi_version() const {\n  Plugin_abi *plugin = get_plugin_struct<Plugin_abi>(plugin_name_);\n\n  return plugin->abi_version;\n}\n\ntemplate <class T>\nT *Library_file::get_plugin_struct(const std::string &symbol) const {\n  // In the older MySQLRouter releases some plugins did not use harness_plugin_\n  // prefix for the plugin structure name. So we check harness_plugin_xxx and\n  // then xxx if the first check failed.\n\n  T *result{nullptr};\n  try {\n    result = get_plugin_struct_internal<T>(\"harness_plugin_\" + symbol);\n  } catch (const std::runtime_error &) {\n    result = get_plugin_struct_internal<T>(plugin_name_);\n  }\n\n  return result;\n}\n\ntemplate <class T>\nT *Library_file::get_plugin_struct_internal(const std::string &symbol) const {\n  T *result{nullptr};\n\n#ifndef _WIN32\n  result = reinterpret_cast<T *>(dlsym(impl_->handle, symbol.c_str()));\n  const char *error = dlerror();\n  if (error) {\n    throw std::runtime_error(\"Loading plugin information for '\" + file_name_ +\n                             \"' failed: \" + error);\n  }\n#else\n  SetLastError(0);\n  result = reinterpret_cast<T *>(GetProcAddress(impl_->handle, symbol.c_str()));\n  DWORD error = GetLastError();\n  if (error) {\n    throw_current_error(\"Loading plugin information for '\" + file_name_ +\n                        \"' failed: \");\n  }\n#endif\n\n  return result;\n}\n\ntemplate Plugin_abi *Library_file::get_plugin_struct<Plugin_abi>(\n    const std::string &) const;\ntemplate Plugin_v1 *Library_file::get_plugin_struct<Plugin_v1>(\n    const std::string &) const;\ntemplate Plugin_abi *Library_file::get_plugin_struct_internal<Plugin_abi>(\n    const std::string &) const;\ntemplate Plugin_v1 *Library_file::get_plugin_struct_internal<Plugin_v1>(\n    const std::string &) const;\n\nLibrary_file::~Library_file() {\n// disable dlclose() if run with address sanitizer to get good memleak reports\n#if USE_DLCLOSE\n#ifndef _WIN32\n  if (impl_->handle) dlclose(impl_->handle);\n#else\n  if (impl_->handle) {\n    FreeLibrary(impl_->handle);\n  }\n#endif\n#endif\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/router/src/harness/src/dynamic_loader.cc": "/*\n  Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.\n\n  This program is free software; you can redistribute it and/or modify\n  it under the terms of the GNU General Public License, version 2.0,\n  as published by the Free Software Foundation.\n\n  This program is also distributed with certain software (including\n  but not limited to OpenSSL) that is licensed under separate terms,\n  as designated in a particular file or component or in included license\n  documentation.  The authors of MySQL hereby grant you an additional\n  permission to link the program and your derivative works with the\n  separately licensed software that they have included with MySQL.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program; if not, write to the Free Software\n  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n*/\n\n#include \"mysql/harness/dynamic_loader.h\"\n\n#ifdef _WIN32\n#include <Windows.h>  // HMODULE\n#else\n#include <dlfcn.h>  // dlopen\n#endif\n\n#include \"mysql/harness/filesystem.h\"  // Path::make_path\n#include \"mysql/harness/stdx/expected.h\"\n\nusing namespace std::string_literals;\n\n#ifdef _WIN32\nstatic std::error_code last_error_code() {\n  // static_cast<> for the \"conversion from 'DWORD' to 'int' requires a\n  // narrowing conversion\"\n  return {static_cast<int>(GetLastError()), std::system_category()};\n#if 0\n  // currently unused on unix\n  return {errno, std::generic_category()};\n#endif\n}\n#endif\n\nconst char default_library_extension[] =\n#ifdef _WIN32\n    \"dll\"\n#else\n    \"so\"\n#endif\n    ;\n\nnamespace mysql_harness {\n\nconst std::error_category &dynamic_loader_category() noexcept {\n  class category_impl : public std::error_category {\n   public:\n    const char *name() const noexcept override { return \"dl\"; }\n    std::string message(int ev) const override {\n      switch (static_cast<DynamicLoaderErrc>(ev)) {\n        case DynamicLoaderErrc::kDlError:\n          return \"dlerror\";\n      }\n\n      return \"(unrecognized error)\";\n    }\n  };\n\n  static category_impl instance;\n  return instance;\n}\n\nstd::error_code make_error_code(DynamicLoaderErrc e) {\n  return {static_cast<int>(e), dynamic_loader_category()};\n}\n\n#ifdef _WIN32\n/**\n * get filename of a module.\n *\n * @note windows only.\n *\n * @param handle handle to a module\n * @returns filename of success, std::error_code on error.\n */\nstatic stdx::expected<std::string, std::error_code> module_filename(\n    DynamicLibrary::native_handle_type handle) {\n  std::string fn;\n\n  fn.resize(MAX_PATH);\n\n  const auto sz = GetModuleFileName(handle, &fn.front(), fn.size());\n  // fn.size() is buffer with \\0\n  // on success, returns size without trailing \\0\n  if (sz == 0) {\n    return stdx::make_unexpected(last_error_code());\n  } else if (sz == fn.size()) {\n    // truncation\n    return stdx::make_unexpected(\n        std::error_code(ERROR_INSUFFICIENT_BUFFER, std::system_category()));\n  } else {\n    fn.resize(sz);\n    return fn;\n  }\n}\n#endif\n\nstdx::expected<DynamicLibrary, std::error_code> DynamicLoader::load(\n    const std::string &libname) const {\n#ifdef _WIN32\n  if (0 == SetDllDirectory(search_path_.c_str())) {\n    return stdx::make_unexpected(last_error_code());\n  }\n\n  std::string filename = libname + \".\" + default_library_extension;\n\n  const DynamicLibrary::native_handle_type handle =\n      LoadLibrary(filename.c_str());\n  if (handle == nullptr) {\n    return stdx::make_unexpected(last_error_code());\n  }\n\n  if (auto res = module_filename(handle)) {\n    // if the filename can be resolved, use it.\n    filename = std::move(res.value());\n  }\n#else\n  // reset older error in the dl-lib\n  dlerror();\n\n  const std::string filename =\n      mysql_harness::Path::make_path(search_path_, libname,\n                                     default_library_extension)\n          .str();\n\n  const DynamicLibrary::native_handle_type handle =\n      dlopen(filename.c_str(), RTLD_LOCAL | RTLD_NOW);\n  if (handle == nullptr) {\n    error_msg_ = dlerror();\n    return stdx::make_unexpected(make_error_code(DynamicLoaderErrc::kDlError));\n  }\n#endif\n\n  return DynamicLibrary{filename, handle};\n}\n\nstdx::expected<void *, std::error_code> DynamicLibrary::symbol(\n    const std::string &name) const {\n#ifdef _WIN32\n  auto *sym = reinterpret_cast<void *>(GetProcAddress(handle_, name.c_str()));\n  if (sym == nullptr) {\n    return stdx::make_unexpected(last_error_code());\n  }\n#else\n  // as the return-value of dlsym() can be NULL even on success, the dlerror()\n  // must be checked if it is non-null\n  auto *sym = dlsym(handle_, name.c_str());\n\n  auto *error = dlerror();\n  if (error != nullptr) {\n    error_msg_ = error;\n    return stdx::make_unexpected(make_error_code(DynamicLoaderErrc::kDlError));\n  }\n#endif\n\n  return {sym};\n}\n\nvoid DynamicLibrary::unload() {\n#ifdef _WIN32\n  if (handle_ != nullptr) FreeLibrary(handle_);\n#else\n  if (handle_ != nullptr) dlclose(handle_);\n#endif\n  handle_ = nullptr;\n}\n\n}  // namespace mysql_harness\n",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/router/src/harness/include/mysql/harness/loader.h": "/*\n  Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.\n\n  This program is free software; you can redistribute it and/or modify\n  it under the terms of the GNU General Public License, version 2.0,\n  as published by the Free Software Foundation.\n\n  This program is also distributed with certain software (including\n  but not limited to OpenSSL) that is licensed under separate terms,\n  as designated in a particular file or component or in included license\n  documentation.  The authors of MySQL hereby grant you an additional\n  permission to link the program and your derivative works with the\n  separately licensed software that they have included with MySQL.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program; if not, write to the Free Software\n  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n*/\n\n/**\n * @class mysql_harness::Loader\n *\n * @ingroup Loader\n *\n *\n *\n * ## Introduction\n *\n * The loader class is responsible for managing the life-cycle of\n * plugins in the harness. Each plugin goes through seven steps in the\n * life-cycle, of which steps #2, #3, #5 and #6 are optional:\n *\n * 1. Loading\n * 2. Initialization\n * 3. Starting\n * 4. Running\n * 5. Stopping\n * 6. Deinitialization\n * 7. Unloading\n *\n * ## Overview of Life-cycle Steps\n *\n * ### 1. Loading ###\n *\n * When *loading*, the plugin is loaded using the dynamic library\n * support available on the operating system. Symbols are evaluated\n * lazily (for example, the `RTLD_LAZY` flag is used for `dlopen`) to\n * allow plugins to be loaded in any order. The symbols that are\n * exported by the plugin are made available to all other plugins\n * loaded (flag `RTLD_GLOBAL` to `dlopen`).\n *\n * As part of the loading procedure, the *plugin structure* (see\n * Plugin class) is fetched from the module and used for the four\n * optional steps below.\n *\n *\n *\n * ### 2. Initialization ###\n *\n * After all the plugins are successfully loaded, each plugin is given\n * a chance to perform initialization. This step is only executed if\n * the plugin structure defines an `init` function. Note that it is\n * guaranteed that the init function of a plugin is called *after* the\n * `init` function of all plugins it requires have been called. The\n * list of these dependencies is specified via `requires` field of the\n * `Plugin` struct.\n *\n * @note if some plugin `init()` function fails, any plugin `init()`\n * functions schedulled to run after will not run, and harness will\n * proceed straight to deinitialization step, bypassing calling\n * `start()` and `stop()` functions.\n *\n *\n *\n * ### 3. Starting ###\n * After all plugins have been successfully initialized, a thread is\n * created for each plugin that has a non-NULL `start` field in the\n * plugin structure. The threads are started in an arbitrary order,\n * so you have to be careful about not assuming that, for example,\n * other plugins required by the plugin have started their thread. If\n * the plugin does not define a `start` function, no thread is created.\n * There is a \"running\" flag associated with each such thread; this\n * flag is set when the thread starts but before the `start` function\n * is called. If necessary, the plugin can spawn more threads using\n * standard C++11 thread calls, however, these threads should not\n * call harness API functions.\n *\n *\n *\n * ### 4. Running ###\n * After starting all plugins (that needed to be started), the harness\n * will enter the *running step*. This is the \"normal\" phase, where the\n * application spends most of its lifetime (application and plugins\n * service requests or do whatever it is they do). Harness will remain\n * in this step until one of two things happen:\n *\n *   1. shutdown signal is received by the harness\n *   2. one of the plugins exits with error\n *\n * When one of these two events occurrs, harness progresses to the\n * next step.\n *\n *\n *\n * ### 5. Stopping ###\n * In this step, harness \"tells\" plugins running `start()` to exit this\n * function by clearing the \"running\" flag. It also invokes `stop()`\n * function for all plugins that provided it. It then waits for all\n * running plugin threads to exit.\n *\n * @note under certain circumstances, `stop()` may overlap execution\n *       with `start()`, or even be called before `start()`.\n *\n *\n *\n * ### 6. Deinitialization ###\n * After all threads have stopped, regardless of whether they stopped\n * with an error or not, the plugins are deinitialized in reverse order\n * of initialization by calling the function in the `deinit` field of\n * the `Plugin` structure. Regardless of whether the `deinit()` functions\n * return an error or not, all plugins schedulled for deinitialisation\n * will be deinitialized.\n *\n * @note for any `init()` functions that failed, `deinit()` functions\n *       will not run.\n * @note plugins may have a `deinit()` function despite not having a\n *       corresponding `init()`. In such cases, the missing `init()` is\n *       treated as if it existed and ran successfully.\n *\n *\n *\n * ### 7. Unloading ###\n * After a plugin has deinitialized, it can be unloaded. It is\n * guaranteed that no module is unloaded before it has been\n * deinitialized.\n *\n * @note This step is currently unimplemented - meaning, it does nothing.\n *       The plugins will remain loaded in memory until the process shuts\n *       down. This makes no practical difference on application behavior\n *       at present, but might be needed if Harness gained ability to\n *       reload plugins in the future.\n\n## Behavior Diagrams\n\nPrevious section described quickly each step of the life-cycle process. In this\nsection, two flow charts are presented which show the operation of all seven\nsteps. First shows a high-level overview, and the second shows all 7 life-cycle\nsteps in more detail. Discussion of details follows in the following sections.\n\nSome points to keep in mind while viewing the diagrams:\n\n- diagrams describe code behavior rather than implementation. So for example:\n  - pseudocode does not directly correspond 1:1 to real code. However, it\n    behaves exactly like the real code.\n\n- seven life-cycle functions shown are actual functions (@c Loader's methods,\n  to be more precise)\n  - load_all(), init_all(), start_all(), main_loop(), stop_all(), deinit_all()\n    are implemented functions (first 6 steps of life-cycle)\n  - unload_all() is the 7th step of life-cycle, but it's currently unimplemented\n\n- when plugin functions exit with error, they do so by calling\n  set_error() before exiting\n\n- some things are not shown to keep the diagram simple:\n  - first error returned by any of the 7 life-cycle functions is\n    saved and passed at the end of life-cycle flow to the calling code\n\n\n### Overview\n\n@verbatim\n\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\                                                                              \\\n\\   START                                                                      \\\n\\     |                                                                        \\\n\\     |                                                                        \\\n\\     |                                                                        \\\n\\     V                                                                        \\\n\\   [load_all()]                                                               \\\n\\     |                                                                        \\\n\\     V                                                                        \\\n\\   <LOAD_OK?>                                                                 \\\n\\     |   |                                                                    \\\n\\ +---N   Y                                                                    \\\n\\ |       |                                                                    \\\n\\ |       v                                                                    \\\n\\ | [init_all()]                                                               \\\n\\ |   |                                                                        \\\n\\ |   v                                                                        \\\n\\ | <INIT_OK?>                                         (  each plugin runs  )  \\\n\\ |   |   |                                            (in a separate thread)  \\\n\\ |   N   Y                                                                    \\\n\\ |   |   |                                             [plugin[1]->start()]   \\\n\\ |   |   v             start plugin threads            [plugin[2]->start()]   \\\n\\ |   | [start_all()] - - - - - - - - - - - - - - - - ->[    ..      ..    ]   \\\n\\ |   |   |                                             [    ..      ..    ]   \\\n\\ |   |   |  + - - - - - - - - - - - - - - - - - - - - -[plugin[n]->start()]   \\\n\\ |   |   |            notification when each                     ^            \\\n\\ |   |   |  |           thread terminates                                     \\\n\\ |   |   |                                                       |            \\\n\\ |   |   |  |                                                     stop plugin \\\n\\ |   |   |                                                       |  threads   \\\n\\ |   |   |  |                                                                 \\\n\\ |   |   |                                                       |            \\\n\\ |   |   v  v                                                                 \\\n\\ |   | [main_loop()]= call ==>[stop_all()] - - - - - - - - - - - +            \\\n\\ |   |   |                                                                    \\\n\\ |   |   |        \\                                                           \\\n\\ |   *<--+         \\                                                          \\\n\\ |   |              \\__ waits for all plugin                                  \\\n\\ |   v                  threads to terminate                                  \\\n\\ | [deinit_all()]                                                             \\\n\\ |   |                                                                        \\\n\\ |   v                                                                        \\\n\\ +-->*                                                                        \\\n\\     |                                                                        \\\n\\     v                                                                        \\\n\\   [unload_all()]                                                             \\\n\\     |                                                                        \\\n\\     |         \\                                                              \\\n\\     |          \\                                                             \\\n\\     v           \\__ currently not implemented                                \\\n\\    END                                                                       \\\n\\                                                                              \\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\n@endverbatim\n\n\n### Detailed View\n\n@verbatim\n\n            START\n              |\n              |\n              v\n\\\\\\\\ load_all() \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\                                    \\\n\\  LOAD_OK = true                    \\\n\\  foreach plugin:                   \\\n\\    load plugin                     \\\n\\    if (exit_status != ok):         \\\n\\      LOAD_OK = false               \\\n\\      break loop                    \\\n\\                                    \\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n              |\n              |\n              v\n            <LOAD_OK?>\n              |   |\n              Y   N----> unload_all() (see further down)\n              |\n              |\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\|\\\\\\ init_all() \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\             |                               \\\n\\             v                               \\\n\\           [INIT_OK = true, i = 1]           \\\n\\             |                               \\\n\\             v                               \\\n\\     +----><plugin[i] exists?>               \\\n\\     |       |   |                           \\\n\\   [i++]     Y   N---------------------+     \\\n\\     ^       |                         |     \\\n\\     |       |                         |     \\\n\\     |       v                         |     \\\n\\     |     <plugin[i] has init()?>     |     \\\n\\     |       |   |                     |     \\\n\\     |       N   Y---+                 |     \\\n\\     |       |       |                 |     \\\n\\     |       |       |                 |     \\\n\\     |       |       v                 |     \\\n\\     |       |     [plugin[i]->init()] |     \\\n\\     |       |       |                 |     \\\n\\     |       |       |                 |     \\\n\\     |       |       |                 |     \\\n\\     |       |       |                 |     \\\n\\     |       |       v                 |     \\\n\\     |       |     <exit ok?>          |     \\\n\\     |       v       |   |             |     \\\n\\     +-------*<------Y   N             |     \\\n\\                         |             |     \\\n\\                         |             |     \\\n\\                         v             |     \\\n\\                   [INIT_OK = false]   |     \\\n\\                     |                 |     \\\n\\                     v                 |     \\\n\\                     *<----------------+     \\\n\\                     |                       \\\n\\                     v                       \\\n\\                   [LAST_PLUGIN = i-1]       \\\n\\                     |                       \\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\|\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n                      |\n                      |\n                      v\n                    <INIT_OK?>\n                      |   |\n                      Y   N----> deinit_all() (see further down)\n                      |\n                      |\n                      v\n\\\\\\\\ start_all() \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\\                                        \\\n\\   for i = 1 to LAST_PLUGIN:            \\\n\\     if plugin[i] has start():          \\  start start() in new thread\n\\       new thread(plugin[i]->start()) - - - - - - - - - - - - - - - - +\n\\                                        \\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\                             |\n                      |\n                      |                                                |\n    +-----------------+\n    |                                                                  |\n\\\\\\\\|\\\\\\ main_loop() \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ \\\\\\\\\\\\\\\\\n    |                                                                  |       \\\n    v                                                                          \\\n+-->*                                                                  |       \\\n|   |                                                                          \\\n|   v                                                                  |       \\\n| <any plugin threads running?>                                                \\\n|   |   |                                                              |       \\\n|   N   Y---+                                                                  \\\n|   |       |                                                          |       \\\n|   |     <shutdown signal received && stop_all() not called yet?>             \\\n|   |       |   |                                                      |       \\\n|   |       N   Y                                                              \\\n|   |       |    == call ==>[stop_all()]- - - - - - - - - - - - - +    |       \\\n|   |       |   |                     tell (each) start() to exit              \\\n|   |       *<--+                                                 |    |       \\\n|   |       |                                                                  \\\n|   |       |                                                     v    v       \\\n|   |       |                                             [plugin[1]->start()] \\\n|   |       v                 (one) plugin thread exits   [plugin[2]->start()] \\\n|   |     [wait for (any)]<- - - - - - - - - - - - - - - -[    ..      ..    ] \\\n|   |     [ thread exit  ]                                [    ..      ..    ] \\\n|   |       |                                             [plugin[n]->start()] \\\n|   |       |                                                     ^            \\\n|   |       |                                                                  \\\n|   |       v                                                     |            \\\n|   |     <thread exit ok?>                                                    \\\n|   |       |   |                                                 |            \\\n|   |       Y   N---+                                                          \\\n|   |       |       |                                             |            \\\n|   |       |       v                                                          \\\n|   |       |     <stop_all() called already?>                    |            \\\n|   |       v       |   |                                                      \\\n|   |       *<------Y   N                                    tell (each)       \\\n|   |       |            = call ==+                        start() to exit     \\\n|   |       |           |         |                               |            \\\n|   |       v           |         |                                            \\\n+---|-------*<----------+         *==>[stop_all()]- - - - - - - - +            \\\n    |                             |                                            \\\n    |                             |        |                                   \\\n    v                             |        |                                   \\\n  <stop_all() called already?>    |        |                                   \\\n    |   |                         |        |                                   \\\n    Y   N                         |        |                                   \\\n    |    == call =================+        |                                   \\\n    |   |                                  |                                   \\\n    *---+                                  |                                   \\\n    |                                      |                                   \\\n\\\\\\\\|\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\|\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n    |                                      |\n    |                                      |\n    v                                      |\n    *<---- init_all() (if !INIT_OK)        |\n    |                                      |\n    |                                      |\n    v                                      |\n\\\\\\\\ deinit_all() \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\     |\n\\                                    \\     |\n\\  for i = LAST_PLUGIN to 1:         \\     |\n\\    if plugin[i] has deinit():      \\     |\n\\      plugin[i]->deinit()           \\     |\n\\      if (exit_status != ok):       \\     |\n\\        # ignore error              \\     |\n\\                                    \\     |\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\     |\n    |                                      |\n    |                                      |\n    v                                      |\n    *<---- load_all() (if !LOAD_OK)        |\n    |                                      |\n    v                                      |\n\\\\\\\\ unload_all() \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\     |\n\\                                    \\     |\n\\  no-op (currently unimplemented)   \\     |\n\\                                    \\     |\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\     |\n    |                                      |\n    |                                      |\n    v                                      /\n   END                                    /\n                                         /\n                                        /\n                                       /                  (  each plugin runs  )\n                                      /                   (in a separate thread)\n\\\\\\\\ stop_all() \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\  run_flag == false\n\\                                    \\    tells start()    [plugin[1]->start()]\n\\  for i = 1 to LAST_PLUGIN:         \\      to exit        [plugin[2]->start()]\n\\    run_flag[i] = false - - - - - - - - - - - - - - - - ->[    ..      ..    ]\n\\    if plugin[i] has stop():        \\                     [    ..      ..    ]\n\\      plugin[i]->stop()             \\                     [    ..      ..    ]\n\\      if (exit_status != ok):       \\                     [plugin[n]->start()]\n\\        # ignore error              \\\n\\                                    \\\n\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n\n@endverbatim\n\n\n\n\n## Discussion\n\n### Persistence (definition)\n\nBefore continuing, we need to define the word \"persist\", used later on. When we\nsay \"persist\", we'll mean the opposite of \"exit\". So when we say a function or\na thread persists, it means that it's not returning/exiting, but instead is\nrunning some forever-loop or is blocked on something, etc. What it's doing\nexactly doesn't matter, what matters, is that it hasn't terminated but\n\"lives on\" (in case of a function, to \"persist\" means the same as to \"block\",\nbut for threads that might sound confusing, this is why we need a new word).\nSo when we call start() in a new thread, it will either run and keep running\n(thread will persist), or it will run briefly and return (thread will exit).\nIn short, \"to persist\" means the opposite of \"to finish running and exit\".\n\n### Plugin API functions\n\nEach plugin can define none, any or all of the following 4 callbacks.\nThey're function pointers, that can be null if not implemented. They're\ntypically called in the order as listed below (under certain circumstances,\nstop() may overlap execution with start(), or even be called before start()).\n\n- init()    -- called inside of main thread\n- start()   -- main thread creates a new thread, then calls this\n- stop()    -- called inside of main thread\n- deinit()  -- called inside of main thread\n\n### Starting and Stopping: Start() ###\n\nIt is typical to implement start function in such a way that it will\n\"persist\" (i.e. it will run some forever-loop processing requests\nrather than exit briefly after being called). In such case, Harness\nmust have a way to terminate it during shutdown operation.\n\nFor this purpose, Harness exposes a boolean \"running\" flag to each plugin, which\nserves as means to communicate the need to shutdown; it is read by\n`is_running()` function. This function should be routinely polled by plugin's\n`start()` function to determine if it should shut down, and once it returns\nfalse, plugin `start()` should terminate as soon as possible. Failure to\nterminate will block Harness from progressing further in its shutdown procedure,\nresulting in application \"hanging\" during shutdown. Typically, `start()`\nwould be implemented more-or-less like so:\n\n    void start()\n    {\n      // run-once code\n\n      while (is_running())\n      {\n        // forever-loop code\n      }\n\n      // clean-up code\n    }\n\nThere is also an alternative blocking function available, `wait_for_stop()`,\nshould that be better suited for the particular plugin design. Instead of\nquickly returning a boolean flag, it will block (with an optional timeout)\nuntil Harness flags to shut down this plugin. It is an efficient functional\nequivalent of:\n\n    while (is_running())\n    {\n      // sleep a little or break on timeout\n    }\n\nWhen entering shutdown phase, Harness will notify all plugins to shut down\nvia mechanisms described above. It is also permitted for plugins to exit on\ntheir own, whether due to error or intended behavior, without consulting\nthis \"running\" flag. Polling the \"running\" flag is only needed when `start()`\n\"persists\" and does not normally exit until told to do so.\n\nAlso, in some designs, `start()` function might find it convenient to be able to\nset the \"running\" flag to false, in order to trigger its own shutdown in another\npiece of code. For such cases, `clear_running()` function is provided, which\nwill do exactly that.\n\nIMPORTANT! Please note that all 3 functions described above (`is_running()`,\n`wait_for_stop()` and `clear_running()`) can only be called from a thread\nrunning `start()` function. If `start()` spawns more theads, these\nfunctions CANNOT be called from them. These functions also cannot be called\nfrom the other three plugin functions (`init()`, `stop()` and `deinit()`).\n\n### Starting and Stopping: Stop() ###\n\nDuring shutdown, or after plugin `start()` function exits (whichever comes\nfirst), plugin's `stop()` function will be called, if defined.\n\nIMPORTANT: `start()` function runs in a different thread than `stop()`\nfunction. By the time `stop()` runs, depending on the circumstances,\n`start()` thread may or may not exist.\n\nIMPORTANT: `stop()` will always be called during shutdown, regardless of whether\nstart() exited with error, exited successfully or is still running.  `stop()`\nmust be able to deal with all 3 scenarios. The rationale for this design\ndecision is given Error Handling section.\n\n\n\n### Persistence in Plugin Functions ###\n\nWhile start() may persist, the other three functions (init(), stop() and\ndeinit()) must obviously not persist, since they run in the main thread.\nAny blocking behavior exhibited in these functions (caused by a bug or\notherwise) will cause the entire application to hang, as will start() that\ndoes not poll and/or honor is_running() flag.\n\n\n\n### Returning Success/Failure from Plugin Function ###\n\nHarness expects all four plugin functions (`init(), `start()`, `stop()` and\n`deinit()`) to notify it in case of an error. This is done via function:\n\n    set_error(PluginFuncEnv* env, ErrorType error, const char* format, ...);\n\nCalling this function flags that the function has failed, and passes the\nerror type and string back to Harness. The converse is also true: not\ncalling this function prior to exiting the function implies success.\nThis distinction is important, because Harness may take certain actions\nbased on the status returned by each function.\n\nIMPORTANT! Throwing exceptions from these functions is not supported.\nIf your plugin uses exceptions internally, that is fine, but please\nensure they are handled before reaching the Harness-Plugin boundary.\n\n\n### Threading Concerns ###\n\nFor each plugin (independent of other plugins):\nOf the 4 plugin functions, `init()` runs first. It is guaranteed that\nit will exit before `start()` and `stop()` are called. `start()` and\n`stop()` can be called in parallel to each other, in any order, with\ntheir lifetimes possibly overlapping. They are guaranteed to both have\nexited before `deinit()` is called.\n\nIf any of the 4 plugin functions spawn any additional threads, Harness\nmakes no provisions for interacting with them in any way: calling\nHarness functions from them is not supported in particular; also such\nthreads should exit before their parent function finishes running.\n\n\n\n### Error Handling ###\n\nNOTE: WL#9558 HLD version of this section additionally discusses design,\n      rationale for the approach chosen, etc; look there if interested.\n\nWhen plugin functions enounter an error, they are expected to signal it via\nset_error(). What happens next, depends on the case, but in all four\ncases the error will be logged automatically by the harness. Also, the first\nerror passed from any plugin will be saved until the end of life-cycle\nprocessing, then passed down to the code calling the harness. This will allow\nthe application code to deal with it accordingly (probably do some of its own\ncleaning and shut down, but that's up to the application). In general, the first\nerror from init() or start() will cause the harness to initiate shut down\nprocedure, while the errors from stop() and deinit() will be ignored completely\n(except of course for being logged and possibly saved for passing on at the\nend). Actions taken for each plugin function are as follows:\n\n\n\n#### init() fails:\n\n  - skip init() for remaining plugins\n\n  - don't run any start() and stop() (proceed directly to deinitialisation)\n\n  - run deinit() only for plugins initialiased so far (excluding the failing\n    one), in reverse order of initialisation, and exit\n\n  - when init() is not provided (is null), it counts as if it ran, if it would\n    have run before the failing plugin (according to topological order)\n\n\n\n#### start() fails:\n\n  - proceed to stop all plugins, then deinit() all in reverse order of\n    initialisation and exit. Please note that ALL plugins will be flagged\n    to stop and have their stop() function called (not just the ones that\n    succeeded in starting - plugin's stop() must be able to deal with such\n    a situation)\n\n\n\n#### stop() or deinit() fails:\n\n  - log error and ignore, proceed as if it didn't happen\n\n*/\n\n#ifndef MYSQL_HARNESS_LOADER_INCLUDED\n#define MYSQL_HARNESS_LOADER_INCLUDED\n\n#include \"router_config.h\"\n\n#include \"config_parser.h\"\n#include \"filesystem.h\"\n#include \"mysql/harness/dynamic_loader.h\"\n#include \"mysql/harness/loader_config.h\"\n#include \"mysql/harness/plugin.h\"\n\n#include \"harness_export.h\"\n\n#include \"mpsc_queue.h\"\n#include \"my_compiler.h\"\n\n#include <csignal>\n#include <cstdarg>  // va_list\n#include <exception>\n#include <future>\n#include <istream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <stdexcept>\n#include <string>\n#include <thread>\n#include <tuple>\n\n#ifdef FRIEND_TEST\n// TODO replace by #include after merge:\n// #include \"../../../mysqlrouter/utils.h\"  // DECLARE_TEST\n/** @brief Declare test (class)\n *\n * When using FRIEND_TEST() on classes that are not in the same namespace\n * as the test, the test (class) needs to be forward-declared. This marco\n * eases this.\n *\n * @note We need this for unit tests, BUT on the TESTED code side (not in unit\n * test code)\n */\n#define DECLARE_TEST(test_case_name, test_name) \\\n  class test_case_name##_##test_name##_Test\n\nclass TestLoader;\nclass LifecycleTest;\n\nDECLARE_TEST(TestStart, StartLogger);\nDECLARE_TEST(LifecycleTest, Simple_None);\nDECLARE_TEST(LifecycleTest, Simple_AllFunctions);\nDECLARE_TEST(LifecycleTest, Simple_Init);\nDECLARE_TEST(LifecycleTest, Simple_StartStop);\nDECLARE_TEST(LifecycleTest, Simple_StartStopBlocking);\nDECLARE_TEST(LifecycleTest, Simple_Start);\nDECLARE_TEST(LifecycleTest, Simple_Stop);\nDECLARE_TEST(LifecycleTest, Simple_Deinit);\nDECLARE_TEST(LifecycleTest, ThreeInstances_NoError);\nDECLARE_TEST(LifecycleTest, BothLifecycles_NoError);\nDECLARE_TEST(LifecycleTest, OneInstance_NothingPersists_NoError);\nDECLARE_TEST(LifecycleTest, OneInstance_NothingPersists_StopFails);\nDECLARE_TEST(LifecycleTest, ThreeInstances_InitFails);\nDECLARE_TEST(LifecycleTest, BothLifecycles_InitFails);\nDECLARE_TEST(LifecycleTest, ThreeInstances_Start1Fails);\nDECLARE_TEST(LifecycleTest, ThreeInstances_Start2Fails);\nDECLARE_TEST(LifecycleTest, ThreeInstances_Start3Fails);\nDECLARE_TEST(LifecycleTest, ThreeInstances_2StartsFail);\nDECLARE_TEST(LifecycleTest, ThreeInstances_StopFails);\nDECLARE_TEST(LifecycleTest, ThreeInstances_DeinintFails);\nDECLARE_TEST(LifecycleTest, ThreeInstances_StartStopDeinitFail);\nDECLARE_TEST(LifecycleTest, NoInstances);\nDECLARE_TEST(LifecycleTest, EmptyErrorMessage);\nDECLARE_TEST(LifecycleTest, send_signals);\nDECLARE_TEST(LifecycleTest, send_signals2);\nDECLARE_TEST(LifecycleTest, wait_for_stop);\nDECLARE_TEST(LifecycleTest, InitThrows);\nDECLARE_TEST(LifecycleTest, StartThrows);\nDECLARE_TEST(LifecycleTest, StopThrows);\nDECLARE_TEST(LifecycleTest, DeinitThrows);\nDECLARE_TEST(LifecycleTest, InitThrowsWeird);\nDECLARE_TEST(LifecycleTest, StartThrowsWeird);\nDECLARE_TEST(LifecycleTest, StopThrowsWeird);\nDECLARE_TEST(LifecycleTest, DeinitThrowsWeird);\nDECLARE_TEST(LoaderReadTest, Loading);\n#endif\n\nnamespace mysql_harness {\n\nstruct Plugin;\nclass Path;\n\n/**\n * PluginFuncEnv object\n *\n * This object is the basis of all communication between Harness and plugin\n * functions. It is passed to plugin functions (as an opaque pointer), and\n * plugin functions return it back to Harness when calling Harness API\n * functions. It has several functions:\n *\n * - maintains a \"running\" flag, which controls starting/stopping\n *   of plugins\n *\n * - conveys exit status back to Harness after each plugin function exits\n *\n * - conveys more information (AppInfo, ConfigSection, ...) to\n *   plugin functions. Note that not all fields are set for all functions -\n *   setting ConfigSection ptr when calling init() makes no sense, for example\n *\n * @note Below we only briefly document the methods. For more information, see\n * Harness API documentation for their corresponding free-function proxies\n * in plugin.h\n */\nclass HARNESS_EXPORT PluginFuncEnv {\n public:\n  /**\n   * Constructor\n   *\n   * @param info AppInfo to pass to plugin function. Can be NULL.\n   * Pointer is owned by the caller and must outlive plugin function call.\n   * @param section ConfigSection to pass to plugin function. Can be NULL.\n   * Pointer is owned by the caller and must outlive plugin function call.\n   * @param running Set \"running\" flag. true = plugin should be running\n   */\n  PluginFuncEnv(const AppInfo *info, const ConfigSection *section,\n                bool running = false);\n\n  // further info getters\n  // (see also corresponding Harness API functions in plugin.h for more info)\n  const ConfigSection *get_config_section() const noexcept;\n  const AppInfo *get_app_info() const noexcept;\n\n  // running flag\n  // (see also corresponding Harness API functions in plugin.h for more info)\n  void set_running() noexcept;\n  void clear_running() noexcept;\n  bool is_running() const noexcept;\n  bool wait_for_stop(uint32_t milliseconds) const\n      noexcept;  // 0 = infinite wait\n\n  // error handling\n  // (see also corresponding Harness API functions in plugin.h for more info)\n  bool exit_ok() const noexcept;\n  MY_ATTRIBUTE((format(printf, 3, 0)))\n  void set_error(ErrorType error_type, const char *fmt, va_list ap) noexcept;\n  std::tuple<std::string, std::exception_ptr> pop_error() noexcept;\n\n private:\n  const AppInfo *app_info_;              // \\.\n  const ConfigSection *config_section_;  //  > initialized in ctor\n  bool running_;                         // /\n  std::string error_message_;\n  ErrorType error_type_ = kNoError;\n\n  mutable std::condition_variable cond_;\n  mutable std::mutex mutex_;\n};\n\nclass HARNESS_EXPORT PluginThreads {\n public:\n  void push_back(std::thread &&thr);\n\n  // wait for the first non-fatal exit from plugin or all plugins exited\n  // cleanly\n  void try_stopped(std::exception_ptr &first_exc);\n\n  void push_exit_status(std::exception_ptr &&eptr) {\n    plugin_stopped_events_.push(std::move(eptr));\n  }\n\n  size_t running() const { return running_; }\n\n  void wait_all_stopped(std::exception_ptr &first_exc);\n\n  void join();\n\n private:\n  std::vector<std::thread> threads_;\n  size_t running_{0};\n\n  /**\n   * queue of events after plugin's start() function exited.\n   *\n   * nullptr if \"finished without error\", pointer to an exception otherwise\n   */\n  WaitingMPSCQueue<std::exception_ptr> plugin_stopped_events_;\n};\n\nclass HARNESS_EXPORT Loader {\n public:\n  /**\n   * Constructor for Loader.\n   *\n   * @param program Name of our program\n   * @param config Router configuration\n   */\n  Loader(const std::string &program, LoaderConfig &config)\n      : config_(config), program_(program) {}\n\n  Loader(const Loader &) = delete;\n  Loader &operator=(const Loader &) = delete;\n\n  /**\n   * Destructor.\n   *\n   * The destructor will call dlclose() on all unclosed shared\n   * libraries.\n   */\n\n  ~Loader();\n\n  /**\n   * Fetch available plugins.\n   *\n   * @return List of names of available plugins.\n   */\n\n  std::list<Config::SectionKey> available() const;\n\n  /**\n   * Initialize and start all loaded plugins.\n   *\n   * All registered plugins will be initialized in proper order and\n   * started (if they have a `start` callback).\n   *\n   * @throws first exception that was triggered by an error returned from any\n   * plugin function.\n   */\n  void start();\n\n  /**\n   * Get reference to configuration object.\n   *\n   * @note In production code we initialize Loader with LoaderConfig\n   * reference maintained by DIM, so this method will return this object.\n   */\n  LoaderConfig &get_config() { return config_; }\n\n private:\n  enum class Status { UNVISITED, ONGOING, VISITED };\n\n  /**\n   * Flags progress of Loader. The progress always proceeds from top to bottom\n   * order in this list.\n   */\n  enum class Stage {\n    // NOTE: do not alter order of these enums!\n    Unset,\n    Loading,\n    Initializing,\n    Starting,\n    Running,\n    Stopping,\n    Deinitializing,\n    Unloading,\n  };\n\n  /**\n   * Load the named plugin from a specific library.\n   *\n   * @param plugin_name Name of the plugin to be loaded.\n   *\n   * @param library_name Name of the library the plugin should be\n   * loaded from.\n   *\n   * @throws bad_plugin (std::runtime_error) on load error\n   */\n  const Plugin *load_from(const std::string &plugin_name,\n                          const std::string &library_name);\n\n  const Plugin *load(const std::string &plugin_name);\n\n  /**\n   * Load the named plugin and all dependent plugins.\n   *\n   * @param plugin_name Name of the plugin to be loaded.\n   * @param key Key of the plugin to be loaded.\n   *\n   * @throws bad_plugin (std::runtime_error) on load error\n   * @throws bad_section (std::runtime_error) when section 'plugin_name' is not\n   * present in configuration\n   *\n   * @post After the execution of this procedure, the plugin and all\n   * plugins required by that plugin will be loaded.\n   */\n  /** @overload */\n  const Plugin *load(const std::string &plugin_name, const std::string &key);\n\n  // IMPORTANT design note: start_all() will block until PluginFuncEnv objects\n  // have been created for all plugins. This guarantees that the required\n  // PluginFuncEnv will always exist when plugin stop() function is called.\n\n  // start() calls these, indents reflect call hierarchy\n  void load_all();  // throws bad_plugin on load error\n  void setup_info();\n  std::exception_ptr\n  run();  // returns first exception returned from below harness functions\n  std::exception_ptr init_all();  // returns first exception triggered by init()\n\n  void\n  start_all();  // forwards first exception triggered by start() to main_loop()\n\n  std::exception_ptr\n  main_loop();  // returns first exception triggered by start() or stop()\n\n  // class stop_all() and waits for plugins the terminate\n  std::exception_ptr stop_and_wait_all();\n\n  std::exception_ptr stop_all();  // returns first exception triggered by stop()\n\n  std::exception_ptr\n  deinit_all();  // returns first exception triggered by deinit()\n\n  void unload_all();\n  size_t external_plugins_to_load_count();\n\n  /**\n   * Topological sort of all plugins and their dependencies.\n   *\n   * Will create a list of plugins in topological order from \"top\"\n   * to \"bottom\".\n   */\n  bool topsort();\n  bool visit(const std::string &name, std::map<std::string, Status> *seen,\n             std::list<std::string> *order);\n\n  /**\n   * Holds plugin's API call information\n   *\n   * @note There's 1 instance per plugin type (not plugin instance)\n   */\n  class HARNESS_EXPORT PluginInfo {\n   public:\n    PluginInfo(const std::string &folder, const std::string &libname);\n    PluginInfo(const Plugin *const plugin) : plugin_(plugin) {}\n\n    void load_plugin_descriptor(const std::string &name);  // throws bad_plugin\n\n    const Plugin *plugin() const { return plugin_; }\n\n    const DynamicLibrary &library() const { return module_; }\n\n   private:\n    DynamicLibrary module_;\n    const Plugin *plugin_{};\n  };\n\n  using PluginMap = std::map<std::string, PluginInfo>;\n\n  // Init order is important, so keep config_ first.\n\n  /**\n   * Configuration sections for all plugins.\n   */\n  LoaderConfig &config_;\n\n  /**\n   * Map of all successfully-loaded plugins (without key name).\n   */\n  PluginMap plugins_;\n\n  /**\n   * Map of all {plugin instance -> plugin start() PluginFuncEnv} objects.\n   * Initially these objects are created in Loader::start_all() and then kept\n   * around until the end of Loader::stop_all(). At the time of writing,\n   * PluginFuncEnv objects for remaining plugin functions (init(), stop() and\n   * deinit()) are not required to live beyond their respective functions calls,\n   * and are therefore created on stack (automatic variables) as needed during\n   * those calls.\n   */\n  std::map<const ConfigSection *, std::shared_ptr<PluginFuncEnv>>\n      plugin_start_env_;\n\n  /**\n   * active plugin threads.\n   */\n  PluginThreads plugin_threads_;\n\n  /**\n   * Initialization order.\n   */\n  std::list<std::string> order_;\n\n  std::string logging_folder_;\n  std::string plugin_folder_;\n  std::string runtime_folder_;\n  std::string config_folder_;\n  std::string data_folder_;\n  std::string program_;\n  AppInfo appinfo_;\n\n#ifdef FRIEND_TEST\n  friend class ::TestLoader;\n  friend class ::LifecycleTest;\n\n  FRIEND_TEST(::TestStart, StartLogger);\n  FRIEND_TEST(::LifecycleTest, Simple_None);\n  FRIEND_TEST(::LifecycleTest, Simple_AllFunctions);\n  FRIEND_TEST(::LifecycleTest, Simple_Init);\n  FRIEND_TEST(::LifecycleTest, Simple_StartStop);\n  FRIEND_TEST(::LifecycleTest, Simple_StartStopBlocking);\n  FRIEND_TEST(::LifecycleTest, Simple_Start);\n  FRIEND_TEST(::LifecycleTest, Simple_Stop);\n  FRIEND_TEST(::LifecycleTest, Simple_Deinit);\n  FRIEND_TEST(::LifecycleTest, ThreeInstances_NoError);\n  FRIEND_TEST(::LifecycleTest, BothLifecycles_NoError);\n  FRIEND_TEST(::LifecycleTest, OneInstance_NothingPersists_NoError);\n  FRIEND_TEST(::LifecycleTest, OneInstance_NothingPersists_StopFails);\n  FRIEND_TEST(::LifecycleTest, ThreeInstances_InitFails);\n  FRIEND_TEST(::LifecycleTest, BothLifecycles_InitFails);\n  FRIEND_TEST(::LifecycleTest, ThreeInstances_Start1Fails);\n  FRIEND_TEST(::LifecycleTest, ThreeInstances_Start2Fails);\n  FRIEND_TEST(::LifecycleTest, ThreeInstances_Start3Fails);\n  FRIEND_TEST(::LifecycleTest, ThreeInstances_2StartsFail);\n  FRIEND_TEST(::LifecycleTest, ThreeInstances_StopFails);\n  FRIEND_TEST(::LifecycleTest, ThreeInstances_DeinintFails);\n  FRIEND_TEST(::LifecycleTest, ThreeInstances_StartStopDeinitFail);\n  FRIEND_TEST(::LifecycleTest, NoInstances);\n  FRIEND_TEST(::LifecycleTest, EmptyErrorMessage);\n  FRIEND_TEST(::LifecycleTest, send_signals);\n  FRIEND_TEST(::LifecycleTest, send_signals2);\n  FRIEND_TEST(::LifecycleTest, wait_for_stop);\n  FRIEND_TEST(::LifecycleTest, InitThrows);\n  FRIEND_TEST(::LifecycleTest, StartThrows);\n  FRIEND_TEST(::LifecycleTest, StopThrows);\n  FRIEND_TEST(::LifecycleTest, DeinitThrows);\n  FRIEND_TEST(::LifecycleTest, InitThrowsWeird);\n  FRIEND_TEST(::LifecycleTest, StartThrowsWeird);\n  FRIEND_TEST(::LifecycleTest, StopThrowsWeird);\n  FRIEND_TEST(::LifecycleTest, DeinitThrowsWeird);\n  FRIEND_TEST(::LoaderReadTest, Loading);\n#endif\n\n};  // class Loader\n\n}  // namespace mysql_harness\n\nHARNESS_EXPORT\nvoid request_application_shutdown();\n\n#ifdef _WIN32\nHARNESS_EXPORT\nvoid register_ctrl_c_handler();\n#endif\n\n#ifdef FRIEND_TEST\nnamespace unittest_backdoor {\nHARNESS_EXPORT\nvoid set_shutdown_pending(bool shutdown_pending);\n}  // namespace unittest_backdoor\n#endif\n\n#endif /* MYSQL_HARNESS_LOADER_INCLUDED */\n",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/router/src/harness/tests/test_loader_lifecycle.cc": "/*\n  Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.\n\n  This program is free software; you can redistribute it and/or modify\n  it under the terms of the GNU General Public License, version 2.0,\n  as published by the Free Software Foundation.\n\n  This program is also distributed with certain software (including\n  but not limited to OpenSSL) that is licensed under separate terms,\n  as designated in a particular file or component or in included license\n  documentation.  The authors of MySQL hereby grant you an additional\n  permission to link the program and your derivative works with the\n  separately licensed software that they have included with MySQL.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program; if not, write to the Free Software\n  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n*/\n\n////////////////////////////////////////////////////////////////////////////////\n//\n// These unit tests test the harness for proper plugin lifecycle management.\n// They focus on four plugin API functions: init(), start(), stop() and\n// deinit(). A special plugin was written (lifecycle.cc) which is the workhorse\n// of these tests. It has configurable exit strategies (see comments in the\n// source file), which allows us to test different scenarios.\n// Also, another secondary plugin was written (lifecycle2.cc); that one is much\n// simpler and it has an (artificial) dependency on lifecycle.cc plugin. It is\n// used to help in testing initialisation/deinitialisation behaviour.\n//\n// Since we have to shutdown the harness many times, we also test the harness\n// shutdown functionality (signal handling) while testing plugin lifecycle.\n//\n////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////\n//\n// lifecycle test plugins dependency chart:\n//\n//                                           ,--(depends on)--> lifecycle3\n// lifecycle2 --(depends on)--> lifecycle --<\n//                                           `--(depends on)--> magic\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// must have this first, before #includes that rely on it\n#include <gmock/gmock-matchers.h>\n#include <gtest/gtest_prod.h>\n\n#include \"my_config.h\"\n\n////////////////////////////////////////\n// Harness include files\n#include \"exception.h\"\n#include \"lifecycle.h\"\n#include \"mysql/harness/filesystem.h\"\n#include \"mysql/harness/loader.h\"\n#include \"mysql/harness/logging/registry.h\"\n#include \"mysql/harness/plugin.h\"\n#include \"test/helpers.h\"\n#include \"utilities.h\"\n\n////////////////////////////////////////\n// Third-party include files\n#include <gmock/gmock.h>\n#include <gtest/gtest.h>\n\n////////////////////////////////////////\n// Standard include files\n#include <algorithm>\n#include <chrono>\n#include <csignal>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <future>\n#include <iostream>\n#include <sstream>\n#include <stdexcept>\n#include <string>\n#include <thread>\n#include <vector>\n\n// see loader.cc for more info on this define\n#ifndef _WIN32\n#define USE_POSIX_SIGNALS\n#endif\n\n#define USE_DLCLOSE 1\n\n// disable dlclose() when built with lsan\n//\n// clang has __has_feature(address_sanitizer)\n// gcc has __SANITIZE_ADDRESS__\n#if defined(__has_feature)\n#if __has_feature(address_sanitizer)\n#undef USE_DLCLOSE\n#define USE_DLCLOSE 0\n#endif\n#endif\n\n#if defined(__SANITIZE_ADDRESS__) && __SANITIZE_ADDRESS__ == 1\n#undef USE_DLCLOSE\n#define USE_DLCLOSE 0\n#endif\n\n// dlopen/dlclose work differently on Alpine\n#if defined(LINUX_ALPINE)\n#undef USE_DLCLOSE\n#define USE_DLCLOSE 0\n#endif\n\nstatic const std::string kPluginNameLifecycle(\"routertestplugin_lifecycle\");\nstatic const std::string kPluginNameLifecycle2(\"routertestplugin_lifecycle2\");\nstatic const std::string kPluginNameLifecycle3(\"routertestplugin_lifecycle3\");\nstatic const std::string kPluginNameMagic(\"routertestplugin_magic\");\n\nusing mysql_harness::Loader;\nusing mysql_harness::Path;\nusing mysql_harness::Plugin;\nusing mysql_harness::test::LifecyclePluginSyncBus;\nusing ::testing::HasSubstr;\nnamespace ch = std::chrono;\n\n// try increasing these if unit tests fail\nconst int kSleepShutdown = 10;\n\nPath g_here;\n\nclass TestLoader : public Loader {\n public:\n  TestLoader(const std::string &program, mysql_harness::LoaderConfig &config)\n      : Loader(program, config) {\n    unittest_backdoor::set_shutdown_pending(false);\n  }\n\n  void read(std::istream &stream) {\n    config_.Config::read(stream);\n    config_.fill_and_check();\n  }\n\n  // Loader::load_all() with ability to disable functions\n  void load_all(int switches) {\n    Loader::load_all();\n    init_lifecycle_plugin(switches);\n  }\n\n  LifecyclePluginSyncBus &get_msg_bus_from_lifecycle_plugin(\n      const std::string &key) {\n    return *lifecycle_get_bus_from_key_(key);\n  }\n\n private:\n  using lifecycle_init_type = void (*)(int);\n  using lifecycle_get_bus_from_key_type =\n      mysql_harness::test::LifecyclePluginSyncBus *(*)(const std::string &);\n\n  void init_lifecycle_plugin(const int switches) {\n    auto const &plugin_info = plugins_.at(kPluginNameLifecycle);\n\n    auto res = plugin_info.library().symbol(\"lifecycle_init\");\n    if (!res) {\n      FAIL() << res.error() << \", \" << plugin_info.library().error_msg();\n      return;\n    }\n    lifecycle_init_ = reinterpret_cast<lifecycle_init_type>(res.value());\n\n    res = plugin_info.library().symbol(\"lifecycle_get_bus_from_key\");\n    if (!res) {\n      FAIL() << res.error() << \", \" << plugin_info.library().error_msg();\n      return;\n    }\n    lifecycle_get_bus_from_key_ =\n        reinterpret_cast<lifecycle_get_bus_from_key_type>(res.value());\n\n    // override plugin functions as requested\n    lifecycle_init_(switches);\n  }\n\n  lifecycle_init_type lifecycle_init_{};\n  lifecycle_get_bus_from_key_type lifecycle_get_bus_from_key_{};\n};  // class TestLoader\n\nclass BasicConsoleOutputTest : public ::testing::Test {\n protected:\n  void clear_log() {\n    log.str(\"\");\n    log.clear();\n  }\n\n  std::stringstream log;\n\n private:\n  void SetUp() override {\n    std::ostream *log_stream =\n        mysql_harness::logging::get_default_logger_stream();\n\n    orig_log_stream_ = log_stream->rdbuf();\n    log_stream->rdbuf(log.rdbuf());\n  }\n\n  void TearDown() override {\n    if (orig_log_stream_) {\n      std::ostream *log_stream =\n          mysql_harness::logging::get_default_logger_stream();\n      log_stream->rdbuf(orig_log_stream_);\n    }\n  }\n\n  std::streambuf *orig_log_stream_;\n};\n\nclass LifecycleTest : public BasicConsoleOutputTest {\n public:\n  LifecycleTest()\n      : params_{{\"program\", \"harness\"}, {\"prefix\", g_here.c_str()}},\n        config_(params_, std::vector<std::string>(),\n                mysql_harness::Config::allow_keys),\n        loader_(\"harness\", config_) {\n    const std::string test_data_dir =\n        mysql_harness::get_tests_data_dir(g_here.str());\n    config_text_ << \"[DEFAULT]                                      \\n\"\n                    \"logging_folder =                               \\n\"\n                    \"plugin_folder  = \" +\n                        mysql_harness::get_plugin_dir(g_here.str()) + \"\\n\" +\n                        \"runtime_folder = \" + test_data_dir + \"\\n\" +\n                        \"config_folder  = \" + test_data_dir + \"\\n\" +\n                        \"data_folder    = \" + test_data_dir + \"\\n\" +\n                        \"                                               \\n\"\n                        \"[logger]                                       \\n\"\n                        \"level = DEBUG                                  \\n\"\n                        \"                                               \\n\"\n                        \"[\" +\n                        kPluginNameLifecycle3 +\n                        \"]                  \\n\"\n                        \"                                               \\n\"\n                        \"[\" +\n                        kPluginNameMagic +\n                        \"]                       \\n\"\n                        \"suki = magic                                   \\n\"\n                        \"                                               \\n\"\n                        \"[\" +\n                        kPluginNameLifecycle + \":instance1]         \\n\";\n  }\n\n  void init_test(std::istream &config_text, int switches) {\n    loader_.read(config_text);\n    loader_.load_all(switches);\n    clear_log();\n  }\n\n  void init_test_without_lifecycle_plugin(std::istream &config_text) {\n    loader_.read(config_text);\n    loader_.Loader::load_all();\n    clear_log();\n  }\n\n  void refresh_log() {\n    // the getline() loop below runs until EOF, therefore on subsequent calls\n    // we need to clear the EOF flag before we can read again\n    log.clear();\n\n    std::string line;\n    while (std::getline(log, line)) {\n      log_lines_.push_back(line);\n    }\n  }\n\n  // NOTE:\n  // Despite the name, LifecyclePluginSyncBus is additionally used for 2-way\n  // synchronisation (please rename it if you have a better name). This is\n  // because if we freeze_bus(), an attempt to pass another message from plugin\n  // will block it, until we unfreeze_and_wait_for_msg().\n\n  LifecyclePluginSyncBus &msg_bus(const std::string &key) {\n    return loader_.get_msg_bus_from_lifecycle_plugin(key);\n  }\n\n  void freeze_bus(LifecyclePluginSyncBus &bus) {\n    bus.mtx.lock();  // so that we don't miss a signal\n  }\n\n  void unfreeze_and_wait_for_msg(LifecyclePluginSyncBus &bus, const char *msg) {\n    std::unique_lock<std::mutex> lock(bus.mtx, std::adopt_lock);\n\n    // block until we receive message we're interested in\n    bus.cv.wait(lock,\n                [&bus, msg]() { return bus.msg.find(msg) != bus.msg.npos; });\n  }\n\n  long count_in_log(const std::string &needle) {\n    long cnt = 0;\n    for (const std::string &line : log_lines_)\n      if (line.find(needle) != line.npos) cnt++;\n    return cnt;\n  }\n\n  const std::map<std::string, std::string> params_;\n  mysql_harness::LoaderConfig config_;\n  TestLoader loader_;\n  std::stringstream config_text_;\n\n  std::vector<std::string> log_lines_;\n};  // class LifecycleTest\n\nvoid delayed_shutdown() {\n  std::this_thread::sleep_for(ch::milliseconds(kSleepShutdown));\n  request_application_shutdown();\n}\n\nint time_diff(const ch::time_point<ch::steady_clock> &t0,\n              const ch::time_point<ch::steady_clock> &t1) {\n  ch::milliseconds duration = ch::duration_cast<ch::milliseconds>(t1 - t0);\n  return static_cast<int>(duration.count());\n}\n\nvoid run_then_signal_shutdown(const std::function<void()> &l) {\n  ch::time_point<ch::steady_clock> t0 = ch::steady_clock::now();\n  std::thread(delayed_shutdown).detach();\n  l();\n  ch::time_point<ch::steady_clock> t1 = ch::steady_clock::now();\n  EXPECT_LE(kSleepShutdown, time_diff(t0, t1));\n}\n\n////////////////////////////////////////////////////////////////////////////////\n//\n// UNIT TESTS: PLATFORM SPECIFIC STUFF\n//\n////////////////////////////////////////////////////////////////////////////////\n\nTEST(StdLibrary, FutureWaitUntil) {\n  // Here we test undocumented/ambiguous behaviour of std::future::wait_until():\n  // what will be returned when you call it when future is ready BUT\n  // timeout is expired? In principle, both return values are plausible:\n  //\n  //   future_status::ready\n  //   future_status::timeout\n  //\n  // On Ubuntu 14.04, it returns future_status::ready, which seems reasonable.\n  // However to ensure it works all platforms, we have a unit test here to to\n  // guard against a nasty surprise in Loader::main_loop() which relies on this\n  // behaviour.\n\n  // fulfill the promise\n  std::promise<int> p;\n  std::future<int> f = p.get_future();\n  p.set_value(42);\n\n  // set timeout\n  ch::steady_clock::time_point timepoint =\n      ch::steady_clock::now() + ch::milliseconds(10);\n\n  // sleep beyond the timeout\n  std::this_thread::sleep_for(ch::milliseconds(30));\n\n  // wait_until() should return that our future is ready,\n  // regardless of the expired timeout\n  std::future_status status = f.wait_until(timepoint);\n  ASSERT_EQ(std::future_status::ready, status);\n  EXPECT_EQ(42, f.get());\n}\n\n////////////////////////////////////////////////////////////////////////////////\n//\n// UNIT TESTS: SIMPLE\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// 2017.03.24: at the time of writing, this is what the \"meat\" of Loader looked\n// like. In the tests below, load_all() is executed in TestLoader::load_all()\n// (called from init_test()), and run() (either as a whole or in parts)\n// should be called directly from unit tests.\n//\n//   void Loader::start() {\n//     load_all();\n//     std::exception_ptr first_eptr = run();\n//     unload_all();\n//\n//     if (first_eptr) {\n//       std::rethrow_exception(first_eptr);\n//     }\n//   }\n//\n//   void Loader::load_all() {\n//     platform_specific_init();\n//     for (std::pair<const std::string&, std::string> name : available()) {\n//       load(name.first, name.second);\n//     }\n//   }\n//\n//   std::exception_ptr Loader::run() {\n//\n//     // initialize plugins\n//     std::exception_ptr first_eptr = init_all();\n//\n//     // run plugins if initialization didn't fail\n//     if (!first_eptr) {\n//       start_all();  // if start() throws, exception is forwarded to\n//       main_loop() first_eptr = main_loop(); // calls stop_all() before\n//       exiting\n//     }\n//     assert(plugin_start_env_.empty());  // stop_all() should have ran and\n//     cleaned them up\n//\n//     // deinitialize plugins\n//     std::exception_ptr tmp = deinit_all();\n//     if (!first_eptr) {\n//       first_eptr = tmp;\n//     }\n//\n//     // return the first exception that was triggered by an error returned\n//     from\n//     // any plugin function\n//     return first_eptr;\n//   }\n\nTEST_F(LifecycleTest, Simple_None) {\n  using namespace mysql_harness::test::PluginDescriptorFlags;\n  ASSERT_NO_FATAL_FAILURE(\n      init_test(config_text_, NoInit | NoDeinit | NoStart | NoStop));\n\n  EXPECT_EQ(loader_.init_all(), nullptr);\n  loader_.start_all();\n  EXPECT_EQ(loader_.main_loop(), nullptr);\n  EXPECT_EQ(loader_.deinit_all(), nullptr);\n\n  const std::list<std::string> initialized = {\n      \"logger\", kPluginNameMagic, kPluginNameLifecycle3, kPluginNameLifecycle};\n  EXPECT_EQ(initialized, loader_.order_);\n\n  refresh_log();\n  EXPECT_EQ(0, count_in_log(\"lifecycle:all init():begin\"));\n  EXPECT_EQ(0, count_in_log(\"lifecycle:all init():EXIT\"));\n  EXPECT_EQ(0, count_in_log(\"lifecycle:instance1 start():begin\"));\n  EXPECT_EQ(0, count_in_log(\"lifecycle:instance1 start():EXIT\"));\n  EXPECT_EQ(0, count_in_log(\"lifecycle:instance1 stop():begin\"));\n  EXPECT_EQ(0, count_in_log(\"lifecycle:instance1 stop():EXIT\"));\n  EXPECT_EQ(0, count_in_log(\"lifecycle:all deinit():begin\"));\n  EXPECT_EQ(0, count_in_log(\"lifecycle:all deinit():EXIT\"));\n}\n\nTEST_F(LifecycleTest, Simple_AllFunctions) {\n  config_text_ << \"init   = exit           \\n\"\n               << \"start  = exitonstop     \\n\"\n               << \"stop   = exit           \\n\"\n               << \"deinit = exit           \\n\";\n  ASSERT_NO_FATAL_FAILURE(init_test(config_text_, 0));\n  LifecyclePluginSyncBus &bus = msg_bus(\"instance1\");\n\n  EXPECT_EQ(loader_.init_all(), nullptr);\n  freeze_bus(bus);\n  loader_.start_all();\n  unfreeze_and_wait_for_msg(\n      bus, \"lifecycle:instance1 start():EXIT_ON_STOP:sleeping\");\n\n  const std::list<std::string> initialized = {\n      \"logger\", kPluginNameMagic, kPluginNameLifecycle3, kPluginNameLifecycle};\n  EXPECT_EQ(initialized, loader_.order_);\n\n  refresh_log();\n  EXPECT_EQ(1, count_in_log(\"lifecycle:all init():begin\"));\n  EXPECT_EQ(1, count_in_log(\"lifecycle:all init():EXIT.\"));\n  EXPECT_EQ(1, count_in_log(\"lifecycle:instance1 start():begin\"));\n  EXPECT_EQ(1,\n            count_in_log(\"lifecycle:instance1 start():EXIT_ON_STOP:sleeping\"));\n  EXPECT_EQ(0, count_in_log(\"lifecycle:instance1 start():EXIT_ON_STOP:done\"));\n  EXPECT_EQ(0, count_in_log(\"lifecycle:instance1 stop():begin\"));\n  EXPECT_EQ(0, count_in_log(\"lifecycle:instance1 stop():EXIT\"));\n  EXPECT_EQ(0, count_in_log(\"lifecycle:all deinit():begin\"));\n  EXPECT_EQ(0, count_in_log(\"lifecycle:all deinit():EXIT\"));\n\n  // signal shutdown after 10ms, main_loop() should block until then\n  run_then_signal_shutdown([&]() { EXPECT_EQ(loader_.main_loop(), nullptr); });\n\n  refresh_log();\n  EXPECT_EQ(1, count_in_log(\"Shutting down. Stopping all plugins.\"));\n  EXPECT_EQ(1, count_in_log(\"lifecycle:instance1 start():EXIT_ON_STOP:done\"));\n  EXPECT_EQ(1, count_in_log(\"lifecycle:instance1 stop():begin\"));\n  EXPECT_EQ(1, count_in_log(\"lifecycle:instance1 stop():EXIT.\"));\n  EXPECT_EQ(0, count_in_log(\"lifecycle:all deinit():begin\"));\n  EXPECT_EQ(0, count_in_log(\"lifecycle:all deinit():EXIT.\"));\n\n  EXPECT_EQ(loader_.deinit_all(), nullptr);\n\n  refresh_log();\n  EXPECT_EQ(1, count_in_log(\"lifecycle:all deinit():begin\"));\n  EXPECT_EQ(1, count_in_log(\"lifecycle:all deinit():EXIT.\"));\n}\n\nTEST_F(LifecycleTest, Simple_Init) {\n  config_text_ << \"init = exit\\n\";\n  using namespace mysql_harness::test::PluginDescriptorFlags;\n  ASSERT_NO_FATAL_FAILURE(init_test(config_text_, NoStart | NoStop | NoDeinit));\n\n  EXPECT_EQ(loader_.init_all(), nullptr);\n  loader_.start_all();\n  EXPECT_EQ(loader_.main_loop(), nullptr);\n  EXPECT_EQ(loader_.deinit_all(), nullptr);\n\n  const std::list<std::string> initialized = {\n      \"logger\", kPluginNameMagic, kPluginNameLifecycle3, kPluginNameLifecycle};\n  EXPECT_EQ(initialized, loader_.order_);\n\n  refresh_log();\n  EXPECT_EQ(1, count_in_log(\"lifecycle:all init():begin\"));\n  EXPECT_EQ(1, count_in_log(\"lifecycle:all init():EXIT\"));\n  EXPECT_EQ(0, count_in_log(\"lifecycle:instance1 start():begin\"));\n  EXPECT_EQ(0, count_in_log(\"lifecycle:instance1 start():EXIT\"));\n  EXPECT_EQ(0, count_in_log(\"lifecycle:instance1 stop():begin\"));\n  EXPECT_EQ(0, count_in_log(\"lifecycle:instance1 stop():EXIT\"));\n  EXPECT_EQ(0, count_in_log(\"lifecycle:all deinit():begin\"));\n  EXPECT_EQ(0, count_in_log(\"lifecycle:all deinit():EXIT\"));\n}\n\nTEST_F(LifecycleTest, Simple_StartStop) {\n  config_text_ << \"start = exitonstop\\n\";\n  config_text_ << \"stop  = exit\\n\";\n\n  using namespace mysql_harness::test::PluginDescriptorFlags;\n  ASSERT_NO_FATAL_FAILURE(init_test(config_text_, NoInit | NoDeinit));\n  LifecyclePluginSyncBus &bus = msg_bus(\"instance1\");\n\n  EXPECT_EQ(loader_.init_all(), nullptr);\n  freeze_bus(bus);\n  loader_.start_all();\n  unfreeze_and_wait_for_msg(\n      bus, \"lifecycle:instance1 start():EXIT_ON_STOP:sleeping\");\n\n  const std::list<std::string> initialized = {\n      \"logger\", kPluginNameMagic, kPluginNameLifecycle3, kPluginNameLifecycle};\n  EXPECT_EQ(initialized, loader_.order_);\n\n  refresh_log();\n  EXPECT_EQ(0, count_in_log(\"lifecycle:all init():begin\"));\n  EXPECT_EQ(0, count_in_log(\"lifecycle:all init():EXIT.\"));\n  EXPECT_EQ(1, count_in_log(\"lifecycle:instance1 start():begin\"));\n  EXPECT_EQ(1,\n            count_in_log(\"lifecycle:instance1 start():EXIT_ON_STOP:sleeping\"));\n  EXPECT_EQ(0, count_in_log(\"lifecycle:instance1 start():EXIT_ON_STOP:done\"));\n  EXPECT_EQ(0, count_in_log(\"lifecycle:instance1 stop():begin\"));\n  EXPECT_EQ(0, count_in_log(\"lifecycle:instance1 stop():EXIT\"));\n  EXPECT_EQ(0, count_in_log(\"lifecycle:all deinit():begin\"));\n  EXPECT_EQ(0, count_in_log(\"lifecycle:all deinit():EXIT\"));\n\n  // signal shutdown after 10ms, main_loop() should block until then\n  run_then_signal_shutdown([&]() { EXPECT_EQ(loader_.main_loop(), nullptr); });\n\n  EXPECT_EQ(loader_.deinit_all(), nullptr);\n\n  refresh_log();\n  EXPECT_EQ(1, count_in_log(\"Shutting down. Stopping all plugins.\"));\n  EXPECT_EQ(1, count_in_log(\"lifecycle:instance1 start():EXIT_ON_STOP:done\"));\n  EXPECT_EQ(1, count_in_log(\"lifecycle:instance1 stop():begin\"));\n  EXPECT_EQ(1, count_in_log(\"lifecycle:instance1 stop():EXIT.\"));\n  EXPECT_EQ(0, count_in_log(\"lifecycle:all deinit():begin\"));\n  EXPECT_EQ(0, count_in_log(\"lifecycle:all deinit():EXIT.\"));\n}\n\nTEST_F(LifecycleTest, Simple_StartStopBlocking) {\n  // Same test as Simple_StartStop, but start() uses blocking API call to wait\n  // until told to shut down, vs actively polling the \"running\" flag\n\n  config_text_ << \"start = exitonstop_s\\n\";  // <--- note the \"_s\" postfix\n  config_text_ << \"stop  = exit\\n\";\n\n  using namespace mysql_harness::test::PluginDescriptorFlags;\n  ASSERT_NO_FATAL_FAILURE(init_test(config_text_, NoInit | NoDeinit));\n  LifecyclePluginSyncBus &bus = msg_bus(\"instance1\");\n\n  EXPECT_EQ(loader_.init_all(), nullptr);\n  freeze_bus(bus);\n  loader_.start_all();\n  unfreeze_and_wait_for_msg(\n      bus, \"lifecycle:instance1 start():EXIT_ON_STOP_SYNC:sleeping\");\n\n  const std::list<std::string> initialized = {\n      \"logger\", kPluginNameMagic, kPluginNameLifecycle3, kPluginNameLifecycle};\n  EXPECT_EQ(initialized, loader_.order_);\n\n  refresh_log();\n  EXPECT_EQ(0, count_in_log(\"lifecycle:all init():begin\"));\n  EXPECT_EQ(0, count_in_log(\"lifecycle:all init():EXIT.\"));\n  EXPECT_EQ(1, count_in_log(\"lifecycle:instance1 start():begin\"));\n  EXPECT_EQ(1, count_in_log(\n                   \"lifecycle:instance1 start():EXIT_ON_STOP_SYNC:sleeping\"));\n  EXPECT_EQ(0,\n            count_in_log(\"lifecycle:instance1 start():EXIT_ON_STOP_SYNC:done\"));\n  EXPECT_EQ(0, count_in_log(\"lifecycle:instance1 stop():begin\"));\n  EXPECT_EQ(0, count_in_log(\"lifecycle:instance1 stop():EXIT\"));\n  EXPECT_EQ(0, count_in_log(\"lifecycle:all deinit():begin\"));\n  EXPECT_EQ(0, count_in_log(\"lifecycle:all deinit():EXIT\"));\n\n  // signal shutdown after 10ms, main_loop() should block until then\n  run_then_signal_shutdown([&]() { EXPECT_EQ(loader_.main_loop(), nullptr); });\n\n  EXPECT_EQ(loader_.deinit_all(), nullptr);\n\n  refresh_log();\n  EXPECT_EQ(1, count_in_log(\"Shutting down. Stopping all plugins.\"));\n  EXPECT_EQ(1,\n            count_in_log(\"lifecycle:instance1 start():EXIT_ON_STOP_SYNC:done\"));\n  EXPECT_EQ(1, count_in_log(\"lifecycle:instance1 stop():begin\"));\n  EXPECT_EQ(1, count_in_log(\"lifecycle:instance1 stop():EXIT.\"));\n  EXPECT_EQ(0, count_in_log(\"lifecycle:all deinit():begin\"));\n  EXPECT_EQ(0, count_in_log(\"lifecycle:all deinit():EXIT.\"));\n}\n\nTEST_F(LifecycleTest, Simple_Start) {\n  config_text_ << \"start = exitonstop\\n\";\n\n  using namespace mysql_harness::test::PluginDescriptorFlags;\n  ASSERT_NO_FATAL_FAILURE(init_test(config_text_, NoInit | NoStop | NoDeinit));\n  LifecyclePluginSyncBus &bus = msg_bus(\"instance1\");\n\n  EXPECT_EQ(loader_.init_all(), nullptr);\n  freeze_bus(bus);\n  loader_.start_all();\n  unfreeze_and_wait_for_msg(\n      bus, \"lifecycle:instance1 start():EXIT_ON_STOP:sleeping\");\n\n  const std::list<std::string> initialized = {\n      \"logger\", kPluginNameMagic, kPluginNameLifecycle3, kPluginNameLifecycle};\n  EXPECT_EQ(initialized, loader_.order_);\n\n  refresh_log();\n  EXPECT_EQ(0, count_in_log(\"lifecycle:all init():begin\"));\n  EXPECT_EQ(0, count_in_log(\"lifecycle:all init():EXIT.\"));\n  EXPECT_EQ(1, count_in_log(\"lifecycle:instance1 start():begin\"));\n  EXPECT_EQ(1,\n            count_in_log(\"lifecycle:instance1 start():EXIT_ON_STOP:sleeping\"));\n  EXPECT_EQ(0, count_in_log(\"lifecycle:instance1 start():EXIT_ON_STOP:done\"));\n  EXPECT_EQ(0, count_in_log(\"lifecycle:instance1 stop():begin\"));\n  EXPECT_EQ(0, count_in_log(\"lifecycle:instance1 stop():EXIT\"));\n  EXPECT_EQ(0, count_in_log(\"lifecycle:all deinit():begin\"));\n  EXPECT_EQ(0, count_in_log(\"lifecycle:all deinit():EXIT\"));\n\n  // signal shutdown after 10ms, main_loop() should block until then\n  run_then_signal_shutdown([&]() { EXPECT_EQ(loader_.main_loop(), nullptr); });\n\n  EXPECT_EQ(loader_.deinit_all(), nullptr);\n\n  refresh_log();\n  EXPECT_EQ(1, count_in_log(\"Shutting down. Stopping all plugins.\"));\n  EXPECT_EQ(1, count_in_log(\"lifecycle:instance1 start():EXIT_ON_STOP:done\"));\n  EXPECT_EQ(0, count_in_log(\"lifecycle:instance1 stop():begin\"));\n  EXPECT_EQ(0, count_in_log(\"lifecycle:instance1 stop():EXIT.\"));\n  EXPECT_EQ(0, count_in_log(\"lifecycle:all deinit():begin\"));\n  EXPECT_EQ(0, count_in_log(\"lifecycle:all deinit():EXIT.\"));\n}\n\nTEST_F(LifecycleTest, Simple_Stop) {\n  config_text_ << \"stop = exit\\n\";\n  using namespace mysql_harness::test::PluginDescriptorFlags;\n  ASSERT_NO_FATAL_FAILURE(init_test(config_text_, NoInit | NoStart | NoDeinit));\n\n  EXPECT_EQ(loader_.init_all(), nullptr);\n  loader_.start_all();\n\n  const std::list<std::string> initialized = {\n      \"logger\", kPluginNameMagic, kPluginNameLifecycle3, kPluginNameLifecycle};\n  EXPECT_EQ(initialized, loader_.order_);\n\n  refresh_log();\n  EXPECT_EQ(0, count_in_log(\"lifecycle:all init():begin\"));\n  EXPECT_EQ(0, count_in_log(\"lifecycle:all init():EXIT\"));\n  EXPECT_EQ(0, count_in_log(\"lifecycle:instance1 start():begin\"));\n  EXPECT_EQ(0, count_in_log(\"lifecycle:instance1 start():EXIT\"));\n  EXPECT_EQ(0, count_in_log(\"lifecycle:instance1 stop():begin\"));\n  EXPECT_EQ(0, count_in_log(\"lifecycle:instance1 stop():EXIT\"));\n  EXPECT_EQ(0, count_in_log(\"lifecycle:all deinit():begin\"));\n  EXPECT_EQ(0, count_in_log(\"lifecycle:all deinit():EXIT\"));\n\n  EXPECT_EQ(loader_.main_loop(), nullptr);\n\n  refresh_log();\n  EXPECT_EQ(1, count_in_log(\"lifecycle:instance1 stop():begin\"));\n  EXPECT_EQ(1, count_in_log(\"lifecycle:instance1 stop():EXIT\"));\n  EXPECT_EQ(0, count_in_log(\"lifecycle:all deinit():begin\"));\n  EXPECT_EQ(0, count_in_log(\"lifecycle:all deinit():EXIT\"));\n\n  EXPECT_EQ(loader_.deinit_all(), nullptr);\n\n  refresh_log();\n  EXPECT_EQ(0, count_in_log(\"lifecycle:all deinit():begin\"));\n  EXPECT_EQ(0, count_in_log(\"lifecycle:all deinit():EXIT\"));\n}\n\nTEST_F(LifecycleTest, Simple_Deinit) {\n  config_text_ << \"deinit = exit\\n\";\n  using namespace mysql_harness::test::PluginDescriptorFlags;\n  ASSERT_NO_FATAL_FAILURE(init_test(config_text_, NoInit | NoStart | NoStop));\n\n  EXPECT_EQ(loader_.init_all(), nullptr);\n  loader_.start_all();\n  EXPECT_EQ(loader_.main_loop(), nullptr);\n\n  const std::list<std::string> initialized = {\n      \"logger\", kPluginNameMagic, kPluginNameLifecycle3, kPluginNameLifecycle};\n  EXPECT_EQ(initialized, loader_.order_);\n\n  refresh_log();\n  EXPECT_EQ(0, count_in_log(\"lifecycle:all init():begin\"));\n  EXPECT_EQ(0, count_in_log(\"lifecycle:all init():EXIT\"));\n  EXPECT_EQ(0, count_in_log(\"lifecycle:instance1 start():begin\"));\n  EXPECT_EQ(0, count_in_log(\"lifecycle:instance1 start():EXIT\"));\n  EXPECT_EQ(0, count_in_log(\"lifecycle:instance1 stop():begin\"));\n  EXPECT_EQ(0, count_in_log(\"lifecycle:instance1 stop():EXIT\"));\n  EXPECT_EQ(0, count_in_log(\"lifecycle:all deinit():begin\"));\n  EXPECT_EQ(0, count_in_log(\"lifecycle:all deinit():EXIT\"));\n\n  EXPECT_EQ(loader_.deinit_all(), nullptr);\n\n  refresh_log();\n  EXPECT_EQ(1, count_in_log(\"lifecycle:all deinit():begin\"));\n  EXPECT_EQ(1, count_in_log(\"lifecycle:all deinit():EXIT\"));\n}\n\n////////////////////////////////////////////////////////////////////////////////\n//\n// UNIT TESTS: COMPLEX\n//\n////////////////////////////////////////////////////////////////////////////////\n\nTEST_F(LifecycleTest, ThreeInstances_NoError) {\n  // In this testcase we do thorough checking, and provide elaborate comments.\n  // We won't do it in other tests, so read this one for better understanding\n  // of others.\n\n  // init() and deinit() config is taken from first instance. This is because\n  // init() and deinit() run only once per plugin, not per plugin instance.\n  config_text_ << \"init   = exit           \\n\"\n               << \"start  = exitonstop     \\n\"\n               << \"stop   = exit           \\n\"\n               << \"deinit = exit           \\n\"\n               << \"                        \\n\"\n               << \"[\" + kPluginNameLifecycle + \":instance2]\\n\"\n               << \"start  = exitonstop     \\n\"\n               << \"stop   = exit           \\n\"\n               << \"                        \\n\"\n               << \"[\" + kPluginNameLifecycle + \":instance3]\\n\"\n               << \"start  = exitonstop     \\n\"\n               << \"stop   = exit           \\n\";\n  using namespace mysql_harness::test::PluginDescriptorFlags;\n  ASSERT_NO_FATAL_FAILURE(init_test(config_text_, 0));\n\n  // signal shutdown after 10ms, run() should block until then\n  run_then_signal_shutdown([&]() { loader_.run(); });\n\n  // all 3 plugins should have remained on the list of \"to be deinitialized\",\n  // since they all should have initialized properly\n  const std::list<std::string> initialized = {\n      \"logger\", kPluginNameMagic, kPluginNameLifecycle3, kPluginNameLifecycle};\n  EXPECT_EQ(initialized, loader_.order_);\n\n  refresh_log();\n\n  // initialisation proceeds in defined order\n  EXPECT_EQ(1, count_in_log(\"Initializing all plugins.\"));\n  EXPECT_EQ(1,\n            count_in_log(\"  plugin '\" + kPluginNameMagic + \"' initializing\"));\n  EXPECT_EQ(1,\n            count_in_log(\"  plugin '\" + kPluginNameMagic + \"' init exit ok\"));\n  EXPECT_EQ(\n      1, count_in_log(\"  plugin '\" + kPluginNameLifecycle3 + \"' initializing\"));\n  EXPECT_EQ(\n      1, count_in_log(\"  plugin '\" + kPluginNameLifecycle3 + \"' init exit ok\"));\n  EXPECT_EQ(\n      1, count_in_log(\"  plugin '\" + kPluginNameLifecycle + \"' initializing\"));\n  EXPECT_EQ(\n      1, count_in_log(\"  plugin '\" + kPluginNameLifecycle + \"' init exit ok\"));\n\n  // plugins may be started in arbitrary order (they run in separate threads)\n  EXPECT_EQ(1, count_in_log(\"Starting all plugins.\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle3 +\n                            \":' doesn't implement start()\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle +\n                            \":instance1' starting\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle +\n                            \":instance2' starting\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle +\n                            \":instance3' starting\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameMagic + \":' starting\"));\n  EXPECT_EQ(1,\n            count_in_log(\"  plugin '\" + kPluginNameMagic + \":' start exit ok\"));\n\n  // similarly, they may stop in arbitrary order\n  EXPECT_EQ(1, count_in_log(\"Shutting down. Stopping all plugins.\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle +\n                            \":instance1' stopping\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle +\n                            \":instance1' stop exit ok\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle +\n                            \":instance2' stopping\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle +\n                            \":instance2' stop exit ok\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle +\n                            \":instance3' stopping\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle +\n                            \":instance3' stop exit ok\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle3 +\n                            \":' doesn't implement stop()\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameMagic +\n                            \":' doesn't implement stop()\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle +\n                            \":instance2' start exit ok\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle +\n                            \":instance3' start exit ok\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle +\n                            \":instance1' start exit ok\"));\n\n  // deinitializasation proceeds in reverse order of initialisation\n  EXPECT_EQ(1, count_in_log(\"Deinitializing all plugins.\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle +\n                            \"' deinitializing\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle +\n                            \"' deinit exit ok\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle3 +\n                            \"' deinitializing\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle3 +\n                            \"' deinit exit ok\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameMagic +\n                            \"' doesn't implement deinit()\"));\n\n  // this is a sunny day scenario, nothing should fail\n  EXPECT_EQ(0, count_in_log(\"failed\"));\n\n  // failure messages would look like this:\n  // init()   -> \"plugin 'lifecycle' init failed: <message>\"\n  // start()  -> \"plugin 'lifecycle:instance1' start terminated with exception:\n  // <message>\" stop()   -> \"plugin 'lifecycle:instance1' stop failed:\n  // <message>\" deinit() -> \"plugin 'lifecycle' deinit failed: <message>\"\n}\n\nTEST_F(LifecycleTest, BothLifecycles_NoError) {\n  config_text_ << \"init   = exit           \\n\"\n               << \"start  = exitonstop     \\n\"\n               << \"stop   = exit           \\n\"\n               << \"deinit = exit           \\n\"\n               << \"                        \\n\"\n               << \"[\" + kPluginNameLifecycle2 + \"]\\n\";\n  using namespace mysql_harness::test::PluginDescriptorFlags;\n  ASSERT_NO_FATAL_FAILURE(init_test(config_text_, 0));\n\n  // signal shutdown after 10ms, run() should block until then\n  run_then_signal_shutdown([&]() { loader_.run(); });\n\n  const std::list<std::string> initialized = {\n      \"logger\", kPluginNameMagic, kPluginNameLifecycle3, kPluginNameLifecycle,\n      kPluginNameLifecycle2};\n  EXPECT_EQ(initialized, loader_.order_);\n\n  refresh_log();\n\n  EXPECT_EQ(1, count_in_log(\"Initializing all plugins.\"));\n  EXPECT_EQ(1,\n            count_in_log(\"  plugin '\" + kPluginNameMagic + \"' init exit ok\"));\n  EXPECT_EQ(\n      1, count_in_log(\"  plugin '\" + kPluginNameLifecycle3 + \"' init exit ok\"));\n  EXPECT_EQ(\n      1, count_in_log(\"  plugin '\" + kPluginNameLifecycle + \"' init exit ok\"));\n  EXPECT_EQ(\n      1, count_in_log(\"  plugin '\" + kPluginNameLifecycle2 + \"' init exit ok\"));\n\n  EXPECT_EQ(1, count_in_log(\"Starting all plugins.\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle3 +\n                            \":' doesn't implement start()\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle +\n                            \":instance1' starting\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle2 +\n                            \":' start exit ok\"));\n  EXPECT_EQ(1,\n            count_in_log(\"  plugin '\" + kPluginNameMagic + \":' start exit ok\"));\n\n  EXPECT_EQ(1, count_in_log(\"Shutting down. Stopping all plugins.\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle +\n                            \":instance1' stop exit ok\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle2 +\n                            \":' stop exit ok\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle3 +\n                            \":' doesn't implement stop()\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameMagic +\n                            \":' doesn't implement stop()\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle +\n                            \":instance1' start exit ok\"));\n\n  EXPECT_EQ(1, count_in_log(\"Deinitializing all plugins.\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle2 +\n                            \"' deinit exit ok\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle +\n                            \"' deinit exit ok\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle3 +\n                            \"' deinit exit ok\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameMagic +\n                            \"' doesn't implement deinit()\"));\n\n  EXPECT_EQ(0, count_in_log(\"failed\"));\n}\n\nTEST_F(LifecycleTest, OneInstance_NothingPersists_NoError) {\n  config_text_ << \"init   = exit           \\n\"\n               << \"start  = exit           \\n\"\n               << \"stop   = exit           \\n\"\n               << \"deinit = exit           \\n\";\n  using namespace mysql_harness::test::PluginDescriptorFlags;\n  ASSERT_NO_FATAL_FAILURE(init_test(config_text_, 0));\n\n  // Router should just shut down on it's own, since there's nothing to run\n  // (all plugin start() functions just exit)\n  loader_.run();\n\n  refresh_log();\n\n  EXPECT_EQ(1, count_in_log(\"Initializing all plugins.\"));\n  EXPECT_EQ(1,\n            count_in_log(\"  plugin '\" + kPluginNameMagic + \"' init exit ok\"));\n  EXPECT_EQ(\n      1, count_in_log(\"  plugin '\" + kPluginNameLifecycle3 + \"' init exit ok\"));\n  EXPECT_EQ(\n      1, count_in_log(\"  plugin '\" + kPluginNameLifecycle + \"' init exit ok\"));\n\n  EXPECT_EQ(1, count_in_log(\"Starting all plugins.\"));\n  EXPECT_EQ(1,\n            count_in_log(\"  plugin '\" + kPluginNameMagic + \":' start exit ok\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle3 +\n                            \":' doesn't implement start()\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle +\n                            \":instance1' starting\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle +\n                            \":instance1' start exit ok\"));\n\n  EXPECT_EQ(1, count_in_log(\"Shutting down. Stopping all plugins.\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle +\n                            \":instance1' stop exit ok\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle3 +\n                            \":' doesn't implement stop()\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameMagic +\n                            \":' doesn't implement stop()\"));\n\n  EXPECT_EQ(1, count_in_log(\"Deinitializing all plugins.\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle +\n                            \"' deinit exit ok\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle3 +\n                            \"' deinit exit ok\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameMagic +\n                            \"' doesn't implement deinit()\"));\n\n  EXPECT_EQ(0, count_in_log(\"failed\"));\n}\n\nTEST_F(LifecycleTest, OneInstance_NothingPersists_StopFails) {\n  config_text_ << \"init   = exit           \\n\"\n               << \"start  = exit           \\n\"\n               << \"stop   = error          \\n\"\n               << \"deinit = exit           \\n\";\n  using namespace mysql_harness::test::PluginDescriptorFlags;\n  ASSERT_NO_FATAL_FAILURE(init_test(config_text_, 0));\n\n  // Router should just shut down on it's own, since there's nothing to run\n  // (all plugin start() functions just exit)\n  try {\n    std::exception_ptr e = loader_.run();\n    if (e) std::rethrow_exception(e);\n    FAIL() << \"stop() should throw std::runtime_error\";\n  } catch (const std::runtime_error &e) {\n    EXPECT_STREQ(\"lifecycle:instance1 stop(): I'm returning error!\", e.what());\n  } catch (...) {\n    FAIL() << \"stop() should throw std::runtime_error\";\n  }\n\n  refresh_log();\n\n  EXPECT_EQ(1, count_in_log(\"Initializing all plugins.\"));\n  EXPECT_EQ(1,\n            count_in_log(\"  plugin '\" + kPluginNameMagic + \"' init exit ok\"));\n  EXPECT_EQ(\n      1, count_in_log(\"  plugin '\" + kPluginNameLifecycle3 + \"' init exit ok\"));\n  EXPECT_EQ(\n      1, count_in_log(\"  plugin '\" + kPluginNameLifecycle + \"' init exit ok\"));\n\n  EXPECT_EQ(1, count_in_log(\"Starting all plugins.\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle3 +\n                            \":' doesn't implement start()\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle +\n                            \":instance1' starting\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle +\n                            \":instance1' start exit ok\"));\n  EXPECT_EQ(1,\n            count_in_log(\"  plugin '\" + kPluginNameMagic + \":' start exit ok\"));\n\n  EXPECT_EQ(1, count_in_log(\"Shutting down. Stopping all plugins.\"));\n  EXPECT_EQ(1,\n            count_in_log(\"  plugin '\" + kPluginNameLifecycle +\n                         \":instance1' stop failed: \"\n                         \"lifecycle:instance1 stop(): I'm returning error!\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle3 +\n                            \":' doesn't implement stop()\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameMagic +\n                            \":' doesn't implement stop()\"));\n\n  EXPECT_EQ(1, count_in_log(\"Deinitializing all plugins.\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle +\n                            \"' deinit exit ok\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle3 +\n                            \"' deinit exit ok\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameMagic +\n                            \"' doesn't implement deinit()\"));\n}\n\nTEST_F(LifecycleTest, ThreeInstances_InitFails) {\n  config_text_ << \"init   = error          \\n\"\n               << \"start  = exitonstop     \\n\"\n               << \"stop   = exit           \\n\"\n               << \"deinit = exit           \\n\"\n               << \"                        \\n\"\n               << \"[\" + kPluginNameLifecycle + \":instance2]   \\n\"\n               << \"start  = exitonstop     \\n\"\n               << \"stop   = exit           \\n\"\n               << \"                        \\n\"\n               << \"[\" + kPluginNameLifecycle + \":instance3]   \\n\"\n               << \"start  = exitonstop     \\n\"\n               << \"stop   = exit           \\n\";\n  using namespace mysql_harness::test::PluginDescriptorFlags;\n  ASSERT_NO_FATAL_FAILURE(init_test(config_text_, 0));\n\n  try {\n    std::exception_ptr e = loader_.run();\n    if (e) std::rethrow_exception(e);\n    FAIL() << \"init() should throw std::runtime_error\";\n  } catch (const std::runtime_error &e) {\n    EXPECT_STREQ(\"lifecycle:all init(): I'm returning error!\", e.what());\n  } catch (...) {\n    FAIL() << \"init() should throw std::runtime_error\";\n  }\n\n  // lifecycle should not be on the list of to-be-deinitialized, since it\n  // failed initialisation\n  const std::list<std::string> initialized = {\"logger\", kPluginNameMagic,\n                                              kPluginNameLifecycle3};\n  EXPECT_EQ(initialized, loader_.order_);\n\n  refresh_log();\n\n  // lifecycle2 should not be initialized\n  EXPECT_EQ(1, count_in_log(\"Initializing all plugins.\"));\n  EXPECT_EQ(1,\n            count_in_log(\"  plugin '\" + kPluginNameMagic + \"' init exit ok\"));\n  EXPECT_EQ(\n      1, count_in_log(\"  plugin '\" + kPluginNameLifecycle3 + \"' init exit ok\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle +\n                            \"' init failed: \"\n                            \"lifecycle:all init(): I'm returning error!\"));\n  // start() and stop() shouldn't run\n  EXPECT_EQ(0, count_in_log(\"Starting all plugins.\"));\n  EXPECT_EQ(0, count_in_log(\"Shutting down. Stopping all plugins.\"));\n\n  // lifecycle2 should not be deinintialized\n  EXPECT_EQ(1, count_in_log(\"Deinitializing all plugins.\"));\n  EXPECT_EQ(0, count_in_log(\"  plugin '\" + kPluginNameLifecycle +\n                            \"' deinit exit ok\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle3 +\n                            \"' deinit exit ok\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameMagic +\n                            \"' doesn't implement deinit()\"));\n}\n\nTEST_F(LifecycleTest, BothLifecycles_InitFails) {\n  config_text_ << \"init   = error          \\n\"\n               << \"start  = exitonstop     \\n\"\n               << \"stop   = exit           \\n\"\n               << \"deinit = exit           \\n\"\n               << \"                        \\n\"\n               << \"[\" + kPluginNameLifecycle2 + \"]            \\n\";\n  using namespace mysql_harness::test::PluginDescriptorFlags;\n  ASSERT_NO_FATAL_FAILURE(init_test(config_text_, 0));\n\n  try {\n    std::exception_ptr e = loader_.run();\n    if (e) std::rethrow_exception(e);\n    FAIL() << \"init() should throw std::runtime_error\";\n  } catch (const std::runtime_error &e) {\n    EXPECT_STREQ(\"lifecycle:all init(): I'm returning error!\", e.what());\n  } catch (...) {\n    FAIL() << \"init() should throw std::runtime_error\";\n  }\n\n  // lifecycle should not be on the list of to-be-deinitialized, since it\n  // failed initialisation; neither should lifecycle2, because it never reached\n  // initialisation phase\n  const std::list<std::string> initialized = {\"logger\", kPluginNameMagic,\n                                              kPluginNameLifecycle3};\n  EXPECT_EQ(initialized, loader_.order_);\n\n  refresh_log();\n\n  // lifecycle2 should not be initialized\n  EXPECT_EQ(1, count_in_log(\"Initializing all plugins.\"));\n  EXPECT_EQ(1,\n            count_in_log(\"  plugin '\" + kPluginNameMagic + \"' init exit ok\"));\n  EXPECT_EQ(\n      1, count_in_log(\"  plugin '\" + kPluginNameLifecycle3 + \"' init exit ok\"));\n  EXPECT_EQ(\n      1, count_in_log(\"  plugin '\" + kPluginNameLifecycle + \"' initializing\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle +\n                            \"' init failed: \"\n                            \"lifecycle:all init(): I'm returning error!\"));\n  EXPECT_EQ(\n      0, count_in_log(\"  plugin \" + kPluginNameLifecycle2 + \"' initializing\"));\n\n  // start() and stop() shouldn't run\n  EXPECT_EQ(0, count_in_log(\"Starting all plugins.\"));\n  EXPECT_EQ(0, count_in_log(\"Shutting down. Stopping all plugins.\"));\n\n  // lifecycle2 should not be deinintialized\n  EXPECT_EQ(1, count_in_log(\"Deinitializing all plugins.\"));\n  EXPECT_EQ(0, count_in_log(\"  plugin \" + kPluginNameLifecycle2 +\n                            \"' deinitializing\"));\n  EXPECT_EQ(0, count_in_log(\"  plugin '\" + kPluginNameLifecycle +\n                            \"' deinit exit ok\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle3 +\n                            \"' deinit exit ok\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameMagic +\n                            \"' doesn't implement deinit()\"));\n}\n\nTEST_F(LifecycleTest, ThreeInstances_Start1Fails) {\n  config_text_ << \"init   = exit           \\n\"\n               << \"start  = error          \\n\"\n               << \"stop   = exit           \\n\"\n               << \"deinit = exit           \\n\"\n               << \"                        \\n\"\n               << \"[\" + kPluginNameLifecycle + \":instance2]   \\n\"\n               << \"start  = exit           \\n\"\n               << \"stop   = exit           \\n\"\n               << \"                        \\n\"\n               << \"[\" + kPluginNameLifecycle + \":instance3]   \\n\"\n               << \"start  = exitonstop     \\n\"\n               << \"stop   = exit           \\n\";\n  using namespace mysql_harness::test::PluginDescriptorFlags;\n  ASSERT_NO_FATAL_FAILURE(init_test(config_text_, 0));\n\n  try {\n    std::exception_ptr e = loader_.run();\n    if (e) std::rethrow_exception(e);\n    FAIL() << \"start() should throw std::runtime_error\";\n  } catch (const std::runtime_error &e) {\n    EXPECT_STREQ(\"lifecycle:instance1 start(): I'm returning error!\", e.what());\n  } catch (...) {\n    FAIL() << \"start() should throw std::runtime_error\";\n  }\n\n  const std::list<std::string> initialized = {\n      \"logger\", kPluginNameMagic, kPluginNameLifecycle3, kPluginNameLifecycle};\n  EXPECT_EQ(initialized, loader_.order_);\n\n  refresh_log();\n\n  EXPECT_EQ(1, count_in_log(\"Initializing all plugins.\"));\n\n  EXPECT_EQ(1, count_in_log(\"Starting all plugins.\"));\n  EXPECT_EQ(1,\n            count_in_log(\"  plugin '\" + kPluginNameMagic + \":' start exit ok\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle3 +\n                            \":' doesn't implement start()\"));\n  EXPECT_EQ(1,\n            count_in_log(\"  plugin '\" + kPluginNameLifecycle +\n                         \":instance1' start failed: \"\n                         \"lifecycle:instance1 start(): I'm returning error!\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle +\n                            \":instance2' starting\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle +\n                            \":instance3' starting\"));\n\n  EXPECT_EQ(1, count_in_log(\"Shutting down. Stopping all plugins.\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameMagic +\n                            \":' doesn't implement stop()\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle3 +\n                            \":' doesn't implement stop()\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle +\n                            \":instance2' stop exit ok\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle +\n                            \":instance3' stop exit ok\"));\n\n  EXPECT_EQ(1, count_in_log(\"Deinitializing all plugins.\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle +\n                            \"' deinit exit ok\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle3 +\n                            \"' deinit exit ok\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameMagic +\n                            \"' doesn't implement deinit()\"));\n}\n\nTEST_F(LifecycleTest, ThreeInstances_Start2Fails) {\n  config_text_ << \"init   = exit           \\n\"\n               << \"start  = exit           \\n\"\n               << \"stop   = exit           \\n\"\n               << \"deinit = exit           \\n\"\n               << \"                        \\n\"\n               << \"[\" + kPluginNameLifecycle + \":instance2]   \\n\"\n               << \"start  = error          \\n\"\n               << \"stop   = exit           \\n\"\n               << \"                        \\n\"\n               << \"[\" + kPluginNameLifecycle + \":instance3]   \\n\"\n               << \"start  = exitonstop     \\n\"\n               << \"stop   = exit           \\n\";\n  using namespace mysql_harness::test::PluginDescriptorFlags;\n  ASSERT_NO_FATAL_FAILURE(init_test(config_text_, 0));\n\n  try {\n    std::exception_ptr e = loader_.run();\n    if (e) std::rethrow_exception(e);\n    FAIL() << \"start() should throw std::runtime_error\";\n  } catch (const std::runtime_error &e) {\n    EXPECT_STREQ(\"lifecycle:instance2 start(): I'm returning error!\", e.what());\n  } catch (...) {\n    FAIL() << \"start() should throw std::runtime_error\";\n  }\n\n  const std::list<std::string> initialized = {\n      \"logger\", kPluginNameMagic, kPluginNameLifecycle3, kPluginNameLifecycle};\n  EXPECT_EQ(initialized, loader_.order_);\n\n  refresh_log();\n\n  EXPECT_EQ(1, count_in_log(\"Initializing all plugins.\"));\n\n  EXPECT_EQ(1, count_in_log(\"Starting all plugins.\"));\n  EXPECT_EQ(1,\n            count_in_log(\"  plugin '\" + kPluginNameMagic + \":' start exit ok\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle3 +\n                            \":' doesn't implement start()\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle +\n                            \":instance1' starting\"));\n  EXPECT_EQ(1,\n            count_in_log(\"  plugin '\" + kPluginNameLifecycle +\n                         \":instance2' start failed: \"\n                         \"lifecycle:instance2 start(): I'm returning error!\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle +\n                            \":instance3' starting\"));\n\n  EXPECT_EQ(1, count_in_log(\"Shutting down. Stopping all plugins.\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameMagic +\n                            \":' doesn't implement stop()\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle3 +\n                            \":' doesn't implement stop()\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle +\n                            \":instance1' stop exit ok\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle +\n                            \":instance3' stop exit ok\"));\n\n  EXPECT_EQ(1, count_in_log(\"Deinitializing all plugins.\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle +\n                            \"' deinit exit ok\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle3 +\n                            \"' deinit exit ok\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameMagic +\n                            \"' doesn't implement deinit()\"));\n}\n\nTEST_F(LifecycleTest, ThreeInstances_Start3Fails) {\n  config_text_ << \"init   = exit           \\n\"\n               << \"start  = exit           \\n\"\n               << \"stop   = exit           \\n\"\n               << \"deinit = exit           \\n\"\n               << \"                        \\n\"\n               << \"[\" + kPluginNameLifecycle + \":instance2]   \\n\"\n               << \"start  = exitonstop     \\n\"\n               << \"stop   = exit           \\n\"\n               << \"                        \\n\"\n               << \"[\" + kPluginNameLifecycle + \":instance3]   \\n\"\n               << \"start  = error          \\n\"\n               << \"stop   = exit           \\n\";\n  using namespace mysql_harness::test::PluginDescriptorFlags;\n  ASSERT_NO_FATAL_FAILURE(init_test(config_text_, 0));\n\n  try {\n    std::exception_ptr e = loader_.run();\n    if (e) std::rethrow_exception(e);\n    FAIL() << \"start() should throw std::runtime_error\";\n  } catch (const std::runtime_error &e) {\n    EXPECT_STREQ(\"lifecycle:instance3 start(): I'm returning error!\", e.what());\n  } catch (...) {\n    FAIL() << \"start() should throw std::runtime_error\";\n  }\n\n  const std::list<std::string> initialized = {\n      \"logger\", kPluginNameMagic, kPluginNameLifecycle3, kPluginNameLifecycle};\n  EXPECT_EQ(initialized, loader_.order_);\n\n  refresh_log();\n\n  EXPECT_EQ(1, count_in_log(\"Initializing all plugins.\"));\n\n  EXPECT_EQ(1, count_in_log(\"Starting all plugins.\"));\n  EXPECT_EQ(1,\n            count_in_log(\"  plugin '\" + kPluginNameMagic + \":' start exit ok\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle3 +\n                            \":' doesn't implement start()\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle +\n                            \":instance1' starting\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle +\n                            \":instance2' starting\"));\n  EXPECT_EQ(1,\n            count_in_log(\"  plugin '\" + kPluginNameLifecycle +\n                         \":instance3' start failed: \"\n                         \"lifecycle:instance3 start(): I'm returning error!\"));\n\n  EXPECT_EQ(1, count_in_log(\"Shutting down. Stopping all plugins.\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameMagic +\n                            \":' doesn't implement stop()\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle3 +\n                            \":' doesn't implement stop()\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle +\n                            \":instance1' stop exit ok\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle +\n                            \":instance2' stop exit ok\"));\n\n  EXPECT_EQ(1, count_in_log(\"Deinitializing all plugins.\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle +\n                            \"' deinit exit ok\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle3 +\n                            \"' deinit exit ok\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameMagic +\n                            \"' doesn't implement deinit()\"));\n}\n\nTEST_F(LifecycleTest, ThreeInstances_2StartsFail) {\n  config_text_ << \"init   = exit           \\n\"\n               << \"start  = error          \\n\"\n               << \"stop   = exit           \\n\"\n               << \"deinit = exit           \\n\"\n               << \"                        \\n\"\n               << \"[\" + kPluginNameLifecycle + \":instance2]   \\n\"\n               << \"start  = exitonstop     \\n\"\n               << \"stop   = exit           \\n\"\n               << \"                        \\n\"\n               << \"[\" + kPluginNameLifecycle + \":instance3]   \\n\"\n               << \"start  = error          \\n\"\n               << \"stop   = exit           \\n\";\n  using namespace mysql_harness::test::PluginDescriptorFlags;\n  ASSERT_NO_FATAL_FAILURE(init_test(config_text_, 0));\n\n  try {\n    std::exception_ptr e = loader_.run();\n    if (e) std::rethrow_exception(e);\n    FAIL() << \"start() should throw std::runtime_error\";\n  } catch (const std::runtime_error &e) {\n    // instance1 or instance3, undeterministic\n    EXPECT_TRUE(strstr(e.what(), \"start(): I'm returning error!\"));\n  } catch (...) {\n    FAIL() << \"start() should throw std::runtime_error\";\n  }\n\n  const std::list<std::string> initialized = {\n      \"logger\", kPluginNameMagic, kPluginNameLifecycle3, kPluginNameLifecycle};\n  EXPECT_EQ(initialized, loader_.order_);\n\n  refresh_log();\n\n  EXPECT_EQ(1, count_in_log(\"Initializing all plugins.\"));\n\n  EXPECT_EQ(1, count_in_log(\"Starting all plugins.\"));\n  EXPECT_EQ(1,\n            count_in_log(\"  plugin '\" + kPluginNameMagic + \":' start exit ok\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle3 +\n                            \":' doesn't implement start()\"));\n  EXPECT_EQ(1,\n            count_in_log(\"  plugin '\" + kPluginNameLifecycle +\n                         \":instance1' start failed: \"\n                         \"lifecycle:instance1 start(): I'm returning error!\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle +\n                            \":instance2' starting\"));\n  EXPECT_EQ(1,\n            count_in_log(\"  plugin '\" + kPluginNameLifecycle +\n                         \":instance3' start failed: \"\n                         \"lifecycle:instance3 start(): I'm returning error!\"));\n\n  EXPECT_EQ(1, count_in_log(\"Shutting down. Stopping all plugins.\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameMagic +\n                            \":' doesn't implement stop()\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle3 +\n                            \":' doesn't implement stop()\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle +\n                            \":instance2' stop exit ok\"));\n\n  EXPECT_EQ(1, count_in_log(\"Deinitializing all plugins.\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle +\n                            \"' deinit exit ok\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle3 +\n                            \"' deinit exit ok\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameMagic +\n                            \"' doesn't implement deinit()\"));\n}\n\nTEST_F(LifecycleTest, ThreeInstances_StopFails) {\n  config_text_ << \"init   = exit           \\n\"\n               << \"start  = exitonstop     \\n\"\n               << \"stop   = exit           \\n\"\n               << \"deinit = exit           \\n\"\n               << \"                        \\n\"\n               << \"[\" + kPluginNameLifecycle + \":instance2]   \\n\"\n               << \"start  = exitonstop     \\n\"\n               << \"stop   = error          \\n\"\n               << \"                        \\n\"\n               << \"[\" + kPluginNameLifecycle + \":instance3]   \\n\"\n               << \"start  = exitonstop     \\n\"\n               << \"stop   = exit           \\n\";\n  using namespace mysql_harness::test::PluginDescriptorFlags;\n  ASSERT_NO_FATAL_FAILURE(init_test(config_text_, 0));\n\n  // signal shutdown after 10ms, run() should block until then\n  run_then_signal_shutdown([&]() {\n    try {\n      std::exception_ptr e = loader_.run();\n      if (e) std::rethrow_exception(e);\n      FAIL() << \"stop() should throw std::runtime_error\";\n    } catch (const std::runtime_error &e) {\n      EXPECT_STREQ(\"lifecycle:instance2 stop(): I'm returning error!\",\n                   e.what());\n    } catch (...) {\n      FAIL() << \"stop() should throw std::runtime_error\";\n    }\n  });\n\n  refresh_log();\n\n  EXPECT_EQ(1, count_in_log(\"Initializing all plugins.\"));\n\n  EXPECT_EQ(1, count_in_log(\"Starting all plugins.\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameMagic + \":' starting\"));\n  EXPECT_EQ(1,\n            count_in_log(\"  plugin '\" + kPluginNameMagic + \":' start exit ok\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle3 +\n                            \":' doesn't implement start()\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle +\n                            \":instance1' starting\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle +\n                            \":instance2' starting\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle +\n                            \":instance3' starting\"));\n\n  EXPECT_EQ(1, count_in_log(\"Shutting down. Stopping all plugins.\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameMagic +\n                            \":' doesn't implement stop()\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle3 +\n                            \":' doesn't implement stop()\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle +\n                            \":instance1' stop exit ok\"));\n  EXPECT_EQ(1,\n            count_in_log(\"  plugin '\" + kPluginNameLifecycle +\n                         \":instance2' stop failed: \"\n                         \"lifecycle:instance2 stop(): I'm returning error!\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle +\n                            \":instance3' stop exit ok\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle +\n                            \":instance1' start exit ok\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle +\n                            \":instance2' start exit ok\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle +\n                            \":instance3' start exit ok\"));\n\n  EXPECT_EQ(1, count_in_log(\"Deinitializing all plugins.\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle +\n                            \"' deinit exit ok\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle3 +\n                            \"' deinit exit ok\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameMagic +\n                            \"' doesn't implement deinit()\"));\n}\n\nTEST_F(LifecycleTest, ThreeInstances_DeinintFails) {\n  config_text_ << \"init   = exit           \\n\"\n               << \"start  = exitonstop     \\n\"\n               << \"stop   = exit           \\n\"\n               << \"deinit = error          \\n\"\n               << \"                        \\n\"\n               << \"[\" + kPluginNameLifecycle + \":instance2]   \\n\"\n               << \"start  = exitonstop     \\n\"\n               << \"stop   = exit           \\n\"\n               << \"                        \\n\"\n               << \"[\" + kPluginNameLifecycle + \":instance3]   \\n\"\n               << \"start  = exitonstop     \\n\"\n               << \"stop   = exit           \\n\";\n  using namespace mysql_harness::test::PluginDescriptorFlags;\n  ASSERT_NO_FATAL_FAILURE(init_test(config_text_, 0));\n\n  // signal shutdown after 10ms, run() should block until then\n  run_then_signal_shutdown([&]() {\n    try {\n      std::exception_ptr e = loader_.run();\n      if (e) std::rethrow_exception(e);\n      FAIL() << \"deinit() should throw std::runtime_error\";\n    } catch (const std::runtime_error &e) {\n      EXPECT_STREQ(\"lifecycle:all deinit(): I'm returning error!\", e.what());\n    } catch (...) {\n      FAIL() << \"deinit() should throw std::runtime_error\";\n    }\n  });\n\n  refresh_log();\n\n  EXPECT_EQ(1, count_in_log(\"Initializing all plugins.\"));\n\n  EXPECT_EQ(1, count_in_log(\"Starting all plugins.\"));\n\n  EXPECT_EQ(1, count_in_log(\"Shutting down. Stopping all plugins.\"));\n\n  EXPECT_EQ(1, count_in_log(\"Deinitializing all plugins.\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle +\n                            \"' deinit failed: \"\n                            \"lifecycle:all deinit(): I'm returning error!\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameMagic +\n                            \"' doesn't implement deinit()\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle3 +\n                            \"' deinit exit ok\"));\n}\n\nTEST_F(LifecycleTest, ThreeInstances_StartStopDeinitFail) {\n  config_text_ << \"init   = exit           \\n\"\n               << \"start  = exitonstop     \\n\"\n               << \"stop   = exit           \\n\"\n               << \"deinit = error          \\n\"\n               << \"                        \\n\"\n               << \"[\" + kPluginNameLifecycle + \":instance2]   \\n\"\n               << \"start  = error          \\n\"\n               << \"stop   = exit           \\n\"\n               << \"                        \\n\"\n               << \"[\" + kPluginNameLifecycle + \":instance3]   \\n\"\n               << \"start  = exitonstop     \\n\"\n               << \"stop   = error          \\n\";\n  using namespace mysql_harness::test::PluginDescriptorFlags;\n  ASSERT_NO_FATAL_FAILURE(init_test(config_text_, 0));\n\n  // exception from start() should get propagated\n  try {\n    std::exception_ptr e = loader_.run();\n    if (e) std::rethrow_exception(e);\n    FAIL() << \"start() should throw std::runtime_error\";\n  } catch (const std::runtime_error &e) {\n    EXPECT_STREQ(\"lifecycle:instance2 start(): I'm returning error!\", e.what());\n  } catch (...) {\n    FAIL() << \"start() should throw std::runtime_error\";\n  }\n\n  const std::list<std::string> initialized = {\n      \"logger\", \"\" + kPluginNameMagic + \"\", \"\" + kPluginNameLifecycle3 + \"\",\n      \"\" + kPluginNameLifecycle + \"\"};\n  EXPECT_EQ(initialized, loader_.order_);\n\n  refresh_log();\n\n  EXPECT_EQ(1, count_in_log(\"Initializing all plugins.\"));\n\n  EXPECT_EQ(1, count_in_log(\"Starting all plugins.\"));\n  EXPECT_EQ(1,\n            count_in_log(\"  plugin '\" + kPluginNameMagic + \":' start exit ok\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle3 +\n                            \":' doesn't implement start()\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle +\n                            \":instance1' starting\"));\n  EXPECT_EQ(1,\n            count_in_log(\"  plugin '\" + kPluginNameLifecycle +\n                         \":instance2' start failed: \"\n                         \"lifecycle:instance2 start(): I'm returning error!\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle +\n                            \":instance3' starting\"));\n\n  EXPECT_EQ(1, count_in_log(\"Shutting down. Stopping all plugins.\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameMagic +\n                            \":' doesn't implement stop()\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle3 +\n                            \":' doesn't implement stop()\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle +\n                            \":instance1' stop exit ok\"));\n  EXPECT_EQ(1,\n            count_in_log(\"  plugin '\" + kPluginNameLifecycle +\n                         \":instance3' stop failed: \"\n                         \"lifecycle:instance3 stop(): I'm returning error!\"));\n\n  EXPECT_EQ(1, count_in_log(\"Deinitializing all plugins.\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle +\n                            \"' deinit failed: \"\n                            \"lifecycle:all deinit(): I'm returning error!\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle3 +\n                            \"' deinit exit ok\"));\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameMagic +\n                            \"' doesn't implement deinit()\"));\n}\n\nTEST_F(LifecycleTest, NoInstances) {\n  // This test tests Loader's ability to correctly start up and shut down\n  // without any plugins.  However note, that currently we expect our Router to\n  // exit with an error when there's not plugins to run, but that is a\n  // higher-level concern.  So while the check happens inside Loader (because\n  // it's not possible to check from the outside), this test bypasses this\n  // check.\n  const std::string plugin_dir = mysql_harness::get_plugin_dir(g_here.str());\n  config_text_.str(\n      \"[DEFAULT]                                      \\n\"\n      \"logging_folder =                               \\n\"\n      \"plugin_folder  = \" +\n      plugin_dir +\n      \"\\n\"\n      \"runtime_folder = {prefix}                      \\n\"\n      \"config_folder  = {prefix}                      \\n\"\n      \"                                               \\n\"\n      \"[logger]                                       \\n\"\n      \"level = DEBUG                                  \\n\"\n      \"                                               \\n\");\n  init_test_without_lifecycle_plugin(config_text_);\n\n  loader_.run();\n\n  refresh_log();\n\n  EXPECT_EQ(1, count_in_log(\"Initializing all plugins.\"));\n  EXPECT_EQ(1, count_in_log(\"Starting all plugins.\"));\n  EXPECT_EQ(1, count_in_log(\"Shutting down. Stopping all plugins.\"));\n  EXPECT_EQ(1, count_in_log(\"Deinitializing all plugins.\"));\n  EXPECT_EQ(0, count_in_log(\"failed\"));\n}\n\n// note: we don't test an equivalent scenario when the plugin throws (an empty\n//       \"what\" field), because to accomplish this, plugin would have to throw\n//       something like:\n//\n//           throw std::runtime_error();\n//\n//       which (on GCC 4.8.4 anyway) emits std::logic_error with a message\n//       complaining about a null std::string. In other words, what() returning\n//       a null string in harness' catch block is not likely.\nTEST_F(LifecycleTest, EmptyErrorMessage) {\n  // this test tests PluginFuncEnv::set_error() function, when passed a null\n  // string.\n\n  config_text_ << \"init   = error_empty    \\n\"\n               << \"start  = exit           \\n\"\n               << \"stop   = exit           \\n\"\n               << \"deinit = exit           \\n\";\n  using namespace mysql_harness::test::PluginDescriptorFlags;\n  ASSERT_NO_FATAL_FAILURE(init_test(config_text_, NoStart | NoStop | NoDeinit));\n\n  // null string should be replaced with '<empty message>'\n  try {\n    std::exception_ptr e = loader_.run();\n    if (e) std::rethrow_exception(e);\n    FAIL() << \"init() should throw std::runtime_error\";\n  } catch (const std::runtime_error &e) {\n    EXPECT_STREQ(\"<empty message>\", e.what());\n  } catch (...) {\n    FAIL() << \"init() should throw std::runtime_error\";\n  }\n\n  // null string should be replaced with '<empty message>'\n  refresh_log();\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle +\n                            \"' init \"\n                            \"failed: <empty message>\"));\n}\n\n// maybe these should be moved to test_loader.cc (or wherever PluginFuncEnv\n// class ends up) these tests probably obsolete the EmptyErrorMessage test above\nTEST_F(LifecycleTest, set_error_message) {\n  std::string emsg;\n  mysql_harness::PluginFuncEnv ctx(nullptr, nullptr);\n\n  // simple\n  mysql_harness::set_error(&ctx, mysql_harness::kRuntimeError, \"foo\");\n  std::tie(emsg, std::ignore) = ctx.pop_error();\n  EXPECT_STREQ(\"foo\", emsg.c_str());\n\n  // complex\n  mysql_harness::set_error(&ctx, mysql_harness::kRuntimeError, \"[%s:%s] %d\",\n                           \"foo\", \"bar\", 42);\n  std::tie(emsg, std::ignore) = ctx.pop_error();\n  EXPECT_STREQ(\"[foo:bar] 42\", emsg.c_str());\n\n  // cornercase: empty\n#ifndef __GNUC__\n  // gcc/clang catch it at compile time: error: zero-length gnu_printf format\n  // string [-Werror=format-zero-length]\n  mysql_harness::set_error(&ctx, mysql_harness::kRuntimeError, \"\");\n  std::tie(emsg, std::ignore) = ctx.pop_error();\n  EXPECT_STREQ(\"\", emsg.c_str());\n#endif\n\n  // cornercase: NULL\n  mysql_harness::set_error(&ctx, mysql_harness::kRuntimeError, nullptr);\n  std::tie(emsg, std::ignore) = ctx.pop_error();\n  EXPECT_STREQ(\"<empty message>\", emsg.c_str());\n\n#ifndef __GNUC__\n  // gcc/clang catch it at compile time: error: too many arguments for format\n  // [-Werror=format-extra-args] cornercase: NULL + arg\n  mysql_harness::set_error(&ctx, mysql_harness::kRuntimeError, nullptr, \"foo\");\n  std::tie(emsg, std::ignore) = ctx.pop_error();\n  EXPECT_STREQ(\"<empty message>\", emsg.c_str());\n#endif\n\n#ifndef __GNUC__\n  // gcc/clang catch it at compile time\n\n  // cornercase: extra arg\n  mysql_harness::set_error(&ctx, mysql_harness::kRuntimeError, \"foo\", \"bar\");\n  std::tie(emsg, std::ignore) = ctx.pop_error();\n  EXPECT_STREQ(\"foo\", emsg.c_str());\n#endif\n}\n\nTEST_F(LifecycleTest, set_error_exception) {\n  std::exception_ptr eptr;\n  mysql_harness::PluginFuncEnv ctx(nullptr, nullptr);\n\n  // test all supported exception types\n\n  mysql_harness::set_error(&ctx, mysql_harness::kRuntimeError, nullptr);\n  std::tie(std::ignore, eptr) = ctx.pop_error();\n  EXPECT_THROW({ std::rethrow_exception(eptr); }, std::runtime_error);\n\n  mysql_harness::set_error(&ctx, mysql_harness::kConfigInvalidArgument,\n                           nullptr);\n  std::tie(std::ignore, eptr) = ctx.pop_error();\n  EXPECT_THROW({ std::rethrow_exception(eptr); }, std::invalid_argument);\n\n  mysql_harness::set_error(&ctx, mysql_harness::kConfigSyntaxError, nullptr);\n  std::tie(std::ignore, eptr) = ctx.pop_error();\n  EXPECT_THROW({ std::rethrow_exception(eptr); }, mysql_harness::syntax_error);\n\n  mysql_harness::set_error(&ctx, mysql_harness::kUndefinedError, nullptr);\n  std::tie(std::ignore, eptr) = ctx.pop_error();\n  EXPECT_THROW({ std::rethrow_exception(eptr); }, std::runtime_error);\n}\n\n#ifdef USE_POSIX_SIGNALS  // these don't make sense on Windows\nTEST_F(LifecycleTest, send_signals) {\n  // this test verifies that:\n  // - sending SIGINT or SIGTERM will trigger shutdown\n  //   (we only test SIGINT here, and SIGTERM in the next test)\n  // - sending any other signal will do nothing\n\n  config_text_ << \"init   = exit           \\n\"\n               << \"start  = exitonstop     \\n\"\n               << \"stop   = exit           \\n\"\n               << \"deinit = exit           \\n\";\n  using namespace mysql_harness::test::PluginDescriptorFlags;\n  ASSERT_NO_FATAL_FAILURE(init_test(config_text_, 0));\n  LifecyclePluginSyncBus &bus = msg_bus(\"instance1\");\n\n  EXPECT_EQ(loader_.init_all(), nullptr);\n  freeze_bus(bus);\n  loader_.start_all();\n  unfreeze_and_wait_for_msg(\n      bus, \"lifecycle:instance1 start():EXIT_ON_STOP:sleeping\");\n\n  // nothing should happen - all signals but the ones we care about should be\n  // ignored (here we only test a few, the rest is assumed to behave the same)\n  kill(getpid(), SIGUSR1);\n  kill(getpid(), SIGALRM);\n\n  // signal shutdown after 10ms, main_loop() should block until then\n  auto call_SIGINT = []() {\n    std::this_thread::sleep_for(ch::milliseconds(kSleepShutdown));\n    kill(getpid(), SIGINT);\n  };\n  std::thread(call_SIGINT).detach();\n  EXPECT_EQ(loader_.main_loop(), nullptr);\n\n  refresh_log();\n  EXPECT_EQ(1, count_in_log(\"Shutting down. Stopping all plugins.\"));\n}\n\nTEST_F(LifecycleTest, send_signals2) {\n  // continuation of the previous test (test SIGTERM this time)\n\n  config_text_ << \"init   = exit           \\n\"\n               << \"start  = exitonstop     \\n\"\n               << \"stop   = exit           \\n\"\n               << \"deinit = exit           \\n\";\n  using namespace mysql_harness::test::PluginDescriptorFlags;\n  ASSERT_NO_FATAL_FAILURE(init_test(config_text_, 0));\n  LifecyclePluginSyncBus &bus = msg_bus(\"instance1\");\n\n  EXPECT_EQ(loader_.init_all(), nullptr);\n  freeze_bus(bus);\n  loader_.start_all();\n  unfreeze_and_wait_for_msg(\n      bus, \"lifecycle:instance1 start():EXIT_ON_STOP:sleeping\");\n\n  // signal shutdown after 10ms, main_loop() should block until then\n  auto call_SIGTERM = []() {\n    std::this_thread::sleep_for(ch::milliseconds(kSleepShutdown));\n    kill(getpid(), SIGTERM);\n  };\n  std::thread(call_SIGTERM).detach();\n  EXPECT_EQ(loader_.main_loop(), nullptr);\n\n  refresh_log();\n  EXPECT_EQ(1, count_in_log(\"Shutting down. Stopping all plugins.\"));\n}\n#endif\n\n/**\n * @test\n * This test verifies operation of Harness API function wait_for_stop().\n * It is tested in two scenarios:\n *   1. when Router is \"running\": it should block until timeout expires\n *   2. when Router is \"stopping\": it should exit immediately\n */\nTEST_F(LifecycleTest, wait_for_stop) {\n  // SCENARIO #1: When Router is \"running\"\n  // EXPECTATION:\n  //   wait_for_stop() inside should block for 100ms, then return false (time\n  //   out)\n  // EXPLANATION:\n  //   When plugin function start() is called, Router will be in a \"running\"\n  //   state. Inside start() calls wait_for_stop(timeout = 100ms), which\n  //   means wait_for_stop() SHOULD block and time out after 100ms. Then the\n  //   start() will just exit, and when it does that, it will cause Router to\n  //   initiate shutdown (and set the shutdown flag), as there are no more\n  //   plugins running.\n  config_text_ << \"start = exitonstop_shorttimeout\\n\";\n\n  // SCENARIO #2: When Router is \"stopping\"\n  // EXPECTATION:\n  //   wait_for_stop() inside should return immediately, then return true (due\n  //   to shut down flag being set)\n  // EXPLANATION:\n  //   Now that start() has exited, Router has progressed to \"stopping\" state,\n  //   and as a result, plugin function stop() will be called. stop() makes a\n  //   call to wait_for_stop(<big timeout value>). Since this time around,\n  //   Router is already in the \"stopping\" state, the function SHOULD exit\n  //   immediately, returing control back to stop(), which just exits after.\n  config_text_ << \"stop  = exitonstop_longtimeout\\n\";\n\n  using namespace mysql_harness::test::PluginDescriptorFlags;\n  ASSERT_NO_FATAL_FAILURE(init_test(config_text_, NoInit | NoDeinit));\n  LifecyclePluginSyncBus &bus = msg_bus(\"instance1\");\n\n  EXPECT_EQ(loader_.init_all(), nullptr);\n  freeze_bus(bus);\n\n  ch::time_point<ch::steady_clock> t0, t1;\n\n  // run scenarios #1 and #2\n  {\n    t0 = ch::steady_clock::now();\n    loader_.start_all();\n\n    // wait to enter scenario #1\n    unfreeze_and_wait_for_msg(\n        bus, \"lifecycle:instance1 start():EXIT_ON_STOP_SHORT_TIMEOUT:sleeping\");\n\n    // we are now in scenario #1\n    // (wait_for_stop() in start() should be sleeping right now; main_loop() is\n    // blocked waiting for start() to exit)\n    refresh_log();\n    // clang-format off\n    EXPECT_EQ(1, count_in_log(\"lifecycle:instance1 start():begin\"));\n    EXPECT_EQ(1, count_in_log(\"lifecycle:instance1 start():EXIT_ON_STOP_SHORT_TIMEOUT:sleeping\"));\n    EXPECT_EQ(0, count_in_log(\"lifecycle:instance1 start():EXIT_ON_STOP_SHORT_TIMEOUT:done, ret = true (stop request received)\"));\n    EXPECT_EQ(0, count_in_log(\"lifecycle:instance1 start():EXIT_ON_STOP_SHORT_TIMEOUT:done, ret = false (timed out)\"));\n    EXPECT_EQ(0, count_in_log(\"lifecycle:instance1 stop():begin\"));\n    EXPECT_EQ(0, count_in_log(\"lifecycle:instance1 stop():EXIT_ON_STOP_LONG_TIMEOUT:done, ret = true (stop request received)\"));\n    EXPECT_EQ(0, count_in_log(\"lifecycle:instance1 stop():EXIT_ON_STOP_LONG_TIMEOUT:done, ret = false (timed out)\"));\n    // clang-format on\n\n    // wait for scenario #1 to finish and scenario #2 to run\n    // (start() should exit without error, causing main_loop() to unblock and\n    // progress to calling stop(), then finally return)\n    EXPECT_EQ(loader_.main_loop(), nullptr);\n\n    // stop the timer\n    t1 = ch::steady_clock::now();\n  }\n\n  // verify expectations\n  {\n    // first, we measure the time to run scenarios #1 and #2:\n    // - Scenario #1 should take 100+ ms to execute (wait_for_stop() should\n    //   block for 100ms, everything else is fast)\n    // - Scenario #2 should take close to 0 ms to execute (wait_for_stop()\n    //   should return immiedately, everything else is fast)\n    //\n    // Therefore, we expect that the cumulative time should be close to just\n    // over 100ms:\n    // - if it was less than 100ms, scenario #1 must have failed\n    //   (wait_for_stop() failed to block).\n    // - if it takes 10 seconds or more, scenario #2 must have failed\n    //   (wait_for_stop(timeout = 10 seconds) timed out, instead of returning\n    //   immediately)\n\n    // NOTE about a choice of timeout (10 seconds):\n    // 10s timeout is a little arbitrary.  In theory, all we need is something\n    // just a little over 100ms, since Scenario #2 has no blocking states and\n    // should run really quick.  So we might be tempted to pick something like\n    // 110ms or 200ms, however as we have learned, it's possible to exceed such\n    // timeout on a busy OSX machine and fail the test.  The fault lies with\n    // calls to std::condition_variable::wait_for() (called inside of\n    // wait_for_stop()) which calls syscall psync_cvwait().  Deeper underneath,\n    // it turns out that unless a thread making this syscall has heightened\n    // priority (which it does not), OSX is free to delay delivering signal\n    // for performance reasons.\n    //\n    // We don't bother #ifdef-ing the timeout for OSX, because in principle,\n    // many/all non-RT OSes probably have no tight guarrantees for wait_for()\n    // just like OSX, and an excessive timeout value does not slow down the\n    // test run time.\n\n    // expect 100ms <= (t1-t0) < 10s\n    EXPECT_LE(100, time_diff(t0, t1));        // 100 = scenario #1 timeout\n    EXPECT_GT(10 * 1000, time_diff(t0, t1));  // 10000 = scenario #2 timeout\n\n    // verify what both wait_for_stop()'s returned\n    refresh_log();\n    // clang-format off\n    EXPECT_EQ(0, count_in_log(\"lifecycle:instance1 start():EXIT_ON_STOP_SHORT_TIMEOUT:done, ret = true (stop request received)\"));\n    EXPECT_EQ(1, count_in_log(\"lifecycle:instance1 start():EXIT_ON_STOP_SHORT_TIMEOUT:done, ret = false (timed out)\"));\n    EXPECT_EQ(1, count_in_log(\"lifecycle:instance1 stop():begin\"));\n    EXPECT_EQ(1, count_in_log(\"lifecycle:instance1 stop():EXIT_ON_STOP_LONG_TIMEOUT:done, ret = true (stop request received)\"));\n    EXPECT_EQ(0, count_in_log(\"lifecycle:instance1 stop():EXIT_ON_STOP_LONG_TIMEOUT:done, ret = false (timed out)\"));\n    // clang-format on\n  }\n}\n\n// Next 4 tests should only run in release builds. Code in debug builds throws\n// assertion to warn the plugin developers that their plugins throw. But we\n// wouldn't want to do this on production systems, so instead, we handle this\n// error gracefully. Note that officially this behaviour is undefined, thus\n// we are free to change this behaviour as we see fit.\n#ifdef NDEBUG  // cmake's -DCMAKE_BUILD_TYPE=Release or RelWithDebInfo (not\n               // case sensitive) will define it\nTEST_F(LifecycleTest, InitThrows) {\n  config_text_ << \"init = throw\\n\";\n\n  using namespace mysql_harness::test::PluginDescriptorFlags;\n  ASSERT_NO_FATAL_FAILURE(init_test(config_text_, NoStart | NoStop | NoDeinit));\n\n  try {\n    std::exception_ptr e = loader_.run();\n    if (e) std::rethrow_exception(e);\n    FAIL() << \"init() should throw std::runtime_error\";\n  } catch (const std::runtime_error &e) {\n    EXPECT_STREQ(\"lifecycle:all init(): I'm throwing!\", e.what());\n  } catch (...) {\n    FAIL() << \"init() should throw std::runtime_error\";\n  }\n\n  refresh_log();\n\n  EXPECT_EQ(\n      1,\n      count_in_log(\n          \"  plugin '\" + kPluginNameLifecycle +\n          \"' init threw unexpected \"\n          \"exception - please contact plugin developers for more information: \"\n          \"lifecycle:all init(): I'm throwing!\"));\n}\n\nTEST_F(LifecycleTest, StartThrows) {\n  config_text_ << \"start = throw\\n\";\n\n  using namespace mysql_harness::test::PluginDescriptorFlags;\n  ASSERT_NO_FATAL_FAILURE(init_test(config_text_, NoInit | NoStop | NoDeinit));\n\n  try {\n    std::exception_ptr e = loader_.run();\n    if (e) std::rethrow_exception(e);\n    FAIL() << \"start() should throw std::runtime_error\";\n  } catch (const std::runtime_error &e) {\n    EXPECT_STREQ(\"lifecycle:instance1 start(): I'm throwing!\", e.what());\n  } catch (...) {\n    FAIL() << \"start() should throw std::runtime_error\";\n  }\n\n  refresh_log();\n\n  EXPECT_EQ(\n      1, count_in_log(\n             \"  plugin '\" + kPluginNameLifecycle +\n             \":instance1' start threw \"\n             \"unexpected exception - please contact plugin developers for more \"\n             \"information: lifecycle:instance1 start(): I'm throwing!\"));\n}\n\nTEST_F(LifecycleTest, StopThrows) {\n  config_text_ << \"stop = throw\\n\";\n\n  using namespace mysql_harness::test::PluginDescriptorFlags;\n  ASSERT_NO_FATAL_FAILURE(init_test(config_text_, NoInit | NoStart | NoDeinit));\n\n  try {\n    std::exception_ptr e = loader_.run();\n    if (e) std::rethrow_exception(e);\n    FAIL() << \"stop() should throw std::runtime_error\";\n  } catch (const std::runtime_error &e) {\n    EXPECT_STREQ(\"lifecycle:instance1 stop(): I'm throwing!\", e.what());\n  } catch (...) {\n    FAIL() << \"stop() should throw std::runtime_error\";\n  }\n\n  refresh_log();\n\n  EXPECT_EQ(\n      1, count_in_log(\n             \"  plugin '\" + kPluginNameLifecycle +\n             \":instance1' stop threw \"\n             \"unexpected exception - please contact plugin developers for more \"\n             \"information: lifecycle:instance1 stop(): I'm throwing!\"));\n}\n\nTEST_F(LifecycleTest, DeinitThrows) {\n  config_text_ << \"deinit = throw\\n\";\n\n  using namespace mysql_harness::test::PluginDescriptorFlags;\n  ASSERT_NO_FATAL_FAILURE(init_test(config_text_, NoInit | NoStart | NoStop));\n\n  try {\n    std::exception_ptr e = loader_.run();\n    if (e) std::rethrow_exception(e);\n    FAIL() << \"deinit() should throw std::runtime_error\";\n  } catch (const std::runtime_error &e) {\n    EXPECT_STREQ(\"lifecycle:all deinit(): I'm throwing!\", e.what());\n  } catch (...) {\n    FAIL() << \"deinit() should throw std::runtime_error\";\n  }\n\n  refresh_log();\n\n  EXPECT_EQ(\n      1,\n      count_in_log(\n          \"  plugin '\" + kPluginNameLifecycle +\n          \"' deinit threw unexpected \"\n          \"exception - please contact plugin developers for more information: \"\n          \"lifecycle:all deinit(): I'm throwing!\"));\n}\n\n// The following 4 are the same as above 4, but this time we throw unusual\n// exceptions (not derived from std::exception), to test catch(...) logic\n// in Loader's code\nTEST_F(LifecycleTest, InitThrowsWeird) {\n  config_text_ << \"init = throw_weird\\n\";\n\n  using namespace mysql_harness::test::PluginDescriptorFlags;\n  ASSERT_NO_FATAL_FAILURE(init_test(config_text_, NoStart | NoStop | NoDeinit));\n\n  try {\n    std::exception_ptr e = loader_.run();\n    if (e) std::rethrow_exception(e);\n    FAIL() << \"init() should throw non-standard exception object\";\n  } catch (const std::runtime_error &e) {\n    FAIL() << \"init() should throw non-standard exception object\";\n  } catch (...) {\n  }\n\n  refresh_log();\n\n  EXPECT_EQ(1, count_in_log(\"  plugin '\" + kPluginNameLifecycle +\n                            \"' init threw unexpected \"\n                            \"exception - please contact plugin developers for \"\n                            \"more information.\"));\n}\n\nTEST_F(LifecycleTest, StartThrowsWeird) {\n  config_text_ << \"start = throw_weird\\n\";\n\n  using namespace mysql_harness::test::PluginDescriptorFlags;\n  ASSERT_NO_FATAL_FAILURE(init_test(config_text_, NoInit | NoStop | NoDeinit));\n\n  try {\n    std::exception_ptr e = loader_.run();\n    if (e) std::rethrow_exception(e);\n    FAIL() << \"start() should throw non-standard exception object\";\n  } catch (const std::runtime_error &e) {\n    FAIL() << \"start() should throw non-standard exception object\";\n  } catch (...) {\n  }\n\n  refresh_log();\n\n  EXPECT_EQ(\n      1, count_in_log(\"  plugin '\" + kPluginNameLifecycle +\n                      \":instance1' start \"\n                      \"threw unexpected \"\n                      \"exception - please contact plugin developers for more \"\n                      \"information.\"));\n}\n\nTEST_F(LifecycleTest, StopThrowsWeird) {\n  config_text_ << \"stop = throw_weird\\n\";\n\n  using namespace mysql_harness::test::PluginDescriptorFlags;\n  ASSERT_NO_FATAL_FAILURE(init_test(config_text_, NoInit | NoStart | NoDeinit));\n\n  try {\n    std::exception_ptr e = loader_.run();\n    if (e) std::rethrow_exception(e);\n    FAIL() << \"stop() should throw non-standard exception object\";\n  } catch (const std::runtime_error &e) {\n    FAIL() << \"stop() should throw non-standard exception object\";\n  } catch (...) {\n  }\n\n  refresh_log();\n\n  EXPECT_THAT(log_lines_,\n              ::testing::Contains(::testing::HasSubstr(\n                  \"  plugin '\" + kPluginNameLifecycle +\n                  \":instance1' stop threw \"\n                  \"unexpected \"\n                  \"exception - please contact plugin developers for \"\n                  \"more information.\")));\n}\n\nTEST_F(LifecycleTest, DeinitThrowsWeird) {\n  config_text_ << \"deinit = throw_weird\\n\";\n\n  using namespace mysql_harness::test::PluginDescriptorFlags;\n  ASSERT_NO_FATAL_FAILURE(init_test(config_text_, NoInit | NoStart | NoStop));\n\n  try {\n    std::exception_ptr e = loader_.run();\n    if (e) std::rethrow_exception(e);\n    FAIL() << \"deinit() should throw non-standard exception object\";\n  } catch (const std::runtime_error &e) {\n    FAIL() << \"deinit() should throw non-standard exception object, got \"\n           << e.what();\n  } catch (...) {\n  }\n\n  refresh_log();\n\n  EXPECT_THAT(log_lines_,\n              ::testing::Contains(::testing::HasSubstr(\n                  \"  plugin '\" + kPluginNameLifecycle +\n                  \"' deinit threw unexpected \"\n                  \"exception - please contact plugin developers for \"\n                  \"more information.\")));\n}\n\n#endif  // #ifdef NDEBUG\n\nTEST_F(LifecycleTest, LoadingNonExistentPlugin) {\n  clear_log();\n\n  config_text_\n      << \"[nonexistent_plugin]\\n\";  // should cause Loader::load_all() to throw\n  config_text_\n      << \"[nonexistent_plugin_2]\\n\";  // no attempt to load this should be made\n  loader_.read(config_text_);\n\n  try {\n    loader_.start();\n    FAIL() << \"Loader::start() should throw bad_plugin\";\n  } catch (const bad_plugin &e) {\n    EXPECT_THAT(e.what(), HasSubstr(\"nonexistent_plugin\"));\n  } catch (const std::exception &e) {\n    FAIL() << \"Loader::start() should throw bad_plugin, but got: \" << e.what();\n  }\n\n  refresh_log();\n\n  EXPECT_THAT(\n      log_lines_,\n      ::testing::Contains(::testing::HasSubstr(\"] Unloading all plugins.\")));\n\n  // Loader::load_all() should have stopped loading as soon as it encountered\n  // 'nonexistent_plugin'. Therefore, it should not attempt to load the next\n  // plugin, 'nonexistent_plugin_2', thus we should find no trace of such string\n  // in the log.\n  EXPECT_THAT(log_lines_,\n              ::testing::Not(::testing::Contains(\"nonexistent_plugin_2\")));\n}\n\nint main(int argc, char *argv[]) {\n  g_here = Path(argv[0]).dirname();\n  init_test_logger();\n\n  ::testing::InitGoogleTest(&argc, argv);\n  int res = RUN_ALL_TESTS();\n\n  return res;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/include/my_sharedlib.h": "/*\n   Copyright (c) 2016, 2017, Oracle and/or its affiliates. All rights reserved.\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License, version 2.0,\n   as published by the Free Software Foundation.\n\n   This program is also distributed with certain software (including\n   but not limited to OpenSSL) that is licensed under separate terms,\n   as designated in a particular file or component or in included license\n   documentation.  The authors of MySQL hereby grant you an additional\n   permission to link the program and your derivative works with the\n   separately licensed software that they have included with MySQL.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License, version 2.0, for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA */\n\n#ifndef MY_SHAREDLIB_INCLUDED\n#define MY_SHAREDLIB_INCLUDED\n\n/**\n  @file include/my_sharedlib.h\n  Functions related to handling of plugins and other dynamically loaded\n  libraries.\n*/\n\n#if defined(_WIN32)\n#define dlsym(lib, name) (void *)GetProcAddress((HMODULE)lib, name)\n#define dlopen(libname, unused) LoadLibraryEx(libname, NULL, 0)\n#define dlclose(lib) FreeLibrary((HMODULE)lib)\n#define DLERROR_GENERATE(errmsg, error_number)                          \\\n  char win_errormsg[2048];                                              \\\n  if (FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, 0, error_number, 0,     \\\n                    win_errormsg, 2048, NULL)) {                        \\\n    char *ptr;                                                          \\\n    for (ptr = &win_errormsg[0] + strlen(win_errormsg) - 1;             \\\n         ptr >= &win_errormsg[0] && strchr(\"\\r\\n\\t\\0x20\", *ptr); ptr--) \\\n      *ptr = 0;                                                         \\\n    errmsg = win_errormsg;                                              \\\n  } else                                                                \\\n    errmsg = \"\"\n#define dlerror() \"\"\n#define dlopen_errno GetLastError()\n\n#else /* _WIN32 */\n\n#ifndef MYSQL_ABI_CHECK\n#include <dlfcn.h>\n#include <errno.h>\n#endif\n\n#define DLERROR_GENERATE(errmsg, error_number) errmsg = dlerror()\n#define dlopen_errno errno\n#endif /* _WIN32 */\n\n/*\n  MYSQL_PLUGIN_IMPORT macro is used to export mysqld data\n  (i.e variables) for usage in storage engine loadable plugins.\n  Outside of Windows, it is dummy.\n*/\n#if (defined(_WIN32) && defined(MYSQL_DYNAMIC_PLUGIN))\n#define MYSQL_PLUGIN_IMPORT __declspec(dllimport)\n#else\n#define MYSQL_PLUGIN_IMPORT\n#endif\n\n#endif  // MY_SHAREDLIB_INCLUDED\n",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/plugin/innodb_memcached/daemon_memcached/daemon/memcached.c": "/* -*- Mode: C; tab-width: 4; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/*\n *  memcached - memory caching daemon\n *\n *       http://www.danga.com/memcached/\n *  Copyright (c) 2015, 2016, Oracle and/or its affiliates. All rights reserved.\n *  Copyright 2003 Danga Interactive, Inc.  All rights reserved.\n *  This file was modified by Oracle on 28-08-2015 and 23-03-2016.\n *  Modifications copyright (c) 2015, 2016, Oracle and/or its affiliates.\n *  All rights reserved.\n *\n *  Use and distribution licensed under the BSD license.  See\n *  the LICENSE file for full text.\n *\n *  Authors:\n *      Anatoly Vorobey <mellon@pobox.com>\n *      Brad Fitzpatrick <brad@danga.com>\n *\n *  Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.\n */\n#include \"config.h\"\n#include \"config_static.h\"\n#include \"memcached.h\"\n#include \"memcached/extension_loggers.h\"\n#include \"utilities/engine_loader.h\"\n\n#include <signal.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <time.h>\n#include <assert.h>\n#include <limits.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <stddef.h>\n#include <dlfcn.h>\n\n#include \"memcached_mysql.h\"\n\n#define INNODB_MEMCACHED\nvoid my_thread_init();\nvoid my_thread_end();\n\nstatic inline void item_set_cas(const void *cookie, item *it, uint64_t cas) {\n    settings.engine.v1->item_set_cas(settings.engine.v0, cookie, it, cas);\n}\n\n/* The item must always be called \"it\" */\n#define SLAB_GUTS(conn, thread_stats, slab_op, thread_op) \\\n    thread_stats->slab_stats[info.clsid].slab_op++;\n\n#define THREAD_GUTS(conn, thread_stats, slab_op, thread_op) \\\n    thread_stats->thread_op++;\n\n#define THREAD_GUTS2(conn, thread_stats, slab_op, thread_op) \\\n    thread_stats->slab_op++; \\\n    thread_stats->thread_op++;\n\n#define SLAB_THREAD_GUTS(conn, thread_stats, slab_op, thread_op) \\\n    SLAB_GUTS(conn, thread_stats, slab_op, thread_op) \\\n    THREAD_GUTS(conn, thread_stats, slab_op, thread_op)\n\n#define STATS_INCR1(GUTS, conn, slab_op, thread_op, key, nkey) { \\\n    struct independent_stats *independent_stats = get_independent_stats(conn); \\\n    struct thread_stats *thread_stats = \\\n        &independent_stats->thread_stats[conn->thread->index]; \\\n    topkeys_t *topkeys = independent_stats->topkeys; \\\n    pthread_mutex_lock(&thread_stats->mutex); \\\n    GUTS(conn, thread_stats, slab_op, thread_op); \\\n    pthread_mutex_unlock(&thread_stats->mutex); \\\n    TK(topkeys, slab_op, key, nkey, current_time); \\\n}\n\n#define STATS_INCR(conn, op, key, nkey) \\\n    STATS_INCR1(THREAD_GUTS, conn, op, op, key, nkey)\n\n#define SLAB_INCR(conn, op, key, nkey) \\\n    STATS_INCR1(SLAB_GUTS, conn, op, op, key, nkey)\n\n#define STATS_TWO(conn, slab_op, thread_op, key, nkey) \\\n    STATS_INCR1(THREAD_GUTS2, conn, slab_op, thread_op, key, nkey)\n\n#define SLAB_TWO(conn, slab_op, thread_op, key, nkey) \\\n    STATS_INCR1(SLAB_THREAD_GUTS, conn, slab_op, thread_op, key, nkey)\n\n#define STATS_HIT(conn, op, key, nkey) \\\n    SLAB_TWO(conn, op##_hits, cmd_##op, key, nkey)\n\n#define STATS_MISS(conn, op, key, nkey) \\\n    STATS_TWO(conn, op##_misses, cmd_##op, key, nkey)\n\n#if defined(HAVE_GCC_SYNC_BUILTINS)\n\n#define STATS_NOKEY(conn, op)\t\\\ndo { \\\n    struct thread_stats *thread_stats = \\\n        get_thread_stats(conn); \\\n\t__sync_add_and_fetch(&thread_stats->op, 1); \\\n} while (0)\n\n#define STATS_NOKEY2(conn, op1, op2)\t\\\ndo { \\\n    struct thread_stats *thread_stats = \\\n        get_thread_stats(conn); \\\n\t__sync_add_and_fetch(&thread_stats->op1, 1); \\\n\t__sync_add_and_fetch(&thread_stats->op2, 1); \\\n} while (0)\n\n#define STATS_ADD(conn, op, amt)\t\\\ndo { \\\n    struct thread_stats *thread_stats = \\\n        get_thread_stats(conn); \\\n\t__sync_add_and_fetch(&thread_stats->op, amt); \\\n} while (0)\n\n#define MEMCACHED_ATOMIC_MSG\t\"InnoDB MEMCACHED: Memcached uses atomic increment \\n\"\n\n#else /* HAVE_GCC_SYNC_BUILTINS */\n#define STATS_NOKEY(conn, op) { \\\n    struct thread_stats *thread_stats = \\\n        get_thread_stats(conn); \\\n    pthread_mutex_lock(&thread_stats->mutex); \\\n    thread_stats->op++; \\\n    pthread_mutex_unlock(&thread_stats->mutex); \\\n}\n\n#define STATS_NOKEY2(conn, op1, op2) { \\\n    struct thread_stats *thread_stats = \\\n        get_thread_stats(conn); \\\n    pthread_mutex_lock(&thread_stats->mutex); \\\n    thread_stats->op1++; \\\n    thread_stats->op2++; \\\n    pthread_mutex_unlock(&thread_stats->mutex); \\\n}\n\n#define STATS_ADD(conn, op, amt) { \\\n    struct thread_stats *thread_stats = \\\n        get_thread_stats(conn); \\\n    pthread_mutex_lock(&thread_stats->mutex); \\\n    thread_stats->op += amt; \\\n    pthread_mutex_unlock(&thread_stats->mutex); \\\n}\n\n#define MEMCACHED_ATOMIC_MSG\t\"InnoDB Memcached: Memcached DOES NOT use atomic increment\"\n#endif /* HAVE_GCC_SYNC_BUILTINS */\n\nvolatile sig_atomic_t memcached_shutdown;\nvolatile sig_atomic_t memcached_initialized;\n\n/*\n * We keep the current time of day in a global variable that's updated by a\n * timer event. This saves us a bunch of time() system calls (we really only\n * need to get the time once a second, whereas there can be tens of thousands\n * of requests a second) and allows us to use server-start-relative timestamps\n * rather than absolute UNIX timestamps, a space savings on systems where\n * sizeof(time_t) > sizeof(unsigned int).\n */\nvolatile rel_time_t current_time;\n\n/*\n * forward declarations\n */\nstatic SOCKET new_socket(struct addrinfo *ai);\nstatic int try_read_command(conn *c);\nstatic inline struct independent_stats *get_independent_stats(conn *c);\nstatic inline struct thread_stats *get_thread_stats(conn *c);\nstatic void register_callback(ENGINE_HANDLE *eh,\n                              ENGINE_EVENT_TYPE type,\n                              EVENT_CALLBACK cb, const void *cb_data);\nenum try_read_result {\n    READ_DATA_RECEIVED,\n    READ_NO_DATA_RECEIVED,\n    READ_ERROR,            /** an error occurred (on the socket) (or client closed connection) */\n    READ_MEMORY_ERROR      /** failed to allocate more memory */\n};\n\nstatic enum try_read_result try_read_network(conn *c);\nstatic enum try_read_result try_read_udp(conn *c);\n\n/* stats */\nstatic void stats_init(void);\nstatic void server_stats(ADD_STAT add_stats, conn *c, bool aggregate);\nstatic void process_stat_settings(ADD_STAT add_stats, void *c);\n\n\n/* defaults */\nstatic void settings_init(void);\n\n/* event handling, network IO */\nstatic void event_handler(const int fd, const short which, void *arg);\nstatic void complete_nread(conn *c);\nstatic char *process_command(conn *c, char *command);\nstatic void write_and_free(conn *c, char *buf, int bytes);\nstatic int ensure_iov_space(conn *c);\nstatic int add_iov(conn *c, const void *buf, int len);\nstatic int add_msghdr(conn *c);\n\n\n/* time handling */\nstatic void set_current_time(void);  /* update the global variable holding\n                              global 32-bit seconds-since-start time\n                              (to avoid 64 bit time_t) */\n\n/** exported globals **/\nstruct stats stats;\nstruct settings settings;\nstatic time_t process_started;     /* when the process was started */\n\n/** file scope variables **/\nstatic conn *listen_conn = NULL;\nstatic int  udp_socket[100];\nstatic int  num_udp_socket;\nstatic struct event_base *main_base;\nstatic struct independent_stats *default_independent_stats;\n\nstatic struct engine_event_handler *engine_event_handlers[MAX_ENGINE_EVENT_TYPE + 1];\n\nenum transmit_result {\n    TRANSMIT_COMPLETE,   /** All done writing. */\n    TRANSMIT_INCOMPLETE, /** More data remaining to write. */\n    TRANSMIT_SOFT_ERROR, /** Can't write any more right now. */\n    TRANSMIT_HARD_ERROR  /** Can't write (c->state is set to conn_closing) */\n};\n\nstatic enum transmit_result transmit(conn *c);\n\n#define REALTIME_MAXDELTA 60*60*24*30\n\n// Perform all callbacks of a given type for the given connection.\nstatic void perform_callbacks(ENGINE_EVENT_TYPE type,\n                              const void *data,\n                              const void *c) {\n    for (struct engine_event_handler *h = engine_event_handlers[type];\n         h; h = h->next) {\n        h->cb(c, type, data, h->cb_data);\n    }\n}\n\n/*\n * given time value that's either unix time or delta from current unix time,\n * return unix time. Use the fact that delta can't exceed one month\n * (and real time value can't be that low).\n */\nstatic rel_time_t realtime(const time_t exptime) {\n    /* no. of seconds in 30 days - largest possible delta exptime */\n\n    if (exptime == 0) return 0; /* 0 means never expire */\n\n    if (exptime > REALTIME_MAXDELTA) {\n        /* if item expiration is at/before the server started, give it an\n           expiration time of 1 second after the server started.\n           (because 0 means don't expire).  without this, we'd\n           underflow and wrap around to some large value way in the\n           future, effectively making items expiring in the past\n           really expiring never */\n        if (exptime <= process_started)\n            return (rel_time_t)1;\n        return (rel_time_t)(exptime - process_started);\n    } else {\n        return (rel_time_t)(exptime + current_time);\n    }\n}\n\n/**\n * Convert the relative time to an absolute time (relative to EPOC ;) )\n */\nstatic time_t abstime(const rel_time_t exptime)\n{\n    return process_started + exptime;\n}\n\nstatic void stats_init(void) {\n    stats.daemon_conns = 0;\n    stats.rejected_conns = 0;\n    stats.curr_conns = stats.total_conns = stats.conn_structs = 0;\n\n    stats_prefix_init();\n}\n\nstatic void stats_reset(const void *cookie) {\n    struct conn *conn = (struct conn*)cookie;\n    STATS_LOCK();\n    stats.rejected_conns = 0;\n    stats.total_conns = 0;\n    stats_prefix_clear();\n    STATS_UNLOCK();\n    threadlocal_stats_reset(get_independent_stats(conn)->thread_stats);\n    settings.engine.v1->reset_stats(settings.engine.v0, cookie);\n}\n\nstatic void settings_init(void) {\n    settings.use_cas = true;\n    settings.access = 0700;\n    settings.port = 11211;\n    settings.udpport = 11211;\n    /* By default this string should be NULL for getaddrinfo() */\n    settings.inter = NULL;\n    settings.maxbytes = 64 * 1024 * 1024; /* default is 64MB */\n    settings.maxconns = 1000;         /* to limit connections-related memory to about 5MB */\n    settings.verbose = 0;\n    settings.oldest_live = 0;\n    settings.evict_to_free = 1;       /* push old items out of cache when memory runs out */\n    settings.socketpath = NULL;       /* by default, not using a unix socket */\n    settings.factor = 1.25;\n    settings.chunk_size = 48;         /* space for a modest key and value */\n    settings.num_threads = 4;         /* N workers */\n    settings.num_threads_per_udp = 0;\n    settings.prefix_delimiter = ':';\n    settings.detail_enabled = 0;\n    settings.allow_detailed = true;\n    settings.reqs_per_event = DEFAULT_REQS_PER_EVENT;\n    settings.backlog = 1024;\n    settings.binding_protocol = negotiating_prot;\n    settings.item_size_max = 1024 * 1024; /* The famous 1MB upper limit. */\n    settings.topkeys = 0;\n    settings.require_sasl = false;\n    settings.extensions.logger = get_stderr_logger();\n}\n\n/*\n * Adds a message header to a connection.\n *\n * Returns 0 on success, -1 on out-of-memory.\n */\nstatic int add_msghdr(conn *c)\n{\n    struct msghdr *msg;\n\n    assert(c != NULL);\n\n    if (c->msgsize == c->msgused) {\n        msg = realloc(c->msglist, c->msgsize * 2 * sizeof(struct msghdr));\n        if (! msg)\n            return -1;\n        c->msglist = msg;\n        c->msgsize *= 2;\n    }\n\n    msg = c->msglist + c->msgused;\n\n    /* this wipes msg_iovlen, msg_control, msg_controllen, and\n       msg_flags, the last 3 of which aren't defined on solaris: */\n    memset(msg, 0, sizeof(struct msghdr));\n\n    msg->msg_iov = &c->iov[c->iovused];\n\n    if (c->request_addr_size > 0) {\n        msg->msg_name = &c->request_addr;\n        msg->msg_namelen = c->request_addr_size;\n    }\n\n    c->msgbytes = 0;\n    c->msgused++;\n\n    if (IS_UDP(c->transport)) {\n        /* Leave room for the UDP header, which we'll fill in later. */\n        return add_iov(c, NULL, UDP_HEADER_SIZE);\n    }\n\n    return 0;\n}\n\nstatic const char *prot_text(enum protocol prot) {\n    char *rv = \"unknown\";\n    switch(prot) {\n        case ascii_prot:\n            rv = \"ascii\";\n            break;\n        case binary_prot:\n            rv = \"binary\";\n            break;\n        case negotiating_prot:\n            rv = \"auto-negotiate\";\n            break;\n    }\n    return rv;\n}\n\nstruct {\n    pthread_mutex_t mutex;\n    bool disabled;\n    ssize_t count;\n    uint64_t num_disable;\n} listen_state;\n\nstatic bool is_listen_disabled(void) {\n    bool ret;\n    pthread_mutex_lock(&listen_state.mutex);\n    ret = listen_state.disabled;\n    pthread_mutex_unlock(&listen_state.mutex);\n    return ret;\n}\n\nstatic uint64_t get_listen_disabled_num(void) {\n    uint64_t ret;\n    pthread_mutex_lock(&listen_state.mutex);\n    ret = listen_state.num_disable;\n    pthread_mutex_unlock(&listen_state.mutex);\n    return ret;\n}\n\nstatic void disable_listen(void) {\n    pthread_mutex_lock(&listen_state.mutex);\n    listen_state.disabled = true;\n    listen_state.count = 10;\n    ++listen_state.num_disable;\n    pthread_mutex_unlock(&listen_state.mutex);\n\n    conn *next;\n    for (next = listen_conn; next; next = next->next) {\n        update_event(next, 0);\n        if (listen(next->sfd, 1) != 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                            \"listen() failed\",\n                                            strerror(errno));\n        }\n    }\n}\n\nvoid safe_close(SOCKET sfd) {\n    if (sfd != INVALID_SOCKET) {\n        int rval;\n        while ((rval = closesocket(sfd)) == SOCKET_ERROR &&\n               (errno == EINTR || errno == EAGAIN)) {\n            /* go ahead and retry */\n        }\n\n        if (rval == SOCKET_ERROR) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                            \"Failed to close socket %d (%s)!!\\n\", (int)sfd,\n                                            strerror(errno));\n        } else {\n            STATS_LOCK();\n            stats.curr_conns--;\n            STATS_UNLOCK();\n\n            if (is_listen_disabled()) {\n                notify_dispatcher();\n            }\n        }\n    }\n}\n\n/*\n * Free list management for connections.\n */\ncache_t *conn_cache;      /* suffix cache */\n\n/**\n * Reset all of the dynamic buffers used by a connection back to their\n * default sizes. The strategy for resizing the buffers is to allocate a\n * new one of the correct size and free the old one if the allocation succeeds\n * instead of using realloc to change the buffer size (because realloc may\n * not shrink the buffers, and will also copy the memory). If the allocation\n * fails the buffer will be unchanged.\n *\n * @param c the connection to resize the buffers for\n * @return true if all allocations succeeded, false if one or more of the\n *         allocations failed.\n */\nstatic bool conn_reset_buffersize(conn *c) {\n    bool ret = true;\n\n    if (c->rsize != DATA_BUFFER_SIZE) {\n        void *ptr = malloc(DATA_BUFFER_SIZE);\n        if (ptr != NULL) {\n            free(c->rbuf);\n            c->rbuf = ptr;\n            c->rsize = DATA_BUFFER_SIZE;\n        } else {\n            ret = false;\n        }\n    }\n\n    if (c->wsize != DATA_BUFFER_SIZE) {\n        void *ptr = malloc(DATA_BUFFER_SIZE);\n        if (ptr != NULL) {\n            free(c->wbuf);\n            c->wbuf = ptr;\n            c->wsize = DATA_BUFFER_SIZE;\n        } else {\n            ret = false;\n        }\n    }\n\n    if (c->isize != ITEM_LIST_INITIAL) {\n        void *ptr = malloc(sizeof(item *) * ITEM_LIST_INITIAL);\n        if (ptr != NULL) {\n            free(c->ilist);\n            c->ilist = ptr;\n            c->isize = ITEM_LIST_INITIAL;\n        } else {\n            ret = false;\n        }\n    }\n\n    if (c->suffixsize != SUFFIX_LIST_INITIAL) {\n        void *ptr = malloc(sizeof(char *) * SUFFIX_LIST_INITIAL);\n        if (ptr != NULL) {\n            free(c->suffixlist);\n            c->suffixlist = ptr;\n            c->suffixsize = SUFFIX_LIST_INITIAL;\n        } else {\n            ret = false;\n        }\n    }\n\n    if (c->iovsize != IOV_LIST_INITIAL) {\n        void *ptr = malloc(sizeof(struct iovec) * IOV_LIST_INITIAL);\n        if (ptr != NULL) {\n            free(c->iov);\n            c->iov = ptr;\n            c->iovsize = IOV_LIST_INITIAL;\n        } else {\n            ret = false;\n        }\n    }\n\n    if (c->msgsize != MSG_LIST_INITIAL) {\n        void *ptr = malloc(sizeof(struct msghdr) * MSG_LIST_INITIAL);\n        if (ptr != NULL) {\n            free(c->msglist);\n            c->msglist = ptr;\n            c->msgsize = MSG_LIST_INITIAL;\n        } else {\n            ret = false;\n        }\n    }\n\n    return ret;\n}\n\n/**\n * Constructor for all memory allocations of connection objects. Initialize\n * all members and allocate the transfer buffers.\n *\n * @param buffer The memory allocated by the object cache\n * @param unused1 not used\n * @param unused2 not used\n * @return 0 on success, 1 if we failed to allocate memory\n */\nstatic int conn_constructor(void *buffer, void *unused1, int unused2) {\n    (void)unused1; (void)unused2;\n\n    conn *c = buffer;\n    memset(c, 0, sizeof(*c));\n    MEMCACHED_CONN_CREATE(c);\n\n    if (!conn_reset_buffersize(c)) {\n        free(c->rbuf);\n        free(c->wbuf);\n        free(c->ilist);\n        free(c->suffixlist);\n        free(c->iov);\n        free(c->msglist);\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING,\n                                        NULL,\n                                        \"Failed to allocate buffers for connection\\n\");\n        return 1;\n    }\n\n    STATS_LOCK();\n    stats.conn_structs++;\n    STATS_UNLOCK();\n\n    return 0;\n}\n\n/**\n * Destructor for all connection objects. Release all allocated resources.\n *\n * @param buffer The memory allocated by the objec cache\n * @param unused not used\n */\nstatic void conn_destructor(void *buffer, void *unused) {\n    (void)unused;\n    conn *c = buffer;\n    free(c->rbuf);\n    free(c->wbuf);\n    free(c->ilist);\n    free(c->suffixlist);\n    free(c->iov);\n    free(c->msglist);\n\n    STATS_LOCK();\n    stats.conn_structs--;\n    STATS_UNLOCK();\n}\n\nconn *conn_new(const SOCKET sfd, STATE_FUNC init_state,\n               const int event_flags,\n               const int read_buffer_size, enum network_transport transport,\n               struct event_base *base, struct timeval *timeout) {\n    conn *c = cache_alloc(conn_cache);\n    if (c == NULL) {\n        return NULL;\n    }\n\n    assert(c->thread == NULL);\n\n    if (c->rsize < read_buffer_size) {\n        void *mem = malloc(read_buffer_size);\n        if (mem) {\n            c->rsize = read_buffer_size;\n            free(c->rbuf);\n            c->rbuf = mem;\n        } else {\n            assert(c->thread == NULL);\n            cache_free(conn_cache, c);\n            return NULL;\n        }\n    }\n\n    c->transport = transport;\n    c->protocol = settings.binding_protocol;\n\n    /* unix socket mode doesn't need this, so zeroed out.  but why\n     * is this done for every command?  presumably for UDP\n     * mode.  */\n    if (!settings.socketpath) {\n        c->request_addr_size = sizeof(c->request_addr);\n    } else {\n        c->request_addr_size = 0;\n    }\n\n    if (settings.verbose > 1) {\n        if (init_state == conn_listening) {\n            settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                            \"<%d server listening (%s)\\n\", sfd,\n                                            prot_text(c->protocol));\n        } else if (IS_UDP(transport)) {\n            settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                            \"<%d server listening (udp)\\n\", sfd);\n        } else if (c->protocol == negotiating_prot) {\n            settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                            \"<%d new auto-negotiating client connection\\n\",\n                                            sfd);\n        } else if (c->protocol == ascii_prot) {\n            settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                            \"<%d new ascii client connection.\\n\", sfd);\n        } else if (c->protocol == binary_prot) {\n            settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                            \"<%d new binary client connection.\\n\", sfd);\n        } else {\n            settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                            \"<%d new unknown (%d) client connection\\n\",\n                                            sfd, c->protocol);\n            assert(false);\n        }\n    }\n\n    c->sfd = sfd;\n    c->state = init_state;\n    c->rlbytes = 0;\n    c->cmd = -1;\n    c->ascii_cmd = NULL;\n    c->rbytes = c->wbytes = 0;\n    c->wcurr = c->wbuf;\n    c->rcurr = c->rbuf;\n    c->ritem = 0;\n    c->icurr = c->ilist;\n    c->suffixcurr = c->suffixlist;\n    c->ileft = 0;\n    c->suffixleft = 0;\n    c->iovused = 0;\n    c->msgcurr = 0;\n    c->msgused = 0;\n    c->next = NULL;\n    c->list_state = 0;\n\n    c->write_and_go = init_state;\n    c->write_and_free = 0;\n    c->item = 0;\n\n    c->noreply = false;\n\n    event_set(&c->event, sfd, event_flags, event_handler, (void *)c);\n    event_base_set(base, &c->event);\n    c->ev_flags = event_flags;\n\n    if (!register_event(c, timeout)) {\n        assert(c->thread == NULL);\n        cache_free(conn_cache, c);\n        return NULL;\n    }\n\n    STATS_LOCK();\n    stats.total_conns++;\n    STATS_UNLOCK();\n\n    c->aiostat = ENGINE_SUCCESS;\n    c->ewouldblock = false;\n    c->refcount = 1;\n\n    MEMCACHED_CONN_ALLOCATE(c->sfd);\n\n    perform_callbacks(ON_CONNECT, NULL, c);\n\n    return c;\n}\n\nstatic void conn_cleanup(conn *c) {\n    assert(c != NULL);\n\n    if (c->item) {\n        settings.engine.v1->release(settings.engine.v0, c, c->item);\n        c->item = 0;\n    }\n\n    if (c->ileft != 0) {\n        for (; c->ileft > 0; c->ileft--,c->icurr++) {\n            settings.engine.v1->release(settings.engine.v0, c, *(c->icurr));\n        }\n    }\n\n    if (c->suffixleft != 0) {\n        for (; c->suffixleft > 0; c->suffixleft--, c->suffixcurr++) {\n            cache_free(c->thread->suffix_cache, *(c->suffixcurr));\n        }\n    }\n\n    if (c->write_and_free) {\n        free(c->write_and_free);\n        c->write_and_free = 0;\n    }\n\n    if (c->sasl_conn) {\n        sasl_dispose(&c->sasl_conn);\n        c->sasl_conn = NULL;\n    }\n\n    if (c->engine_storage) {\n\tvoid* cleanup_data = c->engine_storage;\n\tc->engine_storage = NULL;\n\tsettings.engine.v1->clean_engine(settings.engine.v0, c, cleanup_data);\n    }\n\n    c->tap_iterator = NULL;\n    c->thread = NULL;\n    assert(c->next == NULL);\n    c->ascii_cmd = NULL;\n    c->sfd = INVALID_SOCKET;\n    c->tap_nack_mode = false;\n}\n\nvoid conn_close(conn *c) {\n    assert(c != NULL);\n    assert(c->sfd == INVALID_SOCKET);\n\n    if (c->ascii_cmd != NULL) {\n        c->ascii_cmd->abort(c->ascii_cmd, c);\n    }\n\n    assert(c->thread);\n    LOCK_THREAD(c->thread);\n    /* remove from pending-io list */\n    if (settings.verbose > 1 && list_contains(c->thread->pending_io, c)) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                        \"Current connection was in the pending-io list.. Nuking it\\n\");\n    }\n    c->thread->pending_io = list_remove(c->thread->pending_io, c);\n    c->thread->pending_close = list_remove(c->thread->pending_close, c);\n    UNLOCK_THREAD(c->thread);\n\n    conn_cleanup(c);\n\n    /*\n     * The contract with the object cache is that we should return the\n     * object in a constructed state. Reset the buffers to the default\n     * size\n     */\n    conn_reset_buffersize(c);\n    assert(c->thread == NULL);\n    cache_free(conn_cache, c);\n}\n\n/*\n * Shrinks a connection's buffers if they're too big.  This prevents\n * periodic large \"get\" requests from permanently chewing lots of server\n * memory.\n *\n * This should only be called in between requests since it can wipe output\n * buffers!\n */\nstatic void conn_shrink(conn *c) {\n    assert(c != NULL);\n\n    if (IS_UDP(c->transport))\n        return;\n\n    if (c->rsize > READ_BUFFER_HIGHWAT && c->rbytes < DATA_BUFFER_SIZE) {\n        char *newbuf;\n\n        if (c->rcurr != c->rbuf)\n            memmove(c->rbuf, c->rcurr, (size_t)c->rbytes);\n\n        newbuf = (char *)realloc((void *)c->rbuf, DATA_BUFFER_SIZE);\n\n        if (newbuf) {\n            c->rbuf = newbuf;\n            c->rsize = DATA_BUFFER_SIZE;\n        }\n        /* TODO check other branch... */\n        c->rcurr = c->rbuf;\n    }\n\n    if (c->isize > ITEM_LIST_HIGHWAT) {\n        item **newbuf = (item**) realloc((void *)c->ilist, ITEM_LIST_INITIAL * sizeof(c->ilist[0]));\n        if (newbuf) {\n            c->ilist = newbuf;\n            c->isize = ITEM_LIST_INITIAL;\n        }\n    /* TODO check error condition? */\n    }\n\n    if (c->msgsize > MSG_LIST_HIGHWAT) {\n        struct msghdr *newbuf = (struct msghdr *) realloc((void *)c->msglist, MSG_LIST_INITIAL * sizeof(c->msglist[0]));\n        if (newbuf) {\n            c->msglist = newbuf;\n            c->msgsize = MSG_LIST_INITIAL;\n        }\n    /* TODO check error condition? */\n    }\n\n    if (c->iovsize > IOV_LIST_HIGHWAT) {\n        struct iovec *newbuf = (struct iovec *) realloc((void *)c->iov, IOV_LIST_INITIAL * sizeof(c->iov[0]));\n        if (newbuf) {\n            c->iov = newbuf;\n            c->iovsize = IOV_LIST_INITIAL;\n        }\n    /* TODO check return value */\n    }\n}\n\n/**\n * Convert a state name to a human readable form.\n */\nconst char *state_text(STATE_FUNC state) {\n    if (state == conn_listening) {\n        return \"conn_listening\";\n    } else if (state == conn_new_cmd) {\n        return \"conn_new_cmd\";\n    } else if (state == conn_waiting) {\n        return \"conn_waiting\";\n    } else if (state == conn_read) {\n        return \"conn_read\";\n    } else if (state == conn_parse_cmd) {\n        return \"conn_parse_cmd\";\n    } else if (state == conn_write) {\n        return \"conn_write\";\n    } else if (state == conn_nread) {\n        return \"conn_nread\";\n    } else if (state == conn_swallow) {\n        return \"conn_swallow\";\n    } else if (state == conn_closing) {\n        return \"conn_closing\";\n    } else if (state == conn_mwrite) {\n        return \"conn_mwrite\";\n    } else if (state == conn_ship_log) {\n        return \"conn_ship_log\";\n    } else if (state == conn_add_tap_client) {\n        return \"conn_add_tap_client\";\n    } else if (state == conn_setup_tap_stream) {\n        return \"conn_setup_tap_stream\";\n    } else if (state == conn_pending_close) {\n        return \"conn_pending_close\";\n    } else if (state == conn_immediate_close) {\n        return \"conn_immediate_close\";\n    } else {\n        return \"Unknown\";\n    }\n}\n\n/*\n * Sets a connection's current state in the state machine. Any special\n * processing that needs to happen on certain state transitions can\n * happen here.\n */\nvoid conn_set_state(conn *c, STATE_FUNC state) {\n    assert(c != NULL);\n\n    if (state != c->state) {\n        /*\n         * The connections in the \"tap thread\" behaves differently than\n         * normal connections because they operate in a full duplex mode.\n         * New messages may appear from both sides, so we can't block on\n         * read from the nework / engine\n         */\n        if (c->thread == tap_thread) {\n            if (state == conn_waiting) {\n                c->which = EV_WRITE;\n                state = conn_ship_log;\n            }\n        }\n\n        if (settings.verbose > 2 || c->state == conn_closing\n            || c->state == conn_add_tap_client) {\n            settings.extensions.logger->log(EXTENSION_LOG_DETAIL, c,\n                                            \"%d: going from %s to %s\\n\",\n                                            c->sfd, state_text(c->state),\n                                            state_text(state));\n        }\n\n        c->state = state;\n\n        if (state == conn_write || state == conn_mwrite) {\n            MEMCACHED_PROCESS_COMMAND_END(c->sfd, c->wbuf, c->wbytes);\n        }\n    }\n}\n\n/*\n * Ensures that there is room for another struct iovec in a connection's\n * iov list.\n *\n * Returns 0 on success, -1 on out-of-memory.\n */\nstatic int ensure_iov_space(conn *c) {\n    assert(c != NULL);\n\n    if (c->iovused >= c->iovsize) {\n        int i, iovnum;\n        struct iovec *new_iov = (struct iovec *)realloc(c->iov,\n                                (c->iovsize * 2) * sizeof(struct iovec));\n        if (! new_iov)\n            return -1;\n        c->iov = new_iov;\n        c->iovsize *= 2;\n\n        /* Point all the msghdr structures at the new list. */\n        for (i = 0, iovnum = 0; i < c->msgused; i++) {\n            c->msglist[i].msg_iov = &c->iov[iovnum];\n            iovnum += c->msglist[i].msg_iovlen;\n        }\n    }\n\n    return 0;\n}\n\n\n/*\n * Adds data to the list of pending data that will be written out to a\n * connection.\n *\n * Returns 0 on success, -1 on out-of-memory.\n */\n\nstatic int add_iov(conn *c, const void *buf, int len) {\n    struct msghdr *m;\n    int leftover;\n    bool limit_to_mtu;\n\n    assert(c != NULL);\n\n    do {\n        m = &c->msglist[c->msgused - 1];\n\n        /*\n         * Limit UDP packets, and the first payloads of TCP replies, to\n         * UDP_MAX_PAYLOAD_SIZE bytes.\n         */\n        limit_to_mtu = IS_UDP(c->transport) || (1 == c->msgused);\n\n        /* We may need to start a new msghdr if this one is full. */\n        if (m->msg_iovlen == IOV_MAX ||\n            (limit_to_mtu && c->msgbytes >= UDP_MAX_PAYLOAD_SIZE)) {\n            add_msghdr(c);\n            m = &c->msglist[c->msgused - 1];\n        }\n\n        if (ensure_iov_space(c) != 0)\n            return -1;\n\n        /* If the fragment is too big to fit in the datagram, split it up */\n        if (limit_to_mtu && len + c->msgbytes > UDP_MAX_PAYLOAD_SIZE) {\n            leftover = len + c->msgbytes - UDP_MAX_PAYLOAD_SIZE;\n            len -= leftover;\n        } else {\n            leftover = 0;\n        }\n\n        m = &c->msglist[c->msgused - 1];\n        m->msg_iov[m->msg_iovlen].iov_base = (void *)buf;\n        m->msg_iov[m->msg_iovlen].iov_len = len;\n\n        c->msgbytes += len;\n        c->iovused++;\n        m->msg_iovlen++;\n\n        buf = ((char *)buf) + len;\n        len = leftover;\n    } while (leftover > 0);\n\n    return 0;\n}\n\n\n/*\n * Constructs a set of UDP headers and attaches them to the outgoing messages.\n */\nstatic int build_udp_headers(conn *c) {\n    int i;\n    unsigned char *hdr;\n\n    assert(c != NULL);\n\n    if (c->msgused > c->hdrsize) {\n        void *new_hdrbuf;\n        if (c->hdrbuf)\n            new_hdrbuf = realloc(c->hdrbuf, c->msgused * 2 * UDP_HEADER_SIZE);\n        else\n            new_hdrbuf = malloc(c->msgused * 2 * UDP_HEADER_SIZE);\n        if (! new_hdrbuf)\n            return -1;\n        c->hdrbuf = (unsigned char *)new_hdrbuf;\n        c->hdrsize = c->msgused * 2;\n    }\n\n    hdr = c->hdrbuf;\n    for (i = 0; i < c->msgused; i++) {\n        c->msglist[i].msg_iov[0].iov_base = (void*)hdr;\n        c->msglist[i].msg_iov[0].iov_len = UDP_HEADER_SIZE;\n        *hdr++ = c->request_id / 256;\n        *hdr++ = c->request_id % 256;\n        *hdr++ = i / 256;\n        *hdr++ = i % 256;\n        *hdr++ = c->msgused / 256;\n        *hdr++ = c->msgused % 256;\n        *hdr++ = 0;\n        *hdr++ = 0;\n        assert((void *) hdr == (caddr_t)c->msglist[i].msg_iov[0].iov_base + UDP_HEADER_SIZE);\n    }\n\n    return 0;\n}\n\n\nstatic void out_string(conn *c, const char *str) {\n    size_t len;\n\n    assert(c != NULL);\n\n    if (c->noreply) {\n        if (settings.verbose > 1) {\n            settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                            \">%d NOREPLY %s\\n\", c->sfd, str);\n        }\n        c->noreply = false;\n        if (c->sbytes > 0) {\n            conn_set_state(c, conn_swallow);\n        } else {\n            conn_set_state(c, conn_new_cmd);\n        }\n        return;\n    }\n\n    if (settings.verbose > 1) {\n        settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                        \">%d %s\\n\", c->sfd, str);\n    }\n\n    /* Nuke a partial output... */\n    c->msgcurr = 0;\n    c->msgused = 0;\n    c->iovused = 0;\n    add_msghdr(c);\n\n    len = strlen(str);\n    if ((len + 2) > c->wsize) {\n        /* ought to be always enough. just fail for simplicity */\n        str = \"SERVER_ERROR output line too long\";\n        len = strlen(str);\n    }\n\n    memcpy(c->wbuf, str, len);\n    memcpy(c->wbuf + len, \"\\r\\n\", 2);\n    c->wbytes = len + 2;\n    c->wcurr = c->wbuf;\n\n    conn_set_state(c, conn_write);\n\n    if (c->sbytes > 0) {\n        c->write_and_go = conn_swallow;\n    } else {\n        c->write_and_go = conn_new_cmd;\n    }\n\n    return;\n}\n\n/*\n * we get here after reading the value in set/add/replace commands. The command\n * has been stored in c->cmd, and the item is ready in c->item.\n */\nstatic void complete_update_ascii(conn *c) {\n    assert(c != NULL);\n\n    item *it = c->item;\n    item_info info = { .nvalue = 1 };\n    if (!settings.engine.v1->get_item_info(settings.engine.v0, c, it, &info)) {\n        settings.engine.v1->release(settings.engine.v0, c, it);\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                        \"%d: Failed to get item info\\n\",\n                                        c->sfd);\n        out_string(c, \"SERVER_ERROR failed to get item details\");\n        return;\n    }\n\n    c->sbytes = 2; // swallow \\r\\n\n    ENGINE_ERROR_CODE ret = c->aiostat;\n    c->aiostat = ENGINE_SUCCESS;\n    if (ret == ENGINE_SUCCESS) {\n        ret = settings.engine.v1->store(settings.engine.v0, c, it, &c->cas,\n                                        c->store_op, 0);\n    }\n\n#ifdef ENABLE_DTRACE\n    switch (c->store_op) {\n    case OPERATION_ADD:\n        MEMCACHED_COMMAND_ADD(c->sfd, info.key, info.nkey,\n                              (ret == ENGINE_SUCCESS) ? info.nbytes : -1, c->cas);\n        break;\n    case OPERATION_REPLACE:\n        MEMCACHED_COMMAND_REPLACE(c->sfd, info.key, info.nkey,\n                                  (ret == ENGINE_SUCCESS) ? info.nbytes : -1, c->cas);\n        break;\n    case OPERATION_APPEND:\n        MEMCACHED_COMMAND_APPEND(c->sfd, info.key, info.nkey,\n                                 (ret == ENGINE_SUCCESS) ? info.nbytes : -1, c->cas);\n        break;\n    case OPERATION_PREPEND:\n        MEMCACHED_COMMAND_PREPEND(c->sfd, info.key, info.nkey,\n                                  (ret == ENGINE_SUCCESS) ? info.nbytes : -1, c->cas);\n        break;\n    case OPERATION_SET:\n        MEMCACHED_COMMAND_SET(c->sfd, info.key, info.nkey,\n                              (ret == ENGINE_SUCCESS) ? info.nbytes : -1, c->cas);\n        break;\n    case OPERATION_CAS:\n        MEMCACHED_COMMAND_CAS(c->sfd, info.key, info.nkey, info.nbytes, c->cas);\n        break;\n    }\n#endif\n\n    switch (ret) {\n    case ENGINE_SUCCESS:\n        out_string(c, \"STORED\");\n        break;\n    case ENGINE_KEY_EEXISTS:\n        out_string(c, \"EXISTS\");\n        break;\n    case ENGINE_KEY_ENOENT:\n        out_string(c, \"NOT_FOUND\");\n        break;\n    case ENGINE_NOT_STORED:\n        out_string(c, \"NOT_STORED\");\n        break;\n    case ENGINE_DISCONNECT:\n        c->state = conn_closing;\n        break;\n    case ENGINE_ENOTSUP:\n        out_string(c, \"SERVER_ERROR not supported\");\n        break;\n    case ENGINE_ENOMEM:\n        out_string(c, \"SERVER_ERROR out of memory\");\n        break;\n    case ENGINE_TMPFAIL:\n        out_string(c, \"SERVER_ERROR temporary failure\");\n        break;\n    case ENGINE_EINVAL:\n        out_string(c, \"CLIENT_ERROR invalid arguments\");\n        break;\n    case ENGINE_E2BIG:\n        out_string(c, \"CLIENT_ERROR value too big\");\n        break;\n    case ENGINE_EACCESS:\n        out_string(c, \"CLIENT_ERROR access control violation\");\n        break;\n    case ENGINE_NOT_MY_VBUCKET:\n        out_string(c, \"SERVER_ERROR not my vbucket\");\n        break;\n    case ENGINE_FAILED:\n        out_string(c, \"SERVER_ERROR failure\");\n        break;\n    case ENGINE_EWOULDBLOCK:\n        c->ewouldblock = true;\n        break;\n    case ENGINE_WANT_MORE:\n        assert(false);\n        c->state = conn_closing;\n        break;\n\n    default:\n        out_string(c, \"SERVER_ERROR internal\");\n    }\n\n    if (c->store_op == OPERATION_CAS) {\n        switch (ret) {\n        case ENGINE_SUCCESS:\n            SLAB_INCR(c, cas_hits, info.key, info.nkey);\n            break;\n        case ENGINE_KEY_EEXISTS:\n            SLAB_INCR(c, cas_badval, info.key, info.nkey);\n            break;\n        case ENGINE_KEY_ENOENT:\n            STATS_NOKEY(c, cas_misses);\n            break;\n        default:\n            ;\n        }\n    } else {\n        SLAB_INCR(c, cmd_set, info.key, info.nkey);\n    }\n\n    if (!c->ewouldblock) {\n        /* release the c->item reference */\n        settings.engine.v1->release(settings.engine.v0, c, c->item);\n        c->item = 0;\n    }\n}\n\n/**\n * get a pointer to the start of the request struct for the current command\n */\nstatic void* binary_get_request(conn *c) {\n    char *ret = c->rcurr;\n    ret -= (sizeof(c->binary_header) + c->binary_header.request.keylen +\n            c->binary_header.request.extlen);\n\n    assert(ret >= c->rbuf);\n    return ret;\n}\n\n/**\n * get a pointer to the key in this request\n */\nstatic char* binary_get_key(conn *c) {\n    return c->rcurr - (c->binary_header.request.keylen);\n}\n\n/**\n * Insert a key into a buffer, but replace all non-printable characters\n * with a '.'.\n *\n * @param dest where to store the output\n * @param destsz size of destination buffer\n * @param prefix string to insert before the data\n * @param client the client we are serving\n * @param from_client set to true if this data is from the client\n * @param key the key to add to the buffer\n * @param nkey the number of bytes in the key\n * @return number of bytes in dest if success, -1 otherwise\n */\nstatic ssize_t key_to_printable_buffer(char *dest, size_t destsz,\n                                       int client, bool from_client,\n                                       const char *prefix,\n                                       const char *key,\n                                       size_t nkey)\n{\n    ssize_t nw = snprintf(dest, destsz, \"%c%d %s \", from_client ? '>' : '<',\n                          client, prefix);\n    if (nw == -1) {\n        return -1;\n    }\n\n    char *ptr = dest + nw;\n    destsz -= nw;\n    if (nkey > destsz) {\n        nkey = destsz;\n    }\n\n    for (ssize_t ii = 0; ii < nkey; ++ii, ++key, ++ptr) {\n        if (isgraph(*key)) {\n            *ptr = *key;\n        } else {\n            *ptr = '.';\n        }\n    }\n\n    *ptr = '\\0';\n    return ptr - dest;\n}\n\n/**\n * Convert a byte array to a text string\n *\n * @param dest where to store the output\n * @param destsz size of destination buffer\n * @param prefix string to insert before the data\n * @param client the client we are serving\n * @param from_client set to true if this data is from the client\n * @param data the data to add to the buffer\n * @param size the number of bytes in data to print\n * @return number of bytes in dest if success, -1 otherwise\n */\nstatic ssize_t bytes_to_output_string(char *dest, size_t destsz,\n                                      int client, bool from_client,\n                                      const char *prefix,\n                                      const char *data,\n                                      size_t size)\n{\n    ssize_t nw = snprintf(dest, destsz, \"%c%d %s\", from_client ? '>' : '<',\n                          client, prefix);\n    if (nw == -1) {\n        return -1;\n    }\n    ssize_t offset = nw;\n\n    for (ssize_t ii = 0; ii < size; ++ii) {\n        if (ii % 4 == 0) {\n            if ((nw = snprintf(dest + offset, destsz - offset, \"\\n%c%d  \",\n                               from_client ? '>' : '<', client)) == -1) {\n                return  -1;\n            }\n            offset += nw;\n        }\n        if ((nw = snprintf(dest + offset, destsz - offset,\n                           \" 0x%02x\", (unsigned char)data[ii])) == -1) {\n            return -1;\n        }\n        offset += nw;\n    }\n\n    if ((nw = snprintf(dest + offset, destsz - offset, \"\\n\")) == -1) {\n        return -1;\n    }\n\n    return offset + nw;\n}\n\nstatic void add_bin_header(conn *c, uint16_t err, uint8_t hdr_len, uint16_t key_len, uint32_t body_len) {\n    protocol_binary_response_header* header;\n\n    assert(c);\n\n    c->msgcurr = 0;\n    c->msgused = 0;\n    c->iovused = 0;\n    if (add_msghdr(c) != 0) {\n        /* XXX:  out_string is inappropriate here */\n        out_string(c, \"SERVER_ERROR out of memory\");\n        return;\n    }\n\n    header = (protocol_binary_response_header *)c->wbuf;\n\n    header->response.magic = (uint8_t)PROTOCOL_BINARY_RES;\n    header->response.opcode = c->binary_header.request.opcode;\n    header->response.keylen = (uint16_t)htons(key_len);\n\n    header->response.extlen = (uint8_t)hdr_len;\n    header->response.datatype = (uint8_t)PROTOCOL_BINARY_RAW_BYTES;\n    header->response.status = (uint16_t)htons(err);\n\n    header->response.bodylen = htonl(body_len);\n    header->response.opaque = c->opaque;\n    header->response.cas = htonll(c->cas);\n\n    if (settings.verbose > 1) {\n        char buffer[1024];\n        if (bytes_to_output_string(buffer, sizeof(buffer), c->sfd, false,\n                                   \"Writing bin response:\",\n                                   (const char*)header->bytes,\n                                   sizeof(header->bytes)) != -1) {\n            settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                            \"%s\", buffer);\n        }\n    }\n\n    add_iov(c, c->wbuf, sizeof(header->response));\n}\n\n/**\n * Convert an error code generated from the storage engine to the corresponding\n * error code used by the protocol layer.\n * @param e the error code as used in the engine\n * @return the error code as used by the protocol layer\n */\nstatic protocol_binary_response_status engine_error_2_protocol_error(ENGINE_ERROR_CODE e) {\n    protocol_binary_response_status ret;\n\n    switch (e) {\n    case ENGINE_SUCCESS:\n        return PROTOCOL_BINARY_RESPONSE_SUCCESS;\n    case ENGINE_KEY_ENOENT:\n        return PROTOCOL_BINARY_RESPONSE_KEY_ENOENT;\n    case ENGINE_KEY_EEXISTS:\n        return PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS;\n    case ENGINE_ENOMEM:\n        return PROTOCOL_BINARY_RESPONSE_ENOMEM;\n    case ENGINE_TMPFAIL:\n        return PROTOCOL_BINARY_RESPONSE_ETMPFAIL;\n    case ENGINE_NOT_STORED:\n        return PROTOCOL_BINARY_RESPONSE_NOT_STORED;\n    case ENGINE_EINVAL:\n        return PROTOCOL_BINARY_RESPONSE_EINVAL;\n    case ENGINE_ENOTSUP:\n        return PROTOCOL_BINARY_RESPONSE_NOT_SUPPORTED;\n    case ENGINE_E2BIG:\n        return PROTOCOL_BINARY_RESPONSE_E2BIG;\n    case ENGINE_NOT_MY_VBUCKET:\n        return PROTOCOL_BINARY_RESPONSE_NOT_MY_VBUCKET;\n    default:\n        ret = PROTOCOL_BINARY_RESPONSE_EINTERNAL;\n    }\n\n    return ret;\n}\n\nstatic void write_bin_packet(conn *c, protocol_binary_response_status err, int swallow) {\n    ssize_t len;\n    char buffer[1024] = { [sizeof(buffer) - 1] = '\\0' };\n\n    switch (err) {\n    case PROTOCOL_BINARY_RESPONSE_SUCCESS:\n        len = 0;\n        break;\n    case PROTOCOL_BINARY_RESPONSE_ENOMEM:\n        len = snprintf(buffer, sizeof(buffer), \"Out of memory\");\n        break;\n    case PROTOCOL_BINARY_RESPONSE_ETMPFAIL:\n        len = snprintf(buffer, sizeof(buffer), \"Temporary failure\");\n        break;\n    case PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND:\n        len = snprintf(buffer, sizeof(buffer), \"Unknown command\");\n        break;\n    case PROTOCOL_BINARY_RESPONSE_KEY_ENOENT:\n        len = snprintf(buffer, sizeof(buffer), \"Not found\");\n        break;\n    case PROTOCOL_BINARY_RESPONSE_EINVAL:\n        len = snprintf(buffer, sizeof(buffer), \"Invalid arguments\");\n        break;\n    case PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS:\n        len = snprintf(buffer, sizeof(buffer), \"Data exists for key\");\n        break;\n    case PROTOCOL_BINARY_RESPONSE_E2BIG:\n        len = snprintf(buffer, sizeof(buffer), \"Too large\");\n        break;\n    case PROTOCOL_BINARY_RESPONSE_DELTA_BADVAL:\n        len = snprintf(buffer, sizeof(buffer),\n                       \"Non-numeric server-side value for incr or decr\");\n        break;\n    case PROTOCOL_BINARY_RESPONSE_NOT_STORED:\n        len = snprintf(buffer, sizeof(buffer), \"Not stored\");\n        break;\n    case PROTOCOL_BINARY_RESPONSE_AUTH_ERROR:\n        len = snprintf(buffer, sizeof(buffer), \"Auth failure\");\n        break;\n    case PROTOCOL_BINARY_RESPONSE_NOT_SUPPORTED:\n        len = snprintf(buffer, sizeof(buffer), \"Not supported\");\n        break;\n    case PROTOCOL_BINARY_RESPONSE_NOT_MY_VBUCKET:\n        len = snprintf(buffer, sizeof(buffer),\n                       \"I'm not responsible for this vbucket\");\n        break;\n\n    default:\n        len = snprintf(buffer, sizeof(buffer), \"UNHANDLED ERROR (%d)\", err);\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                        \">%d UNHANDLED ERROR: %d\\n\", c->sfd, err);\n    }\n\n    /* Allow the engine to pass extra error information */\n    if (settings.engine.v1->errinfo != NULL) {\n        size_t elen = settings.engine.v1->errinfo(settings.engine.v0, c, buffer + len + 2,\n                                                  sizeof(buffer) - len - 3);\n\n        if (elen > 0) {\n            memcpy(buffer + len, \": \", 2);\n            len += elen + 2;\n        }\n    }\n\n    if (err != PROTOCOL_BINARY_RESPONSE_SUCCESS && settings.verbose > 1) {\n        settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                        \">%d Writing an error: %s\\n\", c->sfd,\n                                        buffer);\n    }\n\n    add_bin_header(c, err, 0, 0, len);\n    if (len > 0) {\n        add_iov(c, buffer, len);\n    }\n    conn_set_state(c, conn_mwrite);\n    if (swallow > 0) {\n        c->sbytes = swallow;\n        c->write_and_go = conn_swallow;\n    } else {\n        c->write_and_go = conn_new_cmd;\n    }\n}\n\n/* Form and send a response to a command over the binary protocol */\nstatic void write_bin_response(conn *c, void *d, int hlen, int keylen, int dlen) {\n    if (!c->noreply || c->cmd == PROTOCOL_BINARY_CMD_GET ||\n        c->cmd == PROTOCOL_BINARY_CMD_GETK) {\n        add_bin_header(c, 0, hlen, keylen, dlen);\n        if(dlen > 0) {\n            add_iov(c, d, dlen);\n        }\n        conn_set_state(c, conn_mwrite);\n        c->write_and_go = conn_new_cmd;\n    } else {\n        conn_set_state(c, conn_new_cmd);\n    }\n}\n\n\nstatic void complete_incr_bin(conn *c) {\n    protocol_binary_response_incr* rsp = (protocol_binary_response_incr*)c->wbuf;\n    protocol_binary_request_incr* req = binary_get_request(c);\n\n    assert(c != NULL);\n    assert(c->wsize >= sizeof(*rsp));\n\n    /* fix byteorder in the request */\n    uint64_t delta = ntohll(req->message.body.delta);\n    uint64_t initial = ntohll(req->message.body.initial);\n    rel_time_t expiration = ntohl(req->message.body.expiration);\n    char *key = binary_get_key(c);\n    size_t nkey = c->binary_header.request.keylen;\n    bool incr = (c->cmd == PROTOCOL_BINARY_CMD_INCREMENT ||\n                 c->cmd == PROTOCOL_BINARY_CMD_INCREMENTQ);\n\n    if (settings.verbose > 1) {\n        char buffer[1024];\n        ssize_t nw;\n        nw = key_to_printable_buffer(buffer, sizeof(buffer), c->sfd, true,\n                                     incr ? \"INCR\" : \"DECR\", key, nkey);\n        if (nw != -1) {\n            if (snprintf(buffer + nw, sizeof(buffer) - nw,\n                         \" %\" PRIu64 \", %\" PRIu64 \", %\" PRIu64 \"\\n\",\n                         delta, initial, (uint64_t)expiration) != -1) {\n                settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c, \"%s\",\n                                                buffer);\n            }\n        }\n    }\n\n    ENGINE_ERROR_CODE ret = c->aiostat;\n    c->aiostat = ENGINE_SUCCESS;\n    if (ret == ENGINE_SUCCESS) {\n        ret = settings.engine.v1->arithmetic(settings.engine.v0,\n                                             c, key, nkey, incr,\n                                             req->message.body.expiration != 0xffffffff,\n                                             delta, initial, expiration,\n                                             &c->cas,\n                                             &rsp->message.body.value,\n                                             c->binary_header.request.vbucket);\n    }\n\n    switch (ret) {\n    case ENGINE_SUCCESS:\n        rsp->message.body.value = htonll(rsp->message.body.value);\n        write_bin_response(c, &rsp->message.body, 0, 0,\n                           sizeof (rsp->message.body.value));\n        if (incr) {\n            STATS_INCR(c, incr_hits, key, nkey);\n        } else {\n            STATS_INCR(c, decr_hits, key, nkey);\n        }\n        break;\n    case ENGINE_KEY_EEXISTS:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS, 0);\n        break;\n    case ENGINE_KEY_ENOENT:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, 0);\n        if (c->cmd == PROTOCOL_BINARY_CMD_INCREMENT) {\n            STATS_INCR(c, incr_misses, key, nkey);\n        } else {\n            STATS_INCR(c, decr_misses, key, nkey);\n        }\n        break;\n    case ENGINE_ENOMEM:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, 0);\n        break;\n    case ENGINE_TMPFAIL:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_ETMPFAIL, 0);\n        break;\n    case ENGINE_EINVAL:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_DELTA_BADVAL, 0);\n        break;\n    case ENGINE_NOT_STORED:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_NOT_STORED, 0);\n        break;\n    case ENGINE_DISCONNECT:\n        c->state = conn_closing;\n        break;\n    case ENGINE_ENOTSUP:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_NOT_SUPPORTED, 0);\n        break;\n    case ENGINE_NOT_MY_VBUCKET:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_NOT_MY_VBUCKET, 0);\n        break;\n    case ENGINE_EWOULDBLOCK:\n        c->ewouldblock = true;\n        break;\n    default:\n        abort();\n    }\n}\n\nstatic void complete_update_bin(conn *c) {\n    protocol_binary_response_status eno = PROTOCOL_BINARY_RESPONSE_EINVAL;\n    assert(c != NULL);\n\n    item *it = c->item;\n    item_info info = { .nvalue = 1 };\n    if (!settings.engine.v1->get_item_info(settings.engine.v0, c, it, &info)) {\n        settings.engine.v1->release(settings.engine.v0, c, it);\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                        \"%d: Failed to get item info\\n\",\n                                        c->sfd);\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_EINTERNAL, 0);\n        return;\n    }\n\n    ENGINE_ERROR_CODE ret = c->aiostat;\n    c->aiostat = ENGINE_SUCCESS;\n    if (ret == ENGINE_SUCCESS) {\n        ret = settings.engine.v1->store(settings.engine.v0, c,\n                                        it, &c->cas, c->store_op,\n                                        c->binary_header.request.vbucket);\n    }\n\n#ifdef ENABLE_DTRACE\n    switch (c->cmd) {\n    case OPERATION_ADD:\n        MEMCACHED_COMMAND_ADD(c->sfd, info.key, info.nkey,\n                              (ret == ENGINE_SUCCESS) ? info.nbytes : -1, c->cas);\n        break;\n    case OPERATION_REPLACE:\n        MEMCACHED_COMMAND_REPLACE(c->sfd, info.key, info.nkey,\n                                  (ret == ENGINE_SUCCESS) ? info.nbytes : -1, c->cas);\n        break;\n    case OPERATION_APPEND:\n        MEMCACHED_COMMAND_APPEND(c->sfd, info.key, info.nkey,\n                                 (ret == ENGINE_SUCCESS) ? info.nbytes : -1, c->cas);\n        break;\n    case OPERATION_PREPEND:\n        MEMCACHED_COMMAND_PREPEND(c->sfd, info.key, info.nkey,\n                                  (ret == ENGINE_SUCCESS) ? info.nbytes : -1, c->cas);\n        break;\n    case OPERATION_SET:\n        MEMCACHED_COMMAND_SET(c->sfd, info.key, info.nkey,\n                              (ret == ENGINE_SUCCESS) ? info.nbytes : -1, c->cas);\n        break;\n    }\n#endif\n\n    switch (ret) {\n    case ENGINE_SUCCESS:\n        /* Stored */\n        write_bin_response(c, NULL, 0, 0, 0);\n        break;\n    case ENGINE_KEY_EEXISTS:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS, 0);\n        break;\n    case ENGINE_KEY_ENOENT:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, 0);\n        break;\n    case ENGINE_ENOMEM:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, 0);\n        break;\n    case ENGINE_TMPFAIL:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_ETMPFAIL, 0);\n        break;\n    case ENGINE_EWOULDBLOCK:\n        c->ewouldblock = true;\n        break;\n    case ENGINE_DISCONNECT:\n        c->state = conn_closing;\n        break;\n    case ENGINE_ENOTSUP:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_NOT_SUPPORTED, 0);\n        break;\n    case ENGINE_NOT_MY_VBUCKET:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_NOT_MY_VBUCKET, 0);\n        break;\n    default:\n        if (c->store_op == OPERATION_ADD) {\n            eno = PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS;\n        } else if(c->store_op == OPERATION_REPLACE) {\n            eno = PROTOCOL_BINARY_RESPONSE_KEY_ENOENT;\n        } else {\n            eno = PROTOCOL_BINARY_RESPONSE_NOT_STORED;\n        }\n        write_bin_packet(c, eno, 0);\n    }\n\n    if (c->store_op == OPERATION_CAS) {\n        switch (ret) {\n        case ENGINE_SUCCESS:\n            SLAB_INCR(c, cas_hits, info.key, info.nkey);\n            break;\n        case ENGINE_KEY_EEXISTS:\n            SLAB_INCR(c, cas_badval, info.key, info.nkey);\n            break;\n        case ENGINE_KEY_ENOENT:\n            STATS_NOKEY(c, cas_misses);\n            break;\n        default:\n            ;\n        }\n    } else {\n        SLAB_INCR(c, cmd_set, info.key, info.nkey);\n    }\n\n    if (!c->ewouldblock) {\n        /* release the c->item reference */\n        settings.engine.v1->release(settings.engine.v0, c, c->item);\n        c->item = 0;\n    }\n}\n\nstatic void process_bin_get(conn *c) {\n    item *it = NULL;\n\n    protocol_binary_response_get* rsp = (protocol_binary_response_get*)c->wbuf;\n    char* key = binary_get_key(c);\n    size_t nkey = c->binary_header.request.keylen;\n\n    if (settings.verbose > 1) {\n        char buffer[1024];\n        if (key_to_printable_buffer(buffer, sizeof(buffer), c->sfd, true,\n                                    \"GET\", key, nkey) != -1) {\n            settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c, \"%s\\n\",\n                                            buffer);\n        }\n    }\n\n    ENGINE_ERROR_CODE ret = c->aiostat;\n    c->aiostat = ENGINE_SUCCESS;\n    if (ret == ENGINE_SUCCESS) {\n        ret = settings.engine.v1->get(settings.engine.v0, c, &it, key, nkey,\n                                      c->binary_header.request.vbucket);\n    }\n\n    uint16_t keylen;\n    uint32_t bodylen;\n    item_info info = { .nvalue = 1 };\n\n    switch (ret) {\n    case ENGINE_SUCCESS:\n        if (!settings.engine.v1->get_item_info(settings.engine.v0, c, it, &info)) {\n            settings.engine.v1->release(settings.engine.v0, c, it);\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                            \"%d: Failed to get item info\\n\",\n                                            c->sfd);\n            write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_EINTERNAL, 0);\n            break;\n        }\n\n        keylen = 0;\n        bodylen = sizeof(rsp->message.body) + info.nbytes;\n\n        STATS_HIT(c, get, key, nkey);\n\n        if (c->cmd == PROTOCOL_BINARY_CMD_GETK) {\n            bodylen += nkey;\n            keylen = nkey;\n        }\n        add_bin_header(c, 0, sizeof(rsp->message.body), keylen, bodylen);\n        rsp->message.header.response.cas = htonll(info.cas);\n\n        // add the flags\n        rsp->message.body.flags = info.flags;\n        add_iov(c, &rsp->message.body, sizeof(rsp->message.body));\n\n        if (c->cmd == PROTOCOL_BINARY_CMD_GETK) {\n            add_iov(c, info.key, nkey);\n        }\n\n        add_iov(c, info.value[0].iov_base, info.value[0].iov_len);\n        conn_set_state(c, conn_mwrite);\n        /* Remember this item so we can garbage collect it later */\n        c->item = it;\n        break;\n    case ENGINE_KEY_ENOENT:\n        STATS_MISS(c, get, key, nkey);\n\n        MEMCACHED_COMMAND_GET(c->sfd, key, nkey, -1, 0);\n\n        if (c->noreply) {\n            conn_set_state(c, conn_new_cmd);\n        } else {\n            if (c->cmd == PROTOCOL_BINARY_CMD_GETK) {\n                char *ofs = c->wbuf + sizeof(protocol_binary_response_header);\n                add_bin_header(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT,\n                               0, nkey, nkey);\n                memcpy(ofs, key, nkey);\n                add_iov(c, ofs, nkey);\n                conn_set_state(c, conn_mwrite);\n            } else {\n                write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, 0);\n            }\n        }\n        break;\n    case ENGINE_EWOULDBLOCK:\n        c->ewouldblock = true;\n        break;\n    case ENGINE_DISCONNECT:\n        c->state = conn_closing;\n        break;\n    case ENGINE_TMPFAIL:\n\tbreak;\n    case ENGINE_ENOTSUP:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_NOT_SUPPORTED, 0);\n        break;\n    case ENGINE_NOT_MY_VBUCKET:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_NOT_MY_VBUCKET, 0);\n        break;\n    default:\n        /* @todo add proper error handling! */\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                        \"Unknown error code: %d\\n\", ret);\n        abort();\n    }\n\n    if (settings.detail_enabled && ret != ENGINE_EWOULDBLOCK) {\n        stats_prefix_record_get(key, nkey, ret == ENGINE_SUCCESS);\n    }\n}\n\nstatic void append_bin_stats(const char *key, const uint16_t klen,\n                             const char *val, const uint32_t vlen,\n                             conn *c) {\n    char *buf = c->dynamic_buffer.buffer + c->dynamic_buffer.offset;\n    uint32_t bodylen = klen + vlen;\n    protocol_binary_response_header header = {\n        .response.magic = (uint8_t)PROTOCOL_BINARY_RES,\n        .response.opcode = PROTOCOL_BINARY_CMD_STAT,\n        .response.keylen = (uint16_t)htons(klen),\n        .response.datatype = (uint8_t)PROTOCOL_BINARY_RAW_BYTES,\n        .response.bodylen = htonl(bodylen),\n        .response.opaque = c->opaque\n    };\n\n    memcpy(buf, header.bytes, sizeof(header.response));\n    buf += sizeof(header.response);\n\n    if (klen > 0) {\n        memcpy(buf, key, klen);\n        buf += klen;\n\n        if (vlen > 0) {\n            memcpy(buf, val, vlen);\n        }\n    }\n\n    c->dynamic_buffer.offset += sizeof(header.response) + bodylen;\n}\n\n/**\n * Append a key-value pair to the stats output buffer. This function assumes\n * that the output buffer is big enough (it will be if you call it through\n * append_stats)\n */\nstatic void append_ascii_stats(const char *key, const uint16_t klen,\n                               const char *val, const uint32_t vlen,\n                               conn *c) {\n    char *pos = c->dynamic_buffer.buffer + c->dynamic_buffer.offset;\n    uint32_t nbytes = 5; /* \"END\\r\\n\" or \"STAT \" */\n\n    if (klen == 0 && vlen == 0) {\n        memcpy(pos, \"END\\r\\n\", 5);\n    } else {\n        memcpy(pos, \"STAT \", 5);\n        memcpy(pos + nbytes, key, klen);\n        nbytes += klen;\n        if (vlen != 0) {\n            pos[nbytes] = ' ';\n            ++nbytes;\n            memcpy(pos + nbytes, val, vlen);\n            nbytes += vlen;\n        }\n        memcpy(pos + nbytes, \"\\r\\n\", 2);\n        nbytes += 2;\n    }\n\n    c->dynamic_buffer.offset += nbytes;\n}\n\nstatic bool grow_dynamic_buffer(conn *c, size_t needed) {\n    size_t nsize = c->dynamic_buffer.size;\n    size_t available = nsize - c->dynamic_buffer.offset;\n    bool rv = true;\n\n    /* Special case: No buffer -- need to allocate fresh */\n    if (c->dynamic_buffer.buffer == NULL) {\n        nsize = 1024;\n        available = c->dynamic_buffer.size = c->dynamic_buffer.offset = 0;\n    }\n\n    while (needed > available) {\n        assert(nsize > 0);\n        nsize = nsize << 1;\n        available = nsize - c->dynamic_buffer.offset;\n    }\n\n    if (nsize != c->dynamic_buffer.size) {\n        char *ptr = realloc(c->dynamic_buffer.buffer, nsize);\n        if (ptr) {\n            c->dynamic_buffer.buffer = ptr;\n            c->dynamic_buffer.size = nsize;\n        } else {\n            rv = false;\n        }\n    }\n\n    return rv;\n}\n\nstatic void append_stats(const char *key, const uint16_t klen,\n                         const char *val, const uint32_t vlen,\n                         const void *cookie)\n{\n    /* value without a key is invalid */\n    if (klen == 0 && vlen > 0) {\n        return ;\n    }\n\n    conn *c = (conn*)cookie;\n\n    if (c->protocol == binary_prot) {\n        size_t needed = vlen + klen + sizeof(protocol_binary_response_header);\n        if (!grow_dynamic_buffer(c, needed)) {\n            return ;\n        }\n        append_bin_stats(key, klen, val, vlen, c);\n    } else {\n        size_t needed = vlen + klen + 10; // 10 == \"STAT = \\r\\n\"\n        if (!grow_dynamic_buffer(c, needed)) {\n            return ;\n        }\n        append_ascii_stats(key, klen, val, vlen, c);\n    }\n\n    assert(c->dynamic_buffer.offset <= c->dynamic_buffer.size);\n}\n\nstatic void process_bin_stat(conn *c) {\n    char *subcommand = binary_get_key(c);\n    size_t nkey = c->binary_header.request.keylen;\n\n    if (settings.verbose > 1) {\n        char buffer[1024];\n        if (key_to_printable_buffer(buffer, sizeof(buffer), c->sfd, true,\n                                    \"STATS\", subcommand, nkey) != -1) {\n            settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c, \"%s\\n\",\n                                            buffer);\n        }\n    }\n\n    ENGINE_ERROR_CODE ret = c->aiostat;\n    c->aiostat = ENGINE_SUCCESS;\n    c->ewouldblock = false;\n\n    if (ret == ENGINE_SUCCESS) {\n        if (nkey == 0) {\n            /* request all statistics */\n            ret = settings.engine.v1->get_stats(settings.engine.v0, c, NULL, 0, append_stats);\n            if (ret == ENGINE_SUCCESS) {\n                server_stats(&append_stats, c, false);\n            }\n        } else if (strncmp(subcommand, \"reset\", 5) == 0) {\n            stats_reset(c);\n            settings.engine.v1->reset_stats(settings.engine.v0, c);\n        } else if (strncmp(subcommand, \"settings\", 8) == 0) {\n            process_stat_settings(&append_stats, c);\n        } else if (strncmp(subcommand, \"detail\", 6) == 0) {\n            char *subcmd_pos = subcommand + 6;\n            if (settings.allow_detailed) {\n                if (strncmp(subcmd_pos, \" dump\", 5) == 0) {\n                    int len;\n                    char *dump_buf = stats_prefix_dump(&len);\n                    if (dump_buf == NULL || len <= 0) {\n                        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, 0);\n                        return ;\n                    } else {\n                        append_stats(\"detailed\", strlen(\"detailed\"), dump_buf, len, c);\n                        free(dump_buf);\n                    }\n                } else if (strncmp(subcmd_pos, \" on\", 3) == 0) {\n                    settings.detail_enabled = 1;\n                } else if (strncmp(subcmd_pos, \" off\", 4) == 0) {\n                    settings.detail_enabled = 0;\n                } else {\n                    write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, 0);\n                    return;\n                }\n            } else {\n                write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, 0);\n                return;\n            }\n        } else if (strncmp(subcommand, \"aggregate\", 9) == 0) {\n            server_stats(&append_stats, c, true);\n        } else if (strncmp(subcommand, \"topkeys\", 7) == 0) {\n            topkeys_t *tk = get_independent_stats(c)->topkeys;\n            if (tk != NULL) {\n                topkeys_stats(tk, c, current_time, append_stats);\n            } else {\n                write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, 0);\n                return;\n            }\n        } else {\n            ret = settings.engine.v1->get_stats(settings.engine.v0, c,\n                                                subcommand, nkey,\n                                                append_stats);\n        }\n    }\n\n    switch (ret) {\n    case ENGINE_SUCCESS:\n        append_stats(NULL, 0, NULL, 0, c);\n        write_and_free(c, c->dynamic_buffer.buffer, c->dynamic_buffer.offset);\n        c->dynamic_buffer.buffer = NULL;\n        break;\n    case ENGINE_ENOMEM:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, 0);\n        break;\n    case ENGINE_TMPFAIL:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_ETMPFAIL, 0);\n        break;\n    case ENGINE_KEY_ENOENT:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, 0);\n        break;\n    case ENGINE_DISCONNECT:\n        c->state = conn_closing;\n        break;\n    case ENGINE_ENOTSUP:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_NOT_SUPPORTED, 0);\n        break;\n    case ENGINE_EWOULDBLOCK:\n        c->ewouldblock = true;\n        break;\n    default:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_EINVAL, 0);\n    }\n}\n\nstatic void bin_read_chunk(conn *c, enum bin_substates next_substate, uint32_t chunk) {\n    assert(c);\n    c->substate = next_substate;\n    c->rlbytes = chunk;\n\n    /* Ok... do we have room for everything in our buffer? */\n    ptrdiff_t offset = c->rcurr + sizeof(protocol_binary_request_header) - c->rbuf;\n    if (c->rlbytes > c->rsize - offset) {\n        size_t nsize = c->rsize;\n        size_t size = c->rlbytes + sizeof(protocol_binary_request_header);\n\n        while (size > nsize) {\n            nsize *= 2;\n        }\n\n        if (nsize != c->rsize) {\n            if (settings.verbose > 1) {\n                settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                        \"%d: Need to grow buffer from %lu to %lu\\n\",\n                        c->sfd, (unsigned long)c->rsize, (unsigned long)nsize);\n            }\n            char *newm = realloc(c->rbuf, nsize);\n            if (newm == NULL) {\n                if (settings.verbose) {\n                    settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                            \"%d: Failed to grow buffer.. closing connection\\n\",\n                            c->sfd);\n                }\n                conn_set_state(c, conn_closing);\n                return;\n            }\n\n            c->rbuf= newm;\n            /* rcurr should point to the same offset in the packet */\n            c->rcurr = c->rbuf + offset - sizeof(protocol_binary_request_header);\n            c->rsize = nsize;\n        }\n        if (c->rbuf != c->rcurr) {\n            memmove(c->rbuf, c->rcurr, c->rbytes);\n            c->rcurr = c->rbuf;\n            if (settings.verbose > 1) {\n                settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                                \"%d: Repack input buffer\\n\",\n                                                c->sfd);\n            }\n        }\n    }\n\n    /* preserve the header in the buffer.. */\n    c->ritem = c->rcurr + sizeof(protocol_binary_request_header);\n    conn_set_state(c, conn_nread);\n}\n\nstatic void bin_read_key(conn *c, enum bin_substates next_substate, int extra) {\n    bin_read_chunk(c, next_substate, c->keylen + extra);\n}\n\n\n/* Just write an error message and disconnect the client */\nstatic void handle_binary_protocol_error(conn *c) {\n    write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_EINVAL, 0);\n    if (settings.verbose) {\n        settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                \"%d: Protocol error (opcode %02x), close connection\\n\",\n                c->sfd, c->binary_header.request.opcode);\n    }\n    c->write_and_go = conn_closing;\n}\n\nstatic void init_sasl_conn(conn *c) {\n    assert(c);\n    if (!c->sasl_conn) {\n        int result=sasl_server_new(\"memcached\",\n                                   NULL, NULL, NULL, NULL,\n                                   NULL, 0, &c->sasl_conn);\n        if (result != SASL_OK) {\n            if (settings.verbose) {\n                settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                         \"%d: Failed to initialize SASL conn.\\n\",\n                         c->sfd);\n            }\n            c->sasl_conn = NULL;\n        }\n    }\n}\n\nstatic void get_auth_data(const void *cookie, auth_data_t *data) {\n    conn *c = (conn*)cookie;\n    if (c->sasl_conn) {\n        sasl_getprop(c->sasl_conn, SASL_USERNAME, (void*)&data->username);\n#ifdef ENABLE_ISASL\n        sasl_getprop(c->sasl_conn, ISASL_CONFIG, (void*)&data->config);\n#endif\n    }\n}\n\n#ifdef SASL_ENABLED\nstatic void bin_list_sasl_mechs(conn *c) {\n    init_sasl_conn(c);\n    const char *result_string = NULL;\n    unsigned int string_length = 0;\n    int result=sasl_listmech(c->sasl_conn, NULL,\n                             \"\",   /* What to prepend the string with */\n                             \" \",  /* What to separate mechanisms with */\n                             \"\",   /* What to append to the string */\n                             &result_string, &string_length,\n                             NULL);\n    if (result != SASL_OK) {\n        /* Perhaps there's a better error for this... */\n        if (settings.verbose) {\n            settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                     \"%d: Failed to list SASL mechanisms.\\n\",\n                     c->sfd);\n        }\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_AUTH_ERROR, 0);\n        return;\n    }\n    write_bin_response(c, (char*)result_string, 0, 0, string_length);\n}\n#endif\n\nstruct sasl_tmp {\n    int ksize;\n    int vsize;\n    char data[]; /* data + ksize == value */\n};\n\nstatic void process_bin_sasl_auth(conn *c) {\n    assert(c->binary_header.request.extlen == 0);\n\n    int nkey = c->binary_header.request.keylen;\n    int vlen = c->binary_header.request.bodylen - nkey;\n\n    if (nkey > MAX_SASL_MECH_LEN) {\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_EINVAL, vlen);\n        c->write_and_go = conn_swallow;\n        return;\n    }\n\n    char *key = binary_get_key(c);\n    assert(key);\n\n    size_t buffer_size = sizeof(struct sasl_tmp) + nkey + vlen + 2;\n    struct sasl_tmp *data = calloc(sizeof(struct sasl_tmp) + buffer_size, 1);\n    if (!data) {\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, vlen);\n        c->write_and_go = conn_swallow;\n        return;\n    }\n\n    data->ksize = nkey;\n    data->vsize = vlen;\n    memcpy(data->data, key, nkey);\n\n    c->item = data;\n    c->ritem = data->data + nkey;\n    c->rlbytes = vlen;\n    conn_set_state(c, conn_nread);\n    c->substate = bin_reading_sasl_auth_data;\n}\n\nstatic void process_bin_complete_sasl_auth(conn *c) {\n    const char *out = NULL;\n    unsigned int outlen = 0;\n\n    assert(c->item);\n    init_sasl_conn(c);\n\n    int nkey = c->binary_header.request.keylen;\n    int vlen = c->binary_header.request.bodylen - nkey;\n\n    struct sasl_tmp *stmp = c->item;\n    char mech[nkey+1];\n    memcpy(mech, stmp->data, nkey);\n    mech[nkey] = 0x00;\n\n    if (settings.verbose) {\n        settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                \"%d: mech: ``%s'' with %d bytes of data\\n\", c->sfd, mech, vlen);\n    }\n\n    const char *challenge = vlen == 0 ? NULL : (stmp->data + nkey);\n\n    int result=-1;\n\n    switch (c->cmd) {\n    case PROTOCOL_BINARY_CMD_SASL_AUTH:\n        result = sasl_server_start(c->sasl_conn, mech,\n                                   challenge, vlen,\n                                   &out, &outlen);\n        break;\n    case PROTOCOL_BINARY_CMD_SASL_STEP:\n        result = sasl_server_step(c->sasl_conn,\n                                  challenge, vlen,\n                                  &out, &outlen);\n        break;\n    default:\n        assert(false); /* CMD should be one of the above */\n        /* This code is pretty much impossible, but makes the compiler\n           happier */\n        if (settings.verbose) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                    \"%d: Unhandled command %d with challenge %s\\n\",\n                    c->sfd, c->cmd, challenge);\n        }\n        break;\n    }\n\n    free(c->item);\n    c->item = NULL;\n    c->ritem = NULL;\n\n    if (settings.verbose) {\n        settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                                        \"%d: sasl result code:  %d\\n\",\n                                        c->sfd, result);\n    }\n\n    switch(result) {\n    case SASL_OK:\n        write_bin_response(c, \"Authenticated\", 0, 0, strlen(\"Authenticated\"));\n        auth_data_t data;\n        get_auth_data(c, &data);\n        perform_callbacks(ON_AUTH, (const void*)&data, c);\n        STATS_NOKEY(c, auth_cmds);\n        break;\n    case SASL_CONTINUE:\n        add_bin_header(c, PROTOCOL_BINARY_RESPONSE_AUTH_CONTINUE, 0, 0, outlen);\n        if(outlen > 0) {\n            add_iov(c, out, outlen);\n        }\n        conn_set_state(c, conn_mwrite);\n        c->write_and_go = conn_new_cmd;\n        break;\n    default:\n        if (settings.verbose) {\n            settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                                            \"%d: Unknown sasl response:  %d\\n\",\n                                            c->sfd, result);\n        }\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_AUTH_ERROR, 0);\n        STATS_NOKEY2(c, auth_cmds, auth_errors);\n    }\n}\n\nstatic bool authenticated(conn *c) {\n    bool rv = false;\n\n    switch (c->cmd) {\n    case PROTOCOL_BINARY_CMD_SASL_LIST_MECHS: /* FALLTHROUGH */\n    case PROTOCOL_BINARY_CMD_SASL_AUTH:       /* FALLTHROUGH */\n    case PROTOCOL_BINARY_CMD_SASL_STEP:       /* FALLTHROUGH */\n    case PROTOCOL_BINARY_CMD_VERSION:         /* FALLTHROUGH */\n        rv = true;\n        break;\n    default:\n        if (c->sasl_conn) {\n            const void *uname = NULL;\n            sasl_getprop(c->sasl_conn, SASL_USERNAME, &uname);\n            rv = uname != NULL;\n        }\n    }\n\n    if (settings.verbose > 1) {\n        settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                \"%d: authenticated() in cmd 0x%02x is %s\\n\",\n                c->sfd, c->cmd, rv ? \"true\" : \"false\");\n    }\n\n    return rv;\n}\n\nstatic bool binary_response_handler(const void *key, uint16_t keylen,\n                                    const void *ext, uint8_t extlen,\n                                    const void *body, uint32_t bodylen,\n                                    uint8_t datatype, uint16_t status,\n                                    uint64_t cas, const void *cookie)\n{\n    conn *c = (conn*)cookie;\n    /* Look at append_bin_stats */\n    size_t needed = keylen + extlen + bodylen + sizeof(protocol_binary_response_header);\n    if (!grow_dynamic_buffer(c, needed)) {\n        if (settings.verbose > 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                    \"<%d ERROR: Failed to allocate memory for response\\n\",\n                    c->sfd);\n        }\n        return false;\n    }\n\n    char *buf = c->dynamic_buffer.buffer + c->dynamic_buffer.offset;\n    protocol_binary_response_header header = {\n        .response.magic = (uint8_t)PROTOCOL_BINARY_RES,\n        .response.opcode = c->binary_header.request.opcode,\n        .response.keylen = (uint16_t)htons(keylen),\n        .response.extlen = extlen,\n        .response.datatype = datatype,\n        .response.status = (uint16_t)htons(status),\n        .response.bodylen = htonl(bodylen + keylen + extlen),\n        .response.opaque = c->opaque,\n        .response.cas = htonll(cas),\n    };\n\n    memcpy(buf, header.bytes, sizeof(header.response));\n    buf += sizeof(header.response);\n\n    if (extlen > 0) {\n        memcpy(buf, ext, extlen);\n        buf += extlen;\n    }\n\n    if (keylen > 0) {\n        memcpy(buf, key, keylen);\n        buf += keylen;\n    }\n\n    if (bodylen > 0) {\n        memcpy(buf, body, bodylen);\n    }\n\n    c->dynamic_buffer.offset += needed;\n\n    return true;\n}\n\n/**\n * Tap stats (these are only used by the tap thread, so they don't need\n * to be in the threadlocal struct right now...\n */\nstruct tap_cmd_stats {\n    uint64_t connect;\n    uint64_t mutation;\n    uint64_t checkpoint_start;\n    uint64_t checkpoint_end;\n    uint64_t delete;\n    uint64_t flush;\n    uint64_t opaque;\n    uint64_t vbucket_set;\n};\n\nstruct tap_stats {\n    pthread_mutex_t mutex;\n    struct tap_cmd_stats sent;\n    struct tap_cmd_stats received;\n} tap_stats = { .mutex = PTHREAD_MUTEX_INITIALIZER };\n\nstatic void ship_tap_log(conn *c) {\n    assert(c->thread->type == TAP);\n    c->msgcurr = 0;\n    c->msgused = 0;\n    c->iovused = 0;\n    if (add_msghdr(c) != 0) {\n        if (settings.verbose) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                            \"%d: Failed to create output headers. Shutting down tap connection\\n\", c->sfd);\n        }\n        conn_set_state(c, conn_closing);\n        return ;\n    }\n    /* @todo add check for buffer overflow of c->wbuf) */\n    c->wcurr = c->wbuf;\n\n    bool more_data = true;\n    bool send_data = false;\n    bool disconnect = false;\n\n    item *it;\n    uint32_t bodylen;\n    int ii = 0;\n    c->icurr = c->ilist;\n    do {\n        /* @todo fixme! */\n        if (ii++ == 10) {\n            break;\n        }\n\n        void *engine;\n        uint16_t nengine;\n        uint8_t ttl;\n        uint16_t tap_flags;\n        uint32_t seqno;\n        uint16_t vbucket;\n\n        tap_event_t event = c->tap_iterator(settings.engine.v0, c, &it,\n                                            &engine, &nengine, &ttl,\n                                            &tap_flags, &seqno, &vbucket);\n        union {\n            protocol_binary_request_tap_mutation mutation;\n            protocol_binary_request_tap_delete delete;\n            protocol_binary_request_tap_flush flush;\n            protocol_binary_request_tap_opaque opaque;\n            protocol_binary_request_noop noop;\n        } msg = {\n            .mutation.message.header.request.magic = (uint8_t)PROTOCOL_BINARY_REQ,\n        };\n\n        msg.opaque.message.header.request.opaque = htonl(seqno);\n        msg.opaque.message.body.tap.enginespecific_length = htons(nengine);\n        msg.opaque.message.body.tap.ttl = ttl;\n        msg.opaque.message.body.tap.flags = htons(tap_flags);\n        msg.opaque.message.header.request.extlen = 8;\n        msg.opaque.message.header.request.vbucket = htons(vbucket);\n        item_info info = { .nvalue = 1 };\n\n        switch (event) {\n        case TAP_NOOP :\n            send_data = true;\n            msg.noop.message.header.request.opcode = PROTOCOL_BINARY_CMD_NOOP;\n            msg.noop.message.header.request.extlen = 0;\n            msg.noop.message.header.request.bodylen = htonl(0);\n            memcpy(c->wcurr, msg.noop.bytes, sizeof(msg.noop.bytes));\n            add_iov(c, c->wcurr, sizeof(msg.noop.bytes));\n            c->wcurr += sizeof(msg.noop.bytes);\n            c->wbytes += sizeof(msg.noop.bytes);\n            break;\n        case TAP_PAUSE :\n            more_data = false;\n            break;\n        case TAP_CHECKPOINT_START:\n        case TAP_CHECKPOINT_END:\n        case TAP_MUTATION:\n            if (!settings.engine.v1->get_item_info(settings.engine.v0, c, it, &info)) {\n                settings.engine.v1->release(settings.engine.v0, c, it);\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                                \"%d: Failed to get item info\\n\", c->sfd);\n                break;\n            }\n            send_data = true;\n            c->ilist[c->ileft++] = it;\n\n            if (event == TAP_CHECKPOINT_START) {\n                msg.mutation.message.header.request.opcode =\n                    PROTOCOL_BINARY_CMD_TAP_CHECKPOINT_START;\n                pthread_mutex_lock(&tap_stats.mutex);\n                tap_stats.sent.checkpoint_start++;\n                pthread_mutex_unlock(&tap_stats.mutex);\n            } else if (event == TAP_CHECKPOINT_END) {\n                msg.mutation.message.header.request.opcode =\n                    PROTOCOL_BINARY_CMD_TAP_CHECKPOINT_END;\n                pthread_mutex_lock(&tap_stats.mutex);\n                tap_stats.sent.checkpoint_end++;\n                pthread_mutex_unlock(&tap_stats.mutex);\n            } else if (event == TAP_MUTATION) {\n                msg.mutation.message.header.request.opcode = PROTOCOL_BINARY_CMD_TAP_MUTATION;\n                pthread_mutex_lock(&tap_stats.mutex);\n                tap_stats.sent.mutation++;\n                pthread_mutex_unlock(&tap_stats.mutex);\n            }\n\n            msg.mutation.message.header.request.cas = htonll(info.cas);\n            msg.mutation.message.header.request.keylen = htons(info.nkey);\n            msg.mutation.message.header.request.extlen = 16;\n\n            bodylen = 16 + info.nkey + nengine;\n            if ((tap_flags & TAP_FLAG_NO_VALUE) == 0) {\n                bodylen += info.nbytes;\n            }\n            msg.mutation.message.header.request.bodylen = htonl(bodylen);\n            msg.mutation.message.body.item.flags = htonl(info.flags);\n            msg.mutation.message.body.item.expiration = htonl(info.exptime);\n            msg.mutation.message.body.tap.enginespecific_length = htons(nengine);\n            msg.mutation.message.body.tap.ttl = ttl;\n            msg.mutation.message.body.tap.flags = htons(tap_flags);\n            memcpy(c->wcurr, msg.mutation.bytes, sizeof(msg.mutation.bytes));\n\n            add_iov(c, c->wcurr, sizeof(msg.mutation.bytes));\n            c->wcurr += sizeof(msg.mutation.bytes);\n            c->wbytes += sizeof(msg.mutation.bytes);\n\n            if (nengine > 0) {\n                memcpy(c->wcurr, engine, nengine);\n                add_iov(c, c->wcurr, nengine);\n                c->wcurr += nengine;\n                c->wbytes += nengine;\n            }\n\n            add_iov(c, info.key, info.nkey);\n            if ((tap_flags & TAP_FLAG_NO_VALUE) == 0) {\n                add_iov(c, info.value[0].iov_base, info.value[0].iov_len);\n            }\n\n            break;\n        case TAP_DELETION:\n            /* This is a delete */\n            if (!settings.engine.v1->get_item_info(settings.engine.v0, c, it, &info)) {\n                settings.engine.v1->release(settings.engine.v0, c, it);\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                                \"%d: Failed to get item info\\n\", c->sfd);\n                break;\n            }\n            send_data = true;\n            c->ilist[c->ileft++] = it;\n            msg.delete.message.header.request.opcode = PROTOCOL_BINARY_CMD_TAP_DELETE;\n            msg.delete.message.header.request.cas = htonll(info.cas);\n            msg.delete.message.header.request.keylen = htons(info.nkey);\n\n            bodylen = 8 + info.nkey + nengine;\n            if ((tap_flags & TAP_FLAG_NO_VALUE) == 0) {\n                bodylen += info.nbytes;\n            }\n            msg.delete.message.header.request.bodylen = htonl(bodylen);\n\n            memcpy(c->wcurr, msg.delete.bytes, sizeof(msg.delete.bytes));\n            add_iov(c, c->wcurr, sizeof(msg.delete.bytes));\n            c->wcurr += sizeof(msg.delete.bytes);\n            c->wbytes += sizeof(msg.delete.bytes);\n\n            if (nengine > 0) {\n                memcpy(c->wcurr, engine, nengine);\n                add_iov(c, c->wcurr, nengine);\n                c->wcurr += nengine;\n                c->wbytes += nengine;\n            }\n\n            add_iov(c, info.key, info.nkey);\n            if ((tap_flags & TAP_FLAG_NO_VALUE) == 0) {\n                add_iov(c, info.value[0].iov_base, info.value[0].iov_len);\n            }\n\n            pthread_mutex_lock(&tap_stats.mutex);\n            tap_stats.sent.delete++;\n            pthread_mutex_unlock(&tap_stats.mutex);\n            break;\n\n        case TAP_DISCONNECT:\n            disconnect = true;\n            more_data = false;\n            break;\n        case TAP_VBUCKET_SET:\n        case TAP_FLUSH:\n        case TAP_OPAQUE:\n            send_data = true;\n\n            if (event == TAP_OPAQUE) {\n                msg.flush.message.header.request.opcode = PROTOCOL_BINARY_CMD_TAP_OPAQUE;\n                pthread_mutex_lock(&tap_stats.mutex);\n                tap_stats.sent.opaque++;\n                pthread_mutex_unlock(&tap_stats.mutex);\n\n            } else if (event == TAP_FLUSH) {\n                msg.flush.message.header.request.opcode = PROTOCOL_BINARY_CMD_TAP_FLUSH;\n                pthread_mutex_lock(&tap_stats.mutex);\n                tap_stats.sent.flush++;\n                pthread_mutex_unlock(&tap_stats.mutex);\n            } else if (event == TAP_VBUCKET_SET) {\n                msg.flush.message.header.request.opcode = PROTOCOL_BINARY_CMD_TAP_VBUCKET_SET;\n                msg.flush.message.body.tap.flags = htons(tap_flags);\n                pthread_mutex_lock(&tap_stats.mutex);\n                tap_stats.sent.vbucket_set++;\n                pthread_mutex_unlock(&tap_stats.mutex);\n            }\n\n            msg.flush.message.header.request.bodylen = htonl(8 + nengine);\n            memcpy(c->wcurr, msg.flush.bytes, sizeof(msg.flush.bytes));\n            add_iov(c, c->wcurr, sizeof(msg.flush.bytes));\n            c->wcurr += sizeof(msg.flush.bytes);\n            c->wbytes += sizeof(msg.flush.bytes);\n            if (nengine > 0) {\n                memcpy(c->wcurr, engine, nengine);\n                add_iov(c, c->wcurr, nengine);\n                c->wcurr += nengine;\n                c->wbytes += nengine;\n            }\n            break;\n        default:\n            abort();\n        }\n    } while (more_data);\n\n    c->ewouldblock = false;\n    if (send_data) {\n        conn_set_state(c, conn_mwrite);\n        if (disconnect) {\n            c->write_and_go = conn_closing;\n        } else {\n            c->write_and_go = conn_ship_log;\n        }\n    } else {\n        if (disconnect) {\n            conn_set_state(c, conn_closing);\n        } else {\n            /* No more items to ship to the slave at this time.. suspend.. */\n            if (settings.verbose > 1) {\n                settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                                \"%d: No more items in tap log.. waiting\\n\",\n                                                c->sfd);\n            }\n            c->ewouldblock = true;\n        }\n    }\n}\n\nstatic void process_bin_unknown_packet(conn *c) {\n    void *packet = c->rcurr - (c->binary_header.request.bodylen +\n                               sizeof(c->binary_header));\n\n    ENGINE_ERROR_CODE ret = c->aiostat;\n    c->aiostat = ENGINE_SUCCESS;\n    c->ewouldblock = false;\n\n    if (ret == ENGINE_SUCCESS) {\n        ret = settings.engine.v1->unknown_command(settings.engine.v0, c, packet,\n                                                  binary_response_handler);\n    }\n\n    if (ret == ENGINE_SUCCESS) {\n        if (c->dynamic_buffer.buffer != NULL) {\n            write_and_free(c, c->dynamic_buffer.buffer, c->dynamic_buffer.offset);\n            c->dynamic_buffer.buffer = NULL;\n        } else {\n            conn_set_state(c, conn_new_cmd);\n        }\n    } else if (ret == ENGINE_ENOTSUP) {\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND, 0);\n    } else if (ret == ENGINE_EWOULDBLOCK) {\n        c->ewouldblock = true;\n    } else {\n        /* FATAL ERROR, shut down connection */\n        conn_set_state(c, conn_closing);\n    }\n}\n\nstatic void process_bin_tap_connect(conn *c) {\n    char *packet = (c->rcurr - (c->binary_header.request.bodylen +\n                                sizeof(c->binary_header)));\n    protocol_binary_request_tap_connect *req = (void*)packet;\n    const char *key = packet + sizeof(req->bytes);\n    const char *data = key + c->binary_header.request.keylen;\n    uint32_t flags = 0;\n    size_t ndata = c->binary_header.request.bodylen -\n        c->binary_header.request.extlen -\n        c->binary_header.request.keylen;\n\n    if (c->binary_header.request.extlen == 4) {\n        flags = ntohl(req->message.body.flags);\n\n        if (flags & TAP_CONNECT_FLAG_BACKFILL) {\n            /* the userdata has to be at least 8 bytes! */\n            if (ndata < 8) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                                \"%d: ERROR: Invalid tap connect message\\n\",\n                                                c->sfd);\n                conn_set_state(c, conn_closing);\n                return ;\n            }\n        }\n    } else {\n        data -= 4;\n        key -= 4;\n    }\n\n    if (settings.verbose && c->binary_header.request.keylen > 0) {\n        char buffer[1024];\n        int len = c->binary_header.request.keylen;\n        if (len >= sizeof(buffer)) {\n            len = sizeof(buffer) - 1;\n        }\n        memcpy(buffer, key, len);\n        buffer[len] = '\\0';\n        settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                        \"%d: Trying to connect with named tap connection: <%s>\\n\",\n                                        c->sfd, buffer);\n    }\n\n    TAP_ITERATOR iterator = settings.engine.v1->get_tap_iterator(\n        settings.engine.v0, c, key, c->binary_header.request.keylen,\n        flags, data, ndata);\n\n    if (iterator == NULL) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                        \"%d: FATAL: The engine does not support tap\\n\",\n                                        c->sfd);\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_NOT_SUPPORTED, 0);\n        c->write_and_go = conn_closing;\n    } else {\n        c->tap_iterator = iterator;\n        c->which = EV_WRITE;\n        conn_set_state(c, conn_ship_log);\n    }\n}\n\nstatic void process_bin_tap_packet(tap_event_t event, conn *c) {\n    assert(c != NULL);\n    char *packet = (c->rcurr - (c->binary_header.request.bodylen +\n                                sizeof(c->binary_header)));\n    protocol_binary_request_tap_no_extras *tap = (void*)packet;\n    uint16_t nengine = ntohs(tap->message.body.tap.enginespecific_length);\n    uint16_t tap_flags = ntohs(tap->message.body.tap.flags);\n    uint32_t seqno = ntohl(tap->message.header.request.opaque);\n    uint8_t ttl = tap->message.body.tap.ttl;\n    assert(ttl > 0);\n    char *engine_specific = packet + sizeof(tap->bytes);\n    char *key = engine_specific + nengine;\n    uint16_t nkey = c->binary_header.request.keylen;\n    char *data = key + nkey;\n    uint32_t flags = 0;\n    uint32_t exptime = 0;\n    uint32_t ndata = c->binary_header.request.bodylen - nengine - nkey - 8;\n\n    if (event == TAP_MUTATION || event == TAP_CHECKPOINT_START ||\n        event == TAP_CHECKPOINT_END) {\n        protocol_binary_request_tap_mutation *mutation = (void*)tap;\n        flags = ntohl(mutation->message.body.item.flags);\n        exptime = ntohl(mutation->message.body.item.expiration);\n        key += 8;\n        data += 8;\n        ndata -= 8;\n    }\n\n    ENGINE_ERROR_CODE ret = c->aiostat;\n    if (ret == ENGINE_SUCCESS) {\n        ret = settings.engine.v1->tap_notify(settings.engine.v0, c,\n                                             engine_specific, nengine,\n                                             ttl - 1, tap_flags,\n                                             event, seqno,\n                                             key, nkey,\n                                             flags, exptime,\n                                             ntohll(tap->message.header.request.cas),\n                                             data, ndata,\n                                             c->binary_header.request.vbucket);\n    }\n\n    switch (ret) {\n    case ENGINE_DISCONNECT:\n        conn_set_state(c, conn_closing);\n        break;\n    case ENGINE_EWOULDBLOCK:\n        c->ewouldblock = true;\n        break;\n    default:\n        if ((tap_flags & TAP_FLAG_ACK) ||\n            (ret != ENGINE_SUCCESS && c->tap_nack_mode))\n        {\n            write_bin_packet(c, engine_error_2_protocol_error(ret), 0);\n        } else {\n            conn_set_state(c, conn_new_cmd);\n        }\n    }\n}\n\nstatic void process_bin_tap_ack(conn *c) {\n    assert(c != NULL);\n    char *packet = (c->rcurr - (c->binary_header.request.bodylen +\n                                sizeof(c->binary_header)));\n    protocol_binary_response_no_extras *rsp = (void*)packet;\n    uint32_t seqno = ntohl(rsp->message.header.response.opaque);\n    uint16_t status = ntohs(rsp->message.header.response.status);\n    char *key = packet + sizeof(rsp->bytes);\n\n    ENGINE_ERROR_CODE ret = ENGINE_DISCONNECT;\n    if (settings.engine.v1->tap_notify != NULL) {\n        ret = settings.engine.v1->tap_notify(settings.engine.v0, c, NULL, 0, 0, status,\n                                             TAP_ACK, seqno, key,\n                                             c->binary_header.request.keylen, 0, 0,\n                                             0, NULL, 0, 0);\n    }\n\n    if (ret == ENGINE_DISCONNECT) {\n        conn_set_state(c, conn_closing);\n    } else {\n        conn_set_state(c, conn_ship_log);\n    }\n}\n\n/**\n * We received a noop response.. just ignore it\n */\nstatic void process_bin_noop_response(conn *c) {\n    assert(c != NULL);\n    conn_set_state(c, conn_new_cmd);\n}\n\nstatic void process_bin_verbosity(conn *c) {\n    char *packet = (c->rcurr - (c->binary_header.request.bodylen +\n                                sizeof(c->binary_header)));\n    protocol_binary_request_verbosity *req = (void*)packet;\n    uint32_t level = (uint32_t)ntohl(req->message.body.level);\n    if (level > MAX_VERBOSITY_LEVEL) {\n        level = MAX_VERBOSITY_LEVEL;\n    }\n    settings.verbose = (int)level;\n    perform_callbacks(ON_LOG_LEVEL, NULL, NULL);\n    write_bin_response(c, NULL, 0, 0, 0);\n}\n\nstatic void process_bin_packet(conn *c) {\n    /* @todo this should be an array of funciton pointers and call through */\n    switch (c->binary_header.request.opcode) {\n    case PROTOCOL_BINARY_CMD_TAP_CONNECT:\n        pthread_mutex_lock(&tap_stats.mutex);\n        tap_stats.received.connect++;\n        pthread_mutex_unlock(&tap_stats.mutex);\n        conn_set_state(c, conn_add_tap_client);\n        break;\n    case PROTOCOL_BINARY_CMD_TAP_MUTATION:\n        pthread_mutex_lock(&tap_stats.mutex);\n        tap_stats.received.mutation++;\n        pthread_mutex_unlock(&tap_stats.mutex);\n        process_bin_tap_packet(TAP_MUTATION, c);\n        break;\n    case PROTOCOL_BINARY_CMD_TAP_CHECKPOINT_START:\n        pthread_mutex_lock(&tap_stats.mutex);\n        tap_stats.received.checkpoint_start++;\n        pthread_mutex_unlock(&tap_stats.mutex);\n        process_bin_tap_packet(TAP_CHECKPOINT_START, c);\n        break;\n    case PROTOCOL_BINARY_CMD_TAP_CHECKPOINT_END:\n        pthread_mutex_lock(&tap_stats.mutex);\n        tap_stats.received.checkpoint_end++;\n        pthread_mutex_unlock(&tap_stats.mutex);\n        process_bin_tap_packet(TAP_CHECKPOINT_END, c);\n        break;\n    case PROTOCOL_BINARY_CMD_TAP_DELETE:\n        pthread_mutex_lock(&tap_stats.mutex);\n        tap_stats.received.delete++;\n        pthread_mutex_unlock(&tap_stats.mutex);\n        process_bin_tap_packet(TAP_DELETION, c);\n        break;\n    case PROTOCOL_BINARY_CMD_TAP_FLUSH:\n        pthread_mutex_lock(&tap_stats.mutex);\n        tap_stats.received.flush++;\n        pthread_mutex_unlock(&tap_stats.mutex);\n        process_bin_tap_packet(TAP_FLUSH, c);\n        break;\n    case PROTOCOL_BINARY_CMD_TAP_OPAQUE:\n        pthread_mutex_lock(&tap_stats.mutex);\n        tap_stats.received.opaque++;\n        pthread_mutex_unlock(&tap_stats.mutex);\n        process_bin_tap_packet(TAP_OPAQUE, c);\n        break;\n    case PROTOCOL_BINARY_CMD_TAP_VBUCKET_SET:\n        pthread_mutex_lock(&tap_stats.mutex);\n        tap_stats.received.vbucket_set++;\n        pthread_mutex_unlock(&tap_stats.mutex);\n        process_bin_tap_packet(TAP_VBUCKET_SET, c);\n        break;\n    case PROTOCOL_BINARY_CMD_VERBOSITY:\n        process_bin_verbosity(c);\n        break;\n    default:\n        process_bin_unknown_packet(c);\n    }\n}\n\n\n\ntypedef void (*RESPONSE_HANDLER)(conn*);\n/**\n * A map between the response packets op-code and the function to handle\n * the response message.\n */\nstatic RESPONSE_HANDLER response_handlers[256] = {\n    [PROTOCOL_BINARY_CMD_NOOP] = process_bin_noop_response,\n    [PROTOCOL_BINARY_CMD_TAP_MUTATION] = process_bin_tap_ack,\n    [PROTOCOL_BINARY_CMD_TAP_DELETE] = process_bin_tap_ack,\n    [PROTOCOL_BINARY_CMD_TAP_FLUSH] = process_bin_tap_ack,\n    [PROTOCOL_BINARY_CMD_TAP_OPAQUE] = process_bin_tap_ack,\n    [PROTOCOL_BINARY_CMD_TAP_VBUCKET_SET] = process_bin_tap_ack,\n    [PROTOCOL_BINARY_CMD_TAP_CHECKPOINT_START] = process_bin_tap_ack,\n    [PROTOCOL_BINARY_CMD_TAP_CHECKPOINT_END] = process_bin_tap_ack\n};\n\nstatic void dispatch_bin_command(conn *c) {\n    int protocol_error = 0;\n\n    int extlen = c->binary_header.request.extlen;\n    uint16_t keylen = c->binary_header.request.keylen;\n    uint32_t bodylen = c->binary_header.request.bodylen;\n\n    if (settings.require_sasl && !authenticated(c)) {\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_AUTH_ERROR, 0);\n        c->write_and_go = conn_closing;\n        return;\n    }\n\n    MEMCACHED_PROCESS_COMMAND_START(c->sfd, c->rcurr, c->rbytes);\n    c->noreply = true;\n\n    /* binprot supports 16bit keys, but internals are still 8bit */\n    if (keylen > KEY_MAX_LENGTH) {\n        handle_binary_protocol_error(c);\n        return;\n    }\n\n    switch (c->cmd) {\n    case PROTOCOL_BINARY_CMD_SETQ:\n        c->cmd = PROTOCOL_BINARY_CMD_SET;\n        break;\n    case PROTOCOL_BINARY_CMD_ADDQ:\n        c->cmd = PROTOCOL_BINARY_CMD_ADD;\n        break;\n    case PROTOCOL_BINARY_CMD_REPLACEQ:\n        c->cmd = PROTOCOL_BINARY_CMD_REPLACE;\n        break;\n    case PROTOCOL_BINARY_CMD_DELETEQ:\n        c->cmd = PROTOCOL_BINARY_CMD_DELETE;\n        break;\n    case PROTOCOL_BINARY_CMD_INCREMENTQ:\n        c->cmd = PROTOCOL_BINARY_CMD_INCREMENT;\n        break;\n    case PROTOCOL_BINARY_CMD_DECREMENTQ:\n        c->cmd = PROTOCOL_BINARY_CMD_DECREMENT;\n        break;\n    case PROTOCOL_BINARY_CMD_QUITQ:\n        c->cmd = PROTOCOL_BINARY_CMD_QUIT;\n        break;\n    case PROTOCOL_BINARY_CMD_FLUSHQ:\n        c->cmd = PROTOCOL_BINARY_CMD_FLUSH;\n        break;\n    case PROTOCOL_BINARY_CMD_APPENDQ:\n        c->cmd = PROTOCOL_BINARY_CMD_APPEND;\n        break;\n    case PROTOCOL_BINARY_CMD_PREPENDQ:\n        c->cmd = PROTOCOL_BINARY_CMD_PREPEND;\n        break;\n    case PROTOCOL_BINARY_CMD_GETQ:\n        c->cmd = PROTOCOL_BINARY_CMD_GET;\n        break;\n    case PROTOCOL_BINARY_CMD_GETKQ:\n        c->cmd = PROTOCOL_BINARY_CMD_GETK;\n        break;\n    default:\n        c->noreply = false;\n    }\n\n    switch (c->cmd) {\n        case PROTOCOL_BINARY_CMD_VERSION:\n            if (extlen == 0 && keylen == 0 && bodylen == 0) {\n                write_bin_response(c, VERSION, 0, 0, strlen(VERSION));\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_FLUSH:\n            if (keylen == 0 && bodylen == extlen && (extlen == 0 || extlen == 4)) {\n                bin_read_key(c, bin_read_flush_exptime, extlen);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_NOOP:\n            if (extlen == 0 && keylen == 0 && bodylen == 0) {\n                write_bin_response(c, NULL, 0, 0, 0);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_SET: /* FALLTHROUGH */\n        case PROTOCOL_BINARY_CMD_ADD: /* FALLTHROUGH */\n        case PROTOCOL_BINARY_CMD_REPLACE:\n            if (extlen == 8 && keylen != 0 && bodylen >= (keylen + 8)) {\n                bin_read_key(c, bin_reading_set_header, 8);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_GETQ:  /* FALLTHROUGH */\n        case PROTOCOL_BINARY_CMD_GET:   /* FALLTHROUGH */\n        case PROTOCOL_BINARY_CMD_GETKQ: /* FALLTHROUGH */\n        case PROTOCOL_BINARY_CMD_GETK:\n            if (extlen == 0 && bodylen == keylen && keylen > 0) {\n                bin_read_key(c, bin_reading_get_key, 0);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_DELETE:\n            if (keylen > 0 && extlen == 0 && bodylen == keylen) {\n                bin_read_key(c, bin_reading_del_header, extlen);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_INCREMENT:\n        case PROTOCOL_BINARY_CMD_DECREMENT:\n            if (keylen > 0 && extlen == 20 && bodylen == (keylen + extlen)) {\n                bin_read_key(c, bin_reading_incr_header, 20);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_APPEND:\n        case PROTOCOL_BINARY_CMD_PREPEND:\n            if (keylen > 0 && extlen == 0) {\n                bin_read_key(c, bin_reading_set_header, 0);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_STAT:\n            if (extlen == 0) {\n                bin_read_key(c, bin_reading_stat, 0);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_QUIT:\n            if (keylen == 0 && extlen == 0 && bodylen == 0) {\n                write_bin_response(c, NULL, 0, 0, 0);\n                c->write_and_go = conn_closing;\n                if (c->noreply) {\n                    conn_set_state(c, conn_closing);\n                }\n            } else {\n                protocol_error = 1;\n            }\n            break;\n       case PROTOCOL_BINARY_CMD_TAP_CONNECT:\n            if (settings.engine.v1->get_tap_iterator == NULL) {\n                write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_NOT_SUPPORTED, bodylen);\n            } else {\n                bin_read_chunk(c, bin_reading_packet,\n                               c->binary_header.request.bodylen);\n            }\n            break;\n       case PROTOCOL_BINARY_CMD_TAP_MUTATION:\n       case PROTOCOL_BINARY_CMD_TAP_CHECKPOINT_START:\n       case PROTOCOL_BINARY_CMD_TAP_CHECKPOINT_END:\n       case PROTOCOL_BINARY_CMD_TAP_DELETE:\n       case PROTOCOL_BINARY_CMD_TAP_FLUSH:\n       case PROTOCOL_BINARY_CMD_TAP_OPAQUE:\n       case PROTOCOL_BINARY_CMD_TAP_VBUCKET_SET:\n            if (settings.engine.v1->tap_notify == NULL) {\n                write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_NOT_SUPPORTED, bodylen);\n            } else {\n                bin_read_chunk(c, bin_reading_packet, c->binary_header.request.bodylen);\n            }\n            break;\n#ifdef SASL_ENABLED\n        case PROTOCOL_BINARY_CMD_SASL_LIST_MECHS:\n            if (extlen == 0 && keylen == 0 && bodylen == 0) {\n                bin_list_sasl_mechs(c);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        case PROTOCOL_BINARY_CMD_SASL_AUTH:\n        case PROTOCOL_BINARY_CMD_SASL_STEP:\n            if (extlen == 0 && keylen != 0) {\n                bin_read_key(c, bin_reading_sasl_auth, 0);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n#endif\n        case PROTOCOL_BINARY_CMD_VERBOSITY:\n            if (extlen == 4 && keylen == 0 && bodylen == 4) {\n                bin_read_chunk(c, bin_reading_packet,\n                               c->binary_header.request.bodylen);\n            } else {\n                protocol_error = 1;\n            }\n            break;\n        default:\n            if (settings.engine.v1->unknown_command == NULL) {\n                write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND,\n                                bodylen);\n            } else {\n                bin_read_chunk(c, bin_reading_packet, c->binary_header.request.bodylen);\n            }\n    }\n\n    if (protocol_error)\n        handle_binary_protocol_error(c);\n}\n\nstatic void process_bin_update(conn *c) {\n    char *key;\n    uint16_t nkey;\n    uint32_t vlen;\n    item *it = NULL;\n    protocol_binary_request_set* req = binary_get_request(c);\n\n    assert(c != NULL);\n\n    key = binary_get_key(c);\n    nkey = c->binary_header.request.keylen;\n\n    /* fix byteorder in the request */\n    req->message.body.flags = req->message.body.flags;\n    rel_time_t expiration = ntohl(req->message.body.expiration);\n\n    vlen = c->binary_header.request.bodylen - (nkey + c->binary_header.request.extlen);\n\n    if (settings.verbose > 1) {\n        char buffer[1024];\n        const char *prefix;\n        if (c->cmd == PROTOCOL_BINARY_CMD_ADD) {\n            prefix = \"ADD\";\n        } else if (c->cmd == PROTOCOL_BINARY_CMD_SET) {\n            prefix = \"SET\";\n        } else {\n            prefix = \"REPLACE\";\n        }\n\n        size_t nw;\n        nw = key_to_printable_buffer(buffer, sizeof(buffer), c->sfd, true,\n                                     prefix, key, nkey);\n\n        if (nw != -1) {\n            if (snprintf(buffer + nw, sizeof(buffer) - nw,\n                         \" Value len is %d\\n\", vlen)) {\n                settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c, \"%s\",\n                                                buffer);\n            }\n        }\n    }\n\n    if (settings.detail_enabled) {\n        stats_prefix_record_set(key, nkey);\n    }\n\n    ENGINE_ERROR_CODE ret = c->aiostat;\n    c->aiostat = ENGINE_SUCCESS;\n    c->ewouldblock = false;\n    item_info info = { .nvalue = 1 };\n\n    if (ret == ENGINE_SUCCESS) {\n        ret = settings.engine.v1->allocate(settings.engine.v0, c,\n                                           &it, key, nkey,\n                                           vlen,\n                                           req->message.body.flags,\n                                           expiration);\n        if (ret == ENGINE_SUCCESS && !settings.engine.v1->get_item_info(settings.engine.v0,\n                                                                        c, it, &info)) {\n            settings.engine.v1->release(settings.engine.v0, c, it);\n            write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_EINTERNAL, 0);\n            return;\n        }\n    }\n\n    switch (ret) {\n    case ENGINE_SUCCESS:\n        item_set_cas(c, it, c->binary_header.request.cas);\n\n        switch (c->cmd) {\n        case PROTOCOL_BINARY_CMD_ADD:\n            c->store_op = OPERATION_ADD;\n            break;\n        case PROTOCOL_BINARY_CMD_SET:\n            c->store_op = OPERATION_SET;\n            break;\n        case PROTOCOL_BINARY_CMD_REPLACE:\n            c->store_op = OPERATION_REPLACE;\n            break;\n        default:\n            assert(0);\n        }\n\n        if (c->binary_header.request.cas != 0) {\n            c->store_op = OPERATION_CAS;\n        }\n\n        c->item = it;\n        c->ritem = info.value[0].iov_base;\n        c->rlbytes = vlen;\n        conn_set_state(c, conn_nread);\n        c->substate = bin_read_set_value;\n        break;\n    case ENGINE_EWOULDBLOCK:\n        c->ewouldblock = true;\n        break;\n    case ENGINE_DISCONNECT:\n        c->state = conn_closing;\n        break;\n    default:\n        if (ret == ENGINE_E2BIG) {\n            write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_E2BIG, vlen);\n        } else {\n            write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, vlen);\n        }\n\n        /*\n         * Avoid stale data persisting in cache because we failed alloc.\n         * Unacceptable for SET (but only if cas matches).\n         * Anywhere else too?\n         */\n        if (c->cmd == PROTOCOL_BINARY_CMD_SET) {\n            /* @todo fix this for the ASYNC interface! */\n            settings.engine.v1->remove(settings.engine.v0, c, key, nkey,\n                                       ntohll(req->message.header.request.cas),\n                                       c->binary_header.request.vbucket);\n        }\n\n        /* swallow the data line */\n        c->write_and_go = conn_swallow;\n    }\n}\n\nstatic void process_bin_append_prepend(conn *c) {\n    char *key;\n    int nkey;\n    int vlen;\n    item *it = NULL;\n\n    assert(c != NULL);\n\n    key = binary_get_key(c);\n    nkey = c->binary_header.request.keylen;\n    vlen = c->binary_header.request.bodylen - nkey;\n\n    if (settings.verbose > 1) {\n        settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                        \"Value len is %d\\n\", vlen);\n    }\n\n    if (settings.detail_enabled) {\n        stats_prefix_record_set(key, nkey);\n    }\n\n    ENGINE_ERROR_CODE ret = c->aiostat;\n    c->aiostat = ENGINE_SUCCESS;\n    c->ewouldblock = false;\n    item_info info = { .nvalue = 1 };\n\n    if (ret == ENGINE_SUCCESS) {\n        ret = settings.engine.v1->allocate(settings.engine.v0, c,\n                                           &it, key, nkey,\n                                           vlen, 0, 0);\n        if (ret == ENGINE_SUCCESS && !settings.engine.v1->get_item_info(settings.engine.v0,\n                                                                        c, it, &info)) {\n            settings.engine.v1->release(settings.engine.v0, c, it);\n            write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_EINTERNAL, 0);\n            return;\n        }\n    }\n\n    switch (ret) {\n    case ENGINE_SUCCESS:\n        item_set_cas(c, it, c->binary_header.request.cas);\n\n        switch (c->cmd) {\n        case PROTOCOL_BINARY_CMD_APPEND:\n            c->store_op = OPERATION_APPEND;\n            break;\n        case PROTOCOL_BINARY_CMD_PREPEND:\n            c->store_op = OPERATION_PREPEND;\n            break;\n        default:\n            assert(0);\n        }\n\n        c->item = it;\n        c->ritem = info.value[0].iov_base;\n        c->rlbytes = vlen;\n        conn_set_state(c, conn_nread);\n        c->substate = bin_read_set_value;\n        break;\n    case ENGINE_EWOULDBLOCK:\n        c->ewouldblock = true;\n        break;\n    case ENGINE_DISCONNECT:\n        c->state = conn_closing;\n        break;\n    default:\n        if (ret == ENGINE_E2BIG) {\n            write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_E2BIG, vlen);\n        } else {\n            write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, vlen);\n        }\n        /* swallow the data line */\n        c->write_and_go = conn_swallow;\n    }\n}\n\nstatic void process_bin_flush(conn *c) {\n    time_t exptime = 0;\n    protocol_binary_request_flush* req = binary_get_request(c);\n\n    if (c->binary_header.request.extlen == sizeof(req->message.body)) {\n        exptime = ntohl(req->message.body.expiration);\n    }\n\n    if (settings.verbose > 1) {\n        settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                        \"%d: flush %ld\", c->sfd,\n                                        (long)exptime);\n    }\n\n    ENGINE_ERROR_CODE ret;\n    ret = settings.engine.v1->flush(settings.engine.v0, c, exptime);\n\n    if (ret == ENGINE_SUCCESS) {\n        write_bin_response(c, NULL, 0, 0, 0);\n    } else if (ret == ENGINE_ENOTSUP) {\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_NOT_SUPPORTED, 0);\n    } else {\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_EINVAL, 0);\n    }\n    STATS_NOKEY(c, cmd_flush);\n}\n\nstatic void process_bin_delete(conn *c) {\n    protocol_binary_request_delete* req = binary_get_request(c);\n\n    char* key = binary_get_key(c);\n    size_t nkey = c->binary_header.request.keylen;\n\n    assert(c != NULL);\n\n    if (settings.verbose > 1) {\n        char buffer[1024];\n        if (key_to_printable_buffer(buffer, sizeof(buffer), c->sfd, true,\n                                    \"DELETE\", key, nkey) != -1) {\n            settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c, \"%s\\n\",\n                                            buffer);\n        }\n    }\n\n    ENGINE_ERROR_CODE ret = c->aiostat;\n    c->aiostat = ENGINE_SUCCESS;\n    c->ewouldblock = false;\n\n    if (ret == ENGINE_SUCCESS) {\n        if (settings.detail_enabled) {\n            stats_prefix_record_delete(key, nkey);\n        }\n        ret = settings.engine.v1->remove(settings.engine.v0, c, key, nkey,\n                                         ntohll(req->message.header.request.cas),\n                                         c->binary_header.request.vbucket);\n    }\n\n    /* For some reason the SLAB_INCR tries to access this... */\n    item_info info = { .nvalue = 1 };\n    switch (ret) {\n    case ENGINE_SUCCESS:\n        write_bin_response(c, NULL, 0, 0, 0);\n        SLAB_INCR(c, delete_hits, key, nkey);\n        break;\n    case ENGINE_KEY_EEXISTS:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS, 0);\n        break;\n    case ENGINE_KEY_ENOENT:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_KEY_ENOENT, 0);\n        STATS_INCR(c, delete_misses, key, nkey);\n        break;\n    case ENGINE_NOT_MY_VBUCKET:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_NOT_MY_VBUCKET, 0);\n        break;\n    case ENGINE_EWOULDBLOCK:\n        c->ewouldblock = true;\n        break;\n    default:\n        write_bin_packet(c, PROTOCOL_BINARY_RESPONSE_EINVAL, 0);\n    }\n}\n\nstatic void complete_nread_binary(conn *c) {\n    assert(c != NULL);\n    assert(c->cmd >= 0);\n\n    switch(c->substate) {\n    case bin_reading_set_header:\n        if (c->cmd == PROTOCOL_BINARY_CMD_APPEND ||\n                c->cmd == PROTOCOL_BINARY_CMD_PREPEND) {\n            process_bin_append_prepend(c);\n        } else {\n            process_bin_update(c);\n        }\n        break;\n    case bin_read_set_value:\n        complete_update_bin(c);\n        break;\n    case bin_reading_get_key:\n        process_bin_get(c);\n        break;\n    case bin_reading_stat:\n        process_bin_stat(c);\n        break;\n    case bin_reading_del_header:\n        process_bin_delete(c);\n        break;\n    case bin_reading_incr_header:\n        complete_incr_bin(c);\n        break;\n    case bin_read_flush_exptime:\n        process_bin_flush(c);\n        break;\n    case bin_reading_sasl_auth:\n        process_bin_sasl_auth(c);\n        break;\n    case bin_reading_sasl_auth_data:\n        process_bin_complete_sasl_auth(c);\n        break;\n    case bin_reading_packet:\n        if (c->binary_header.request.magic == PROTOCOL_BINARY_RES) {\n            RESPONSE_HANDLER handler;\n            handler = response_handlers[c->binary_header.request.opcode];\n            if (handler) {\n                handler(c);\n            } else {\n                settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                       \"%d: ERROR: Unsupported response packet received: %u\\n\",\n                        c->sfd, (unsigned int)c->binary_header.request.opcode);\n                conn_set_state(c, conn_closing);\n            }\n        } else {\n            process_bin_packet(c);\n        }\n        break;\n    default:\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                \"Not handling substate %d\\n\", c->substate);\n        abort();\n    }\n}\n\nstatic void reset_cmd_handler(conn *c) {\n    c->sbytes = 0;\n    c->ascii_cmd = NULL;\n    c->cmd = -1;\n    c->substate = bin_no_state;\n    if(c->item != NULL) {\n        settings.engine.v1->release(settings.engine.v0, c, c->item);\n        c->item = NULL;\n    }\n    conn_shrink(c);\n    if (c->rbytes > 0) {\n        conn_set_state(c, conn_parse_cmd);\n    } else {\n        conn_set_state(c, conn_waiting);\n    }\n}\n\nstatic ENGINE_ERROR_CODE ascii_response_handler(const void *cookie,\n                                                int nbytes,\n                                                const char *dta)\n{\n    conn *c = (conn*)cookie;\n    if (!grow_dynamic_buffer(c, nbytes)) {\n        if (settings.verbose > 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                    \"<%d ERROR: Failed to allocate memory for response\\n\",\n                    c->sfd);\n        }\n        return ENGINE_ENOMEM;\n    }\n\n    char *buf = c->dynamic_buffer.buffer + c->dynamic_buffer.offset;\n    memcpy(buf, dta, nbytes);\n    c->dynamic_buffer.offset += nbytes;\n\n    return ENGINE_SUCCESS;\n}\n\nstatic void complete_nread_ascii(conn *c) {\n    if (c->ascii_cmd != NULL) {\n        c->ewouldblock = false;\n        switch (c->ascii_cmd->execute(c->ascii_cmd->cookie, c, 0, NULL,\n                                      ascii_response_handler)) {\n        case ENGINE_SUCCESS:\n            if (c->dynamic_buffer.buffer != NULL) {\n                write_and_free(c, c->dynamic_buffer.buffer,\n                               c->dynamic_buffer.offset);\n                c->dynamic_buffer.buffer = NULL;\n            } else {\n                conn_set_state(c, conn_new_cmd);\n            }\n            break;\n        case ENGINE_EWOULDBLOCK:\n            c->ewouldblock = true;\n            break;\n        case ENGINE_DISCONNECT:\n        default:\n            conn_set_state(c, conn_closing);\n        }\n    } else {\n        complete_update_ascii(c);\n    }\n}\n\nstatic void complete_nread(conn *c) {\n    assert(c != NULL);\n    assert(c->protocol == ascii_prot\n           || c->protocol == binary_prot);\n\n    if (c->protocol == ascii_prot) {\n        complete_nread_ascii(c);\n    } else if (c->protocol == binary_prot) {\n        complete_nread_binary(c);\n    }\n}\n\n#define COMMAND_TOKEN 0\n#define SUBCOMMAND_TOKEN 1\n#define KEY_TOKEN 1\n\n#define MAX_TOKENS 30\n\n/*\n * Tokenize the command string by replacing whitespace with '\\0' and update\n * the token array tokens with pointer to start of each token and length.\n * Returns total number of tokens.  The last valid token is the terminal\n * token (value points to the first unprocessed character of the string and\n * length zero).\n *\n * Usage example:\n *\n *  while(tokenize_command(command, ncommand, tokens, max_tokens) > 0) {\n *      for(int ix = 0; tokens[ix].length != 0; ix++) {\n *          ...\n *      }\n *      ncommand = tokens[ix].value - command;\n *      command  = tokens[ix].value;\n *   }\n */\nstatic size_t tokenize_command(char *command, token_t *tokens, const size_t max_tokens) {\n    char *s, *e;\n    size_t ntokens = 0;\n\n    assert(command != NULL && tokens != NULL && max_tokens > 1);\n\n    for (s = e = command; ntokens < max_tokens - 1; ++e) {\n        if (*e == ' ') {\n            if (s != e) {\n                tokens[ntokens].value = s;\n                tokens[ntokens].length = e - s;\n                ntokens++;\n                *e = '\\0';\n            }\n            s = e + 1;\n        }\n        else if (*e == '\\0') {\n            if (s != e) {\n                tokens[ntokens].value = s;\n                tokens[ntokens].length = e - s;\n                ntokens++;\n            }\n\n            break; /* string end */\n        }\n    }\n\n    /*\n     * If we scanned the whole string, the terminal value pointer is null,\n     * otherwise it is the first unprocessed character.\n     */\n    tokens[ntokens].value =  *e == '\\0' ? NULL : e;\n    tokens[ntokens].length = 0;\n    ntokens++;\n\n    return ntokens;\n}\n\n#ifdef INNODB_MEMCACHED\nstatic void detokenize(token_t *tokens, size_t ntokens, char **out, int *nbytes)\n#else\nstatic void detokenize(token_t *tokens, int ntokens, char **out, int *nbytes)\n#endif\n{\n    int i, nb;\n    char *buf, *p;\n\n    nb = ntokens; // account for spaces, which is ntokens-1, plus the null\n    for (i = 0; i < ntokens; ++i) {\n        nb += tokens[i].length;\n    }\n\n    buf = malloc(nb * sizeof(char));\n    if (buf != NULL) {\n        p = buf;\n        for (i = 0; i < ntokens; ++i) {\n            memcpy(p, tokens[i].value, tokens[i].length);\n            p += tokens[i].length;\n            *p = ' ';\n            p++;\n        }\n        buf[nb - 1] = '\\0';\n        *nbytes = nb - 1;\n        *out = buf;\n    }\n}\n\n\n/* set up a connection to write a buffer then free it, used for stats */\nstatic void write_and_free(conn *c, char *buf, int bytes) {\n    if (buf) {\n        c->write_and_free = buf;\n        c->wcurr = buf;\n        c->wbytes = bytes;\n        conn_set_state(c, conn_write);\n        c->write_and_go = conn_new_cmd;\n    } else {\n        out_string(c, \"SERVER_ERROR out of memory writing stats\");\n    }\n}\n\nstatic inline bool set_noreply_maybe(conn *c, token_t *tokens, size_t ntokens)\n{\n    int noreply_index = ntokens - 2;\n\n    /*\n      NOTE: this function is not the first place where we are going to\n      send the reply.  We could send it instead from process_command()\n      if the request line has wrong number of tokens.  However parsing\n      malformed line for \"noreply\" option is not reliable anyway, so\n      it can't be helped.\n    */\n    if (tokens[noreply_index].value\n        && strcmp(tokens[noreply_index].value, \"noreply\") == 0) {\n        c->noreply = true;\n    }\n    return c->noreply;\n}\n\nvoid append_stat(const char *name, ADD_STAT add_stats, conn *c,\n                 const char *fmt, ...) {\n    char val_str[STAT_VAL_LEN];\n    int vlen;\n    va_list ap;\n\n    assert(name);\n    assert(add_stats);\n    assert(c);\n    assert(fmt);\n\n    va_start(ap, fmt);\n    vlen = vsnprintf(val_str, sizeof(val_str) - 1, fmt, ap);\n    va_end(ap);\n\n    add_stats(name, strlen(name), val_str, vlen, c);\n}\n\ninline static void process_stats_detail(conn *c, const char *command) {\n    assert(c != NULL);\n\n    if (settings.allow_detailed) {\n        if (strcmp(command, \"on\") == 0) {\n            settings.detail_enabled = 1;\n            out_string(c, \"OK\");\n        }\n        else if (strcmp(command, \"off\") == 0) {\n            settings.detail_enabled = 0;\n            out_string(c, \"OK\");\n        }\n        else if (strcmp(command, \"dump\") == 0) {\n            int len;\n            char *stats = stats_prefix_dump(&len);\n            write_and_free(c, stats, len);\n        }\n        else {\n            out_string(c, \"CLIENT_ERROR usage: stats detail on|off|dump\");\n        }\n    }\n    else {\n        out_string(c, \"CLIENT_ERROR detailed stats disabled\");\n    }\n}\n\nstatic void aggregate_callback(void *in, void *out) {\n    struct thread_stats *out_thread_stats = out;\n    struct independent_stats *in_independent_stats = in;\n    threadlocal_stats_aggregate(in_independent_stats->thread_stats,\n                                out_thread_stats);\n}\n\n/* return server specific stats only */\nstatic void server_stats(ADD_STAT add_stats, conn *c, bool aggregate) {\n    pid_t pid = getpid();\n    rel_time_t now = current_time;\n\n    struct thread_stats thread_stats;\n    threadlocal_stats_clear(&thread_stats);\n\n    if (aggregate && settings.engine.v1->aggregate_stats != NULL) {\n        settings.engine.v1->aggregate_stats(settings.engine.v0,\n                                            (const void *)c,\n                                            aggregate_callback,\n                                            &thread_stats);\n    } else {\n        threadlocal_stats_aggregate(get_independent_stats(c)->thread_stats,\n                                    &thread_stats);\n    }\n\n    struct slab_stats slab_stats;\n    slab_stats_aggregate(&thread_stats, &slab_stats);\n\n#ifndef __WIN32__\n    struct rusage usage;\n    getrusage(RUSAGE_SELF, &usage);\n#endif\n\n    STATS_LOCK();\n\n    APPEND_STAT(\"pid\", \"%lu\", (long)pid);\n    APPEND_STAT(\"uptime\", \"%u\", now);\n    APPEND_STAT(\"time\", \"%ld\", now + (long)process_started);\n    APPEND_STAT(\"version\", \"%s\", VERSION);\n    APPEND_STAT(\"libevent\", \"%s\", event_get_version());\n    APPEND_STAT(\"pointer_size\", \"%d\", (int)(8 * sizeof(void *)));\n\n#ifndef __WIN32__\n    append_stat(\"rusage_user\", add_stats, c, \"%ld.%06ld\",\n                (long)usage.ru_utime.tv_sec,\n                (long)usage.ru_utime.tv_usec);\n    append_stat(\"rusage_system\", add_stats, c, \"%ld.%06ld\",\n                (long)usage.ru_stime.tv_sec,\n                (long)usage.ru_stime.tv_usec);\n#endif\n\n    APPEND_STAT(\"daemon_connections\", \"%u\", stats.daemon_conns);\n    APPEND_STAT(\"curr_connections\", \"%u\", stats.curr_conns);\n    APPEND_STAT(\"total_connections\", \"%u\", stats.total_conns);\n    APPEND_STAT(\"connection_structures\", \"%u\", stats.conn_structs);\n    APPEND_STAT(\"cmd_get\", \"%\"PRIu64, thread_stats.cmd_get);\n    APPEND_STAT(\"cmd_set\", \"%\"PRIu64, slab_stats.cmd_set);\n    APPEND_STAT(\"cmd_flush\", \"%\"PRIu64, thread_stats.cmd_flush);\n    APPEND_STAT(\"auth_cmds\", \"%\"PRIu64, thread_stats.auth_cmds);\n    APPEND_STAT(\"auth_errors\", \"%\"PRIu64, thread_stats.auth_errors);\n    APPEND_STAT(\"get_hits\", \"%\"PRIu64, slab_stats.get_hits);\n    APPEND_STAT(\"get_misses\", \"%\"PRIu64, thread_stats.get_misses);\n    APPEND_STAT(\"delete_misses\", \"%\"PRIu64, thread_stats.delete_misses);\n    APPEND_STAT(\"delete_hits\", \"%\"PRIu64, slab_stats.delete_hits);\n    APPEND_STAT(\"incr_misses\", \"%\"PRIu64, thread_stats.incr_misses);\n    APPEND_STAT(\"incr_hits\", \"%\"PRIu64, thread_stats.incr_hits);\n    APPEND_STAT(\"decr_misses\", \"%\"PRIu64, thread_stats.decr_misses);\n    APPEND_STAT(\"decr_hits\", \"%\"PRIu64, thread_stats.decr_hits);\n    APPEND_STAT(\"cas_misses\", \"%\"PRIu64, thread_stats.cas_misses);\n    APPEND_STAT(\"cas_hits\", \"%\"PRIu64, slab_stats.cas_hits);\n    APPEND_STAT(\"cas_badval\", \"%\"PRIu64, slab_stats.cas_badval);\n    APPEND_STAT(\"bytes_read\", \"%\"PRIu64, thread_stats.bytes_read);\n    APPEND_STAT(\"bytes_written\", \"%\"PRIu64, thread_stats.bytes_written);\n    APPEND_STAT(\"limit_maxbytes\", \"%\"PRIu64, settings.maxbytes);\n    APPEND_STAT(\"accepting_conns\", \"%u\",  is_listen_disabled() ? 0 : 1);\n    APPEND_STAT(\"listen_disabled_num\", \"%\"PRIu64, get_listen_disabled_num());\n    APPEND_STAT(\"rejected_conns\", \"%\" PRIu64, (unsigned long long)stats.rejected_conns);\n    APPEND_STAT(\"threads\", \"%d\", settings.num_threads);\n    APPEND_STAT(\"conn_yields\", \"%\" PRIu64, (unsigned long long)thread_stats.conn_yields);\n    STATS_UNLOCK();\n\n    /*\n     * Add tap stats (only if non-zero)\n     */\n    struct tap_stats ts;\n    pthread_mutex_lock(&tap_stats.mutex);\n    ts = tap_stats;\n    pthread_mutex_unlock(&tap_stats.mutex);\n\n    if (ts.sent.connect) {\n        APPEND_STAT(\"tap_connect_sent\", \"%\"PRIu64, ts.sent.connect);\n    }\n    if (ts.sent.mutation) {\n        APPEND_STAT(\"tap_mutation_sent\", \"%\"PRIu64, ts.sent.mutation);\n    }\n    if (ts.sent.checkpoint_start) {\n        APPEND_STAT(\"tap_checkpoint_start_sent\", \"%\"PRIu64, ts.sent.checkpoint_start);\n    }\n    if (ts.sent.checkpoint_end) {\n        APPEND_STAT(\"tap_checkpoint_end_sent\", \"%\"PRIu64, ts.sent.checkpoint_end);\n    }\n    if (ts.sent.delete) {\n        APPEND_STAT(\"tap_delete_sent\", \"%\"PRIu64, ts.sent.delete);\n    }\n    if (ts.sent.flush) {\n        APPEND_STAT(\"tap_flush_sent\", \"%\"PRIu64, ts.sent.flush);\n    }\n    if (ts.sent.opaque) {\n        APPEND_STAT(\"tap_opaque_sent\", \"%\"PRIu64, ts.sent.opaque);\n    }\n    if (ts.sent.vbucket_set) {\n        APPEND_STAT(\"tap_vbucket_set_sent\", \"%\"PRIu64,\n                    ts.sent.vbucket_set);\n    }\n    if (ts.received.connect) {\n        APPEND_STAT(\"tap_connect_received\", \"%\"PRIu64, ts.received.connect);\n    }\n    if (ts.received.mutation) {\n        APPEND_STAT(\"tap_mutation_received\", \"%\"PRIu64, ts.received.mutation);\n    }\n    if (ts.received.checkpoint_start) {\n        APPEND_STAT(\"tap_checkpoint_start_received\", \"%\"PRIu64, ts.received.checkpoint_start);\n    }\n    if (ts.received.checkpoint_end) {\n        APPEND_STAT(\"tap_checkpoint_end_received\", \"%\"PRIu64, ts.received.checkpoint_end);\n    }\n    if (ts.received.delete) {\n        APPEND_STAT(\"tap_delete_received\", \"%\"PRIu64, ts.received.delete);\n    }\n    if (ts.received.flush) {\n        APPEND_STAT(\"tap_flush_received\", \"%\"PRIu64, ts.received.flush);\n    }\n    if (ts.received.opaque) {\n        APPEND_STAT(\"tap_opaque_received\", \"%\"PRIu64, ts.received.opaque);\n    }\n    if (ts.received.vbucket_set) {\n        APPEND_STAT(\"tap_vbucket_set_received\", \"%\"PRIu64,\n                    ts.received.vbucket_set);\n    }\n}\n\nstatic void process_stat_settings(ADD_STAT add_stats, void *c) {\n    assert(add_stats);\n    APPEND_STAT(\"maxbytes\", \"%u\", (unsigned int)settings.maxbytes);\n    APPEND_STAT(\"maxconns\", \"%d\", settings.maxconns);\n    APPEND_STAT(\"tcpport\", \"%d\", settings.port);\n    APPEND_STAT(\"udpport\", \"%d\", settings.udpport);\n    APPEND_STAT(\"inter\", \"%s\", settings.inter ? settings.inter : \"NULL\");\n    APPEND_STAT(\"verbosity\", \"%d\", settings.verbose);\n    APPEND_STAT(\"oldest\", \"%lu\", (unsigned long)settings.oldest_live);\n    APPEND_STAT(\"evictions\", \"%s\", settings.evict_to_free ? \"on\" : \"off\");\n    APPEND_STAT(\"domain_socket\", \"%s\",\n                settings.socketpath ? settings.socketpath : \"NULL\");\n    APPEND_STAT(\"umask\", \"%o\", settings.access);\n    APPEND_STAT(\"growth_factor\", \"%.2f\", settings.factor);\n    APPEND_STAT(\"chunk_size\", \"%d\", settings.chunk_size);\n    APPEND_STAT(\"num_threads\", \"%d\", settings.num_threads);\n    APPEND_STAT(\"num_threads_per_udp\", \"%d\", settings.num_threads_per_udp);\n    APPEND_STAT(\"stat_key_prefix\", \"%c\", settings.prefix_delimiter);\n    APPEND_STAT(\"detail_enabled\", \"%s\",\n                settings.detail_enabled ? \"yes\" : \"no\");\n    APPEND_STAT(\"allow_detailed\", \"%s\",\n                settings.allow_detailed ? \"yes\" : \"no\");\n    APPEND_STAT(\"reqs_per_event\", \"%d\", settings.reqs_per_event);\n    APPEND_STAT(\"reqs_per_tap_event\", \"%d\", settings.reqs_per_tap_event);\n    APPEND_STAT(\"cas_enabled\", \"%s\", settings.use_cas ? \"yes\" : \"no\");\n    APPEND_STAT(\"tcp_backlog\", \"%d\", settings.backlog);\n    APPEND_STAT(\"binding_protocol\", \"%s\",\n                prot_text(settings.binding_protocol));\n#ifdef SASL_ENABLED\n    APPEND_STAT(\"auth_enabled_sasl\", \"%s\", \"yes\");\n#else\n    APPEND_STAT(\"auth_enabled_sasl\", \"%s\", \"no\");\n#endif\n\n#ifdef ENABLE_ISASL\n    APPEND_STAT(\"auth_sasl_engine\", \"%s\", \"isasl\");\n#elif defined(ENABLE_SASL)\n    APPEND_STAT(\"auth_sasl_engine\", \"%s\", \"cyrus\");\n#else\n    APPEND_STAT(\"auth_sasl_engine\", \"%s\", \"none\");\n#endif\n    APPEND_STAT(\"auth_required_sasl\", \"%s\", settings.require_sasl ? \"yes\" : \"no\");\n    APPEND_STAT(\"item_size_max\", \"%d\", settings.item_size_max);\n    APPEND_STAT(\"topkeys\", \"%d\", settings.topkeys);\n\n    for (EXTENSION_DAEMON_DESCRIPTOR *ptr = settings.extensions.daemons;\n         ptr != NULL;\n         ptr = ptr->next) {\n        APPEND_STAT(\"extension\", \"%s\", ptr->get_name());\n    }\n\n    APPEND_STAT(\"logger\", \"%s\", settings.extensions.logger->get_name());\n\n    for (EXTENSION_ASCII_PROTOCOL_DESCRIPTOR *ptr = settings.extensions.ascii;\n         ptr != NULL;\n         ptr = ptr->next) {\n        APPEND_STAT(\"ascii_extension\", \"%s\", ptr->get_name(ptr->cookie));\n    }\n}\n\nstatic char *process_stat(conn *c, token_t *tokens, const size_t ntokens) {\n    const char *subcommand = tokens[SUBCOMMAND_TOKEN].value;\n    c->dynamic_buffer.offset = 0;\n\n    if (ntokens == 2) {\n        ENGINE_ERROR_CODE ret = c->aiostat;\n        c->aiostat = ENGINE_SUCCESS;\n        c->ewouldblock = false;\n        if (ret == ENGINE_SUCCESS) {\n            server_stats(&append_stats, c, false);\n            ret = settings.engine.v1->get_stats(settings.engine.v0, c,\n                                                NULL, 0, &append_stats);\n            if (ret == ENGINE_EWOULDBLOCK) {\n                c->ewouldblock = true;\n                return c->rcurr + 5;\n            }\n        }\n    } else if (strcmp(subcommand, \"reset\") == 0) {\n        stats_reset(c);\n        out_string(c, \"RESET\");\n        return NULL;\n    } else if (strcmp(subcommand, \"detail\") == 0) {\n        /* NOTE: how to tackle detail with binary? */\n        if (ntokens < 4) {\n            process_stats_detail(c, \"\");  /* outputs the error message */\n        } else {\n            process_stats_detail(c, tokens[2].value);\n        }\n        /* Output already generated */\n        return NULL;\n    } else if (strcmp(subcommand, \"settings\") == 0) {\n        process_stat_settings(&append_stats, c);\n    } else if (strcmp(subcommand, \"cachedump\") == 0) {\n        char *buf = NULL;\n        unsigned int bytes = 0, id, limit = 0;\n\n        if (ntokens < 5) {\n            out_string(c, \"CLIENT_ERROR bad command line\");\n            return NULL;\n        }\n\n        if (!safe_strtoul(tokens[2].value, &id) ||\n            !safe_strtoul(tokens[3].value, &limit)) {\n            out_string(c, \"CLIENT_ERROR bad command line format\");\n            return NULL;\n        }\n\n        if (id >= POWER_LARGEST) {\n            out_string(c, \"CLIENT_ERROR Illegal slab id\");\n            return NULL;\n        }\n\n#ifdef FUTURE\n        buf = item_cachedump(id, limit, &bytes);\n#endif\n        write_and_free(c, buf, bytes);\n        return NULL;\n    } else if (strcmp(subcommand, \"aggregate\") == 0) {\n        server_stats(&append_stats, c, true);\n    } else if (strcmp(subcommand, \"topkeys\") == 0) {\n        topkeys_t *tk = get_independent_stats(c)->topkeys;\n        if (tk != NULL) {\n            topkeys_stats(tk, c, current_time, append_stats);\n        } else {\n            out_string(c, \"ERROR\");\n            return NULL;\n        }\n    } else {\n        /* getting here means that the subcommand is either engine specific or\n           is invalid. query the engine and see. */\n        ENGINE_ERROR_CODE ret = c->aiostat;\n        c->aiostat = ENGINE_SUCCESS;\n        c->ewouldblock = false;\n        if (ret == ENGINE_SUCCESS) {\n            char *buf = NULL;\n            int nb = -1;\n            detokenize(&tokens[1], ntokens - 2, &buf, &nb);\n            ret = settings.engine.v1->get_stats(settings.engine.v0, c, buf,\n                                                nb, append_stats);\n            free(buf);\n        }\n\n        switch (ret) {\n        case ENGINE_SUCCESS:\n            append_stats(NULL, 0, NULL, 0, c);\n            write_and_free(c, c->dynamic_buffer.buffer, c->dynamic_buffer.offset);\n            c->dynamic_buffer.buffer = NULL;\n            break;\n        case ENGINE_ENOMEM:\n            out_string(c, \"SERVER_ERROR out of memory writing stats\");\n            break;\n        case ENGINE_DISCONNECT:\n            c->state = conn_closing;\n            break;\n        case ENGINE_ENOTSUP:\n            out_string(c, \"SERVER_ERROR not supported\");\n            break;\n        case ENGINE_EWOULDBLOCK:\n            c->ewouldblock = true;\n            return tokens[SUBCOMMAND_TOKEN].value;\n        default:\n            out_string(c, \"ERROR\");\n            break;\n        }\n\n        return NULL;\n    }\n\n    /* append terminator and start the transfer */\n    append_stats(NULL, 0, NULL, 0, c);\n\n    if (c->dynamic_buffer.buffer == NULL) {\n        out_string(c, \"SERVER_ERROR out of memory writing stats\");\n    } else {\n        write_and_free(c, c->dynamic_buffer.buffer, c->dynamic_buffer.offset);\n        c->dynamic_buffer.buffer = NULL;\n    }\n\n    return NULL;\n}\n\n/**\n * Get a suffix buffer and insert it into the list of used suffix buffers\n * @param c the connection object\n * @return a pointer to a new suffix buffer or NULL if allocation failed\n */\nstatic char *get_suffix_buffer(conn *c) {\n    if (c->suffixleft == c->suffixsize) {\n        char **new_suffix_list;\n        size_t sz = sizeof(char*) * c->suffixsize * 2;\n\n        new_suffix_list = realloc(c->suffixlist, sz);\n        if (new_suffix_list) {\n            c->suffixsize *= 2;\n            c->suffixlist = new_suffix_list;\n        } else {\n            if (settings.verbose > 1) {\n                settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                        \"=%d Failed to resize suffix buffer\\n\", c->sfd);\n            }\n\n            return NULL;\n        }\n    }\n\n    char *suffix = cache_alloc(c->thread->suffix_cache);\n    if (suffix != NULL) {\n        *(c->suffixlist + c->suffixleft) = suffix;\n        ++c->suffixleft;\n    }\n\n    return suffix;\n}\n\n/* ntokens is overwritten here... shrug.. */\nstatic inline char* process_get_command(conn *c, token_t *tokens, size_t ntokens, bool return_cas) {\n    char *key;\n    size_t nkey;\n    int i = c->ileft;\n    item *it = NULL;\n    token_t *key_token = &tokens[KEY_TOKEN];\n    int range = false;\n    assert(c != NULL);\n\n    do {\n        while(key_token->length != 0) {\n            /* whether there are more keys to fetch */\n            bool next_get = (key_token + 1)->value;\n\n            key = key_token->value;\n            nkey = key_token->length;\n\n            /* whether this is a range search */\n            if (nkey >=  2 && key[0] == '@'\n\t\t&& (key[1] == '>' || key[1] == '<')) {\n\t\trange = true;\n            }\n\n            if(nkey > KEY_MAX_LENGTH) {\n                out_string(c, \"CLIENT_ERROR bad command line format\");\n                return NULL;\n            }\n\n            ENGINE_ERROR_CODE ret = c->aiostat;\n            c->aiostat = ENGINE_SUCCESS;\n\n            if (ret == ENGINE_SUCCESS) {\n                ret = settings.engine.v1->get(settings.engine.v0, c, &it,\n\t\t\t\t\t      key, nkey, next_get);\n            }\n\n            switch (ret) {\n            case ENGINE_EWOULDBLOCK:\n                c->ewouldblock = true;\n                c->ileft = i;\n                return key;\n\n            case ENGINE_SUCCESS:\n                break;\n            case ENGINE_KEY_ENOENT:\n            default:\n                it = NULL;\n                break;\n            }\n\n            if (settings.detail_enabled) {\n                stats_prefix_record_get(key, nkey, NULL != it);\n            }\n\n            if (it) {\n                item_info info = { .nvalue = 1 };\n                if (!settings.engine.v1->get_item_info(settings.engine.v0, c, it,\n                                                       &info)) {\n                    settings.engine.v1->release(settings.engine.v0, c, it);\n                    out_string(c, \"SERVER_ERROR error getting item data\");\n                    break;\n                }\n\n                if (i >= c->isize) {\n                    item **new_list = realloc(c->ilist, sizeof(item *) * c->isize * 2);\n                    if (new_list) {\n                        c->isize *= 2;\n                        c->ilist = new_list;\n                    } else {\n                        settings.engine.v1->release(settings.engine.v0, c, it);\n                        break;\n                    }\n                }\n\n                /* Rebuild the suffix */\n                char *suffix = get_suffix_buffer(c);\n                if (suffix == NULL) {\n                    out_string(c, \"SERVER_ERROR out of memory rebuilding suffix\");\n                    settings.engine.v1->release(settings.engine.v0, c, it);\n                    return NULL;\n                }\n                int suffix_len = snprintf(suffix, SUFFIX_SIZE,\n                                          \" %u %u\\r\\n\", htonl(info.flags),\n                                          info.nbytes);\n\n                /*\n                 * Construct the response. Each hit adds three elements to the\n                 * outgoing data list:\n                 *   \"VALUE \"\n                 *   key\n                 *   \" \" + flags + \" \" + data length + \"\\r\\n\" + data (with \\r\\n)\n                 */\n\n                MEMCACHED_COMMAND_GET(c->sfd, info.key, info.nkey,\n                                      info.nbytes, info.cas);\n                if (return_cas)\n                {\n\n                  char *cas = get_suffix_buffer(c);\n                  if (cas == NULL) {\n                    out_string(c, \"SERVER_ERROR out of memory making CAS suffix\");\n                    settings.engine.v1->release(settings.engine.v0, c, it);\n                    return NULL;\n                  }\n                  int cas_len = snprintf(cas, SUFFIX_SIZE, \" %\"PRIu64\"\\r\\n\",\n                                         info.cas);\n                  if (add_iov(c, \"VALUE \", 6) != 0 ||\n                      add_iov(c, info.key, info.nkey) != 0 ||\n                      add_iov(c, suffix, suffix_len - 2) != 0 ||\n                      add_iov(c, cas, cas_len) != 0 ||\n                      add_iov(c, info.value[0].iov_base, info.value[0].iov_len) != 0 ||\n                      add_iov(c, \"\\r\\n\", 2) != 0)\n                      {\n                          settings.engine.v1->release(settings.engine.v0, c, it);\n                          break;\n                      }\n                }\n                else\n                {\n                  if (add_iov(c, \"VALUE \", 6) != 0 ||\n                      add_iov(c, info.key, info.nkey) != 0 ||\n                      add_iov(c, suffix, suffix_len) != 0 ||\n                      add_iov(c, info.value[0].iov_base, info.value[0].iov_len) != 0 ||\n                      add_iov(c, \"\\r\\n\", 2) != 0)\n                      {\n                          settings.engine.v1->release(settings.engine.v0, c, it);\n                          break;\n                      }\n                }\n\n\n                if (settings.verbose > 1) {\n                    settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                                    \">%d sending key %s\\n\",\n                                                    c->sfd, info.key);\n                }\n\n                /* item_get() has incremented it->refcount for us */\n                STATS_HIT(c, get, key, nkey);\n                *(c->ilist + i) = it;\n                i++;\n\n            } else {\n                STATS_MISS(c, get, key, nkey);\n                MEMCACHED_COMMAND_GET(c->sfd, key, nkey, -1, 0);\n            }\n\n            if (!range) {\n\t\tkey_token++;\n            } else {\n\t\tif (ret == ENGINE_KEY_ENOENT) {\n\t\t\tkey_token->value = NULL;\n\t\t}\n\t\tbreak;\n\t    }\n        }\n\n        /*\n         * If the command string hasn't been fully processed, get the next set\n         * of tokens.\n         */\n        if(key_token->value != NULL) {\n            ntokens = tokenize_command(key_token->value, tokens, MAX_TOKENS);\n            key_token = tokens;\n        }\n\n    } while(key_token->value != NULL);\n\n    c->icurr = c->ilist;\n    c->ileft = i;\n    c->suffixcurr = c->suffixlist;\n\n    if (settings.verbose > 1) {\n        settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                        \">%d END\\n\", c->sfd);\n    }\n\n    /*\n        If the loop was terminated because of out-of-memory, it is not\n        reliable to add END\\r\\n to the buffer, because it might not end\n        in \\r\\n. So we send SERVER_ERROR instead.\n    */\n    if (key_token->value != NULL || add_iov(c, \"END\\r\\n\", 5) != 0\n        || (IS_UDP(c->transport) && build_udp_headers(c) != 0)) {\n        out_string(c, \"SERVER_ERROR out of memory writing get response\");\n    }\n    else {\n        conn_set_state(c, conn_mwrite);\n        c->msgcurr = 0;\n    }\n\n    return NULL;\n}\n\nstatic void process_update_command(conn *c, token_t *tokens, const size_t ntokens, ENGINE_STORE_OPERATION store_op, bool handle_cas) {\n    char *key;\n    size_t nkey;\n    unsigned int flags;\n    int32_t exptime_int = 0;\n    time_t exptime;\n    int vlen = 0;\n    uint64_t req_cas_id=0;\n    item *it = NULL;\n\n    assert(c != NULL);\n\n    set_noreply_maybe(c, tokens, ntokens);\n\n    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {\n        out_string(c, \"CLIENT_ERROR bad command line format\");\n        return;\n    }\n\n    key = tokens[KEY_TOKEN].value;\n    nkey = tokens[KEY_TOKEN].length;\n\n    if (! (safe_strtoul(tokens[2].value, (uint32_t *)&flags)\n           && safe_strtol(tokens[3].value, &exptime_int)\n           && safe_strtol(tokens[4].value, (int32_t *)&vlen))) {\n        out_string(c, \"CLIENT_ERROR bad command line format\");\n        return;\n    }\n\n    /* Negative expire values not allowed */\n\n    if (exptime_int < 0) {\n        out_string(c, \"CLIENT_ERROR Invalid expire time\");\n        return;\n    }\n\n    /* Ubuntu 8.04 breaks when I pass exptime to safe_strtol */\n    exptime = exptime_int;\n\n    // does cas value exist?\n    if (handle_cas) {\n        if (!safe_strtoull(tokens[5].value, &req_cas_id)) {\n            out_string(c, \"CLIENT_ERROR bad command line format\");\n            return;\n        }\n    }\n\n    if (vlen < 0) {\n        out_string(c, \"CLIENT_ERROR bad command line format\");\n        return;\n    }\n\n    if (settings.detail_enabled) {\n        stats_prefix_record_set(key, nkey);\n    }\n\n    ENGINE_ERROR_CODE ret = c->aiostat;\n    c->aiostat = ENGINE_SUCCESS;\n    c->ewouldblock = false;\n\n    if (ret == ENGINE_SUCCESS) {\n        ret = settings.engine.v1->allocate(settings.engine.v0, c,\n                                           &it, key, nkey,\n                                           vlen, htonl(flags), exptime);\n    }\n\n    item_info info = { .nvalue = 1 };\n    switch (ret) {\n    case ENGINE_SUCCESS:\n        item_set_cas(c, it, req_cas_id);\n        if (!settings.engine.v1->get_item_info(settings.engine.v0, c, it, &info)) {\n            settings.engine.v1->release(settings.engine.v0, c, it);\n            out_string(c, \"SERVER_ERROR error getting item data\");\n            break;\n        }\n        c->item = it;\n        c->ritem = info.value[0].iov_base;\n        c->rlbytes = vlen;\n        c->store_op = store_op;\n        conn_set_state(c, conn_nread);\n        break;\n    case ENGINE_EWOULDBLOCK:\n        c->ewouldblock = true;\n        break;\n    case ENGINE_DISCONNECT:\n        c->state = conn_closing;\n        break;\n    default:\n        if (ret == ENGINE_E2BIG) {\n            out_string(c, \"SERVER_ERROR object too large for cache\");\n        } else {\n            out_string(c, \"SERVER_ERROR out of memory storing object\");\n        }\n        /* swallow the data line */\n        c->write_and_go = conn_swallow;\n        c->sbytes = vlen + 2;\n\n        /* Avoid stale data persisting in cache because we failed alloc.\n         * Unacceptable for SET. Anywhere else too? */\n        if (store_op == OPERATION_SET) {\n            settings.engine.v1->remove(settings.engine.v0, c, key, nkey, 0, 0);\n        }\n    }\n}\n\nstatic char* process_arithmetic_command(conn *c, token_t *tokens, const size_t ntokens, const bool incr) {\n\n    uint64_t delta;\n    char *key;\n    size_t nkey;\n\n    assert(c != NULL);\n\n    set_noreply_maybe(c, tokens, ntokens);\n\n    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {\n        out_string(c, \"CLIENT_ERROR bad command line format\");\n        return NULL;\n    }\n\n    key = tokens[KEY_TOKEN].value;\n    nkey = tokens[KEY_TOKEN].length;\n\n    if (!safe_strtoull(tokens[2].value, &delta)) {\n        out_string(c, \"CLIENT_ERROR invalid numeric delta argument\");\n        return NULL;\n    }\n\n    ENGINE_ERROR_CODE ret = c->aiostat;\n    c->aiostat = ENGINE_SUCCESS;\n    uint64_t cas;\n    uint64_t result = 0;\n    if (ret == ENGINE_SUCCESS) {\n        ret = settings.engine.v1->arithmetic(settings.engine.v0, c, key, nkey,\n                                             incr, false, delta, 0, 0, &cas,\n                                             &result, 0);\n    }\n\n    char temp[INCR_MAX_STORAGE_LEN];\n    switch (ret) {\n    case ENGINE_SUCCESS:\n        if (incr) {\n            STATS_INCR(c, incr_hits, key, nkey);\n        } else {\n            STATS_INCR(c, decr_hits, key, nkey);\n        }\n        snprintf(temp, sizeof(temp), \"%\"PRIu64, result);\n        out_string(c, temp);\n        break;\n    case ENGINE_KEY_ENOENT:\n        if (incr) {\n            STATS_INCR(c, incr_misses, key, nkey);\n        } else {\n            STATS_INCR(c, decr_misses, key, nkey);\n        }\n        out_string(c, \"NOT_FOUND\");\n        break;\n    case ENGINE_ENOMEM:\n        out_string(c, \"SERVER_ERROR out of memory\");\n        break;\n    case ENGINE_TMPFAIL:\n        out_string(c, \"SERVER_ERROR temporary failure\");\n        break;\n    case ENGINE_EINVAL:\n        out_string(c, \"CLIENT_ERROR cannot increment or decrement non-numeric value\");\n        break;\n    case ENGINE_NOT_STORED:\n        out_string(c, \"SERVER_ERROR failed to store item\");\n        break;\n    case ENGINE_DISCONNECT:\n        c->state = conn_closing;\n        break;\n    case ENGINE_ENOTSUP:\n        out_string(c, \"SERVER_ERROR not supported\");\n        break;\n    case ENGINE_EWOULDBLOCK:\n        c->ewouldblock = true;\n        return key;\n    default:\n        abort();\n    }\n\n    return NULL;\n}\n\nstatic char *process_delete_command(conn *c, token_t *tokens,\n                                    const size_t ntokens) {\n    char *key;\n    size_t nkey;\n\n    assert(c != NULL);\n\n    if (ntokens > 3) {\n        bool hold_is_zero = strcmp(tokens[KEY_TOKEN+1].value, \"0\") == 0;\n        bool sets_noreply = set_noreply_maybe(c, tokens, ntokens);\n        bool valid = (ntokens == 4 && (hold_is_zero || sets_noreply))\n            || (ntokens == 5 && hold_is_zero && sets_noreply);\n        if (!valid) {\n            out_string(c, \"CLIENT_ERROR bad command line format.  \"\n                       \"Usage: delete <key> [noreply]\");\n            return NULL;\n        }\n    }\n\n    key = tokens[KEY_TOKEN].value;\n    nkey = tokens[KEY_TOKEN].length;\n\n    if (nkey > KEY_MAX_LENGTH) {\n        out_string(c, \"CLIENT_ERROR bad command line format\");\n        return NULL;\n    }\n\n    ENGINE_ERROR_CODE ret = c->aiostat;\n    c->aiostat = ENGINE_SUCCESS;\n    c->ewouldblock = false;\n    if (ret == ENGINE_SUCCESS) {\n        ret = settings.engine.v1->remove(settings.engine.v0, c,\n                                         key, nkey, 0, 0);\n    }\n\n    /* For some reason the SLAB_INCR tries to access this... */\n    item_info info = { .nvalue = 1 };\n    switch (ret) {\n    case ENGINE_SUCCESS:\n        out_string(c, \"DELETED\");\n        SLAB_INCR(c, delete_hits, key, nkey);\n        break;\n    case ENGINE_EWOULDBLOCK:\n        c->ewouldblock = true;\n        return key;\n    case ENGINE_TMPFAIL:\n        out_string(c, \"SERVER_ERROR temporary failure\");\n        break;\n    default:\n        out_string(c, \"NOT_FOUND\");\n        STATS_INCR(c, delete_misses, key, nkey);\n    }\n\n    if (ret != ENGINE_EWOULDBLOCK && settings.detail_enabled) {\n        stats_prefix_record_delete(key, nkey);\n    }\n    return NULL;\n}\n\nstatic char *process_bind_command(conn *c, token_t *tokens,\n                                  const size_t ntokens) {\n    char *name;\n    size_t name_len;\n\n    assert(c != NULL);\n\n    if (ntokens > 3) {\n        out_string(c, \"CLIENT_ERROR bad command line format.  \"\n                      \"Usage: bind <table_id_name>\");\n        return NULL;\n    }\n\n    name = tokens[KEY_TOKEN].value;\n    name_len = tokens[KEY_TOKEN].length;\n\n    if (name_len > KEY_MAX_LENGTH || name_len == 0) {\n        out_string(c, \"CLIENT_ERROR bad command line format\");\n        return NULL;\n    }\n\n    ENGINE_ERROR_CODE ret = c->aiostat;\n    c->aiostat = ENGINE_SUCCESS;\n    c->ewouldblock = false;\n    if (ret == ENGINE_SUCCESS) {\n        ret = settings.engine.v1->bind(settings.engine.v0, c,\n                                       name, name_len);\n    }\n\n    /* For some reason the SLAB_INCR tries to access this... */\n    item_info info = { .nvalue = 1 };\n    switch (ret) {\n    case ENGINE_SUCCESS:\n        out_string(c, \"SUCCEED\");\n        break;\n    case ENGINE_EWOULDBLOCK:\n        c->ewouldblock = true;\n        return name;\n    case ENGINE_TMPFAIL:\n    default:\n        out_string(c, \"NOT_FOUND\");\n    }\n\n    return NULL;\n}\n\nstatic void process_verbosity_command(conn *c, token_t *tokens, const size_t ntokens) {\n    unsigned int level;\n\n    assert(c != NULL);\n\n    set_noreply_maybe(c, tokens, ntokens);\n    if (c->noreply && ntokens == 3) {\n        /* \"verbosity noreply\" is not according to the correct syntax */\n        c->noreply = false;\n        out_string(c, \"ERROR\");\n        return;\n    }\n\n    if (safe_strtoul(tokens[1].value, &level)) {\n        settings.verbose = level > MAX_VERBOSITY_LEVEL ? MAX_VERBOSITY_LEVEL : level;\n        perform_callbacks(ON_LOG_LEVEL, NULL, NULL);\n        out_string(c, \"OK\");\n    } else {\n        out_string(c, \"ERROR\");\n    }\n}\n\nstatic char* process_command(conn *c, char *command) {\n\n    token_t tokens[MAX_TOKENS];\n    size_t ntokens;\n    int comm;\n    char *ret = NULL;\n\n    assert(c != NULL);\n\n    MEMCACHED_PROCESS_COMMAND_START(c->sfd, c->rcurr, c->rbytes);\n\n    if (settings.verbose > 1) {\n        settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                        \"<%d %s\\n\", c->sfd, command);\n    }\n\n    /*\n     * for commands set/add/replace, we build an item and read the data\n     * directly into it, then continue in nread_complete().\n     */\n\n    if (c->ewouldblock) {\n        /*\n         * If we are retrying after the engine has completed a pending io for\n         * this command, skip add_msghdr() etc and clear the ewouldblock flag.\n         */\n        c->ewouldblock = false;\n    } else {\n        c->msgcurr = 0;\n        c->msgused = 0;\n        c->iovused = 0;\n        if (add_msghdr(c) != 0) {\n            out_string(c, \"SERVER_ERROR out of memory preparing response\");\n            return NULL;\n        }\n    }\n\n    ntokens = tokenize_command(command, tokens, MAX_TOKENS);\n    if (ntokens >= 3 &&\n        ((strcmp(tokens[COMMAND_TOKEN].value, \"get\") == 0) ||\n         (strcmp(tokens[COMMAND_TOKEN].value, \"bget\") == 0))) {\n\n        ret = process_get_command(c, tokens, ntokens, false);\n\n    } else if ((ntokens == 6 || ntokens == 7) &&\n               ((strcmp(tokens[COMMAND_TOKEN].value, \"add\") == 0 && (comm = (int)OPERATION_ADD)) ||\n                (strcmp(tokens[COMMAND_TOKEN].value, \"set\") == 0 && (comm = (int)OPERATION_SET)) ||\n                (strcmp(tokens[COMMAND_TOKEN].value, \"replace\") == 0 && (comm = (int)OPERATION_REPLACE)) ||\n                (strcmp(tokens[COMMAND_TOKEN].value, \"prepend\") == 0 && (comm = (int)OPERATION_PREPEND)) ||\n                (strcmp(tokens[COMMAND_TOKEN].value, \"append\") == 0 && (comm = (int)OPERATION_APPEND)) )) {\n\n        process_update_command(c, tokens, ntokens, (ENGINE_STORE_OPERATION)comm, false);\n\n    } else if ((ntokens == 7 || ntokens == 8) && (strcmp(tokens[COMMAND_TOKEN].value, \"cas\") == 0 && (comm = (int)OPERATION_CAS))) {\n\n        process_update_command(c, tokens, ntokens, (ENGINE_STORE_OPERATION)comm, true);\n\n    } else if ((ntokens == 4 || ntokens == 5) && (strcmp(tokens[COMMAND_TOKEN].value, \"incr\") == 0)) {\n\n        ret = process_arithmetic_command(c, tokens, ntokens, 1);\n\n    } else if (ntokens >= 3 && (strcmp(tokens[COMMAND_TOKEN].value, \"gets\") == 0)) {\n\n        ret = process_get_command(c, tokens, ntokens, true);\n\n    } else if ((ntokens == 4 || ntokens == 5) && (strcmp(tokens[COMMAND_TOKEN].value, \"decr\") == 0)) {\n\n        ret = process_arithmetic_command(c, tokens, ntokens, 0);\n\n    } else if (ntokens >= 3 && ntokens <= 5 && (strcmp(tokens[COMMAND_TOKEN].value, \"delete\") == 0)) {\n\n        ret = process_delete_command(c, tokens, ntokens);\n\n    } else if (ntokens == 3 && (strcmp(tokens[COMMAND_TOKEN].value, \"bind\") == 0)) {\n\n        ret = process_bind_command(c, tokens, ntokens);\n\n    } else if (ntokens >= 2 && (strcmp(tokens[COMMAND_TOKEN].value, \"stats\") == 0)) {\n\n        ret = process_stat(c, tokens, ntokens);\n\n    } else if (ntokens >= 2 && ntokens <= 4 && (strcmp(tokens[COMMAND_TOKEN].value, \"flush_all\") == 0)) {\n        time_t exptime;\n\n        set_noreply_maybe(c, tokens, ntokens);\n\n        if (ntokens == (c->noreply ? 3 : 2)) {\n            exptime = 0;\n        } else {\n            exptime = strtol(tokens[1].value, NULL, 10);\n            if(errno == ERANGE) {\n                out_string(c, \"CLIENT_ERROR bad command line format\");\n                return NULL;\n            }\n        }\n\n        ENGINE_ERROR_CODE ret = c->aiostat;\n        c->aiostat = ENGINE_SUCCESS;\n        c->ewouldblock = false;\n        if (ret == ENGINE_SUCCESS) {\n            ret = settings.engine.v1->flush(settings.engine.v0, c, exptime);\n        }\n\n        switch (ret) {\n        case  ENGINE_SUCCESS:\n            out_string(c, \"OK\");\n            break;\n        case ENGINE_ENOTSUP:\n            out_string(c, \"SERVER_ERROR not supported\");\n            break;\n        case ENGINE_EWOULDBLOCK:\n            c->ewouldblock = true;\n            return c->rcurr + 9;\n        default:\n            out_string(c, \"SERVER_ERROR failed to flush cache\");\n        }\n\n        if (ret != ENGINE_EWOULDBLOCK) {\n            STATS_NOKEY(c, cmd_flush);\n        }\n        return NULL;\n\n    } else if (ntokens == 2 && (strcmp(tokens[COMMAND_TOKEN].value, \"version\") == 0)) {\n\n        out_string(c, \"VERSION \" VERSION);\n\n    } else if (ntokens == 2 && (strcmp(tokens[COMMAND_TOKEN].value, \"quit\") == 0)) {\n\n        conn_set_state(c, conn_closing);\n\n    } else if ((ntokens == 3 || ntokens == 4) && (strcmp(tokens[COMMAND_TOKEN].value, \"verbosity\") == 0)) {\n        process_verbosity_command(c, tokens, ntokens);\n    } else if (settings.extensions.ascii != NULL) {\n        EXTENSION_ASCII_PROTOCOL_DESCRIPTOR *cmd;\n        size_t nbytes = 0;\n        char *ptr = NULL;\n\n        if (ntokens > 0) {\n            if (ntokens == MAX_TOKENS) {\n                out_string(c, \"ERROR too many arguments\");\n                return NULL;\n            }\n\n            if (tokens[ntokens - 1].length == 0) {\n                --ntokens;\n            }\n        }\n\n        for (cmd = settings.extensions.ascii; cmd != NULL; cmd = cmd->next) {\n            if (cmd->accept(cmd->cookie, c, ntokens, tokens, &nbytes, &ptr)) {\n                break;\n            }\n        }\n\n        if (cmd == NULL) {\n            out_string(c, \"ERROR unknown command\");\n        } else if (nbytes == 0) {\n            switch (cmd->execute(cmd->cookie, c, ntokens, tokens,\n                                 ascii_response_handler)) {\n            case ENGINE_SUCCESS:\n                if (c->dynamic_buffer.buffer != NULL) {\n                    write_and_free(c, c->dynamic_buffer.buffer,\n                                   c->dynamic_buffer.offset);\n                    c->dynamic_buffer.buffer = NULL;\n                } else {\n                    conn_set_state(c, conn_new_cmd);\n                }\n                break;\n            case ENGINE_EWOULDBLOCK:\n                c->ewouldblock = true;\n                ret = tokens[KEY_TOKEN].value;;\n                break;\n            case ENGINE_DISCONNECT:\n            default:\n                conn_set_state(c, conn_closing);\n\n            }\n        } else {\n            c->rlbytes = nbytes;\n            c->ritem = ptr;\n            c->ascii_cmd = cmd;\n            /* NOT SUPPORTED YET! */\n            conn_set_state(c, conn_nread);\n        }\n    } else {\n        out_string(c, \"ERROR\");\n    }\n    return ret;\n}\n\n/*\n * if we have a complete line in the buffer, process it.\n */\nstatic int try_read_command(conn *c) {\n    assert(c != NULL);\n    assert(c->rcurr <= (c->rbuf + c->rsize));\n    assert(c->rbytes > 0);\n\n    if (c->protocol == negotiating_prot || c->transport == udp_transport)  {\n        if ((unsigned char)c->rbuf[0] == (unsigned char)PROTOCOL_BINARY_REQ) {\n            c->protocol = binary_prot;\n        } else {\n            c->protocol = ascii_prot;\n        }\n\n        if (settings.verbose > 1) {\n            settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                    \"%d: Client using the %s protocol\\n\", c->sfd,\n                    prot_text(c->protocol));\n        }\n    }\n\n    if (c->protocol == binary_prot) {\n        /* Do we have the complete packet header? */\n        if (c->rbytes < sizeof(c->binary_header)) {\n            /* need more data! */\n            return 0;\n        } else {\n#ifdef NEED_ALIGN\n            if (((long)(c->rcurr)) % 8 != 0) {\n                /* must realign input buffer */\n                memmove(c->rbuf, c->rcurr, c->rbytes);\n                c->rcurr = c->rbuf;\n                if (settings.verbose > 1) {\n                    settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                             \"%d: Realign input buffer\\n\", c->sfd);\n                }\n            }\n#endif\n            protocol_binary_request_header* req;\n            req = (protocol_binary_request_header*)c->rcurr;\n\n            if (settings.verbose > 1) {\n                /* Dump the packet before we convert it to host order */\n                char buffer[1024];\n                ssize_t nw;\n                nw = bytes_to_output_string(buffer, sizeof(buffer), c->sfd,\n                                            true, \"Read binary protocol data:\",\n                                            (const char*)req->bytes,\n                                            sizeof(req->bytes));\n                if (nw != -1) {\n                    settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                                    \"%s\", buffer);\n                }\n            }\n\n            c->binary_header = *req;\n            c->binary_header.request.keylen = ntohs(req->request.keylen);\n            c->binary_header.request.bodylen = ntohl(req->request.bodylen);\n            c->binary_header.request.vbucket = ntohs(req->request.vbucket);\n            c->binary_header.request.cas = ntohll(req->request.cas);\n\n\n            if (c->binary_header.request.magic != PROTOCOL_BINARY_REQ &&\n                !(c->binary_header.request.magic == PROTOCOL_BINARY_RES &&\n                  response_handlers[c->binary_header.request.opcode])) {\n                if (settings.verbose) {\n                    if (c->binary_header.request.magic != PROTOCOL_BINARY_RES) {\n                        settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                              \"%d: Invalid magic:  %x\\n\", c->sfd,\n                              c->binary_header.request.magic);\n                    } else {\n                        settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                              \"%d: ERROR: Unsupported response packet received: %u\\n\",\n                              c->sfd, (unsigned int)c->binary_header.request.opcode);\n\n                    }\n                }\n                conn_set_state(c, conn_closing);\n                return -1;\n            }\n\n            c->msgcurr = 0;\n            c->msgused = 0;\n            c->iovused = 0;\n            if (add_msghdr(c) != 0) {\n                out_string(c, \"SERVER_ERROR out of memory\");\n                return 0;\n            }\n\n            c->cmd = c->binary_header.request.opcode;\n            c->keylen = c->binary_header.request.keylen;\n            c->opaque = c->binary_header.request.opaque;\n            /* clear the returned cas value */\n            c->cas = 0;\n\n            dispatch_bin_command(c);\n\n            c->rbytes -= sizeof(c->binary_header);\n            c->rcurr += sizeof(c->binary_header);\n        }\n    } else {\n        char *el, *cont, *left, lb;\n\n        if (c->rbytes == 0) {\n            return 0;\n        }\n\n        el = memchr(c->rcurr, '\\n', c->rbytes);\n        if (!el) {\n            if (c->rbytes > 1024) {\n                /*\n                 * We didn't have a '\\n' in the first k. This _has_ to be a\n                 * large multiget, if not we should just nuke the connection.\n                 */\n                char *ptr = c->rcurr;\n                while (*ptr == ' ') { /* ignore leading whitespaces */\n                    ++ptr;\n                }\n\n                if (ptr - c->rcurr > 100 ||\n                    (strncmp(ptr, \"get \", 4) && strncmp(ptr, \"gets \", 5))) {\n\n                    conn_set_state(c, conn_closing);\n                    return 1;\n                }\n            }\n\n            return 0;\n        }\n        cont = el + 1;\n        if ((el - c->rcurr) > 1 && *(el - 1) == '\\r') {\n            el--;\n        }\n        lb = *el;\n        *el = '\\0';\n\n        assert(cont <= (c->rcurr + c->rbytes));\n\n        LIBEVENT_THREAD *thread = c->thread;\n        LOCK_THREAD(thread);\n        left = process_command(c, c->rcurr);\n        if (c->ewouldblock) {\n            unregister_event(c);\n        }\n        UNLOCK_THREAD(thread);\n\n        if (left != NULL) {\n            /*\n             * We have not processed the entire command. This happens\n             * when the engine returns ENGINE_EWOULDBLOCK for one of the\n             * keys in a get/gets request.\n             */\n            assert (left <= el);\n\n            int count = strlen(c->rcurr);\n            if ((c->rcurr + count) == left) {\n                // Retry the entire command\n                cont = c->rcurr;\n            } else {\n                left -= (count + 1);\n                cont = left;\n                assert(cont >= c->rcurr);\n                if (cont > c->rcurr) {\n                    memmove(cont, c->rcurr, count);\n                }\n            }\n\n            /* de-tokenize the command */\n            while ((left = memchr(left, '\\0', el - left)) != NULL) {\n                *left = ' ';\n            }\n            *el = lb;\n        }\n\n        c->rbytes -= (cont - c->rcurr);\n        c->rcurr = cont;\n\n        assert(c->rcurr <= (c->rbuf + c->rsize));\n    }\n\n    return 1;\n}\n\n/*\n * read a UDP request.\n */\nstatic enum try_read_result try_read_udp(conn *c) {\n    int res;\n\n    assert(c != NULL);\n\n    c->request_addr_size = sizeof(c->request_addr);\n    res = recvfrom(c->sfd, c->rbuf, c->rsize,\n                   0, (struct sockaddr *)&c->request_addr, &c->request_addr_size);\n    if (res > 8) {\n        unsigned char *buf = (unsigned char *)c->rbuf;\n        STATS_ADD(c, bytes_read, res);\n\n        /* Beginning of UDP packet is the request ID; save it. */\n        c->request_id = buf[0] * 256 + buf[1];\n\n        /* If this is a multi-packet request, drop it. */\n        if (buf[4] != 0 || buf[5] != 1) {\n            out_string(c, \"SERVER_ERROR multi-packet request not supported\");\n            return READ_NO_DATA_RECEIVED;\n        }\n\n        /* Don't care about any of the rest of the header. */\n        res -= 8;\n        memmove(c->rbuf, c->rbuf + 8, res);\n\n        c->rbytes += res;\n        c->rcurr = c->rbuf;\n        return READ_DATA_RECEIVED;\n    }\n    return READ_NO_DATA_RECEIVED;\n}\n\n/*\n * read from network as much as we can, handle buffer overflow and connection\n * close.\n * before reading, move the remaining incomplete fragment of a command\n * (if any) to the beginning of the buffer.\n *\n * To protect us from someone flooding a connection with bogus data causing\n * the connection to eat up all available memory, break out and start looking\n * at the data I've got after a number of reallocs...\n *\n * @return enum try_read_result\n */\nstatic enum try_read_result try_read_network(conn *c) {\n    enum try_read_result gotdata = READ_NO_DATA_RECEIVED;\n    int res;\n    int num_allocs = 0;\n    assert(c != NULL);\n\n    if (c->rcurr != c->rbuf) {\n        if (c->rbytes != 0) /* otherwise there's nothing to copy */\n            memmove(c->rbuf, c->rcurr, c->rbytes);\n        c->rcurr = c->rbuf;\n    }\n\n    while (1) {\n        if (c->rbytes >= c->rsize) {\n            if (num_allocs == 4) {\n                return gotdata;\n            }\n            ++num_allocs;\n            char *new_rbuf = realloc(c->rbuf, c->rsize * 2);\n            if (!new_rbuf) {\n                if (settings.verbose > 0) {\n                 settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                          \"Couldn't realloc input buffer\\n\");\n                }\n                c->rbytes = 0; /* ignore what we read */\n                out_string(c, \"SERVER_ERROR out of memory reading request\");\n                c->write_and_go = conn_closing;\n                return READ_MEMORY_ERROR;\n            }\n            c->rcurr = c->rbuf = new_rbuf;\n            c->rsize *= 2;\n        }\n\n        int avail = c->rsize - c->rbytes;\n        res = recv(c->sfd, c->rbuf + c->rbytes, avail, 0);\n        if (res > 0) {\n            STATS_ADD(c, bytes_read, res);\n            gotdata = READ_DATA_RECEIVED;\n            c->rbytes += res;\n            if (res == avail) {\n                continue;\n            } else {\n                break;\n            }\n        }\n        if (res == 0) {\n            return READ_ERROR;\n        }\n        if (res == -1) {\n            if (errno == EAGAIN || errno == EWOULDBLOCK) {\n                break;\n            }\n            return READ_ERROR;\n        }\n    }\n    return gotdata;\n}\n\nbool register_event(conn *c, struct timeval *timeout) {\n#ifdef DEBUG\n    assert(!c->registered_in_libevent);\n#endif\n\n    if (event_add(&c->event, timeout) == -1) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING,\n                                        NULL,\n                                        \"Failed to add connection to libevent: %s\",\n                                        strerror(errno));\n        return false;\n    }\n\n#ifdef DEBUG\n    c->registered_in_libevent = true;\n#endif\n\n    return true;\n}\n\nbool unregister_event(conn *c) {\n#ifdef DEBUG\n    assert(c->registered_in_libevent);\n#endif\n\n    if (event_del(&c->event) == -1) {\n        return false;\n    }\n\n#ifdef DEBUG\n    c->registered_in_libevent = false;\n#endif\n\n    return true;\n}\n\n\nbool update_event(conn *c, const int new_flags) {\n    assert(c != NULL);\n\n    struct event_base *base = c->event.ev_base;\n    if (c->ev_flags == new_flags)\n        return true;\n\n    settings.extensions.logger->log(EXTENSION_LOG_DEBUG, NULL,\n                                    \"Updated event for %d to read=%s, write=%s\\n\",\n                                    c->sfd, (new_flags & EV_READ ? \"yes\" : \"no\"),\n                                    (new_flags & EV_WRITE ? \"yes\" : \"no\"));\n\n    if (!unregister_event(c)) {\n        return false;\n    }\n\n    event_set(&c->event, c->sfd, new_flags, event_handler, (void *)c);\n    event_base_set(base, &c->event);\n    c->ev_flags = new_flags;\n\n    return register_event(c, NULL);\n}\n\n/*\n * Transmit the next chunk of data from our list of msgbuf structures.\n *\n * Returns:\n *   TRANSMIT_COMPLETE   All done writing.\n *   TRANSMIT_INCOMPLETE More data remaining to write.\n *   TRANSMIT_SOFT_ERROR Can't write any more right now.\n *   TRANSMIT_HARD_ERROR Can't write (c->state is set to conn_closing)\n */\nstatic enum transmit_result transmit(conn *c) {\n    assert(c != NULL);\n\n    if (c->msgcurr < c->msgused &&\n            c->msglist[c->msgcurr].msg_iovlen == 0) {\n        /* Finished writing the current msg; advance to the next. */\n        c->msgcurr++;\n    }\n    if (c->msgcurr < c->msgused) {\n        ssize_t res;\n        struct msghdr *m = &c->msglist[c->msgcurr];\n\n        res = sendmsg(c->sfd, m, 0);\n        if (res > 0) {\n            STATS_ADD(c, bytes_written, res);\n\n            /* We've written some of the data. Remove the completed\n               iovec entries from the list of pending writes. */\n            while (m->msg_iovlen > 0 && res >= m->msg_iov->iov_len) {\n                res -= m->msg_iov->iov_len;\n                m->msg_iovlen--;\n                m->msg_iov++;\n            }\n\n            /* Might have written just part of the last iovec entry;\n               adjust it so the next write will do the rest. */\n            if (res > 0) {\n                m->msg_iov->iov_base = (caddr_t)m->msg_iov->iov_base + res;\n                m->msg_iov->iov_len -= res;\n            }\n            return TRANSMIT_INCOMPLETE;\n        }\n        if (res == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n            if (!update_event(c, EV_WRITE | EV_PERSIST)) {\n                if (settings.verbose > 0) {\n                    settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                            \"Couldn't update event\\n\");\n                }\n                conn_set_state(c, conn_closing);\n                return TRANSMIT_HARD_ERROR;\n            }\n            return TRANSMIT_SOFT_ERROR;\n        }\n        /* if res == 0 or res == -1 and error is not EAGAIN or EWOULDBLOCK,\n           we have a real error, on which we close the connection */\n        if (settings.verbose > 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                            \"Failed to write, and not due to blocking: %s\",\n                                            strerror(errno));\n        }\n\n        if (IS_UDP(c->transport))\n            conn_set_state(c, conn_read);\n        else\n            conn_set_state(c, conn_closing);\n        return TRANSMIT_HARD_ERROR;\n    } else {\n        return TRANSMIT_COMPLETE;\n    }\n}\n\nbool conn_listening(conn *c)\n{\n    int sfd;\n    struct sockaddr_storage addr;\n    socklen_t addrlen = sizeof(addr);\n\n    if ((sfd = accept(c->sfd, (struct sockaddr *)&addr, &addrlen)) == -1) {\n        if (errno == EMFILE) {\n            if (settings.verbose > 0) {\n                settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                                                \"Too many open connections\\n\");\n            }\n            disable_listen();\n        } else if (errno != EAGAIN && errno != EWOULDBLOCK) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                            \"Failed to accept new client: %s\\n\",\n                                            strerror(errno));\n        }\n\n        return false;\n    }\n\n    STATS_LOCK();\n    int curr_conns = ++stats.curr_conns;\n    STATS_UNLOCK();\n\n    if (curr_conns >= settings.maxconns) {\n        STATS_LOCK();\n        ++stats.rejected_conns;\n        STATS_UNLOCK();\n\n        if (settings.verbose > 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                                            \"Too many open connections\\n\");\n        }\n\n        safe_close(sfd);\n        return false;\n    }\n\n    if (evutil_make_socket_nonblocking(sfd) == -1) {\n        safe_close(sfd);\n        return false;\n    }\n\n    dispatch_conn_new(sfd, conn_new_cmd, EV_READ | EV_PERSIST,\n                      DATA_BUFFER_SIZE, tcp_transport);\n\n    return false;\n}\n\n/**\n * Ship tap log to the other end. This state differs with all other states\n * in the way that it support full duplex dialog. We're listening to both read\n * and write events from libevent most of the time. If a read event occurs we\n * switch to the conn_read state to read and execute the input message (that would\n * be an ack message from the other side). If a write event occurs we continue to\n * send tap log to the other end.\n * @param c the tap connection to drive\n * @return true if we should continue to process work for this connection, false\n *              if we should start processing events for other connections.\n */\nbool conn_ship_log(conn *c) {\n    bool cont = false;\n\n    if (c->sfd == INVALID_SOCKET) {\n        return false;\n    }\n\n    short mask = EV_READ | EV_PERSIST | EV_WRITE;\n\n    if (c->which & EV_READ || c->rbytes > 0) {\n        if (c->rbytes > 0) {\n            if (try_read_command(c) == 0) {\n                conn_set_state(c, conn_read);\n            }\n        } else {\n            conn_set_state(c, conn_read);\n        }\n\n        // we're going to process something.. let's proceed\n        cont = true;\n\n        // We have a finite number of messages in the input queue\n        // so let's process all of them instead of backing off after\n        // reading a subset of them.\n        // Why? Because we've got every time we're calling ship_tap_log\n        // we try to send a chunk of items.. This means that if we end\n        // up in a situation where we're receiving a burst of nack messages\n        // we'll only process a subset of messages in our input queue,\n        // and it will slowly grow..\n        c->nevents = settings.reqs_per_tap_event;\n    } else if (c->which & EV_WRITE) {\n        --c->nevents;\n        if (c->nevents >= 0) {\n            LOCK_THREAD(c->thread);\n            c->ewouldblock = false;\n            ship_tap_log(c);\n            if (c->ewouldblock) {\n                mask = EV_READ | EV_PERSIST;\n            } else {\n                cont = true;\n            }\n            UNLOCK_THREAD(c->thread);\n        }\n    }\n\n    if (!update_event(c, mask)) {\n        if (settings.verbose > 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_INFO,\n                                            c, \"Couldn't update event\\n\");\n        }\n        conn_set_state(c, conn_closing);\n    }\n\n    return cont;\n}\n\nbool conn_waiting(conn *c) {\n    if (!update_event(c, EV_READ | EV_PERSIST)) {\n        if (settings.verbose > 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                                            \"Couldn't update event\\n\");\n        }\n        conn_set_state(c, conn_closing);\n        return true;\n    }\n    conn_set_state(c, conn_read);\n    return false;\n}\n\nbool conn_read(conn *c) {\n    int res = IS_UDP(c->transport) ? try_read_udp(c) : try_read_network(c);\n    switch (res) {\n    case READ_NO_DATA_RECEIVED:\n        conn_set_state(c, conn_waiting);\n        break;\n    case READ_DATA_RECEIVED:\n        conn_set_state(c, conn_parse_cmd);\n        break;\n    case READ_ERROR:\n        conn_set_state(c, conn_closing);\n        break;\n    case READ_MEMORY_ERROR: /* Failed to allocate more memory */\n        /* State already set by try_read_network */\n        break;\n    }\n\n    return true;\n}\n\nbool conn_parse_cmd(conn *c) {\n    if (try_read_command(c) == 0) {\n        /* wee need more data! */\n        conn_set_state(c, conn_waiting);\n    }\n\n    return !c->ewouldblock;\n}\n\nbool conn_new_cmd(conn *c) {\n    /* Only process nreqs at a time to avoid starving other connections */\n    --c->nevents;\n    if (c->nevents >= 0) {\n        reset_cmd_handler(c);\n    } else {\n        STATS_NOKEY(c, conn_yields);\n        if (c->rbytes > 0) {\n            /* We have already read in data into the input buffer,\n               so libevent will most likely not signal read events\n               on the socket (unless more data is available. As a\n               hack we should just put in a request to write data,\n               because that should be possible ;-)\n            */\n            if (!update_event(c, EV_WRITE | EV_PERSIST)) {\n                if (settings.verbose > 0) {\n                    settings.extensions.logger->log(EXTENSION_LOG_INFO,\n                                                    c, \"Couldn't update event\\n\");\n                }\n                conn_set_state(c, conn_closing);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    return true;\n}\n\n\nbool conn_swallow(conn *c) {\n    ssize_t res;\n    /* we are reading sbytes and throwing them away */\n    if (c->sbytes == 0) {\n        conn_set_state(c, conn_new_cmd);\n        return true;\n    }\n\n    /* first check if we have leftovers in the conn_read buffer */\n    if (c->rbytes > 0) {\n        uint32_t tocopy = c->rbytes > c->sbytes ? c->sbytes : c->rbytes;\n        c->sbytes -= tocopy;\n        c->rcurr += tocopy;\n        c->rbytes -= tocopy;\n        return true;\n    }\n\n    /*  now try reading from the socket */\n    res = recv(c->sfd, c->rbuf, c->rsize > c->sbytes ? c->sbytes : c->rsize, 0);\n    if (res > 0) {\n        STATS_ADD(c, bytes_read, res);\n        c->sbytes -= res;\n        return true;\n    }\n    if (res == 0) { /* end of stream */\n        conn_set_state(c, conn_closing);\n        return true;\n    }\n    if (res == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n        if (!update_event(c, EV_READ | EV_PERSIST)) {\n            if (settings.verbose > 0) {\n                settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                                                \"Couldn't update event\\n\");\n            }\n            conn_set_state(c, conn_closing);\n            return true;\n        }\n        return false;\n    }\n\n    if (errno != ENOTCONN && errno != ECONNRESET) {\n        /* otherwise we have a real error, on which we close the connection */\n        settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                                        \"Failed to read, and not due to blocking (%s)\\n\",\n                                        strerror(errno));\n    }\n\n    conn_set_state(c, conn_closing);\n\n    return true;\n\n}\n\nbool conn_nread(conn *c) {\n    ssize_t res;\n\n    if (c->rlbytes == 0) {\n        LIBEVENT_THREAD *t = c->thread;\n        LOCK_THREAD(t);\n        bool block = c->ewouldblock = false;\n        complete_nread(c);\n        UNLOCK_THREAD(t);\n        /* Breaking this into two, as complete_nread may have\n           moved us to a different thread */\n        t = c->thread;\n        LOCK_THREAD(t);\n        if (c->ewouldblock) {\n            unregister_event(c);\n            block = true;\n        }\n        UNLOCK_THREAD(t);\n        return !block;\n    }\n    /* first check if we have leftovers in the conn_read buffer */\n    if (c->rbytes > 0) {\n        uint32_t tocopy = c->rbytes > c->rlbytes ? c->rlbytes : c->rbytes;\n        if (c->ritem != c->rcurr) {\n            memmove(c->ritem, c->rcurr, tocopy);\n        }\n        c->ritem += tocopy;\n        c->rlbytes -= tocopy;\n        c->rcurr += tocopy;\n        c->rbytes -= tocopy;\n        if (c->rlbytes == 0) {\n            return true;\n        }\n    }\n\n    /*  now try reading from the socket */\n    res = recv(c->sfd, c->ritem, c->rlbytes, 0);\n    if (res > 0) {\n        STATS_ADD(c, bytes_read, res);\n        if (c->rcurr == c->ritem) {\n            c->rcurr += res;\n        }\n        c->ritem += res;\n        c->rlbytes -= res;\n        return true;\n    }\n    if (res == 0) { /* end of stream */\n        conn_set_state(c, conn_closing);\n        return true;\n    }\n\n#ifdef INNODB_MEMCACHED\n    /* MEMCACHED_RESOLVE: on solaris platform, when connect through\n    telnet and waiting for input from an \"add\" or \"set\" command,\n    it could have res == -1 and errno == 0. Thus causing early termination\n    Add \"!errno\" condition here to deal with this scenario for now */\n    if (res == -1 && (errno == EAGAIN || errno == EWOULDBLOCK || !errno)) {\n#else\n    if (res == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) {\n#endif /* INNODB_MEMCACHED */\n        if (!update_event(c, EV_READ | EV_PERSIST)) {\n            if (settings.verbose > 0) {\n                settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                                                \"Couldn't update event\\n\");\n            }\n            conn_set_state(c, conn_closing);\n            return true;\n        }\n        return false;\n    }\n\n    if (errno != ENOTCONN && errno != ECONNRESET) {\n        /* otherwise we have a real error, on which we close the connection */\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                                        \"Failed to read, and not due to blocking:\\n\"\n                                        \"errno: %d %s \\n\"\n                                        \"rcurr=%lx ritem=%lx rbuf=%lx rlbytes=%d rsize=%d\\n\",\n                                        errno, strerror(errno),\n                                        (long)c->rcurr, (long)c->ritem, (long)c->rbuf,\n                                        (int)c->rlbytes, (int)c->rsize);\n    }\n    conn_set_state(c, conn_closing);\n    return true;\n}\n\nbool conn_write(conn *c) {\n    /*\n     * We want to write out a simple response. If we haven't already,\n     * assemble it into a msgbuf list (this will be a single-entry\n     * list for TCP or a two-entry list for UDP).\n     */\n    if (c->iovused == 0 || (IS_UDP(c->transport) && c->iovused == 1)) {\n        if (add_iov(c, c->wcurr, c->wbytes) != 0) {\n            if (settings.verbose > 0) {\n                settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                                                \"Couldn't build response\\n\");\n            }\n            conn_set_state(c, conn_closing);\n            return true;\n        }\n    }\n\n    return conn_mwrite(c);\n}\n\nbool conn_mwrite(conn *c) {\n    if (IS_UDP(c->transport) && c->msgcurr == 0 && build_udp_headers(c) != 0) {\n        if (settings.verbose > 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                                            \"Failed to build UDP headers\\n\");\n        }\n        conn_set_state(c, conn_closing);\n        return true;\n    }\n\n    switch (transmit(c)) {\n    case TRANSMIT_COMPLETE:\n        if (c->state == conn_mwrite) {\n            while (c->ileft > 0) {\n                item *it = *(c->icurr);\n                settings.engine.v1->release(settings.engine.v0, c, it);\n                c->icurr++;\n                c->ileft--;\n            }\n            while (c->suffixleft > 0) {\n                char *suffix = *(c->suffixcurr);\n                cache_free(c->thread->suffix_cache, suffix);\n                c->suffixcurr++;\n                c->suffixleft--;\n            }\n            /* XXX:  I don't know why this wasn't the general case */\n            if(c->protocol == binary_prot) {\n                conn_set_state(c, c->write_and_go);\n            } else {\n                conn_set_state(c, conn_new_cmd);\n            }\n        } else if (c->state == conn_write) {\n            if (c->write_and_free) {\n                free(c->write_and_free);\n                c->write_and_free = 0;\n            }\n            conn_set_state(c, c->write_and_go);\n        } else {\n            if (settings.verbose > 0) {\n                settings.extensions.logger->log(EXTENSION_LOG_INFO, c,\n                                                \"Unexpected state %d\\n\", c->state);\n            }\n            conn_set_state(c, conn_closing);\n        }\n        break;\n\n    case TRANSMIT_INCOMPLETE:\n    case TRANSMIT_HARD_ERROR:\n        break;                   /* Continue in state machine. */\n\n    case TRANSMIT_SOFT_ERROR:\n        return false;\n    }\n\n    return true;\n}\n\nbool conn_pending_close(conn *c) {\n    assert(c->sfd == INVALID_SOCKET);\n    settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                    \"Awaiting clients to release the cookie (pending close for %p)\",\n                                    (void*)c);\n    LOCK_THREAD(c->thread);\n    c->thread->pending_io = list_remove(c->thread->pending_io, c);\n    if (!list_contains(c->thread->pending_close, c)) {\n        enlist_conn(c, &c->thread->pending_close);\n    }\n    UNLOCK_THREAD(c->thread);\n\n    /*\n     * tell the tap connection that we're disconnecting it now,\n     * but give it a grace period\n     */\n    perform_callbacks(ON_DISCONNECT, NULL, c);\n\n    /*\n     * disconnect callback may have changed the state for the object\n     * so we might complete the disconnect now\n     */\n    return c->state != conn_pending_close;\n}\n\nbool conn_immediate_close(conn *c) {\n    settings.extensions.logger->log(EXTENSION_LOG_DETAIL, c,\n                                    \"Immediate close of %p\",\n                                    (void*)c);\n    perform_callbacks(ON_DISCONNECT, NULL, c);\n    conn_close(c);\n\n    return false;\n}\n\nbool conn_closing(conn *c) {\n    if (IS_UDP(c->transport)) {\n        conn_cleanup(c);\n        return false;\n    }\n\n    // We don't want any network notifications anymore..\n    unregister_event(c);\n    safe_close(c->sfd);\n    c->sfd = INVALID_SOCKET;\n\n    if (c->refcount > 1) {\n        conn_set_state(c, conn_pending_close);\n    } else {\n        conn_set_state(c, conn_immediate_close);\n    }\n    return true;\n}\n\nbool conn_add_tap_client(conn *c) {\n    LIBEVENT_THREAD *tp = tap_thread;\n    LIBEVENT_THREAD *orig_thread = c->thread;\n\n    assert(orig_thread);\n    assert(orig_thread != tp);\n\n    c->ewouldblock = true;\n\n    unregister_event(c);\n\n    LOCK_THREAD(orig_thread);\n    /* Clean out the lists */\n    orig_thread->pending_io = list_remove(orig_thread->pending_io, c);\n    orig_thread->pending_close = list_remove(orig_thread->pending_close, c);\n\n    LOCK_THREAD(tp);\n    c->ev_flags = 0;\n    conn_set_state(c, conn_setup_tap_stream);\n    settings.extensions.logger->log(EXTENSION_LOG_DEBUG, NULL,\n                                    \"Moving %d conn from %p to %p\\n\",\n                                    c->sfd, c->thread, tp);\n    c->thread = tp;\n    c->event.ev_base = tp->base;\n    assert(c->next == NULL);\n    assert(c->list_state == 0);\n    enlist_conn(c, &tp->pending_io);\n\n    UNLOCK_THREAD(tp);\n\n    UNLOCK_THREAD(orig_thread);\n\n    notify_thread(tp);\n\n    return false;\n}\n\nbool conn_setup_tap_stream(conn *c) {\n    process_bin_tap_connect(c);\n    return true;\n}\n\nvoid event_handler(const int fd, const short which, void *arg) {\n    conn *c;\n\n    c = (conn *)arg;\n    assert(c != NULL);\n\n    if (memcached_shutdown) {\n        event_base_loopbreak(c->event.ev_base);\n        return ;\n    }\n\n    c->which = which;\n\n    /* sanity */\n    if (fd != c->sfd) {\n        if (settings.verbose > 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, c,\n                    \"Catastrophic: event fd doesn't match conn fd!\\n\");\n        }\n        conn_close(c);\n        return;\n    }\n\n    perform_callbacks(ON_SWITCH_CONN, c, c);\n\n    c->nevents = settings.reqs_per_event;\n    if (c->state == conn_ship_log) {\n        c->nevents = settings.reqs_per_tap_event;\n    }\n\n    LIBEVENT_THREAD *thr = c->thread;\n\n    // Do we have pending closes?\n    const size_t max_items = 256;\n    conn *pending_close[max_items];\n    size_t n_pending_close = 0;\n    if (thr != NULL) {\n        LOCK_THREAD(thr);\n        if (thr->pending_close && thr->last_checked != current_time) {\n            assert(!has_cycle(thr->pending_close));\n            thr->last_checked = current_time;\n\n            n_pending_close = list_to_array(pending_close, max_items,\n                                            &thr->pending_close);\n        }\n        UNLOCK_THREAD(thr);\n    }\n\n    if (settings.verbose) {\n        do {\n            settings.extensions.logger->log(EXTENSION_LOG_DEBUG, c,\n                                            \"%d - Running task: (%s)\\n\",\n                                            c->sfd, state_text(c->state));\n        } while (c->state(c));\n    } else {\n        while (c->state(c)) {\n            /* empty */\n        }\n    }\n\n    /* Close any connections pending close */\n    if (n_pending_close > 0) {\n        for (size_t i = 0; i < n_pending_close; ++i) {\n            conn *ce = pending_close[i];\n            if (ce->refcount == 1) {\n                settings.extensions.logger->log(EXTENSION_LOG_DEBUG, NULL,\n                                                \"OK, time to nuke: %p\\n\",\n                                                (void*)ce);\n                conn_close(ce);\n            } else {\n                LOCK_THREAD(ce->thread);\n                enlist_conn(ce, &ce->thread->pending_close);\n                UNLOCK_THREAD(ce->thread);\n            }\n        }\n    }\n\n    if (thr != NULL) {\n        LOCK_THREAD(thr);\n        finalize_list(pending_close, n_pending_close);\n        UNLOCK_THREAD(thr);\n    }\n}\n\nstatic void dispatch_event_handler(int fd, short which, void *arg) {\n    char buffer[80];\n    ssize_t nr = recv(fd, buffer, sizeof(buffer), 0);\n\n    if (nr != -1 && is_listen_disabled()) {\n        bool enable = false;\n        pthread_mutex_lock(&listen_state.mutex);\n        listen_state.count -= nr;\n        if (listen_state.count <= 0) {\n            enable = true;\n            listen_state.disabled = false;\n        }\n        pthread_mutex_unlock(&listen_state.mutex);\n        if (enable) {\n            conn *next;\n            for (next = listen_conn; next; next = next->next) {\n                update_event(next, EV_READ | EV_PERSIST);\n                if (listen(next->sfd, settings.backlog) != 0) {\n                    settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                                    \"listen() failed\",\n                                                    strerror(errno));\n                }\n            }\n        }\n    }\n}\n\n\n\nstatic SOCKET new_socket(struct addrinfo *ai) {\n    SOCKET sfd;\n\n    sfd = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);\n    if (sfd == INVALID_SOCKET) {\n        return INVALID_SOCKET;\n    }\n\n    if (evutil_make_socket_nonblocking(sfd) == -1) {\n        safe_close(sfd);\n        return INVALID_SOCKET;\n    }\n\n    return sfd;\n}\n\n\n/*\n * Sets a socket's send buffer size to the maximum allowed by the system.\n */\nstatic void maximize_sndbuf(const int sfd) {\n    socklen_t intsize = sizeof(int);\n    int last_good = 0;\n    int min, max, avg;\n    int old_size;\n\n    /* Start with the default size. */\n    if (getsockopt(sfd, SOL_SOCKET, SO_SNDBUF, (void *)&old_size, &intsize) != 0) {\n        if (settings.verbose > 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                            \"getsockopt(SO_SNDBUF): %s\",\n                                            strerror(errno));\n        }\n\n        return;\n    }\n\n    /* Binary-search for the real maximum. */\n    min = old_size;\n    max = MAX_SENDBUF_SIZE;\n\n    while (min <= max) {\n        avg = ((unsigned int)(min + max)) / 2;\n        if (setsockopt(sfd, SOL_SOCKET, SO_SNDBUF, (void *)&avg, intsize) == 0) {\n            last_good = avg;\n            min = avg + 1;\n        } else {\n            max = avg - 1;\n        }\n    }\n\n    if (settings.verbose > 1) {\n        settings.extensions.logger->log(EXTENSION_LOG_DEBUG, NULL,\n                 \"<%d send buffer was %d, now %d\\n\", sfd, old_size, last_good);\n    }\n}\n\n\n\n/**\n * Create a socket and bind it to a specific port number\n * @param interface the interface to bind to\n * @param port the port number to bind to\n * @param transport the transport protocol (TCP / UDP)\n * @param portnumber_file A filepointer to write the port numbers to\n *        when they are successfully added to the list of ports we\n *        listen on.\n */\nstatic int server_socket(const char *interface,\n                         int port,\n                         enum network_transport transport,\n                         FILE *portnumber_file) {\n    int sfd;\n    struct linger ling = {0, 0};\n    struct addrinfo *ai;\n    struct addrinfo *next;\n    struct addrinfo hints = { .ai_flags = AI_PASSIVE,\n                              .ai_family = AF_UNSPEC };\n    char port_buf[NI_MAXSERV];\n    int error;\n    int success = 0;\n    int flags =1;\n    num_udp_socket = 0;\n\n    hints.ai_socktype = IS_UDP(transport) ? SOCK_DGRAM : SOCK_STREAM;\n\n    if (port == -1) {\n        port = 0;\n    }\n    snprintf(port_buf, sizeof(port_buf), \"%d\", port);\n    error= getaddrinfo(interface, port_buf, &hints, &ai);\n    if (error != 0) {\n        if (error != EAI_SYSTEM) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                     \"getaddrinfo(): %s\\n\", gai_strerror(error));\n        } else {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                     \"getaddrinfo(): %s\\n\", strerror(error));\n        }\n        return 1;\n    }\n\n    for (next= ai; next; next= next->ai_next) {\n        conn *listen_conn_add;\n        if ((sfd = new_socket(next)) == INVALID_SOCKET) {\n            /* getaddrinfo can return \"junk\" addresses,\n             * we make sure at least one works before erroring.\n             */\n            continue;\n        }\n\n#ifdef IPV6_V6ONLY\n        if (next->ai_family == AF_INET6) {\n            error = setsockopt(sfd, IPPROTO_IPV6, IPV6_V6ONLY, (char *) &flags, sizeof(flags));\n            if (error != 0) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                                \"setsockopt(IPV6_V6ONLY): %s\",\n                                                strerror(errno));\n                safe_close(sfd);\n                continue;\n            }\n        }\n#endif\n\n        setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flags, sizeof(flags));\n        if (IS_UDP(transport)) {\n            maximize_sndbuf(sfd);\n\t    udp_socket[num_udp_socket] = sfd;\n\t    num_udp_socket++;\n        } else {\n            error = setsockopt(sfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flags, sizeof(flags));\n            if (error != 0) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                                \"setsockopt(SO_KEEPALIVE): %s\",\n                                                strerror(errno));\n            }\n\n            error = setsockopt(sfd, SOL_SOCKET, SO_LINGER, (void *)&ling, sizeof(ling));\n            if (error != 0) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                                \"setsockopt(SO_LINGER): %s\",\n                                                strerror(errno));\n            }\n\n            error = setsockopt(sfd, IPPROTO_TCP, TCP_NODELAY, (void *)&flags, sizeof(flags));\n            if (error != 0) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                                \"setsockopt(TCP_NODELAY): %s\",\n                                                strerror(errno));\n            }\n        }\n\n        if (bind(sfd, next->ai_addr, next->ai_addrlen) == SOCKET_ERROR) {\n            if (errno != EADDRINUSE) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                                \"bind(): %s\",\n                                                strerror(errno));\n                safe_close(sfd);\n                freeaddrinfo(ai);\n                return 1;\n            }\n            safe_close(sfd);\n            continue;\n        } else {\n            success++;\n            if (!IS_UDP(transport) && listen(sfd, settings.backlog) == SOCKET_ERROR) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                                \"listen(): %s\",\n                                                strerror(errno));\n                safe_close(sfd);\n                freeaddrinfo(ai);\n                return 1;\n            }\n            if (portnumber_file != NULL &&\n                (next->ai_addr->sa_family == AF_INET ||\n                 next->ai_addr->sa_family == AF_INET6)) {\n                union {\n                    struct sockaddr_in in;\n                    struct sockaddr_in6 in6;\n                } my_sockaddr;\n                socklen_t len = sizeof(my_sockaddr);\n                if (getsockname(sfd, (struct sockaddr*)&my_sockaddr, &len)==0) {\n                    if (next->ai_addr->sa_family == AF_INET) {\n                        fprintf(portnumber_file, \"%s INET: %u\\n\",\n                                IS_UDP(transport) ? \"UDP\" : \"TCP\",\n                                ntohs(my_sockaddr.in.sin_port));\n                    } else {\n                        fprintf(portnumber_file, \"%s INET6: %u\\n\",\n                                IS_UDP(transport) ? \"UDP\" : \"TCP\",\n                                ntohs(my_sockaddr.in6.sin6_port));\n                    }\n                }\n            }\n        }\n\n        if (IS_UDP(transport)) {\n            int c;\n\n            for (c = 0; c < settings.num_threads_per_udp; c++) {\n                /* this is guaranteed to hit all threads because we round-robin */\n                dispatch_conn_new(sfd, conn_read, EV_READ | EV_PERSIST,\n                                  UDP_READ_BUFFER_SIZE, transport);\n                STATS_LOCK();\n                ++stats.curr_conns;\n                ++stats.daemon_conns;\n                STATS_UNLOCK();\n            }\n        } else {\n            if (!(listen_conn_add = conn_new(sfd, conn_listening,\n                                             EV_READ | EV_PERSIST, 1,\n                                             transport, main_base, NULL))) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                        \"failed to create listening connection\\n\");\n                exit(EXIT_FAILURE);\n            }\n            listen_conn_add->next = listen_conn;\n            listen_conn = listen_conn_add;\n            STATS_LOCK();\n            ++stats.curr_conns;\n            ++stats.daemon_conns;\n            STATS_UNLOCK();\n        }\n    }\n\n    freeaddrinfo(ai);\n\n    /* Return zero iff we detected no errors in starting up connections */\n    return success == 0;\n}\n\nstatic int server_sockets(int port, enum network_transport transport,\n                          FILE *portnumber_file) {\n    if (settings.inter == NULL) {\n        return server_socket(settings.inter, port, transport, portnumber_file);\n    } else {\n        // tokenize them and bind to each one of them..\n        char *b;\n        int ret = 0;\n        char *list = strdup(settings.inter);\n\n        if (list == NULL) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                            \"Failed to allocate memory for parsing server interface string\\n\");\n            return 1;\n        }\n        for (char *p = strtok_r(list, \";,\", &b);\n             p != NULL;\n             p = strtok_r(NULL, \";,\", &b)) {\n            int the_port = port;\n\n            char *s = strchr(p, ':');\n            if (s != NULL) {\n                *s = '\\0';\n                ++s;\n                if (!safe_strtol(s, &the_port)) {\n                    settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                                    \"Invalid port number: \\\"%s\\\"\", s);\n                    return 1;\n                }\n            }\n            if (strcmp(p, \"*\") == 0) {\n                p = NULL;\n            }\n            ret |= server_socket(p, the_port, transport, portnumber_file);\n        }\n        free(list);\n        return ret;\n    }\n}\n\nstatic int new_socket_unix(void) {\n    int sfd;\n\n    if ((sfd = socket(AF_UNIX, SOCK_STREAM, 0)) == INVALID_SOCKET) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                        \"socket(AF_UNIX, SOCK_STREAM, 0): %s\",\n                                        strerror(errno));\n        return INVALID_SOCKET;\n    }\n\n    if (evutil_make_socket_nonblocking(sfd) == -1) {\n        safe_close(sfd);\n        return INVALID_SOCKET;\n    }\n    return sfd;\n}\n\n/* this will probably not work on windows */\nstatic int server_socket_unix(const char *path, int access_mask) {\n    int sfd;\n    struct linger ling = {0, 0};\n    struct sockaddr_un addr;\n    struct stat tstat;\n    int flags =1;\n    int old_umask;\n\n    if (!path) {\n        return 1;\n    }\n\n    if ((sfd = new_socket_unix()) == -1) {\n        return 1;\n    }\n\n    /*\n     * Clean up a previous socket file if we left it around\n     */\n    if (lstat(path, &tstat) == 0) {\n        if (S_ISSOCK(tstat.st_mode))\n            unlink(path);\n    }\n\n    setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void *)&flags, sizeof(flags));\n    setsockopt(sfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flags, sizeof(flags));\n    setsockopt(sfd, SOL_SOCKET, SO_LINGER, (void *)&ling, sizeof(ling));\n\n    /*\n     * the memset call clears nonstandard fields in some impementations\n     * that otherwise mess things up.\n     */\n    memset(&addr, 0, sizeof(addr));\n\n    addr.sun_family = AF_UNIX;\n    strncpy(addr.sun_path, path, sizeof(addr.sun_path) - 1);\n    assert(strcmp(addr.sun_path, path) == 0);\n    old_umask = umask( ~(access_mask&0777));\n    if (bind(sfd, (struct sockaddr *)&addr, sizeof(addr)) == -1) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                        \"bind(): %s\",\n                                        strerror(errno));\n        safe_close(sfd);\n        umask(old_umask);\n        return 1;\n    }\n    umask(old_umask);\n    if (listen(sfd, settings.backlog) == -1) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                        \"listen(): %s\",\n                                        strerror(errno));\n        safe_close(sfd);\n        return 1;\n    }\n    if (!(listen_conn = conn_new(sfd, conn_listening,\n                                 EV_READ | EV_PERSIST, 1,\n                                 local_transport, main_base, NULL))) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                 \"failed to create listening connection\\n\");\n        exit(EXIT_FAILURE);\n    }\n    STATS_LOCK();\n    ++stats.daemon_conns;\n    STATS_UNLOCK();\n\n    return 0;\n}\n\nstatic struct event clockevent;\n\n/* time-sensitive callers can call it by hand with this, outside the normal ever-1-second timer */\nstatic void set_current_time(void) {\n    struct timeval timer;\n\n    gettimeofday(&timer, NULL);\n    current_time = (rel_time_t) (timer.tv_sec - process_started);\n}\n\nstatic void clock_handler(const int fd, const short which, void *arg) {\n    struct timeval t = {.tv_sec = 1, .tv_usec = 0};\n    static bool initialized = false;\n\n    if (memcached_shutdown) {\n        event_base_loopbreak(main_base);\n        return ;\n    }\n\n    if (initialized) {\n        /* only delete the event if it's actually there. */\n        evtimer_del(&clockevent);\n    } else {\n        initialized = true;\n    }\n\n    evtimer_set(&clockevent, clock_handler, 0);\n    event_base_set(main_base, &clockevent);\n    evtimer_add(&clockevent, &t);\n\n    set_current_time();\n}\n\nstatic void usage(void) {\n    printf(PACKAGE \" \" VERSION \"\\n\");\n    printf(\"-p <num>      TCP port number to listen on (default: 11211)\\n\"\n           \"-U <num>      UDP port number to listen on (default: 11211, 0 is off)\\n\"\n           \"-s <file>     UNIX socket path to listen on (disables network support)\\n\"\n           \"-a <mask>     access mask for UNIX socket, in octal (default: 0700)\\n\"\n           \"-l <addr>     interface to listen on (default: INADDR_ANY, all addresses)\\n\"\n           \"              <addr> may be specified as host:port. If you don't specify\\n\"\n           \"              a port number, the value you specified with -p or -U is\\n\"\n           \"              used. You may specify multiple addresses separated by comma\\n\"\n           \"              or by using -l multiple times\\n\"\n           \"-d            run as a daemon\\n\"\n           \"-r            maximize core file limit\\n\"\n           \"-u <username> assume identity of <username> (only when run as root)\\n\"\n           \"-m <num>      max memory to use for items in megabytes (default: 64 MB)\\n\"\n           \"-M            return error on memory exhausted (rather than removing items)\\n\"\n           \"-c <num>      max simultaneous connections (default: 1000)\\n\"\n           \"-k            lock down all paged memory.  Note that there is a\\n\"\n           \"              limit on how much memory you may lock.  Trying to\\n\"\n           \"              allocate more than that would fail, so be sure you\\n\"\n           \"              set the limit correctly for the user you started\\n\"\n           \"              the daemon with (not for -u <username> user;\\n\"\n           \"              under sh this is done with 'ulimit -S -l NUM_KB').\\n\"\n           \"-v            verbose (print errors/warnings while in event loop)\\n\"\n           \"-vv           very verbose (also print client commands/reponses)\\n\"\n           \"-vvv          extremely verbose (also print internal state transitions)\\n\"\n           \"-h            print this help and exit\\n\"\n           \"-i            print memcached and libevent license\\n\"\n           \"-P <file>     save PID in <file>, only used with -d option\\n\"\n           \"-f <factor>   chunk size growth factor (default: 1.25)\\n\"\n           \"-n <bytes>    minimum space allocated for key+value+flags (default: 48)\\n\");\n    printf(\"-L            Try to use large memory pages (if available). Increasing\\n\"\n           \"              the memory page size could reduce the number of TLB misses\\n\"\n           \"              and improve the performance. In order to get large pages\\n\"\n           \"              from the OS, memcached will allocate the total item-cache\\n\"\n           \"              in one large chunk.\\n\");\n    printf(\"-D <char>     Use <char> as the delimiter between key prefixes and IDs.\\n\"\n           \"              This is used for per-prefix stats reporting. The default is\\n\"\n           \"              \\\":\\\" (colon). If this option is specified, stats collection\\n\"\n           \"              is turned on automatically; if not, then it may be turned on\\n\"\n           \"              by sending the \\\"stats detail on\\\" command to the server.\\n\");\n    printf(\"-t <num>      number of threads to use (default: 4)\\n\");\n    printf(\"-R            Maximum number of requests per event, limits the number of\\n\"\n           \"              requests process for a given connection to prevent \\n\"\n           \"              starvation (default: 20)\\n\");\n    printf(\"-C            Disable use of CAS\\n\");\n    printf(\"-b            Set the backlog queue limit (default: 1024)\\n\");\n    printf(\"-B            Binding protocol - one of ascii, binary, or auto (default)\\n\");\n    printf(\"-I            Override the size of each slab page. Adjusts max item size\\n\"\n           \"              (default: 1mb, min: 1k, max: 128m)\\n\");\n    printf(\"-q            Disable detailed stats commands\\n\");\n#ifdef SASL_ENABLED\n    printf(\"-S            Require SASL authentication\\n\");\n#endif\n    printf(\"-X module,cfg Load the module and initialize it with the config\\n\");\n    printf(\"-E engine     Load engine as the storage engine\\n\");\n    printf(\"-e config     Pass config as configuration options to the storage engine\\n\");\n    printf(\"\\nEnvironment variables:\\n\"\n           \"MEMCACHED_PORT_FILENAME   File to write port information to\\n\"\n           \"MEMCACHED_TOP_KEYS        Number of top keys to keep track of\\n\"\n           \"MEMCACHED_REQS_TAP_EVENT  Similar to -R but for tap_ship_log\\n\");\n}\nstatic void usage_license(void) {\n    printf(PACKAGE \" \" VERSION \"\\n\\n\");\n    printf(\n    \"Copyright (c) 2003, Danga Interactive, Inc. <http://www.danga.com/>\\n\"\n    \"All rights reserved.\\n\"\n    \"\\n\"\n    \"Redistribution and use in source and binary forms, with or without\\n\"\n    \"modification, are permitted provided that the following conditions are\\n\"\n    \"met:\\n\"\n    \"\\n\"\n    \"    * Redistributions of source code must retain the above copyright\\n\"\n    \"notice, this list of conditions and the following disclaimer.\\n\"\n    \"\\n\"\n    \"    * Redistributions in binary form must reproduce the above\\n\"\n    \"copyright notice, this list of conditions and the following disclaimer\\n\"\n    \"in the documentation and/or other materials provided with the\\n\"\n    \"distribution.\\n\"\n    \"\\n\"\n    \"    * Neither the name of the Danga Interactive nor the names of its\\n\"\n    \"contributors may be used to endorse or promote products derived from\\n\"\n    \"this software without specific prior written permission.\\n\"\n    \"\\n\"\n    \"THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\\n\"\n    \"\\\"AS IS\\\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\\n\"\n    \"LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\\n\"\n    \"A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\\n\"\n    \"OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\\n\"\n    \"SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\\n\"\n    \"LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\\n\"\n    \"DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\\n\"\n    \"THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\\n\"\n    \"(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\\n\"\n    \"OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n\"\n    \"\\n\"\n    \"\\n\"\n    \"This product includes software developed by Niels Provos.\\n\"\n    \"\\n\"\n    \"[ libevent ]\\n\"\n    \"\\n\"\n    \"Copyright 2000-2003 Niels Provos <provos@citi.umich.edu>\\n\"\n    \"All rights reserved.\\n\"\n    \"\\n\"\n    \"Redistribution and use in source and binary forms, with or without\\n\"\n    \"modification, are permitted provided that the following conditions\\n\"\n    \"are met:\\n\"\n    \"1. Redistributions of source code must retain the above copyright\\n\"\n    \"   notice, this list of conditions and the following disclaimer.\\n\"\n    \"2. Redistributions in binary form must reproduce the above copyright\\n\"\n    \"   notice, this list of conditions and the following disclaimer in the\\n\"\n    \"   documentation and/or other materials provided with the distribution.\\n\"\n    \"3. All advertising materials mentioning features or use of this software\\n\"\n    \"   must display the following acknowledgement:\\n\"\n    \"      This product includes software developed by Niels Provos.\\n\"\n    \"4. The name of the author may not be used to endorse or promote products\\n\"\n    \"   derived from this software without specific prior written permission.\\n\"\n    \"\\n\"\n    \"THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\\n\"\n    \"IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\\n\"\n    \"OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\\n\"\n    \"IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\\n\"\n    \"INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\\n\"\n    \"NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\\n\"\n    \"DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\\n\"\n    \"THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\\n\"\n    \"(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\\n\"\n    \"THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n\"\n    );\n\n    return;\n}\n\nstatic void save_pid(const char *pid_file) {\n    FILE *fp;\n\n    if (access(pid_file, F_OK) == 0) {\n        if ((fp = fopen(pid_file, \"r\")) != NULL) {\n            char buffer[1024];\n            if (fgets(buffer, sizeof(buffer), fp) != NULL) {\n                unsigned int pid;\n                if (safe_strtoul(buffer, &pid) && kill((pid_t)pid, 0) == 0) {\n                    settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                               \"WARNING: The pid file contained the following (running) pid: %u\\n\", pid);\n                }\n            }\n            fclose(fp);\n        }\n    }\n\n    if ((fp = fopen(pid_file, \"w\")) == NULL) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                 \"Could not open the pid file %s for writing: %s\\n\",\n                 pid_file, strerror(errno));\n        return;\n    }\n\n    fprintf(fp,\"%ld\\n\", (long)getpid());\n    if (fclose(fp) == -1) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"Could not close the pid file %s: %s\\n\",\n                pid_file, strerror(errno));\n    }\n}\n\nstatic void remove_pidfile(const char *pid_file) {\n    if (pid_file != NULL) {\n        if (unlink(pid_file) != 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                    \"Could not remove the pid file %s: %s\\n\",\n                    pid_file, strerror(errno));\n        }\n    }\n}\n\n#ifndef HAVE_SIGIGNORE\nstatic int sigignore(int sig) {\n    struct sigaction sa = { .sa_handler = SIG_IGN, .sa_flags = 0 };\n\n    if (sigemptyset(&sa.sa_mask) == -1 || sigaction(sig, &sa, 0) == -1) {\n        return -1;\n    }\n    return 0;\n}\n#endif /* !HAVE_SIGIGNORE */\n\nstatic void sigterm_handler(int sig) {\n    assert(sig == SIGTERM || sig == SIGINT);\n    memcached_shutdown = 1;\n}\n\nstatic int install_sigterm_handler(void) {\n    struct sigaction sa = {.sa_handler = sigterm_handler, .sa_flags = 0};\n\n    if (sigemptyset(&sa.sa_mask) == -1 || sigaction(SIGTERM, &sa, 0) == -1 ||\n        sigaction(SIGINT, &sa, 0) == -1) {\n        return -1;\n    }\n\n    return 0;\n}\n\n/*\n * On systems that supports multiple page sizes we may reduce the\n * number of TLB-misses by using the biggest available page size\n */\nstatic int enable_large_pages(void) {\n#if defined(HAVE_GETPAGESIZES) && defined(HAVE_MEMCNTL)\n    int ret = -1;\n    size_t sizes[32];\n    int avail = getpagesizes(sizes, 32);\n    if (avail != -1) {\n        size_t max = sizes[0];\n        struct memcntl_mha arg = {0};\n        int ii;\n\n        for (ii = 1; ii < avail; ++ii) {\n            if (max < sizes[ii]) {\n                max = sizes[ii];\n            }\n        }\n\n        arg.mha_flags   = 0;\n        arg.mha_pagesize = max;\n        arg.mha_cmd = MHA_MAPSIZE_BSSBRK;\n\n        if (memcntl(0, 0, MC_HAT_ADVISE, (caddr_t)&arg, 0, 0) == -1) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                  \"Failed to set large pages: %s\\nWill use default page size\\n\",\n                  strerror(errno));\n        } else {\n            ret = 0;\n        }\n    } else {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n          \"Failed to get supported pagesizes: %s\\nWill use default page size\\n\",\n          strerror(errno));\n    }\n\n    return ret;\n#else\n    return 0;\n#endif\n}\n\nstatic const char* get_server_version(void) {\n    return VERSION;\n}\n\nstatic void store_engine_specific(const void *cookie,\n                                  void *engine_data) {\n    conn *c = (conn*)cookie;\n    c->engine_storage = engine_data;\n}\n\nstatic void *get_engine_specific(const void *cookie) {\n    conn *c = (conn*)cookie;\n    return c->engine_storage;\n}\n\nstatic int get_socket_fd(const void *cookie) {\n    conn *c = (conn *)cookie;\n    return c->sfd;\n}\n\nstatic void set_tap_nack_mode(const void *cookie, bool enable) {\n    conn *c = (conn *)cookie;\n    c->tap_nack_mode = enable;\n}\n\nstatic void reserve_cookie(const void *cookie) {\n    conn *c = (conn *)cookie;\n    ++c->refcount;\n}\n\nstatic void release_cookie(const void *cookie) {\n    conn *c = (conn *)cookie;\n    --c->refcount;\n}\n\nstatic int num_independent_stats(void) {\n    return settings.num_threads + 1;\n}\n\nstatic void *new_independent_stats(void) {\n    int ii;\n    int nrecords = num_independent_stats();\n    struct independent_stats *independent_stats = calloc(sizeof(independent_stats) + sizeof(struct thread_stats) * nrecords, 1);\n\n#ifdef INNODB_MEMCACHED\n    if (independent_stats == NULL) {\n\tfprintf(stderr, \"Unable to allocate memory for\"\n\t\t       \"independent_stats...\\n\");\n       return (NULL);\n    }\n#endif\n\n    if (settings.topkeys > 0)\n        independent_stats->topkeys = topkeys_init(settings.topkeys);\n    for (ii = 0; ii < nrecords; ii++)\n        pthread_mutex_init(&independent_stats->thread_stats[ii].mutex, NULL);\n    return independent_stats;\n}\n\nstatic void release_independent_stats(void *stats) {\n    int ii;\n    int nrecords = num_independent_stats();\n    struct independent_stats *independent_stats = stats;\n    if (independent_stats->topkeys)\n        topkeys_free(independent_stats->topkeys);\n    for (ii = 0; ii < nrecords; ii++)\n        pthread_mutex_destroy(&independent_stats->thread_stats[ii].mutex);\n    free(independent_stats);\n}\n\nstatic inline struct independent_stats *get_independent_stats(conn *c) {\n    struct independent_stats *independent_stats;\n    if (settings.engine.v1->get_stats_struct != NULL) {\n        independent_stats = settings.engine.v1->get_stats_struct(settings.engine.v0, (const void *)c);\n        if (independent_stats == NULL)\n            independent_stats = default_independent_stats;\n    } else {\n        independent_stats = default_independent_stats;\n    }\n    return independent_stats;\n}\n\nstatic inline struct thread_stats *get_thread_stats(conn *c) {\n    struct independent_stats *independent_stats = get_independent_stats(c);\n    assert(c->thread->index < num_independent_stats());\n    return &independent_stats->thread_stats[c->thread->index];\n}\n\nstatic void register_callback(ENGINE_HANDLE *eh,\n                              ENGINE_EVENT_TYPE type,\n                              EVENT_CALLBACK cb, const void *cb_data) {\n    struct engine_event_handler *h =\n        calloc(sizeof(struct engine_event_handler), 1);\n\n    assert(h);\n    h->cb = cb;\n    h->cb_data = cb_data;\n    h->next = engine_event_handlers[type];\n    engine_event_handlers[type] = h;\n}\n\nstatic rel_time_t get_current_time(void)\n{\n    return current_time;\n}\n\nstatic void count_eviction(const void *cookie, const void *key, const int nkey) {\n    topkeys_t *tk = get_independent_stats((conn*)cookie)->topkeys;\n    TK(tk, evictions, key, nkey, get_current_time());\n}\n\n/**\n * To make it easy for engine implementors that doesn't want to care about\n * writing their own incr/decr code, they can just set the arithmetic function\n * to NULL and use this implementation. It is not efficient, due to the fact\n * that it does multiple calls through the interface (get and then cas store).\n * If you don't care, feel free to use it..\n */\nstatic ENGINE_ERROR_CODE internal_arithmetic(ENGINE_HANDLE* handle,\n                                             const void* cookie,\n                                             const void* key,\n                                             const int nkey,\n                                             const bool increment,\n                                             const bool create,\n                                             const uint64_t delta,\n                                             const uint64_t initial,\n                                             const rel_time_t exptime,\n                                             uint64_t *cas,\n                                             uint64_t *result,\n                                             uint16_t vbucket)\n{\n    ENGINE_HANDLE_V1 *e = (ENGINE_HANDLE_V1*)handle;\n\n    item *it = NULL;\n\n    ENGINE_ERROR_CODE ret;\n    ret = e->get(handle, cookie, &it, key, nkey, vbucket);\n\n    if (ret == ENGINE_SUCCESS) {\n        item_info info = { .nvalue = 1 };\n\n        if (!e->get_item_info(handle, cookie, it, &info)) {\n            e->release(handle, cookie, it);\n            return ENGINE_FAILED;\n        }\n\n        char value[80];\n\n        if (info.value[0].iov_len > (sizeof(value) - 1)) {\n            e->release(handle, cookie, it);\n            return ENGINE_EINVAL;\n        }\n\n        memcpy(value, info.value[0].iov_base, info.value[0].iov_len);\n        value[info.value[0].iov_len] = '\\0';\n\n        uint64_t val;\n        if (!safe_strtoull(value, &val)) {\n            e->release(handle, cookie, it);\n            return ENGINE_EINVAL;\n        }\n\n        if (increment) {\n            val += delta;\n        } else {\n            if (delta > val) {\n                val = 0;\n            } else {\n                val -= delta;\n            }\n        }\n\n        size_t nb = snprintf(value, sizeof(value), \"%\"PRIu64, val);\n        *result = val;\n        item *nit = NULL;\n        if (e->allocate(handle, cookie, &nit, key,\n                        nkey, nb, info.flags, info.exptime) != ENGINE_SUCCESS) {\n            e->release(handle, cookie, it);\n            return ENGINE_ENOMEM;\n        }\n\n        item_info i2 = { .nvalue = 1 };\n        if (!e->get_item_info(handle, cookie, nit, &i2)) {\n            e->release(handle, cookie, it);\n            e->release(handle, cookie, nit);\n            return ENGINE_FAILED;\n        }\n\n        memcpy(i2.value[0].iov_base, value, nb);\n        e->item_set_cas(handle, cookie, nit, info.cas);\n        ret = e->store(handle, cookie, nit, cas, OPERATION_CAS, vbucket);\n        e->release(handle, cookie, it);\n        e->release(handle, cookie, nit);\n    } else if (ret == ENGINE_KEY_ENOENT && create) {\n        char value[80];\n        size_t nb = snprintf(value, sizeof(value), \"%\"PRIu64\"\\r\\n\", initial);\n        *result = initial;\n        if (e->allocate(handle, cookie, &it, key, nkey, nb, 0, exptime) != ENGINE_SUCCESS) {\n            e->release(handle, cookie, it);\n            return ENGINE_ENOMEM;\n        }\n\n        item_info info = { .nvalue = 1 };\n        if (!e->get_item_info(handle, cookie, it, &info)) {\n            e->release(handle, cookie, it);\n            return ENGINE_FAILED;\n        }\n\n        memcpy(info.value[0].iov_base, value, nb);\n        ret = e->store(handle, cookie, it, cas, OPERATION_CAS, vbucket);\n        e->release(handle, cookie, it);\n    }\n\n    /* We had a race condition.. just call ourself recursively to retry */\n    if (ret == ENGINE_KEY_EEXISTS) {\n        return internal_arithmetic(handle, cookie, key, nkey, increment, create, delta,\n                                   initial, exptime, cas, result, vbucket);\n    }\n\n    return ret;\n}\n\n/**\n * Register an extension if it's not already registered\n *\n * @param type the type of the extension to register\n * @param extension the extension to register\n * @return true if success, false otherwise\n */\nstatic bool register_extension(extension_type_t type, void *extension)\n{\n    if (extension == NULL) {\n        return false;\n    }\n\n    switch (type) {\n    case EXTENSION_DAEMON:\n        for (EXTENSION_DAEMON_DESCRIPTOR *ptr = settings.extensions.daemons;\n             ptr != NULL;\n             ptr = ptr->next) {\n            if (ptr == extension) {\n                return false;\n            }\n        }\n        ((EXTENSION_DAEMON_DESCRIPTOR *)(extension))->next = settings.extensions.daemons;\n        settings.extensions.daemons = extension;\n        return true;\n    case EXTENSION_LOGGER:\n        settings.extensions.logger = extension;\n        return true;\n    case EXTENSION_ASCII_PROTOCOL:\n        if (settings.extensions.ascii != NULL) {\n            EXTENSION_ASCII_PROTOCOL_DESCRIPTOR *last;\n            for (last = settings.extensions.ascii; last->next != NULL;\n                 last = last->next) {\n                if (last == extension) {\n                    return false;\n                }\n            }\n            if (last == extension) {\n                return false;\n            }\n            last->next = extension;\n            last->next->next = NULL;\n        } else {\n            settings.extensions.ascii = extension;\n            settings.extensions.ascii->next = NULL;\n        }\n        return true;\n\n    default:\n        return false;\n    }\n}\n\n/**\n * Unregister an extension\n *\n * @param type the type of the extension to remove\n * @param extension the extension to remove\n */\nstatic void unregister_extension(extension_type_t type, void *extension)\n{\n    switch (type) {\n    case EXTENSION_DAEMON:\n        {\n            EXTENSION_DAEMON_DESCRIPTOR *prev = NULL;\n            EXTENSION_DAEMON_DESCRIPTOR *ptr = settings.extensions.daemons;\n\n            while (ptr != NULL && ptr != extension) {\n                prev = ptr;\n                ptr = ptr->next;\n            }\n\n            if (ptr != NULL && prev != NULL) {\n                prev->next = ptr->next;\n            }\n\n            if (settings.extensions.daemons == ptr) {\n                settings.extensions.daemons = ptr->next;\n            }\n        }\n        break;\n    case EXTENSION_LOGGER:\n        if (settings.extensions.logger == extension) {\n            if (get_stderr_logger() == extension) {\n                settings.extensions.logger = get_null_logger();\n            } else {\n                settings.extensions.logger = get_stderr_logger();\n            }\n        }\n        break;\n    case EXTENSION_ASCII_PROTOCOL:\n        {\n            EXTENSION_ASCII_PROTOCOL_DESCRIPTOR *prev = NULL;\n            EXTENSION_ASCII_PROTOCOL_DESCRIPTOR *ptr = settings.extensions.ascii;\n\n            while (ptr != NULL && ptr != extension) {\n                prev = ptr;\n                ptr = ptr->next;\n            }\n\n            if (ptr != NULL && prev != NULL) {\n                prev->next = ptr->next;\n            }\n\n            if (settings.extensions.ascii == ptr) {\n                settings.extensions.ascii = ptr->next;\n            }\n        }\n        break;\n\n    default:\n        ;\n    }\n\n}\n\n/**\n * Get the named extension\n */\nstatic void* get_extension(extension_type_t type)\n{\n    switch (type) {\n    case EXTENSION_DAEMON:\n        return settings.extensions.daemons;\n\n    case EXTENSION_LOGGER:\n        return settings.extensions.logger;\n\n    case EXTENSION_ASCII_PROTOCOL:\n        return settings.extensions.ascii;\n\n    default:\n        return NULL;\n    }\n}\n\n#ifdef INNODB_MEMCACHED\nvoid shutdown_server(void) {\n#else\nstatic void shutdown_server(void) {\n#endif /* INNODB_MEMCACHED */\n#ifdef INNODB_MEMCACHED\n    int i;\n    /* Clean up connections */\n    while (listen_conn) {\n\tconn_closing(listen_conn);\n\tlisten_conn = listen_conn->next;\n    }\n\n    for (i = 0; i < num_udp_socket; i++) {\n\tsafe_close(udp_socket[i]);\n    }\n#endif\n    memcached_shutdown = 1;\n}\n\n#ifdef INNODB_MEMCACHED\nbool shutdown_complete(void)\n{\n    return(memcached_shutdown == 2);\n}\n\nbool init_complete(void)\n{\n    return(memcached_initialized == 1);\n}\n#endif\n\nstatic EXTENSION_LOGGER_DESCRIPTOR* get_logger(void)\n{\n    return settings.extensions.logger;\n}\n\nstatic EXTENSION_LOG_LEVEL get_log_level(void)\n{\n    EXTENSION_LOG_LEVEL ret;\n    switch (settings.verbose) {\n    case 0: ret = EXTENSION_LOG_WARNING; break;\n    case 1: ret = EXTENSION_LOG_INFO; break;\n    case 2: ret = EXTENSION_LOG_DEBUG; break;\n    default:\n        ret = EXTENSION_LOG_DETAIL;\n    }\n    return ret;\n}\n\nstatic void set_log_level(EXTENSION_LOG_LEVEL severity)\n{\n    switch (severity) {\n    case EXTENSION_LOG_WARNING: settings.verbose = 0; break;\n    case EXTENSION_LOG_INFO: settings.verbose = 1; break;\n    case EXTENSION_LOG_DEBUG: settings.verbose = 2; break;\n    default:\n        settings.verbose = 3;\n    }\n}\n\nstatic void get_config_append_stats(const char *key, const uint16_t klen,\n                                    const char *val, const uint32_t vlen,\n                                    const void *cookie)\n{\n    if (klen == 0  || vlen == 0) {\n        return ;\n    }\n\n    char *pos = (char*)cookie;\n    size_t nbytes = strlen(pos);\n\n    if ((nbytes + klen + vlen + 3) > 1024) {\n        // Not enough size in the buffer..\n        return;\n    }\n\n    memcpy(pos + nbytes, key, klen);\n    nbytes += klen;\n    pos[nbytes] = '=';\n    ++nbytes;\n    memcpy(pos + nbytes, val, vlen);\n    nbytes += vlen;\n    memcpy(pos + nbytes, \";\", 2);\n}\n\nstatic bool get_config(struct config_item items[]) {\n    char config[1024];\n    config[0] = '\\0';\n    process_stat_settings(get_config_append_stats, config);\n    int rval = parse_config(config, items, NULL);\n    return rval >= 0;\n}\n\n/**\n * Callback the engines may call to get the public server interface\n * @return pointer to a structure containing the interface. The client should\n *         know the layout and perform the proper casts.\n */\nstatic SERVER_HANDLE_V1 *get_server_api(void)\n{\n    static SERVER_CORE_API core_api = {\n        .server_version = get_server_version,\n        .hash = hash,\n        .realtime = realtime,\n        .abstime = abstime,\n        .get_current_time = get_current_time,\n        .parse_config = parse_config,\n        .shutdown = shutdown_server,\n        .get_config = get_config\n    };\n\n    static SERVER_COOKIE_API server_cookie_api = {\n        .get_auth_data = get_auth_data,\n        .store_engine_specific = store_engine_specific,\n        .get_engine_specific = get_engine_specific,\n        .get_socket_fd = get_socket_fd,\n        .set_tap_nack_mode = set_tap_nack_mode,\n        .notify_io_complete = notify_io_complete,\n        .reserve = reserve_cookie,\n        .release = release_cookie\n    };\n\n    static SERVER_STAT_API server_stat_api = {\n        .new_stats = new_independent_stats,\n        .release_stats = release_independent_stats,\n        .evicting = count_eviction\n    };\n\n    static SERVER_LOG_API server_log_api = {\n        .get_logger = get_logger,\n        .get_level = get_log_level,\n        .set_level = set_log_level\n    };\n    static SERVER_EXTENSION_API extension_api = {\n        .register_extension = register_extension,\n        .unregister_extension = unregister_extension,\n        .get_extension = get_extension\n    };\n\n    static SERVER_CALLBACK_API callback_api = {\n        .register_callback = register_callback,\n        .perform_callbacks = perform_callbacks,\n    };\n\n    static SERVER_HANDLE_V1 rv = {\n        .interface = 1,\n        .core = &core_api,\n        .stat = &server_stat_api,\n        .extension = &extension_api,\n        .callback = &callback_api,\n        .log = &server_log_api,\n        .cookie = &server_cookie_api\n    };\n\n    if (rv.engine == NULL) {\n        rv.engine = settings.engine.v0;\n    }\n\n    return &rv;\n}\n\n/**\n * Load a shared object and initialize all the extensions in there.\n *\n * @param soname the name of the shared object (may not be NULL)\n * @param config optional configuration parameters\n * @return true if success, false otherwise\n */\nstatic bool load_extension(const char *soname, const char *config) {\n    if (soname == NULL) {\n        return false;\n    }\n\n    /* Hack to remove the warning from C99 */\n    union my_hack {\n        MEMCACHED_EXTENSIONS_INITIALIZE initialize;\n        void* voidptr;\n    } funky = {.initialize = NULL };\n\n    void *handle = dlopen(soname, RTLD_NOW | RTLD_LOCAL);\n    if (handle == NULL) {\n        const char *msg = dlerror();\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"Failed to open library \\\"%s\\\": %s\\n\",\n                soname, msg ? msg : \"unknown error\");\n        return false;\n    }\n\n    void *symbol = dlsym(handle, \"memcached_extensions_initialize\");\n    if (symbol == NULL) {\n        const char *msg = dlerror();\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"Could not find symbol \\\"memcached_extensions_initialize\\\" in %s: %s\\n\",\n                soname, msg ? msg : \"unknown error\");\n        return false;\n    }\n    funky.voidptr = symbol;\n\n    EXTENSION_ERROR_CODE error = (*funky.initialize)(config, get_server_api);\n\n    if (error != EXTENSION_SUCCESS) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"Failed to initalize extensions from %s. Error code: %d\\n\",\n                soname, error);\n        dlclose(handle);\n        return false;\n    }\n\n    if (settings.verbose > 0) {\n        settings.extensions.logger->log(EXTENSION_LOG_INFO, NULL,\n                \"Loaded extensions from: %s\\n\", soname);\n    }\n\n    return true;\n}\n\n/**\n * Do basic sanity check of the runtime environment\n * @return true if no errors found, false if we can't use this env\n */\nstatic bool sanitycheck(void) {\n    /* One of our biggest problems is old and bogus libevents */\n    const char *ever = event_get_version();\n    if (ever != NULL) {\n        if (strncmp(ever, \"1.\", 2) == 0) {\n            /* Require at least 1.3 (that's still a couple of years old) */\n            if ((ever[2] == '1' || ever[2] == '2') && !isdigit(ever[3])) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                        \"You are using libevent %s.\\nPlease upgrade to\"\n                        \" a more recent version (1.3 or newer)\\n\",\n                        event_get_version());\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n\n#ifdef INNODB_MEMCACHED\nstatic\nchar*\nmy_strdupl(const char* str, int len)\n{\n\tchar*   s = (char*) malloc(len + 1);\n\ts[len] = 0;\n\treturn((char*) memcpy(s, str, len));\n}\n\n/** Function that messages MySQL config variable string to something\nthat can be parsed by getopt() */\nstatic\nvoid\ndaemon_memcached_make_option(char* option, int* option_argc,\n                             char*** option_argv)\n{\n\tstatic const char*      sep = \" \";\n\tchar*                   last;\n\tchar*                   opt_str;\n\tchar*                   my_str;\n\tint                     num_arg = 0;\n\tint                     i = 1;\n\n\tmy_str = my_strdupl(option, strlen(option));\n\n\tfor (opt_str = strtok_r(my_str, sep, &last);\n\t     opt_str;\n\t     opt_str = strtok_r(NULL, sep, &last)) {\n\t\tnum_arg++;\n\t}\n\n\t/* reset my_str, since strtok_r could alter it */\n\tstrncpy(my_str, option, strlen(option));\n\n\t*option_argv = (char**) malloc((num_arg + 1)\n\t\t\t\t       * sizeof(**option_argv));\n\n\tfor (opt_str = strtok_r(my_str, sep, &last);\n\t     opt_str;\n\t     opt_str = strtok_r(NULL, sep, &last)) {\n\t\t(*option_argv)[i] = opt_str;\n\t\ti++;\n\t}\n\n\tassert(i == num_arg + 1);\n\n\t*option_argc = (num_arg + 1);\n\n\treturn;\n}\n\n/* Structure that adds the call back functions struture pointers,\npassed to InnoDB engine */\ntypedef struct eng_config_info {\n\tchar*           option_string;\n\tvoid*           cb_ptr;\n\tunsigned int    eng_r_batch_size;\n\tunsigned int    eng_w_batch_size;\n\tbool\t\tenable_binlog;\n} eng_config_info_t;\n#endif /* INNODB_MEMCACHED */\n\n#ifdef INNODB_MEMCACHED\nvoid* daemon_memcached_main(void *p) {\n#else\nint main (int argc, char **argv) {\n#endif\n    int c;\n    bool lock_memory = false;\n    bool do_daemonize = false;\n    bool preallocate = false;\n    int maxcore = 0;\n    char *username = NULL;\n    char *pid_file = NULL;\n    struct passwd *pw;\n    struct rlimit rlim;\n    char unit = '\\0';\n    int size_max = 0;\n\n    bool protocol_specified = false;\n    bool tcp_specified = false;\n    bool udp_specified = false;\n    memcached_context_t* m_config = (memcached_context_t*)p;\n    const char *engine;\n    const char *engine_config = NULL;\n    char old_options[1024] = { [0] = '\\0' };\n    char *old_opts = old_options;\n#ifdef INNODB_MEMCACHED\n    int option_argc = 0;\n    char** option_argv = NULL;\n    eng_config_info_t my_eng_config;\n\n    memcached_initialized = 0;\n\n    if (m_config->m_engine_library) {\n\tengine = m_config->m_engine_library;\n\n\t/* FIXME: We should have a better way to pass the callback structure\n\tpoint to storage engine. It is now appended in the configure\n\tstring in eng_config_info_t structure */\n\tmy_eng_config.cb_ptr = m_config->m_innodb_api_cb;\n\tmy_eng_config.eng_r_batch_size = m_config->m_r_batch_size;\n\tmy_eng_config.eng_w_batch_size = m_config->m_w_batch_size;\n\tmy_eng_config.enable_binlog = m_config->m_enable_binlog;\n\tmy_eng_config.option_string = old_opts;\n\tengine_config = (const char *) (&my_eng_config);\n\n    } else {\n\tengine = \"default_engine.so\";\n    }\n#else\n    engine = \"default_engine.so\";\n#endif /* INNODB_MEMCACHED */\n\n    memcached_shutdown = 0;\n    memcached_initialized = 0;\n\n    if (!sanitycheck()) {\n        return(NULL);\n    }\n\n    /* make the time we started always be 2 seconds before we really\n       did, so time(0) - time.started is never zero.  if so, things\n       like 'settings.oldest_live' which act as booleans as well as\n       values are now false in boolean context... */\n    process_started = time(0) - 2;\n    set_current_time();\n\n    /* Initialize the socket subsystem */\n    initialize_sockets();\n\n    /* init settings */\n    settings_init();\n\n    if (memcached_initialize_stderr_logger(get_server_api) != EXTENSION_SUCCESS) {\n        fprintf(stderr, \"Failed to initialize log system\\n\");\n        return (NULL);\n    }\n\n    if (m_config->m_mem_option) {\n\tdaemon_memcached_make_option(m_config->m_mem_option,\n\t\t\t\t     &option_argc,\n\t\t\t\t     &option_argv);\n    }\n\n#ifdef INNODB_MEMCACHED\n\n    if (option_argc > 0 && option_argv) {\n\t    /* Always reset the index to 1, since this function can\n\t    be invoked multiple times with install/uninstall plugins */\n\t    optind = 1;\n\t    while (-1 != (c = getopt(option_argc, option_argv,\n\t\t  \"a:\"  /* access mask for unix socket */\n\t\t  \"p:\"  /* TCP port number to listen on */\n\t\t  \"s:\"  /* unix socket path to listen on */\n\t\t  \"U:\"  /* UDP port number to listen on */\n\t\t  \"m:\"  /* max memory to use for items in megabytes */\n\t\t  \"M\"   /* return error on memory exhausted */\n\t\t  \"c:\"  /* max simultaneous connections */\n\t\t  \"k\"   /* lock down all paged memory */\n\t\t  \"hi\"  /* help, licence info */\n\t\t  \"r\"   /* maximize core file limit */\n\t\t  \"v\"   /* verbose */\n\t\t  \"d\"   /* daemon mode */\n\t\t  \"l:\"  /* interface to listen on */\n\t\t  \"u:\"  /* user identity to run as */\n\t\t  \"P:\"  /* save PID in file */\n\t\t  \"f:\"  /* factor? */\n\t\t  \"n:\"  /* minimum space allocated for key+value+flags */\n\t\t  \"t:\"  /* threads */\n\t\t  \"D:\"  /* prefix delimiter? */\n\t\t  \"L\"   /* Large memory pages */\n\t\t  \"R:\"  /* max requests per event */\n\t\t  \"C\"   /* Disable use of CAS */\n\t\t  \"b:\"  /* backlog queue limit */\n\t\t  \"B:\"  /* Binding protocol */\n\t\t  \"I:\"  /* Max item size */\n\t\t  \"S\"   /* Sasl ON */\n\t\t  \"E:\"  /* Engine to load */\n\t\t  \"e:\"  /* Engine options */\n\t\t  \"q\"   /* Disallow detailed stats */\n\t\t  \"X:\"  /* Load extension */\n\t\t))) {\n\t\tswitch (c) {\n\t\tcase 'a':\n\t\t    /* access for unix domain socket, as octal mask (like chmod)*/\n\t\t    settings.access= strtol(optarg,NULL,8);\n\t\t    break;\n\n\t\tcase 'U':\n\t\t    settings.udpport = atoi(optarg);\n\t\t    udp_specified = true;\n\t\t    break;\n\t\tcase 'p':\n\t\t    settings.port = atoi(optarg);\n\t\t    tcp_specified = true;\n\t\t    break;\n\t\tcase 's':\n\t\t    settings.socketpath = optarg;\n\t\t    break;\n\t\tcase 'm':\n\t\t    settings.maxbytes = ((size_t)atoi(optarg)) * 1024 * 1024;\n\t\t     old_opts += sprintf(old_opts, \"cache_size=%lu;\",\n\t\t\t\t\t (unsigned long)settings.maxbytes);\n\t\t   break;\n\t\tcase 'M':\n\t\t    settings.evict_to_free = 0;\n\t\t    old_opts += sprintf(old_opts, \"eviction=false;\");\n\t\t    break;\n\t\tcase 'c':\n\t\t    settings.maxconns = atoi(optarg);\n\t\t    break;\n\t\tcase 'h':\n\t\t    usage();\n\t\t    exit(EXIT_SUCCESS);\n\t\tcase 'i':\n\t\t    usage_license();\n\t\t    exit(EXIT_SUCCESS);\n\t\tcase 'k':\n\t\t    lock_memory = true;\n\t\t    break;\n\t\tcase 'v':\n\t\t    settings.verbose++;\n\t\t    perform_callbacks(ON_LOG_LEVEL, NULL, NULL);\n\t\t    break;\n\t\tcase 'l':\n\t\t    settings.inter= strdup(optarg);\n\t\t    break;\n\t\tcase 'd':\n\t\t    do_daemonize = true;\n\t\t    break;\n\t\tcase 'r':\n\t\t    maxcore = 1;\n\t\t    break;\n\t\tcase 'R':\n\t\t    settings.reqs_per_event = atoi(optarg);\n\t\t    if (settings.reqs_per_event <= 0) {\n\t\t\tsettings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n\t\t\t      \"Number of requests per event must be greater than 0\\n\");\n\t\t\treturn (void*)1;\n\t\t    }\n\t\t    break;\n\t\tcase 'u':\n\t\t    username = optarg;\n\t\t    break;\n\t\tcase 'P':\n\t\t    pid_file = optarg;\n\t\t    break;\n\t\tcase 'f':\n\t\t    settings.factor = atof(optarg);\n\t\t    if (settings.factor <= 1.0) {\n\t\t\tsettings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n\t\t\t\t\"Factor must be greater than 1\\n\");\n\t\t\treturn (void*)1;\n\t\t    }\n\t\t     old_opts += sprintf(old_opts, \"factor=%f;\",\n\t\t\t\t\t settings.factor);\n\t\t   break;\n\t\tcase 'n':\n\t\t    settings.chunk_size = atoi(optarg);\n\t\t    if (settings.chunk_size == 0) {\n\t\t\tsettings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n\t\t\t\t\"Chunk size must be greater than 0\\n\");\n\t\t\treturn (void*)1;\n\t\t    }\n\t\t    old_opts += sprintf(old_opts, \"chunk_size=%u;\",\n\t\t\t\t\tsettings.chunk_size);\n\t\t    break;\n\t\tcase 't':\n\t\t    settings.num_threads = atoi(optarg);\n\t\t    if (settings.num_threads <= 0) {\n\t\t\tsettings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n\t\t\t\t\"Number of threads must be greater than 0\\n\");\n\t\t\treturn (void*)1;\n\t\t    }\n\t\t    /* There're other problems when you get above 64 threads.\n\t\t     * In the future we should portably detect # of cores for the\n\t\t     * default.\n\t\t     */\n\t\t    if (settings.num_threads > 64) {\n\t\t\tsettings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n\t\t\t\t\"WARNING: Setting a high number of worker\"\n\t\t\t\t\"threads is not recommended.\\n\"\n\t\t\t\t\" Set this value to the number of cores in\"\n\t\t\t\t\" your machine or less.\\n\");\n\t\t    }\n\t\t    break;\n\t\tcase 'D':\n\t\t    settings.prefix_delimiter = optarg[0];\n\t\t    settings.detail_enabled = 1;\n\t\t    break;\n\t\tcase 'L' :\n\t\t    if (enable_large_pages() == 0) {\n\t\t\tpreallocate = true;\n\t\t\told_opts += sprintf(old_opts, \"preallocate=true;\");\n\t\t    }\n\t\t    break;\n\t\tcase 'C' :\n\t\t    settings.use_cas = false;\n\t\t    break;\n\t\tcase 'b' :\n\t\t    settings.backlog = atoi(optarg);\n\t\t    break;\n\t\tcase 'B':\n\t\t    protocol_specified = true;\n\t\t    if (strcmp(optarg, \"auto\") == 0) {\n\t\t\tsettings.binding_protocol = negotiating_prot;\n\t\t    } else if (strcmp(optarg, \"binary\") == 0) {\n\t\t\tsettings.binding_protocol = binary_prot;\n\t\t    } else if (strcmp(optarg, \"ascii\") == 0) {\n\t\t\tsettings.binding_protocol = ascii_prot;\n\t\t    } else {\n\t\t\tsettings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n\t\t\t\t\"Invalid value for binding protocol: %s\\n\"\n\t\t\t\t\" -- should be one of auto, binary, or ascii\\n\", optarg);\n\t\t\texit(EX_USAGE);\n\t\t    }\n\t\t    break;\n\t\tcase 'I':\n\t\t    unit = optarg[strlen(optarg)-1];\n\t\t    if (unit == 'k' || unit == 'm' ||\n\t\t\tunit == 'K' || unit == 'M') {\n\t\t\toptarg[strlen(optarg)-1] = '\\0';\n\t\t\tsize_max = atoi(optarg);\n\t\t\tif (unit == 'k' || unit == 'K')\n\t\t\t    size_max *= 1024;\n\t\t\tif (unit == 'm' || unit == 'M')\n\t\t\t    size_max *= 1024 * 1024;\n\t\t\tsettings.item_size_max = size_max;\n\t\t    } else {\n\t\t\tsettings.item_size_max = atoi(optarg);\n\t\t    }\n\t\t    if (settings.item_size_max < 1024) {\n\t\t\tsettings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n\t\t\t\t\"Item max size cannot be less than 1024 bytes.\\n\");\n\t\t\treturn (void*)1;\n\t\t    }\n\t\t    if (settings.item_size_max > 1024 * 1024 * 128) {\n\t\t\tsettings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n\t\t\t\t\"Cannot set item size limit higher than 128 mb.\\n\");\n\t\t\treturn (void*)1;\n\t\t    }\n\t\t    if (settings.item_size_max > 1024 * 1024) {\n\t\t\tsettings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n\t\t\t    \"WARNING: Setting item max size above 1MB is not\"\n\t\t\t    \" recommended!\\n\"\n\t\t\t    \" Raising this limit increases the minimum memory requirements\\n\"\n\t\t\t    \" and will decrease your memory efficiency.\\n\"\n\t\t\t);\n\t\t    }\n#ifndef __WIN32__\n\t\t    old_opts += sprintf(old_opts, \"item_size_max=%zu;\",\n\t\t\t\t\tsettings.item_size_max);\n#else\n\t\t    old_opts += sprintf(old_opts, \"item_size_max=%lu;\", (long unsigned)\n\t\t\t\t\tsettings.item_size_max);\n#endif\n\t\t    break;\n\t\tcase 'E':\n\t\t    engine = optarg;\n\t\t    break;\n\t\tcase 'e':\n\t\t    /* FIXME, we use engine_config to pass callback function\n\t\t    for now. Will need a better solution \n\t\t    engine_config = optarg; */\n\t\t    break;\n\t\tcase 'q':\n\t\t    settings.allow_detailed = false;\n\t\t    break;\n\t\tcase 'S': /* set Sasl authentication to true. Default is false */\n# ifdef ENABLE_MEMCACHED_SASL\n#  ifndef SASL_ENABLED\n\t\t    settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n\t\t\t    \"This server is not built with SASL support.\\n\");\n\t\t    exit(EX_USAGE);\n#  endif /* !SASL_ENABLED */\n\t\t    settings.require_sasl = true;\n# endif /* ENABLE_MEMCACHED_SASL */\n\t\t    break;\n\t\tcase 'X' :\n\t\t    {\n\t\t\tchar *ptr = strchr(optarg, ',');\n\t\t\tif (ptr != NULL) {\n\t\t\t    *ptr = '\\0';\n\t\t\t    ++ptr;\n\t\t\t}\n\t\t\tif (!load_extension(optarg, ptr)) {\n\t\t\t    exit(EXIT_FAILURE);\n\t\t\t}\n\t\t\tif (ptr != NULL) {\n\t\t\t    *(ptr - 1) = ',';\n\t\t\t}\n\t\t    }\n\t\t    break;\n\t\tdefault:\n\t\t    settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n\t\t\t    \"Illegal argument \\\"%c\\\"\\n\", c);\n\t\t    return (void*)1;\n\t\t}\n\t}\n\n\tfree(option_argv);\n    }\n    fprintf(stderr, MEMCACHED_ATOMIC_MSG);\n#else\n    /* process arguments */\n    while (-1 != (c = getopt(argc, argv,\n          \"a:\"  /* access mask for unix socket */\n          \"p:\"  /* TCP port number to listen on */\n          \"s:\"  /* unix socket path to listen on */\n          \"U:\"  /* UDP port number to listen on */\n          \"m:\"  /* max memory to use for items in megabytes */\n          \"M\"   /* return error on memory exhausted */\n          \"c:\"  /* max simultaneous connections */\n          \"k\"   /* lock down all paged memory */\n          \"hi\"  /* help, licence info */\n          \"r\"   /* maximize core file limit */\n          \"v\"   /* verbose */\n          \"d\"   /* daemon mode */\n          \"l:\"  /* interface to listen on */\n          \"u:\"  /* user identity to run as */\n          \"P:\"  /* save PID in file */\n          \"f:\"  /* factor? */\n          \"n:\"  /* minimum space allocated for key+value+flags */\n          \"t:\"  /* threads */\n          \"D:\"  /* prefix delimiter? */\n          \"L\"   /* Large memory pages */\n          \"R:\"  /* max requests per event */\n          \"C\"   /* Disable use of CAS */\n          \"b:\"  /* backlog queue limit */\n          \"B:\"  /* Binding protocol */\n          \"I:\"  /* Max item size */\n          \"S\"   /* Sasl ON */\n          \"E:\"  /* Engine to load */\n          \"e:\"  /* Engine options */\n          \"q\"   /* Disallow detailed stats */\n          \"X:\"  /* Load extension */\n        ))) {\n        switch (c) {\n        case 'a':\n            /* access for unix domain socket, as octal mask (like chmod)*/\n            settings.access= strtol(optarg,NULL,8);\n            break;\n\n        case 'U':\n            settings.udpport = atoi(optarg);\n            udp_specified = true;\n            break;\n        case 'p':\n            settings.port = atoi(optarg);\n            tcp_specified = true;\n            break;\n        case 's':\n            settings.socketpath = optarg;\n            break;\n        case 'm':\n            settings.maxbytes = ((size_t)atoi(optarg)) * 1024 * 1024;\n             old_opts += sprintf(old_opts, \"cache_size=%lu;\",\n                                 (unsigned long)settings.maxbytes);\n           break;\n        case 'M':\n            settings.evict_to_free = 0;\n            old_opts += sprintf(old_opts, \"eviction=false;\");\n            break;\n        case 'c':\n            settings.maxconns = atoi(optarg);\n            break;\n        case 'h':\n            usage();\n            exit(EXIT_SUCCESS);\n        case 'i':\n            usage_license();\n            exit(EXIT_SUCCESS);\n        case 'k':\n            lock_memory = true;\n            break;\n        case 'v':\n            settings.verbose++;\n            perform_callbacks(ON_LOG_LEVEL, NULL, NULL);\n            break;\n        case 'l':\n            if (settings.inter != NULL) {\n                size_t len = strlen(settings.inter) + strlen(optarg) + 2;\n                char *p = malloc(len);\n                if (p == NULL) {\n                    settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                                    \"Failed to allocate memory\\n\");\n                    return 1;\n                }\n                snprintf(p, len, \"%s,%s\", settings.inter, optarg);\n                free(settings.inter);\n                settings.inter = p;\n            } else {\n                settings.inter= strdup(optarg);\n            }\n            break;\n        case 'd':\n            do_daemonize = true;\n            break;\n        case 'r':\n            maxcore = 1;\n            break;\n        case 'R':\n            settings.reqs_per_event = atoi(optarg);\n            if (settings.reqs_per_event <= 0) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                      \"Number of requests per event must be greater than 0\\n\");\n                return 1;\n            }\n            break;\n        case 'u':\n            username = optarg;\n            break;\n        case 'P':\n            pid_file = optarg;\n            break;\n        case 'f':\n            settings.factor = atof(optarg);\n            if (settings.factor <= 1.0) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                        \"Factor must be greater than 1\\n\");\n                return 1;\n            }\n             old_opts += sprintf(old_opts, \"factor=%f;\",\n                                 settings.factor);\n           break;\n        case 'n':\n            settings.chunk_size = atoi(optarg);\n            if (settings.chunk_size == 0) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                        \"Chunk size must be greater than 0\\n\");\n                return 1;\n            }\n            old_opts += sprintf(old_opts, \"chunk_size=%u;\",\n                                settings.chunk_size);\n            break;\n        case 't':\n            settings.num_threads = atoi(optarg);\n            if (settings.num_threads <= 0) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                        \"Number of threads must be greater than 0\\n\");\n                return 1;\n            }\n            /* There're other problems when you get above 64 threads.\n             * In the future we should portably detect # of cores for the\n             * default.\n             */\n            if (settings.num_threads > 64) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                        \"WARNING: Setting a high number of worker\"\n                        \"threads is not recommended.\\n\"\n                        \" Set this value to the number of cores in\"\n                        \" your machine or less.\\n\");\n            }\n            break;\n        case 'D':\n            settings.prefix_delimiter = optarg[0];\n            settings.detail_enabled = 1;\n            break;\n        case 'L' :\n            if (enable_large_pages() == 0) {\n                preallocate = true;\n                old_opts += sprintf(old_opts, \"preallocate=true;\");\n            }\n            break;\n        case 'C' :\n            settings.use_cas = false;\n            break;\n        case 'b' :\n            settings.backlog = atoi(optarg);\n            break;\n        case 'B':\n            protocol_specified = true;\n            if (strcmp(optarg, \"auto\") == 0) {\n                settings.binding_protocol = negotiating_prot;\n            } else if (strcmp(optarg, \"binary\") == 0) {\n                settings.binding_protocol = binary_prot;\n            } else if (strcmp(optarg, \"ascii\") == 0) {\n                settings.binding_protocol = ascii_prot;\n            } else {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                        \"Invalid value for binding protocol: %s\\n\"\n                        \" -- should be one of auto, binary, or ascii\\n\", optarg);\n                exit(EX_USAGE);\n            }\n            break;\n        case 'I':\n            unit = optarg[strlen(optarg)-1];\n            if (unit == 'k' || unit == 'm' ||\n                unit == 'K' || unit == 'M') {\n                optarg[strlen(optarg)-1] = '\\0';\n                size_max = atoi(optarg);\n                if (unit == 'k' || unit == 'K')\n                    size_max *= 1024;\n                if (unit == 'm' || unit == 'M')\n                    size_max *= 1024 * 1024;\n                settings.item_size_max = size_max;\n            } else {\n                settings.item_size_max = atoi(optarg);\n            }\n            if (settings.item_size_max < 1024) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                        \"Item max size cannot be less than 1024 bytes.\\n\");\n                return 1;\n            }\n            if (settings.item_size_max > 1024 * 1024 * 128) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                        \"Cannot set item size limit higher than 128 mb.\\n\");\n                return 1;\n            }\n            if (settings.item_size_max > 1024 * 1024) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                    \"WARNING: Setting item max size above 1MB is not\"\n                    \" recommended!\\n\"\n                    \" Raising this limit increases the minimum memory requirements\\n\"\n                    \" and will decrease your memory efficiency.\\n\"\n                );\n            }\n#ifndef __WIN32__\n            old_opts += sprintf(old_opts, \"item_size_max=%zu;\",\n                                settings.item_size_max);\n#else\n            old_opts += sprintf(old_opts, \"item_size_max=%lu;\", (long unsigned)\n                                settings.item_size_max);\n#endif\n            break;\n        case 'E':\n            engine = optarg;\n            break;\n        case 'e':\n            engine_config = optarg;\n            break;\n        case 'q':\n            settings.allow_detailed = false;\n            break;\n        case 'S': /* set Sasl authentication to true. Default is false */\n#ifndef SASL_ENABLED\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                    \"This server is not built with SASL support.\\n\");\n            exit(EX_USAGE);\n#endif\n            settings.require_sasl = true;\n            break;\n        case 'X' :\n            {\n                char *ptr = strchr(optarg, ',');\n                if (ptr != NULL) {\n                    *ptr = '\\0';\n                    ++ptr;\n                }\n                if (!load_extension(optarg, ptr)) {\n                    exit(EXIT_FAILURE);\n                }\n                if (ptr != NULL) {\n                    *(ptr - 1) = ',';\n                }\n            }\n            break;\n        default:\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                    \"Illegal argument \\\"%c\\\"\\n\", c);\n            return 1;\n        }\n    }\n#endif /* INNODB_MEMCACHED */\n\n    if (getenv(\"MEMCACHED_REQS_TAP_EVENT\") != NULL) {\n        settings.reqs_per_tap_event = atoi(getenv(\"MEMCACHED_REQS_TAP_EVENT\"));\n    }\n\n    if (settings.reqs_per_tap_event <= 0) {\n        settings.reqs_per_tap_event = DEFAULT_REQS_PER_TAP_EVENT;\n    }\n\n\n    if (install_sigterm_handler() != 0) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                                        \"Failed to install SIGTERM handler\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    char *topkeys_env = getenv(\"MEMCACHED_TOP_KEYS\");\n    if (topkeys_env != NULL) {\n        settings.topkeys = atoi(topkeys_env);\n        if (settings.topkeys < 0) {\n            settings.topkeys = 0;\n        }\n    }\n\n    if (settings.require_sasl) {\n        if (!protocol_specified) {\n            settings.binding_protocol = binary_prot;\n        } else {\n            if (settings.binding_protocol == negotiating_prot) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                        \"ERROR: You cannot use auto-negotiating protocol while requiring SASL.\\n\");\n                exit(EX_USAGE);\n            }\n            if (settings.binding_protocol == ascii_prot) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                        \"ERROR: You cannot use only ASCII protocol while requiring SASL.\\n\");\n                exit(EX_USAGE);\n            }\n        }\n    }\n\n    if (tcp_specified && !udp_specified) {\n        settings.udpport = settings.port;\n    } else if (udp_specified && !tcp_specified) {\n        settings.port = settings.udpport;\n    }\n\n    /*\n    if (engine_config != NULL && strlen(old_options) > 0) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"ERROR: You can't mix -e with the old options\\n\");\n        return (NULL);\n    } else if (engine_config == NULL && strlen(old_options) > 0) {\n        engine_config = old_options;\n    } */\n\n    if (maxcore != 0) {\n        struct rlimit rlim_new;\n        /*\n         * First try raising to infinity; if that fails, try bringing\n         * the soft limit to the hard.\n         */\n        if (getrlimit(RLIMIT_CORE, &rlim) == 0) {\n            rlim_new.rlim_cur = rlim_new.rlim_max = RLIM_INFINITY;\n            if (setrlimit(RLIMIT_CORE, &rlim_new)!= 0) {\n                /* failed. try raising just to the old max */\n                rlim_new.rlim_cur = rlim_new.rlim_max = rlim.rlim_max;\n                (void)setrlimit(RLIMIT_CORE, &rlim_new);\n            }\n        }\n        /*\n         * getrlimit again to see what we ended up with. Only fail if\n         * the soft limit ends up 0, because then no core files will be\n         * created at all.\n         */\n\n        if ((getrlimit(RLIMIT_CORE, &rlim) != 0) || rlim.rlim_cur == 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                    \"failed to ensure corefile creation\\n\");\n            exit(EX_OSERR);\n        }\n    }\n\n    /*\n     * If needed, increase rlimits to allow as many connections\n     * as needed.\n     */\n\n    if (getrlimit(RLIMIT_NOFILE, &rlim) != 0) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"failed to getrlimit number of files\\n\");\n        exit(EX_OSERR);\n    } else {\n        int maxfiles = settings.maxconns;\n        if (rlim.rlim_cur < maxfiles)\n            rlim.rlim_cur = maxfiles;\n        if (rlim.rlim_max < rlim.rlim_cur)\n            rlim.rlim_max = rlim.rlim_cur;\n        if (setrlimit(RLIMIT_NOFILE, &rlim) != 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                    \"failed to set rlimit for open files. Try running as\"\n                    \" root or requesting smaller maxconns value.\\n\");\n            exit(EX_OSERR);\n        }\n    }\n\n    /* Sanity check for the connection structures */\n    int nfiles = 0;\n    if (settings.port != 0) {\n        nfiles += 2;\n    }\n    if (settings.udpport != 0) {\n        nfiles += settings.num_threads * 2;\n    }\n\n    if (settings.maxconns <= nfiles) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"Configuratioin error. \\n\"\n                \"You specified %d connections, but the system will use at \"\n                \"least %d\\nconnection structures to start.\\n\",\n                settings.maxconns, nfiles);\n        exit(EX_USAGE);\n    }\n\n    /* lose root privileges if we have them */\n    if (getuid() == 0 || geteuid() == 0) {\n        if (username == 0 || *username == '\\0') {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                    \"can't run as root without the -u switch\\n\");\n            exit(EX_USAGE);\n        }\n        if ((pw = getpwnam(username)) == 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                    \"can't find the user %s to switch to\\n\", username);\n            exit(EX_NOUSER);\n        }\n        if (setgid(pw->pw_gid) < 0 || setuid(pw->pw_uid) < 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                    \"failed to assume identity of user %s: %s\\n\", username,\n                    strerror(errno));\n            exit(EX_OSERR);\n        }\n    }\n\n#ifdef SASL_ENABLED\n    init_sasl();\n#endif /* SASL */\n\n    /* daemonize if requested */\n    /* if we want to ensure our ability to dump core, don't chdir to / */\n    if (do_daemonize) {\n        if (sigignore(SIGHUP) == -1) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                    \"Failed to ignore SIGHUP: \", strerror(errno));\n        }\n        if (daemonize(maxcore, settings.verbose) == -1) {\n             settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                    \"failed to daemon() in order to daemonize\\n\");\n            exit(EXIT_FAILURE);\n        }\n    }\n\n    /* lock paged memory if needed */\n    if (lock_memory) {\n#ifdef HAVE_MLOCKALL\n        int res = mlockall(MCL_CURRENT | MCL_FUTURE);\n        if (res != 0) {\n            settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                    \"warning: -k invalid, mlockall() failed: %s\\n\",\n                    strerror(errno));\n        }\n#else\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"warning: -k invalid, mlockall() not supported on this platform.  proceeding without.\\n\");\n#endif\n    }\n\n    /* initialize main thread libevent instance */\n    main_base = event_init();\n\n    /* Load the storage engine */\n    ENGINE_HANDLE *engine_handle = NULL;\n    if (!load_engine(engine,get_server_api,settings.extensions.logger,&engine_handle)) {\n        /* Error already reported */\n#ifdef INNODB_MEMCACHED\n        shutdown_server();\n        goto func_exit;\n#else\n        exit(EXIT_FAILURE);\n#endif\n    }\n\n#ifdef INNODB_MEMCACHED\n    my_thread_init();\n#endif\n\n    if(!init_engine(engine_handle,engine_config,settings.extensions.logger)) {\n#ifdef INNODB_MEMCACHED\n\tmy_thread_end();\n        shutdown_server();\n        goto func_exit;\n#else\n\treturn(false);\n#endif /* INNODB_MEMCACHED */\n    }\n\n    if(settings.verbose > 0) {\n        log_engine_details(engine_handle,settings.extensions.logger);\n    }\n    settings.engine.v1 = (ENGINE_HANDLE_V1 *) engine_handle;\n\n    if (settings.engine.v1->arithmetic == NULL) {\n        settings.engine.v1->arithmetic = internal_arithmetic;\n    }\n\n    /* initialize other stuff */\n    stats_init();\n\n    if (!(conn_cache = cache_create(\"conn\", sizeof(conn), sizeof(void*),\n                                    conn_constructor, conn_destructor))) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"Failed to create connection cache\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    default_independent_stats = new_independent_stats();\n\n#ifdef INNODB_MEMCACHED\n    if (!default_independent_stats) {\n\texit(EXIT_FAILURE);\n    }\n#endif\n\n#ifndef __WIN32__\n    /*\n     * ignore SIGPIPE signals; we can use errno == EPIPE if we\n     * need that information\n     */\n    if (sigignore(SIGPIPE) == -1) {\n        settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"failed to ignore SIGPIPE; sigaction\");\n        exit(EX_OSERR);\n    }\n#endif\n\n    /* start up worker threads if MT mode */\n    thread_init(settings.num_threads, main_base, dispatch_event_handler);\n\n    /* initialise clock event */\n    clock_handler(0, 0, 0);\n\n    /* create unix mode sockets after dropping privileges */\n    if (settings.socketpath != NULL) {\n        if (server_socket_unix(settings.socketpath,settings.access)) {\n            vperror(\"failed to listen on UNIX socket: %s\", settings.socketpath);\n            exit(EX_OSERR);\n        }\n    }\n\n    /* create the listening socket, bind it, and init */\n    if (settings.socketpath == NULL) {\n        int udp_port;\n\n        const char *portnumber_filename = getenv(\"MEMCACHED_PORT_FILENAME\");\n        char temp_portnumber_filename[PATH_MAX];\n        FILE *portnumber_file = NULL;\n\n        if (portnumber_filename != NULL) {\n            snprintf(temp_portnumber_filename,\n                     sizeof(temp_portnumber_filename),\n                     \"%s.lck\", portnumber_filename);\n\n            portnumber_file = fopen(temp_portnumber_filename, \"a\");\n            if (portnumber_file == NULL) {\n                settings.extensions.logger->log(EXTENSION_LOG_WARNING, NULL,\n                        \"Failed to open \\\"%s\\\": %s\\n\",\n                        temp_portnumber_filename, strerror(errno));\n            }\n        }\n\n        if (settings.port && server_sockets(settings.port, tcp_transport,\n                                            portnumber_file)) {\n\t\tvperror(\"failed to listen on TCP port %d\", settings.port);\n#ifdef INNODB_MEMCACHED\n\t\tmy_thread_end();\n\t\tshutdown_server();\n\t\tgoto func_exit;\n#else\n\t\texit(EX_OSERR);\n#endif /* INNODB_MEMCACHED */\n        }\n\n        /*\n         * initialization order: first create the listening sockets\n         * (may need root on low ports), then drop root if needed,\n         * then daemonise if needed, then init libevent (in some cases\n         * descriptors created by libevent wouldn't survive forking).\n         */\n        udp_port = settings.udpport ? settings.udpport : settings.port;\n\n        /* create the UDP listening socket and bind it */\n        if (settings.udpport && server_sockets(settings.udpport, udp_transport,\n                                               portnumber_file)) {\n            vperror(\"failed to listen on UDP port %d\", settings.udpport);\n            exit(EX_OSERR);\n        }\n\n        if (portnumber_file) {\n            fclose(portnumber_file);\n            rename(temp_portnumber_filename, portnumber_filename);\n        }\n    }\n\n    if (pid_file != NULL) {\n        save_pid(pid_file);\n    }\n\n    /* Drop privileges no longer needed */\n    drop_privileges();\n\n    memcached_initialized = 1;\n\n    /* enter the event loop */\n    event_base_loop(main_base, 0);\n\n    if (settings.verbose) {\n        settings.extensions.logger->log(EXTENSION_LOG_INFO, NULL,\n                                        \"Initiating shutdown\\n\");\n    }\n\nfunc_exit:\n\n    if (settings.engine.v1)\n      settings.engine.v1->destroy(settings.engine.v0, false);\n\n    threads_shutdown();\n\n    /* remove the PID file if we're a daemon */\n    if (do_daemonize)\n        remove_pidfile(pid_file);\n    /* Clean up strdup() call for bind() address */\n    if (settings.inter)\n      free(settings.inter);\n\n#ifdef INNODB_MEMCACHED\n    /* free event base */\n    if (main_base) {\n        event_base_free(main_base);\n        main_base = NULL;\n    }\n    my_thread_end();\n#endif\n\n    memcached_shutdown = 2;\n    memcached_initialized = 2;\n\n    return EXIT_SUCCESS;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/plugin/innodb_memcached/daemon_memcached/utilities/engine_loader.c": "/* -*- Mode: C; tab-width: 4; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n#include \"config.h\"\n#include <ctype.h>\n#include <stdio.h>\n#include <string.h>\n#include <dlfcn.h>\n#include \"utilities/engine_loader.h\"\n#include <memcached/types.h>\n\nstatic const char * const feature_descriptions[] = {\n    \"compare and swap\",\n    \"persistent storage\",\n    \"secondary engine\",\n    \"access control\",\n    \"multi tenancy\",\n    \"LRU\"\n};\n\nvoid *handle = NULL;\n\nbool load_engine(const char *soname,\n                 SERVER_HANDLE_V1 *(*get_server_api)(void),\n                 EXTENSION_LOGGER_DESCRIPTOR *logger,\n                 ENGINE_HANDLE **engine_handle)\n{\n    ENGINE_HANDLE *engine = NULL;\n    /* Hack to remove the warning from C99 */\n    union my_hack {\n        CREATE_INSTANCE create;\n        void* voidptr;\n    } my_create = {.create = NULL };\n\n    handle = dlopen(soname, RTLD_NOW | RTLD_LOCAL);\n    if (handle == NULL) {\n        const char *msg = dlerror();\n        logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"Failed to open library \\\"%s\\\": %s\\n\",\n                soname ? soname : \"self\",\n                msg ? msg : \"unknown error\");\n        return false;\n    }\n\n    void *symbol = dlsym(handle, \"create_instance\");\n    if (symbol == NULL) {\n        logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"Could not find symbol \\\"create_instance\\\" in %s: %s\\n\",\n                soname ? soname : \"self\",\n                dlerror());\n        return false;\n    }\n    my_create.voidptr = symbol;\n\n    /* request a instance with protocol version 1 */\n    ENGINE_ERROR_CODE error = (*my_create.create)(1, get_server_api, &engine);\n\n    if (error != ENGINE_SUCCESS || engine == NULL) {\n        logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"Failed to create instance. Error code: %d\\n\", error);\n        dlclose(handle);\n        return false;\n    }\n    *engine_handle = engine;\n    return true;\n}\n\nbool init_engine(ENGINE_HANDLE * engine,\n                 const char *config_str,\n                 EXTENSION_LOGGER_DESCRIPTOR *logger)\n{\n    ENGINE_HANDLE_V1 *engine_v1 = NULL;\n\n    if (handle == NULL) {\n        logger->log(EXTENSION_LOG_WARNING, NULL,\n                \"Failed to initialize engine, engine must fist be loaded.\");\n        return false;\n    }\n\n    if (engine->interface == 1) {\n        engine_v1 = (ENGINE_HANDLE_V1*)engine;\n\n        // validate that the required engine interface is implemented:\n        if (engine_v1->get_info == NULL || engine_v1->initialize == NULL ||\n            engine_v1->destroy == NULL || engine_v1->allocate == NULL ||\n            engine_v1->remove == NULL || engine_v1->release == NULL ||\n            engine_v1->get == NULL || engine_v1->store == NULL ||\n            engine_v1->flush == NULL ||\n            engine_v1->get_stats == NULL || engine_v1->reset_stats == NULL ||\n            engine_v1->item_set_cas == NULL ||\n            engine_v1->get_item_info == NULL)\n        {\n            logger->log(EXTENSION_LOG_WARNING, NULL,\n                        \"Failed to initialize engine; it does not implement the engine interface.\");\n            return false;\n        }\n\n        ENGINE_ERROR_CODE error = engine_v1->initialize(engine,config_str);\n        if (error != ENGINE_SUCCESS) {\n            engine_v1->destroy(engine, false);\n            logger->log(EXTENSION_LOG_WARNING, NULL,\n                    \"Failed to initialize instance. Error code: %d\\n\",\n                    error);\n            dlclose(handle);\n            return false;\n        }\n    } else {\n        logger->log(EXTENSION_LOG_WARNING, NULL,\n                 \"Unsupported interface level\\n\");\n        dlclose(handle);\n        return false;\n    }\n    return true;\n}\n\nvoid log_engine_details(ENGINE_HANDLE * engine,\n                        EXTENSION_LOGGER_DESCRIPTOR *logger)\n{\n    ENGINE_HANDLE_V1 *engine_v1 = (ENGINE_HANDLE_V1*)engine;\n    const engine_info *info;\n    info = engine_v1->get_info(engine);\n    if (info) {\n        char message[4096];\n        ssize_t nw = snprintf(message, sizeof(message), \"Loaded engine: %s\\n\",\n                                        info->description ?\n                                        info->description : \"Unknown\");\n        if (nw == -1) {\n            return;\n        }\n        ssize_t offset = nw;\n        bool comma = false;\n\n        if (info->num_features > 0) {\n            nw = snprintf(message + offset, sizeof(message) - offset,\n                          \"Supplying the following features: \");\n            if (nw == -1) {\n                return;\n            }\n            offset += nw;\n            for (int ii = 0; ii < info->num_features; ++ii) {\n                if (info->features[ii].description != NULL) {\n                    // We don't want to write partially from source\n                    if (sizeof(message)-offset <=\n                        2+strlen(info->features[ii].description))\n                    {\n                        return;\n                    }\n\n                    nw = snprintf(message + offset, sizeof(message) - offset,\n                                  \"%s%s\", comma ? \", \" : \"\",\n                                  info->features[ii].description);\n                } else {\n                    if (info->features[ii].feature <= LAST_REGISTERED_ENGINE_FEATURE) {\n                        nw = snprintf(message + offset, sizeof(message) - offset,\n                                      \"%s%s\", comma ? \", \" : \"\",\n                                      feature_descriptions[info->features[ii].feature]);\n                    } else {\n                        nw = snprintf(message + offset, sizeof(message) - offset,\n                                      \"%sUnknown feature: %d\", comma ? \", \" : \"\",\n                                      info->features[ii].feature);\n                    }\n                }\n                comma = true;\n                if (nw == -1) {\n                    return;\n                }\n                offset += nw;\n            }\n        }\n        logger->log(EXTENSION_LOG_INFO, NULL, \"%s\\n\", message);\n    } else {\n        logger->log(EXTENSION_LOG_INFO, NULL,\n                                        \"Loaded engine: Unknown\\n\");\n    }\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/plugin/innodb_memcached/daemon_memcached/programs/engine_testapp.c": "/* -*- Mode: C; tab-width: 4; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n#include \"config.h\"\n#include <assert.h>\n#include <dlfcn.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <signal.h>\n#include <pthread.h>\n#include \"utilities/engine_loader.h\"\n#include <memcached/engine_testapp.h>\n#include <memcached/extension_loggers.h>\n#include <mock_server.h>\n\nstruct mock_engine {\n    ENGINE_HANDLE_V1 me;\n    ENGINE_HANDLE_V1 *the_engine;\n    TAP_ITERATOR iterator;\n};\n\n#ifndef WIN32\nstatic sig_atomic_t alarmed;\n\nstatic void alarm_handler(int sig) {\n    alarmed = 1;\n}\n#endif\n\nstatic inline struct mock_engine* get_handle(ENGINE_HANDLE* handle) {\n    return (struct mock_engine*)handle;\n}\n\nstatic tap_event_t mock_tap_iterator(ENGINE_HANDLE* handle,\n                                     const void *cookie, item **itm,\n                                     void **es, uint16_t *nes, uint8_t *ttl,\n                                     uint16_t *flags, uint32_t *seqno,\n                                     uint16_t *vbucket) {\n   struct mock_engine *me = get_handle(handle);\n   return me->iterator((ENGINE_HANDLE*)me->the_engine, cookie, itm, es, nes,\n                       ttl, flags, seqno, vbucket);\n}\n\nstatic const engine_info* mock_get_info(ENGINE_HANDLE* handle) {\n    struct mock_engine *me = get_handle(handle);\n    return me->the_engine->get_info((ENGINE_HANDLE*)me->the_engine);\n}\n\nstatic ENGINE_ERROR_CODE mock_initialize(ENGINE_HANDLE* handle,\n                                         const char* config_str) {\n    struct mock_engine *me = get_handle(handle);\n    return me->the_engine->initialize((ENGINE_HANDLE*)me->the_engine, config_str);\n}\n\nstatic void mock_destroy(ENGINE_HANDLE* handle, const bool force) {\n    struct mock_engine *me = get_handle(handle);\n    me->the_engine->destroy((ENGINE_HANDLE*)me->the_engine, force);\n}\n\nstatic ENGINE_ERROR_CODE mock_allocate(ENGINE_HANDLE* handle,\n                                       const void* cookie,\n                                       item **item,\n                                       const void* key,\n                                       const size_t nkey,\n                                       const size_t nbytes,\n                                       const int flags,\n                                       const rel_time_t exptime) {\n    struct mock_engine *me = get_handle(handle);\n    struct mock_connstruct *c = (void*)cookie;\n    if (c == NULL) {\n        c = (void*)create_mock_cookie();\n    }\n\n    c->nblocks = 0;\n    ENGINE_ERROR_CODE ret = ENGINE_SUCCESS;\n    pthread_mutex_lock(&c->mutex);\n    while (ret == ENGINE_SUCCESS &&\n           (ret = me->the_engine->allocate((ENGINE_HANDLE*)me->the_engine, c,\n                                           item, key, nkey,\n                                           nbytes, flags,\n                                           exptime)) == ENGINE_EWOULDBLOCK &&\n           c->handle_ewouldblock)\n    {\n        ++c->nblocks;\n        pthread_cond_wait(&c->cond, &c->mutex);\n        ret = c->status;\n    }\n    pthread_mutex_unlock(&c->mutex);\n\n    if (c != cookie) {\n        destroy_mock_cookie(c);\n    }\n\n    return ret;\n}\n\nstatic ENGINE_ERROR_CODE mock_remove(ENGINE_HANDLE* handle,\n                                     const void* cookie,\n                                     const void* key,\n                                     const size_t nkey,\n                                     uint64_t cas,\n                                     uint16_t vbucket)\n{\n    struct mock_engine *me = get_handle(handle);\n    struct mock_connstruct *c = (void*)cookie;\n    if (c == NULL) {\n        c = (void*)create_mock_cookie();\n    }\n\n    c->nblocks = 0;\n    ENGINE_ERROR_CODE ret = ENGINE_SUCCESS;\n    pthread_mutex_lock(&c->mutex);\n    while (ret == ENGINE_SUCCESS &&\n           (ret = me->the_engine->remove((ENGINE_HANDLE*)me->the_engine, c, key,\n                                         nkey, cas, vbucket)) == ENGINE_EWOULDBLOCK &&\n           c->handle_ewouldblock)\n    {\n        ++c->nblocks;\n        pthread_cond_wait(&c->cond, &c->mutex);\n        ret = c->status;\n    }\n    pthread_mutex_unlock(&c->mutex);\n\n    if (c != cookie) {\n        destroy_mock_cookie(c);\n    }\n\n    return ret;\n}\n\nstatic void mock_release(ENGINE_HANDLE* handle,\n                         const void *cookie,\n                         item* item) {\n    struct mock_engine *me = get_handle(handle);\n    me->the_engine->release((ENGINE_HANDLE*)me->the_engine, cookie, item);\n}\n\nstatic ENGINE_ERROR_CODE mock_get(ENGINE_HANDLE* handle,\n                                  const void* cookie,\n                                  item** item,\n                                  const void* key,\n                                  const int nkey,\n                                  uint16_t vbucket) {\n    struct mock_engine *me = get_handle(handle);\n    struct mock_connstruct *c = (void*)cookie;\n    if (c == NULL) {\n        c = (void*)create_mock_cookie();\n    }\n\n    c->nblocks = 0;\n    ENGINE_ERROR_CODE ret = ENGINE_SUCCESS;\n    pthread_mutex_lock(&c->mutex);\n    while (ret == ENGINE_SUCCESS &&\n           (ret = me->the_engine->get((ENGINE_HANDLE*)me->the_engine, c, item,\n                                      key, nkey, vbucket)) == ENGINE_EWOULDBLOCK &&\n           c->handle_ewouldblock)\n    {\n        ++c->nblocks;\n        pthread_cond_wait(&c->cond, &c->mutex);\n        ret = c->status;\n    }\n    pthread_mutex_unlock(&c->mutex);\n\n    if (c != cookie) {\n        destroy_mock_cookie(c);\n    }\n\n    return ret;\n}\n\nstatic ENGINE_ERROR_CODE mock_get_stats(ENGINE_HANDLE* handle,\n                                        const void* cookie,\n                                        const char* stat_key,\n                                        int nkey,\n                                        ADD_STAT add_stat)\n{\n    struct mock_engine *me = get_handle(handle);\n    struct mock_connstruct *c = (void*)cookie;\n    if (c == NULL) {\n        c = (void*)create_mock_cookie();\n    }\n\n    c->nblocks = 0;\n    ENGINE_ERROR_CODE ret = ENGINE_SUCCESS;\n    pthread_mutex_lock(&c->mutex);\n    while (ret == ENGINE_SUCCESS &&\n           (ret = me->the_engine->get_stats((ENGINE_HANDLE*)me->the_engine, c, stat_key,\n                                            nkey, add_stat)) == ENGINE_EWOULDBLOCK &&\n           c->handle_ewouldblock)\n    {\n        ++c->nblocks;\n        pthread_cond_wait(&c->cond, &c->mutex);\n        ret = c->status;\n    }\n    pthread_mutex_unlock(&c->mutex);\n\n    if (c != cookie) {\n        destroy_mock_cookie(c);\n    }\n\n    return ret;\n}\n\nstatic ENGINE_ERROR_CODE mock_store(ENGINE_HANDLE* handle,\n                                    const void *cookie,\n                                    item* item,\n                                    uint64_t *cas,\n                                    ENGINE_STORE_OPERATION operation,\n                                    uint16_t vbucket) {\n    struct mock_engine *me = get_handle(handle);\n    struct mock_connstruct *c = (void*)cookie;\n    if (c == NULL) {\n        c = (void*)create_mock_cookie();\n    }\n\n    c->nblocks = 0;\n    ENGINE_ERROR_CODE ret = ENGINE_SUCCESS;\n    pthread_mutex_lock(&c->mutex);\n    while (ret == ENGINE_SUCCESS &&\n           (ret = me->the_engine->store((ENGINE_HANDLE*)me->the_engine, c, item, cas,\n                                        operation, vbucket)) == ENGINE_EWOULDBLOCK &&\n           c->handle_ewouldblock)\n    {\n        ++c->nblocks;\n        pthread_cond_wait(&c->cond, &c->mutex);\n        ret = c->status;\n    }\n    pthread_mutex_unlock(&c->mutex);\n\n    if (c != cookie) {\n        destroy_mock_cookie(c);\n    }\n\n    return ret;\n}\n\nstatic ENGINE_ERROR_CODE mock_arithmetic(ENGINE_HANDLE* handle,\n                                         const void* cookie,\n                                         const void* key,\n                                         const int nkey,\n                                         const bool increment,\n                                         const bool create,\n                                         const uint64_t delta,\n                                         const uint64_t initial,\n                                         const rel_time_t exptime,\n                                         uint64_t *cas,\n                                         uint64_t *result,\n                                         uint16_t vbucket) {\n    struct mock_engine *me = get_handle(handle);\n    struct mock_connstruct *c = (void*)cookie;\n    if (c == NULL) {\n        c = (void*)create_mock_cookie();\n    }\n\n    c->nblocks = 0;\n    ENGINE_ERROR_CODE ret = ENGINE_SUCCESS;\n    pthread_mutex_lock(&c->mutex);\n    while (ret == ENGINE_SUCCESS &&\n           (ret = me->the_engine->arithmetic((ENGINE_HANDLE*)me->the_engine, c, key,\n                                             nkey, increment, create,\n                                             delta, initial, exptime,\n                                             cas, result, vbucket)) == ENGINE_EWOULDBLOCK &&\n           c->handle_ewouldblock)\n    {\n        ++c->nblocks;\n        pthread_cond_wait(&c->cond, &c->mutex);\n        ret = c->status;\n    }\n    pthread_mutex_unlock(&c->mutex);\n\n    if (c != cookie) {\n        destroy_mock_cookie(c);\n    }\n\n    return ret;\n}\n\nstatic ENGINE_ERROR_CODE mock_flush(ENGINE_HANDLE* handle,\n                                    const void* cookie, time_t when) {\n    struct mock_engine *me = get_handle(handle);\n    struct mock_connstruct *c = (void*)cookie;\n    if (c == NULL) {\n        c = (void*)create_mock_cookie();\n    }\n\n    c->nblocks = 0;\n    ENGINE_ERROR_CODE ret = ENGINE_SUCCESS;\n    pthread_mutex_lock(&c->mutex);\n    while (ret == ENGINE_SUCCESS &&\n           (ret = me->the_engine->flush((ENGINE_HANDLE*)me->the_engine, c, when)) == ENGINE_EWOULDBLOCK &&\n           c->handle_ewouldblock)\n    {\n        ++c->nblocks;\n        pthread_cond_wait(&c->cond, &c->mutex);\n        ret = c->status;\n    }\n    pthread_mutex_unlock(&c->mutex);\n\n    if (c != cookie) {\n        destroy_mock_cookie(c);\n    }\n\n    return ret;\n}\n\nstatic void mock_reset_stats(ENGINE_HANDLE* handle, const void *cookie) {\n    struct mock_engine *me = get_handle(handle);\n    me->the_engine->reset_stats((ENGINE_HANDLE*)me->the_engine, cookie);\n}\n\nstatic ENGINE_ERROR_CODE mock_unknown_command(ENGINE_HANDLE* handle,\n                                              const void* cookie,\n                                              protocol_binary_request_header *request,\n                                              ADD_RESPONSE response)\n{\n    struct mock_engine *me = get_handle(handle);\n    struct mock_connstruct *c = (void*)cookie;\n    if (c == NULL) {\n        c = (void*)create_mock_cookie();\n    }\n\n    c->nblocks = 0;\n    ENGINE_ERROR_CODE ret = ENGINE_SUCCESS;\n    pthread_mutex_lock(&c->mutex);\n    while (ret == ENGINE_SUCCESS &&\n           (ret = me->the_engine->unknown_command((ENGINE_HANDLE*)me->the_engine, c,\n                                                  request, response)) == ENGINE_EWOULDBLOCK &&\n           c->handle_ewouldblock)\n    {\n        ++c->nblocks;\n        pthread_cond_wait(&c->cond, &c->mutex);\n        ret = c->status;\n    }\n    pthread_mutex_unlock(&c->mutex);\n\n    if (c != cookie) {\n        destroy_mock_cookie(c);\n    }\n\n    return ret;\n}\n\nstatic void mock_item_set_cas(ENGINE_HANDLE *handle, const void *cookie,\n                              item* item, uint64_t val)\n{\n    struct mock_engine *me = get_handle(handle);\n    me->the_engine->item_set_cas((ENGINE_HANDLE*)me->the_engine, cookie, item, val);\n}\n\n\nstatic bool mock_get_item_info(ENGINE_HANDLE *handle, const void *cookie,\n                               const item* item, item_info *item_info)\n{\n    struct mock_engine *me = get_handle(handle);\n    return me->the_engine->get_item_info((ENGINE_HANDLE*)me->the_engine,\n                                         cookie, item, item_info);\n}\n\nstatic void *mock_get_stats_struct(ENGINE_HANDLE* handle, const void* cookie)\n{\n    struct mock_engine *me = get_handle(handle);\n    return me->the_engine->get_stats_struct((ENGINE_HANDLE*)me->the_engine, cookie);\n}\n\nstatic ENGINE_ERROR_CODE mock_aggregate_stats(ENGINE_HANDLE* handle,\n                                              const void* cookie,\n                                              void (*callback)(void*, void*),\n                                              void *vptr)\n{\n    struct mock_engine *me = get_handle(handle);\n    struct mock_connstruct *c = (void*)cookie;\n    if (c == NULL) {\n        c = (void*)create_mock_cookie();\n    }\n\n    c->nblocks = 0;\n    ENGINE_ERROR_CODE ret = ENGINE_SUCCESS;\n    pthread_mutex_lock(&c->mutex);\n    while (ret == ENGINE_SUCCESS &&\n           (ret = me->the_engine->aggregate_stats((ENGINE_HANDLE*)me->the_engine, c,\n                                                  callback, vptr)) == ENGINE_EWOULDBLOCK &&\n           c->handle_ewouldblock)\n    {\n        ++c->nblocks;\n        pthread_cond_wait(&c->cond, &c->mutex);\n        ret = c->status;\n    }\n    pthread_mutex_unlock(&c->mutex);\n\n    if (c != cookie) {\n        destroy_mock_cookie(c);\n    }\n\n    return ret;\n}\n\nstatic ENGINE_ERROR_CODE mock_tap_notify(ENGINE_HANDLE* handle,\n                                        const void *cookie,\n                                        void *engine_specific,\n                                        uint16_t nengine,\n                                        uint8_t ttl,\n                                        uint16_t tap_flags,\n                                        tap_event_t tap_event,\n                                        uint32_t tap_seqno,\n                                        const void *key,\n                                        size_t nkey,\n                                        uint32_t flags,\n                                        uint32_t exptime,\n                                        uint64_t cas,\n                                        const void *data,\n                                        size_t ndata,\n                                         uint16_t vbucket) {\n\n    struct mock_engine *me = get_handle(handle);\n    struct mock_connstruct *c = (void*)cookie;\n    if (c == NULL) {\n        c = (void*)create_mock_cookie();\n    }\n\n    c->nblocks = 0;\n    ENGINE_ERROR_CODE ret = ENGINE_SUCCESS;\n    pthread_mutex_lock(&c->mutex);\n    while (ret == ENGINE_SUCCESS &&\n           (ret = me->the_engine->tap_notify((ENGINE_HANDLE*)me->the_engine, c,\n                                             engine_specific, nengine, ttl, tap_flags,\n                                             tap_event, tap_seqno, key, nkey, flags,\n                                             exptime, cas, data, ndata, vbucket)) == ENGINE_EWOULDBLOCK &&\n           c->handle_ewouldblock)\n    {\n        ++c->nblocks;\n        pthread_cond_wait(&c->cond, &c->mutex);\n        ret = c->status;\n    }\n    pthread_mutex_unlock(&c->mutex);\n\n    if (c != cookie) {\n        destroy_mock_cookie(c);\n    }\n\n    return ret;\n}\n\n\nstatic TAP_ITERATOR mock_get_tap_iterator(ENGINE_HANDLE* handle, const void* cookie,\n                                           const void* client, size_t nclient,\n                                           uint32_t flags,\n                                           const void* userdata, size_t nuserdata) {\n    struct mock_engine *me = get_handle(handle);\n    me->iterator = me->the_engine->get_tap_iterator((ENGINE_HANDLE*)me->the_engine, cookie,\n                                                    client, nclient, flags, userdata, nuserdata);\n    return (me->iterator != NULL) ? mock_tap_iterator : NULL;\n}\n\nstatic size_t mock_errinfo(ENGINE_HANDLE *handle, const void* cookie,\n                           char *buffer, size_t buffsz) {\n    struct mock_engine *me = get_handle(handle);\n    return me->the_engine->errinfo((ENGINE_HANDLE*)me->the_engine, cookie,\n                                   buffer, buffsz);\n}\n\n\nstruct mock_engine default_mock_engine = {\n    .me = {\n        .interface = {\n            .interface = 1\n        },\n        .get_info = mock_get_info,\n        .initialize = mock_initialize,\n        .destroy = mock_destroy,\n        .allocate = mock_allocate,\n        .remove = mock_remove,\n        .release = mock_release,\n        .get = mock_get,\n        .store = mock_store,\n        .arithmetic = mock_arithmetic,\n        .flush = mock_flush,\n        .get_stats = mock_get_stats,\n        .reset_stats = mock_reset_stats,\n        .get_stats_struct = mock_get_stats_struct,\n        .aggregate_stats = mock_aggregate_stats,\n        .unknown_command = mock_unknown_command,\n        .tap_notify = mock_tap_notify,\n        .get_tap_iterator = mock_get_tap_iterator,\n        .item_set_cas = mock_item_set_cas,\n        .get_item_info = mock_get_item_info,\n        .errinfo = mock_errinfo\n    }\n};\nstruct mock_engine mock_engine;\n\nEXTENSION_LOGGER_DESCRIPTOR *logger_descriptor = NULL;\nstatic ENGINE_HANDLE *handle = NULL;\nstatic ENGINE_HANDLE_V1 *handle_v1 = NULL;\n\nstatic void usage(void) {\n    printf(\"\\n\");\n    printf(\"engine_testapp -E <path_to_engine_lib> -T <path_to_testlib>\\n\");\n    printf(\"               [-e <engine_config>] [-h]\\n\");\n    printf(\"\\n\");\n    printf(\"-E <path_to_engine_lib>      Path to the engine library file. The\\n\");\n    printf(\"                             engine library file is a library file\\n\");\n    printf(\"                             (.so or .dll) that the contains the \\n\");\n    printf(\"                             implementation of the engine being\\n\");\n    printf(\"                             tested.\\n\");\n    printf(\"\\n\");\n    printf(\"-T <path_to_testlib>         Path to the test library file. The test\\n\");\n    printf(\"                             library file is a library file (.so or\\n\");\n    printf(\"                             .dll) that contains the set of tests\\n\");\n    printf(\"                             to be executed.\\n\");\n    printf(\"\\n\");\n    printf(\"-t <timeout>                 Maximum time to run a test.\\n\");\n    printf(\"-e <engine_config>           Engine configuration string passed to\\n\");\n    printf(\"                             the engine.\\n\");\n    printf(\"-q                           Only print errors.\");\n    printf(\"-.                           Print a . for each executed test.\");\n    printf(\"\\n\");\n    printf(\"-h                           Prints this usage text.\\n\");\n    printf(\"\\n\");\n}\n\nstatic int report_test(const char *name, enum test_result r, bool quiet) {\n    int rc = 0;\n    char *msg = NULL;\n    bool color_enabled = getenv(\"TESTAPP_ENABLE_COLOR\") != NULL;\n    int color = 0;\n    char color_str[8] = { 0 };\n    char *reset_color = \"\\033[m\";\n    switch(r) {\n    case SUCCESS:\n        msg=\"OK\";\n        color = 32;\n        break;\n    case SKIPPED:\n        msg=\"SKIPPED\";\n        color = 32;\n        break;\n    case FAIL:\n        color = 31;\n        msg=\"FAIL\";\n        rc = 1;\n        break;\n    case DIED:\n        color = 31;\n        msg = \"DIED\";\n        rc = 1;\n        break;\n    case TIMEOUT:\n        color = 31;\n        msg = \"TIMED OUT\";\n        rc = 1;\n        break;\n    case CORE:\n        color = 31;\n        msg = \"CORE DUMPED\";\n        rc = 1;\n        break;\n    case PENDING:\n        color = 33;\n        msg = \"PENDING\";\n        break;\n    }\n    assert(msg);\n    if (color_enabled) {\n        snprintf(color_str, sizeof(color_str), \"\\033[%dm\", color);\n    }\n    if (quiet) {\n        if (r != SUCCESS) {\n            printf(\"%s:  %s%s%s\\n\", name, color_str, msg,\n                   color_enabled ? reset_color : \"\");\n            fflush(stdout);\n        }\n    } else {\n        printf(\"%s%s%s\\n\", color_str, msg, color_enabled ? reset_color : \"\");\n    }\n    return rc;\n}\n\nstatic ENGINE_HANDLE_V1 *start_your_engines(const char *engine, const char* cfg, bool engine_init) {\n\n    init_mock_server(handle);\n    if (!load_engine(engine, &get_mock_server_api, logger_descriptor, &handle)) {\n        fprintf(stderr, \"Failed to load engine %s.\\n\", engine);\n        return NULL;\n    }\n\n    if (engine_init) {\n        if(!init_engine(handle, cfg, logger_descriptor)) {\n            fprintf(stderr, \"Failed to init engine %s with config %s.\\n\", engine, cfg);\n            return NULL;\n        }\n    }\n\n    mock_engine = default_mock_engine;\n    handle_v1 = mock_engine.the_engine = (ENGINE_HANDLE_V1*)handle;\n    handle = (ENGINE_HANDLE*)&mock_engine.me;\n    handle_v1 = &mock_engine.me;\n\n    // Reset all members that aren't set (to allow the users to write\n    // testcases to verify that they initialize them..\n    assert(mock_engine.me.interface.interface == mock_engine.the_engine->interface.interface);\n\n    if (mock_engine.the_engine->get_stats_struct == NULL) {\n        mock_engine.me.get_stats_struct = NULL;\n    }\n    if (mock_engine.the_engine->aggregate_stats == NULL) {\n        mock_engine.me.aggregate_stats = NULL;\n    }\n    if (mock_engine.the_engine->unknown_command == NULL) {\n        mock_engine.me.unknown_command = NULL;\n    }\n    if (mock_engine.the_engine->tap_notify == NULL) {\n        mock_engine.me.tap_notify = NULL;\n    }\n    if (mock_engine.the_engine->get_tap_iterator == NULL) {\n        mock_engine.me.get_tap_iterator = NULL;\n    }\n    if (mock_engine.the_engine->errinfo == NULL) {\n        mock_engine.me.errinfo = NULL;\n    }\n\n    return &mock_engine.me;\n}\n\nstatic void destroy_engine(bool force) {\n    if (handle_v1) {\n        handle_v1->destroy(handle, force);\n        handle_v1 = NULL;\n        handle = NULL;\n    }\n}\n\nstatic void reload_engine(ENGINE_HANDLE **h, ENGINE_HANDLE_V1 **h1,\n                          const char* engine, const char *cfg, bool init, bool force) {\n    destroy_engine(force);\n    handle_v1 = start_your_engines(engine, cfg, init);\n    handle = (ENGINE_HANDLE*)(handle_v1);\n    *h1 = handle_v1;\n    *h = handle;\n}\n\nstatic enum test_result run_test(engine_test_t test, const char *engine, const char *default_cfg) {\n    enum test_result ret = PENDING;\n    if (test.tfun != NULL) {\n#if !defined(USE_GCOV) && !defined(WIN32)\n        pid_t pid = fork();\n        if (pid == 0) {\n#endif\n            /* Start the engines and go */\n            start_your_engines(engine, test.cfg ? test.cfg : default_cfg, true);\n            if (test.test_setup != NULL) {\n                if (!test.test_setup(handle, handle_v1)) {\n                    fprintf(stderr, \"Failed to run setup for test %s\\n\", test.name);\n                    return FAIL;\n                }\n            }\n            ret = test.tfun(handle, handle_v1);\n            if (test.test_teardown != NULL) {\n                if (!test.test_teardown(handle, handle_v1)) {\n                    fprintf(stderr, \"WARNING: Failed to run teardown for test %s\\n\", test.name);\n                }\n            }\n            destroy_engine(false);\n#if !defined(USE_GCOV) && !defined(WIN32)\n            exit((int)ret);\n        } else if (pid == (pid_t)-1) {\n            ret = FAIL;\n        } else {\n            int rc;\n            while (alarmed == 0 && waitpid(pid, &rc, 0) == (pid_t)-1) {\n                if (errno != EINTR) {\n                    abort();\n                }\n            }\n\n            if (alarmed) {\n                kill(pid, 9);\n                ret = TIMEOUT;\n            } else if (WIFEXITED(rc)) {\n                ret = (enum test_result)WEXITSTATUS(rc);\n            } else if (WIFSIGNALED(rc) && WCOREDUMP(rc)) {\n                ret = CORE;\n            } else {\n                ret = DIED;\n            }\n        }\n#endif\n    }\n\n    return ret;\n}\n\nstatic void setup_alarm_handler() {\n#ifndef WIN32\n    struct sigaction sig_handler;\n\n    sig_handler.sa_handler = alarm_handler;\n    sig_handler.sa_flags = 0;\n\n    sigaction(SIGALRM, &sig_handler, NULL);\n#endif\n}\n\nstatic void set_test_timeout(int timeout) {\n#ifndef WIN32\n    alarm(timeout);\n#endif\n}\n\nstatic void clear_test_timeout() {\n#ifndef WIN32\n    alarm(0);\n    alarmed = 0;\n#endif\n}\n\nint main(int argc, char **argv) {\n    int c, exitcode = 0, num_cases = 0, timeout = 0;\n    bool quiet = false;\n    bool dot = false;\n    const char *engine = NULL;\n    const char *engine_args = NULL;\n    const char *test_suite = NULL;\n    const char *test_case = NULL;\n    engine_test_t *testcases = NULL;\n    logger_descriptor = get_null_logger();\n\n    /* Hack to remove the warning from C99 */\n    union {\n        GET_TESTS get_tests;\n        void* voidptr;\n    } my_get_test = {.get_tests = NULL };\n\n    /* Hack to remove the warning from C99 */\n    union {\n        SETUP_SUITE setup_suite;\n        void* voidptr;\n    } my_setup_suite = {.setup_suite = NULL };\n\n    /* Hack to remove the warning from C99 */\n    union {\n        TEARDOWN_SUITE teardown_suite;\n        void* voidptr;\n    } my_teardown_suite = {.teardown_suite = NULL };\n\n\n    /* Use unbuffered stdio */\n    setbuf(stdout, NULL);\n    setbuf(stderr, NULL);\n\n    setup_alarm_handler();\n\n    /* process arguments */\n    while (-1 != (c = getopt(argc, argv,\n          \"h\"  /* usage */\n          \"E:\" /* Engine to load */\n          \"e:\" /* Engine options */\n          \"T:\" /* Library with tests to load */\n          \"t:\" /* Timeout */\n          \"q\"  /* Be more quiet (only report failures) */\n          \".\"  /* dot mode. */\n          \"n:\"  /* test case to run */\n        ))) {\n        switch (c) {\n        case 'E':\n            engine = optarg;\n            break;\n        case 'e':\n            engine_args = optarg;\n            break;\n        case 'h':\n            usage();\n            return 0;\n        case 'T':\n            test_suite = optarg;\n            break;\n        case 't':\n            timeout = atoi(optarg);\n            break;\n        case 'n':\n            test_case = optarg;\n            break;\n        case 'q':\n            quiet = true;\n            break;\n        case '.':\n            dot = true;\n            break;\n        default:\n            fprintf(stderr, \"Illegal argument \\\"%c\\\"\\n\", c);\n            return 1;\n        }\n    }\n\n    //validate args\n    if (engine == NULL) {\n        fprintf(stderr, \"You must provide a path to the storage engine library.\\n\");\n        return 1;\n    }\n\n    if (test_suite == NULL) {\n        fprintf(stderr, \"You must provide a path to the testsuite library.\\n\");\n        return 1;\n    }\n\n    //load test_suite\n    void* handle = dlopen(test_suite, RTLD_NOW | RTLD_LOCAL);\n    if (handle == NULL) {\n        const char *msg = dlerror();\n        fprintf(stderr, \"Failed to load testsuite %s: %s\\n\", test_suite, msg ? msg : \"unknown error\");\n        return 1;\n    }\n\n    //get the test cases\n    void *symbol = dlsym(handle, \"get_tests\");\n    if (symbol == NULL) {\n        const char *msg = dlerror();\n        fprintf(stderr, \"Could not find get_tests function in testsuite %s: %s\\n\", test_suite, msg ? msg : \"unknown error\");\n        return 1;\n    }\n    my_get_test.voidptr = symbol;\n    testcases = (*my_get_test.get_tests)();\n\n    //set up the suite if needed\n    struct test_harness harness = { .default_engine_cfg = engine_args,\n                                    .engine_path = engine,\n                                    .reload_engine = reload_engine,\n                                    .start_engine = start_your_engines,\n                                    .create_cookie = create_mock_cookie,\n                                    .destroy_cookie = destroy_mock_cookie,\n                                    .set_ewouldblock_handling = mock_set_ewouldblock_handling,\n                                    .lock_cookie = lock_mock_cookie,\n                                    .unlock_cookie = unlock_mock_cookie,\n                                    .waitfor_cookie = waitfor_mock_cookie,\n                                    .time_travel = mock_time_travel };\n    symbol = dlsym(handle, \"setup_suite\");\n    if (symbol != NULL) {\n        my_setup_suite.voidptr = symbol;\n        if (!(*my_setup_suite.setup_suite)(&harness)) {\n            fprintf(stderr, \"Failed to set up test suite %s \\n\", test_suite);\n            return 1;\n        }\n    }\n\n\n    for (num_cases = 0; testcases[num_cases].name; num_cases++) {\n        /* Just counting */\n    }\n\n    if (!quiet) {\n        printf(\"1..%d\\n\", num_cases);\n    }\n\n    int i;\n    bool need_newline = false;\n    for (i = 0; testcases[i].name; i++) {\n        if (test_case != NULL && strcmp(test_case, testcases[i].name) != 0)\n            continue;\n        if (!quiet) {\n            printf(\"Running %s... \", testcases[i].name);\n            fflush(stdout);\n        } else if(dot) {\n            printf(\".\");\n            need_newline = true;\n            /* Add a newline every few tests */\n            if ((i+1) % 70 == 0) {\n                printf(\"\\n\");\n                need_newline = false;\n            }\n        }\n        set_test_timeout(timeout);\n        exitcode += report_test(testcases[i].name,\n                                run_test(testcases[i], engine, engine_args),\n                                quiet);\n        clear_test_timeout();\n    }\n\n    if (need_newline) {\n        printf(\"\\n\");\n    }\n\n    //tear down the suite if needed\n    symbol = dlsym(handle, \"teardown_suite\");\n    if (symbol != NULL) {\n        my_teardown_suite.voidptr = symbol;\n        if (!(*my_teardown_suite.teardown_suite)()) {\n            fprintf(stderr, \"Failed to teardown up test suite %s \\n\", test_suite);\n        }\n    }\n\n    printf(\"# Passed %d of %d tests\\n\", num_cases - exitcode, num_cases);\n\n    return exitcode;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/plugin/innodb_memcached/daemon_memcached/win32/dlfcn.h": "#ifndef DLFCN_H\n#define DLFCN_H\nvoid* dlopen(const char* path, int mode);\nvoid* dlsym(void* handle, const char* symbol);\nint dlclose(void* handle);\nconst char *dlerror(void);\n\n#define RTLD_LAZY 1\n#define RTLD_LOCAL 2\n\n#define RTLD_NOW 0x00002\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/plugin/innodb_memcached/daemon_memcached/win32/dlfcn.c": "/* -*- Mode: C; tab-width: 4; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n#include <stdio.h>\n#include <windows.h>\n#include <dlfcn.h>\n#include <stdbool.h>\n\n/*\n * Keep track if the user tried to call dlopen(NULL, xx) to be able to give a sane\n * error message\n */\nstatic bool self = false;\n\nvoid* dlopen(const char* path, int mode) {\n    if (path == NULL) {\n        // We don't support opening ourself\n        self = true;\n        return NULL;\n    }\n\n    void* handle = LoadLibrary(path);\n    if (handle == NULL) {\n        char *buf = malloc(strlen(path) + 20);\n        sprintf(buf, \"%s.dll\", path);\n        handle = LoadLibrary(buf);\n        free(buf);\n    }\n\n    return handle;\n}\n\nvoid* dlsym(void* handle, const char* symbol) {\n    return GetProcAddress(handle, symbol);\n}\n\nint dlclose(void* handle) {\n    // dlclose returns zero on success.\n    // FreeLibrary returns nonzero on success.\n    return FreeLibrary(handle) != 0;\n}\n\nstatic char dlerror_buf[200];\n\nconst char *dlerror(void) {\n    if (self) {\n        return \"not supported\";\n    }\n\n    DWORD err = GetLastError();\n    LPVOID error_msg;\n    if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |\n                      FORMAT_MESSAGE_FROM_SYSTEM |\n                      FORMAT_MESSAGE_IGNORE_INSERTS,\n                      NULL, err, 0, (LPTSTR)&error_msg, 0, NULL) != 0) {\n        strncpy(dlerror_buf, error_msg, sizeof(dlerror_buf));\n        dlerror_buf[sizeof(dlerror_buf) - 1] = '\\0';\n        LocalFree(error_msg);\n    } else {\n        return \"Failed to get error message\";\n    }\n\n    return dlerror_buf;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/extra/libedit/libedit-20190324-3.1/ltmain.sh": "#! /bin/sh\n## DO NOT EDIT - This file generated from ./build-aux/ltmain.in\n##               by inline-source v2014-01-03.01\n\n# libtool (GNU libtool) 2.4.6\n# Provide generalized library-building support services.\n# Written by Gordon Matzigkeit <gord@gnu.ai.mit.edu>, 1996\n\n# Copyright (C) 1996-2015 Free Software Foundation, Inc.\n# This is free software; see the source for copying conditions.  There is NO\n# warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\n# GNU Libtool is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation; either version 2 of the License, or\n# (at your option) any later version.\n#\n# As a special exception to the GNU General Public License,\n# if you distribute this file as part of a program or library that\n# is built using GNU Libtool, you may include this file under the\n# same distribution terms that you use for the rest of that program.\n#\n# GNU Libtool is distributed in the hope that it will be useful, but\n# WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n# General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n\nPROGRAM=libtool\nPACKAGE=libtool\nVERSION=2.4.6\npackage_revision=2.4.6\n\n\n## ------ ##\n## Usage. ##\n## ------ ##\n\n# Run './libtool --help' for help with using this script from the\n# command line.\n\n\n## ------------------------------- ##\n## User overridable command paths. ##\n## ------------------------------- ##\n\n# After configure completes, it has a better idea of some of the\n# shell tools we need than the defaults used by the functions shared\n# with bootstrap, so set those here where they can still be over-\n# ridden by the user, but otherwise take precedence.\n\n: ${AUTOCONF=\"autoconf\"}\n: ${AUTOMAKE=\"automake\"}\n\n\n## -------------------------- ##\n## Source external libraries. ##\n## -------------------------- ##\n\n# Much of our low-level functionality needs to be sourced from external\n# libraries, which are installed to $pkgauxdir.\n\n# Set a version string for this script.\nscriptversion=2015-01-20.17; # UTC\n\n# General shell script boiler plate, and helper functions.\n# Written by Gary V. Vaughan, 2004\n\n# Copyright (C) 2004-2015 Free Software Foundation, Inc.\n# This is free software; see the source for copying conditions.  There is NO\n# warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\n# This program is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation; either version 3 of the License, or\n# (at your option) any later version.\n\n# As a special exception to the GNU General Public License, if you distribute\n# this file as part of a program or library that is built using GNU Libtool,\n# you may include this file under the same distribution terms that you use\n# for the rest of that program.\n\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNES FOR A PARTICULAR PURPOSE. See the GNU\n# General Public License for more details.\n\n# You should have received a copy of the GNU General Public License\n# along with this program. If not, see <http://www.gnu.org/licenses/>.\n\n# Please report bugs or propose patches to gary@gnu.org.\n\n\n## ------ ##\n## Usage. ##\n## ------ ##\n\n# Evaluate this file near the top of your script to gain access to\n# the functions and variables defined here:\n#\n#   . `echo \"$0\" | ${SED-sed} 's|[^/]*$||'`/build-aux/funclib.sh\n#\n# If you need to override any of the default environment variable\n# settings, do that before evaluating this file.\n\n\n## -------------------- ##\n## Shell normalisation. ##\n## -------------------- ##\n\n# Some shells need a little help to be as Bourne compatible as possible.\n# Before doing anything else, make sure all that help has been provided!\n\nDUALCASE=1; export DUALCASE # for MKS sh\nif test -n \"${ZSH_VERSION+set}\" && (emulate sh) >/dev/null 2>&1; then :\n  emulate sh\n  NULLCMD=:\n  # Pre-4.2 versions of Zsh do word splitting on ${1+\"$@\"}, which\n  # is contrary to our usage.  Disable this feature.\n  alias -g '${1+\"$@\"}'='\"$@\"'\n  setopt NO_GLOB_SUBST\nelse\n  case `(set -o) 2>/dev/null` in *posix*) set -o posix ;; esac\nfi\n\n# NLS nuisances: We save the old values in case they are required later.\n_G_user_locale=\n_G_safe_locale=\nfor _G_var in LANG LANGUAGE LC_ALL LC_CTYPE LC_COLLATE LC_MESSAGES\ndo\n  eval \"if test set = \\\"\\${$_G_var+set}\\\"; then\n          save_$_G_var=\\$$_G_var\n          $_G_var=C\n\t  export $_G_var\n\t  _G_user_locale=\\\"$_G_var=\\\\\\$save_\\$_G_var; \\$_G_user_locale\\\"\n\t  _G_safe_locale=\\\"$_G_var=C; \\$_G_safe_locale\\\"\n\tfi\"\ndone\n\n# CDPATH.\n(unset CDPATH) >/dev/null 2>&1 && unset CDPATH\n\n# Make sure IFS has a sensible default\nsp=' '\nnl='\n'\nIFS=\"$sp\t$nl\"\n\n# There are apparently some retarded systems that use ';' as a PATH separator!\nif test \"${PATH_SEPARATOR+set}\" != set; then\n  PATH_SEPARATOR=:\n  (PATH='/bin;/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 && {\n    (PATH='/bin:/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 ||\n      PATH_SEPARATOR=';'\n  }\nfi\n\n\n\n## ------------------------- ##\n## Locate command utilities. ##\n## ------------------------- ##\n\n\n# func_executable_p FILE\n# ----------------------\n# Check that FILE is an executable regular file.\nfunc_executable_p ()\n{\n    test -f \"$1\" && test -x \"$1\"\n}\n\n\n# func_path_progs PROGS_LIST CHECK_FUNC [PATH]\n# --------------------------------------------\n# Search for either a program that responds to --version with output\n# containing \"GNU\", or else returned by CHECK_FUNC otherwise, by\n# trying all the directories in PATH with each of the elements of\n# PROGS_LIST.\n#\n# CHECK_FUNC should accept the path to a candidate program, and\n# set $func_check_prog_result if it truncates its output less than\n# $_G_path_prog_max characters.\nfunc_path_progs ()\n{\n    _G_progs_list=$1\n    _G_check_func=$2\n    _G_PATH=${3-\"$PATH\"}\n\n    _G_path_prog_max=0\n    _G_path_prog_found=false\n    _G_save_IFS=$IFS; IFS=${PATH_SEPARATOR-:}\n    for _G_dir in $_G_PATH; do\n      IFS=$_G_save_IFS\n      test -z \"$_G_dir\" && _G_dir=.\n      for _G_prog_name in $_G_progs_list; do\n        for _exeext in '' .EXE; do\n          _G_path_prog=$_G_dir/$_G_prog_name$_exeext\n          func_executable_p \"$_G_path_prog\" || continue\n          case `\"$_G_path_prog\" --version 2>&1` in\n            *GNU*) func_path_progs_result=$_G_path_prog _G_path_prog_found=: ;;\n            *)     $_G_check_func $_G_path_prog\n\t\t   func_path_progs_result=$func_check_prog_result\n\t\t   ;;\n          esac\n          $_G_path_prog_found && break 3\n        done\n      done\n    done\n    IFS=$_G_save_IFS\n    test -z \"$func_path_progs_result\" && {\n      echo \"no acceptable sed could be found in \\$PATH\" >&2\n      exit 1\n    }\n}\n\n\n# We want to be able to use the functions in this file before configure\n# has figured out where the best binaries are kept, which means we have\n# to search for them ourselves - except when the results are already set\n# where we skip the searches.\n\n# Unless the user overrides by setting SED, search the path for either GNU\n# sed, or the sed that truncates its output the least.\ntest -z \"$SED\" && {\n  _G_sed_script=s/aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa/bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb/\n  for _G_i in 1 2 3 4 5 6 7; do\n    _G_sed_script=$_G_sed_script$nl$_G_sed_script\n  done\n  echo \"$_G_sed_script\" 2>/dev/null | sed 99q >conftest.sed\n  _G_sed_script=\n\n  func_check_prog_sed ()\n  {\n    _G_path_prog=$1\n\n    _G_count=0\n    printf 0123456789 >conftest.in\n    while :\n    do\n      cat conftest.in conftest.in >conftest.tmp\n      mv conftest.tmp conftest.in\n      cp conftest.in conftest.nl\n      echo '' >> conftest.nl\n      \"$_G_path_prog\" -f conftest.sed <conftest.nl >conftest.out 2>/dev/null || break\n      diff conftest.out conftest.nl >/dev/null 2>&1 || break\n      _G_count=`expr $_G_count + 1`\n      if test \"$_G_count\" -gt \"$_G_path_prog_max\"; then\n        # Best one so far, save it but keep looking for a better one\n        func_check_prog_result=$_G_path_prog\n        _G_path_prog_max=$_G_count\n      fi\n      # 10*(2^10) chars as input seems more than enough\n      test 10 -lt \"$_G_count\" && break\n    done\n    rm -f conftest.in conftest.tmp conftest.nl conftest.out\n  }\n\n  func_path_progs \"sed gsed\" func_check_prog_sed $PATH:/usr/xpg4/bin\n  rm -f conftest.sed\n  SED=$func_path_progs_result\n}\n\n\n# Unless the user overrides by setting GREP, search the path for either GNU\n# grep, or the grep that truncates its output the least.\ntest -z \"$GREP\" && {\n  func_check_prog_grep ()\n  {\n    _G_path_prog=$1\n\n    _G_count=0\n    _G_path_prog_max=0\n    printf 0123456789 >conftest.in\n    while :\n    do\n      cat conftest.in conftest.in >conftest.tmp\n      mv conftest.tmp conftest.in\n      cp conftest.in conftest.nl\n      echo 'GREP' >> conftest.nl\n      \"$_G_path_prog\" -e 'GREP$' -e '-(cannot match)-' <conftest.nl >conftest.out 2>/dev/null || break\n      diff conftest.out conftest.nl >/dev/null 2>&1 || break\n      _G_count=`expr $_G_count + 1`\n      if test \"$_G_count\" -gt \"$_G_path_prog_max\"; then\n        # Best one so far, save it but keep looking for a better one\n        func_check_prog_result=$_G_path_prog\n        _G_path_prog_max=$_G_count\n      fi\n      # 10*(2^10) chars as input seems more than enough\n      test 10 -lt \"$_G_count\" && break\n    done\n    rm -f conftest.in conftest.tmp conftest.nl conftest.out\n  }\n\n  func_path_progs \"grep ggrep\" func_check_prog_grep $PATH:/usr/xpg4/bin\n  GREP=$func_path_progs_result\n}\n\n\n## ------------------------------- ##\n## User overridable command paths. ##\n## ------------------------------- ##\n\n# All uppercase variable names are used for environment variables.  These\n# variables can be overridden by the user before calling a script that\n# uses them if a suitable command of that name is not already available\n# in the command search PATH.\n\n: ${CP=\"cp -f\"}\n: ${ECHO=\"printf %s\\n\"}\n: ${EGREP=\"$GREP -E\"}\n: ${FGREP=\"$GREP -F\"}\n: ${LN_S=\"ln -s\"}\n: ${MAKE=\"make\"}\n: ${MKDIR=\"mkdir\"}\n: ${MV=\"mv -f\"}\n: ${RM=\"rm -f\"}\n: ${SHELL=\"${CONFIG_SHELL-/bin/sh}\"}\n\n\n## -------------------- ##\n## Useful sed snippets. ##\n## -------------------- ##\n\nsed_dirname='s|/[^/]*$||'\nsed_basename='s|^.*/||'\n\n# Sed substitution that helps us do robust quoting.  It backslashifies\n# metacharacters that are still active within double-quoted strings.\nsed_quote_subst='s|\\([`\"$\\\\]\\)|\\\\\\1|g'\n\n# Same as above, but do not quote variable references.\nsed_double_quote_subst='s/\\([\"`\\\\]\\)/\\\\\\1/g'\n\n# Sed substitution that turns a string into a regex matching for the\n# string literally.\nsed_make_literal_regex='s|[].[^$\\\\*\\/]|\\\\&|g'\n\n# Sed substitution that converts a w32 file name or path\n# that contains forward slashes, into one that contains\n# (escaped) backslashes.  A very naive implementation.\nsed_naive_backslashify='s|\\\\\\\\*|\\\\|g;s|/|\\\\|g;s|\\\\|\\\\\\\\|g'\n\n# Re-'\\' parameter expansions in output of sed_double_quote_subst that\n# were '\\'-ed in input to the same.  If an odd number of '\\' preceded a\n# '$' in input to sed_double_quote_subst, that '$' was protected from\n# expansion.  Since each input '\\' is now two '\\'s, look for any number\n# of runs of four '\\'s followed by two '\\'s and then a '$'.  '\\' that '$'.\n_G_bs='\\\\'\n_G_bs2='\\\\\\\\'\n_G_bs4='\\\\\\\\\\\\\\\\'\n_G_dollar='\\$'\nsed_double_backslash=\"\\\n  s/$_G_bs4/&\\\\\n/g\n  s/^$_G_bs2$_G_dollar/$_G_bs&/\n  s/\\\\([^$_G_bs]\\\\)$_G_bs2$_G_dollar/\\\\1$_G_bs2$_G_bs$_G_dollar/g\n  s/\\n//g\"\n\n\n## ----------------- ##\n## Global variables. ##\n## ----------------- ##\n\n# Except for the global variables explicitly listed below, the following\n# functions in the '^func_' namespace, and the '^require_' namespace\n# variables initialised in the 'Resource management' section, sourcing\n# this file will not pollute your global namespace with anything\n# else. There's no portable way to scope variables in Bourne shell\n# though, so actually running these functions will sometimes place\n# results into a variable named after the function, and often use\n# temporary variables in the '^_G_' namespace. If you are careful to\n# avoid using those namespaces casually in your sourcing script, things\n# should continue to work as you expect. And, of course, you can freely\n# overwrite any of the functions or variables defined here before\n# calling anything to customize them.\n\nEXIT_SUCCESS=0\nEXIT_FAILURE=1\nEXIT_MISMATCH=63  # $? = 63 is used to indicate version mismatch to missing.\nEXIT_SKIP=77\t  # $? = 77 is used to indicate a skipped test to automake.\n\n# Allow overriding, eg assuming that you follow the convention of\n# putting '$debug_cmd' at the start of all your functions, you can get\n# bash to show function call trace with:\n#\n#    debug_cmd='eval echo \"${FUNCNAME[0]} $*\" >&2' bash your-script-name\ndebug_cmd=${debug_cmd-\":\"}\nexit_cmd=:\n\n# By convention, finish your script with:\n#\n#    exit $exit_status\n#\n# so that you can set exit_status to non-zero if you want to indicate\n# something went wrong during execution without actually bailing out at\n# the point of failure.\nexit_status=$EXIT_SUCCESS\n\n# Work around backward compatibility issue on IRIX 6.5. On IRIX 6.4+, sh\n# is ksh but when the shell is invoked as \"sh\" and the current value of\n# the _XPG environment variable is not equal to 1 (one), the special\n# positional parameter $0, within a function call, is the name of the\n# function.\nprogpath=$0\n\n# The name of this program.\nprogname=`$ECHO \"$progpath\" |$SED \"$sed_basename\"`\n\n# Make sure we have an absolute progpath for reexecution:\ncase $progpath in\n  [\\\\/]*|[A-Za-z]:\\\\*) ;;\n  *[\\\\/]*)\n     progdir=`$ECHO \"$progpath\" |$SED \"$sed_dirname\"`\n     progdir=`cd \"$progdir\" && pwd`\n     progpath=$progdir/$progname\n     ;;\n  *)\n     _G_IFS=$IFS\n     IFS=${PATH_SEPARATOR-:}\n     for progdir in $PATH; do\n       IFS=$_G_IFS\n       test -x \"$progdir/$progname\" && break\n     done\n     IFS=$_G_IFS\n     test -n \"$progdir\" || progdir=`pwd`\n     progpath=$progdir/$progname\n     ;;\nesac\n\n\n## ----------------- ##\n## Standard options. ##\n## ----------------- ##\n\n# The following options affect the operation of the functions defined\n# below, and should be set appropriately depending on run-time para-\n# meters passed on the command line.\n\nopt_dry_run=false\nopt_quiet=false\nopt_verbose=false\n\n# Categories 'all' and 'none' are always available.  Append any others\n# you will pass as the first argument to func_warning from your own\n# code.\nwarning_categories=\n\n# By default, display warnings according to 'opt_warning_types'.  Set\n# 'warning_func'  to ':' to elide all warnings, or func_fatal_error to\n# treat the next displayed warning as a fatal error.\nwarning_func=func_warn_and_continue\n\n# Set to 'all' to display all warnings, 'none' to suppress all\n# warnings, or a space delimited list of some subset of\n# 'warning_categories' to display only the listed warnings.\nopt_warning_types=all\n\n\n## -------------------- ##\n## Resource management. ##\n## -------------------- ##\n\n# This section contains definitions for functions that each ensure a\n# particular resource (a file, or a non-empty configuration variable for\n# example) is available, and if appropriate to extract default values\n# from pertinent package files. Call them using their associated\n# 'require_*' variable to ensure that they are executed, at most, once.\n#\n# It's entirely deliberate that calling these functions can set\n# variables that don't obey the namespace limitations obeyed by the rest\n# of this file, in order that that they be as useful as possible to\n# callers.\n\n\n# require_term_colors\n# -------------------\n# Allow display of bold text on terminals that support it.\nrequire_term_colors=func_require_term_colors\nfunc_require_term_colors ()\n{\n    $debug_cmd\n\n    test -t 1 && {\n      # COLORTERM and USE_ANSI_COLORS environment variables take\n      # precedence, because most terminfo databases neglect to describe\n      # whether color sequences are supported.\n      test -n \"${COLORTERM+set}\" && : ${USE_ANSI_COLORS=\"1\"}\n\n      if test 1 = \"$USE_ANSI_COLORS\"; then\n        # Standard ANSI escape sequences\n        tc_reset='\u001b[0m'\n        tc_bold='\u001b[1m';   tc_standout='\u001b[7m'\n        tc_red='\u001b[31m';   tc_green='\u001b[32m'\n        tc_blue='\u001b[34m';  tc_cyan='\u001b[36m'\n      else\n        # Otherwise trust the terminfo database after all.\n        test -n \"`tput sgr0 2>/dev/null`\" && {\n          tc_reset=`tput sgr0`\n          test -n \"`tput bold 2>/dev/null`\" && tc_bold=`tput bold`\n          tc_standout=$tc_bold\n          test -n \"`tput smso 2>/dev/null`\" && tc_standout=`tput smso`\n          test -n \"`tput setaf 1 2>/dev/null`\" && tc_red=`tput setaf 1`\n          test -n \"`tput setaf 2 2>/dev/null`\" && tc_green=`tput setaf 2`\n          test -n \"`tput setaf 4 2>/dev/null`\" && tc_blue=`tput setaf 4`\n          test -n \"`tput setaf 5 2>/dev/null`\" && tc_cyan=`tput setaf 5`\n        }\n      fi\n    }\n\n    require_term_colors=:\n}\n\n\n## ----------------- ##\n## Function library. ##\n## ----------------- ##\n\n# This section contains a variety of useful functions to call in your\n# scripts. Take note of the portable wrappers for features provided by\n# some modern shells, which will fall back to slower equivalents on\n# less featureful shells.\n\n\n# func_append VAR VALUE\n# ---------------------\n# Append VALUE onto the existing contents of VAR.\n\n  # We should try to minimise forks, especially on Windows where they are\n  # unreasonably slow, so skip the feature probes when bash or zsh are\n  # being used:\n  if test set = \"${BASH_VERSION+set}${ZSH_VERSION+set}\"; then\n    : ${_G_HAVE_ARITH_OP=\"yes\"}\n    : ${_G_HAVE_XSI_OPS=\"yes\"}\n    # The += operator was introduced in bash 3.1\n    case $BASH_VERSION in\n      [12].* | 3.0 | 3.0*) ;;\n      *)\n        : ${_G_HAVE_PLUSEQ_OP=\"yes\"}\n        ;;\n    esac\n  fi\n\n  # _G_HAVE_PLUSEQ_OP\n  # Can be empty, in which case the shell is probed, \"yes\" if += is\n  # useable or anything else if it does not work.\n  test -z \"$_G_HAVE_PLUSEQ_OP\" \\\n    && (eval 'x=a; x+=\" b\"; test \"a b\" = \"$x\"') 2>/dev/null \\\n    && _G_HAVE_PLUSEQ_OP=yes\n\nif test yes = \"$_G_HAVE_PLUSEQ_OP\"\nthen\n  # This is an XSI compatible shell, allowing a faster implementation...\n  eval 'func_append ()\n  {\n    $debug_cmd\n\n    eval \"$1+=\\$2\"\n  }'\nelse\n  # ...otherwise fall back to using expr, which is often a shell builtin.\n  func_append ()\n  {\n    $debug_cmd\n\n    eval \"$1=\\$$1\\$2\"\n  }\nfi\n\n\n# func_append_quoted VAR VALUE\n# ----------------------------\n# Quote VALUE and append to the end of shell variable VAR, separated\n# by a space.\nif test yes = \"$_G_HAVE_PLUSEQ_OP\"; then\n  eval 'func_append_quoted ()\n  {\n    $debug_cmd\n\n    func_quote_for_eval \"$2\"\n    eval \"$1+=\\\\ \\$func_quote_for_eval_result\"\n  }'\nelse\n  func_append_quoted ()\n  {\n    $debug_cmd\n\n    func_quote_for_eval \"$2\"\n    eval \"$1=\\$$1\\\\ \\$func_quote_for_eval_result\"\n  }\nfi\n\n\n# func_append_uniq VAR VALUE\n# --------------------------\n# Append unique VALUE onto the existing contents of VAR, assuming\n# entries are delimited by the first character of VALUE.  For example:\n#\n#   func_append_uniq options \" --another-option option-argument\"\n#\n# will only append to $options if \" --another-option option-argument \"\n# is not already present somewhere in $options already (note spaces at\n# each end implied by leading space in second argument).\nfunc_append_uniq ()\n{\n    $debug_cmd\n\n    eval _G_current_value='`$ECHO $'$1'`'\n    _G_delim=`expr \"$2\" : '\\(.\\)'`\n\n    case $_G_delim$_G_current_value$_G_delim in\n      *\"$2$_G_delim\"*) ;;\n      *) func_append \"$@\" ;;\n    esac\n}\n\n\n# func_arith TERM...\n# ------------------\n# Set func_arith_result to the result of evaluating TERMs.\n  test -z \"$_G_HAVE_ARITH_OP\" \\\n    && (eval 'test 2 = $(( 1 + 1 ))') 2>/dev/null \\\n    && _G_HAVE_ARITH_OP=yes\n\nif test yes = \"$_G_HAVE_ARITH_OP\"; then\n  eval 'func_arith ()\n  {\n    $debug_cmd\n\n    func_arith_result=$(( $* ))\n  }'\nelse\n  func_arith ()\n  {\n    $debug_cmd\n\n    func_arith_result=`expr \"$@\"`\n  }\nfi\n\n\n# func_basename FILE\n# ------------------\n# Set func_basename_result to FILE with everything up to and including\n# the last / stripped.\nif test yes = \"$_G_HAVE_XSI_OPS\"; then\n  # If this shell supports suffix pattern removal, then use it to avoid\n  # forking. Hide the definitions single quotes in case the shell chokes\n  # on unsupported syntax...\n  _b='func_basename_result=${1##*/}'\n  _d='case $1 in\n        */*) func_dirname_result=${1%/*}$2 ;;\n        *  ) func_dirname_result=$3        ;;\n      esac'\n\nelse\n  # ...otherwise fall back to using sed.\n  _b='func_basename_result=`$ECHO \"$1\" |$SED \"$sed_basename\"`'\n  _d='func_dirname_result=`$ECHO \"$1\"  |$SED \"$sed_dirname\"`\n      if test \"X$func_dirname_result\" = \"X$1\"; then\n        func_dirname_result=$3\n      else\n        func_append func_dirname_result \"$2\"\n      fi'\nfi\n\neval 'func_basename ()\n{\n    $debug_cmd\n\n    '\"$_b\"'\n}'\n\n\n# func_dirname FILE APPEND NONDIR_REPLACEMENT\n# -------------------------------------------\n# Compute the dirname of FILE.  If nonempty, add APPEND to the result,\n# otherwise set result to NONDIR_REPLACEMENT.\neval 'func_dirname ()\n{\n    $debug_cmd\n\n    '\"$_d\"'\n}'\n\n\n# func_dirname_and_basename FILE APPEND NONDIR_REPLACEMENT\n# --------------------------------------------------------\n# Perform func_basename and func_dirname in a single function\n# call:\n#   dirname:  Compute the dirname of FILE.  If nonempty,\n#             add APPEND to the result, otherwise set result\n#             to NONDIR_REPLACEMENT.\n#             value returned in \"$func_dirname_result\"\n#   basename: Compute filename of FILE.\n#             value retuned in \"$func_basename_result\"\n# For efficiency, we do not delegate to the functions above but instead\n# duplicate the functionality here.\neval 'func_dirname_and_basename ()\n{\n    $debug_cmd\n\n    '\"$_b\"'\n    '\"$_d\"'\n}'\n\n\n# func_echo ARG...\n# ----------------\n# Echo program name prefixed message.\nfunc_echo ()\n{\n    $debug_cmd\n\n    _G_message=$*\n\n    func_echo_IFS=$IFS\n    IFS=$nl\n    for _G_line in $_G_message; do\n      IFS=$func_echo_IFS\n      $ECHO \"$progname: $_G_line\"\n    done\n    IFS=$func_echo_IFS\n}\n\n\n# func_echo_all ARG...\n# --------------------\n# Invoke $ECHO with all args, space-separated.\nfunc_echo_all ()\n{\n    $ECHO \"$*\"\n}\n\n\n# func_echo_infix_1 INFIX ARG...\n# ------------------------------\n# Echo program name, followed by INFIX on the first line, with any\n# additional lines not showing INFIX.\nfunc_echo_infix_1 ()\n{\n    $debug_cmd\n\n    $require_term_colors\n\n    _G_infix=$1; shift\n    _G_indent=$_G_infix\n    _G_prefix=\"$progname: $_G_infix: \"\n    _G_message=$*\n\n    # Strip color escape sequences before counting printable length\n    for _G_tc in \"$tc_reset\" \"$tc_bold\" \"$tc_standout\" \"$tc_red\" \"$tc_green\" \"$tc_blue\" \"$tc_cyan\"\n    do\n      test -n \"$_G_tc\" && {\n        _G_esc_tc=`$ECHO \"$_G_tc\" | $SED \"$sed_make_literal_regex\"`\n        _G_indent=`$ECHO \"$_G_indent\" | $SED \"s|$_G_esc_tc||g\"`\n      }\n    done\n    _G_indent=\"$progname: \"`echo \"$_G_indent\" | $SED 's|.| |g'`\"  \" ## exclude from sc_prohibit_nested_quotes\n\n    func_echo_infix_1_IFS=$IFS\n    IFS=$nl\n    for _G_line in $_G_message; do\n      IFS=$func_echo_infix_1_IFS\n      $ECHO \"$_G_prefix$tc_bold$_G_line$tc_reset\" >&2\n      _G_prefix=$_G_indent\n    done\n    IFS=$func_echo_infix_1_IFS\n}\n\n\n# func_error ARG...\n# -----------------\n# Echo program name prefixed message to standard error.\nfunc_error ()\n{\n    $debug_cmd\n\n    $require_term_colors\n\n    func_echo_infix_1 \"  $tc_standout${tc_red}error$tc_reset\" \"$*\" >&2\n}\n\n\n# func_fatal_error ARG...\n# -----------------------\n# Echo program name prefixed message to standard error, and exit.\nfunc_fatal_error ()\n{\n    $debug_cmd\n\n    func_error \"$*\"\n    exit $EXIT_FAILURE\n}\n\n\n# func_grep EXPRESSION FILENAME\n# -----------------------------\n# Check whether EXPRESSION matches any line of FILENAME, without output.\nfunc_grep ()\n{\n    $debug_cmd\n\n    $GREP \"$1\" \"$2\" >/dev/null 2>&1\n}\n\n\n# func_len STRING\n# ---------------\n# Set func_len_result to the length of STRING. STRING may not\n# start with a hyphen.\n  test -z \"$_G_HAVE_XSI_OPS\" \\\n    && (eval 'x=a/b/c;\n      test 5aa/bb/cc = \"${#x}${x%%/*}${x%/*}${x#*/}${x##*/}\"') 2>/dev/null \\\n    && _G_HAVE_XSI_OPS=yes\n\nif test yes = \"$_G_HAVE_XSI_OPS\"; then\n  eval 'func_len ()\n  {\n    $debug_cmd\n\n    func_len_result=${#1}\n  }'\nelse\n  func_len ()\n  {\n    $debug_cmd\n\n    func_len_result=`expr \"$1\" : \".*\" 2>/dev/null || echo $max_cmd_len`\n  }\nfi\n\n\n# func_mkdir_p DIRECTORY-PATH\n# ---------------------------\n# Make sure the entire path to DIRECTORY-PATH is available.\nfunc_mkdir_p ()\n{\n    $debug_cmd\n\n    _G_directory_path=$1\n    _G_dir_list=\n\n    if test -n \"$_G_directory_path\" && test : != \"$opt_dry_run\"; then\n\n      # Protect directory names starting with '-'\n      case $_G_directory_path in\n        -*) _G_directory_path=./$_G_directory_path ;;\n      esac\n\n      # While some portion of DIR does not yet exist...\n      while test ! -d \"$_G_directory_path\"; do\n        # ...make a list in topmost first order.  Use a colon delimited\n\t# list incase some portion of path contains whitespace.\n        _G_dir_list=$_G_directory_path:$_G_dir_list\n\n        # If the last portion added has no slash in it, the list is done\n        case $_G_directory_path in */*) ;; *) break ;; esac\n\n        # ...otherwise throw away the child directory and loop\n        _G_directory_path=`$ECHO \"$_G_directory_path\" | $SED -e \"$sed_dirname\"`\n      done\n      _G_dir_list=`$ECHO \"$_G_dir_list\" | $SED 's|:*$||'`\n\n      func_mkdir_p_IFS=$IFS; IFS=:\n      for _G_dir in $_G_dir_list; do\n\tIFS=$func_mkdir_p_IFS\n        # mkdir can fail with a 'File exist' error if two processes\n        # try to create one of the directories concurrently.  Don't\n        # stop in that case!\n        $MKDIR \"$_G_dir\" 2>/dev/null || :\n      done\n      IFS=$func_mkdir_p_IFS\n\n      # Bail out if we (or some other process) failed to create a directory.\n      test -d \"$_G_directory_path\" || \\\n        func_fatal_error \"Failed to create '$1'\"\n    fi\n}\n\n\n# func_mktempdir [BASENAME]\n# -------------------------\n# Make a temporary directory that won't clash with other running\n# libtool processes, and avoids race conditions if possible.  If\n# given, BASENAME is the basename for that directory.\nfunc_mktempdir ()\n{\n    $debug_cmd\n\n    _G_template=${TMPDIR-/tmp}/${1-$progname}\n\n    if test : = \"$opt_dry_run\"; then\n      # Return a directory name, but don't create it in dry-run mode\n      _G_tmpdir=$_G_template-$$\n    else\n\n      # If mktemp works, use that first and foremost\n      _G_tmpdir=`mktemp -d \"$_G_template-XXXXXXXX\" 2>/dev/null`\n\n      if test ! -d \"$_G_tmpdir\"; then\n        # Failing that, at least try and use $RANDOM to avoid a race\n        _G_tmpdir=$_G_template-${RANDOM-0}$$\n\n        func_mktempdir_umask=`umask`\n        umask 0077\n        $MKDIR \"$_G_tmpdir\"\n        umask $func_mktempdir_umask\n      fi\n\n      # If we're not in dry-run mode, bomb out on failure\n      test -d \"$_G_tmpdir\" || \\\n        func_fatal_error \"cannot create temporary directory '$_G_tmpdir'\"\n    fi\n\n    $ECHO \"$_G_tmpdir\"\n}\n\n\n# func_normal_abspath PATH\n# ------------------------\n# Remove doubled-up and trailing slashes, \".\" path components,\n# and cancel out any \"..\" path components in PATH after making\n# it an absolute path.\nfunc_normal_abspath ()\n{\n    $debug_cmd\n\n    # These SED scripts presuppose an absolute path with a trailing slash.\n    _G_pathcar='s|^/\\([^/]*\\).*$|\\1|'\n    _G_pathcdr='s|^/[^/]*||'\n    _G_removedotparts=':dotsl\n\t\ts|/\\./|/|g\n\t\tt dotsl\n\t\ts|/\\.$|/|'\n    _G_collapseslashes='s|/\\{1,\\}|/|g'\n    _G_finalslash='s|/*$|/|'\n\n    # Start from root dir and reassemble the path.\n    func_normal_abspath_result=\n    func_normal_abspath_tpath=$1\n    func_normal_abspath_altnamespace=\n    case $func_normal_abspath_tpath in\n      \"\")\n        # Empty path, that just means $cwd.\n        func_stripname '' '/' \"`pwd`\"\n        func_normal_abspath_result=$func_stripname_result\n        return\n        ;;\n      # The next three entries are used to spot a run of precisely\n      # two leading slashes without using negated character classes;\n      # we take advantage of case's first-match behaviour.\n      ///*)\n        # Unusual form of absolute path, do nothing.\n        ;;\n      //*)\n        # Not necessarily an ordinary path; POSIX reserves leading '//'\n        # and for example Cygwin uses it to access remote file shares\n        # over CIFS/SMB, so we conserve a leading double slash if found.\n        func_normal_abspath_altnamespace=/\n        ;;\n      /*)\n        # Absolute path, do nothing.\n        ;;\n      *)\n        # Relative path, prepend $cwd.\n        func_normal_abspath_tpath=`pwd`/$func_normal_abspath_tpath\n        ;;\n    esac\n\n    # Cancel out all the simple stuff to save iterations.  We also want\n    # the path to end with a slash for ease of parsing, so make sure\n    # there is one (and only one) here.\n    func_normal_abspath_tpath=`$ECHO \"$func_normal_abspath_tpath\" | $SED \\\n          -e \"$_G_removedotparts\" -e \"$_G_collapseslashes\" -e \"$_G_finalslash\"`\n    while :; do\n      # Processed it all yet?\n      if test / = \"$func_normal_abspath_tpath\"; then\n        # If we ascended to the root using \"..\" the result may be empty now.\n        if test -z \"$func_normal_abspath_result\"; then\n          func_normal_abspath_result=/\n        fi\n        break\n      fi\n      func_normal_abspath_tcomponent=`$ECHO \"$func_normal_abspath_tpath\" | $SED \\\n          -e \"$_G_pathcar\"`\n      func_normal_abspath_tpath=`$ECHO \"$func_normal_abspath_tpath\" | $SED \\\n          -e \"$_G_pathcdr\"`\n      # Figure out what to do with it\n      case $func_normal_abspath_tcomponent in\n        \"\")\n          # Trailing empty path component, ignore it.\n          ;;\n        ..)\n          # Parent dir; strip last assembled component from result.\n          func_dirname \"$func_normal_abspath_result\"\n          func_normal_abspath_result=$func_dirname_result\n          ;;\n        *)\n          # Actual path component, append it.\n          func_append func_normal_abspath_result \"/$func_normal_abspath_tcomponent\"\n          ;;\n      esac\n    done\n    # Restore leading double-slash if one was found on entry.\n    func_normal_abspath_result=$func_normal_abspath_altnamespace$func_normal_abspath_result\n}\n\n\n# func_notquiet ARG...\n# --------------------\n# Echo program name prefixed message only when not in quiet mode.\nfunc_notquiet ()\n{\n    $debug_cmd\n\n    $opt_quiet || func_echo ${1+\"$@\"}\n\n    # A bug in bash halts the script if the last line of a function\n    # fails when set -e is in force, so we need another command to\n    # work around that:\n    :\n}\n\n\n# func_relative_path SRCDIR DSTDIR\n# --------------------------------\n# Set func_relative_path_result to the relative path from SRCDIR to DSTDIR.\nfunc_relative_path ()\n{\n    $debug_cmd\n\n    func_relative_path_result=\n    func_normal_abspath \"$1\"\n    func_relative_path_tlibdir=$func_normal_abspath_result\n    func_normal_abspath \"$2\"\n    func_relative_path_tbindir=$func_normal_abspath_result\n\n    # Ascend the tree starting from libdir\n    while :; do\n      # check if we have found a prefix of bindir\n      case $func_relative_path_tbindir in\n        $func_relative_path_tlibdir)\n          # found an exact match\n          func_relative_path_tcancelled=\n          break\n          ;;\n        $func_relative_path_tlibdir*)\n          # found a matching prefix\n          func_stripname \"$func_relative_path_tlibdir\" '' \"$func_relative_path_tbindir\"\n          func_relative_path_tcancelled=$func_stripname_result\n          if test -z \"$func_relative_path_result\"; then\n            func_relative_path_result=.\n          fi\n          break\n          ;;\n        *)\n          func_dirname $func_relative_path_tlibdir\n          func_relative_path_tlibdir=$func_dirname_result\n          if test -z \"$func_relative_path_tlibdir\"; then\n            # Have to descend all the way to the root!\n            func_relative_path_result=../$func_relative_path_result\n            func_relative_path_tcancelled=$func_relative_path_tbindir\n            break\n          fi\n          func_relative_path_result=../$func_relative_path_result\n          ;;\n      esac\n    done\n\n    # Now calculate path; take care to avoid doubling-up slashes.\n    func_stripname '' '/' \"$func_relative_path_result\"\n    func_relative_path_result=$func_stripname_result\n    func_stripname '/' '/' \"$func_relative_path_tcancelled\"\n    if test -n \"$func_stripname_result\"; then\n      func_append func_relative_path_result \"/$func_stripname_result\"\n    fi\n\n    # Normalisation. If bindir is libdir, return '.' else relative path.\n    if test -n \"$func_relative_path_result\"; then\n      func_stripname './' '' \"$func_relative_path_result\"\n      func_relative_path_result=$func_stripname_result\n    fi\n\n    test -n \"$func_relative_path_result\" || func_relative_path_result=.\n\n    :\n}\n\n\n# func_quote_for_eval ARG...\n# --------------------------\n# Aesthetically quote ARGs to be evaled later.\n# This function returns two values:\n#   i) func_quote_for_eval_result\n#      double-quoted, suitable for a subsequent eval\n#  ii) func_quote_for_eval_unquoted_result\n#      has all characters that are still active within double\n#      quotes backslashified.\nfunc_quote_for_eval ()\n{\n    $debug_cmd\n\n    func_quote_for_eval_unquoted_result=\n    func_quote_for_eval_result=\n    while test 0 -lt $#; do\n      case $1 in\n        *[\\\\\\`\\\"\\$]*)\n\t  _G_unquoted_arg=`printf '%s\\n' \"$1\" |$SED \"$sed_quote_subst\"` ;;\n        *)\n          _G_unquoted_arg=$1 ;;\n      esac\n      if test -n \"$func_quote_for_eval_unquoted_result\"; then\n\tfunc_append func_quote_for_eval_unquoted_result \" $_G_unquoted_arg\"\n      else\n        func_append func_quote_for_eval_unquoted_result \"$_G_unquoted_arg\"\n      fi\n\n      case $_G_unquoted_arg in\n        # Double-quote args containing shell metacharacters to delay\n        # word splitting, command substitution and variable expansion\n        # for a subsequent eval.\n        # Many Bourne shells cannot handle close brackets correctly\n        # in scan sets, so we specify it separately.\n        *[\\[\\~\\#\\^\\&\\*\\(\\)\\{\\}\\|\\;\\<\\>\\?\\'\\ \\\t]*|*]*|\"\")\n          _G_quoted_arg=\\\"$_G_unquoted_arg\\\"\n          ;;\n        *)\n          _G_quoted_arg=$_G_unquoted_arg\n\t  ;;\n      esac\n\n      if test -n \"$func_quote_for_eval_result\"; then\n\tfunc_append func_quote_for_eval_result \" $_G_quoted_arg\"\n      else\n        func_append func_quote_for_eval_result \"$_G_quoted_arg\"\n      fi\n      shift\n    done\n}\n\n\n# func_quote_for_expand ARG\n# -------------------------\n# Aesthetically quote ARG to be evaled later; same as above,\n# but do not quote variable references.\nfunc_quote_for_expand ()\n{\n    $debug_cmd\n\n    case $1 in\n      *[\\\\\\`\\\"]*)\n\t_G_arg=`$ECHO \"$1\" | $SED \\\n\t    -e \"$sed_double_quote_subst\" -e \"$sed_double_backslash\"` ;;\n      *)\n        _G_arg=$1 ;;\n    esac\n\n    case $_G_arg in\n      # Double-quote args containing shell metacharacters to delay\n      # word splitting and command substitution for a subsequent eval.\n      # Many Bourne shells cannot handle close brackets correctly\n      # in scan sets, so we specify it separately.\n      *[\\[\\~\\#\\^\\&\\*\\(\\)\\{\\}\\|\\;\\<\\>\\?\\'\\ \\\t]*|*]*|\"\")\n        _G_arg=\\\"$_G_arg\\\"\n        ;;\n    esac\n\n    func_quote_for_expand_result=$_G_arg\n}\n\n\n# func_stripname PREFIX SUFFIX NAME\n# ---------------------------------\n# strip PREFIX and SUFFIX from NAME, and store in func_stripname_result.\n# PREFIX and SUFFIX must not contain globbing or regex special\n# characters, hashes, percent signs, but SUFFIX may contain a leading\n# dot (in which case that matches only a dot).\nif test yes = \"$_G_HAVE_XSI_OPS\"; then\n  eval 'func_stripname ()\n  {\n    $debug_cmd\n\n    # pdksh 5.2.14 does not do ${X%$Y} correctly if both X and Y are\n    # positional parameters, so assign one to ordinary variable first.\n    func_stripname_result=$3\n    func_stripname_result=${func_stripname_result#\"$1\"}\n    func_stripname_result=${func_stripname_result%\"$2\"}\n  }'\nelse\n  func_stripname ()\n  {\n    $debug_cmd\n\n    case $2 in\n      .*) func_stripname_result=`$ECHO \"$3\" | $SED -e \"s%^$1%%\" -e \"s%\\\\\\\\$2\\$%%\"`;;\n      *)  func_stripname_result=`$ECHO \"$3\" | $SED -e \"s%^$1%%\" -e \"s%$2\\$%%\"`;;\n    esac\n  }\nfi\n\n\n# func_show_eval CMD [FAIL_EXP]\n# -----------------------------\n# Unless opt_quiet is true, then output CMD.  Then, if opt_dryrun is\n# not true, evaluate CMD.  If the evaluation of CMD fails, and FAIL_EXP\n# is given, then evaluate it.\nfunc_show_eval ()\n{\n    $debug_cmd\n\n    _G_cmd=$1\n    _G_fail_exp=${2-':'}\n\n    func_quote_for_expand \"$_G_cmd\"\n    eval \"func_notquiet $func_quote_for_expand_result\"\n\n    $opt_dry_run || {\n      eval \"$_G_cmd\"\n      _G_status=$?\n      if test 0 -ne \"$_G_status\"; then\n\teval \"(exit $_G_status); $_G_fail_exp\"\n      fi\n    }\n}\n\n\n# func_show_eval_locale CMD [FAIL_EXP]\n# ------------------------------------\n# Unless opt_quiet is true, then output CMD.  Then, if opt_dryrun is\n# not true, evaluate CMD.  If the evaluation of CMD fails, and FAIL_EXP\n# is given, then evaluate it.  Use the saved locale for evaluation.\nfunc_show_eval_locale ()\n{\n    $debug_cmd\n\n    _G_cmd=$1\n    _G_fail_exp=${2-':'}\n\n    $opt_quiet || {\n      func_quote_for_expand \"$_G_cmd\"\n      eval \"func_echo $func_quote_for_expand_result\"\n    }\n\n    $opt_dry_run || {\n      eval \"$_G_user_locale\n\t    $_G_cmd\"\n      _G_status=$?\n      eval \"$_G_safe_locale\"\n      if test 0 -ne \"$_G_status\"; then\n\teval \"(exit $_G_status); $_G_fail_exp\"\n      fi\n    }\n}\n\n\n# func_tr_sh\n# ----------\n# Turn $1 into a string suitable for a shell variable name.\n# Result is stored in $func_tr_sh_result.  All characters\n# not in the set a-zA-Z0-9_ are replaced with '_'. Further,\n# if $1 begins with a digit, a '_' is prepended as well.\nfunc_tr_sh ()\n{\n    $debug_cmd\n\n    case $1 in\n    [0-9]* | *[!a-zA-Z0-9_]*)\n      func_tr_sh_result=`$ECHO \"$1\" | $SED -e 's/^\\([0-9]\\)/_\\1/' -e 's/[^a-zA-Z0-9_]/_/g'`\n      ;;\n    * )\n      func_tr_sh_result=$1\n      ;;\n    esac\n}\n\n\n# func_verbose ARG...\n# -------------------\n# Echo program name prefixed message in verbose mode only.\nfunc_verbose ()\n{\n    $debug_cmd\n\n    $opt_verbose && func_echo \"$*\"\n\n    :\n}\n\n\n# func_warn_and_continue ARG...\n# -----------------------------\n# Echo program name prefixed warning message to standard error.\nfunc_warn_and_continue ()\n{\n    $debug_cmd\n\n    $require_term_colors\n\n    func_echo_infix_1 \"${tc_red}warning$tc_reset\" \"$*\" >&2\n}\n\n\n# func_warning CATEGORY ARG...\n# ----------------------------\n# Echo program name prefixed warning message to standard error. Warning\n# messages can be filtered according to CATEGORY, where this function\n# elides messages where CATEGORY is not listed in the global variable\n# 'opt_warning_types'.\nfunc_warning ()\n{\n    $debug_cmd\n\n    # CATEGORY must be in the warning_categories list!\n    case \" $warning_categories \" in\n      *\" $1 \"*) ;;\n      *) func_internal_error \"invalid warning category '$1'\" ;;\n    esac\n\n    _G_category=$1\n    shift\n\n    case \" $opt_warning_types \" in\n      *\" $_G_category \"*) $warning_func ${1+\"$@\"} ;;\n    esac\n}\n\n\n# func_sort_ver VER1 VER2\n# -----------------------\n# 'sort -V' is not generally available.\n# Note this deviates from the version comparison in automake\n# in that it treats 1.5 < 1.5.0, and treats 1.4.4a < 1.4-p3a\n# but this should suffice as we won't be specifying old\n# version formats or redundant trailing .0 in bootstrap.conf.\n# If we did want full compatibility then we should probably\n# use m4_version_compare from autoconf.\nfunc_sort_ver ()\n{\n    $debug_cmd\n\n    printf '%s\\n%s\\n' \"$1\" \"$2\" \\\n      | sort -t. -k 1,1n -k 2,2n -k 3,3n -k 4,4n -k 5,5n -k 6,6n -k 7,7n -k 8,8n -k 9,9n\n}\n\n# func_lt_ver PREV CURR\n# ---------------------\n# Return true if PREV and CURR are in the correct order according to\n# func_sort_ver, otherwise false.  Use it like this:\n#\n#  func_lt_ver \"$prev_ver\" \"$proposed_ver\" || func_fatal_error \"...\"\nfunc_lt_ver ()\n{\n    $debug_cmd\n\n    test \"x$1\" = x`func_sort_ver \"$1\" \"$2\" | $SED 1q`\n}\n\n\n# Local variables:\n# mode: shell-script\n# sh-indentation: 2\n# eval: (add-hook 'before-save-hook 'time-stamp)\n# time-stamp-pattern: \"10/scriptversion=%:y-%02m-%02d.%02H; # UTC\"\n# time-stamp-time-zone: \"UTC\"\n# End:\n#! /bin/sh\n\n# Set a version string for this script.\nscriptversion=2014-01-07.03; # UTC\n\n# A portable, pluggable option parser for Bourne shell.\n# Written by Gary V. Vaughan, 2010\n\n# Copyright (C) 2010-2015 Free Software Foundation, Inc.\n# This is free software; see the source for copying conditions.  There is NO\n# warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n# Please report bugs or propose patches to gary@gnu.org.\n\n\n## ------ ##\n## Usage. ##\n## ------ ##\n\n# This file is a library for parsing options in your shell scripts along\n# with assorted other useful supporting features that you can make use\n# of too.\n#\n# For the simplest scripts you might need only:\n#\n#   #!/bin/sh\n#   . relative/path/to/funclib.sh\n#   . relative/path/to/options-parser\n#   scriptversion=1.0\n#   func_options ${1+\"$@\"}\n#   eval set dummy \"$func_options_result\"; shift\n#   ...rest of your script...\n#\n# In order for the '--version' option to work, you will need to have a\n# suitably formatted comment like the one at the top of this file\n# starting with '# Written by ' and ending with '# warranty; '.\n#\n# For '-h' and '--help' to work, you will also need a one line\n# description of your script's purpose in a comment directly above the\n# '# Written by ' line, like the one at the top of this file.\n#\n# The default options also support '--debug', which will turn on shell\n# execution tracing (see the comment above debug_cmd below for another\n# use), and '--verbose' and the func_verbose function to allow your script\n# to display verbose messages only when your user has specified\n# '--verbose'.\n#\n# After sourcing this file, you can plug processing for additional\n# options by amending the variables from the 'Configuration' section\n# below, and following the instructions in the 'Option parsing'\n# section further down.\n\n## -------------- ##\n## Configuration. ##\n## -------------- ##\n\n# You should override these variables in your script after sourcing this\n# file so that they reflect the customisations you have added to the\n# option parser.\n\n# The usage line for option parsing errors and the start of '-h' and\n# '--help' output messages. You can embed shell variables for delayed\n# expansion at the time the message is displayed, but you will need to\n# quote other shell meta-characters carefully to prevent them being\n# expanded when the contents are evaled.\nusage='$progpath [OPTION]...'\n\n# Short help message in response to '-h' and '--help'.  Add to this or\n# override it after sourcing this library to reflect the full set of\n# options your script accepts.\nusage_message=\"\\\n       --debug        enable verbose shell tracing\n   -W, --warnings=CATEGORY\n                      report the warnings falling in CATEGORY [all]\n   -v, --verbose      verbosely report processing\n       --version      print version information and exit\n   -h, --help         print short or long help message and exit\n\"\n\n# Additional text appended to 'usage_message' in response to '--help'.\nlong_help_message=\"\nWarning categories include:\n       'all'          show all warnings\n       'none'         turn off all the warnings\n       'error'        warnings are treated as fatal errors\"\n\n# Help message printed before fatal option parsing errors.\nfatal_help=\"Try '\\$progname --help' for more information.\"\n\n\n\n## ------------------------- ##\n## Hook function management. ##\n## ------------------------- ##\n\n# This section contains functions for adding, removing, and running hooks\n# to the main code.  A hook is just a named list of of function, that can\n# be run in order later on.\n\n# func_hookable FUNC_NAME\n# -----------------------\n# Declare that FUNC_NAME will run hooks added with\n# 'func_add_hook FUNC_NAME ...'.\nfunc_hookable ()\n{\n    $debug_cmd\n\n    func_append hookable_fns \" $1\"\n}\n\n\n# func_add_hook FUNC_NAME HOOK_FUNC\n# ---------------------------------\n# Request that FUNC_NAME call HOOK_FUNC before it returns.  FUNC_NAME must\n# first have been declared \"hookable\" by a call to 'func_hookable'.\nfunc_add_hook ()\n{\n    $debug_cmd\n\n    case \" $hookable_fns \" in\n      *\" $1 \"*) ;;\n      *) func_fatal_error \"'$1' does not accept hook functions.\" ;;\n    esac\n\n    eval func_append ${1}_hooks '\" $2\"'\n}\n\n\n# func_remove_hook FUNC_NAME HOOK_FUNC\n# ------------------------------------\n# Remove HOOK_FUNC from the list of functions called by FUNC_NAME.\nfunc_remove_hook ()\n{\n    $debug_cmd\n\n    eval ${1}_hooks='`$ECHO \"\\$'$1'_hooks\" |$SED \"s| '$2'||\"`'\n}\n\n\n# func_run_hooks FUNC_NAME [ARG]...\n# ---------------------------------\n# Run all hook functions registered to FUNC_NAME.\n# It is assumed that the list of hook functions contains nothing more\n# than a whitespace-delimited list of legal shell function names, and\n# no effort is wasted trying to catch shell meta-characters or preserve\n# whitespace.\nfunc_run_hooks ()\n{\n    $debug_cmd\n\n    case \" $hookable_fns \" in\n      *\" $1 \"*) ;;\n      *) func_fatal_error \"'$1' does not support hook funcions.n\" ;;\n    esac\n\n    eval _G_hook_fns=\\$$1_hooks; shift\n\n    for _G_hook in $_G_hook_fns; do\n      eval $_G_hook '\"$@\"'\n\n      # store returned options list back into positional\n      # parameters for next 'cmd' execution.\n      eval _G_hook_result=\\$${_G_hook}_result\n      eval set dummy \"$_G_hook_result\"; shift\n    done\n\n    func_quote_for_eval ${1+\"$@\"}\n    func_run_hooks_result=$func_quote_for_eval_result\n}\n\n\n\n## --------------- ##\n## Option parsing. ##\n## --------------- ##\n\n# In order to add your own option parsing hooks, you must accept the\n# full positional parameter list in your hook function, remove any\n# options that you action, and then pass back the remaining unprocessed\n# options in '<hooked_function_name>_result', escaped suitably for\n# 'eval'.  Like this:\n#\n#    my_options_prep ()\n#    {\n#        $debug_cmd\n#\n#        # Extend the existing usage message.\n#        usage_message=$usage_message'\n#      -s, --silent       don'\\''t print informational messages\n#    '\n#\n#        func_quote_for_eval ${1+\"$@\"}\n#        my_options_prep_result=$func_quote_for_eval_result\n#    }\n#    func_add_hook func_options_prep my_options_prep\n#\n#\n#    my_silent_option ()\n#    {\n#        $debug_cmd\n#\n#        # Note that for efficiency, we parse as many options as we can\n#        # recognise in a loop before passing the remainder back to the\n#        # caller on the first unrecognised argument we encounter.\n#        while test $# -gt 0; do\n#          opt=$1; shift\n#          case $opt in\n#            --silent|-s) opt_silent=: ;;\n#            # Separate non-argument short options:\n#            -s*)         func_split_short_opt \"$_G_opt\"\n#                         set dummy \"$func_split_short_opt_name\" \\\n#                             \"-$func_split_short_opt_arg\" ${1+\"$@\"}\n#                         shift\n#                         ;;\n#            *)            set dummy \"$_G_opt\" \"$*\"; shift; break ;;\n#          esac\n#        done\n#\n#        func_quote_for_eval ${1+\"$@\"}\n#        my_silent_option_result=$func_quote_for_eval_result\n#    }\n#    func_add_hook func_parse_options my_silent_option\n#\n#\n#    my_option_validation ()\n#    {\n#        $debug_cmd\n#\n#        $opt_silent && $opt_verbose && func_fatal_help \"\\\n#    '--silent' and '--verbose' options are mutually exclusive.\"\n#\n#        func_quote_for_eval ${1+\"$@\"}\n#        my_option_validation_result=$func_quote_for_eval_result\n#    }\n#    func_add_hook func_validate_options my_option_validation\n#\n# You'll alse need to manually amend $usage_message to reflect the extra\n# options you parse.  It's preferable to append if you can, so that\n# multiple option parsing hooks can be added safely.\n\n\n# func_options [ARG]...\n# ---------------------\n# All the functions called inside func_options are hookable. See the\n# individual implementations for details.\nfunc_hookable func_options\nfunc_options ()\n{\n    $debug_cmd\n\n    func_options_prep ${1+\"$@\"}\n    eval func_parse_options \\\n        ${func_options_prep_result+\"$func_options_prep_result\"}\n    eval func_validate_options \\\n        ${func_parse_options_result+\"$func_parse_options_result\"}\n\n    eval func_run_hooks func_options \\\n        ${func_validate_options_result+\"$func_validate_options_result\"}\n\n    # save modified positional parameters for caller\n    func_options_result=$func_run_hooks_result\n}\n\n\n# func_options_prep [ARG]...\n# --------------------------\n# All initialisations required before starting the option parse loop.\n# Note that when calling hook functions, we pass through the list of\n# positional parameters.  If a hook function modifies that list, and\n# needs to propogate that back to rest of this script, then the complete\n# modified list must be put in 'func_run_hooks_result' before\n# returning.\nfunc_hookable func_options_prep\nfunc_options_prep ()\n{\n    $debug_cmd\n\n    # Option defaults:\n    opt_verbose=false\n    opt_warning_types=\n\n    func_run_hooks func_options_prep ${1+\"$@\"}\n\n    # save modified positional parameters for caller\n    func_options_prep_result=$func_run_hooks_result\n}\n\n\n# func_parse_options [ARG]...\n# ---------------------------\n# The main option parsing loop.\nfunc_hookable func_parse_options\nfunc_parse_options ()\n{\n    $debug_cmd\n\n    func_parse_options_result=\n\n    # this just eases exit handling\n    while test $# -gt 0; do\n      # Defer to hook functions for initial option parsing, so they\n      # get priority in the event of reusing an option name.\n      func_run_hooks func_parse_options ${1+\"$@\"}\n\n      # Adjust func_parse_options positional parameters to match\n      eval set dummy \"$func_run_hooks_result\"; shift\n\n      # Break out of the loop if we already parsed every option.\n      test $# -gt 0 || break\n\n      _G_opt=$1\n      shift\n      case $_G_opt in\n        --debug|-x)   debug_cmd='set -x'\n                      func_echo \"enabling shell trace mode\"\n                      $debug_cmd\n                      ;;\n\n        --no-warnings|--no-warning|--no-warn)\n                      set dummy --warnings none ${1+\"$@\"}\n                      shift\n\t\t      ;;\n\n        --warnings|--warning|-W)\n                      test $# = 0 && func_missing_arg $_G_opt && break\n                      case \" $warning_categories $1\" in\n                        *\" $1 \"*)\n                          # trailing space prevents matching last $1 above\n                          func_append_uniq opt_warning_types \" $1\"\n                          ;;\n                        *all)\n                          opt_warning_types=$warning_categories\n                          ;;\n                        *none)\n                          opt_warning_types=none\n                          warning_func=:\n                          ;;\n                        *error)\n                          opt_warning_types=$warning_categories\n                          warning_func=func_fatal_error\n                          ;;\n                        *)\n                          func_fatal_error \\\n                             \"unsupported warning category: '$1'\"\n                          ;;\n                      esac\n                      shift\n                      ;;\n\n        --verbose|-v) opt_verbose=: ;;\n        --version)    func_version ;;\n        -\\?|-h)       func_usage ;;\n        --help)       func_help ;;\n\n\t# Separate optargs to long options (plugins may need this):\n\t--*=*)        func_split_equals \"$_G_opt\"\n\t              set dummy \"$func_split_equals_lhs\" \\\n                          \"$func_split_equals_rhs\" ${1+\"$@\"}\n                      shift\n                      ;;\n\n       # Separate optargs to short options:\n        -W*)\n                      func_split_short_opt \"$_G_opt\"\n                      set dummy \"$func_split_short_opt_name\" \\\n                          \"$func_split_short_opt_arg\" ${1+\"$@\"}\n                      shift\n                      ;;\n\n        # Separate non-argument short options:\n        -\\?*|-h*|-v*|-x*)\n                      func_split_short_opt \"$_G_opt\"\n                      set dummy \"$func_split_short_opt_name\" \\\n                          \"-$func_split_short_opt_arg\" ${1+\"$@\"}\n                      shift\n                      ;;\n\n        --)           break ;;\n        -*)           func_fatal_help \"unrecognised option: '$_G_opt'\" ;;\n        *)            set dummy \"$_G_opt\" ${1+\"$@\"}; shift; break ;;\n      esac\n    done\n\n    # save modified positional parameters for caller\n    func_quote_for_eval ${1+\"$@\"}\n    func_parse_options_result=$func_quote_for_eval_result\n}\n\n\n# func_validate_options [ARG]...\n# ------------------------------\n# Perform any sanity checks on option settings and/or unconsumed\n# arguments.\nfunc_hookable func_validate_options\nfunc_validate_options ()\n{\n    $debug_cmd\n\n    # Display all warnings if -W was not given.\n    test -n \"$opt_warning_types\" || opt_warning_types=\" $warning_categories\"\n\n    func_run_hooks func_validate_options ${1+\"$@\"}\n\n    # Bail if the options were screwed!\n    $exit_cmd $EXIT_FAILURE\n\n    # save modified positional parameters for caller\n    func_validate_options_result=$func_run_hooks_result\n}\n\n\n\n## ----------------- ##\n## Helper functions. ##\n## ----------------- ##\n\n# This section contains the helper functions used by the rest of the\n# hookable option parser framework in ascii-betical order.\n\n\n# func_fatal_help ARG...\n# ----------------------\n# Echo program name prefixed message to standard error, followed by\n# a help hint, and exit.\nfunc_fatal_help ()\n{\n    $debug_cmd\n\n    eval \\$ECHO \\\"\"Usage: $usage\"\\\"\n    eval \\$ECHO \\\"\"$fatal_help\"\\\"\n    func_error ${1+\"$@\"}\n    exit $EXIT_FAILURE\n}\n\n\n# func_help\n# ---------\n# Echo long help message to standard output and exit.\nfunc_help ()\n{\n    $debug_cmd\n\n    func_usage_message\n    $ECHO \"$long_help_message\"\n    exit 0\n}\n\n\n# func_missing_arg ARGNAME\n# ------------------------\n# Echo program name prefixed message to standard error and set global\n# exit_cmd.\nfunc_missing_arg ()\n{\n    $debug_cmd\n\n    func_error \"Missing argument for '$1'.\"\n    exit_cmd=exit\n}\n\n\n# func_split_equals STRING\n# ------------------------\n# Set func_split_equals_lhs and func_split_equals_rhs shell variables after\n# splitting STRING at the '=' sign.\ntest -z \"$_G_HAVE_XSI_OPS\" \\\n    && (eval 'x=a/b/c;\n      test 5aa/bb/cc = \"${#x}${x%%/*}${x%/*}${x#*/}${x##*/}\"') 2>/dev/null \\\n    && _G_HAVE_XSI_OPS=yes\n\nif test yes = \"$_G_HAVE_XSI_OPS\"\nthen\n  # This is an XSI compatible shell, allowing a faster implementation...\n  eval 'func_split_equals ()\n  {\n      $debug_cmd\n\n      func_split_equals_lhs=${1%%=*}\n      func_split_equals_rhs=${1#*=}\n      test \"x$func_split_equals_lhs\" = \"x$1\" \\\n        && func_split_equals_rhs=\n  }'\nelse\n  # ...otherwise fall back to using expr, which is often a shell builtin.\n  func_split_equals ()\n  {\n      $debug_cmd\n\n      func_split_equals_lhs=`expr \"x$1\" : 'x\\([^=]*\\)'`\n      func_split_equals_rhs=\n      test \"x$func_split_equals_lhs\" = \"x$1\" \\\n        || func_split_equals_rhs=`expr \"x$1\" : 'x[^=]*=\\(.*\\)$'`\n  }\nfi #func_split_equals\n\n\n# func_split_short_opt SHORTOPT\n# -----------------------------\n# Set func_split_short_opt_name and func_split_short_opt_arg shell\n# variables after splitting SHORTOPT after the 2nd character.\nif test yes = \"$_G_HAVE_XSI_OPS\"\nthen\n  # This is an XSI compatible shell, allowing a faster implementation...\n  eval 'func_split_short_opt ()\n  {\n      $debug_cmd\n\n      func_split_short_opt_arg=${1#??}\n      func_split_short_opt_name=${1%\"$func_split_short_opt_arg\"}\n  }'\nelse\n  # ...otherwise fall back to using expr, which is often a shell builtin.\n  func_split_short_opt ()\n  {\n      $debug_cmd\n\n      func_split_short_opt_name=`expr \"x$1\" : 'x-\\(.\\)'`\n      func_split_short_opt_arg=`expr \"x$1\" : 'x-.\\(.*\\)$'`\n  }\nfi #func_split_short_opt\n\n\n# func_usage\n# ----------\n# Echo short help message to standard output and exit.\nfunc_usage ()\n{\n    $debug_cmd\n\n    func_usage_message\n    $ECHO \"Run '$progname --help |${PAGER-more}' for full usage\"\n    exit 0\n}\n\n\n# func_usage_message\n# ------------------\n# Echo short help message to standard output.\nfunc_usage_message ()\n{\n    $debug_cmd\n\n    eval \\$ECHO \\\"\"Usage: $usage\"\\\"\n    echo\n    $SED -n 's|^# ||\n        /^Written by/{\n          x;p;x\n        }\n\th\n\t/^Written by/q' < \"$progpath\"\n    echo\n    eval \\$ECHO \\\"\"$usage_message\"\\\"\n}\n\n\n# func_version\n# ------------\n# Echo version message to standard output and exit.\nfunc_version ()\n{\n    $debug_cmd\n\n    printf '%s\\n' \"$progname $scriptversion\"\n    $SED -n '\n        /(C)/!b go\n        :more\n        /\\./!{\n          N\n          s|\\n# | |\n          b more\n        }\n        :go\n        /^# Written by /,/# warranty; / {\n          s|^# ||\n          s|^# *$||\n          s|\\((C)\\)[ 0-9,-]*[ ,-]\\([1-9][0-9]* \\)|\\1 \\2|\n          p\n        }\n        /^# Written by / {\n          s|^# ||\n          p\n        }\n        /^warranty; /q' < \"$progpath\"\n\n    exit $?\n}\n\n\n# Local variables:\n# mode: shell-script\n# sh-indentation: 2\n# eval: (add-hook 'before-save-hook 'time-stamp)\n# time-stamp-pattern: \"10/scriptversion=%:y-%02m-%02d.%02H; # UTC\"\n# time-stamp-time-zone: \"UTC\"\n# End:\n\n# Set a version string.\nscriptversion='(GNU libtool) 2.4.6'\n\n\n# func_echo ARG...\n# ----------------\n# Libtool also displays the current mode in messages, so override\n# funclib.sh func_echo with this custom definition.\nfunc_echo ()\n{\n    $debug_cmd\n\n    _G_message=$*\n\n    func_echo_IFS=$IFS\n    IFS=$nl\n    for _G_line in $_G_message; do\n      IFS=$func_echo_IFS\n      $ECHO \"$progname${opt_mode+: $opt_mode}: $_G_line\"\n    done\n    IFS=$func_echo_IFS\n}\n\n\n# func_warning ARG...\n# -------------------\n# Libtool warnings are not categorized, so override funclib.sh\n# func_warning with this simpler definition.\nfunc_warning ()\n{\n    $debug_cmd\n\n    $warning_func ${1+\"$@\"}\n}\n\n\n## ---------------- ##\n## Options parsing. ##\n## ---------------- ##\n\n# Hook in the functions to make sure our own options are parsed during\n# the option parsing loop.\n\nusage='$progpath [OPTION]... [MODE-ARG]...'\n\n# Short help message in response to '-h'.\nusage_message=\"Options:\n       --config             show all configuration variables\n       --debug              enable verbose shell tracing\n   -n, --dry-run            display commands without modifying any files\n       --features           display basic configuration information and exit\n       --mode=MODE          use operation mode MODE\n       --no-warnings        equivalent to '-Wnone'\n       --preserve-dup-deps  don't remove duplicate dependency libraries\n       --quiet, --silent    don't print informational messages\n       --tag=TAG            use configuration variables from tag TAG\n   -v, --verbose            print more informational messages than default\n       --version            print version information\n   -W, --warnings=CATEGORY  report the warnings falling in CATEGORY [all]\n   -h, --help, --help-all   print short, long, or detailed help message\n\"\n\n# Additional text appended to 'usage_message' in response to '--help'.\nfunc_help ()\n{\n    $debug_cmd\n\n    func_usage_message\n    $ECHO \"$long_help_message\n\nMODE must be one of the following:\n\n       clean           remove files from the build directory\n       compile         compile a source file into a libtool object\n       execute         automatically set library path, then run a program\n       finish          complete the installation of libtool libraries\n       install         install libraries or executables\n       link            create a library or an executable\n       uninstall       remove libraries from an installed directory\n\nMODE-ARGS vary depending on the MODE.  When passed as first option,\n'--mode=MODE' may be abbreviated as 'MODE' or a unique abbreviation of that.\nTry '$progname --help --mode=MODE' for a more detailed description of MODE.\n\nWhen reporting a bug, please describe a test case to reproduce it and\ninclude the following information:\n\n       host-triplet:   $host\n       shell:          $SHELL\n       compiler:       $LTCC\n       compiler flags: $LTCFLAGS\n       linker:         $LD (gnu? $with_gnu_ld)\n       version:        $progname (GNU libtool) 2.4.6\n       automake:       `($AUTOMAKE --version) 2>/dev/null |$SED 1q`\n       autoconf:       `($AUTOCONF --version) 2>/dev/null |$SED 1q`\n\nReport bugs to <bug-libtool@gnu.org>.\nGNU libtool home page: <http://www.gnu.org/software/libtool/>.\nGeneral help using GNU software: <http://www.gnu.org/gethelp/>.\"\n    exit 0\n}\n\n\n# func_lo2o OBJECT-NAME\n# ---------------------\n# Transform OBJECT-NAME from a '.lo' suffix to the platform specific\n# object suffix.\n\nlo2o=s/\\\\.lo\\$/.$objext/\no2lo=s/\\\\.$objext\\$/.lo/\n\nif test yes = \"$_G_HAVE_XSI_OPS\"; then\n  eval 'func_lo2o ()\n  {\n    case $1 in\n      *.lo) func_lo2o_result=${1%.lo}.$objext ;;\n      *   ) func_lo2o_result=$1               ;;\n    esac\n  }'\n\n  # func_xform LIBOBJ-OR-SOURCE\n  # ---------------------------\n  # Transform LIBOBJ-OR-SOURCE from a '.o' or '.c' (or otherwise)\n  # suffix to a '.lo' libtool-object suffix.\n  eval 'func_xform ()\n  {\n    func_xform_result=${1%.*}.lo\n  }'\nelse\n  # ...otherwise fall back to using sed.\n  func_lo2o ()\n  {\n    func_lo2o_result=`$ECHO \"$1\" | $SED \"$lo2o\"`\n  }\n\n  func_xform ()\n  {\n    func_xform_result=`$ECHO \"$1\" | $SED 's|\\.[^.]*$|.lo|'`\n  }\nfi\n\n\n# func_fatal_configuration ARG...\n# -------------------------------\n# Echo program name prefixed message to standard error, followed by\n# a configuration failure hint, and exit.\nfunc_fatal_configuration ()\n{\n    func__fatal_error ${1+\"$@\"} \\\n      \"See the $PACKAGE documentation for more information.\" \\\n      \"Fatal configuration error.\"\n}\n\n\n# func_config\n# -----------\n# Display the configuration for all the tags in this script.\nfunc_config ()\n{\n    re_begincf='^# ### BEGIN LIBTOOL'\n    re_endcf='^# ### END LIBTOOL'\n\n    # Default configuration.\n    $SED \"1,/$re_begincf CONFIG/d;/$re_endcf CONFIG/,\\$d\" < \"$progpath\"\n\n    # Now print the configurations for the tags.\n    for tagname in $taglist; do\n      $SED -n \"/$re_begincf TAG CONFIG: $tagname\\$/,/$re_endcf TAG CONFIG: $tagname\\$/p\" < \"$progpath\"\n    done\n\n    exit $?\n}\n\n\n# func_features\n# -------------\n# Display the features supported by this script.\nfunc_features ()\n{\n    echo \"host: $host\"\n    if test yes = \"$build_libtool_libs\"; then\n      echo \"enable shared libraries\"\n    else\n      echo \"disable shared libraries\"\n    fi\n    if test yes = \"$build_old_libs\"; then\n      echo \"enable static libraries\"\n    else\n      echo \"disable static libraries\"\n    fi\n\n    exit $?\n}\n\n\n# func_enable_tag TAGNAME\n# -----------------------\n# Verify that TAGNAME is valid, and either flag an error and exit, or\n# enable the TAGNAME tag.  We also add TAGNAME to the global $taglist\n# variable here.\nfunc_enable_tag ()\n{\n    # Global variable:\n    tagname=$1\n\n    re_begincf=\"^# ### BEGIN LIBTOOL TAG CONFIG: $tagname\\$\"\n    re_endcf=\"^# ### END LIBTOOL TAG CONFIG: $tagname\\$\"\n    sed_extractcf=/$re_begincf/,/$re_endcf/p\n\n    # Validate tagname.\n    case $tagname in\n      *[!-_A-Za-z0-9,/]*)\n        func_fatal_error \"invalid tag name: $tagname\"\n        ;;\n    esac\n\n    # Don't test for the \"default\" C tag, as we know it's\n    # there but not specially marked.\n    case $tagname in\n        CC) ;;\n    *)\n        if $GREP \"$re_begincf\" \"$progpath\" >/dev/null 2>&1; then\n\t  taglist=\"$taglist $tagname\"\n\n\t  # Evaluate the configuration.  Be careful to quote the path\n\t  # and the sed script, to avoid splitting on whitespace, but\n\t  # also don't use non-portable quotes within backquotes within\n\t  # quotes we have to do it in 2 steps:\n\t  extractedcf=`$SED -n -e \"$sed_extractcf\" < \"$progpath\"`\n\t  eval \"$extractedcf\"\n        else\n\t  func_error \"ignoring unknown tag $tagname\"\n        fi\n        ;;\n    esac\n}\n\n\n# func_check_version_match\n# ------------------------\n# Ensure that we are using m4 macros, and libtool script from the same\n# release of libtool.\nfunc_check_version_match ()\n{\n    if test \"$package_revision\" != \"$macro_revision\"; then\n      if test \"$VERSION\" != \"$macro_version\"; then\n        if test -z \"$macro_version\"; then\n          cat >&2 <<_LT_EOF\n$progname: Version mismatch error.  This is $PACKAGE $VERSION, but the\n$progname: definition of this LT_INIT comes from an older release.\n$progname: You should recreate aclocal.m4 with macros from $PACKAGE $VERSION\n$progname: and run autoconf again.\n_LT_EOF\n        else\n          cat >&2 <<_LT_EOF\n$progname: Version mismatch error.  This is $PACKAGE $VERSION, but the\n$progname: definition of this LT_INIT comes from $PACKAGE $macro_version.\n$progname: You should recreate aclocal.m4 with macros from $PACKAGE $VERSION\n$progname: and run autoconf again.\n_LT_EOF\n        fi\n      else\n        cat >&2 <<_LT_EOF\n$progname: Version mismatch error.  This is $PACKAGE $VERSION, revision $package_revision,\n$progname: but the definition of this LT_INIT comes from revision $macro_revision.\n$progname: You should recreate aclocal.m4 with macros from revision $package_revision\n$progname: of $PACKAGE $VERSION and run autoconf again.\n_LT_EOF\n      fi\n\n      exit $EXIT_MISMATCH\n    fi\n}\n\n\n# libtool_options_prep [ARG]...\n# -----------------------------\n# Preparation for options parsed by libtool.\nlibtool_options_prep ()\n{\n    $debug_mode\n\n    # Option defaults:\n    opt_config=false\n    opt_dlopen=\n    opt_dry_run=false\n    opt_help=false\n    opt_mode=\n    opt_preserve_dup_deps=false\n    opt_quiet=false\n\n    nonopt=\n    preserve_args=\n\n    # Shorthand for --mode=foo, only valid as the first argument\n    case $1 in\n    clean|clea|cle|cl)\n      shift; set dummy --mode clean ${1+\"$@\"}; shift\n      ;;\n    compile|compil|compi|comp|com|co|c)\n      shift; set dummy --mode compile ${1+\"$@\"}; shift\n      ;;\n    execute|execut|execu|exec|exe|ex|e)\n      shift; set dummy --mode execute ${1+\"$@\"}; shift\n      ;;\n    finish|finis|fini|fin|fi|f)\n      shift; set dummy --mode finish ${1+\"$@\"}; shift\n      ;;\n    install|instal|insta|inst|ins|in|i)\n      shift; set dummy --mode install ${1+\"$@\"}; shift\n      ;;\n    link|lin|li|l)\n      shift; set dummy --mode link ${1+\"$@\"}; shift\n      ;;\n    uninstall|uninstal|uninsta|uninst|unins|unin|uni|un|u)\n      shift; set dummy --mode uninstall ${1+\"$@\"}; shift\n      ;;\n    esac\n\n    # Pass back the list of options.\n    func_quote_for_eval ${1+\"$@\"}\n    libtool_options_prep_result=$func_quote_for_eval_result\n}\nfunc_add_hook func_options_prep libtool_options_prep\n\n\n# libtool_parse_options [ARG]...\n# ---------------------------------\n# Provide handling for libtool specific options.\nlibtool_parse_options ()\n{\n    $debug_cmd\n\n    # Perform our own loop to consume as many options as possible in\n    # each iteration.\n    while test $# -gt 0; do\n      _G_opt=$1\n      shift\n      case $_G_opt in\n        --dry-run|--dryrun|-n)\n                        opt_dry_run=:\n                        ;;\n\n        --config)       func_config ;;\n\n        --dlopen|-dlopen)\n                        opt_dlopen=\"${opt_dlopen+$opt_dlopen\n}$1\"\n                        shift\n                        ;;\n\n        --preserve-dup-deps)\n                        opt_preserve_dup_deps=: ;;\n\n        --features)     func_features ;;\n\n        --finish)       set dummy --mode finish ${1+\"$@\"}; shift ;;\n\n        --help)         opt_help=: ;;\n\n        --help-all)     opt_help=': help-all' ;;\n\n        --mode)         test $# = 0 && func_missing_arg $_G_opt && break\n                        opt_mode=$1\n                        case $1 in\n                          # Valid mode arguments:\n                          clean|compile|execute|finish|install|link|relink|uninstall) ;;\n\n                          # Catch anything else as an error\n                          *) func_error \"invalid argument for $_G_opt\"\n                             exit_cmd=exit\n                             break\n                             ;;\n                        esac\n                        shift\n                        ;;\n\n        --no-silent|--no-quiet)\n                        opt_quiet=false\n                        func_append preserve_args \" $_G_opt\"\n                        ;;\n\n        --no-warnings|--no-warning|--no-warn)\n                        opt_warning=false\n                        func_append preserve_args \" $_G_opt\"\n                        ;;\n\n        --no-verbose)\n                        opt_verbose=false\n                        func_append preserve_args \" $_G_opt\"\n                        ;;\n\n        --silent|--quiet)\n                        opt_quiet=:\n                        opt_verbose=false\n                        func_append preserve_args \" $_G_opt\"\n                        ;;\n\n        --tag)          test $# = 0 && func_missing_arg $_G_opt && break\n                        opt_tag=$1\n                        func_append preserve_args \" $_G_opt $1\"\n                        func_enable_tag \"$1\"\n                        shift\n                        ;;\n\n        --verbose|-v)   opt_quiet=false\n                        opt_verbose=:\n                        func_append preserve_args \" $_G_opt\"\n                        ;;\n\n\t# An option not handled by this hook function:\n        *)\t\tset dummy \"$_G_opt\" ${1+\"$@\"};\tshift; break  ;;\n      esac\n    done\n\n\n    # save modified positional parameters for caller\n    func_quote_for_eval ${1+\"$@\"}\n    libtool_parse_options_result=$func_quote_for_eval_result\n}\nfunc_add_hook func_parse_options libtool_parse_options\n\n\n\n# libtool_validate_options [ARG]...\n# ---------------------------------\n# Perform any sanity checks on option settings and/or unconsumed\n# arguments.\nlibtool_validate_options ()\n{\n    # save first non-option argument\n    if test 0 -lt $#; then\n      nonopt=$1\n      shift\n    fi\n\n    # preserve --debug\n    test : = \"$debug_cmd\" || func_append preserve_args \" --debug\"\n\n    case $host in\n      # Solaris2 added to fix http://debbugs.gnu.org/cgi/bugreport.cgi?bug=16452\n      # see also: http://gcc.gnu.org/bugzilla/show_bug.cgi?id=59788\n      *cygwin* | *mingw* | *pw32* | *cegcc* | *solaris2* | *os2*)\n        # don't eliminate duplications in $postdeps and $predeps\n        opt_duplicate_compiler_generated_deps=:\n        ;;\n      *)\n        opt_duplicate_compiler_generated_deps=$opt_preserve_dup_deps\n        ;;\n    esac\n\n    $opt_help || {\n      # Sanity checks first:\n      func_check_version_match\n\n      test yes != \"$build_libtool_libs\" \\\n        && test yes != \"$build_old_libs\" \\\n        && func_fatal_configuration \"not configured to build any kind of library\"\n\n      # Darwin sucks\n      eval std_shrext=\\\"$shrext_cmds\\\"\n\n      # Only execute mode is allowed to have -dlopen flags.\n      if test -n \"$opt_dlopen\" && test execute != \"$opt_mode\"; then\n        func_error \"unrecognized option '-dlopen'\"\n        $ECHO \"$help\" 1>&2\n        exit $EXIT_FAILURE\n      fi\n\n      # Change the help message to a mode-specific one.\n      generic_help=$help\n      help=\"Try '$progname --help --mode=$opt_mode' for more information.\"\n    }\n\n    # Pass back the unparsed argument list\n    func_quote_for_eval ${1+\"$@\"}\n    libtool_validate_options_result=$func_quote_for_eval_result\n}\nfunc_add_hook func_validate_options libtool_validate_options\n\n\n# Process options as early as possible so that --help and --version\n# can return quickly.\nfunc_options ${1+\"$@\"}\neval set dummy \"$func_options_result\"; shift\n\n\n\n## ----------- ##\n##    Main.    ##\n## ----------- ##\n\nmagic='%%%MAGIC variable%%%'\nmagic_exe='%%%MAGIC EXE variable%%%'\n\n# Global variables.\nextracted_archives=\nextracted_serial=0\n\n# If this variable is set in any of the actions, the command in it\n# will be execed at the end.  This prevents here-documents from being\n# left over by shells.\nexec_cmd=\n\n\n# A function that is used when there is no print builtin or printf.\nfunc_fallback_echo ()\n{\n  eval 'cat <<_LTECHO_EOF\n$1\n_LTECHO_EOF'\n}\n\n# func_generated_by_libtool\n# True iff stdin has been generated by Libtool. This function is only\n# a basic sanity check; it will hardly flush out determined imposters.\nfunc_generated_by_libtool_p ()\n{\n  $GREP \"^# Generated by .*$PACKAGE\" > /dev/null 2>&1\n}\n\n# func_lalib_p file\n# True iff FILE is a libtool '.la' library or '.lo' object file.\n# This function is only a basic sanity check; it will hardly flush out\n# determined imposters.\nfunc_lalib_p ()\n{\n    test -f \"$1\" &&\n      $SED -e 4q \"$1\" 2>/dev/null | func_generated_by_libtool_p\n}\n\n# func_lalib_unsafe_p file\n# True iff FILE is a libtool '.la' library or '.lo' object file.\n# This function implements the same check as func_lalib_p without\n# resorting to external programs.  To this end, it redirects stdin and\n# closes it afterwards, without saving the original file descriptor.\n# As a safety measure, use it only where a negative result would be\n# fatal anyway.  Works if 'file' does not exist.\nfunc_lalib_unsafe_p ()\n{\n    lalib_p=no\n    if test -f \"$1\" && test -r \"$1\" && exec 5<&0 <\"$1\"; then\n\tfor lalib_p_l in 1 2 3 4\n\tdo\n\t    read lalib_p_line\n\t    case $lalib_p_line in\n\t\t\\#\\ Generated\\ by\\ *$PACKAGE* ) lalib_p=yes; break;;\n\t    esac\n\tdone\n\texec 0<&5 5<&-\n    fi\n    test yes = \"$lalib_p\"\n}\n\n# func_ltwrapper_script_p file\n# True iff FILE is a libtool wrapper script\n# This function is only a basic sanity check; it will hardly flush out\n# determined imposters.\nfunc_ltwrapper_script_p ()\n{\n    test -f \"$1\" &&\n      $lt_truncate_bin < \"$1\" 2>/dev/null | func_generated_by_libtool_p\n}\n\n# func_ltwrapper_executable_p file\n# True iff FILE is a libtool wrapper executable\n# This function is only a basic sanity check; it will hardly flush out\n# determined imposters.\nfunc_ltwrapper_executable_p ()\n{\n    func_ltwrapper_exec_suffix=\n    case $1 in\n    *.exe) ;;\n    *) func_ltwrapper_exec_suffix=.exe ;;\n    esac\n    $GREP \"$magic_exe\" \"$1$func_ltwrapper_exec_suffix\" >/dev/null 2>&1\n}\n\n# func_ltwrapper_scriptname file\n# Assumes file is an ltwrapper_executable\n# uses $file to determine the appropriate filename for a\n# temporary ltwrapper_script.\nfunc_ltwrapper_scriptname ()\n{\n    func_dirname_and_basename \"$1\" \"\" \".\"\n    func_stripname '' '.exe' \"$func_basename_result\"\n    func_ltwrapper_scriptname_result=$func_dirname_result/$objdir/${func_stripname_result}_ltshwrapper\n}\n\n# func_ltwrapper_p file\n# True iff FILE is a libtool wrapper script or wrapper executable\n# This function is only a basic sanity check; it will hardly flush out\n# determined imposters.\nfunc_ltwrapper_p ()\n{\n    func_ltwrapper_script_p \"$1\" || func_ltwrapper_executable_p \"$1\"\n}\n\n\n# func_execute_cmds commands fail_cmd\n# Execute tilde-delimited COMMANDS.\n# If FAIL_CMD is given, eval that upon failure.\n# FAIL_CMD may read-access the current command in variable CMD!\nfunc_execute_cmds ()\n{\n    $debug_cmd\n\n    save_ifs=$IFS; IFS='~'\n    for cmd in $1; do\n      IFS=$sp$nl\n      eval cmd=\\\"$cmd\\\"\n      IFS=$save_ifs\n      func_show_eval \"$cmd\" \"${2-:}\"\n    done\n    IFS=$save_ifs\n}\n\n\n# func_source file\n# Source FILE, adding directory component if necessary.\n# Note that it is not necessary on cygwin/mingw to append a dot to\n# FILE even if both FILE and FILE.exe exist: automatic-append-.exe\n# behavior happens only for exec(3), not for open(2)!  Also, sourcing\n# 'FILE.' does not work on cygwin managed mounts.\nfunc_source ()\n{\n    $debug_cmd\n\n    case $1 in\n    */* | *\\\\*)\t. \"$1\" ;;\n    *)\t\t. \"./$1\" ;;\n    esac\n}\n\n\n# func_resolve_sysroot PATH\n# Replace a leading = in PATH with a sysroot.  Store the result into\n# func_resolve_sysroot_result\nfunc_resolve_sysroot ()\n{\n  func_resolve_sysroot_result=$1\n  case $func_resolve_sysroot_result in\n  =*)\n    func_stripname '=' '' \"$func_resolve_sysroot_result\"\n    func_resolve_sysroot_result=$lt_sysroot$func_stripname_result\n    ;;\n  esac\n}\n\n# func_replace_sysroot PATH\n# If PATH begins with the sysroot, replace it with = and\n# store the result into func_replace_sysroot_result.\nfunc_replace_sysroot ()\n{\n  case $lt_sysroot:$1 in\n  ?*:\"$lt_sysroot\"*)\n    func_stripname \"$lt_sysroot\" '' \"$1\"\n    func_replace_sysroot_result='='$func_stripname_result\n    ;;\n  *)\n    # Including no sysroot.\n    func_replace_sysroot_result=$1\n    ;;\n  esac\n}\n\n# func_infer_tag arg\n# Infer tagged configuration to use if any are available and\n# if one wasn't chosen via the \"--tag\" command line option.\n# Only attempt this if the compiler in the base compile\n# command doesn't match the default compiler.\n# arg is usually of the form 'gcc ...'\nfunc_infer_tag ()\n{\n    $debug_cmd\n\n    if test -n \"$available_tags\" && test -z \"$tagname\"; then\n      CC_quoted=\n      for arg in $CC; do\n\tfunc_append_quoted CC_quoted \"$arg\"\n      done\n      CC_expanded=`func_echo_all $CC`\n      CC_quoted_expanded=`func_echo_all $CC_quoted`\n      case $@ in\n      # Blanks in the command may have been stripped by the calling shell,\n      # but not from the CC environment variable when configure was run.\n      \" $CC \"* | \"$CC \"* | \" $CC_expanded \"* | \"$CC_expanded \"* | \\\n      \" $CC_quoted\"* | \"$CC_quoted \"* | \" $CC_quoted_expanded \"* | \"$CC_quoted_expanded \"*) ;;\n      # Blanks at the start of $base_compile will cause this to fail\n      # if we don't check for them as well.\n      *)\n\tfor z in $available_tags; do\n\t  if $GREP \"^# ### BEGIN LIBTOOL TAG CONFIG: $z$\" < \"$progpath\" > /dev/null; then\n\t    # Evaluate the configuration.\n\t    eval \"`$SED -n -e '/^# ### BEGIN LIBTOOL TAG CONFIG: '$z'$/,/^# ### END LIBTOOL TAG CONFIG: '$z'$/p' < $progpath`\"\n\t    CC_quoted=\n\t    for arg in $CC; do\n\t      # Double-quote args containing other shell metacharacters.\n\t      func_append_quoted CC_quoted \"$arg\"\n\t    done\n\t    CC_expanded=`func_echo_all $CC`\n\t    CC_quoted_expanded=`func_echo_all $CC_quoted`\n\t    case \"$@ \" in\n\t    \" $CC \"* | \"$CC \"* | \" $CC_expanded \"* | \"$CC_expanded \"* | \\\n\t    \" $CC_quoted\"* | \"$CC_quoted \"* | \" $CC_quoted_expanded \"* | \"$CC_quoted_expanded \"*)\n\t      # The compiler in the base compile command matches\n\t      # the one in the tagged configuration.\n\t      # Assume this is the tagged configuration we want.\n\t      tagname=$z\n\t      break\n\t      ;;\n\t    esac\n\t  fi\n\tdone\n\t# If $tagname still isn't set, then no tagged configuration\n\t# was found and let the user know that the \"--tag\" command\n\t# line option must be used.\n\tif test -z \"$tagname\"; then\n\t  func_echo \"unable to infer tagged configuration\"\n\t  func_fatal_error \"specify a tag with '--tag'\"\n#\telse\n#\t  func_verbose \"using $tagname tagged configuration\"\n\tfi\n\t;;\n      esac\n    fi\n}\n\n\n\n# func_write_libtool_object output_name pic_name nonpic_name\n# Create a libtool object file (analogous to a \".la\" file),\n# but don't create it if we're doing a dry run.\nfunc_write_libtool_object ()\n{\n    write_libobj=$1\n    if test yes = \"$build_libtool_libs\"; then\n      write_lobj=\\'$2\\'\n    else\n      write_lobj=none\n    fi\n\n    if test yes = \"$build_old_libs\"; then\n      write_oldobj=\\'$3\\'\n    else\n      write_oldobj=none\n    fi\n\n    $opt_dry_run || {\n      cat >${write_libobj}T <<EOF\n# $write_libobj - a libtool object file\n# Generated by $PROGRAM (GNU $PACKAGE) $VERSION\n#\n# Please DO NOT delete this file!\n# It is necessary for linking the library.\n\n# Name of the PIC object.\npic_object=$write_lobj\n\n# Name of the non-PIC object\nnon_pic_object=$write_oldobj\n\nEOF\n      $MV \"${write_libobj}T\" \"$write_libobj\"\n    }\n}\n\n\n##################################################\n# FILE NAME AND PATH CONVERSION HELPER FUNCTIONS #\n##################################################\n\n# func_convert_core_file_wine_to_w32 ARG\n# Helper function used by file name conversion functions when $build is *nix,\n# and $host is mingw, cygwin, or some other w32 environment. Relies on a\n# correctly configured wine environment available, with the winepath program\n# in $build's $PATH.\n#\n# ARG is the $build file name to be converted to w32 format.\n# Result is available in $func_convert_core_file_wine_to_w32_result, and will\n# be empty on error (or when ARG is empty)\nfunc_convert_core_file_wine_to_w32 ()\n{\n  $debug_cmd\n\n  func_convert_core_file_wine_to_w32_result=$1\n  if test -n \"$1\"; then\n    # Unfortunately, winepath does not exit with a non-zero error code, so we\n    # are forced to check the contents of stdout. On the other hand, if the\n    # command is not found, the shell will set an exit code of 127 and print\n    # *an error message* to stdout. So we must check for both error code of\n    # zero AND non-empty stdout, which explains the odd construction:\n    func_convert_core_file_wine_to_w32_tmp=`winepath -w \"$1\" 2>/dev/null`\n    if test \"$?\" -eq 0 && test -n \"$func_convert_core_file_wine_to_w32_tmp\"; then\n      func_convert_core_file_wine_to_w32_result=`$ECHO \"$func_convert_core_file_wine_to_w32_tmp\" |\n        $SED -e \"$sed_naive_backslashify\"`\n    else\n      func_convert_core_file_wine_to_w32_result=\n    fi\n  fi\n}\n# end: func_convert_core_file_wine_to_w32\n\n\n# func_convert_core_path_wine_to_w32 ARG\n# Helper function used by path conversion functions when $build is *nix, and\n# $host is mingw, cygwin, or some other w32 environment. Relies on a correctly\n# configured wine environment available, with the winepath program in $build's\n# $PATH. Assumes ARG has no leading or trailing path separator characters.\n#\n# ARG is path to be converted from $build format to win32.\n# Result is available in $func_convert_core_path_wine_to_w32_result.\n# Unconvertible file (directory) names in ARG are skipped; if no directory names\n# are convertible, then the result may be empty.\nfunc_convert_core_path_wine_to_w32 ()\n{\n  $debug_cmd\n\n  # unfortunately, winepath doesn't convert paths, only file names\n  func_convert_core_path_wine_to_w32_result=\n  if test -n \"$1\"; then\n    oldIFS=$IFS\n    IFS=:\n    for func_convert_core_path_wine_to_w32_f in $1; do\n      IFS=$oldIFS\n      func_convert_core_file_wine_to_w32 \"$func_convert_core_path_wine_to_w32_f\"\n      if test -n \"$func_convert_core_file_wine_to_w32_result\"; then\n        if test -z \"$func_convert_core_path_wine_to_w32_result\"; then\n          func_convert_core_path_wine_to_w32_result=$func_convert_core_file_wine_to_w32_result\n        else\n          func_append func_convert_core_path_wine_to_w32_result \";$func_convert_core_file_wine_to_w32_result\"\n        fi\n      fi\n    done\n    IFS=$oldIFS\n  fi\n}\n# end: func_convert_core_path_wine_to_w32\n\n\n# func_cygpath ARGS...\n# Wrapper around calling the cygpath program via LT_CYGPATH. This is used when\n# when (1) $build is *nix and Cygwin is hosted via a wine environment; or (2)\n# $build is MSYS and $host is Cygwin, or (3) $build is Cygwin. In case (1) or\n# (2), returns the Cygwin file name or path in func_cygpath_result (input\n# file name or path is assumed to be in w32 format, as previously converted\n# from $build's *nix or MSYS format). In case (3), returns the w32 file name\n# or path in func_cygpath_result (input file name or path is assumed to be in\n# Cygwin format). Returns an empty string on error.\n#\n# ARGS are passed to cygpath, with the last one being the file name or path to\n# be converted.\n#\n# Specify the absolute *nix (or w32) name to cygpath in the LT_CYGPATH\n# environment variable; do not put it in $PATH.\nfunc_cygpath ()\n{\n  $debug_cmd\n\n  if test -n \"$LT_CYGPATH\" && test -f \"$LT_CYGPATH\"; then\n    func_cygpath_result=`$LT_CYGPATH \"$@\" 2>/dev/null`\n    if test \"$?\" -ne 0; then\n      # on failure, ensure result is empty\n      func_cygpath_result=\n    fi\n  else\n    func_cygpath_result=\n    func_error \"LT_CYGPATH is empty or specifies non-existent file: '$LT_CYGPATH'\"\n  fi\n}\n#end: func_cygpath\n\n\n# func_convert_core_msys_to_w32 ARG\n# Convert file name or path ARG from MSYS format to w32 format.  Return\n# result in func_convert_core_msys_to_w32_result.\nfunc_convert_core_msys_to_w32 ()\n{\n  $debug_cmd\n\n  # awkward: cmd appends spaces to result\n  func_convert_core_msys_to_w32_result=`( cmd //c echo \"$1\" ) 2>/dev/null |\n    $SED -e 's/[ ]*$//' -e \"$sed_naive_backslashify\"`\n}\n#end: func_convert_core_msys_to_w32\n\n\n# func_convert_file_check ARG1 ARG2\n# Verify that ARG1 (a file name in $build format) was converted to $host\n# format in ARG2. Otherwise, emit an error message, but continue (resetting\n# func_to_host_file_result to ARG1).\nfunc_convert_file_check ()\n{\n  $debug_cmd\n\n  if test -z \"$2\" && test -n \"$1\"; then\n    func_error \"Could not determine host file name corresponding to\"\n    func_error \"  '$1'\"\n    func_error \"Continuing, but uninstalled executables may not work.\"\n    # Fallback:\n    func_to_host_file_result=$1\n  fi\n}\n# end func_convert_file_check\n\n\n# func_convert_path_check FROM_PATHSEP TO_PATHSEP FROM_PATH TO_PATH\n# Verify that FROM_PATH (a path in $build format) was converted to $host\n# format in TO_PATH. Otherwise, emit an error message, but continue, resetting\n# func_to_host_file_result to a simplistic fallback value (see below).\nfunc_convert_path_check ()\n{\n  $debug_cmd\n\n  if test -z \"$4\" && test -n \"$3\"; then\n    func_error \"Could not determine the host path corresponding to\"\n    func_error \"  '$3'\"\n    func_error \"Continuing, but uninstalled executables may not work.\"\n    # Fallback.  This is a deliberately simplistic \"conversion\" and\n    # should not be \"improved\".  See libtool.info.\n    if test \"x$1\" != \"x$2\"; then\n      lt_replace_pathsep_chars=\"s|$1|$2|g\"\n      func_to_host_path_result=`echo \"$3\" |\n        $SED -e \"$lt_replace_pathsep_chars\"`\n    else\n      func_to_host_path_result=$3\n    fi\n  fi\n}\n# end func_convert_path_check\n\n\n# func_convert_path_front_back_pathsep FRONTPAT BACKPAT REPL ORIG\n# Modifies func_to_host_path_result by prepending REPL if ORIG matches FRONTPAT\n# and appending REPL if ORIG matches BACKPAT.\nfunc_convert_path_front_back_pathsep ()\n{\n  $debug_cmd\n\n  case $4 in\n  $1 ) func_to_host_path_result=$3$func_to_host_path_result\n    ;;\n  esac\n  case $4 in\n  $2 ) func_append func_to_host_path_result \"$3\"\n    ;;\n  esac\n}\n# end func_convert_path_front_back_pathsep\n\n\n##################################################\n# $build to $host FILE NAME CONVERSION FUNCTIONS #\n##################################################\n# invoked via '$to_host_file_cmd ARG'\n#\n# In each case, ARG is the path to be converted from $build to $host format.\n# Result will be available in $func_to_host_file_result.\n\n\n# func_to_host_file ARG\n# Converts the file name ARG from $build format to $host format. Return result\n# in func_to_host_file_result.\nfunc_to_host_file ()\n{\n  $debug_cmd\n\n  $to_host_file_cmd \"$1\"\n}\n# end func_to_host_file\n\n\n# func_to_tool_file ARG LAZY\n# converts the file name ARG from $build format to toolchain format. Return\n# result in func_to_tool_file_result.  If the conversion in use is listed\n# in (the comma separated) LAZY, no conversion takes place.\nfunc_to_tool_file ()\n{\n  $debug_cmd\n\n  case ,$2, in\n    *,\"$to_tool_file_cmd\",*)\n      func_to_tool_file_result=$1\n      ;;\n    *)\n      $to_tool_file_cmd \"$1\"\n      func_to_tool_file_result=$func_to_host_file_result\n      ;;\n  esac\n}\n# end func_to_tool_file\n\n\n# func_convert_file_noop ARG\n# Copy ARG to func_to_host_file_result.\nfunc_convert_file_noop ()\n{\n  func_to_host_file_result=$1\n}\n# end func_convert_file_noop\n\n\n# func_convert_file_msys_to_w32 ARG\n# Convert file name ARG from (mingw) MSYS to (mingw) w32 format; automatic\n# conversion to w32 is not available inside the cwrapper.  Returns result in\n# func_to_host_file_result.\nfunc_convert_file_msys_to_w32 ()\n{\n  $debug_cmd\n\n  func_to_host_file_result=$1\n  if test -n \"$1\"; then\n    func_convert_core_msys_to_w32 \"$1\"\n    func_to_host_file_result=$func_convert_core_msys_to_w32_result\n  fi\n  func_convert_file_check \"$1\" \"$func_to_host_file_result\"\n}\n# end func_convert_file_msys_to_w32\n\n\n# func_convert_file_cygwin_to_w32 ARG\n# Convert file name ARG from Cygwin to w32 format.  Returns result in\n# func_to_host_file_result.\nfunc_convert_file_cygwin_to_w32 ()\n{\n  $debug_cmd\n\n  func_to_host_file_result=$1\n  if test -n \"$1\"; then\n    # because $build is cygwin, we call \"the\" cygpath in $PATH; no need to use\n    # LT_CYGPATH in this case.\n    func_to_host_file_result=`cygpath -m \"$1\"`\n  fi\n  func_convert_file_check \"$1\" \"$func_to_host_file_result\"\n}\n# end func_convert_file_cygwin_to_w32\n\n\n# func_convert_file_nix_to_w32 ARG\n# Convert file name ARG from *nix to w32 format.  Requires a wine environment\n# and a working winepath. Returns result in func_to_host_file_result.\nfunc_convert_file_nix_to_w32 ()\n{\n  $debug_cmd\n\n  func_to_host_file_result=$1\n  if test -n \"$1\"; then\n    func_convert_core_file_wine_to_w32 \"$1\"\n    func_to_host_file_result=$func_convert_core_file_wine_to_w32_result\n  fi\n  func_convert_file_check \"$1\" \"$func_to_host_file_result\"\n}\n# end func_convert_file_nix_to_w32\n\n\n# func_convert_file_msys_to_cygwin ARG\n# Convert file name ARG from MSYS to Cygwin format.  Requires LT_CYGPATH set.\n# Returns result in func_to_host_file_result.\nfunc_convert_file_msys_to_cygwin ()\n{\n  $debug_cmd\n\n  func_to_host_file_result=$1\n  if test -n \"$1\"; then\n    func_convert_core_msys_to_w32 \"$1\"\n    func_cygpath -u \"$func_convert_core_msys_to_w32_result\"\n    func_to_host_file_result=$func_cygpath_result\n  fi\n  func_convert_file_check \"$1\" \"$func_to_host_file_result\"\n}\n# end func_convert_file_msys_to_cygwin\n\n\n# func_convert_file_nix_to_cygwin ARG\n# Convert file name ARG from *nix to Cygwin format.  Requires Cygwin installed\n# in a wine environment, working winepath, and LT_CYGPATH set.  Returns result\n# in func_to_host_file_result.\nfunc_convert_file_nix_to_cygwin ()\n{\n  $debug_cmd\n\n  func_to_host_file_result=$1\n  if test -n \"$1\"; then\n    # convert from *nix to w32, then use cygpath to convert from w32 to cygwin.\n    func_convert_core_file_wine_to_w32 \"$1\"\n    func_cygpath -u \"$func_convert_core_file_wine_to_w32_result\"\n    func_to_host_file_result=$func_cygpath_result\n  fi\n  func_convert_file_check \"$1\" \"$func_to_host_file_result\"\n}\n# end func_convert_file_nix_to_cygwin\n\n\n#############################################\n# $build to $host PATH CONVERSION FUNCTIONS #\n#############################################\n# invoked via '$to_host_path_cmd ARG'\n#\n# In each case, ARG is the path to be converted from $build to $host format.\n# The result will be available in $func_to_host_path_result.\n#\n# Path separators are also converted from $build format to $host format.  If\n# ARG begins or ends with a path separator character, it is preserved (but\n# converted to $host format) on output.\n#\n# All path conversion functions are named using the following convention:\n#   file name conversion function    : func_convert_file_X_to_Y ()\n#   path conversion function         : func_convert_path_X_to_Y ()\n# where, for any given $build/$host combination the 'X_to_Y' value is the\n# same.  If conversion functions are added for new $build/$host combinations,\n# the two new functions must follow this pattern, or func_init_to_host_path_cmd\n# will break.\n\n\n# func_init_to_host_path_cmd\n# Ensures that function \"pointer\" variable $to_host_path_cmd is set to the\n# appropriate value, based on the value of $to_host_file_cmd.\nto_host_path_cmd=\nfunc_init_to_host_path_cmd ()\n{\n  $debug_cmd\n\n  if test -z \"$to_host_path_cmd\"; then\n    func_stripname 'func_convert_file_' '' \"$to_host_file_cmd\"\n    to_host_path_cmd=func_convert_path_$func_stripname_result\n  fi\n}\n\n\n# func_to_host_path ARG\n# Converts the path ARG from $build format to $host format. Return result\n# in func_to_host_path_result.\nfunc_to_host_path ()\n{\n  $debug_cmd\n\n  func_init_to_host_path_cmd\n  $to_host_path_cmd \"$1\"\n}\n# end func_to_host_path\n\n\n# func_convert_path_noop ARG\n# Copy ARG to func_to_host_path_result.\nfunc_convert_path_noop ()\n{\n  func_to_host_path_result=$1\n}\n# end func_convert_path_noop\n\n\n# func_convert_path_msys_to_w32 ARG\n# Convert path ARG from (mingw) MSYS to (mingw) w32 format; automatic\n# conversion to w32 is not available inside the cwrapper.  Returns result in\n# func_to_host_path_result.\nfunc_convert_path_msys_to_w32 ()\n{\n  $debug_cmd\n\n  func_to_host_path_result=$1\n  if test -n \"$1\"; then\n    # Remove leading and trailing path separator characters from ARG.  MSYS\n    # behavior is inconsistent here; cygpath turns them into '.;' and ';.';\n    # and winepath ignores them completely.\n    func_stripname : : \"$1\"\n    func_to_host_path_tmp1=$func_stripname_result\n    func_convert_core_msys_to_w32 \"$func_to_host_path_tmp1\"\n    func_to_host_path_result=$func_convert_core_msys_to_w32_result\n    func_convert_path_check : \";\" \\\n      \"$func_to_host_path_tmp1\" \"$func_to_host_path_result\"\n    func_convert_path_front_back_pathsep \":*\" \"*:\" \";\" \"$1\"\n  fi\n}\n# end func_convert_path_msys_to_w32\n\n\n# func_convert_path_cygwin_to_w32 ARG\n# Convert path ARG from Cygwin to w32 format.  Returns result in\n# func_to_host_file_result.\nfunc_convert_path_cygwin_to_w32 ()\n{\n  $debug_cmd\n\n  func_to_host_path_result=$1\n  if test -n \"$1\"; then\n    # See func_convert_path_msys_to_w32:\n    func_stripname : : \"$1\"\n    func_to_host_path_tmp1=$func_stripname_result\n    func_to_host_path_result=`cygpath -m -p \"$func_to_host_path_tmp1\"`\n    func_convert_path_check : \";\" \\\n      \"$func_to_host_path_tmp1\" \"$func_to_host_path_result\"\n    func_convert_path_front_back_pathsep \":*\" \"*:\" \";\" \"$1\"\n  fi\n}\n# end func_convert_path_cygwin_to_w32\n\n\n# func_convert_path_nix_to_w32 ARG\n# Convert path ARG from *nix to w32 format.  Requires a wine environment and\n# a working winepath.  Returns result in func_to_host_file_result.\nfunc_convert_path_nix_to_w32 ()\n{\n  $debug_cmd\n\n  func_to_host_path_result=$1\n  if test -n \"$1\"; then\n    # See func_convert_path_msys_to_w32:\n    func_stripname : : \"$1\"\n    func_to_host_path_tmp1=$func_stripname_result\n    func_convert_core_path_wine_to_w32 \"$func_to_host_path_tmp1\"\n    func_to_host_path_result=$func_convert_core_path_wine_to_w32_result\n    func_convert_path_check : \";\" \\\n      \"$func_to_host_path_tmp1\" \"$func_to_host_path_result\"\n    func_convert_path_front_back_pathsep \":*\" \"*:\" \";\" \"$1\"\n  fi\n}\n# end func_convert_path_nix_to_w32\n\n\n# func_convert_path_msys_to_cygwin ARG\n# Convert path ARG from MSYS to Cygwin format.  Requires LT_CYGPATH set.\n# Returns result in func_to_host_file_result.\nfunc_convert_path_msys_to_cygwin ()\n{\n  $debug_cmd\n\n  func_to_host_path_result=$1\n  if test -n \"$1\"; then\n    # See func_convert_path_msys_to_w32:\n    func_stripname : : \"$1\"\n    func_to_host_path_tmp1=$func_stripname_result\n    func_convert_core_msys_to_w32 \"$func_to_host_path_tmp1\"\n    func_cygpath -u -p \"$func_convert_core_msys_to_w32_result\"\n    func_to_host_path_result=$func_cygpath_result\n    func_convert_path_check : : \\\n      \"$func_to_host_path_tmp1\" \"$func_to_host_path_result\"\n    func_convert_path_front_back_pathsep \":*\" \"*:\" : \"$1\"\n  fi\n}\n# end func_convert_path_msys_to_cygwin\n\n\n# func_convert_path_nix_to_cygwin ARG\n# Convert path ARG from *nix to Cygwin format.  Requires Cygwin installed in a\n# a wine environment, working winepath, and LT_CYGPATH set.  Returns result in\n# func_to_host_file_result.\nfunc_convert_path_nix_to_cygwin ()\n{\n  $debug_cmd\n\n  func_to_host_path_result=$1\n  if test -n \"$1\"; then\n    # Remove leading and trailing path separator characters from\n    # ARG. msys behavior is inconsistent here, cygpath turns them\n    # into '.;' and ';.', and winepath ignores them completely.\n    func_stripname : : \"$1\"\n    func_to_host_path_tmp1=$func_stripname_result\n    func_convert_core_path_wine_to_w32 \"$func_to_host_path_tmp1\"\n    func_cygpath -u -p \"$func_convert_core_path_wine_to_w32_result\"\n    func_to_host_path_result=$func_cygpath_result\n    func_convert_path_check : : \\\n      \"$func_to_host_path_tmp1\" \"$func_to_host_path_result\"\n    func_convert_path_front_back_pathsep \":*\" \"*:\" : \"$1\"\n  fi\n}\n# end func_convert_path_nix_to_cygwin\n\n\n# func_dll_def_p FILE\n# True iff FILE is a Windows DLL '.def' file.\n# Keep in sync with _LT_DLL_DEF_P in libtool.m4\nfunc_dll_def_p ()\n{\n  $debug_cmd\n\n  func_dll_def_p_tmp=`$SED -n \\\n    -e 's/^[\t ]*//' \\\n    -e '/^\\(;.*\\)*$/d' \\\n    -e 's/^\\(EXPORTS\\|LIBRARY\\)\\([\t ].*\\)*$/DEF/p' \\\n    -e q \\\n    \"$1\"`\n  test DEF = \"$func_dll_def_p_tmp\"\n}\n\n\n# func_mode_compile arg...\nfunc_mode_compile ()\n{\n    $debug_cmd\n\n    # Get the compilation command and the source file.\n    base_compile=\n    srcfile=$nonopt  #  always keep a non-empty value in \"srcfile\"\n    suppress_opt=yes\n    suppress_output=\n    arg_mode=normal\n    libobj=\n    later=\n    pie_flag=\n\n    for arg\n    do\n      case $arg_mode in\n      arg  )\n\t# do not \"continue\".  Instead, add this to base_compile\n\tlastarg=$arg\n\targ_mode=normal\n\t;;\n\n      target )\n\tlibobj=$arg\n\targ_mode=normal\n\tcontinue\n\t;;\n\n      normal )\n\t# Accept any command-line options.\n\tcase $arg in\n\t-o)\n\t  test -n \"$libobj\" && \\\n\t    func_fatal_error \"you cannot specify '-o' more than once\"\n\t  arg_mode=target\n\t  continue\n\t  ;;\n\n\t-pie | -fpie | -fPIE)\n          func_append pie_flag \" $arg\"\n\t  continue\n\t  ;;\n\n\t-shared | -static | -prefer-pic | -prefer-non-pic)\n\t  func_append later \" $arg\"\n\t  continue\n\t  ;;\n\n\t-no-suppress)\n\t  suppress_opt=no\n\t  continue\n\t  ;;\n\n\t-Xcompiler)\n\t  arg_mode=arg  #  the next one goes into the \"base_compile\" arg list\n\t  continue      #  The current \"srcfile\" will either be retained or\n\t  ;;            #  replaced later.  I would guess that would be a bug.\n\n\t-Wc,*)\n\t  func_stripname '-Wc,' '' \"$arg\"\n\t  args=$func_stripname_result\n\t  lastarg=\n\t  save_ifs=$IFS; IFS=,\n\t  for arg in $args; do\n\t    IFS=$save_ifs\n\t    func_append_quoted lastarg \"$arg\"\n\t  done\n\t  IFS=$save_ifs\n\t  func_stripname ' ' '' \"$lastarg\"\n\t  lastarg=$func_stripname_result\n\n\t  # Add the arguments to base_compile.\n\t  func_append base_compile \" $lastarg\"\n\t  continue\n\t  ;;\n\n\t*)\n\t  # Accept the current argument as the source file.\n\t  # The previous \"srcfile\" becomes the current argument.\n\t  #\n\t  lastarg=$srcfile\n\t  srcfile=$arg\n\t  ;;\n\tesac  #  case $arg\n\t;;\n      esac    #  case $arg_mode\n\n      # Aesthetically quote the previous argument.\n      func_append_quoted base_compile \"$lastarg\"\n    done # for arg\n\n    case $arg_mode in\n    arg)\n      func_fatal_error \"you must specify an argument for -Xcompile\"\n      ;;\n    target)\n      func_fatal_error \"you must specify a target with '-o'\"\n      ;;\n    *)\n      # Get the name of the library object.\n      test -z \"$libobj\" && {\n\tfunc_basename \"$srcfile\"\n\tlibobj=$func_basename_result\n      }\n      ;;\n    esac\n\n    # Recognize several different file suffixes.\n    # If the user specifies -o file.o, it is replaced with file.lo\n    case $libobj in\n    *.[cCFSifmso] | \\\n    *.ada | *.adb | *.ads | *.asm | \\\n    *.c++ | *.cc | *.ii | *.class | *.cpp | *.cxx | \\\n    *.[fF][09]? | *.for | *.java | *.go | *.obj | *.sx | *.cu | *.cup)\n      func_xform \"$libobj\"\n      libobj=$func_xform_result\n      ;;\n    esac\n\n    case $libobj in\n    *.lo) func_lo2o \"$libobj\"; obj=$func_lo2o_result ;;\n    *)\n      func_fatal_error \"cannot determine name of library object from '$libobj'\"\n      ;;\n    esac\n\n    func_infer_tag $base_compile\n\n    for arg in $later; do\n      case $arg in\n      -shared)\n\ttest yes = \"$build_libtool_libs\" \\\n\t  || func_fatal_configuration \"cannot build a shared library\"\n\tbuild_old_libs=no\n\tcontinue\n\t;;\n\n      -static)\n\tbuild_libtool_libs=no\n\tbuild_old_libs=yes\n\tcontinue\n\t;;\n\n      -prefer-pic)\n\tpic_mode=yes\n\tcontinue\n\t;;\n\n      -prefer-non-pic)\n\tpic_mode=no\n\tcontinue\n\t;;\n      esac\n    done\n\n    func_quote_for_eval \"$libobj\"\n    test \"X$libobj\" != \"X$func_quote_for_eval_result\" \\\n      && $ECHO \"X$libobj\" | $GREP '[]~#^*{};<>?\"'\"'\"'\t &()|`$[]' \\\n      && func_warning \"libobj name '$libobj' may not contain shell special characters.\"\n    func_dirname_and_basename \"$obj\" \"/\" \"\"\n    objname=$func_basename_result\n    xdir=$func_dirname_result\n    lobj=$xdir$objdir/$objname\n\n    test -z \"$base_compile\" && \\\n      func_fatal_help \"you must specify a compilation command\"\n\n    # Delete any leftover library objects.\n    if test yes = \"$build_old_libs\"; then\n      removelist=\"$obj $lobj $libobj ${libobj}T\"\n    else\n      removelist=\"$lobj $libobj ${libobj}T\"\n    fi\n\n    # On Cygwin there's no \"real\" PIC flag so we must build both object types\n    case $host_os in\n    cygwin* | mingw* | pw32* | os2* | cegcc*)\n      pic_mode=default\n      ;;\n    esac\n    if test no = \"$pic_mode\" && test pass_all != \"$deplibs_check_method\"; then\n      # non-PIC code in shared libraries is not supported\n      pic_mode=default\n    fi\n\n    # Calculate the filename of the output object if compiler does\n    # not support -o with -c\n    if test no = \"$compiler_c_o\"; then\n      output_obj=`$ECHO \"$srcfile\" | $SED 's%^.*/%%; s%\\.[^.]*$%%'`.$objext\n      lockfile=$output_obj.lock\n    else\n      output_obj=\n      need_locks=no\n      lockfile=\n    fi\n\n    # Lock this critical section if it is needed\n    # We use this script file to make the link, it avoids creating a new file\n    if test yes = \"$need_locks\"; then\n      until $opt_dry_run || ln \"$progpath\" \"$lockfile\" 2>/dev/null; do\n\tfunc_echo \"Waiting for $lockfile to be removed\"\n\tsleep 2\n      done\n    elif test warn = \"$need_locks\"; then\n      if test -f \"$lockfile\"; then\n\t$ECHO \"\\\n*** ERROR, $lockfile exists and contains:\n`cat $lockfile 2>/dev/null`\n\nThis indicates that another process is trying to use the same\ntemporary object file, and libtool could not work around it because\nyour compiler does not support '-c' and '-o' together.  If you\nrepeat this compilation, it may succeed, by chance, but you had better\navoid parallel builds (make -j) in this platform, or get a better\ncompiler.\"\n\n\t$opt_dry_run || $RM $removelist\n\texit $EXIT_FAILURE\n      fi\n      func_append removelist \" $output_obj\"\n      $ECHO \"$srcfile\" > \"$lockfile\"\n    fi\n\n    $opt_dry_run || $RM $removelist\n    func_append removelist \" $lockfile\"\n    trap '$opt_dry_run || $RM $removelist; exit $EXIT_FAILURE' 1 2 15\n\n    func_to_tool_file \"$srcfile\" func_convert_file_msys_to_w32\n    srcfile=$func_to_tool_file_result\n    func_quote_for_eval \"$srcfile\"\n    qsrcfile=$func_quote_for_eval_result\n\n    # Only build a PIC object if we are building libtool libraries.\n    if test yes = \"$build_libtool_libs\"; then\n      # Without this assignment, base_compile gets emptied.\n      fbsd_hideous_sh_bug=$base_compile\n\n      if test no != \"$pic_mode\"; then\n\tcommand=\"$base_compile $qsrcfile $pic_flag\"\n      else\n\t# Don't build PIC code\n\tcommand=\"$base_compile $qsrcfile\"\n      fi\n\n      func_mkdir_p \"$xdir$objdir\"\n\n      if test -z \"$output_obj\"; then\n\t# Place PIC objects in $objdir\n\tfunc_append command \" -o $lobj\"\n      fi\n\n      func_show_eval_locale \"$command\"\t\\\n          'test -n \"$output_obj\" && $RM $removelist; exit $EXIT_FAILURE'\n\n      if test warn = \"$need_locks\" &&\n\t test \"X`cat $lockfile 2>/dev/null`\" != \"X$srcfile\"; then\n\t$ECHO \"\\\n*** ERROR, $lockfile contains:\n`cat $lockfile 2>/dev/null`\n\nbut it should contain:\n$srcfile\n\nThis indicates that another process is trying to use the same\ntemporary object file, and libtool could not work around it because\nyour compiler does not support '-c' and '-o' together.  If you\nrepeat this compilation, it may succeed, by chance, but you had better\navoid parallel builds (make -j) in this platform, or get a better\ncompiler.\"\n\n\t$opt_dry_run || $RM $removelist\n\texit $EXIT_FAILURE\n      fi\n\n      # Just move the object if needed, then go on to compile the next one\n      if test -n \"$output_obj\" && test \"X$output_obj\" != \"X$lobj\"; then\n\tfunc_show_eval '$MV \"$output_obj\" \"$lobj\"' \\\n\t  'error=$?; $opt_dry_run || $RM $removelist; exit $error'\n      fi\n\n      # Allow error messages only from the first compilation.\n      if test yes = \"$suppress_opt\"; then\n\tsuppress_output=' >/dev/null 2>&1'\n      fi\n    fi\n\n    # Only build a position-dependent object if we build old libraries.\n    if test yes = \"$build_old_libs\"; then\n      if test yes != \"$pic_mode\"; then\n\t# Don't build PIC code\n\tcommand=\"$base_compile $qsrcfile$pie_flag\"\n      else\n\tcommand=\"$base_compile $qsrcfile $pic_flag\"\n      fi\n      if test yes = \"$compiler_c_o\"; then\n\tfunc_append command \" -o $obj\"\n      fi\n\n      # Suppress compiler output if we already did a PIC compilation.\n      func_append command \"$suppress_output\"\n      func_show_eval_locale \"$command\" \\\n        '$opt_dry_run || $RM $removelist; exit $EXIT_FAILURE'\n\n      if test warn = \"$need_locks\" &&\n\t test \"X`cat $lockfile 2>/dev/null`\" != \"X$srcfile\"; then\n\t$ECHO \"\\\n*** ERROR, $lockfile contains:\n`cat $lockfile 2>/dev/null`\n\nbut it should contain:\n$srcfile\n\nThis indicates that another process is trying to use the same\ntemporary object file, and libtool could not work around it because\nyour compiler does not support '-c' and '-o' together.  If you\nrepeat this compilation, it may succeed, by chance, but you had better\navoid parallel builds (make -j) in this platform, or get a better\ncompiler.\"\n\n\t$opt_dry_run || $RM $removelist\n\texit $EXIT_FAILURE\n      fi\n\n      # Just move the object if needed\n      if test -n \"$output_obj\" && test \"X$output_obj\" != \"X$obj\"; then\n\tfunc_show_eval '$MV \"$output_obj\" \"$obj\"' \\\n\t  'error=$?; $opt_dry_run || $RM $removelist; exit $error'\n      fi\n    fi\n\n    $opt_dry_run || {\n      func_write_libtool_object \"$libobj\" \"$objdir/$objname\" \"$objname\"\n\n      # Unlock the critical section if it was locked\n      if test no != \"$need_locks\"; then\n\tremovelist=$lockfile\n        $RM \"$lockfile\"\n      fi\n    }\n\n    exit $EXIT_SUCCESS\n}\n\n$opt_help || {\n  test compile = \"$opt_mode\" && func_mode_compile ${1+\"$@\"}\n}\n\nfunc_mode_help ()\n{\n    # We need to display help for each of the modes.\n    case $opt_mode in\n      \"\")\n        # Generic help is extracted from the usage comments\n        # at the start of this file.\n        func_help\n        ;;\n\n      clean)\n        $ECHO \\\n\"Usage: $progname [OPTION]... --mode=clean RM [RM-OPTION]... FILE...\n\nRemove files from the build directory.\n\nRM is the name of the program to use to delete files associated with each FILE\n(typically '/bin/rm').  RM-OPTIONS are options (such as '-f') to be passed\nto RM.\n\nIf FILE is a libtool library, object or program, all the files associated\nwith it are deleted. Otherwise, only FILE itself is deleted using RM.\"\n        ;;\n\n      compile)\n      $ECHO \\\n\"Usage: $progname [OPTION]... --mode=compile COMPILE-COMMAND... SOURCEFILE\n\nCompile a source file into a libtool library object.\n\nThis mode accepts the following additional options:\n\n  -o OUTPUT-FILE    set the output file name to OUTPUT-FILE\n  -no-suppress      do not suppress compiler output for multiple passes\n  -prefer-pic       try to build PIC objects only\n  -prefer-non-pic   try to build non-PIC objects only\n  -shared           do not build a '.o' file suitable for static linking\n  -static           only build a '.o' file suitable for static linking\n  -Wc,FLAG          pass FLAG directly to the compiler\n\nCOMPILE-COMMAND is a command to be used in creating a 'standard' object file\nfrom the given SOURCEFILE.\n\nThe output file name is determined by removing the directory component from\nSOURCEFILE, then substituting the C source code suffix '.c' with the\nlibrary object suffix, '.lo'.\"\n        ;;\n\n      execute)\n        $ECHO \\\n\"Usage: $progname [OPTION]... --mode=execute COMMAND [ARGS]...\n\nAutomatically set library path, then run a program.\n\nThis mode accepts the following additional options:\n\n  -dlopen FILE      add the directory containing FILE to the library path\n\nThis mode sets the library path environment variable according to '-dlopen'\nflags.\n\nIf any of the ARGS are libtool executable wrappers, then they are translated\ninto their corresponding uninstalled binary, and any of their required library\ndirectories are added to the library path.\n\nThen, COMMAND is executed, with ARGS as arguments.\"\n        ;;\n\n      finish)\n        $ECHO \\\n\"Usage: $progname [OPTION]... --mode=finish [LIBDIR]...\n\nComplete the installation of libtool libraries.\n\nEach LIBDIR is a directory that contains libtool libraries.\n\nThe commands that this mode executes may require superuser privileges.  Use\nthe '--dry-run' option if you just want to see what would be executed.\"\n        ;;\n\n      install)\n        $ECHO \\\n\"Usage: $progname [OPTION]... --mode=install INSTALL-COMMAND...\n\nInstall executables or libraries.\n\nINSTALL-COMMAND is the installation command.  The first component should be\neither the 'install' or 'cp' program.\n\nThe following components of INSTALL-COMMAND are treated specially:\n\n  -inst-prefix-dir PREFIX-DIR  Use PREFIX-DIR as a staging area for installation\n\nThe rest of the components are interpreted as arguments to that command (only\nBSD-compatible install options are recognized).\"\n        ;;\n\n      link)\n        $ECHO \\\n\"Usage: $progname [OPTION]... --mode=link LINK-COMMAND...\n\nLink object files or libraries together to form another library, or to\ncreate an executable program.\n\nLINK-COMMAND is a command using the C compiler that you would use to create\na program from several object files.\n\nThe following components of LINK-COMMAND are treated specially:\n\n  -all-static       do not do any dynamic linking at all\n  -avoid-version    do not add a version suffix if possible\n  -bindir BINDIR    specify path to binaries directory (for systems where\n                    libraries must be found in the PATH setting at runtime)\n  -dlopen FILE      '-dlpreopen' FILE if it cannot be dlopened at runtime\n  -dlpreopen FILE   link in FILE and add its symbols to lt_preloaded_symbols\n  -export-dynamic   allow symbols from OUTPUT-FILE to be resolved with dlsym(3)\n  -export-symbols SYMFILE\n                    try to export only the symbols listed in SYMFILE\n  -export-symbols-regex REGEX\n                    try to export only the symbols matching REGEX\n  -LLIBDIR          search LIBDIR for required installed libraries\n  -lNAME            OUTPUT-FILE requires the installed library libNAME\n  -module           build a library that can dlopened\n  -no-fast-install  disable the fast-install mode\n  -no-install       link a not-installable executable\n  -no-undefined     declare that a library does not refer to external symbols\n  -o OUTPUT-FILE    create OUTPUT-FILE from the specified objects\n  -objectlist FILE  use a list of object files found in FILE to specify objects\n  -os2dllname NAME  force a short DLL name on OS/2 (no effect on other OSes)\n  -precious-files-regex REGEX\n                    don't remove output files matching REGEX\n  -release RELEASE  specify package release information\n  -rpath LIBDIR     the created library will eventually be installed in LIBDIR\n  -R[ ]LIBDIR       add LIBDIR to the runtime path of programs and libraries\n  -shared           only do dynamic linking of libtool libraries\n  -shrext SUFFIX    override the standard shared library file extension\n  -static           do not do any dynamic linking of uninstalled libtool libraries\n  -static-libtool-libs\n                    do not do any dynamic linking of libtool libraries\n  -version-info CURRENT[:REVISION[:AGE]]\n                    specify library version info [each variable defaults to 0]\n  -weak LIBNAME     declare that the target provides the LIBNAME interface\n  -Wc,FLAG\n  -Xcompiler FLAG   pass linker-specific FLAG directly to the compiler\n  -Wl,FLAG\n  -Xlinker FLAG     pass linker-specific FLAG directly to the linker\n  -XCClinker FLAG   pass link-specific FLAG to the compiler driver (CC)\n\nAll other options (arguments beginning with '-') are ignored.\n\nEvery other argument is treated as a filename.  Files ending in '.la' are\ntreated as uninstalled libtool libraries, other files are standard or library\nobject files.\n\nIf the OUTPUT-FILE ends in '.la', then a libtool library is created,\nonly library objects ('.lo' files) may be specified, and '-rpath' is\nrequired, except when creating a convenience library.\n\nIf OUTPUT-FILE ends in '.a' or '.lib', then a standard library is created\nusing 'ar' and 'ranlib', or on Windows using 'lib'.\n\nIf OUTPUT-FILE ends in '.lo' or '.$objext', then a reloadable object file\nis created, otherwise an executable program is created.\"\n        ;;\n\n      uninstall)\n        $ECHO \\\n\"Usage: $progname [OPTION]... --mode=uninstall RM [RM-OPTION]... FILE...\n\nRemove libraries from an installation directory.\n\nRM is the name of the program to use to delete files associated with each FILE\n(typically '/bin/rm').  RM-OPTIONS are options (such as '-f') to be passed\nto RM.\n\nIf FILE is a libtool library, all the files associated with it are deleted.\nOtherwise, only FILE itself is deleted using RM.\"\n        ;;\n\n      *)\n        func_fatal_help \"invalid operation mode '$opt_mode'\"\n        ;;\n    esac\n\n    echo\n    $ECHO \"Try '$progname --help' for more information about other modes.\"\n}\n\n# Now that we've collected a possible --mode arg, show help if necessary\nif $opt_help; then\n  if test : = \"$opt_help\"; then\n    func_mode_help\n  else\n    {\n      func_help noexit\n      for opt_mode in compile link execute install finish uninstall clean; do\n\tfunc_mode_help\n      done\n    } | $SED -n '1p; 2,$s/^Usage:/  or: /p'\n    {\n      func_help noexit\n      for opt_mode in compile link execute install finish uninstall clean; do\n\techo\n\tfunc_mode_help\n      done\n    } |\n    $SED '1d\n      /^When reporting/,/^Report/{\n\tH\n\td\n      }\n      $x\n      /information about other modes/d\n      /more detailed .*MODE/d\n      s/^Usage:.*--mode=\\([^ ]*\\) .*/Description of \\1 mode:/'\n  fi\n  exit $?\nfi\n\n\n# func_mode_execute arg...\nfunc_mode_execute ()\n{\n    $debug_cmd\n\n    # The first argument is the command name.\n    cmd=$nonopt\n    test -z \"$cmd\" && \\\n      func_fatal_help \"you must specify a COMMAND\"\n\n    # Handle -dlopen flags immediately.\n    for file in $opt_dlopen; do\n      test -f \"$file\" \\\n\t|| func_fatal_help \"'$file' is not a file\"\n\n      dir=\n      case $file in\n      *.la)\n\tfunc_resolve_sysroot \"$file\"\n\tfile=$func_resolve_sysroot_result\n\n\t# Check to see that this really is a libtool archive.\n\tfunc_lalib_unsafe_p \"$file\" \\\n\t  || func_fatal_help \"'$lib' is not a valid libtool archive\"\n\n\t# Read the libtool library.\n\tdlname=\n\tlibrary_names=\n\tfunc_source \"$file\"\n\n\t# Skip this library if it cannot be dlopened.\n\tif test -z \"$dlname\"; then\n\t  # Warn if it was a shared library.\n\t  test -n \"$library_names\" && \\\n\t    func_warning \"'$file' was not linked with '-export-dynamic'\"\n\t  continue\n\tfi\n\n\tfunc_dirname \"$file\" \"\" \".\"\n\tdir=$func_dirname_result\n\n\tif test -f \"$dir/$objdir/$dlname\"; then\n\t  func_append dir \"/$objdir\"\n\telse\n\t  if test ! -f \"$dir/$dlname\"; then\n\t    func_fatal_error \"cannot find '$dlname' in '$dir' or '$dir/$objdir'\"\n\t  fi\n\tfi\n\t;;\n\n      *.lo)\n\t# Just add the directory containing the .lo file.\n\tfunc_dirname \"$file\" \"\" \".\"\n\tdir=$func_dirname_result\n\t;;\n\n      *)\n\tfunc_warning \"'-dlopen' is ignored for non-libtool libraries and objects\"\n\tcontinue\n\t;;\n      esac\n\n      # Get the absolute pathname.\n      absdir=`cd \"$dir\" && pwd`\n      test -n \"$absdir\" && dir=$absdir\n\n      # Now add the directory to shlibpath_var.\n      if eval \"test -z \\\"\\$$shlibpath_var\\\"\"; then\n\teval \"$shlibpath_var=\\\"\\$dir\\\"\"\n      else\n\teval \"$shlibpath_var=\\\"\\$dir:\\$$shlibpath_var\\\"\"\n      fi\n    done\n\n    # This variable tells wrapper scripts just to set shlibpath_var\n    # rather than running their programs.\n    libtool_execute_magic=$magic\n\n    # Check if any of the arguments is a wrapper script.\n    args=\n    for file\n    do\n      case $file in\n      -* | *.la | *.lo ) ;;\n      *)\n\t# Do a test to see if this is really a libtool program.\n\tif func_ltwrapper_script_p \"$file\"; then\n\t  func_source \"$file\"\n\t  # Transform arg to wrapped name.\n\t  file=$progdir/$program\n\telif func_ltwrapper_executable_p \"$file\"; then\n\t  func_ltwrapper_scriptname \"$file\"\n\t  func_source \"$func_ltwrapper_scriptname_result\"\n\t  # Transform arg to wrapped name.\n\t  file=$progdir/$program\n\tfi\n\t;;\n      esac\n      # Quote arguments (to preserve shell metacharacters).\n      func_append_quoted args \"$file\"\n    done\n\n    if $opt_dry_run; then\n      # Display what would be done.\n      if test -n \"$shlibpath_var\"; then\n\teval \"\\$ECHO \\\"\\$shlibpath_var=\\$$shlibpath_var\\\"\"\n\techo \"export $shlibpath_var\"\n      fi\n      $ECHO \"$cmd$args\"\n      exit $EXIT_SUCCESS\n    else\n      if test -n \"$shlibpath_var\"; then\n\t# Export the shlibpath_var.\n\teval \"export $shlibpath_var\"\n      fi\n\n      # Restore saved environment variables\n      for lt_var in LANG LANGUAGE LC_ALL LC_CTYPE LC_COLLATE LC_MESSAGES\n      do\n\teval \"if test \\\"\\${save_$lt_var+set}\\\" = set; then\n                $lt_var=\\$save_$lt_var; export $lt_var\n\t      else\n\t\t$lt_unset $lt_var\n\t      fi\"\n      done\n\n      # Now prepare to actually exec the command.\n      exec_cmd=\\$cmd$args\n    fi\n}\n\ntest execute = \"$opt_mode\" && func_mode_execute ${1+\"$@\"}\n\n\n# func_mode_finish arg...\nfunc_mode_finish ()\n{\n    $debug_cmd\n\n    libs=\n    libdirs=\n    admincmds=\n\n    for opt in \"$nonopt\" ${1+\"$@\"}\n    do\n      if test -d \"$opt\"; then\n\tfunc_append libdirs \" $opt\"\n\n      elif test -f \"$opt\"; then\n\tif func_lalib_unsafe_p \"$opt\"; then\n\t  func_append libs \" $opt\"\n\telse\n\t  func_warning \"'$opt' is not a valid libtool archive\"\n\tfi\n\n      else\n\tfunc_fatal_error \"invalid argument '$opt'\"\n      fi\n    done\n\n    if test -n \"$libs\"; then\n      if test -n \"$lt_sysroot\"; then\n        sysroot_regex=`$ECHO \"$lt_sysroot\" | $SED \"$sed_make_literal_regex\"`\n        sysroot_cmd=\"s/\\([ ']\\)$sysroot_regex/\\1/g;\"\n      else\n        sysroot_cmd=\n      fi\n\n      # Remove sysroot references\n      if $opt_dry_run; then\n        for lib in $libs; do\n          echo \"removing references to $lt_sysroot and '=' prefixes from $lib\"\n        done\n      else\n        tmpdir=`func_mktempdir`\n        for lib in $libs; do\n\t  $SED -e \"$sysroot_cmd s/\\([ ']-[LR]\\)=/\\1/g; s/\\([ ']\\)=/\\1/g\" $lib \\\n\t    > $tmpdir/tmp-la\n\t  mv -f $tmpdir/tmp-la $lib\n\tdone\n        ${RM}r \"$tmpdir\"\n      fi\n    fi\n\n    if test -n \"$finish_cmds$finish_eval\" && test -n \"$libdirs\"; then\n      for libdir in $libdirs; do\n\tif test -n \"$finish_cmds\"; then\n\t  # Do each command in the finish commands.\n\t  func_execute_cmds \"$finish_cmds\" 'admincmds=\"$admincmds\n'\"$cmd\"'\"'\n\tfi\n\tif test -n \"$finish_eval\"; then\n\t  # Do the single finish_eval.\n\t  eval cmds=\\\"$finish_eval\\\"\n\t  $opt_dry_run || eval \"$cmds\" || func_append admincmds \"\n       $cmds\"\n\tfi\n      done\n    fi\n\n    # Exit here if they wanted silent mode.\n    $opt_quiet && exit $EXIT_SUCCESS\n\n    if test -n \"$finish_cmds$finish_eval\" && test -n \"$libdirs\"; then\n      echo \"----------------------------------------------------------------------\"\n      echo \"Libraries have been installed in:\"\n      for libdir in $libdirs; do\n\t$ECHO \"   $libdir\"\n      done\n      echo\n      echo \"If you ever happen to want to link against installed libraries\"\n      echo \"in a given directory, LIBDIR, you must either use libtool, and\"\n      echo \"specify the full pathname of the library, or use the '-LLIBDIR'\"\n      echo \"flag during linking and do at least one of the following:\"\n      if test -n \"$shlibpath_var\"; then\n\techo \"   - add LIBDIR to the '$shlibpath_var' environment variable\"\n\techo \"     during execution\"\n      fi\n      if test -n \"$runpath_var\"; then\n\techo \"   - add LIBDIR to the '$runpath_var' environment variable\"\n\techo \"     during linking\"\n      fi\n      if test -n \"$hardcode_libdir_flag_spec\"; then\n\tlibdir=LIBDIR\n\teval flag=\\\"$hardcode_libdir_flag_spec\\\"\n\n\t$ECHO \"   - use the '$flag' linker flag\"\n      fi\n      if test -n \"$admincmds\"; then\n\t$ECHO \"   - have your system administrator run these commands:$admincmds\"\n      fi\n      if test -f /etc/ld.so.conf; then\n\techo \"   - have your system administrator add LIBDIR to '/etc/ld.so.conf'\"\n      fi\n      echo\n\n      echo \"See any operating system documentation about shared libraries for\"\n      case $host in\n\tsolaris2.[6789]|solaris2.1[0-9])\n\t  echo \"more information, such as the ld(1), crle(1) and ld.so(8) manual\"\n\t  echo \"pages.\"\n\t  ;;\n\t*)\n\t  echo \"more information, such as the ld(1) and ld.so(8) manual pages.\"\n\t  ;;\n      esac\n      echo \"----------------------------------------------------------------------\"\n    fi\n    exit $EXIT_SUCCESS\n}\n\ntest finish = \"$opt_mode\" && func_mode_finish ${1+\"$@\"}\n\n\n# func_mode_install arg...\nfunc_mode_install ()\n{\n    $debug_cmd\n\n    # There may be an optional sh(1) argument at the beginning of\n    # install_prog (especially on Windows NT).\n    if test \"$SHELL\" = \"$nonopt\" || test /bin/sh = \"$nonopt\" ||\n       # Allow the use of GNU shtool's install command.\n       case $nonopt in *shtool*) :;; *) false;; esac\n    then\n      # Aesthetically quote it.\n      func_quote_for_eval \"$nonopt\"\n      install_prog=\"$func_quote_for_eval_result \"\n      arg=$1\n      shift\n    else\n      install_prog=\n      arg=$nonopt\n    fi\n\n    # The real first argument should be the name of the installation program.\n    # Aesthetically quote it.\n    func_quote_for_eval \"$arg\"\n    func_append install_prog \"$func_quote_for_eval_result\"\n    install_shared_prog=$install_prog\n    case \" $install_prog \" in\n      *[\\\\\\ /]cp\\ *) install_cp=: ;;\n      *) install_cp=false ;;\n    esac\n\n    # We need to accept at least all the BSD install flags.\n    dest=\n    files=\n    opts=\n    prev=\n    install_type=\n    isdir=false\n    stripme=\n    no_mode=:\n    for arg\n    do\n      arg2=\n      if test -n \"$dest\"; then\n\tfunc_append files \" $dest\"\n\tdest=$arg\n\tcontinue\n      fi\n\n      case $arg in\n      -d) isdir=: ;;\n      -f)\n\tif $install_cp; then :; else\n\t  prev=$arg\n\tfi\n\t;;\n      -g | -m | -o)\n\tprev=$arg\n\t;;\n      -s)\n\tstripme=\" -s\"\n\tcontinue\n\t;;\n      -*)\n\t;;\n      *)\n\t# If the previous option needed an argument, then skip it.\n\tif test -n \"$prev\"; then\n\t  if test X-m = \"X$prev\" && test -n \"$install_override_mode\"; then\n\t    arg2=$install_override_mode\n\t    no_mode=false\n\t  fi\n\t  prev=\n\telse\n\t  dest=$arg\n\t  continue\n\tfi\n\t;;\n      esac\n\n      # Aesthetically quote the argument.\n      func_quote_for_eval \"$arg\"\n      func_append install_prog \" $func_quote_for_eval_result\"\n      if test -n \"$arg2\"; then\n\tfunc_quote_for_eval \"$arg2\"\n      fi\n      func_append install_shared_prog \" $func_quote_for_eval_result\"\n    done\n\n    test -z \"$install_prog\" && \\\n      func_fatal_help \"you must specify an install program\"\n\n    test -n \"$prev\" && \\\n      func_fatal_help \"the '$prev' option requires an argument\"\n\n    if test -n \"$install_override_mode\" && $no_mode; then\n      if $install_cp; then :; else\n\tfunc_quote_for_eval \"$install_override_mode\"\n\tfunc_append install_shared_prog \" -m $func_quote_for_eval_result\"\n      fi\n    fi\n\n    if test -z \"$files\"; then\n      if test -z \"$dest\"; then\n\tfunc_fatal_help \"no file or destination specified\"\n      else\n\tfunc_fatal_help \"you must specify a destination\"\n      fi\n    fi\n\n    # Strip any trailing slash from the destination.\n    func_stripname '' '/' \"$dest\"\n    dest=$func_stripname_result\n\n    # Check to see that the destination is a directory.\n    test -d \"$dest\" && isdir=:\n    if $isdir; then\n      destdir=$dest\n      destname=\n    else\n      func_dirname_and_basename \"$dest\" \"\" \".\"\n      destdir=$func_dirname_result\n      destname=$func_basename_result\n\n      # Not a directory, so check to see that there is only one file specified.\n      set dummy $files; shift\n      test \"$#\" -gt 1 && \\\n\tfunc_fatal_help \"'$dest' is not a directory\"\n    fi\n    case $destdir in\n    [\\\\/]* | [A-Za-z]:[\\\\/]*) ;;\n    *)\n      for file in $files; do\n\tcase $file in\n\t*.lo) ;;\n\t*)\n\t  func_fatal_help \"'$destdir' must be an absolute directory name\"\n\t  ;;\n\tesac\n      done\n      ;;\n    esac\n\n    # This variable tells wrapper scripts just to set variables rather\n    # than running their programs.\n    libtool_install_magic=$magic\n\n    staticlibs=\n    future_libdirs=\n    current_libdirs=\n    for file in $files; do\n\n      # Do each installation.\n      case $file in\n      *.$libext)\n\t# Do the static libraries later.\n\tfunc_append staticlibs \" $file\"\n\t;;\n\n      *.la)\n\tfunc_resolve_sysroot \"$file\"\n\tfile=$func_resolve_sysroot_result\n\n\t# Check to see that this really is a libtool archive.\n\tfunc_lalib_unsafe_p \"$file\" \\\n\t  || func_fatal_help \"'$file' is not a valid libtool archive\"\n\n\tlibrary_names=\n\told_library=\n\trelink_command=\n\tfunc_source \"$file\"\n\n\t# Add the libdir to current_libdirs if it is the destination.\n\tif test \"X$destdir\" = \"X$libdir\"; then\n\t  case \"$current_libdirs \" in\n\t  *\" $libdir \"*) ;;\n\t  *) func_append current_libdirs \" $libdir\" ;;\n\t  esac\n\telse\n\t  # Note the libdir as a future libdir.\n\t  case \"$future_libdirs \" in\n\t  *\" $libdir \"*) ;;\n\t  *) func_append future_libdirs \" $libdir\" ;;\n\t  esac\n\tfi\n\n\tfunc_dirname \"$file\" \"/\" \"\"\n\tdir=$func_dirname_result\n\tfunc_append dir \"$objdir\"\n\n\tif test -n \"$relink_command\"; then\n\t  # Determine the prefix the user has applied to our future dir.\n\t  inst_prefix_dir=`$ECHO \"$destdir\" | $SED -e \"s%$libdir\\$%%\"`\n\n\t  # Don't allow the user to place us outside of our expected\n\t  # location b/c this prevents finding dependent libraries that\n\t  # are installed to the same prefix.\n\t  # At present, this check doesn't affect windows .dll's that\n\t  # are installed into $libdir/../bin (currently, that works fine)\n\t  # but it's something to keep an eye on.\n\t  test \"$inst_prefix_dir\" = \"$destdir\" && \\\n\t    func_fatal_error \"error: cannot install '$file' to a directory not ending in $libdir\"\n\n\t  if test -n \"$inst_prefix_dir\"; then\n\t    # Stick the inst_prefix_dir data into the link command.\n\t    relink_command=`$ECHO \"$relink_command\" | $SED \"s%@inst_prefix_dir@%-inst-prefix-dir $inst_prefix_dir%\"`\n\t  else\n\t    relink_command=`$ECHO \"$relink_command\" | $SED \"s%@inst_prefix_dir@%%\"`\n\t  fi\n\n\t  func_warning \"relinking '$file'\"\n\t  func_show_eval \"$relink_command\" \\\n\t    'func_fatal_error \"error: relink '\\''$file'\\'' with the above command before installing it\"'\n\tfi\n\n\t# See the names of the shared library.\n\tset dummy $library_names; shift\n\tif test -n \"$1\"; then\n\t  realname=$1\n\t  shift\n\n\t  srcname=$realname\n\t  test -n \"$relink_command\" && srcname=${realname}T\n\n\t  # Install the shared library and build the symlinks.\n\t  func_show_eval \"$install_shared_prog $dir/$srcname $destdir/$realname\" \\\n\t      'exit $?'\n\t  tstripme=$stripme\n\t  case $host_os in\n\t  cygwin* | mingw* | pw32* | cegcc*)\n\t    case $realname in\n\t    *.dll.a)\n\t      tstripme=\n\t      ;;\n\t    esac\n\t    ;;\n\t  os2*)\n\t    case $realname in\n\t    *_dll.a)\n\t      tstripme=\n\t      ;;\n\t    esac\n\t    ;;\n\t  esac\n\t  if test -n \"$tstripme\" && test -n \"$striplib\"; then\n\t    func_show_eval \"$striplib $destdir/$realname\" 'exit $?'\n\t  fi\n\n\t  if test \"$#\" -gt 0; then\n\t    # Delete the old symlinks, and create new ones.\n\t    # Try 'ln -sf' first, because the 'ln' binary might depend on\n\t    # the symlink we replace!  Solaris /bin/ln does not understand -f,\n\t    # so we also need to try rm && ln -s.\n\t    for linkname\n\t    do\n\t      test \"$linkname\" != \"$realname\" \\\n\t\t&& func_show_eval \"(cd $destdir && { $LN_S -f $realname $linkname || { $RM $linkname && $LN_S $realname $linkname; }; })\"\n\t    done\n\t  fi\n\n\t  # Do each command in the postinstall commands.\n\t  lib=$destdir/$realname\n\t  func_execute_cmds \"$postinstall_cmds\" 'exit $?'\n\tfi\n\n\t# Install the pseudo-library for information purposes.\n\tfunc_basename \"$file\"\n\tname=$func_basename_result\n\tinstname=$dir/${name}i\n\tfunc_show_eval \"$install_prog $instname $destdir/$name\" 'exit $?'\n\n\t# Maybe install the static library, too.\n\ttest -n \"$old_library\" && func_append staticlibs \" $dir/$old_library\"\n\t;;\n\n      *.lo)\n\t# Install (i.e. copy) a libtool object.\n\n\t# Figure out destination file name, if it wasn't already specified.\n\tif test -n \"$destname\"; then\n\t  destfile=$destdir/$destname\n\telse\n\t  func_basename \"$file\"\n\t  destfile=$func_basename_result\n\t  destfile=$destdir/$destfile\n\tfi\n\n\t# Deduce the name of the destination old-style object file.\n\tcase $destfile in\n\t*.lo)\n\t  func_lo2o \"$destfile\"\n\t  staticdest=$func_lo2o_result\n\t  ;;\n\t*.$objext)\n\t  staticdest=$destfile\n\t  destfile=\n\t  ;;\n\t*)\n\t  func_fatal_help \"cannot copy a libtool object to '$destfile'\"\n\t  ;;\n\tesac\n\n\t# Install the libtool object if requested.\n\ttest -n \"$destfile\" && \\\n\t  func_show_eval \"$install_prog $file $destfile\" 'exit $?'\n\n\t# Install the old object if enabled.\n\tif test yes = \"$build_old_libs\"; then\n\t  # Deduce the name of the old-style object file.\n\t  func_lo2o \"$file\"\n\t  staticobj=$func_lo2o_result\n\t  func_show_eval \"$install_prog \\$staticobj \\$staticdest\" 'exit $?'\n\tfi\n\texit $EXIT_SUCCESS\n\t;;\n\n      *)\n\t# Figure out destination file name, if it wasn't already specified.\n\tif test -n \"$destname\"; then\n\t  destfile=$destdir/$destname\n\telse\n\t  func_basename \"$file\"\n\t  destfile=$func_basename_result\n\t  destfile=$destdir/$destfile\n\tfi\n\n\t# If the file is missing, and there is a .exe on the end, strip it\n\t# because it is most likely a libtool script we actually want to\n\t# install\n\tstripped_ext=\n\tcase $file in\n\t  *.exe)\n\t    if test ! -f \"$file\"; then\n\t      func_stripname '' '.exe' \"$file\"\n\t      file=$func_stripname_result\n\t      stripped_ext=.exe\n\t    fi\n\t    ;;\n\tesac\n\n\t# Do a test to see if this is really a libtool program.\n\tcase $host in\n\t*cygwin* | *mingw*)\n\t    if func_ltwrapper_executable_p \"$file\"; then\n\t      func_ltwrapper_scriptname \"$file\"\n\t      wrapper=$func_ltwrapper_scriptname_result\n\t    else\n\t      func_stripname '' '.exe' \"$file\"\n\t      wrapper=$func_stripname_result\n\t    fi\n\t    ;;\n\t*)\n\t    wrapper=$file\n\t    ;;\n\tesac\n\tif func_ltwrapper_script_p \"$wrapper\"; then\n\t  notinst_deplibs=\n\t  relink_command=\n\n\t  func_source \"$wrapper\"\n\n\t  # Check the variables that should have been set.\n\t  test -z \"$generated_by_libtool_version\" && \\\n\t    func_fatal_error \"invalid libtool wrapper script '$wrapper'\"\n\n\t  finalize=:\n\t  for lib in $notinst_deplibs; do\n\t    # Check to see that each library is installed.\n\t    libdir=\n\t    if test -f \"$lib\"; then\n\t      func_source \"$lib\"\n\t    fi\n\t    libfile=$libdir/`$ECHO \"$lib\" | $SED 's%^.*/%%g'`\n\t    if test -n \"$libdir\" && test ! -f \"$libfile\"; then\n\t      func_warning \"'$lib' has not been installed in '$libdir'\"\n\t      finalize=false\n\t    fi\n\t  done\n\n\t  relink_command=\n\t  func_source \"$wrapper\"\n\n\t  outputname=\n\t  if test no = \"$fast_install\" && test -n \"$relink_command\"; then\n\t    $opt_dry_run || {\n\t      if $finalize; then\n\t        tmpdir=`func_mktempdir`\n\t\tfunc_basename \"$file$stripped_ext\"\n\t\tfile=$func_basename_result\n\t        outputname=$tmpdir/$file\n\t        # Replace the output file specification.\n\t        relink_command=`$ECHO \"$relink_command\" | $SED 's%@OUTPUT@%'\"$outputname\"'%g'`\n\n\t        $opt_quiet || {\n\t          func_quote_for_expand \"$relink_command\"\n\t\t  eval \"func_echo $func_quote_for_expand_result\"\n\t        }\n\t        if eval \"$relink_command\"; then :\n\t          else\n\t\t  func_error \"error: relink '$file' with the above command before installing it\"\n\t\t  $opt_dry_run || ${RM}r \"$tmpdir\"\n\t\t  continue\n\t        fi\n\t        file=$outputname\n\t      else\n\t        func_warning \"cannot relink '$file'\"\n\t      fi\n\t    }\n\t  else\n\t    # Install the binary that we compiled earlier.\n\t    file=`$ECHO \"$file$stripped_ext\" | $SED \"s%\\([^/]*\\)$%$objdir/\\1%\"`\n\t  fi\n\tfi\n\n\t# remove .exe since cygwin /usr/bin/install will append another\n\t# one anyway\n\tcase $install_prog,$host in\n\t*/usr/bin/install*,*cygwin*)\n\t  case $file:$destfile in\n\t  *.exe:*.exe)\n\t    # this is ok\n\t    ;;\n\t  *.exe:*)\n\t    destfile=$destfile.exe\n\t    ;;\n\t  *:*.exe)\n\t    func_stripname '' '.exe' \"$destfile\"\n\t    destfile=$func_stripname_result\n\t    ;;\n\t  esac\n\t  ;;\n\tesac\n\tfunc_show_eval \"$install_prog\\$stripme \\$file \\$destfile\" 'exit $?'\n\t$opt_dry_run || if test -n \"$outputname\"; then\n\t  ${RM}r \"$tmpdir\"\n\tfi\n\t;;\n      esac\n    done\n\n    for file in $staticlibs; do\n      func_basename \"$file\"\n      name=$func_basename_result\n\n      # Set up the ranlib parameters.\n      oldlib=$destdir/$name\n      func_to_tool_file \"$oldlib\" func_convert_file_msys_to_w32\n      tool_oldlib=$func_to_tool_file_result\n\n      func_show_eval \"$install_prog \\$file \\$oldlib\" 'exit $?'\n\n      if test -n \"$stripme\" && test -n \"$old_striplib\"; then\n\tfunc_show_eval \"$old_striplib $tool_oldlib\" 'exit $?'\n      fi\n\n      # Do each command in the postinstall commands.\n      func_execute_cmds \"$old_postinstall_cmds\" 'exit $?'\n    done\n\n    test -n \"$future_libdirs\" && \\\n      func_warning \"remember to run '$progname --finish$future_libdirs'\"\n\n    if test -n \"$current_libdirs\"; then\n      # Maybe just do a dry run.\n      $opt_dry_run && current_libdirs=\" -n$current_libdirs\"\n      exec_cmd='$SHELL \"$progpath\" $preserve_args --finish$current_libdirs'\n    else\n      exit $EXIT_SUCCESS\n    fi\n}\n\ntest install = \"$opt_mode\" && func_mode_install ${1+\"$@\"}\n\n\n# func_generate_dlsyms outputname originator pic_p\n# Extract symbols from dlprefiles and create ${outputname}S.o with\n# a dlpreopen symbol table.\nfunc_generate_dlsyms ()\n{\n    $debug_cmd\n\n    my_outputname=$1\n    my_originator=$2\n    my_pic_p=${3-false}\n    my_prefix=`$ECHO \"$my_originator\" | $SED 's%[^a-zA-Z0-9]%_%g'`\n    my_dlsyms=\n\n    if test -n \"$dlfiles$dlprefiles\" || test no != \"$dlself\"; then\n      if test -n \"$NM\" && test -n \"$global_symbol_pipe\"; then\n\tmy_dlsyms=${my_outputname}S.c\n      else\n\tfunc_error \"not configured to extract global symbols from dlpreopened files\"\n      fi\n    fi\n\n    if test -n \"$my_dlsyms\"; then\n      case $my_dlsyms in\n      \"\") ;;\n      *.c)\n\t# Discover the nlist of each of the dlfiles.\n\tnlist=$output_objdir/$my_outputname.nm\n\n\tfunc_show_eval \"$RM $nlist ${nlist}S ${nlist}T\"\n\n\t# Parse the name list into a source file.\n\tfunc_verbose \"creating $output_objdir/$my_dlsyms\"\n\n\t$opt_dry_run || $ECHO > \"$output_objdir/$my_dlsyms\" \"\\\n/* $my_dlsyms - symbol resolution table for '$my_outputname' dlsym emulation. */\n/* Generated by $PROGRAM (GNU $PACKAGE) $VERSION */\n\n#ifdef __cplusplus\nextern \\\"C\\\" {\n#endif\n\n#if defined __GNUC__ && (((__GNUC__ == 4) && (__GNUC_MINOR__ >= 4)) || (__GNUC__ > 4))\n#pragma GCC diagnostic ignored \\\"-Wstrict-prototypes\\\"\n#endif\n\n/* Keep this code in sync between libtool.m4, ltmain, lt_system.h, and tests.  */\n#if defined _WIN32 || defined __CYGWIN__ || defined _WIN32_WCE\n/* DATA imports from DLLs on WIN32 can't be const, because runtime\n   relocations are performed -- see ld's documentation on pseudo-relocs.  */\n# define LT_DLSYM_CONST\n#elif defined __osf__\n/* This system does not cope well with relocations in const data.  */\n# define LT_DLSYM_CONST\n#else\n# define LT_DLSYM_CONST const\n#endif\n\n#define STREQ(s1, s2) (strcmp ((s1), (s2)) == 0)\n\n/* External symbol declarations for the compiler. */\\\n\"\n\n\tif test yes = \"$dlself\"; then\n\t  func_verbose \"generating symbol list for '$output'\"\n\n\t  $opt_dry_run || echo ': @PROGRAM@ ' > \"$nlist\"\n\n\t  # Add our own program objects to the symbol list.\n\t  progfiles=`$ECHO \"$objs$old_deplibs\" | $SP2NL | $SED \"$lo2o\" | $NL2SP`\n\t  for progfile in $progfiles; do\n\t    func_to_tool_file \"$progfile\" func_convert_file_msys_to_w32\n\t    func_verbose \"extracting global C symbols from '$func_to_tool_file_result'\"\n\t    $opt_dry_run || eval \"$NM $func_to_tool_file_result | $global_symbol_pipe >> '$nlist'\"\n\t  done\n\n\t  if test -n \"$exclude_expsyms\"; then\n\t    $opt_dry_run || {\n\t      eval '$EGREP -v \" ($exclude_expsyms)$\" \"$nlist\" > \"$nlist\"T'\n\t      eval '$MV \"$nlist\"T \"$nlist\"'\n\t    }\n\t  fi\n\n\t  if test -n \"$export_symbols_regex\"; then\n\t    $opt_dry_run || {\n\t      eval '$EGREP -e \"$export_symbols_regex\" \"$nlist\" > \"$nlist\"T'\n\t      eval '$MV \"$nlist\"T \"$nlist\"'\n\t    }\n\t  fi\n\n\t  # Prepare the list of exported symbols\n\t  if test -z \"$export_symbols\"; then\n\t    export_symbols=$output_objdir/$outputname.exp\n\t    $opt_dry_run || {\n\t      $RM $export_symbols\n\t      eval \"$SED -n -e '/^: @PROGRAM@ $/d' -e 's/^.* \\(.*\\)$/\\1/p' \"'< \"$nlist\" > \"$export_symbols\"'\n\t      case $host in\n\t      *cygwin* | *mingw* | *cegcc* )\n                eval \"echo EXPORTS \"'> \"$output_objdir/$outputname.def\"'\n                eval 'cat \"$export_symbols\" >> \"$output_objdir/$outputname.def\"'\n\t        ;;\n\t      esac\n\t    }\n\t  else\n\t    $opt_dry_run || {\n\t      eval \"$SED -e 's/\\([].[*^$]\\)/\\\\\\\\\\1/g' -e 's/^/ /' -e 's/$/$/'\"' < \"$export_symbols\" > \"$output_objdir/$outputname.exp\"'\n\t      eval '$GREP -f \"$output_objdir/$outputname.exp\" < \"$nlist\" > \"$nlist\"T'\n\t      eval '$MV \"$nlist\"T \"$nlist\"'\n\t      case $host in\n\t        *cygwin* | *mingw* | *cegcc* )\n\t          eval \"echo EXPORTS \"'> \"$output_objdir/$outputname.def\"'\n\t          eval 'cat \"$nlist\" >> \"$output_objdir/$outputname.def\"'\n\t          ;;\n\t      esac\n\t    }\n\t  fi\n\tfi\n\n\tfor dlprefile in $dlprefiles; do\n\t  func_verbose \"extracting global C symbols from '$dlprefile'\"\n\t  func_basename \"$dlprefile\"\n\t  name=$func_basename_result\n          case $host in\n\t    *cygwin* | *mingw* | *cegcc* )\n\t      # if an import library, we need to obtain dlname\n\t      if func_win32_import_lib_p \"$dlprefile\"; then\n\t        func_tr_sh \"$dlprefile\"\n\t        eval \"curr_lafile=\\$libfile_$func_tr_sh_result\"\n\t        dlprefile_dlbasename=\n\t        if test -n \"$curr_lafile\" && func_lalib_p \"$curr_lafile\"; then\n\t          # Use subshell, to avoid clobbering current variable values\n\t          dlprefile_dlname=`source \"$curr_lafile\" && echo \"$dlname\"`\n\t          if test -n \"$dlprefile_dlname\"; then\n\t            func_basename \"$dlprefile_dlname\"\n\t            dlprefile_dlbasename=$func_basename_result\n\t          else\n\t            # no lafile. user explicitly requested -dlpreopen <import library>.\n\t            $sharedlib_from_linklib_cmd \"$dlprefile\"\n\t            dlprefile_dlbasename=$sharedlib_from_linklib_result\n\t          fi\n\t        fi\n\t        $opt_dry_run || {\n\t          if test -n \"$dlprefile_dlbasename\"; then\n\t            eval '$ECHO \": $dlprefile_dlbasename\" >> \"$nlist\"'\n\t          else\n\t            func_warning \"Could not compute DLL name from $name\"\n\t            eval '$ECHO \": $name \" >> \"$nlist\"'\n\t          fi\n\t          func_to_tool_file \"$dlprefile\" func_convert_file_msys_to_w32\n\t          eval \"$NM \\\"$func_to_tool_file_result\\\" 2>/dev/null | $global_symbol_pipe |\n\t            $SED -e '/I __imp/d' -e 's/I __nm_/D /;s/_nm__//' >> '$nlist'\"\n\t        }\n\t      else # not an import lib\n\t        $opt_dry_run || {\n\t          eval '$ECHO \": $name \" >> \"$nlist\"'\n\t          func_to_tool_file \"$dlprefile\" func_convert_file_msys_to_w32\n\t          eval \"$NM \\\"$func_to_tool_file_result\\\" 2>/dev/null | $global_symbol_pipe >> '$nlist'\"\n\t        }\n\t      fi\n\t    ;;\n\t    *)\n\t      $opt_dry_run || {\n\t        eval '$ECHO \": $name \" >> \"$nlist\"'\n\t        func_to_tool_file \"$dlprefile\" func_convert_file_msys_to_w32\n\t        eval \"$NM \\\"$func_to_tool_file_result\\\" 2>/dev/null | $global_symbol_pipe >> '$nlist'\"\n\t      }\n\t    ;;\n          esac\n\tdone\n\n\t$opt_dry_run || {\n\t  # Make sure we have at least an empty file.\n\t  test -f \"$nlist\" || : > \"$nlist\"\n\n\t  if test -n \"$exclude_expsyms\"; then\n\t    $EGREP -v \" ($exclude_expsyms)$\" \"$nlist\" > \"$nlist\"T\n\t    $MV \"$nlist\"T \"$nlist\"\n\t  fi\n\n\t  # Try sorting and uniquifying the output.\n\t  if $GREP -v \"^: \" < \"$nlist\" |\n\t      if sort -k 3 </dev/null >/dev/null 2>&1; then\n\t\tsort -k 3\n\t      else\n\t\tsort +2\n\t      fi |\n\t      uniq > \"$nlist\"S; then\n\t    :\n\t  else\n\t    $GREP -v \"^: \" < \"$nlist\" > \"$nlist\"S\n\t  fi\n\n\t  if test -f \"$nlist\"S; then\n\t    eval \"$global_symbol_to_cdecl\"' < \"$nlist\"S >> \"$output_objdir/$my_dlsyms\"'\n\t  else\n\t    echo '/* NONE */' >> \"$output_objdir/$my_dlsyms\"\n\t  fi\n\n\t  func_show_eval '$RM \"${nlist}I\"'\n\t  if test -n \"$global_symbol_to_import\"; then\n\t    eval \"$global_symbol_to_import\"' < \"$nlist\"S > \"$nlist\"I'\n\t  fi\n\n\t  echo >> \"$output_objdir/$my_dlsyms\" \"\\\n\n/* The mapping between symbol names and symbols.  */\ntypedef struct {\n  const char *name;\n  void *address;\n} lt_dlsymlist;\nextern LT_DLSYM_CONST lt_dlsymlist\nlt_${my_prefix}_LTX_preloaded_symbols[];\\\n\"\n\n\t  if test -s \"$nlist\"I; then\n\t    echo >> \"$output_objdir/$my_dlsyms\" \"\\\nstatic void lt_syminit(void)\n{\n  LT_DLSYM_CONST lt_dlsymlist *symbol = lt_${my_prefix}_LTX_preloaded_symbols;\n  for (; symbol->name; ++symbol)\n    {\"\n\t    $SED 's/.*/      if (STREQ (symbol->name, \\\"&\\\")) symbol->address = (void *) \\&&;/' < \"$nlist\"I >> \"$output_objdir/$my_dlsyms\"\n\t    echo >> \"$output_objdir/$my_dlsyms\" \"\\\n    }\n}\"\n\t  fi\n\t  echo >> \"$output_objdir/$my_dlsyms\" \"\\\nLT_DLSYM_CONST lt_dlsymlist\nlt_${my_prefix}_LTX_preloaded_symbols[] =\n{ {\\\"$my_originator\\\", (void *) 0},\"\n\n\t  if test -s \"$nlist\"I; then\n\t    echo >> \"$output_objdir/$my_dlsyms\" \"\\\n  {\\\"@INIT@\\\", (void *) &lt_syminit},\"\n\t  fi\n\n\t  case $need_lib_prefix in\n\t  no)\n\t    eval \"$global_symbol_to_c_name_address\" < \"$nlist\" >> \"$output_objdir/$my_dlsyms\"\n\t    ;;\n\t  *)\n\t    eval \"$global_symbol_to_c_name_address_lib_prefix\" < \"$nlist\" >> \"$output_objdir/$my_dlsyms\"\n\t    ;;\n\t  esac\n\t  echo >> \"$output_objdir/$my_dlsyms\" \"\\\n  {0, (void *) 0}\n};\n\n/* This works around a problem in FreeBSD linker */\n#ifdef FREEBSD_WORKAROUND\nstatic const void *lt_preloaded_setup() {\n  return lt_${my_prefix}_LTX_preloaded_symbols;\n}\n#endif\n\n#ifdef __cplusplus\n}\n#endif\\\n\"\n\t} # !$opt_dry_run\n\n\tpic_flag_for_symtable=\n\tcase \"$compile_command \" in\n\t*\" -static \"*) ;;\n\t*)\n\t  case $host in\n\t  # compiling the symbol table file with pic_flag works around\n\t  # a FreeBSD bug that causes programs to crash when -lm is\n\t  # linked before any other PIC object.  But we must not use\n\t  # pic_flag when linking with -static.  The problem exists in\n\t  # FreeBSD 2.2.6 and is fixed in FreeBSD 3.1.\n\t  *-*-freebsd2.*|*-*-freebsd3.0*|*-*-freebsdelf3.0*)\n\t    pic_flag_for_symtable=\" $pic_flag -DFREEBSD_WORKAROUND\" ;;\n\t  *-*-hpux*)\n\t    pic_flag_for_symtable=\" $pic_flag\"  ;;\n\t  *)\n\t    $my_pic_p && pic_flag_for_symtable=\" $pic_flag\"\n\t    ;;\n\t  esac\n\t  ;;\n\tesac\n\tsymtab_cflags=\n\tfor arg in $LTCFLAGS; do\n\t  case $arg in\n\t  -pie | -fpie | -fPIE) ;;\n\t  *) func_append symtab_cflags \" $arg\" ;;\n\t  esac\n\tdone\n\n\t# Now compile the dynamic symbol file.\n\tfunc_show_eval '(cd $output_objdir && $LTCC$symtab_cflags -c$no_builtin_flag$pic_flag_for_symtable \"$my_dlsyms\")' 'exit $?'\n\n\t# Clean up the generated files.\n\tfunc_show_eval '$RM \"$output_objdir/$my_dlsyms\" \"$nlist\" \"${nlist}S\" \"${nlist}T\" \"${nlist}I\"'\n\n\t# Transform the symbol file into the correct name.\n\tsymfileobj=$output_objdir/${my_outputname}S.$objext\n\tcase $host in\n\t*cygwin* | *mingw* | *cegcc* )\n\t  if test -f \"$output_objdir/$my_outputname.def\"; then\n\t    compile_command=`$ECHO \"$compile_command\" | $SED \"s%@SYMFILE@%$output_objdir/$my_outputname.def $symfileobj%\"`\n\t    finalize_command=`$ECHO \"$finalize_command\" | $SED \"s%@SYMFILE@%$output_objdir/$my_outputname.def $symfileobj%\"`\n\t  else\n\t    compile_command=`$ECHO \"$compile_command\" | $SED \"s%@SYMFILE@%$symfileobj%\"`\n\t    finalize_command=`$ECHO \"$finalize_command\" | $SED \"s%@SYMFILE@%$symfileobj%\"`\n\t  fi\n\t  ;;\n\t*)\n\t  compile_command=`$ECHO \"$compile_command\" | $SED \"s%@SYMFILE@%$symfileobj%\"`\n\t  finalize_command=`$ECHO \"$finalize_command\" | $SED \"s%@SYMFILE@%$symfileobj%\"`\n\t  ;;\n\tesac\n\t;;\n      *)\n\tfunc_fatal_error \"unknown suffix for '$my_dlsyms'\"\n\t;;\n      esac\n    else\n      # We keep going just in case the user didn't refer to\n      # lt_preloaded_symbols.  The linker will fail if global_symbol_pipe\n      # really was required.\n\n      # Nullify the symbol file.\n      compile_command=`$ECHO \"$compile_command\" | $SED \"s% @SYMFILE@%%\"`\n      finalize_command=`$ECHO \"$finalize_command\" | $SED \"s% @SYMFILE@%%\"`\n    fi\n}\n\n# func_cygming_gnu_implib_p ARG\n# This predicate returns with zero status (TRUE) if\n# ARG is a GNU/binutils-style import library. Returns\n# with nonzero status (FALSE) otherwise.\nfunc_cygming_gnu_implib_p ()\n{\n  $debug_cmd\n\n  func_to_tool_file \"$1\" func_convert_file_msys_to_w32\n  func_cygming_gnu_implib_tmp=`$NM \"$func_to_tool_file_result\" | eval \"$global_symbol_pipe\" | $EGREP ' (_head_[A-Za-z0-9_]+_[ad]l*|[A-Za-z0-9_]+_[ad]l*_iname)$'`\n  test -n \"$func_cygming_gnu_implib_tmp\"\n}\n\n# func_cygming_ms_implib_p ARG\n# This predicate returns with zero status (TRUE) if\n# ARG is an MS-style import library. Returns\n# with nonzero status (FALSE) otherwise.\nfunc_cygming_ms_implib_p ()\n{\n  $debug_cmd\n\n  func_to_tool_file \"$1\" func_convert_file_msys_to_w32\n  func_cygming_ms_implib_tmp=`$NM \"$func_to_tool_file_result\" | eval \"$global_symbol_pipe\" | $GREP '_NULL_IMPORT_DESCRIPTOR'`\n  test -n \"$func_cygming_ms_implib_tmp\"\n}\n\n# func_win32_libid arg\n# return the library type of file 'arg'\n#\n# Need a lot of goo to handle *both* DLLs and import libs\n# Has to be a shell function in order to 'eat' the argument\n# that is supplied when $file_magic_command is called.\n# Despite the name, also deal with 64 bit binaries.\nfunc_win32_libid ()\n{\n  $debug_cmd\n\n  win32_libid_type=unknown\n  win32_fileres=`file -L $1 2>/dev/null`\n  case $win32_fileres in\n  *ar\\ archive\\ import\\ library*) # definitely import\n    win32_libid_type=\"x86 archive import\"\n    ;;\n  *ar\\ archive*) # could be an import, or static\n    # Keep the egrep pattern in sync with the one in _LT_CHECK_MAGIC_METHOD.\n    if eval $OBJDUMP -f $1 | $SED -e '10q' 2>/dev/null |\n       $EGREP 'file format (pei*-i386(.*architecture: i386)?|pe-arm-wince|pe-x86-64)' >/dev/null; then\n      case $nm_interface in\n      \"MS dumpbin\")\n\tif func_cygming_ms_implib_p \"$1\" ||\n\t   func_cygming_gnu_implib_p \"$1\"\n\tthen\n\t  win32_nmres=import\n\telse\n\t  win32_nmres=\n\tfi\n\t;;\n      *)\n\tfunc_to_tool_file \"$1\" func_convert_file_msys_to_w32\n\twin32_nmres=`eval $NM -f posix -A \\\"$func_to_tool_file_result\\\" |\n\t  $SED -n -e '\n\t    1,100{\n\t\t/ I /{\n\t\t    s|.*|import|\n\t\t    p\n\t\t    q\n\t\t}\n\t    }'`\n\t;;\n      esac\n      case $win32_nmres in\n      import*)  win32_libid_type=\"x86 archive import\";;\n      *)        win32_libid_type=\"x86 archive static\";;\n      esac\n    fi\n    ;;\n  *DLL*)\n    win32_libid_type=\"x86 DLL\"\n    ;;\n  *executable*) # but shell scripts are \"executable\" too...\n    case $win32_fileres in\n    *MS\\ Windows\\ PE\\ Intel*)\n      win32_libid_type=\"x86 DLL\"\n      ;;\n    esac\n    ;;\n  esac\n  $ECHO \"$win32_libid_type\"\n}\n\n# func_cygming_dll_for_implib ARG\n#\n# Platform-specific function to extract the\n# name of the DLL associated with the specified\n# import library ARG.\n# Invoked by eval'ing the libtool variable\n#    $sharedlib_from_linklib_cmd\n# Result is available in the variable\n#    $sharedlib_from_linklib_result\nfunc_cygming_dll_for_implib ()\n{\n  $debug_cmd\n\n  sharedlib_from_linklib_result=`$DLLTOOL --identify-strict --identify \"$1\"`\n}\n\n# func_cygming_dll_for_implib_fallback_core SECTION_NAME LIBNAMEs\n#\n# The is the core of a fallback implementation of a\n# platform-specific function to extract the name of the\n# DLL associated with the specified import library LIBNAME.\n#\n# SECTION_NAME is either .idata$6 or .idata$7, depending\n# on the platform and compiler that created the implib.\n#\n# Echos the name of the DLL associated with the\n# specified import library.\nfunc_cygming_dll_for_implib_fallback_core ()\n{\n  $debug_cmd\n\n  match_literal=`$ECHO \"$1\" | $SED \"$sed_make_literal_regex\"`\n  $OBJDUMP -s --section \"$1\" \"$2\" 2>/dev/null |\n    $SED '/^Contents of section '\"$match_literal\"':/{\n      # Place marker at beginning of archive member dllname section\n      s/.*/====MARK====/\n      p\n      d\n    }\n    # These lines can sometimes be longer than 43 characters, but\n    # are always uninteresting\n    /:[\t ]*file format pe[i]\\{,1\\}-/d\n    /^In archive [^:]*:/d\n    # Ensure marker is printed\n    /^====MARK====/p\n    # Remove all lines with less than 43 characters\n    /^.\\{43\\}/!d\n    # From remaining lines, remove first 43 characters\n    s/^.\\{43\\}//' |\n    $SED -n '\n      # Join marker and all lines until next marker into a single line\n      /^====MARK====/ b para\n      H\n      $ b para\n      b\n      :para\n      x\n      s/\\n//g\n      # Remove the marker\n      s/^====MARK====//\n      # Remove trailing dots and whitespace\n      s/[\\. \\t]*$//\n      # Print\n      /./p' |\n    # we now have a list, one entry per line, of the stringified\n    # contents of the appropriate section of all members of the\n    # archive that possess that section. Heuristic: eliminate\n    # all those that have a first or second character that is\n    # a '.' (that is, objdump's representation of an unprintable\n    # character.) This should work for all archives with less than\n    # 0x302f exports -- but will fail for DLLs whose name actually\n    # begins with a literal '.' or a single character followed by\n    # a '.'.\n    #\n    # Of those that remain, print the first one.\n    $SED -e '/^\\./d;/^.\\./d;q'\n}\n\n# func_cygming_dll_for_implib_fallback ARG\n# Platform-specific function to extract the\n# name of the DLL associated with the specified\n# import library ARG.\n#\n# This fallback implementation is for use when $DLLTOOL\n# does not support the --identify-strict option.\n# Invoked by eval'ing the libtool variable\n#    $sharedlib_from_linklib_cmd\n# Result is available in the variable\n#    $sharedlib_from_linklib_result\nfunc_cygming_dll_for_implib_fallback ()\n{\n  $debug_cmd\n\n  if func_cygming_gnu_implib_p \"$1\"; then\n    # binutils import library\n    sharedlib_from_linklib_result=`func_cygming_dll_for_implib_fallback_core '.idata$7' \"$1\"`\n  elif func_cygming_ms_implib_p \"$1\"; then\n    # ms-generated import library\n    sharedlib_from_linklib_result=`func_cygming_dll_for_implib_fallback_core '.idata$6' \"$1\"`\n  else\n    # unknown\n    sharedlib_from_linklib_result=\n  fi\n}\n\n\n# func_extract_an_archive dir oldlib\nfunc_extract_an_archive ()\n{\n    $debug_cmd\n\n    f_ex_an_ar_dir=$1; shift\n    f_ex_an_ar_oldlib=$1\n    if test yes = \"$lock_old_archive_extraction\"; then\n      lockfile=$f_ex_an_ar_oldlib.lock\n      until $opt_dry_run || ln \"$progpath\" \"$lockfile\" 2>/dev/null; do\n\tfunc_echo \"Waiting for $lockfile to be removed\"\n\tsleep 2\n      done\n    fi\n    func_show_eval \"(cd \\$f_ex_an_ar_dir && $AR x \\\"\\$f_ex_an_ar_oldlib\\\")\" \\\n\t\t   'stat=$?; rm -f \"$lockfile\"; exit $stat'\n    if test yes = \"$lock_old_archive_extraction\"; then\n      $opt_dry_run || rm -f \"$lockfile\"\n    fi\n    if ($AR t \"$f_ex_an_ar_oldlib\" | sort | sort -uc >/dev/null 2>&1); then\n     :\n    else\n      func_fatal_error \"object name conflicts in archive: $f_ex_an_ar_dir/$f_ex_an_ar_oldlib\"\n    fi\n}\n\n\n# func_extract_archives gentop oldlib ...\nfunc_extract_archives ()\n{\n    $debug_cmd\n\n    my_gentop=$1; shift\n    my_oldlibs=${1+\"$@\"}\n    my_oldobjs=\n    my_xlib=\n    my_xabs=\n    my_xdir=\n\n    for my_xlib in $my_oldlibs; do\n      # Extract the objects.\n      case $my_xlib in\n\t[\\\\/]* | [A-Za-z]:[\\\\/]*) my_xabs=$my_xlib ;;\n\t*) my_xabs=`pwd`\"/$my_xlib\" ;;\n      esac\n      func_basename \"$my_xlib\"\n      my_xlib=$func_basename_result\n      my_xlib_u=$my_xlib\n      while :; do\n        case \" $extracted_archives \" in\n\t*\" $my_xlib_u \"*)\n\t  func_arith $extracted_serial + 1\n\t  extracted_serial=$func_arith_result\n\t  my_xlib_u=lt$extracted_serial-$my_xlib ;;\n\t*) break ;;\n\tesac\n      done\n      extracted_archives=\"$extracted_archives $my_xlib_u\"\n      my_xdir=$my_gentop/$my_xlib_u\n\n      func_mkdir_p \"$my_xdir\"\n\n      case $host in\n      *-darwin*)\n\tfunc_verbose \"Extracting $my_xabs\"\n\t# Do not bother doing anything if just a dry run\n\t$opt_dry_run || {\n\t  darwin_orig_dir=`pwd`\n\t  cd $my_xdir || exit $?\n\t  darwin_archive=$my_xabs\n\t  darwin_curdir=`pwd`\n\t  func_basename \"$darwin_archive\"\n\t  darwin_base_archive=$func_basename_result\n\t  darwin_arches=`$LIPO -info \"$darwin_archive\" 2>/dev/null | $GREP Architectures 2>/dev/null || true`\n\t  if test -n \"$darwin_arches\"; then\n\t    darwin_arches=`$ECHO \"$darwin_arches\" | $SED -e 's/.*are://'`\n\t    darwin_arch=\n\t    func_verbose \"$darwin_base_archive has multiple architectures $darwin_arches\"\n\t    for darwin_arch in  $darwin_arches; do\n\t      func_mkdir_p \"unfat-$$/$darwin_base_archive-$darwin_arch\"\n\t      $LIPO -thin $darwin_arch -output \"unfat-$$/$darwin_base_archive-$darwin_arch/$darwin_base_archive\" \"$darwin_archive\"\n\t      cd \"unfat-$$/$darwin_base_archive-$darwin_arch\"\n\t      func_extract_an_archive \"`pwd`\" \"$darwin_base_archive\"\n\t      cd \"$darwin_curdir\"\n\t      $RM \"unfat-$$/$darwin_base_archive-$darwin_arch/$darwin_base_archive\"\n\t    done # $darwin_arches\n            ## Okay now we've a bunch of thin objects, gotta fatten them up :)\n\t    darwin_filelist=`find unfat-$$ -type f -name \\*.o -print -o -name \\*.lo -print | $SED -e \"$sed_basename\" | sort -u`\n\t    darwin_file=\n\t    darwin_files=\n\t    for darwin_file in $darwin_filelist; do\n\t      darwin_files=`find unfat-$$ -name $darwin_file -print | sort | $NL2SP`\n\t      $LIPO -create -output \"$darwin_file\" $darwin_files\n\t    done # $darwin_filelist\n\t    $RM -rf unfat-$$\n\t    cd \"$darwin_orig_dir\"\n\t  else\n\t    cd $darwin_orig_dir\n\t    func_extract_an_archive \"$my_xdir\" \"$my_xabs\"\n\t  fi # $darwin_arches\n\t} # !$opt_dry_run\n\t;;\n      *)\n        func_extract_an_archive \"$my_xdir\" \"$my_xabs\"\n\t;;\n      esac\n      my_oldobjs=\"$my_oldobjs \"`find $my_xdir -name \\*.$objext -print -o -name \\*.lo -print | sort | $NL2SP`\n    done\n\n    func_extract_archives_result=$my_oldobjs\n}\n\n\n# func_emit_wrapper [arg=no]\n#\n# Emit a libtool wrapper script on stdout.\n# Don't directly open a file because we may want to\n# incorporate the script contents within a cygwin/mingw\n# wrapper executable.  Must ONLY be called from within\n# func_mode_link because it depends on a number of variables\n# set therein.\n#\n# ARG is the value that the WRAPPER_SCRIPT_BELONGS_IN_OBJDIR\n# variable will take.  If 'yes', then the emitted script\n# will assume that the directory where it is stored is\n# the $objdir directory.  This is a cygwin/mingw-specific\n# behavior.\nfunc_emit_wrapper ()\n{\n\tfunc_emit_wrapper_arg1=${1-no}\n\n\t$ECHO \"\\\n#! $SHELL\n\n# $output - temporary wrapper script for $objdir/$outputname\n# Generated by $PROGRAM (GNU $PACKAGE) $VERSION\n#\n# The $output program cannot be directly executed until all the libtool\n# libraries that it depends on are installed.\n#\n# This wrapper script should never be moved out of the build directory.\n# If it is, it will not operate correctly.\n\n# Sed substitution that helps us do robust quoting.  It backslashifies\n# metacharacters that are still active within double-quoted strings.\nsed_quote_subst='$sed_quote_subst'\n\n# Be Bourne compatible\nif test -n \\\"\\${ZSH_VERSION+set}\\\" && (emulate sh) >/dev/null 2>&1; then\n  emulate sh\n  NULLCMD=:\n  # Zsh 3.x and 4.x performs word splitting on \\${1+\\\"\\$@\\\"}, which\n  # is contrary to our usage.  Disable this feature.\n  alias -g '\\${1+\\\"\\$@\\\"}'='\\\"\\$@\\\"'\n  setopt NO_GLOB_SUBST\nelse\n  case \\`(set -o) 2>/dev/null\\` in *posix*) set -o posix;; esac\nfi\nBIN_SH=xpg4; export BIN_SH # for Tru64\nDUALCASE=1; export DUALCASE # for MKS sh\n\n# The HP-UX ksh and POSIX shell print the target directory to stdout\n# if CDPATH is set.\n(unset CDPATH) >/dev/null 2>&1 && unset CDPATH\n\nrelink_command=\\\"$relink_command\\\"\n\n# This environment variable determines our operation mode.\nif test \\\"\\$libtool_install_magic\\\" = \\\"$magic\\\"; then\n  # install mode needs the following variables:\n  generated_by_libtool_version='$macro_version'\n  notinst_deplibs='$notinst_deplibs'\nelse\n  # When we are sourced in execute mode, \\$file and \\$ECHO are already set.\n  if test \\\"\\$libtool_execute_magic\\\" != \\\"$magic\\\"; then\n    file=\\\"\\$0\\\"\"\n\n    qECHO=`$ECHO \"$ECHO\" | $SED \"$sed_quote_subst\"`\n    $ECHO \"\\\n\n# A function that is used when there is no print builtin or printf.\nfunc_fallback_echo ()\n{\n  eval 'cat <<_LTECHO_EOF\n\\$1\n_LTECHO_EOF'\n}\n    ECHO=\\\"$qECHO\\\"\n  fi\n\n# Very basic option parsing. These options are (a) specific to\n# the libtool wrapper, (b) are identical between the wrapper\n# /script/ and the wrapper /executable/ that is used only on\n# windows platforms, and (c) all begin with the string \"--lt-\"\n# (application programs are unlikely to have options that match\n# this pattern).\n#\n# There are only two supported options: --lt-debug and\n# --lt-dump-script. There is, deliberately, no --lt-help.\n#\n# The first argument to this parsing function should be the\n# script's $0 value, followed by \"$@\".\nlt_option_debug=\nfunc_parse_lt_options ()\n{\n  lt_script_arg0=\\$0\n  shift\n  for lt_opt\n  do\n    case \\\"\\$lt_opt\\\" in\n    --lt-debug) lt_option_debug=1 ;;\n    --lt-dump-script)\n        lt_dump_D=\\`\\$ECHO \\\"X\\$lt_script_arg0\\\" | $SED -e 's/^X//' -e 's%/[^/]*$%%'\\`\n        test \\\"X\\$lt_dump_D\\\" = \\\"X\\$lt_script_arg0\\\" && lt_dump_D=.\n        lt_dump_F=\\`\\$ECHO \\\"X\\$lt_script_arg0\\\" | $SED -e 's/^X//' -e 's%^.*/%%'\\`\n        cat \\\"\\$lt_dump_D/\\$lt_dump_F\\\"\n        exit 0\n      ;;\n    --lt-*)\n        \\$ECHO \\\"Unrecognized --lt- option: '\\$lt_opt'\\\" 1>&2\n        exit 1\n      ;;\n    esac\n  done\n\n  # Print the debug banner immediately:\n  if test -n \\\"\\$lt_option_debug\\\"; then\n    echo \\\"$outputname:$output:\\$LINENO: libtool wrapper (GNU $PACKAGE) $VERSION\\\" 1>&2\n  fi\n}\n\n# Used when --lt-debug. Prints its arguments to stdout\n# (redirection is the responsibility of the caller)\nfunc_lt_dump_args ()\n{\n  lt_dump_args_N=1;\n  for lt_arg\n  do\n    \\$ECHO \\\"$outputname:$output:\\$LINENO: newargv[\\$lt_dump_args_N]: \\$lt_arg\\\"\n    lt_dump_args_N=\\`expr \\$lt_dump_args_N + 1\\`\n  done\n}\n\n# Core function for launching the target application\nfunc_exec_program_core ()\n{\n\"\n  case $host in\n  # Backslashes separate directories on plain windows\n  *-*-mingw | *-*-os2* | *-cegcc*)\n    $ECHO \"\\\n      if test -n \\\"\\$lt_option_debug\\\"; then\n        \\$ECHO \\\"$outputname:$output:\\$LINENO: newargv[0]: \\$progdir\\\\\\\\\\$program\\\" 1>&2\n        func_lt_dump_args \\${1+\\\"\\$@\\\"} 1>&2\n      fi\n      exec \\\"\\$progdir\\\\\\\\\\$program\\\" \\${1+\\\"\\$@\\\"}\n\"\n    ;;\n\n  *)\n    $ECHO \"\\\n      if test -n \\\"\\$lt_option_debug\\\"; then\n        \\$ECHO \\\"$outputname:$output:\\$LINENO: newargv[0]: \\$progdir/\\$program\\\" 1>&2\n        func_lt_dump_args \\${1+\\\"\\$@\\\"} 1>&2\n      fi\n      exec \\\"\\$progdir/\\$program\\\" \\${1+\\\"\\$@\\\"}\n\"\n    ;;\n  esac\n  $ECHO \"\\\n      \\$ECHO \\\"\\$0: cannot exec \\$program \\$*\\\" 1>&2\n      exit 1\n}\n\n# A function to encapsulate launching the target application\n# Strips options in the --lt-* namespace from \\$@ and\n# launches target application with the remaining arguments.\nfunc_exec_program ()\n{\n  case \\\" \\$* \\\" in\n  *\\\\ --lt-*)\n    for lt_wr_arg\n    do\n      case \\$lt_wr_arg in\n      --lt-*) ;;\n      *) set x \\\"\\$@\\\" \\\"\\$lt_wr_arg\\\"; shift;;\n      esac\n      shift\n    done ;;\n  esac\n  func_exec_program_core \\${1+\\\"\\$@\\\"}\n}\n\n  # Parse options\n  func_parse_lt_options \\\"\\$0\\\" \\${1+\\\"\\$@\\\"}\n\n  # Find the directory that this script lives in.\n  thisdir=\\`\\$ECHO \\\"\\$file\\\" | $SED 's%/[^/]*$%%'\\`\n  test \\\"x\\$thisdir\\\" = \\\"x\\$file\\\" && thisdir=.\n\n  # Follow symbolic links until we get to the real thisdir.\n  file=\\`ls -ld \\\"\\$file\\\" | $SED -n 's/.*-> //p'\\`\n  while test -n \\\"\\$file\\\"; do\n    destdir=\\`\\$ECHO \\\"\\$file\\\" | $SED 's%/[^/]*\\$%%'\\`\n\n    # If there was a directory component, then change thisdir.\n    if test \\\"x\\$destdir\\\" != \\\"x\\$file\\\"; then\n      case \\\"\\$destdir\\\" in\n      [\\\\\\\\/]* | [A-Za-z]:[\\\\\\\\/]*) thisdir=\\\"\\$destdir\\\" ;;\n      *) thisdir=\\\"\\$thisdir/\\$destdir\\\" ;;\n      esac\n    fi\n\n    file=\\`\\$ECHO \\\"\\$file\\\" | $SED 's%^.*/%%'\\`\n    file=\\`ls -ld \\\"\\$thisdir/\\$file\\\" | $SED -n 's/.*-> //p'\\`\n  done\n\n  # Usually 'no', except on cygwin/mingw when embedded into\n  # the cwrapper.\n  WRAPPER_SCRIPT_BELONGS_IN_OBJDIR=$func_emit_wrapper_arg1\n  if test \\\"\\$WRAPPER_SCRIPT_BELONGS_IN_OBJDIR\\\" = \\\"yes\\\"; then\n    # special case for '.'\n    if test \\\"\\$thisdir\\\" = \\\".\\\"; then\n      thisdir=\\`pwd\\`\n    fi\n    # remove .libs from thisdir\n    case \\\"\\$thisdir\\\" in\n    *[\\\\\\\\/]$objdir ) thisdir=\\`\\$ECHO \\\"\\$thisdir\\\" | $SED 's%[\\\\\\\\/][^\\\\\\\\/]*$%%'\\` ;;\n    $objdir )   thisdir=. ;;\n    esac\n  fi\n\n  # Try to get the absolute directory name.\n  absdir=\\`cd \\\"\\$thisdir\\\" && pwd\\`\n  test -n \\\"\\$absdir\\\" && thisdir=\\\"\\$absdir\\\"\n\"\n\n\tif test yes = \"$fast_install\"; then\n\t  $ECHO \"\\\n  program=lt-'$outputname'$exeext\n  progdir=\\\"\\$thisdir/$objdir\\\"\n\n  if test ! -f \\\"\\$progdir/\\$program\\\" ||\n     { file=\\`ls -1dt \\\"\\$progdir/\\$program\\\" \\\"\\$progdir/../\\$program\\\" 2>/dev/null | $SED 1q\\`; \\\\\n       test \\\"X\\$file\\\" != \\\"X\\$progdir/\\$program\\\"; }; then\n\n    file=\\\"\\$\\$-\\$program\\\"\n\n    if test ! -d \\\"\\$progdir\\\"; then\n      $MKDIR \\\"\\$progdir\\\"\n    else\n      $RM \\\"\\$progdir/\\$file\\\"\n    fi\"\n\n\t  $ECHO \"\\\n\n    # relink executable if necessary\n    if test -n \\\"\\$relink_command\\\"; then\n      if relink_command_output=\\`eval \\$relink_command 2>&1\\`; then :\n      else\n\t\\$ECHO \\\"\\$relink_command_output\\\" >&2\n\t$RM \\\"\\$progdir/\\$file\\\"\n\texit 1\n      fi\n    fi\n\n    $MV \\\"\\$progdir/\\$file\\\" \\\"\\$progdir/\\$program\\\" 2>/dev/null ||\n    { $RM \\\"\\$progdir/\\$program\\\";\n      $MV \\\"\\$progdir/\\$file\\\" \\\"\\$progdir/\\$program\\\"; }\n    $RM \\\"\\$progdir/\\$file\\\"\n  fi\"\n\telse\n\t  $ECHO \"\\\n  program='$outputname'\n  progdir=\\\"\\$thisdir/$objdir\\\"\n\"\n\tfi\n\n\t$ECHO \"\\\n\n  if test -f \\\"\\$progdir/\\$program\\\"; then\"\n\n\t# fixup the dll searchpath if we need to.\n\t#\n\t# Fix the DLL searchpath if we need to.  Do this before prepending\n\t# to shlibpath, because on Windows, both are PATH and uninstalled\n\t# libraries must come first.\n\tif test -n \"$dllsearchpath\"; then\n\t  $ECHO \"\\\n    # Add the dll search path components to the executable PATH\n    PATH=$dllsearchpath:\\$PATH\n\"\n\tfi\n\n\t# Export our shlibpath_var if we have one.\n\tif test yes = \"$shlibpath_overrides_runpath\" && test -n \"$shlibpath_var\" && test -n \"$temp_rpath\"; then\n\t  $ECHO \"\\\n    # Add our own library path to $shlibpath_var\n    $shlibpath_var=\\\"$temp_rpath\\$$shlibpath_var\\\"\n\n    # Some systems cannot cope with colon-terminated $shlibpath_var\n    # The second colon is a workaround for a bug in BeOS R4 sed\n    $shlibpath_var=\\`\\$ECHO \\\"\\$$shlibpath_var\\\" | $SED 's/::*\\$//'\\`\n\n    export $shlibpath_var\n\"\n\tfi\n\n\t$ECHO \"\\\n    if test \\\"\\$libtool_execute_magic\\\" != \\\"$magic\\\"; then\n      # Run the actual program with our arguments.\n      func_exec_program \\${1+\\\"\\$@\\\"}\n    fi\n  else\n    # The program doesn't exist.\n    \\$ECHO \\\"\\$0: error: '\\$progdir/\\$program' does not exist\\\" 1>&2\n    \\$ECHO \\\"This script is just a wrapper for \\$program.\\\" 1>&2\n    \\$ECHO \\\"See the $PACKAGE documentation for more information.\\\" 1>&2\n    exit 1\n  fi\nfi\\\n\"\n}\n\n\n# func_emit_cwrapperexe_src\n# emit the source code for a wrapper executable on stdout\n# Must ONLY be called from within func_mode_link because\n# it depends on a number of variable set therein.\nfunc_emit_cwrapperexe_src ()\n{\n\tcat <<EOF\n\n/* $cwrappersource - temporary wrapper executable for $objdir/$outputname\n   Generated by $PROGRAM (GNU $PACKAGE) $VERSION\n\n   The $output program cannot be directly executed until all the libtool\n   libraries that it depends on are installed.\n\n   This wrapper executable should never be moved out of the build directory.\n   If it is, it will not operate correctly.\n*/\nEOF\n\t    cat <<\"EOF\"\n#ifdef _MSC_VER\n# define _CRT_SECURE_NO_DEPRECATE 1\n#endif\n#include <stdio.h>\n#include <stdlib.h>\n#ifdef _MSC_VER\n# include <direct.h>\n# include <process.h>\n# include <io.h>\n#else\n# include <unistd.h>\n# include <stdint.h>\n# ifdef __CYGWIN__\n#  include <io.h>\n# endif\n#endif\n#include <malloc.h>\n#include <stdarg.h>\n#include <assert.h>\n#include <string.h>\n#include <ctype.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n\n#define STREQ(s1, s2) (strcmp ((s1), (s2)) == 0)\n\n/* declarations of non-ANSI functions */\n#if defined __MINGW32__\n# ifdef __STRICT_ANSI__\nint _putenv (const char *);\n# endif\n#elif defined __CYGWIN__\n# ifdef __STRICT_ANSI__\nchar *realpath (const char *, char *);\nint putenv (char *);\nint setenv (const char *, const char *, int);\n# endif\n/* #elif defined other_platform || defined ... */\n#endif\n\n/* portability defines, excluding path handling macros */\n#if defined _MSC_VER\n# define setmode _setmode\n# define stat    _stat\n# define chmod   _chmod\n# define getcwd  _getcwd\n# define putenv  _putenv\n# define S_IXUSR _S_IEXEC\n#elif defined __MINGW32__\n# define setmode _setmode\n# define stat    _stat\n# define chmod   _chmod\n# define getcwd  _getcwd\n# define putenv  _putenv\n#elif defined __CYGWIN__\n# define HAVE_SETENV\n# define FOPEN_WB \"wb\"\n/* #elif defined other platforms ... */\n#endif\n\n#if defined PATH_MAX\n# define LT_PATHMAX PATH_MAX\n#elif defined MAXPATHLEN\n# define LT_PATHMAX MAXPATHLEN\n#else\n# define LT_PATHMAX 1024\n#endif\n\n#ifndef S_IXOTH\n# define S_IXOTH 0\n#endif\n#ifndef S_IXGRP\n# define S_IXGRP 0\n#endif\n\n/* path handling portability macros */\n#ifndef DIR_SEPARATOR\n# define DIR_SEPARATOR '/'\n# define PATH_SEPARATOR ':'\n#endif\n\n#if defined _WIN32 || defined __MSDOS__ || defined __DJGPP__ || \\\n  defined __OS2__\n# define HAVE_DOS_BASED_FILE_SYSTEM\n# define FOPEN_WB \"wb\"\n# ifndef DIR_SEPARATOR_2\n#  define DIR_SEPARATOR_2 '\\\\'\n# endif\n# ifndef PATH_SEPARATOR_2\n#  define PATH_SEPARATOR_2 ';'\n# endif\n#endif\n\n#ifndef DIR_SEPARATOR_2\n# define IS_DIR_SEPARATOR(ch) ((ch) == DIR_SEPARATOR)\n#else /* DIR_SEPARATOR_2 */\n# define IS_DIR_SEPARATOR(ch) \\\n\t(((ch) == DIR_SEPARATOR) || ((ch) == DIR_SEPARATOR_2))\n#endif /* DIR_SEPARATOR_2 */\n\n#ifndef PATH_SEPARATOR_2\n# define IS_PATH_SEPARATOR(ch) ((ch) == PATH_SEPARATOR)\n#else /* PATH_SEPARATOR_2 */\n# define IS_PATH_SEPARATOR(ch) ((ch) == PATH_SEPARATOR_2)\n#endif /* PATH_SEPARATOR_2 */\n\n#ifndef FOPEN_WB\n# define FOPEN_WB \"w\"\n#endif\n#ifndef _O_BINARY\n# define _O_BINARY 0\n#endif\n\n#define XMALLOC(type, num)      ((type *) xmalloc ((num) * sizeof(type)))\n#define XFREE(stale) do { \\\n  if (stale) { free (stale); stale = 0; } \\\n} while (0)\n\n#if defined LT_DEBUGWRAPPER\nstatic int lt_debug = 1;\n#else\nstatic int lt_debug = 0;\n#endif\n\nconst char *program_name = \"libtool-wrapper\"; /* in case xstrdup fails */\n\nvoid *xmalloc (size_t num);\nchar *xstrdup (const char *string);\nconst char *base_name (const char *name);\nchar *find_executable (const char *wrapper);\nchar *chase_symlinks (const char *pathspec);\nint make_executable (const char *path);\nint check_executable (const char *path);\nchar *strendzap (char *str, const char *pat);\nvoid lt_debugprintf (const char *file, int line, const char *fmt, ...);\nvoid lt_fatal (const char *file, int line, const char *message, ...);\nstatic const char *nonnull (const char *s);\nstatic const char *nonempty (const char *s);\nvoid lt_setenv (const char *name, const char *value);\nchar *lt_extend_str (const char *orig_value, const char *add, int to_end);\nvoid lt_update_exe_path (const char *name, const char *value);\nvoid lt_update_lib_path (const char *name, const char *value);\nchar **prepare_spawn (char **argv);\nvoid lt_dump_script (FILE *f);\nEOF\n\n\t    cat <<EOF\n#if __GNUC__ < 4 || (__GNUC__ == 4 && __GNUC_MINOR__ < 5)\n# define externally_visible volatile\n#else\n# define externally_visible __attribute__((externally_visible)) volatile\n#endif\nexternally_visible const char * MAGIC_EXE = \"$magic_exe\";\nconst char * LIB_PATH_VARNAME = \"$shlibpath_var\";\nEOF\n\n\t    if test yes = \"$shlibpath_overrides_runpath\" && test -n \"$shlibpath_var\" && test -n \"$temp_rpath\"; then\n              func_to_host_path \"$temp_rpath\"\n\t      cat <<EOF\nconst char * LIB_PATH_VALUE   = \"$func_to_host_path_result\";\nEOF\n\t    else\n\t      cat <<\"EOF\"\nconst char * LIB_PATH_VALUE   = \"\";\nEOF\n\t    fi\n\n\t    if test -n \"$dllsearchpath\"; then\n              func_to_host_path \"$dllsearchpath:\"\n\t      cat <<EOF\nconst char * EXE_PATH_VARNAME = \"PATH\";\nconst char * EXE_PATH_VALUE   = \"$func_to_host_path_result\";\nEOF\n\t    else\n\t      cat <<\"EOF\"\nconst char * EXE_PATH_VARNAME = \"\";\nconst char * EXE_PATH_VALUE   = \"\";\nEOF\n\t    fi\n\n\t    if test yes = \"$fast_install\"; then\n\t      cat <<EOF\nconst char * TARGET_PROGRAM_NAME = \"lt-$outputname\"; /* hopefully, no .exe */\nEOF\n\t    else\n\t      cat <<EOF\nconst char * TARGET_PROGRAM_NAME = \"$outputname\"; /* hopefully, no .exe */\nEOF\n\t    fi\n\n\n\t    cat <<\"EOF\"\n\n#define LTWRAPPER_OPTION_PREFIX         \"--lt-\"\n\nstatic const char *ltwrapper_option_prefix = LTWRAPPER_OPTION_PREFIX;\nstatic const char *dumpscript_opt       = LTWRAPPER_OPTION_PREFIX \"dump-script\";\nstatic const char *debug_opt            = LTWRAPPER_OPTION_PREFIX \"debug\";\n\nint\nmain (int argc, char *argv[])\n{\n  char **newargz;\n  int  newargc;\n  char *tmp_pathspec;\n  char *actual_cwrapper_path;\n  char *actual_cwrapper_name;\n  char *target_name;\n  char *lt_argv_zero;\n  int rval = 127;\n\n  int i;\n\n  program_name = (char *) xstrdup (base_name (argv[0]));\n  newargz = XMALLOC (char *, (size_t) argc + 1);\n\n  /* very simple arg parsing; don't want to rely on getopt\n   * also, copy all non cwrapper options to newargz, except\n   * argz[0], which is handled differently\n   */\n  newargc=0;\n  for (i = 1; i < argc; i++)\n    {\n      if (STREQ (argv[i], dumpscript_opt))\n\t{\nEOF\n\t    case $host in\n\t      *mingw* | *cygwin* )\n\t\t# make stdout use \"unix\" line endings\n\t\techo \"          setmode(1,_O_BINARY);\"\n\t\t;;\n\t      esac\n\n\t    cat <<\"EOF\"\n\t  lt_dump_script (stdout);\n\t  return 0;\n\t}\n      if (STREQ (argv[i], debug_opt))\n\t{\n          lt_debug = 1;\n          continue;\n\t}\n      if (STREQ (argv[i], ltwrapper_option_prefix))\n        {\n          /* however, if there is an option in the LTWRAPPER_OPTION_PREFIX\n             namespace, but it is not one of the ones we know about and\n             have already dealt with, above (inluding dump-script), then\n             report an error. Otherwise, targets might begin to believe\n             they are allowed to use options in the LTWRAPPER_OPTION_PREFIX\n             namespace. The first time any user complains about this, we'll\n             need to make LTWRAPPER_OPTION_PREFIX a configure-time option\n             or a configure.ac-settable value.\n           */\n          lt_fatal (__FILE__, __LINE__,\n\t\t    \"unrecognized %s option: '%s'\",\n                    ltwrapper_option_prefix, argv[i]);\n        }\n      /* otherwise ... */\n      newargz[++newargc] = xstrdup (argv[i]);\n    }\n  newargz[++newargc] = NULL;\n\nEOF\n\t    cat <<EOF\n  /* The GNU banner must be the first non-error debug message */\n  lt_debugprintf (__FILE__, __LINE__, \"libtool wrapper (GNU $PACKAGE) $VERSION\\n\");\nEOF\n\t    cat <<\"EOF\"\n  lt_debugprintf (__FILE__, __LINE__, \"(main) argv[0]: %s\\n\", argv[0]);\n  lt_debugprintf (__FILE__, __LINE__, \"(main) program_name: %s\\n\", program_name);\n\n  tmp_pathspec = find_executable (argv[0]);\n  if (tmp_pathspec == NULL)\n    lt_fatal (__FILE__, __LINE__, \"couldn't find %s\", argv[0]);\n  lt_debugprintf (__FILE__, __LINE__,\n                  \"(main) found exe (before symlink chase) at: %s\\n\",\n\t\t  tmp_pathspec);\n\n  actual_cwrapper_path = chase_symlinks (tmp_pathspec);\n  lt_debugprintf (__FILE__, __LINE__,\n                  \"(main) found exe (after symlink chase) at: %s\\n\",\n\t\t  actual_cwrapper_path);\n  XFREE (tmp_pathspec);\n\n  actual_cwrapper_name = xstrdup (base_name (actual_cwrapper_path));\n  strendzap (actual_cwrapper_path, actual_cwrapper_name);\n\n  /* wrapper name transforms */\n  strendzap (actual_cwrapper_name, \".exe\");\n  tmp_pathspec = lt_extend_str (actual_cwrapper_name, \".exe\", 1);\n  XFREE (actual_cwrapper_name);\n  actual_cwrapper_name = tmp_pathspec;\n  tmp_pathspec = 0;\n\n  /* target_name transforms -- use actual target program name; might have lt- prefix */\n  target_name = xstrdup (base_name (TARGET_PROGRAM_NAME));\n  strendzap (target_name, \".exe\");\n  tmp_pathspec = lt_extend_str (target_name, \".exe\", 1);\n  XFREE (target_name);\n  target_name = tmp_pathspec;\n  tmp_pathspec = 0;\n\n  lt_debugprintf (__FILE__, __LINE__,\n\t\t  \"(main) libtool target name: %s\\n\",\n\t\t  target_name);\nEOF\n\n\t    cat <<EOF\n  newargz[0] =\n    XMALLOC (char, (strlen (actual_cwrapper_path) +\n\t\t    strlen (\"$objdir\") + 1 + strlen (actual_cwrapper_name) + 1));\n  strcpy (newargz[0], actual_cwrapper_path);\n  strcat (newargz[0], \"$objdir\");\n  strcat (newargz[0], \"/\");\nEOF\n\n\t    cat <<\"EOF\"\n  /* stop here, and copy so we don't have to do this twice */\n  tmp_pathspec = xstrdup (newargz[0]);\n\n  /* do NOT want the lt- prefix here, so use actual_cwrapper_name */\n  strcat (newargz[0], actual_cwrapper_name);\n\n  /* DO want the lt- prefix here if it exists, so use target_name */\n  lt_argv_zero = lt_extend_str (tmp_pathspec, target_name, 1);\n  XFREE (tmp_pathspec);\n  tmp_pathspec = NULL;\nEOF\n\n\t    case $host_os in\n\t      mingw*)\n\t    cat <<\"EOF\"\n  {\n    char* p;\n    while ((p = strchr (newargz[0], '\\\\')) != NULL)\n      {\n\t*p = '/';\n      }\n    while ((p = strchr (lt_argv_zero, '\\\\')) != NULL)\n      {\n\t*p = '/';\n      }\n  }\nEOF\n\t    ;;\n\t    esac\n\n\t    cat <<\"EOF\"\n  XFREE (target_name);\n  XFREE (actual_cwrapper_path);\n  XFREE (actual_cwrapper_name);\n\n  lt_setenv (\"BIN_SH\", \"xpg4\"); /* for Tru64 */\n  lt_setenv (\"DUALCASE\", \"1\");  /* for MSK sh */\n  /* Update the DLL searchpath.  EXE_PATH_VALUE ($dllsearchpath) must\n     be prepended before (that is, appear after) LIB_PATH_VALUE ($temp_rpath)\n     because on Windows, both *_VARNAMEs are PATH but uninstalled\n     libraries must come first. */\n  lt_update_exe_path (EXE_PATH_VARNAME, EXE_PATH_VALUE);\n  lt_update_lib_path (LIB_PATH_VARNAME, LIB_PATH_VALUE);\n\n  lt_debugprintf (__FILE__, __LINE__, \"(main) lt_argv_zero: %s\\n\",\n\t\t  nonnull (lt_argv_zero));\n  for (i = 0; i < newargc; i++)\n    {\n      lt_debugprintf (__FILE__, __LINE__, \"(main) newargz[%d]: %s\\n\",\n\t\t      i, nonnull (newargz[i]));\n    }\n\nEOF\n\n\t    case $host_os in\n\t      mingw*)\n\t\tcat <<\"EOF\"\n  /* execv doesn't actually work on mingw as expected on unix */\n  newargz = prepare_spawn (newargz);\n  rval = (int) _spawnv (_P_WAIT, lt_argv_zero, (const char * const *) newargz);\n  if (rval == -1)\n    {\n      /* failed to start process */\n      lt_debugprintf (__FILE__, __LINE__,\n\t\t      \"(main) failed to launch target \\\"%s\\\": %s\\n\",\n\t\t      lt_argv_zero, nonnull (strerror (errno)));\n      return 127;\n    }\n  return rval;\nEOF\n\t\t;;\n\t      *)\n\t\tcat <<\"EOF\"\n  execv (lt_argv_zero, newargz);\n  return rval; /* =127, but avoids unused variable warning */\nEOF\n\t\t;;\n\t    esac\n\n\t    cat <<\"EOF\"\n}\n\nvoid *\nxmalloc (size_t num)\n{\n  void *p = (void *) malloc (num);\n  if (!p)\n    lt_fatal (__FILE__, __LINE__, \"memory exhausted\");\n\n  return p;\n}\n\nchar *\nxstrdup (const char *string)\n{\n  return string ? strcpy ((char *) xmalloc (strlen (string) + 1),\n\t\t\t  string) : NULL;\n}\n\nconst char *\nbase_name (const char *name)\n{\n  const char *base;\n\n#if defined HAVE_DOS_BASED_FILE_SYSTEM\n  /* Skip over the disk name in MSDOS pathnames. */\n  if (isalpha ((unsigned char) name[0]) && name[1] == ':')\n    name += 2;\n#endif\n\n  for (base = name; *name; name++)\n    if (IS_DIR_SEPARATOR (*name))\n      base = name + 1;\n  return base;\n}\n\nint\ncheck_executable (const char *path)\n{\n  struct stat st;\n\n  lt_debugprintf (__FILE__, __LINE__, \"(check_executable): %s\\n\",\n                  nonempty (path));\n  if ((!path) || (!*path))\n    return 0;\n\n  if ((stat (path, &st) >= 0)\n      && (st.st_mode & (S_IXUSR | S_IXGRP | S_IXOTH)))\n    return 1;\n  else\n    return 0;\n}\n\nint\nmake_executable (const char *path)\n{\n  int rval = 0;\n  struct stat st;\n\n  lt_debugprintf (__FILE__, __LINE__, \"(make_executable): %s\\n\",\n                  nonempty (path));\n  if ((!path) || (!*path))\n    return 0;\n\n  if (stat (path, &st) >= 0)\n    {\n      rval = chmod (path, st.st_mode | S_IXOTH | S_IXGRP | S_IXUSR);\n    }\n  return rval;\n}\n\n/* Searches for the full path of the wrapper.  Returns\n   newly allocated full path name if found, NULL otherwise\n   Does not chase symlinks, even on platforms that support them.\n*/\nchar *\nfind_executable (const char *wrapper)\n{\n  int has_slash = 0;\n  const char *p;\n  const char *p_next;\n  /* static buffer for getcwd */\n  char tmp[LT_PATHMAX + 1];\n  size_t tmp_len;\n  char *concat_name;\n\n  lt_debugprintf (__FILE__, __LINE__, \"(find_executable): %s\\n\",\n                  nonempty (wrapper));\n\n  if ((wrapper == NULL) || (*wrapper == '\\0'))\n    return NULL;\n\n  /* Absolute path? */\n#if defined HAVE_DOS_BASED_FILE_SYSTEM\n  if (isalpha ((unsigned char) wrapper[0]) && wrapper[1] == ':')\n    {\n      concat_name = xstrdup (wrapper);\n      if (check_executable (concat_name))\n\treturn concat_name;\n      XFREE (concat_name);\n    }\n  else\n    {\n#endif\n      if (IS_DIR_SEPARATOR (wrapper[0]))\n\t{\n\t  concat_name = xstrdup (wrapper);\n\t  if (check_executable (concat_name))\n\t    return concat_name;\n\t  XFREE (concat_name);\n\t}\n#if defined HAVE_DOS_BASED_FILE_SYSTEM\n    }\n#endif\n\n  for (p = wrapper; *p; p++)\n    if (*p == '/')\n      {\n\thas_slash = 1;\n\tbreak;\n      }\n  if (!has_slash)\n    {\n      /* no slashes; search PATH */\n      const char *path = getenv (\"PATH\");\n      if (path != NULL)\n\t{\n\t  for (p = path; *p; p = p_next)\n\t    {\n\t      const char *q;\n\t      size_t p_len;\n\t      for (q = p; *q; q++)\n\t\tif (IS_PATH_SEPARATOR (*q))\n\t\t  break;\n\t      p_len = (size_t) (q - p);\n\t      p_next = (*q == '\\0' ? q : q + 1);\n\t      if (p_len == 0)\n\t\t{\n\t\t  /* empty path: current directory */\n\t\t  if (getcwd (tmp, LT_PATHMAX) == NULL)\n\t\t    lt_fatal (__FILE__, __LINE__, \"getcwd failed: %s\",\n                              nonnull (strerror (errno)));\n\t\t  tmp_len = strlen (tmp);\n\t\t  concat_name =\n\t\t    XMALLOC (char, tmp_len + 1 + strlen (wrapper) + 1);\n\t\t  memcpy (concat_name, tmp, tmp_len);\n\t\t  concat_name[tmp_len] = '/';\n\t\t  strcpy (concat_name + tmp_len + 1, wrapper);\n\t\t}\n\t      else\n\t\t{\n\t\t  concat_name =\n\t\t    XMALLOC (char, p_len + 1 + strlen (wrapper) + 1);\n\t\t  memcpy (concat_name, p, p_len);\n\t\t  concat_name[p_len] = '/';\n\t\t  strcpy (concat_name + p_len + 1, wrapper);\n\t\t}\n\t      if (check_executable (concat_name))\n\t\treturn concat_name;\n\t      XFREE (concat_name);\n\t    }\n\t}\n      /* not found in PATH; assume curdir */\n    }\n  /* Relative path | not found in path: prepend cwd */\n  if (getcwd (tmp, LT_PATHMAX) == NULL)\n    lt_fatal (__FILE__, __LINE__, \"getcwd failed: %s\",\n              nonnull (strerror (errno)));\n  tmp_len = strlen (tmp);\n  concat_name = XMALLOC (char, tmp_len + 1 + strlen (wrapper) + 1);\n  memcpy (concat_name, tmp, tmp_len);\n  concat_name[tmp_len] = '/';\n  strcpy (concat_name + tmp_len + 1, wrapper);\n\n  if (check_executable (concat_name))\n    return concat_name;\n  XFREE (concat_name);\n  return NULL;\n}\n\nchar *\nchase_symlinks (const char *pathspec)\n{\n#ifndef S_ISLNK\n  return xstrdup (pathspec);\n#else\n  char buf[LT_PATHMAX];\n  struct stat s;\n  char *tmp_pathspec = xstrdup (pathspec);\n  char *p;\n  int has_symlinks = 0;\n  while (strlen (tmp_pathspec) && !has_symlinks)\n    {\n      lt_debugprintf (__FILE__, __LINE__,\n\t\t      \"checking path component for symlinks: %s\\n\",\n\t\t      tmp_pathspec);\n      if (lstat (tmp_pathspec, &s) == 0)\n\t{\n\t  if (S_ISLNK (s.st_mode) != 0)\n\t    {\n\t      has_symlinks = 1;\n\t      break;\n\t    }\n\n\t  /* search backwards for last DIR_SEPARATOR */\n\t  p = tmp_pathspec + strlen (tmp_pathspec) - 1;\n\t  while ((p > tmp_pathspec) && (!IS_DIR_SEPARATOR (*p)))\n\t    p--;\n\t  if ((p == tmp_pathspec) && (!IS_DIR_SEPARATOR (*p)))\n\t    {\n\t      /* no more DIR_SEPARATORS left */\n\t      break;\n\t    }\n\t  *p = '\\0';\n\t}\n      else\n\t{\n\t  lt_fatal (__FILE__, __LINE__,\n\t\t    \"error accessing file \\\"%s\\\": %s\",\n\t\t    tmp_pathspec, nonnull (strerror (errno)));\n\t}\n    }\n  XFREE (tmp_pathspec);\n\n  if (!has_symlinks)\n    {\n      return xstrdup (pathspec);\n    }\n\n  tmp_pathspec = realpath (pathspec, buf);\n  if (tmp_pathspec == 0)\n    {\n      lt_fatal (__FILE__, __LINE__,\n\t\t\"could not follow symlinks for %s\", pathspec);\n    }\n  return xstrdup (tmp_pathspec);\n#endif\n}\n\nchar *\nstrendzap (char *str, const char *pat)\n{\n  size_t len, patlen;\n\n  assert (str != NULL);\n  assert (pat != NULL);\n\n  len = strlen (str);\n  patlen = strlen (pat);\n\n  if (patlen <= len)\n    {\n      str += len - patlen;\n      if (STREQ (str, pat))\n\t*str = '\\0';\n    }\n  return str;\n}\n\nvoid\nlt_debugprintf (const char *file, int line, const char *fmt, ...)\n{\n  va_list args;\n  if (lt_debug)\n    {\n      (void) fprintf (stderr, \"%s:%s:%d: \", program_name, file, line);\n      va_start (args, fmt);\n      (void) vfprintf (stderr, fmt, args);\n      va_end (args);\n    }\n}\n\nstatic void\nlt_error_core (int exit_status, const char *file,\n\t       int line, const char *mode,\n\t       const char *message, va_list ap)\n{\n  fprintf (stderr, \"%s:%s:%d: %s: \", program_name, file, line, mode);\n  vfprintf (stderr, message, ap);\n  fprintf (stderr, \".\\n\");\n\n  if (exit_status >= 0)\n    exit (exit_status);\n}\n\nvoid\nlt_fatal (const char *file, int line, const char *message, ...)\n{\n  va_list ap;\n  va_start (ap, message);\n  lt_error_core (EXIT_FAILURE, file, line, \"FATAL\", message, ap);\n  va_end (ap);\n}\n\nstatic const char *\nnonnull (const char *s)\n{\n  return s ? s : \"(null)\";\n}\n\nstatic const char *\nnonempty (const char *s)\n{\n  return (s && !*s) ? \"(empty)\" : nonnull (s);\n}\n\nvoid\nlt_setenv (const char *name, const char *value)\n{\n  lt_debugprintf (__FILE__, __LINE__,\n\t\t  \"(lt_setenv) setting '%s' to '%s'\\n\",\n                  nonnull (name), nonnull (value));\n  {\n#ifdef HAVE_SETENV\n    /* always make a copy, for consistency with !HAVE_SETENV */\n    char *str = xstrdup (value);\n    setenv (name, str, 1);\n#else\n    size_t len = strlen (name) + 1 + strlen (value) + 1;\n    char *str = XMALLOC (char, len);\n    sprintf (str, \"%s=%s\", name, value);\n    if (putenv (str) != EXIT_SUCCESS)\n      {\n        XFREE (str);\n      }\n#endif\n  }\n}\n\nchar *\nlt_extend_str (const char *orig_value, const char *add, int to_end)\n{\n  char *new_value;\n  if (orig_value && *orig_value)\n    {\n      size_t orig_value_len = strlen (orig_value);\n      size_t add_len = strlen (add);\n      new_value = XMALLOC (char, add_len + orig_value_len + 1);\n      if (to_end)\n        {\n          strcpy (new_value, orig_value);\n          strcpy (new_value + orig_value_len, add);\n        }\n      else\n        {\n          strcpy (new_value, add);\n          strcpy (new_value + add_len, orig_value);\n        }\n    }\n  else\n    {\n      new_value = xstrdup (add);\n    }\n  return new_value;\n}\n\nvoid\nlt_update_exe_path (const char *name, const char *value)\n{\n  lt_debugprintf (__FILE__, __LINE__,\n\t\t  \"(lt_update_exe_path) modifying '%s' by prepending '%s'\\n\",\n                  nonnull (name), nonnull (value));\n\n  if (name && *name && value && *value)\n    {\n      char *new_value = lt_extend_str (getenv (name), value, 0);\n      /* some systems can't cope with a ':'-terminated path #' */\n      size_t len = strlen (new_value);\n      while ((len > 0) && IS_PATH_SEPARATOR (new_value[len-1]))\n        {\n          new_value[--len] = '\\0';\n        }\n      lt_setenv (name, new_value);\n      XFREE (new_value);\n    }\n}\n\nvoid\nlt_update_lib_path (const char *name, const char *value)\n{\n  lt_debugprintf (__FILE__, __LINE__,\n\t\t  \"(lt_update_lib_path) modifying '%s' by prepending '%s'\\n\",\n                  nonnull (name), nonnull (value));\n\n  if (name && *name && value && *value)\n    {\n      char *new_value = lt_extend_str (getenv (name), value, 0);\n      lt_setenv (name, new_value);\n      XFREE (new_value);\n    }\n}\n\nEOF\n\t    case $host_os in\n\t      mingw*)\n\t\tcat <<\"EOF\"\n\n/* Prepares an argument vector before calling spawn().\n   Note that spawn() does not by itself call the command interpreter\n     (getenv (\"COMSPEC\") != NULL ? getenv (\"COMSPEC\") :\n      ({ OSVERSIONINFO v; v.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);\n         GetVersionEx(&v);\n         v.dwPlatformId == VER_PLATFORM_WIN32_NT;\n      }) ? \"cmd.exe\" : \"command.com\").\n   Instead it simply concatenates the arguments, separated by ' ', and calls\n   CreateProcess().  We must quote the arguments since Win32 CreateProcess()\n   interprets characters like ' ', '\\t', '\\\\', '\"' (but not '<' and '>') in a\n   special way:\n   - Space and tab are interpreted as delimiters. They are not treated as\n     delimiters if they are surrounded by double quotes: \"...\".\n   - Unescaped double quotes are removed from the input. Their only effect is\n     that within double quotes, space and tab are treated like normal\n     characters.\n   - Backslashes not followed by double quotes are not special.\n   - But 2*n+1 backslashes followed by a double quote become\n     n backslashes followed by a double quote (n >= 0):\n       \\\" -> \"\n       \\\\\\\" -> \\\"\n       \\\\\\\\\\\" -> \\\\\"\n */\n#define SHELL_SPECIAL_CHARS \"\\\"\\\\ \\001\\002\\003\\004\\005\\006\\007\\010\\011\\012\\013\\014\\015\\016\\017\\020\\021\\022\\023\\024\\025\\026\\027\\030\\031\\032\\033\\034\\035\\036\\037\"\n#define SHELL_SPACE_CHARS \" \\001\\002\\003\\004\\005\\006\\007\\010\\011\\012\\013\\014\\015\\016\\017\\020\\021\\022\\023\\024\\025\\026\\027\\030\\031\\032\\033\\034\\035\\036\\037\"\nchar **\nprepare_spawn (char **argv)\n{\n  size_t argc;\n  char **new_argv;\n  size_t i;\n\n  /* Count number of arguments.  */\n  for (argc = 0; argv[argc] != NULL; argc++)\n    ;\n\n  /* Allocate new argument vector.  */\n  new_argv = XMALLOC (char *, argc + 1);\n\n  /* Put quoted arguments into the new argument vector.  */\n  for (i = 0; i < argc; i++)\n    {\n      const char *string = argv[i];\n\n      if (string[0] == '\\0')\n\tnew_argv[i] = xstrdup (\"\\\"\\\"\");\n      else if (strpbrk (string, SHELL_SPECIAL_CHARS) != NULL)\n\t{\n\t  int quote_around = (strpbrk (string, SHELL_SPACE_CHARS) != NULL);\n\t  size_t length;\n\t  unsigned int backslashes;\n\t  const char *s;\n\t  char *quoted_string;\n\t  char *p;\n\n\t  length = 0;\n\t  backslashes = 0;\n\t  if (quote_around)\n\t    length++;\n\t  for (s = string; *s != '\\0'; s++)\n\t    {\n\t      char c = *s;\n\t      if (c == '\"')\n\t\tlength += backslashes + 1;\n\t      length++;\n\t      if (c == '\\\\')\n\t\tbackslashes++;\n\t      else\n\t\tbackslashes = 0;\n\t    }\n\t  if (quote_around)\n\t    length += backslashes + 1;\n\n\t  quoted_string = XMALLOC (char, length + 1);\n\n\t  p = quoted_string;\n\t  backslashes = 0;\n\t  if (quote_around)\n\t    *p++ = '\"';\n\t  for (s = string; *s != '\\0'; s++)\n\t    {\n\t      char c = *s;\n\t      if (c == '\"')\n\t\t{\n\t\t  unsigned int j;\n\t\t  for (j = backslashes + 1; j > 0; j--)\n\t\t    *p++ = '\\\\';\n\t\t}\n\t      *p++ = c;\n\t      if (c == '\\\\')\n\t\tbackslashes++;\n\t      else\n\t\tbackslashes = 0;\n\t    }\n\t  if (quote_around)\n\t    {\n\t      unsigned int j;\n\t      for (j = backslashes; j > 0; j--)\n\t\t*p++ = '\\\\';\n\t      *p++ = '\"';\n\t    }\n\t  *p = '\\0';\n\n\t  new_argv[i] = quoted_string;\n\t}\n      else\n\tnew_argv[i] = (char *) string;\n    }\n  new_argv[argc] = NULL;\n\n  return new_argv;\n}\nEOF\n\t\t;;\n\t    esac\n\n            cat <<\"EOF\"\nvoid lt_dump_script (FILE* f)\n{\nEOF\n\t    func_emit_wrapper yes |\n\t      $SED -n -e '\ns/^\\(.\\{79\\}\\)\\(..*\\)/\\1\\\n\\2/\nh\ns/\\([\\\\\"]\\)/\\\\\\1/g\ns/$/\\\\n/\ns/\\([^\\n]*\\).*/  fputs (\"\\1\", f);/p\ng\nD'\n            cat <<\"EOF\"\n}\nEOF\n}\n# end: func_emit_cwrapperexe_src\n\n# func_win32_import_lib_p ARG\n# True if ARG is an import lib, as indicated by $file_magic_cmd\nfunc_win32_import_lib_p ()\n{\n    $debug_cmd\n\n    case `eval $file_magic_cmd \\\"\\$1\\\" 2>/dev/null | $SED -e 10q` in\n    *import*) : ;;\n    *) false ;;\n    esac\n}\n\n# func_suncc_cstd_abi\n# !!ONLY CALL THIS FOR SUN CC AFTER $compile_command IS FULLY EXPANDED!!\n# Several compiler flags select an ABI that is incompatible with the\n# Cstd library. Avoid specifying it if any are in CXXFLAGS.\nfunc_suncc_cstd_abi ()\n{\n    $debug_cmd\n\n    case \" $compile_command \" in\n    *\" -compat=g \"*|*\\ -std=c++[0-9][0-9]\\ *|*\" -library=stdcxx4 \"*|*\" -library=stlport4 \"*)\n      suncc_use_cstd_abi=no\n      ;;\n    *)\n      suncc_use_cstd_abi=yes\n      ;;\n    esac\n}\n\n# func_mode_link arg...\nfunc_mode_link ()\n{\n    $debug_cmd\n\n    case $host in\n    *-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-cegcc*)\n      # It is impossible to link a dll without this setting, and\n      # we shouldn't force the makefile maintainer to figure out\n      # what system we are compiling for in order to pass an extra\n      # flag for every libtool invocation.\n      # allow_undefined=no\n\n      # FIXME: Unfortunately, there are problems with the above when trying\n      # to make a dll that has undefined symbols, in which case not\n      # even a static library is built.  For now, we need to specify\n      # -no-undefined on the libtool link line when we can be certain\n      # that all symbols are satisfied, otherwise we get a static library.\n      allow_undefined=yes\n      ;;\n    *)\n      allow_undefined=yes\n      ;;\n    esac\n    libtool_args=$nonopt\n    base_compile=\"$nonopt $@\"\n    compile_command=$nonopt\n    finalize_command=$nonopt\n\n    compile_rpath=\n    finalize_rpath=\n    compile_shlibpath=\n    finalize_shlibpath=\n    convenience=\n    old_convenience=\n    deplibs=\n    old_deplibs=\n    compiler_flags=\n    linker_flags=\n    dllsearchpath=\n    lib_search_path=`pwd`\n    inst_prefix_dir=\n    new_inherited_linker_flags=\n\n    avoid_version=no\n    bindir=\n    dlfiles=\n    dlprefiles=\n    dlself=no\n    export_dynamic=no\n    export_symbols=\n    export_symbols_regex=\n    generated=\n    libobjs=\n    ltlibs=\n    module=no\n    no_install=no\n    objs=\n    os2dllname=\n    non_pic_objects=\n    precious_files_regex=\n    prefer_static_libs=no\n    preload=false\n    prev=\n    prevarg=\n    release=\n    rpath=\n    xrpath=\n    perm_rpath=\n    temp_rpath=\n    thread_safe=no\n    vinfo=\n    vinfo_number=no\n    weak_libs=\n    single_module=$wl-single_module\n    func_infer_tag $base_compile\n\n    # We need to know -static, to get the right output filenames.\n    for arg\n    do\n      case $arg in\n      -shared)\n\ttest yes != \"$build_libtool_libs\" \\\n\t  && func_fatal_configuration \"cannot build a shared library\"\n\tbuild_old_libs=no\n\tbreak\n\t;;\n      -all-static | -static | -static-libtool-libs)\n\tcase $arg in\n\t-all-static)\n\t  if test yes = \"$build_libtool_libs\" && test -z \"$link_static_flag\"; then\n\t    func_warning \"complete static linking is impossible in this configuration\"\n\t  fi\n\t  if test -n \"$link_static_flag\"; then\n\t    dlopen_self=$dlopen_self_static\n\t  fi\n\t  prefer_static_libs=yes\n\t  ;;\n\t-static)\n\t  if test -z \"$pic_flag\" && test -n \"$link_static_flag\"; then\n\t    dlopen_self=$dlopen_self_static\n\t  fi\n\t  prefer_static_libs=built\n\t  ;;\n\t-static-libtool-libs)\n\t  if test -z \"$pic_flag\" && test -n \"$link_static_flag\"; then\n\t    dlopen_self=$dlopen_self_static\n\t  fi\n\t  prefer_static_libs=yes\n\t  ;;\n\tesac\n\tbuild_libtool_libs=no\n\tbuild_old_libs=yes\n\tbreak\n\t;;\n      esac\n    done\n\n    # See if our shared archives depend on static archives.\n    test -n \"$old_archive_from_new_cmds\" && build_old_libs=yes\n\n    # Go through the arguments, transforming them on the way.\n    while test \"$#\" -gt 0; do\n      arg=$1\n      shift\n      func_quote_for_eval \"$arg\"\n      qarg=$func_quote_for_eval_unquoted_result\n      func_append libtool_args \" $func_quote_for_eval_result\"\n\n      # If the previous option needs an argument, assign it.\n      if test -n \"$prev\"; then\n\tcase $prev in\n\toutput)\n\t  func_append compile_command \" @OUTPUT@\"\n\t  func_append finalize_command \" @OUTPUT@\"\n\t  ;;\n\tesac\n\n\tcase $prev in\n\tbindir)\n\t  bindir=$arg\n\t  prev=\n\t  continue\n\t  ;;\n\tdlfiles|dlprefiles)\n\t  $preload || {\n\t    # Add the symbol object into the linking commands.\n\t    func_append compile_command \" @SYMFILE@\"\n\t    func_append finalize_command \" @SYMFILE@\"\n\t    preload=:\n\t  }\n\t  case $arg in\n\t  *.la | *.lo) ;;  # We handle these cases below.\n\t  force)\n\t    if test no = \"$dlself\"; then\n\t      dlself=needless\n\t      export_dynamic=yes\n\t    fi\n\t    prev=\n\t    continue\n\t    ;;\n\t  self)\n\t    if test dlprefiles = \"$prev\"; then\n\t      dlself=yes\n\t    elif test dlfiles = \"$prev\" && test yes != \"$dlopen_self\"; then\n\t      dlself=yes\n\t    else\n\t      dlself=needless\n\t      export_dynamic=yes\n\t    fi\n\t    prev=\n\t    continue\n\t    ;;\n\t  *)\n\t    if test dlfiles = \"$prev\"; then\n\t      func_append dlfiles \" $arg\"\n\t    else\n\t      func_append dlprefiles \" $arg\"\n\t    fi\n\t    prev=\n\t    continue\n\t    ;;\n\t  esac\n\t  ;;\n\texpsyms)\n\t  export_symbols=$arg\n\t  test -f \"$arg\" \\\n\t    || func_fatal_error \"symbol file '$arg' does not exist\"\n\t  prev=\n\t  continue\n\t  ;;\n\texpsyms_regex)\n\t  export_symbols_regex=$arg\n\t  prev=\n\t  continue\n\t  ;;\n\tframework)\n\t  case $host in\n\t    *-*-darwin*)\n\t      case \"$deplibs \" in\n\t\t*\" $qarg.ltframework \"*) ;;\n\t\t*) func_append deplibs \" $qarg.ltframework\" # this is fixed later\n\t\t   ;;\n\t      esac\n\t      ;;\n\t  esac\n\t  prev=\n\t  continue\n\t  ;;\n\tinst_prefix)\n\t  inst_prefix_dir=$arg\n\t  prev=\n\t  continue\n\t  ;;\n\tmllvm)\n\t  # Clang does not use LLVM to link, so we can simply discard any\n\t  # '-mllvm $arg' options when doing the link step.\n\t  prev=\n\t  continue\n\t  ;;\n\tobjectlist)\n\t  if test -f \"$arg\"; then\n\t    save_arg=$arg\n\t    moreargs=\n\t    for fil in `cat \"$save_arg\"`\n\t    do\n#\t      func_append moreargs \" $fil\"\n\t      arg=$fil\n\t      # A libtool-controlled object.\n\n\t      # Check to see that this really is a libtool object.\n\t      if func_lalib_unsafe_p \"$arg\"; then\n\t\tpic_object=\n\t\tnon_pic_object=\n\n\t\t# Read the .lo file\n\t\tfunc_source \"$arg\"\n\n\t\tif test -z \"$pic_object\" ||\n\t\t   test -z \"$non_pic_object\" ||\n\t\t   test none = \"$pic_object\" &&\n\t\t   test none = \"$non_pic_object\"; then\n\t\t  func_fatal_error \"cannot find name of object for '$arg'\"\n\t\tfi\n\n\t\t# Extract subdirectory from the argument.\n\t\tfunc_dirname \"$arg\" \"/\" \"\"\n\t\txdir=$func_dirname_result\n\n\t\tif test none != \"$pic_object\"; then\n\t\t  # Prepend the subdirectory the object is found in.\n\t\t  pic_object=$xdir$pic_object\n\n\t\t  if test dlfiles = \"$prev\"; then\n\t\t    if test yes = \"$build_libtool_libs\" && test yes = \"$dlopen_support\"; then\n\t\t      func_append dlfiles \" $pic_object\"\n\t\t      prev=\n\t\t      continue\n\t\t    else\n\t\t      # If libtool objects are unsupported, then we need to preload.\n\t\t      prev=dlprefiles\n\t\t    fi\n\t\t  fi\n\n\t\t  # CHECK ME:  I think I busted this.  -Ossama\n\t\t  if test dlprefiles = \"$prev\"; then\n\t\t    # Preload the old-style object.\n\t\t    func_append dlprefiles \" $pic_object\"\n\t\t    prev=\n\t\t  fi\n\n\t\t  # A PIC object.\n\t\t  func_append libobjs \" $pic_object\"\n\t\t  arg=$pic_object\n\t\tfi\n\n\t\t# Non-PIC object.\n\t\tif test none != \"$non_pic_object\"; then\n\t\t  # Prepend the subdirectory the object is found in.\n\t\t  non_pic_object=$xdir$non_pic_object\n\n\t\t  # A standard non-PIC object\n\t\t  func_append non_pic_objects \" $non_pic_object\"\n\t\t  if test -z \"$pic_object\" || test none = \"$pic_object\"; then\n\t\t    arg=$non_pic_object\n\t\t  fi\n\t\telse\n\t\t  # If the PIC object exists, use it instead.\n\t\t  # $xdir was prepended to $pic_object above.\n\t\t  non_pic_object=$pic_object\n\t\t  func_append non_pic_objects \" $non_pic_object\"\n\t\tfi\n\t      else\n\t\t# Only an error if not doing a dry-run.\n\t\tif $opt_dry_run; then\n\t\t  # Extract subdirectory from the argument.\n\t\t  func_dirname \"$arg\" \"/\" \"\"\n\t\t  xdir=$func_dirname_result\n\n\t\t  func_lo2o \"$arg\"\n\t\t  pic_object=$xdir$objdir/$func_lo2o_result\n\t\t  non_pic_object=$xdir$func_lo2o_result\n\t\t  func_append libobjs \" $pic_object\"\n\t\t  func_append non_pic_objects \" $non_pic_object\"\n\t        else\n\t\t  func_fatal_error \"'$arg' is not a valid libtool object\"\n\t\tfi\n\t      fi\n\t    done\n\t  else\n\t    func_fatal_error \"link input file '$arg' does not exist\"\n\t  fi\n\t  arg=$save_arg\n\t  prev=\n\t  continue\n\t  ;;\n\tos2dllname)\n\t  os2dllname=$arg\n\t  prev=\n\t  continue\n\t  ;;\n\tprecious_regex)\n\t  precious_files_regex=$arg\n\t  prev=\n\t  continue\n\t  ;;\n\trelease)\n\t  release=-$arg\n\t  prev=\n\t  continue\n\t  ;;\n\trpath | xrpath)\n\t  # We need an absolute path.\n\t  case $arg in\n\t  [\\\\/]* | [A-Za-z]:[\\\\/]*) ;;\n\t  *)\n\t    func_fatal_error \"only absolute run-paths are allowed\"\n\t    ;;\n\t  esac\n\t  if test rpath = \"$prev\"; then\n\t    case \"$rpath \" in\n\t    *\" $arg \"*) ;;\n\t    *) func_append rpath \" $arg\" ;;\n\t    esac\n\t  else\n\t    case \"$xrpath \" in\n\t    *\" $arg \"*) ;;\n\t    *) func_append xrpath \" $arg\" ;;\n\t    esac\n\t  fi\n\t  prev=\n\t  continue\n\t  ;;\n\tshrext)\n\t  shrext_cmds=$arg\n\t  prev=\n\t  continue\n\t  ;;\n\tweak)\n\t  func_append weak_libs \" $arg\"\n\t  prev=\n\t  continue\n\t  ;;\n\txcclinker)\n\t  func_append linker_flags \" $qarg\"\n\t  func_append compiler_flags \" $qarg\"\n\t  prev=\n\t  func_append compile_command \" $qarg\"\n\t  func_append finalize_command \" $qarg\"\n\t  continue\n\t  ;;\n\txcompiler)\n\t  func_append compiler_flags \" $qarg\"\n\t  prev=\n\t  func_append compile_command \" $qarg\"\n\t  func_append finalize_command \" $qarg\"\n\t  continue\n\t  ;;\n\txlinker)\n\t  func_append linker_flags \" $qarg\"\n\t  func_append compiler_flags \" $wl$qarg\"\n\t  prev=\n\t  func_append compile_command \" $wl$qarg\"\n\t  func_append finalize_command \" $wl$qarg\"\n\t  continue\n\t  ;;\n\t*)\n\t  eval \"$prev=\\\"\\$arg\\\"\"\n\t  prev=\n\t  continue\n\t  ;;\n\tesac\n      fi # test -n \"$prev\"\n\n      prevarg=$arg\n\n      case $arg in\n      -all-static)\n\tif test -n \"$link_static_flag\"; then\n\t  # See comment for -static flag below, for more details.\n\t  func_append compile_command \" $link_static_flag\"\n\t  func_append finalize_command \" $link_static_flag\"\n\tfi\n\tcontinue\n\t;;\n\n      -allow-undefined)\n\t# FIXME: remove this flag sometime in the future.\n\tfunc_fatal_error \"'-allow-undefined' must not be used because it is the default\"\n\t;;\n\n      -avoid-version)\n\tavoid_version=yes\n\tcontinue\n\t;;\n\n      -bindir)\n\tprev=bindir\n\tcontinue\n\t;;\n\n      -dlopen)\n\tprev=dlfiles\n\tcontinue\n\t;;\n\n      -dlpreopen)\n\tprev=dlprefiles\n\tcontinue\n\t;;\n\n      -export-dynamic)\n\texport_dynamic=yes\n\tcontinue\n\t;;\n\n      -export-symbols | -export-symbols-regex)\n\tif test -n \"$export_symbols\" || test -n \"$export_symbols_regex\"; then\n\t  func_fatal_error \"more than one -exported-symbols argument is not allowed\"\n\tfi\n\tif test X-export-symbols = \"X$arg\"; then\n\t  prev=expsyms\n\telse\n\t  prev=expsyms_regex\n\tfi\n\tcontinue\n\t;;\n\n      -framework)\n\tprev=framework\n\tcontinue\n\t;;\n\n      -inst-prefix-dir)\n\tprev=inst_prefix\n\tcontinue\n\t;;\n\n      # The native IRIX linker understands -LANG:*, -LIST:* and -LNO:*\n      # so, if we see these flags be careful not to treat them like -L\n      -L[A-Z][A-Z]*:*)\n\tcase $with_gcc/$host in\n\tno/*-*-irix* | /*-*-irix*)\n\t  func_append compile_command \" $arg\"\n\t  func_append finalize_command \" $arg\"\n\t  ;;\n\tesac\n\tcontinue\n\t;;\n\n      -L*)\n\tfunc_stripname \"-L\" '' \"$arg\"\n\tif test -z \"$func_stripname_result\"; then\n\t  if test \"$#\" -gt 0; then\n\t    func_fatal_error \"require no space between '-L' and '$1'\"\n\t  else\n\t    func_fatal_error \"need path for '-L' option\"\n\t  fi\n\tfi\n\tfunc_resolve_sysroot \"$func_stripname_result\"\n\tdir=$func_resolve_sysroot_result\n\t# We need an absolute path.\n\tcase $dir in\n\t[\\\\/]* | [A-Za-z]:[\\\\/]*) ;;\n\t*)\n\t  absdir=`cd \"$dir\" && pwd`\n\t  test -z \"$absdir\" && \\\n\t    func_fatal_error \"cannot determine absolute directory name of '$dir'\"\n\t  dir=$absdir\n\t  ;;\n\tesac\n\tcase \"$deplibs \" in\n\t*\" -L$dir \"* | *\" $arg \"*)\n\t  # Will only happen for absolute or sysroot arguments\n\t  ;;\n\t*)\n\t  # Preserve sysroot, but never include relative directories\n\t  case $dir in\n\t    [\\\\/]* | [A-Za-z]:[\\\\/]* | =*) func_append deplibs \" $arg\" ;;\n\t    *) func_append deplibs \" -L$dir\" ;;\n\t  esac\n\t  func_append lib_search_path \" $dir\"\n\t  ;;\n\tesac\n\tcase $host in\n\t*-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-cegcc*)\n\t  testbindir=`$ECHO \"$dir\" | $SED 's*/lib$*/bin*'`\n\t  case :$dllsearchpath: in\n\t  *\":$dir:\"*) ;;\n\t  ::) dllsearchpath=$dir;;\n\t  *) func_append dllsearchpath \":$dir\";;\n\t  esac\n\t  case :$dllsearchpath: in\n\t  *\":$testbindir:\"*) ;;\n\t  ::) dllsearchpath=$testbindir;;\n\t  *) func_append dllsearchpath \":$testbindir\";;\n\t  esac\n\t  ;;\n\tesac\n\tcontinue\n\t;;\n\n      -l*)\n\tif test X-lc = \"X$arg\" || test X-lm = \"X$arg\"; then\n\t  case $host in\n\t  *-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-beos* | *-cegcc* | *-*-haiku*)\n\t    # These systems don't actually have a C or math library (as such)\n\t    continue\n\t    ;;\n\t  *-*-os2*)\n\t    # These systems don't actually have a C library (as such)\n\t    test X-lc = \"X$arg\" && continue\n\t    ;;\n\t  *-*-openbsd* | *-*-freebsd* | *-*-dragonfly* | *-*-bitrig*)\n\t    # Do not include libc due to us having libc/libc_r.\n\t    test X-lc = \"X$arg\" && continue\n\t    ;;\n\t  *-*-rhapsody* | *-*-darwin1.[012])\n\t    # Rhapsody C and math libraries are in the System framework\n\t    func_append deplibs \" System.ltframework\"\n\t    continue\n\t    ;;\n\t  *-*-sco3.2v5* | *-*-sco5v6*)\n\t    # Causes problems with __ctype\n\t    test X-lc = \"X$arg\" && continue\n\t    ;;\n\t  *-*-sysv4.2uw2* | *-*-sysv5* | *-*-unixware* | *-*-OpenUNIX*)\n\t    # Compiler inserts libc in the correct place for threads to work\n\t    test X-lc = \"X$arg\" && continue\n\t    ;;\n\t  esac\n\telif test X-lc_r = \"X$arg\"; then\n\t case $host in\n\t *-*-openbsd* | *-*-freebsd* | *-*-dragonfly* | *-*-bitrig*)\n\t   # Do not include libc_r directly, use -pthread flag.\n\t   continue\n\t   ;;\n\t esac\n\tfi\n\tfunc_append deplibs \" $arg\"\n\tcontinue\n\t;;\n\n      -mllvm)\n\tprev=mllvm\n\tcontinue\n\t;;\n\n      -module)\n\tmodule=yes\n\tcontinue\n\t;;\n\n      # Tru64 UNIX uses -model [arg] to determine the layout of C++\n      # classes, name mangling, and exception handling.\n      # Darwin uses the -arch flag to determine output architecture.\n      -model|-arch|-isysroot|--sysroot)\n\tfunc_append compiler_flags \" $arg\"\n\tfunc_append compile_command \" $arg\"\n\tfunc_append finalize_command \" $arg\"\n\tprev=xcompiler\n\tcontinue\n\t;;\n\n      -mt|-mthreads|-kthread|-Kthread|-pthread|-pthreads|--thread-safe \\\n      |-threads|-fopenmp|-openmp|-mp|-xopenmp|-omp|-qsmp=*)\n\tfunc_append compiler_flags \" $arg\"\n\tfunc_append compile_command \" $arg\"\n\tfunc_append finalize_command \" $arg\"\n\tcase \"$new_inherited_linker_flags \" in\n\t    *\" $arg \"*) ;;\n\t    * ) func_append new_inherited_linker_flags \" $arg\" ;;\n\tesac\n\tcontinue\n\t;;\n\n      -multi_module)\n\tsingle_module=$wl-multi_module\n\tcontinue\n\t;;\n\n      -no-fast-install)\n\tfast_install=no\n\tcontinue\n\t;;\n\n      -no-install)\n\tcase $host in\n\t*-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-*-darwin* | *-cegcc*)\n\t  # The PATH hackery in wrapper scripts is required on Windows\n\t  # and Darwin in order for the loader to find any dlls it needs.\n\t  func_warning \"'-no-install' is ignored for $host\"\n\t  func_warning \"assuming '-no-fast-install' instead\"\n\t  fast_install=no\n\t  ;;\n\t*) no_install=yes ;;\n\tesac\n\tcontinue\n\t;;\n\n      -no-undefined)\n\tallow_undefined=no\n\tcontinue\n\t;;\n\n      -objectlist)\n\tprev=objectlist\n\tcontinue\n\t;;\n\n      -os2dllname)\n\tprev=os2dllname\n\tcontinue\n\t;;\n\n      -o) prev=output ;;\n\n      -precious-files-regex)\n\tprev=precious_regex\n\tcontinue\n\t;;\n\n      -release)\n\tprev=release\n\tcontinue\n\t;;\n\n      -rpath)\n\tprev=rpath\n\tcontinue\n\t;;\n\n      -R)\n\tprev=xrpath\n\tcontinue\n\t;;\n\n      -R*)\n\tfunc_stripname '-R' '' \"$arg\"\n\tdir=$func_stripname_result\n\t# We need an absolute path.\n\tcase $dir in\n\t[\\\\/]* | [A-Za-z]:[\\\\/]*) ;;\n\t=*)\n\t  func_stripname '=' '' \"$dir\"\n\t  dir=$lt_sysroot$func_stripname_result\n\t  ;;\n\t*)\n\t  func_fatal_error \"only absolute run-paths are allowed\"\n\t  ;;\n\tesac\n\tcase \"$xrpath \" in\n\t*\" $dir \"*) ;;\n\t*) func_append xrpath \" $dir\" ;;\n\tesac\n\tcontinue\n\t;;\n\n      -shared)\n\t# The effects of -shared are defined in a previous loop.\n\tcontinue\n\t;;\n\n      -shrext)\n\tprev=shrext\n\tcontinue\n\t;;\n\n      -static | -static-libtool-libs)\n\t# The effects of -static are defined in a previous loop.\n\t# We used to do the same as -all-static on platforms that\n\t# didn't have a PIC flag, but the assumption that the effects\n\t# would be equivalent was wrong.  It would break on at least\n\t# Digital Unix and AIX.\n\tcontinue\n\t;;\n\n      -thread-safe)\n\tthread_safe=yes\n\tcontinue\n\t;;\n\n      -version-info)\n\tprev=vinfo\n\tcontinue\n\t;;\n\n      -version-number)\n\tprev=vinfo\n\tvinfo_number=yes\n\tcontinue\n\t;;\n\n      -weak)\n        prev=weak\n\tcontinue\n\t;;\n\n      -Wc,*)\n\tfunc_stripname '-Wc,' '' \"$arg\"\n\targs=$func_stripname_result\n\targ=\n\tsave_ifs=$IFS; IFS=,\n\tfor flag in $args; do\n\t  IFS=$save_ifs\n          func_quote_for_eval \"$flag\"\n\t  func_append arg \" $func_quote_for_eval_result\"\n\t  func_append compiler_flags \" $func_quote_for_eval_result\"\n\tdone\n\tIFS=$save_ifs\n\tfunc_stripname ' ' '' \"$arg\"\n\targ=$func_stripname_result\n\t;;\n\n      -Wl,*)\n\tfunc_stripname '-Wl,' '' \"$arg\"\n\targs=$func_stripname_result\n\targ=\n\tsave_ifs=$IFS; IFS=,\n\tfor flag in $args; do\n\t  IFS=$save_ifs\n          func_quote_for_eval \"$flag\"\n\t  func_append arg \" $wl$func_quote_for_eval_result\"\n\t  func_append compiler_flags \" $wl$func_quote_for_eval_result\"\n\t  func_append linker_flags \" $func_quote_for_eval_result\"\n\tdone\n\tIFS=$save_ifs\n\tfunc_stripname ' ' '' \"$arg\"\n\targ=$func_stripname_result\n\t;;\n\n      -Xcompiler)\n\tprev=xcompiler\n\tcontinue\n\t;;\n\n      -Xlinker)\n\tprev=xlinker\n\tcontinue\n\t;;\n\n      -XCClinker)\n\tprev=xcclinker\n\tcontinue\n\t;;\n\n      # -msg_* for osf cc\n      -msg_*)\n\tfunc_quote_for_eval \"$arg\"\n\targ=$func_quote_for_eval_result\n\t;;\n\n      # Flags to be passed through unchanged, with rationale:\n      # -64, -mips[0-9]      enable 64-bit mode for the SGI compiler\n      # -r[0-9][0-9]*        specify processor for the SGI compiler\n      # -xarch=*, -xtarget=* enable 64-bit mode for the Sun compiler\n      # +DA*, +DD*           enable 64-bit mode for the HP compiler\n      # -q*                  compiler args for the IBM compiler\n      # -m*, -t[45]*, -txscale* architecture-specific flags for GCC\n      # -F/path              path to uninstalled frameworks, gcc on darwin\n      # -p, -pg, --coverage, -fprofile-*  profiling flags for GCC\n      # -fstack-protector*   stack protector flags for GCC\n      # @file                GCC response files\n      # -tp=*                Portland pgcc target processor selection\n      # --sysroot=*          for sysroot support\n      # -O*, -g*, -flto*, -fwhopr*, -fuse-linker-plugin GCC link-time optimization\n      # -stdlib=*            select c++ std lib with clang\n      -64|-mips[0-9]|-r[0-9][0-9]*|-xarch=*|-xtarget=*|+DA*|+DD*|-q*|-m*| \\\n      -t[45]*|-txscale*|-p|-pg|--coverage|-fprofile-*|-F*|@*|-tp=*|--sysroot=*| \\\n      -O*|-g*|-flto*|-fwhopr*|-fuse-linker-plugin|-fstack-protector*|-stdlib=*)\n        func_quote_for_eval \"$arg\"\n\targ=$func_quote_for_eval_result\n        func_append compile_command \" $arg\"\n        func_append finalize_command \" $arg\"\n        func_append compiler_flags \" $arg\"\n        continue\n        ;;\n\n      -Z*)\n        if test os2 = \"`expr $host : '.*\\(os2\\)'`\"; then\n          # OS/2 uses -Zxxx to specify OS/2-specific options\n\t  compiler_flags=\"$compiler_flags $arg\"\n\t  func_append compile_command \" $arg\"\n\t  func_append finalize_command \" $arg\"\n\t  case $arg in\n\t  -Zlinker | -Zstack)\n\t    prev=xcompiler\n\t    ;;\n\t  esac\n\t  continue\n        else\n\t  # Otherwise treat like 'Some other compiler flag' below\n\t  func_quote_for_eval \"$arg\"\n\t  arg=$func_quote_for_eval_result\n        fi\n\t;;\n\n      # Some other compiler flag.\n      -* | +*)\n        func_quote_for_eval \"$arg\"\n\targ=$func_quote_for_eval_result\n\t;;\n\n      *.$objext)\n\t# A standard object.\n\tfunc_append objs \" $arg\"\n\t;;\n\n      *.lo)\n\t# A libtool-controlled object.\n\n\t# Check to see that this really is a libtool object.\n\tif func_lalib_unsafe_p \"$arg\"; then\n\t  pic_object=\n\t  non_pic_object=\n\n\t  # Read the .lo file\n\t  func_source \"$arg\"\n\n\t  if test -z \"$pic_object\" ||\n\t     test -z \"$non_pic_object\" ||\n\t     test none = \"$pic_object\" &&\n\t     test none = \"$non_pic_object\"; then\n\t    func_fatal_error \"cannot find name of object for '$arg'\"\n\t  fi\n\n\t  # Extract subdirectory from the argument.\n\t  func_dirname \"$arg\" \"/\" \"\"\n\t  xdir=$func_dirname_result\n\n\t  test none = \"$pic_object\" || {\n\t    # Prepend the subdirectory the object is found in.\n\t    pic_object=$xdir$pic_object\n\n\t    if test dlfiles = \"$prev\"; then\n\t      if test yes = \"$build_libtool_libs\" && test yes = \"$dlopen_support\"; then\n\t\tfunc_append dlfiles \" $pic_object\"\n\t\tprev=\n\t\tcontinue\n\t      else\n\t\t# If libtool objects are unsupported, then we need to preload.\n\t\tprev=dlprefiles\n\t      fi\n\t    fi\n\n\t    # CHECK ME:  I think I busted this.  -Ossama\n\t    if test dlprefiles = \"$prev\"; then\n\t      # Preload the old-style object.\n\t      func_append dlprefiles \" $pic_object\"\n\t      prev=\n\t    fi\n\n\t    # A PIC object.\n\t    func_append libobjs \" $pic_object\"\n\t    arg=$pic_object\n\t  }\n\n\t  # Non-PIC object.\n\t  if test none != \"$non_pic_object\"; then\n\t    # Prepend the subdirectory the object is found in.\n\t    non_pic_object=$xdir$non_pic_object\n\n\t    # A standard non-PIC object\n\t    func_append non_pic_objects \" $non_pic_object\"\n\t    if test -z \"$pic_object\" || test none = \"$pic_object\"; then\n\t      arg=$non_pic_object\n\t    fi\n\t  else\n\t    # If the PIC object exists, use it instead.\n\t    # $xdir was prepended to $pic_object above.\n\t    non_pic_object=$pic_object\n\t    func_append non_pic_objects \" $non_pic_object\"\n\t  fi\n\telse\n\t  # Only an error if not doing a dry-run.\n\t  if $opt_dry_run; then\n\t    # Extract subdirectory from the argument.\n\t    func_dirname \"$arg\" \"/\" \"\"\n\t    xdir=$func_dirname_result\n\n\t    func_lo2o \"$arg\"\n\t    pic_object=$xdir$objdir/$func_lo2o_result\n\t    non_pic_object=$xdir$func_lo2o_result\n\t    func_append libobjs \" $pic_object\"\n\t    func_append non_pic_objects \" $non_pic_object\"\n\t  else\n\t    func_fatal_error \"'$arg' is not a valid libtool object\"\n\t  fi\n\tfi\n\t;;\n\n      *.$libext)\n\t# An archive.\n\tfunc_append deplibs \" $arg\"\n\tfunc_append old_deplibs \" $arg\"\n\tcontinue\n\t;;\n\n      *.la)\n\t# A libtool-controlled library.\n\n\tfunc_resolve_sysroot \"$arg\"\n\tif test dlfiles = \"$prev\"; then\n\t  # This library was specified with -dlopen.\n\t  func_append dlfiles \" $func_resolve_sysroot_result\"\n\t  prev=\n\telif test dlprefiles = \"$prev\"; then\n\t  # The library was specified with -dlpreopen.\n\t  func_append dlprefiles \" $func_resolve_sysroot_result\"\n\t  prev=\n\telse\n\t  func_append deplibs \" $func_resolve_sysroot_result\"\n\tfi\n\tcontinue\n\t;;\n\n      # Some other compiler argument.\n      *)\n\t# Unknown arguments in both finalize_command and compile_command need\n\t# to be aesthetically quoted because they are evaled later.\n\tfunc_quote_for_eval \"$arg\"\n\targ=$func_quote_for_eval_result\n\t;;\n      esac # arg\n\n      # Now actually substitute the argument into the commands.\n      if test -n \"$arg\"; then\n\tfunc_append compile_command \" $arg\"\n\tfunc_append finalize_command \" $arg\"\n      fi\n    done # argument parsing loop\n\n    test -n \"$prev\" && \\\n      func_fatal_help \"the '$prevarg' option requires an argument\"\n\n    if test yes = \"$export_dynamic\" && test -n \"$export_dynamic_flag_spec\"; then\n      eval arg=\\\"$export_dynamic_flag_spec\\\"\n      func_append compile_command \" $arg\"\n      func_append finalize_command \" $arg\"\n    fi\n\n    oldlibs=\n    # calculate the name of the file, without its directory\n    func_basename \"$output\"\n    outputname=$func_basename_result\n    libobjs_save=$libobjs\n\n    if test -n \"$shlibpath_var\"; then\n      # get the directories listed in $shlibpath_var\n      eval shlib_search_path=\\`\\$ECHO \\\"\\$$shlibpath_var\\\" \\| \\$SED \\'s/:/ /g\\'\\`\n    else\n      shlib_search_path=\n    fi\n    eval sys_lib_search_path=\\\"$sys_lib_search_path_spec\\\"\n    eval sys_lib_dlsearch_path=\\\"$sys_lib_dlsearch_path_spec\\\"\n\n    # Definition is injected by LT_CONFIG during libtool generation.\n    func_munge_path_list sys_lib_dlsearch_path \"$LT_SYS_LIBRARY_PATH\"\n\n    func_dirname \"$output\" \"/\" \"\"\n    output_objdir=$func_dirname_result$objdir\n    func_to_tool_file \"$output_objdir/\"\n    tool_output_objdir=$func_to_tool_file_result\n    # Create the object directory.\n    func_mkdir_p \"$output_objdir\"\n\n    # Determine the type of output\n    case $output in\n    \"\")\n      func_fatal_help \"you must specify an output file\"\n      ;;\n    *.$libext) linkmode=oldlib ;;\n    *.lo | *.$objext) linkmode=obj ;;\n    *.la) linkmode=lib ;;\n    *) linkmode=prog ;; # Anything else should be a program.\n    esac\n\n    specialdeplibs=\n\n    libs=\n    # Find all interdependent deplibs by searching for libraries\n    # that are linked more than once (e.g. -la -lb -la)\n    for deplib in $deplibs; do\n      if $opt_preserve_dup_deps; then\n\tcase \"$libs \" in\n\t*\" $deplib \"*) func_append specialdeplibs \" $deplib\" ;;\n\tesac\n      fi\n      func_append libs \" $deplib\"\n    done\n\n    if test lib = \"$linkmode\"; then\n      libs=\"$predeps $libs $compiler_lib_search_path $postdeps\"\n\n      # Compute libraries that are listed more than once in $predeps\n      # $postdeps and mark them as special (i.e., whose duplicates are\n      # not to be eliminated).\n      pre_post_deps=\n      if $opt_duplicate_compiler_generated_deps; then\n\tfor pre_post_dep in $predeps $postdeps; do\n\t  case \"$pre_post_deps \" in\n\t  *\" $pre_post_dep \"*) func_append specialdeplibs \" $pre_post_deps\" ;;\n\t  esac\n\t  func_append pre_post_deps \" $pre_post_dep\"\n\tdone\n      fi\n      pre_post_deps=\n    fi\n\n    deplibs=\n    newdependency_libs=\n    newlib_search_path=\n    need_relink=no # whether we're linking any uninstalled libtool libraries\n    notinst_deplibs= # not-installed libtool libraries\n    notinst_path= # paths that contain not-installed libtool libraries\n\n    case $linkmode in\n    lib)\n\tpasses=\"conv dlpreopen link\"\n\tfor file in $dlfiles $dlprefiles; do\n\t  case $file in\n\t  *.la) ;;\n\t  *)\n\t    func_fatal_help \"libraries can '-dlopen' only libtool libraries: $file\"\n\t    ;;\n\t  esac\n\tdone\n\t;;\n    prog)\n\tcompile_deplibs=\n\tfinalize_deplibs=\n\talldeplibs=false\n\tnewdlfiles=\n\tnewdlprefiles=\n\tpasses=\"conv scan dlopen dlpreopen link\"\n\t;;\n    *)  passes=\"conv\"\n\t;;\n    esac\n\n    for pass in $passes; do\n      # The preopen pass in lib mode reverses $deplibs; put it back here\n      # so that -L comes before libs that need it for instance...\n      if test lib,link = \"$linkmode,$pass\"; then\n\t## FIXME: Find the place where the list is rebuilt in the wrong\n\t##        order, and fix it there properly\n        tmp_deplibs=\n\tfor deplib in $deplibs; do\n\t  tmp_deplibs=\"$deplib $tmp_deplibs\"\n\tdone\n\tdeplibs=$tmp_deplibs\n      fi\n\n      if test lib,link = \"$linkmode,$pass\" ||\n\t test prog,scan = \"$linkmode,$pass\"; then\n\tlibs=$deplibs\n\tdeplibs=\n      fi\n      if test prog = \"$linkmode\"; then\n\tcase $pass in\n\tdlopen) libs=$dlfiles ;;\n\tdlpreopen) libs=$dlprefiles ;;\n\tlink) libs=\"$deplibs %DEPLIBS% $dependency_libs\" ;;\n\tesac\n      fi\n      if test lib,dlpreopen = \"$linkmode,$pass\"; then\n\t# Collect and forward deplibs of preopened libtool libs\n\tfor lib in $dlprefiles; do\n\t  # Ignore non-libtool-libs\n\t  dependency_libs=\n\t  func_resolve_sysroot \"$lib\"\n\t  case $lib in\n\t  *.la)\tfunc_source \"$func_resolve_sysroot_result\" ;;\n\t  esac\n\n\t  # Collect preopened libtool deplibs, except any this library\n\t  # has declared as weak libs\n\t  for deplib in $dependency_libs; do\n\t    func_basename \"$deplib\"\n            deplib_base=$func_basename_result\n\t    case \" $weak_libs \" in\n\t    *\" $deplib_base \"*) ;;\n\t    *) func_append deplibs \" $deplib\" ;;\n\t    esac\n\t  done\n\tdone\n\tlibs=$dlprefiles\n      fi\n      if test dlopen = \"$pass\"; then\n\t# Collect dlpreopened libraries\n\tsave_deplibs=$deplibs\n\tdeplibs=\n      fi\n\n      for deplib in $libs; do\n\tlib=\n\tfound=false\n\tcase $deplib in\n\t-mt|-mthreads|-kthread|-Kthread|-pthread|-pthreads|--thread-safe \\\n        |-threads|-fopenmp|-openmp|-mp|-xopenmp|-omp|-qsmp=*)\n\t  if test prog,link = \"$linkmode,$pass\"; then\n\t    compile_deplibs=\"$deplib $compile_deplibs\"\n\t    finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t  else\n\t    func_append compiler_flags \" $deplib\"\n\t    if test lib = \"$linkmode\"; then\n\t\tcase \"$new_inherited_linker_flags \" in\n\t\t    *\" $deplib \"*) ;;\n\t\t    * ) func_append new_inherited_linker_flags \" $deplib\" ;;\n\t\tesac\n\t    fi\n\t  fi\n\t  continue\n\t  ;;\n\t-l*)\n\t  if test lib != \"$linkmode\" && test prog != \"$linkmode\"; then\n\t    func_warning \"'-l' is ignored for archives/objects\"\n\t    continue\n\t  fi\n\t  func_stripname '-l' '' \"$deplib\"\n\t  name=$func_stripname_result\n\t  if test lib = \"$linkmode\"; then\n\t    searchdirs=\"$newlib_search_path $lib_search_path $compiler_lib_search_dirs $sys_lib_search_path $shlib_search_path\"\n\t  else\n\t    searchdirs=\"$newlib_search_path $lib_search_path $sys_lib_search_path $shlib_search_path\"\n\t  fi\n\t  for searchdir in $searchdirs; do\n\t    for search_ext in .la $std_shrext .so .a; do\n\t      # Search the libtool library\n\t      lib=$searchdir/lib$name$search_ext\n\t      if test -f \"$lib\"; then\n\t\tif test .la = \"$search_ext\"; then\n\t\t  found=:\n\t\telse\n\t\t  found=false\n\t\tfi\n\t\tbreak 2\n\t      fi\n\t    done\n\t  done\n\t  if $found; then\n\t    # deplib is a libtool library\n\t    # If $allow_libtool_libs_with_static_runtimes && $deplib is a stdlib,\n\t    # We need to do some special things here, and not later.\n\t    if test yes = \"$allow_libtool_libs_with_static_runtimes\"; then\n\t      case \" $predeps $postdeps \" in\n\t      *\" $deplib \"*)\n\t\tif func_lalib_p \"$lib\"; then\n\t\t  library_names=\n\t\t  old_library=\n\t\t  func_source \"$lib\"\n\t\t  for l in $old_library $library_names; do\n\t\t    ll=$l\n\t\t  done\n\t\t  if test \"X$ll\" = \"X$old_library\"; then # only static version available\n\t\t    found=false\n\t\t    func_dirname \"$lib\" \"\" \".\"\n\t\t    ladir=$func_dirname_result\n\t\t    lib=$ladir/$old_library\n\t\t    if test prog,link = \"$linkmode,$pass\"; then\n\t\t      compile_deplibs=\"$deplib $compile_deplibs\"\n\t\t      finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t\t    else\n\t\t      deplibs=\"$deplib $deplibs\"\n\t\t      test lib = \"$linkmode\" && newdependency_libs=\"$deplib $newdependency_libs\"\n\t\t    fi\n\t\t    continue\n\t\t  fi\n\t\tfi\n\t\t;;\n\t      *) ;;\n\t      esac\n\t    fi\n\t  else\n\t    # deplib doesn't seem to be a libtool library\n\t    if test prog,link = \"$linkmode,$pass\"; then\n\t      compile_deplibs=\"$deplib $compile_deplibs\"\n\t      finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t    else\n\t      deplibs=\"$deplib $deplibs\"\n\t      test lib = \"$linkmode\" && newdependency_libs=\"$deplib $newdependency_libs\"\n\t    fi\n\t    continue\n\t  fi\n\t  ;; # -l\n\t*.ltframework)\n\t  if test prog,link = \"$linkmode,$pass\"; then\n\t    compile_deplibs=\"$deplib $compile_deplibs\"\n\t    finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t  else\n\t    deplibs=\"$deplib $deplibs\"\n\t    if test lib = \"$linkmode\"; then\n\t\tcase \"$new_inherited_linker_flags \" in\n\t\t    *\" $deplib \"*) ;;\n\t\t    * ) func_append new_inherited_linker_flags \" $deplib\" ;;\n\t\tesac\n\t    fi\n\t  fi\n\t  continue\n\t  ;;\n\t-L*)\n\t  case $linkmode in\n\t  lib)\n\t    deplibs=\"$deplib $deplibs\"\n\t    test conv = \"$pass\" && continue\n\t    newdependency_libs=\"$deplib $newdependency_libs\"\n\t    func_stripname '-L' '' \"$deplib\"\n\t    func_resolve_sysroot \"$func_stripname_result\"\n\t    func_append newlib_search_path \" $func_resolve_sysroot_result\"\n\t    ;;\n\t  prog)\n\t    if test conv = \"$pass\"; then\n\t      deplibs=\"$deplib $deplibs\"\n\t      continue\n\t    fi\n\t    if test scan = \"$pass\"; then\n\t      deplibs=\"$deplib $deplibs\"\n\t    else\n\t      compile_deplibs=\"$deplib $compile_deplibs\"\n\t      finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t    fi\n\t    func_stripname '-L' '' \"$deplib\"\n\t    func_resolve_sysroot \"$func_stripname_result\"\n\t    func_append newlib_search_path \" $func_resolve_sysroot_result\"\n\t    ;;\n\t  *)\n\t    func_warning \"'-L' is ignored for archives/objects\"\n\t    ;;\n\t  esac # linkmode\n\t  continue\n\t  ;; # -L\n\t-R*)\n\t  if test link = \"$pass\"; then\n\t    func_stripname '-R' '' \"$deplib\"\n\t    func_resolve_sysroot \"$func_stripname_result\"\n\t    dir=$func_resolve_sysroot_result\n\t    # Make sure the xrpath contains only unique directories.\n\t    case \"$xrpath \" in\n\t    *\" $dir \"*) ;;\n\t    *) func_append xrpath \" $dir\" ;;\n\t    esac\n\t  fi\n\t  deplibs=\"$deplib $deplibs\"\n\t  continue\n\t  ;;\n\t*.la)\n\t  func_resolve_sysroot \"$deplib\"\n\t  lib=$func_resolve_sysroot_result\n\t  ;;\n\t*.$libext)\n\t  if test conv = \"$pass\"; then\n\t    deplibs=\"$deplib $deplibs\"\n\t    continue\n\t  fi\n\t  case $linkmode in\n\t  lib)\n\t    # Linking convenience modules into shared libraries is allowed,\n\t    # but linking other static libraries is non-portable.\n\t    case \" $dlpreconveniencelibs \" in\n\t    *\" $deplib \"*) ;;\n\t    *)\n\t      valid_a_lib=false\n\t      case $deplibs_check_method in\n\t\tmatch_pattern*)\n\t\t  set dummy $deplibs_check_method; shift\n\t\t  match_pattern_regex=`expr \"$deplibs_check_method\" : \"$1 \\(.*\\)\"`\n\t\t  if eval \"\\$ECHO \\\"$deplib\\\"\" 2>/dev/null | $SED 10q \\\n\t\t    | $EGREP \"$match_pattern_regex\" > /dev/null; then\n\t\t    valid_a_lib=:\n\t\t  fi\n\t\t;;\n\t\tpass_all)\n\t\t  valid_a_lib=:\n\t\t;;\n\t      esac\n\t      if $valid_a_lib; then\n\t\techo\n\t\t$ECHO \"*** Warning: Linking the shared library $output against the\"\n\t\t$ECHO \"*** static library $deplib is not portable!\"\n\t\tdeplibs=\"$deplib $deplibs\"\n\t      else\n\t\techo\n\t\t$ECHO \"*** Warning: Trying to link with static lib archive $deplib.\"\n\t\techo \"*** I have the capability to make that library automatically link in when\"\n\t\techo \"*** you link to this library.  But I can only do this if you have a\"\n\t\techo \"*** shared version of the library, which you do not appear to have\"\n\t\techo \"*** because the file extensions .$libext of this argument makes me believe\"\n\t\techo \"*** that it is just a static archive that I should not use here.\"\n\t      fi\n\t      ;;\n\t    esac\n\t    continue\n\t    ;;\n\t  prog)\n\t    if test link != \"$pass\"; then\n\t      deplibs=\"$deplib $deplibs\"\n\t    else\n\t      compile_deplibs=\"$deplib $compile_deplibs\"\n\t      finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t    fi\n\t    continue\n\t    ;;\n\t  esac # linkmode\n\t  ;; # *.$libext\n\t*.lo | *.$objext)\n\t  if test conv = \"$pass\"; then\n\t    deplibs=\"$deplib $deplibs\"\n\t  elif test prog = \"$linkmode\"; then\n\t    if test dlpreopen = \"$pass\" || test yes != \"$dlopen_support\" || test no = \"$build_libtool_libs\"; then\n\t      # If there is no dlopen support or we're linking statically,\n\t      # we need to preload.\n\t      func_append newdlprefiles \" $deplib\"\n\t      compile_deplibs=\"$deplib $compile_deplibs\"\n\t      finalize_deplibs=\"$deplib $finalize_deplibs\"\n\t    else\n\t      func_append newdlfiles \" $deplib\"\n\t    fi\n\t  fi\n\t  continue\n\t  ;;\n\t%DEPLIBS%)\n\t  alldeplibs=:\n\t  continue\n\t  ;;\n\tesac # case $deplib\n\n\t$found || test -f \"$lib\" \\\n\t  || func_fatal_error \"cannot find the library '$lib' or unhandled argument '$deplib'\"\n\n\t# Check to see that this really is a libtool archive.\n\tfunc_lalib_unsafe_p \"$lib\" \\\n\t  || func_fatal_error \"'$lib' is not a valid libtool archive\"\n\n\tfunc_dirname \"$lib\" \"\" \".\"\n\tladir=$func_dirname_result\n\n\tdlname=\n\tdlopen=\n\tdlpreopen=\n\tlibdir=\n\tlibrary_names=\n\told_library=\n\tinherited_linker_flags=\n\t# If the library was installed with an old release of libtool,\n\t# it will not redefine variables installed, or shouldnotlink\n\tinstalled=yes\n\tshouldnotlink=no\n\tavoidtemprpath=\n\n\n\t# Read the .la file\n\tfunc_source \"$lib\"\n\n\t# Convert \"-framework foo\" to \"foo.ltframework\"\n\tif test -n \"$inherited_linker_flags\"; then\n\t  tmp_inherited_linker_flags=`$ECHO \"$inherited_linker_flags\" | $SED 's/-framework \\([^ $]*\\)/\\1.ltframework/g'`\n\t  for tmp_inherited_linker_flag in $tmp_inherited_linker_flags; do\n\t    case \" $new_inherited_linker_flags \" in\n\t      *\" $tmp_inherited_linker_flag \"*) ;;\n\t      *) func_append new_inherited_linker_flags \" $tmp_inherited_linker_flag\";;\n\t    esac\n\t  done\n\tfi\n\tdependency_libs=`$ECHO \" $dependency_libs\" | $SED 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\tif test lib,link = \"$linkmode,$pass\" ||\n\t   test prog,scan = \"$linkmode,$pass\" ||\n\t   { test prog != \"$linkmode\" && test lib != \"$linkmode\"; }; then\n\t  test -n \"$dlopen\" && func_append dlfiles \" $dlopen\"\n\t  test -n \"$dlpreopen\" && func_append dlprefiles \" $dlpreopen\"\n\tfi\n\n\tif test conv = \"$pass\"; then\n\t  # Only check for convenience libraries\n\t  deplibs=\"$lib $deplibs\"\n\t  if test -z \"$libdir\"; then\n\t    if test -z \"$old_library\"; then\n\t      func_fatal_error \"cannot find name of link library for '$lib'\"\n\t    fi\n\t    # It is a libtool convenience library, so add in its objects.\n\t    func_append convenience \" $ladir/$objdir/$old_library\"\n\t    func_append old_convenience \" $ladir/$objdir/$old_library\"\n\t  elif test prog != \"$linkmode\" && test lib != \"$linkmode\"; then\n\t    func_fatal_error \"'$lib' is not a convenience library\"\n\t  fi\n\t  tmp_libs=\n\t  for deplib in $dependency_libs; do\n\t    deplibs=\"$deplib $deplibs\"\n\t    if $opt_preserve_dup_deps; then\n\t      case \"$tmp_libs \" in\n\t      *\" $deplib \"*) func_append specialdeplibs \" $deplib\" ;;\n\t      esac\n\t    fi\n\t    func_append tmp_libs \" $deplib\"\n\t  done\n\t  continue\n\tfi # $pass = conv\n\n\n\t# Get the name of the library we link against.\n\tlinklib=\n\tif test -n \"$old_library\" &&\n\t   { test yes = \"$prefer_static_libs\" ||\n\t     test built,no = \"$prefer_static_libs,$installed\"; }; then\n\t  linklib=$old_library\n\telse\n\t  for l in $old_library $library_names; do\n\t    linklib=$l\n\t  done\n\tfi\n\tif test -z \"$linklib\"; then\n\t  func_fatal_error \"cannot find name of link library for '$lib'\"\n\tfi\n\n\t# This library was specified with -dlopen.\n\tif test dlopen = \"$pass\"; then\n\t  test -z \"$libdir\" \\\n\t    && func_fatal_error \"cannot -dlopen a convenience library: '$lib'\"\n\t  if test -z \"$dlname\" ||\n\t     test yes != \"$dlopen_support\" ||\n\t     test no = \"$build_libtool_libs\"\n\t  then\n\t    # If there is no dlname, no dlopen support or we're linking\n\t    # statically, we need to preload.  We also need to preload any\n\t    # dependent libraries so libltdl's deplib preloader doesn't\n\t    # bomb out in the load deplibs phase.\n\t    func_append dlprefiles \" $lib $dependency_libs\"\n\t  else\n\t    func_append newdlfiles \" $lib\"\n\t  fi\n\t  continue\n\tfi # $pass = dlopen\n\n\t# We need an absolute path.\n\tcase $ladir in\n\t[\\\\/]* | [A-Za-z]:[\\\\/]*) abs_ladir=$ladir ;;\n\t*)\n\t  abs_ladir=`cd \"$ladir\" && pwd`\n\t  if test -z \"$abs_ladir\"; then\n\t    func_warning \"cannot determine absolute directory name of '$ladir'\"\n\t    func_warning \"passing it literally to the linker, although it might fail\"\n\t    abs_ladir=$ladir\n\t  fi\n\t  ;;\n\tesac\n\tfunc_basename \"$lib\"\n\tlaname=$func_basename_result\n\n\t# Find the relevant object directory and library name.\n\tif test yes = \"$installed\"; then\n\t  if test ! -f \"$lt_sysroot$libdir/$linklib\" && test -f \"$abs_ladir/$linklib\"; then\n\t    func_warning \"library '$lib' was moved.\"\n\t    dir=$ladir\n\t    absdir=$abs_ladir\n\t    libdir=$abs_ladir\n\t  else\n\t    dir=$lt_sysroot$libdir\n\t    absdir=$lt_sysroot$libdir\n\t  fi\n\t  test yes = \"$hardcode_automatic\" && avoidtemprpath=yes\n\telse\n\t  if test ! -f \"$ladir/$objdir/$linklib\" && test -f \"$abs_ladir/$linklib\"; then\n\t    dir=$ladir\n\t    absdir=$abs_ladir\n\t    # Remove this search path later\n\t    func_append notinst_path \" $abs_ladir\"\n\t  else\n\t    dir=$ladir/$objdir\n\t    absdir=$abs_ladir/$objdir\n\t    # Remove this search path later\n\t    func_append notinst_path \" $abs_ladir\"\n\t  fi\n\tfi # $installed = yes\n\tfunc_stripname 'lib' '.la' \"$laname\"\n\tname=$func_stripname_result\n\n\t# This library was specified with -dlpreopen.\n\tif test dlpreopen = \"$pass\"; then\n\t  if test -z \"$libdir\" && test prog = \"$linkmode\"; then\n\t    func_fatal_error \"only libraries may -dlpreopen a convenience library: '$lib'\"\n\t  fi\n\t  case $host in\n\t    # special handling for platforms with PE-DLLs.\n\t    *cygwin* | *mingw* | *cegcc* )\n\t      # Linker will automatically link against shared library if both\n\t      # static and shared are present.  Therefore, ensure we extract\n\t      # symbols from the import library if a shared library is present\n\t      # (otherwise, the dlopen module name will be incorrect).  We do\n\t      # this by putting the import library name into $newdlprefiles.\n\t      # We recover the dlopen module name by 'saving' the la file\n\t      # name in a special purpose variable, and (later) extracting the\n\t      # dlname from the la file.\n\t      if test -n \"$dlname\"; then\n\t        func_tr_sh \"$dir/$linklib\"\n\t        eval \"libfile_$func_tr_sh_result=\\$abs_ladir/\\$laname\"\n\t        func_append newdlprefiles \" $dir/$linklib\"\n\t      else\n\t        func_append newdlprefiles \" $dir/$old_library\"\n\t        # Keep a list of preopened convenience libraries to check\n\t        # that they are being used correctly in the link pass.\n\t        test -z \"$libdir\" && \\\n\t          func_append dlpreconveniencelibs \" $dir/$old_library\"\n\t      fi\n\t    ;;\n\t    * )\n\t      # Prefer using a static library (so that no silly _DYNAMIC symbols\n\t      # are required to link).\n\t      if test -n \"$old_library\"; then\n\t        func_append newdlprefiles \" $dir/$old_library\"\n\t        # Keep a list of preopened convenience libraries to check\n\t        # that they are being used correctly in the link pass.\n\t        test -z \"$libdir\" && \\\n\t          func_append dlpreconveniencelibs \" $dir/$old_library\"\n\t      # Otherwise, use the dlname, so that lt_dlopen finds it.\n\t      elif test -n \"$dlname\"; then\n\t        func_append newdlprefiles \" $dir/$dlname\"\n\t      else\n\t        func_append newdlprefiles \" $dir/$linklib\"\n\t      fi\n\t    ;;\n\t  esac\n\tfi # $pass = dlpreopen\n\n\tif test -z \"$libdir\"; then\n\t  # Link the convenience library\n\t  if test lib = \"$linkmode\"; then\n\t    deplibs=\"$dir/$old_library $deplibs\"\n\t  elif test prog,link = \"$linkmode,$pass\"; then\n\t    compile_deplibs=\"$dir/$old_library $compile_deplibs\"\n\t    finalize_deplibs=\"$dir/$old_library $finalize_deplibs\"\n\t  else\n\t    deplibs=\"$lib $deplibs\" # used for prog,scan pass\n\t  fi\n\t  continue\n\tfi\n\n\n\tif test prog = \"$linkmode\" && test link != \"$pass\"; then\n\t  func_append newlib_search_path \" $ladir\"\n\t  deplibs=\"$lib $deplibs\"\n\n\t  linkalldeplibs=false\n\t  if test no != \"$link_all_deplibs\" || test -z \"$library_names\" ||\n\t     test no = \"$build_libtool_libs\"; then\n\t    linkalldeplibs=:\n\t  fi\n\n\t  tmp_libs=\n\t  for deplib in $dependency_libs; do\n\t    case $deplib in\n\t    -L*) func_stripname '-L' '' \"$deplib\"\n\t         func_resolve_sysroot \"$func_stripname_result\"\n\t         func_append newlib_search_path \" $func_resolve_sysroot_result\"\n\t\t ;;\n\t    esac\n\t    # Need to link against all dependency_libs?\n\t    if $linkalldeplibs; then\n\t      deplibs=\"$deplib $deplibs\"\n\t    else\n\t      # Need to hardcode shared library paths\n\t      # or/and link against static libraries\n\t      newdependency_libs=\"$deplib $newdependency_libs\"\n\t    fi\n\t    if $opt_preserve_dup_deps; then\n\t      case \"$tmp_libs \" in\n\t      *\" $deplib \"*) func_append specialdeplibs \" $deplib\" ;;\n\t      esac\n\t    fi\n\t    func_append tmp_libs \" $deplib\"\n\t  done # for deplib\n\t  continue\n\tfi # $linkmode = prog...\n\n\tif test prog,link = \"$linkmode,$pass\"; then\n\t  if test -n \"$library_names\" &&\n\t     { { test no = \"$prefer_static_libs\" ||\n\t         test built,yes = \"$prefer_static_libs,$installed\"; } ||\n\t       test -z \"$old_library\"; }; then\n\t    # We need to hardcode the library path\n\t    if test -n \"$shlibpath_var\" && test -z \"$avoidtemprpath\"; then\n\t      # Make sure the rpath contains only unique directories.\n\t      case $temp_rpath: in\n\t      *\"$absdir:\"*) ;;\n\t      *) func_append temp_rpath \"$absdir:\" ;;\n\t      esac\n\t    fi\n\n\t    # Hardcode the library path.\n\t    # Skip directories that are in the system default run-time\n\t    # search path.\n\t    case \" $sys_lib_dlsearch_path \" in\n\t    *\" $absdir \"*) ;;\n\t    *)\n\t      case \"$compile_rpath \" in\n\t      *\" $absdir \"*) ;;\n\t      *) func_append compile_rpath \" $absdir\" ;;\n\t      esac\n\t      ;;\n\t    esac\n\t    case \" $sys_lib_dlsearch_path \" in\n\t    *\" $libdir \"*) ;;\n\t    *)\n\t      case \"$finalize_rpath \" in\n\t      *\" $libdir \"*) ;;\n\t      *) func_append finalize_rpath \" $libdir\" ;;\n\t      esac\n\t      ;;\n\t    esac\n\t  fi # $linkmode,$pass = prog,link...\n\n\t  if $alldeplibs &&\n\t     { test pass_all = \"$deplibs_check_method\" ||\n\t       { test yes = \"$build_libtool_libs\" &&\n\t\t test -n \"$library_names\"; }; }; then\n\t    # We only need to search for static libraries\n\t    continue\n\t  fi\n\tfi\n\n\tlink_static=no # Whether the deplib will be linked statically\n\tuse_static_libs=$prefer_static_libs\n\tif test built = \"$use_static_libs\" && test yes = \"$installed\"; then\n\t  use_static_libs=no\n\tfi\n\tif test -n \"$library_names\" &&\n\t   { test no = \"$use_static_libs\" || test -z \"$old_library\"; }; then\n\t  case $host in\n\t  *cygwin* | *mingw* | *cegcc* | *os2*)\n\t      # No point in relinking DLLs because paths are not encoded\n\t      func_append notinst_deplibs \" $lib\"\n\t      need_relink=no\n\t    ;;\n\t  *)\n\t    if test no = \"$installed\"; then\n\t      func_append notinst_deplibs \" $lib\"\n\t      need_relink=yes\n\t    fi\n\t    ;;\n\t  esac\n\t  # This is a shared library\n\n\t  # Warn about portability, can't link against -module's on some\n\t  # systems (darwin).  Don't bleat about dlopened modules though!\n\t  dlopenmodule=\n\t  for dlpremoduletest in $dlprefiles; do\n\t    if test \"X$dlpremoduletest\" = \"X$lib\"; then\n\t      dlopenmodule=$dlpremoduletest\n\t      break\n\t    fi\n\t  done\n\t  if test -z \"$dlopenmodule\" && test yes = \"$shouldnotlink\" && test link = \"$pass\"; then\n\t    echo\n\t    if test prog = \"$linkmode\"; then\n\t      $ECHO \"*** Warning: Linking the executable $output against the loadable module\"\n\t    else\n\t      $ECHO \"*** Warning: Linking the shared library $output against the loadable module\"\n\t    fi\n\t    $ECHO \"*** $linklib is not portable!\"\n\t  fi\n\t  if test lib = \"$linkmode\" &&\n\t     test yes = \"$hardcode_into_libs\"; then\n\t    # Hardcode the library path.\n\t    # Skip directories that are in the system default run-time\n\t    # search path.\n\t    case \" $sys_lib_dlsearch_path \" in\n\t    *\" $absdir \"*) ;;\n\t    *)\n\t      case \"$compile_rpath \" in\n\t      *\" $absdir \"*) ;;\n\t      *) func_append compile_rpath \" $absdir\" ;;\n\t      esac\n\t      ;;\n\t    esac\n\t    case \" $sys_lib_dlsearch_path \" in\n\t    *\" $libdir \"*) ;;\n\t    *)\n\t      case \"$finalize_rpath \" in\n\t      *\" $libdir \"*) ;;\n\t      *) func_append finalize_rpath \" $libdir\" ;;\n\t      esac\n\t      ;;\n\t    esac\n\t  fi\n\n\t  if test -n \"$old_archive_from_expsyms_cmds\"; then\n\t    # figure out the soname\n\t    set dummy $library_names\n\t    shift\n\t    realname=$1\n\t    shift\n\t    libname=`eval \"\\\\$ECHO \\\"$libname_spec\\\"\"`\n\t    # use dlname if we got it. it's perfectly good, no?\n\t    if test -n \"$dlname\"; then\n\t      soname=$dlname\n\t    elif test -n \"$soname_spec\"; then\n\t      # bleh windows\n\t      case $host in\n\t      *cygwin* | mingw* | *cegcc* | *os2*)\n\t        func_arith $current - $age\n\t\tmajor=$func_arith_result\n\t\tversuffix=-$major\n\t\t;;\n\t      esac\n\t      eval soname=\\\"$soname_spec\\\"\n\t    else\n\t      soname=$realname\n\t    fi\n\n\t    # Make a new name for the extract_expsyms_cmds to use\n\t    soroot=$soname\n\t    func_basename \"$soroot\"\n\t    soname=$func_basename_result\n\t    func_stripname 'lib' '.dll' \"$soname\"\n\t    newlib=libimp-$func_stripname_result.a\n\n\t    # If the library has no export list, then create one now\n\t    if test -f \"$output_objdir/$soname-def\"; then :\n\t    else\n\t      func_verbose \"extracting exported symbol list from '$soname'\"\n\t      func_execute_cmds \"$extract_expsyms_cmds\" 'exit $?'\n\t    fi\n\n\t    # Create $newlib\n\t    if test -f \"$output_objdir/$newlib\"; then :; else\n\t      func_verbose \"generating import library for '$soname'\"\n\t      func_execute_cmds \"$old_archive_from_expsyms_cmds\" 'exit $?'\n\t    fi\n\t    # make sure the library variables are pointing to the new library\n\t    dir=$output_objdir\n\t    linklib=$newlib\n\t  fi # test -n \"$old_archive_from_expsyms_cmds\"\n\n\t  if test prog = \"$linkmode\" || test relink != \"$opt_mode\"; then\n\t    add_shlibpath=\n\t    add_dir=\n\t    add=\n\t    lib_linked=yes\n\t    case $hardcode_action in\n\t    immediate | unsupported)\n\t      if test no = \"$hardcode_direct\"; then\n\t\tadd=$dir/$linklib\n\t\tcase $host in\n\t\t  *-*-sco3.2v5.0.[024]*) add_dir=-L$dir ;;\n\t\t  *-*-sysv4*uw2*) add_dir=-L$dir ;;\n\t\t  *-*-sysv5OpenUNIX* | *-*-sysv5UnixWare7.[01].[10]* | \\\n\t\t    *-*-unixware7*) add_dir=-L$dir ;;\n\t\t  *-*-darwin* )\n\t\t    # if the lib is a (non-dlopened) module then we cannot\n\t\t    # link against it, someone is ignoring the earlier warnings\n\t\t    if /usr/bin/file -L $add 2> /dev/null |\n\t\t\t $GREP \": [^:]* bundle\" >/dev/null; then\n\t\t      if test \"X$dlopenmodule\" != \"X$lib\"; then\n\t\t\t$ECHO \"*** Warning: lib $linklib is a module, not a shared library\"\n\t\t\tif test -z \"$old_library\"; then\n\t\t\t  echo\n\t\t\t  echo \"*** And there doesn't seem to be a static archive available\"\n\t\t\t  echo \"*** The link will probably fail, sorry\"\n\t\t\telse\n\t\t\t  add=$dir/$old_library\n\t\t\tfi\n\t\t      elif test -n \"$old_library\"; then\n\t\t\tadd=$dir/$old_library\n\t\t      fi\n\t\t    fi\n\t\tesac\n\t      elif test no = \"$hardcode_minus_L\"; then\n\t\tcase $host in\n\t\t*-*-sunos*) add_shlibpath=$dir ;;\n\t\tesac\n\t\tadd_dir=-L$dir\n\t\tadd=-l$name\n\t      elif test no = \"$hardcode_shlibpath_var\"; then\n\t\tadd_shlibpath=$dir\n\t\tadd=-l$name\n\t      else\n\t\tlib_linked=no\n\t      fi\n\t      ;;\n\t    relink)\n\t      if test yes = \"$hardcode_direct\" &&\n\t         test no = \"$hardcode_direct_absolute\"; then\n\t\tadd=$dir/$linklib\n\t      elif test yes = \"$hardcode_minus_L\"; then\n\t\tadd_dir=-L$absdir\n\t\t# Try looking first in the location we're being installed to.\n\t\tif test -n \"$inst_prefix_dir\"; then\n\t\t  case $libdir in\n\t\t    [\\\\/]*)\n\t\t      func_append add_dir \" -L$inst_prefix_dir$libdir\"\n\t\t      ;;\n\t\t  esac\n\t\tfi\n\t\tadd=-l$name\n\t      elif test yes = \"$hardcode_shlibpath_var\"; then\n\t\tadd_shlibpath=$dir\n\t\tadd=-l$name\n\t      else\n\t\tlib_linked=no\n\t      fi\n\t      ;;\n\t    *) lib_linked=no ;;\n\t    esac\n\n\t    if test yes != \"$lib_linked\"; then\n\t      func_fatal_configuration \"unsupported hardcode properties\"\n\t    fi\n\n\t    if test -n \"$add_shlibpath\"; then\n\t      case :$compile_shlibpath: in\n\t      *\":$add_shlibpath:\"*) ;;\n\t      *) func_append compile_shlibpath \"$add_shlibpath:\" ;;\n\t      esac\n\t    fi\n\t    if test prog = \"$linkmode\"; then\n\t      test -n \"$add_dir\" && compile_deplibs=\"$add_dir $compile_deplibs\"\n\t      test -n \"$add\" && compile_deplibs=\"$add $compile_deplibs\"\n\t    else\n\t      test -n \"$add_dir\" && deplibs=\"$add_dir $deplibs\"\n\t      test -n \"$add\" && deplibs=\"$add $deplibs\"\n\t      if test yes != \"$hardcode_direct\" &&\n\t\t test yes != \"$hardcode_minus_L\" &&\n\t\t test yes = \"$hardcode_shlibpath_var\"; then\n\t\tcase :$finalize_shlibpath: in\n\t\t*\":$libdir:\"*) ;;\n\t\t*) func_append finalize_shlibpath \"$libdir:\" ;;\n\t\tesac\n\t      fi\n\t    fi\n\t  fi\n\n\t  if test prog = \"$linkmode\" || test relink = \"$opt_mode\"; then\n\t    add_shlibpath=\n\t    add_dir=\n\t    add=\n\t    # Finalize command for both is simple: just hardcode it.\n\t    if test yes = \"$hardcode_direct\" &&\n\t       test no = \"$hardcode_direct_absolute\"; then\n\t      add=$libdir/$linklib\n\t    elif test yes = \"$hardcode_minus_L\"; then\n\t      add_dir=-L$libdir\n\t      add=-l$name\n\t    elif test yes = \"$hardcode_shlibpath_var\"; then\n\t      case :$finalize_shlibpath: in\n\t      *\":$libdir:\"*) ;;\n\t      *) func_append finalize_shlibpath \"$libdir:\" ;;\n\t      esac\n\t      add=-l$name\n\t    elif test yes = \"$hardcode_automatic\"; then\n\t      if test -n \"$inst_prefix_dir\" &&\n\t\t test -f \"$inst_prefix_dir$libdir/$linklib\"; then\n\t\tadd=$inst_prefix_dir$libdir/$linklib\n\t      else\n\t\tadd=$libdir/$linklib\n\t      fi\n\t    else\n\t      # We cannot seem to hardcode it, guess we'll fake it.\n\t      add_dir=-L$libdir\n\t      # Try looking first in the location we're being installed to.\n\t      if test -n \"$inst_prefix_dir\"; then\n\t\tcase $libdir in\n\t\t  [\\\\/]*)\n\t\t    func_append add_dir \" -L$inst_prefix_dir$libdir\"\n\t\t    ;;\n\t\tesac\n\t      fi\n\t      add=-l$name\n\t    fi\n\n\t    if test prog = \"$linkmode\"; then\n\t      test -n \"$add_dir\" && finalize_deplibs=\"$add_dir $finalize_deplibs\"\n\t      test -n \"$add\" && finalize_deplibs=\"$add $finalize_deplibs\"\n\t    else\n\t      test -n \"$add_dir\" && deplibs=\"$add_dir $deplibs\"\n\t      test -n \"$add\" && deplibs=\"$add $deplibs\"\n\t    fi\n\t  fi\n\telif test prog = \"$linkmode\"; then\n\t  # Here we assume that one of hardcode_direct or hardcode_minus_L\n\t  # is not unsupported.  This is valid on all known static and\n\t  # shared platforms.\n\t  if test unsupported != \"$hardcode_direct\"; then\n\t    test -n \"$old_library\" && linklib=$old_library\n\t    compile_deplibs=\"$dir/$linklib $compile_deplibs\"\n\t    finalize_deplibs=\"$dir/$linklib $finalize_deplibs\"\n\t  else\n\t    compile_deplibs=\"-l$name -L$dir $compile_deplibs\"\n\t    finalize_deplibs=\"-l$name -L$dir $finalize_deplibs\"\n\t  fi\n\telif test yes = \"$build_libtool_libs\"; then\n\t  # Not a shared library\n\t  if test pass_all != \"$deplibs_check_method\"; then\n\t    # We're trying link a shared library against a static one\n\t    # but the system doesn't support it.\n\n\t    # Just print a warning and add the library to dependency_libs so\n\t    # that the program can be linked against the static library.\n\t    echo\n\t    $ECHO \"*** Warning: This system cannot link to static lib archive $lib.\"\n\t    echo \"*** I have the capability to make that library automatically link in when\"\n\t    echo \"*** you link to this library.  But I can only do this if you have a\"\n\t    echo \"*** shared version of the library, which you do not appear to have.\"\n\t    if test yes = \"$module\"; then\n\t      echo \"*** But as you try to build a module library, libtool will still create \"\n\t      echo \"*** a static module, that should work as long as the dlopening application\"\n\t      echo \"*** is linked with the -dlopen flag to resolve symbols at runtime.\"\n\t      if test -z \"$global_symbol_pipe\"; then\n\t\techo\n\t\techo \"*** However, this would only work if libtool was able to extract symbol\"\n\t\techo \"*** lists from a program, using 'nm' or equivalent, but libtool could\"\n\t\techo \"*** not find such a program.  So, this module is probably useless.\"\n\t\techo \"*** 'nm' from GNU binutils and a full rebuild may help.\"\n\t      fi\n\t      if test no = \"$build_old_libs\"; then\n\t\tbuild_libtool_libs=module\n\t\tbuild_old_libs=yes\n\t      else\n\t\tbuild_libtool_libs=no\n\t      fi\n\t    fi\n\t  else\n\t    deplibs=\"$dir/$old_library $deplibs\"\n\t    link_static=yes\n\t  fi\n\tfi # link shared/static library?\n\n\tif test lib = \"$linkmode\"; then\n\t  if test -n \"$dependency_libs\" &&\n\t     { test yes != \"$hardcode_into_libs\" ||\n\t       test yes = \"$build_old_libs\" ||\n\t       test yes = \"$link_static\"; }; then\n\t    # Extract -R from dependency_libs\n\t    temp_deplibs=\n\t    for libdir in $dependency_libs; do\n\t      case $libdir in\n\t      -R*) func_stripname '-R' '' \"$libdir\"\n\t           temp_xrpath=$func_stripname_result\n\t\t   case \" $xrpath \" in\n\t\t   *\" $temp_xrpath \"*) ;;\n\t\t   *) func_append xrpath \" $temp_xrpath\";;\n\t\t   esac;;\n\t      *) func_append temp_deplibs \" $libdir\";;\n\t      esac\n\t    done\n\t    dependency_libs=$temp_deplibs\n\t  fi\n\n\t  func_append newlib_search_path \" $absdir\"\n\t  # Link against this library\n\t  test no = \"$link_static\" && newdependency_libs=\"$abs_ladir/$laname $newdependency_libs\"\n\t  # ... and its dependency_libs\n\t  tmp_libs=\n\t  for deplib in $dependency_libs; do\n\t    newdependency_libs=\"$deplib $newdependency_libs\"\n\t    case $deplib in\n              -L*) func_stripname '-L' '' \"$deplib\"\n                   func_resolve_sysroot \"$func_stripname_result\";;\n              *) func_resolve_sysroot \"$deplib\" ;;\n            esac\n\t    if $opt_preserve_dup_deps; then\n\t      case \"$tmp_libs \" in\n\t      *\" $func_resolve_sysroot_result \"*)\n                func_append specialdeplibs \" $func_resolve_sysroot_result\" ;;\n\t      esac\n\t    fi\n\t    func_append tmp_libs \" $func_resolve_sysroot_result\"\n\t  done\n\n\t  if test no != \"$link_all_deplibs\"; then\n\t    # Add the search paths of all dependency libraries\n\t    for deplib in $dependency_libs; do\n\t      path=\n\t      case $deplib in\n\t      -L*) path=$deplib ;;\n\t      *.la)\n\t        func_resolve_sysroot \"$deplib\"\n\t        deplib=$func_resolve_sysroot_result\n\t        func_dirname \"$deplib\" \"\" \".\"\n\t\tdir=$func_dirname_result\n\t\t# We need an absolute path.\n\t\tcase $dir in\n\t\t[\\\\/]* | [A-Za-z]:[\\\\/]*) absdir=$dir ;;\n\t\t*)\n\t\t  absdir=`cd \"$dir\" && pwd`\n\t\t  if test -z \"$absdir\"; then\n\t\t    func_warning \"cannot determine absolute directory name of '$dir'\"\n\t\t    absdir=$dir\n\t\t  fi\n\t\t  ;;\n\t\tesac\n\t\tif $GREP \"^installed=no\" $deplib > /dev/null; then\n\t\tcase $host in\n\t\t*-*-darwin*)\n\t\t  depdepl=\n\t\t  eval deplibrary_names=`$SED -n -e 's/^library_names=\\(.*\\)$/\\1/p' $deplib`\n\t\t  if test -n \"$deplibrary_names\"; then\n\t\t    for tmp in $deplibrary_names; do\n\t\t      depdepl=$tmp\n\t\t    done\n\t\t    if test -f \"$absdir/$objdir/$depdepl\"; then\n\t\t      depdepl=$absdir/$objdir/$depdepl\n\t\t      darwin_install_name=`$OTOOL -L $depdepl | awk '{if (NR == 2) {print $1;exit}}'`\n                      if test -z \"$darwin_install_name\"; then\n                          darwin_install_name=`$OTOOL64 -L $depdepl  | awk '{if (NR == 2) {print $1;exit}}'`\n                      fi\n\t\t      func_append compiler_flags \" $wl-dylib_file $wl$darwin_install_name:$depdepl\"\n\t\t      func_append linker_flags \" -dylib_file $darwin_install_name:$depdepl\"\n\t\t      path=\n\t\t    fi\n\t\t  fi\n\t\t  ;;\n\t\t*)\n\t\t  path=-L$absdir/$objdir\n\t\t  ;;\n\t\tesac\n\t\telse\n\t\t  eval libdir=`$SED -n -e 's/^libdir=\\(.*\\)$/\\1/p' $deplib`\n\t\t  test -z \"$libdir\" && \\\n\t\t    func_fatal_error \"'$deplib' is not a valid libtool archive\"\n\t\t  test \"$absdir\" != \"$libdir\" && \\\n\t\t    func_warning \"'$deplib' seems to be moved\"\n\n\t\t  path=-L$absdir\n\t\tfi\n\t\t;;\n\t      esac\n\t      case \" $deplibs \" in\n\t      *\" $path \"*) ;;\n\t      *) deplibs=\"$path $deplibs\" ;;\n\t      esac\n\t    done\n\t  fi # link_all_deplibs != no\n\tfi # linkmode = lib\n      done # for deplib in $libs\n      if test link = \"$pass\"; then\n\tif test prog = \"$linkmode\"; then\n\t  compile_deplibs=\"$new_inherited_linker_flags $compile_deplibs\"\n\t  finalize_deplibs=\"$new_inherited_linker_flags $finalize_deplibs\"\n\telse\n\t  compiler_flags=\"$compiler_flags \"`$ECHO \" $new_inherited_linker_flags\" | $SED 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\tfi\n      fi\n      dependency_libs=$newdependency_libs\n      if test dlpreopen = \"$pass\"; then\n\t# Link the dlpreopened libraries before other libraries\n\tfor deplib in $save_deplibs; do\n\t  deplibs=\"$deplib $deplibs\"\n\tdone\n      fi\n      if test dlopen != \"$pass\"; then\n\ttest conv = \"$pass\" || {\n\t  # Make sure lib_search_path contains only unique directories.\n\t  lib_search_path=\n\t  for dir in $newlib_search_path; do\n\t    case \"$lib_search_path \" in\n\t    *\" $dir \"*) ;;\n\t    *) func_append lib_search_path \" $dir\" ;;\n\t    esac\n\t  done\n\t  newlib_search_path=\n\t}\n\n\tif test prog,link = \"$linkmode,$pass\"; then\n\t  vars=\"compile_deplibs finalize_deplibs\"\n\telse\n\t  vars=deplibs\n\tfi\n\tfor var in $vars dependency_libs; do\n\t  # Add libraries to $var in reverse order\n\t  eval tmp_libs=\\\"\\$$var\\\"\n\t  new_libs=\n\t  for deplib in $tmp_libs; do\n\t    # FIXME: Pedantically, this is the right thing to do, so\n\t    #        that some nasty dependency loop isn't accidentally\n\t    #        broken:\n\t    #new_libs=\"$deplib $new_libs\"\n\t    # Pragmatically, this seems to cause very few problems in\n\t    # practice:\n\t    case $deplib in\n\t    -L*) new_libs=\"$deplib $new_libs\" ;;\n\t    -R*) ;;\n\t    *)\n\t      # And here is the reason: when a library appears more\n\t      # than once as an explicit dependence of a library, or\n\t      # is implicitly linked in more than once by the\n\t      # compiler, it is considered special, and multiple\n\t      # occurrences thereof are not removed.  Compare this\n\t      # with having the same library being listed as a\n\t      # dependency of multiple other libraries: in this case,\n\t      # we know (pedantically, we assume) the library does not\n\t      # need to be listed more than once, so we keep only the\n\t      # last copy.  This is not always right, but it is rare\n\t      # enough that we require users that really mean to play\n\t      # such unportable linking tricks to link the library\n\t      # using -Wl,-lname, so that libtool does not consider it\n\t      # for duplicate removal.\n\t      case \" $specialdeplibs \" in\n\t      *\" $deplib \"*) new_libs=\"$deplib $new_libs\" ;;\n\t      *)\n\t\tcase \" $new_libs \" in\n\t\t*\" $deplib \"*) ;;\n\t\t*) new_libs=\"$deplib $new_libs\" ;;\n\t\tesac\n\t\t;;\n\t      esac\n\t      ;;\n\t    esac\n\t  done\n\t  tmp_libs=\n\t  for deplib in $new_libs; do\n\t    case $deplib in\n\t    -L*)\n\t      case \" $tmp_libs \" in\n\t      *\" $deplib \"*) ;;\n\t      *) func_append tmp_libs \" $deplib\" ;;\n\t      esac\n\t      ;;\n\t    *) func_append tmp_libs \" $deplib\" ;;\n\t    esac\n\t  done\n\t  eval $var=\\\"$tmp_libs\\\"\n\tdone # for var\n      fi\n\n      # Add Sun CC postdeps if required:\n      test CXX = \"$tagname\" && {\n        case $host_os in\n        linux*)\n          case `$CC -V 2>&1 | sed 5q` in\n          *Sun\\ C*) # Sun C++ 5.9\n            func_suncc_cstd_abi\n\n            if test no != \"$suncc_use_cstd_abi\"; then\n              func_append postdeps ' -library=Cstd -library=Crun'\n            fi\n            ;;\n          esac\n          ;;\n\n        solaris*)\n          func_cc_basename \"$CC\"\n          case $func_cc_basename_result in\n          CC* | sunCC*)\n            func_suncc_cstd_abi\n\n            if test no != \"$suncc_use_cstd_abi\"; then\n              func_append postdeps ' -library=Cstd -library=Crun'\n            fi\n            ;;\n          esac\n          ;;\n        esac\n      }\n\n      # Last step: remove runtime libs from dependency_libs\n      # (they stay in deplibs)\n      tmp_libs=\n      for i in $dependency_libs; do\n\tcase \" $predeps $postdeps $compiler_lib_search_path \" in\n\t*\" $i \"*)\n\t  i=\n\t  ;;\n\tesac\n\tif test -n \"$i\"; then\n\t  func_append tmp_libs \" $i\"\n\tfi\n      done\n      dependency_libs=$tmp_libs\n    done # for pass\n    if test prog = \"$linkmode\"; then\n      dlfiles=$newdlfiles\n    fi\n    if test prog = \"$linkmode\" || test lib = \"$linkmode\"; then\n      dlprefiles=$newdlprefiles\n    fi\n\n    case $linkmode in\n    oldlib)\n      if test -n \"$dlfiles$dlprefiles\" || test no != \"$dlself\"; then\n\tfunc_warning \"'-dlopen' is ignored for archives\"\n      fi\n\n      case \" $deplibs\" in\n      *\\ -l* | *\\ -L*)\n\tfunc_warning \"'-l' and '-L' are ignored for archives\" ;;\n      esac\n\n      test -n \"$rpath\" && \\\n\tfunc_warning \"'-rpath' is ignored for archives\"\n\n      test -n \"$xrpath\" && \\\n\tfunc_warning \"'-R' is ignored for archives\"\n\n      test -n \"$vinfo\" && \\\n\tfunc_warning \"'-version-info/-version-number' is ignored for archives\"\n\n      test -n \"$release\" && \\\n\tfunc_warning \"'-release' is ignored for archives\"\n\n      test -n \"$export_symbols$export_symbols_regex\" && \\\n\tfunc_warning \"'-export-symbols' is ignored for archives\"\n\n      # Now set the variables for building old libraries.\n      build_libtool_libs=no\n      oldlibs=$output\n      func_append objs \"$old_deplibs\"\n      ;;\n\n    lib)\n      # Make sure we only generate libraries of the form 'libNAME.la'.\n      case $outputname in\n      lib*)\n\tfunc_stripname 'lib' '.la' \"$outputname\"\n\tname=$func_stripname_result\n\teval shared_ext=\\\"$shrext_cmds\\\"\n\teval libname=\\\"$libname_spec\\\"\n\t;;\n      *)\n\ttest no = \"$module\" \\\n\t  && func_fatal_help \"libtool library '$output' must begin with 'lib'\"\n\n\tif test no != \"$need_lib_prefix\"; then\n\t  # Add the \"lib\" prefix for modules if required\n\t  func_stripname '' '.la' \"$outputname\"\n\t  name=$func_stripname_result\n\t  eval shared_ext=\\\"$shrext_cmds\\\"\n\t  eval libname=\\\"$libname_spec\\\"\n\telse\n\t  func_stripname '' '.la' \"$outputname\"\n\t  libname=$func_stripname_result\n\tfi\n\t;;\n      esac\n\n      if test -n \"$objs\"; then\n\tif test pass_all != \"$deplibs_check_method\"; then\n\t  func_fatal_error \"cannot build libtool library '$output' from non-libtool objects on this host:$objs\"\n\telse\n\t  echo\n\t  $ECHO \"*** Warning: Linking the shared library $output against the non-libtool\"\n\t  $ECHO \"*** objects $objs is not portable!\"\n\t  func_append libobjs \" $objs\"\n\tfi\n      fi\n\n      test no = \"$dlself\" \\\n\t|| func_warning \"'-dlopen self' is ignored for libtool libraries\"\n\n      set dummy $rpath\n      shift\n      test 1 -lt \"$#\" \\\n\t&& func_warning \"ignoring multiple '-rpath's for a libtool library\"\n\n      install_libdir=$1\n\n      oldlibs=\n      if test -z \"$rpath\"; then\n\tif test yes = \"$build_libtool_libs\"; then\n\t  # Building a libtool convenience library.\n\t  # Some compilers have problems with a '.al' extension so\n\t  # convenience libraries should have the same extension an\n\t  # archive normally would.\n\t  oldlibs=\"$output_objdir/$libname.$libext $oldlibs\"\n\t  build_libtool_libs=convenience\n\t  build_old_libs=yes\n\tfi\n\n\ttest -n \"$vinfo\" && \\\n\t  func_warning \"'-version-info/-version-number' is ignored for convenience libraries\"\n\n\ttest -n \"$release\" && \\\n\t  func_warning \"'-release' is ignored for convenience libraries\"\n      else\n\n\t# Parse the version information argument.\n\tsave_ifs=$IFS; IFS=:\n\tset dummy $vinfo 0 0 0\n\tshift\n\tIFS=$save_ifs\n\n\ttest -n \"$7\" && \\\n\t  func_fatal_help \"too many parameters to '-version-info'\"\n\n\t# convert absolute version numbers to libtool ages\n\t# this retains compatibility with .la files and attempts\n\t# to make the code below a bit more comprehensible\n\n\tcase $vinfo_number in\n\tyes)\n\t  number_major=$1\n\t  number_minor=$2\n\t  number_revision=$3\n\t  #\n\t  # There are really only two kinds -- those that\n\t  # use the current revision as the major version\n\t  # and those that subtract age and use age as\n\t  # a minor version.  But, then there is irix\n\t  # that has an extra 1 added just for fun\n\t  #\n\t  case $version_type in\n\t  # correct linux to gnu/linux during the next big refactor\n\t  darwin|freebsd-elf|linux|osf|windows|none)\n\t    func_arith $number_major + $number_minor\n\t    current=$func_arith_result\n\t    age=$number_minor\n\t    revision=$number_revision\n\t    ;;\n\t  freebsd-aout|qnx|sunos)\n\t    current=$number_major\n\t    revision=$number_minor\n\t    age=0\n\t    ;;\n\t  irix|nonstopux)\n\t    func_arith $number_major + $number_minor\n\t    current=$func_arith_result\n\t    age=$number_minor\n\t    revision=$number_minor\n\t    lt_irix_increment=no\n\t    ;;\n\t  esac\n\t  ;;\n\tno)\n\t  current=$1\n\t  revision=$2\n\t  age=$3\n\t  ;;\n\tesac\n\n\t# Check that each of the things are valid numbers.\n\tcase $current in\n\t0|[1-9]|[1-9][0-9]|[1-9][0-9][0-9]|[1-9][0-9][0-9][0-9]|[1-9][0-9][0-9][0-9][0-9]) ;;\n\t*)\n\t  func_error \"CURRENT '$current' must be a nonnegative integer\"\n\t  func_fatal_error \"'$vinfo' is not valid version information\"\n\t  ;;\n\tesac\n\n\tcase $revision in\n\t0|[1-9]|[1-9][0-9]|[1-9][0-9][0-9]|[1-9][0-9][0-9][0-9]|[1-9][0-9][0-9][0-9][0-9]) ;;\n\t*)\n\t  func_error \"REVISION '$revision' must be a nonnegative integer\"\n\t  func_fatal_error \"'$vinfo' is not valid version information\"\n\t  ;;\n\tesac\n\n\tcase $age in\n\t0|[1-9]|[1-9][0-9]|[1-9][0-9][0-9]|[1-9][0-9][0-9][0-9]|[1-9][0-9][0-9][0-9][0-9]) ;;\n\t*)\n\t  func_error \"AGE '$age' must be a nonnegative integer\"\n\t  func_fatal_error \"'$vinfo' is not valid version information\"\n\t  ;;\n\tesac\n\n\tif test \"$age\" -gt \"$current\"; then\n\t  func_error \"AGE '$age' is greater than the current interface number '$current'\"\n\t  func_fatal_error \"'$vinfo' is not valid version information\"\n\tfi\n\n\t# Calculate the version variables.\n\tmajor=\n\tversuffix=\n\tverstring=\n\tcase $version_type in\n\tnone) ;;\n\n\tdarwin)\n\t  # Like Linux, but with the current version available in\n\t  # verstring for coding it into the library header\n\t  func_arith $current - $age\n\t  major=.$func_arith_result\n\t  versuffix=$major.$age.$revision\n\t  # Darwin ld doesn't like 0 for these options...\n\t  func_arith $current + 1\n\t  minor_current=$func_arith_result\n\t  xlcverstring=\"$wl-compatibility_version $wl$minor_current $wl-current_version $wl$minor_current.$revision\"\n\t  verstring=\"-compatibility_version $minor_current -current_version $minor_current.$revision\"\n          # On Darwin other compilers\n          case $CC in\n              nagfor*)\n                  verstring=\"$wl-compatibility_version $wl$minor_current $wl-current_version $wl$minor_current.$revision\"\n                  ;;\n              *)\n                  verstring=\"-compatibility_version $minor_current -current_version $minor_current.$revision\"\n                  ;;\n          esac\n\t  ;;\n\n\tfreebsd-aout)\n\t  major=.$current\n\t  versuffix=.$current.$revision\n\t  ;;\n\n\tfreebsd-elf)\n\t  func_arith $current - $age\n\t  major=.$func_arith_result\n\t  versuffix=$major.$age.$revision\n\t  ;;\n\n\tirix | nonstopux)\n\t  if test no = \"$lt_irix_increment\"; then\n\t    func_arith $current - $age\n\t  else\n\t    func_arith $current - $age + 1\n\t  fi\n\t  major=$func_arith_result\n\n\t  case $version_type in\n\t    nonstopux) verstring_prefix=nonstopux ;;\n\t    *)         verstring_prefix=sgi ;;\n\t  esac\n\t  verstring=$verstring_prefix$major.$revision\n\n\t  # Add in all the interfaces that we are compatible with.\n\t  loop=$revision\n\t  while test 0 -ne \"$loop\"; do\n\t    func_arith $revision - $loop\n\t    iface=$func_arith_result\n\t    func_arith $loop - 1\n\t    loop=$func_arith_result\n\t    verstring=$verstring_prefix$major.$iface:$verstring\n\t  done\n\n\t  # Before this point, $major must not contain '.'.\n\t  major=.$major\n\t  versuffix=$major.$revision\n\t  ;;\n\n\tlinux) # correct to gnu/linux during the next big refactor\n\t  func_arith $current - $age\n\t  major=.$func_arith_result\n\t  versuffix=$major.$age.$revision\n\t  ;;\n\n\tosf)\n\t  func_arith $current - $age\n\t  major=.$func_arith_result\n\t  versuffix=.$current.$age.$revision\n\t  verstring=$current.$age.$revision\n\n\t  # Add in all the interfaces that we are compatible with.\n\t  loop=$age\n\t  while test 0 -ne \"$loop\"; do\n\t    func_arith $current - $loop\n\t    iface=$func_arith_result\n\t    func_arith $loop - 1\n\t    loop=$func_arith_result\n\t    verstring=$verstring:$iface.0\n\t  done\n\n\t  # Make executables depend on our current version.\n\t  func_append verstring \":$current.0\"\n\t  ;;\n\n\tqnx)\n\t  major=.$current\n\t  versuffix=.$current\n\t  ;;\n\n\tsco)\n\t  major=.$current\n\t  versuffix=.$current\n\t  ;;\n\n\tsunos)\n\t  major=.$current\n\t  versuffix=.$current.$revision\n\t  ;;\n\n\twindows)\n\t  # Use '-' rather than '.', since we only want one\n\t  # extension on DOS 8.3 file systems.\n\t  func_arith $current - $age\n\t  major=$func_arith_result\n\t  versuffix=-$major\n\t  ;;\n\n\t*)\n\t  func_fatal_configuration \"unknown library version type '$version_type'\"\n\t  ;;\n\tesac\n\n\t# Clear the version info if we defaulted, and they specified a release.\n\tif test -z \"$vinfo\" && test -n \"$release\"; then\n\t  major=\n\t  case $version_type in\n\t  darwin)\n\t    # we can't check for \"0.0\" in archive_cmds due to quoting\n\t    # problems, so we reset it completely\n\t    verstring=\n\t    ;;\n\t  *)\n\t    verstring=0.0\n\t    ;;\n\t  esac\n\t  if test no = \"$need_version\"; then\n\t    versuffix=\n\t  else\n\t    versuffix=.0.0\n\t  fi\n\tfi\n\n\t# Remove version info from name if versioning should be avoided\n\tif test yes,no = \"$avoid_version,$need_version\"; then\n\t  major=\n\t  versuffix=\n\t  verstring=\n\tfi\n\n\t# Check to see if the archive will have undefined symbols.\n\tif test yes = \"$allow_undefined\"; then\n\t  if test unsupported = \"$allow_undefined_flag\"; then\n\t    if test yes = \"$build_old_libs\"; then\n\t      func_warning \"undefined symbols not allowed in $host shared libraries; building static only\"\n\t      build_libtool_libs=no\n\t    else\n\t      func_fatal_error \"can't build $host shared library unless -no-undefined is specified\"\n\t    fi\n\t  fi\n\telse\n\t  # Don't allow undefined symbols.\n\t  allow_undefined_flag=$no_undefined_flag\n\tfi\n\n      fi\n\n      func_generate_dlsyms \"$libname\" \"$libname\" :\n      func_append libobjs \" $symfileobj\"\n      test \" \" = \"$libobjs\" && libobjs=\n\n      if test relink != \"$opt_mode\"; then\n\t# Remove our outputs, but don't remove object files since they\n\t# may have been created when compiling PIC objects.\n\tremovelist=\n\ttempremovelist=`$ECHO \"$output_objdir/*\"`\n\tfor p in $tempremovelist; do\n\t  case $p in\n\t    *.$objext | *.gcno)\n\t       ;;\n\t    $output_objdir/$outputname | $output_objdir/$libname.* | $output_objdir/$libname$release.*)\n\t       if test -n \"$precious_files_regex\"; then\n\t\t if $ECHO \"$p\" | $EGREP -e \"$precious_files_regex\" >/dev/null 2>&1\n\t\t then\n\t\t   continue\n\t\t fi\n\t       fi\n\t       func_append removelist \" $p\"\n\t       ;;\n\t    *) ;;\n\t  esac\n\tdone\n\ttest -n \"$removelist\" && \\\n\t  func_show_eval \"${RM}r \\$removelist\"\n      fi\n\n      # Now set the variables for building old libraries.\n      if test yes = \"$build_old_libs\" && test convenience != \"$build_libtool_libs\"; then\n\tfunc_append oldlibs \" $output_objdir/$libname.$libext\"\n\n\t# Transform .lo files to .o files.\n\toldobjs=\"$objs \"`$ECHO \"$libobjs\" | $SP2NL | $SED \"/\\.$libext$/d; $lo2o\" | $NL2SP`\n      fi\n\n      # Eliminate all temporary directories.\n      #for path in $notinst_path; do\n      #\tlib_search_path=`$ECHO \"$lib_search_path \" | $SED \"s% $path % %g\"`\n      #\tdeplibs=`$ECHO \"$deplibs \" | $SED \"s% -L$path % %g\"`\n      #\tdependency_libs=`$ECHO \"$dependency_libs \" | $SED \"s% -L$path % %g\"`\n      #done\n\n      if test -n \"$xrpath\"; then\n\t# If the user specified any rpath flags, then add them.\n\ttemp_xrpath=\n\tfor libdir in $xrpath; do\n\t  func_replace_sysroot \"$libdir\"\n\t  func_append temp_xrpath \" -R$func_replace_sysroot_result\"\n\t  case \"$finalize_rpath \" in\n\t  *\" $libdir \"*) ;;\n\t  *) func_append finalize_rpath \" $libdir\" ;;\n\t  esac\n\tdone\n\tif test yes != \"$hardcode_into_libs\" || test yes = \"$build_old_libs\"; then\n\t  dependency_libs=\"$temp_xrpath $dependency_libs\"\n\tfi\n      fi\n\n      # Make sure dlfiles contains only unique files that won't be dlpreopened\n      old_dlfiles=$dlfiles\n      dlfiles=\n      for lib in $old_dlfiles; do\n\tcase \" $dlprefiles $dlfiles \" in\n\t*\" $lib \"*) ;;\n\t*) func_append dlfiles \" $lib\" ;;\n\tesac\n      done\n\n      # Make sure dlprefiles contains only unique files\n      old_dlprefiles=$dlprefiles\n      dlprefiles=\n      for lib in $old_dlprefiles; do\n\tcase \"$dlprefiles \" in\n\t*\" $lib \"*) ;;\n\t*) func_append dlprefiles \" $lib\" ;;\n\tesac\n      done\n\n      if test yes = \"$build_libtool_libs\"; then\n\tif test -n \"$rpath\"; then\n\t  case $host in\n\t  *-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-*-beos* | *-cegcc* | *-*-haiku*)\n\t    # these systems don't actually have a c library (as such)!\n\t    ;;\n\t  *-*-rhapsody* | *-*-darwin1.[012])\n\t    # Rhapsody C library is in the System framework\n\t    func_append deplibs \" System.ltframework\"\n\t    ;;\n\t  *-*-netbsd*)\n\t    # Don't link with libc until the a.out ld.so is fixed.\n\t    ;;\n\t  *-*-openbsd* | *-*-freebsd* | *-*-dragonfly*)\n\t    # Do not include libc due to us having libc/libc_r.\n\t    ;;\n\t  *-*-sco3.2v5* | *-*-sco5v6*)\n\t    # Causes problems with __ctype\n\t    ;;\n\t  *-*-sysv4.2uw2* | *-*-sysv5* | *-*-unixware* | *-*-OpenUNIX*)\n\t    # Compiler inserts libc in the correct place for threads to work\n\t    ;;\n\t  *)\n\t    # Add libc to deplibs on all other systems if necessary.\n\t    if test yes = \"$build_libtool_need_lc\"; then\n\t      func_append deplibs \" -lc\"\n\t    fi\n\t    ;;\n\t  esac\n\tfi\n\n\t# Transform deplibs into only deplibs that can be linked in shared.\n\tname_save=$name\n\tlibname_save=$libname\n\trelease_save=$release\n\tversuffix_save=$versuffix\n\tmajor_save=$major\n\t# I'm not sure if I'm treating the release correctly.  I think\n\t# release should show up in the -l (ie -lgmp5) so we don't want to\n\t# add it in twice.  Is that correct?\n\trelease=\n\tversuffix=\n\tmajor=\n\tnewdeplibs=\n\tdroppeddeps=no\n\tcase $deplibs_check_method in\n\tpass_all)\n\t  # Don't check for shared/static.  Everything works.\n\t  # This might be a little naive.  We might want to check\n\t  # whether the library exists or not.  But this is on\n\t  # osf3 & osf4 and I'm not really sure... Just\n\t  # implementing what was already the behavior.\n\t  newdeplibs=$deplibs\n\t  ;;\n\ttest_compile)\n\t  # This code stresses the \"libraries are programs\" paradigm to its\n\t  # limits. Maybe even breaks it.  We compile a program, linking it\n\t  # against the deplibs as a proxy for the library.  Then we can check\n\t  # whether they linked in statically or dynamically with ldd.\n\t  $opt_dry_run || $RM conftest.c\n\t  cat > conftest.c <<EOF\n\t  int main() { return 0; }\nEOF\n\t  $opt_dry_run || $RM conftest\n\t  if $LTCC $LTCFLAGS -o conftest conftest.c $deplibs; then\n\t    ldd_output=`ldd conftest`\n\t    for i in $deplibs; do\n\t      case $i in\n\t      -l*)\n\t\tfunc_stripname -l '' \"$i\"\n\t\tname=$func_stripname_result\n\t\tif test yes = \"$allow_libtool_libs_with_static_runtimes\"; then\n\t\t  case \" $predeps $postdeps \" in\n\t\t  *\" $i \"*)\n\t\t    func_append newdeplibs \" $i\"\n\t\t    i=\n\t\t    ;;\n\t\t  esac\n\t\tfi\n\t\tif test -n \"$i\"; then\n\t\t  libname=`eval \"\\\\$ECHO \\\"$libname_spec\\\"\"`\n\t\t  deplib_matches=`eval \"\\\\$ECHO \\\"$library_names_spec\\\"\"`\n\t\t  set dummy $deplib_matches; shift\n\t\t  deplib_match=$1\n\t\t  if test `expr \"$ldd_output\" : \".*$deplib_match\"` -ne 0; then\n\t\t    func_append newdeplibs \" $i\"\n\t\t  else\n\t\t    droppeddeps=yes\n\t\t    echo\n\t\t    $ECHO \"*** Warning: dynamic linker does not accept needed library $i.\"\n\t\t    echo \"*** I have the capability to make that library automatically link in when\"\n\t\t    echo \"*** you link to this library.  But I can only do this if you have a\"\n\t\t    echo \"*** shared version of the library, which I believe you do not have\"\n\t\t    echo \"*** because a test_compile did reveal that the linker did not use it for\"\n\t\t    echo \"*** its dynamic dependency list that programs get resolved with at runtime.\"\n\t\t  fi\n\t\tfi\n\t\t;;\n\t      *)\n\t\tfunc_append newdeplibs \" $i\"\n\t\t;;\n\t      esac\n\t    done\n\t  else\n\t    # Error occurred in the first compile.  Let's try to salvage\n\t    # the situation: Compile a separate program for each library.\n\t    for i in $deplibs; do\n\t      case $i in\n\t      -l*)\n\t\tfunc_stripname -l '' \"$i\"\n\t\tname=$func_stripname_result\n\t\t$opt_dry_run || $RM conftest\n\t\tif $LTCC $LTCFLAGS -o conftest conftest.c $i; then\n\t\t  ldd_output=`ldd conftest`\n\t\t  if test yes = \"$allow_libtool_libs_with_static_runtimes\"; then\n\t\t    case \" $predeps $postdeps \" in\n\t\t    *\" $i \"*)\n\t\t      func_append newdeplibs \" $i\"\n\t\t      i=\n\t\t      ;;\n\t\t    esac\n\t\t  fi\n\t\t  if test -n \"$i\"; then\n\t\t    libname=`eval \"\\\\$ECHO \\\"$libname_spec\\\"\"`\n\t\t    deplib_matches=`eval \"\\\\$ECHO \\\"$library_names_spec\\\"\"`\n\t\t    set dummy $deplib_matches; shift\n\t\t    deplib_match=$1\n\t\t    if test `expr \"$ldd_output\" : \".*$deplib_match\"` -ne 0; then\n\t\t      func_append newdeplibs \" $i\"\n\t\t    else\n\t\t      droppeddeps=yes\n\t\t      echo\n\t\t      $ECHO \"*** Warning: dynamic linker does not accept needed library $i.\"\n\t\t      echo \"*** I have the capability to make that library automatically link in when\"\n\t\t      echo \"*** you link to this library.  But I can only do this if you have a\"\n\t\t      echo \"*** shared version of the library, which you do not appear to have\"\n\t\t      echo \"*** because a test_compile did reveal that the linker did not use this one\"\n\t\t      echo \"*** as a dynamic dependency that programs can get resolved with at runtime.\"\n\t\t    fi\n\t\t  fi\n\t\telse\n\t\t  droppeddeps=yes\n\t\t  echo\n\t\t  $ECHO \"*** Warning!  Library $i is needed by this library but I was not able to\"\n\t\t  echo \"*** make it link in!  You will probably need to install it or some\"\n\t\t  echo \"*** library that it depends on before this library will be fully\"\n\t\t  echo \"*** functional.  Installing it before continuing would be even better.\"\n\t\tfi\n\t\t;;\n\t      *)\n\t\tfunc_append newdeplibs \" $i\"\n\t\t;;\n\t      esac\n\t    done\n\t  fi\n\t  ;;\n\tfile_magic*)\n\t  set dummy $deplibs_check_method; shift\n\t  file_magic_regex=`expr \"$deplibs_check_method\" : \"$1 \\(.*\\)\"`\n\t  for a_deplib in $deplibs; do\n\t    case $a_deplib in\n\t    -l*)\n\t      func_stripname -l '' \"$a_deplib\"\n\t      name=$func_stripname_result\n\t      if test yes = \"$allow_libtool_libs_with_static_runtimes\"; then\n\t\tcase \" $predeps $postdeps \" in\n\t\t*\" $a_deplib \"*)\n\t\t  func_append newdeplibs \" $a_deplib\"\n\t\t  a_deplib=\n\t\t  ;;\n\t\tesac\n\t      fi\n\t      if test -n \"$a_deplib\"; then\n\t\tlibname=`eval \"\\\\$ECHO \\\"$libname_spec\\\"\"`\n\t\tif test -n \"$file_magic_glob\"; then\n\t\t  libnameglob=`func_echo_all \"$libname\" | $SED -e $file_magic_glob`\n\t\telse\n\t\t  libnameglob=$libname\n\t\tfi\n\t\ttest yes = \"$want_nocaseglob\" && nocaseglob=`shopt -p nocaseglob`\n\t\tfor i in $lib_search_path $sys_lib_search_path $shlib_search_path; do\n\t\t  if test yes = \"$want_nocaseglob\"; then\n\t\t    shopt -s nocaseglob\n\t\t    potential_libs=`ls $i/$libnameglob[.-]* 2>/dev/null`\n\t\t    $nocaseglob\n\t\t  else\n\t\t    potential_libs=`ls $i/$libnameglob[.-]* 2>/dev/null`\n\t\t  fi\n\t\t  for potent_lib in $potential_libs; do\n\t\t      # Follow soft links.\n\t\t      if ls -lLd \"$potent_lib\" 2>/dev/null |\n\t\t\t $GREP \" -> \" >/dev/null; then\n\t\t\tcontinue\n\t\t      fi\n\t\t      # The statement above tries to avoid entering an\n\t\t      # endless loop below, in case of cyclic links.\n\t\t      # We might still enter an endless loop, since a link\n\t\t      # loop can be closed while we follow links,\n\t\t      # but so what?\n\t\t      potlib=$potent_lib\n\t\t      while test -h \"$potlib\" 2>/dev/null; do\n\t\t\tpotliblink=`ls -ld $potlib | $SED 's/.* -> //'`\n\t\t\tcase $potliblink in\n\t\t\t[\\\\/]* | [A-Za-z]:[\\\\/]*) potlib=$potliblink;;\n\t\t\t*) potlib=`$ECHO \"$potlib\" | $SED 's|[^/]*$||'`\"$potliblink\";;\n\t\t\tesac\n\t\t      done\n\t\t      if eval $file_magic_cmd \\\"\\$potlib\\\" 2>/dev/null |\n\t\t\t $SED -e 10q |\n\t\t\t $EGREP \"$file_magic_regex\" > /dev/null; then\n\t\t\tfunc_append newdeplibs \" $a_deplib\"\n\t\t\ta_deplib=\n\t\t\tbreak 2\n\t\t      fi\n\t\t  done\n\t\tdone\n\t      fi\n\t      if test -n \"$a_deplib\"; then\n\t\tdroppeddeps=yes\n\t\techo\n\t\t$ECHO \"*** Warning: linker path does not have real file for library $a_deplib.\"\n\t\techo \"*** I have the capability to make that library automatically link in when\"\n\t\techo \"*** you link to this library.  But I can only do this if you have a\"\n\t\techo \"*** shared version of the library, which you do not appear to have\"\n\t\techo \"*** because I did check the linker path looking for a file starting\"\n\t\tif test -z \"$potlib\"; then\n\t\t  $ECHO \"*** with $libname but no candidates were found. (...for file magic test)\"\n\t\telse\n\t\t  $ECHO \"*** with $libname and none of the candidates passed a file format test\"\n\t\t  $ECHO \"*** using a file magic. Last file checked: $potlib\"\n\t\tfi\n\t      fi\n\t      ;;\n\t    *)\n\t      # Add a -L argument.\n\t      func_append newdeplibs \" $a_deplib\"\n\t      ;;\n\t    esac\n\t  done # Gone through all deplibs.\n\t  ;;\n\tmatch_pattern*)\n\t  set dummy $deplibs_check_method; shift\n\t  match_pattern_regex=`expr \"$deplibs_check_method\" : \"$1 \\(.*\\)\"`\n\t  for a_deplib in $deplibs; do\n\t    case $a_deplib in\n\t    -l*)\n\t      func_stripname -l '' \"$a_deplib\"\n\t      name=$func_stripname_result\n\t      if test yes = \"$allow_libtool_libs_with_static_runtimes\"; then\n\t\tcase \" $predeps $postdeps \" in\n\t\t*\" $a_deplib \"*)\n\t\t  func_append newdeplibs \" $a_deplib\"\n\t\t  a_deplib=\n\t\t  ;;\n\t\tesac\n\t      fi\n\t      if test -n \"$a_deplib\"; then\n\t\tlibname=`eval \"\\\\$ECHO \\\"$libname_spec\\\"\"`\n\t\tfor i in $lib_search_path $sys_lib_search_path $shlib_search_path; do\n\t\t  potential_libs=`ls $i/$libname[.-]* 2>/dev/null`\n\t\t  for potent_lib in $potential_libs; do\n\t\t    potlib=$potent_lib # see symlink-check above in file_magic test\n\t\t    if eval \"\\$ECHO \\\"$potent_lib\\\"\" 2>/dev/null | $SED 10q | \\\n\t\t       $EGREP \"$match_pattern_regex\" > /dev/null; then\n\t\t      func_append newdeplibs \" $a_deplib\"\n\t\t      a_deplib=\n\t\t      break 2\n\t\t    fi\n\t\t  done\n\t\tdone\n\t      fi\n\t      if test -n \"$a_deplib\"; then\n\t\tdroppeddeps=yes\n\t\techo\n\t\t$ECHO \"*** Warning: linker path does not have real file for library $a_deplib.\"\n\t\techo \"*** I have the capability to make that library automatically link in when\"\n\t\techo \"*** you link to this library.  But I can only do this if you have a\"\n\t\techo \"*** shared version of the library, which you do not appear to have\"\n\t\techo \"*** because I did check the linker path looking for a file starting\"\n\t\tif test -z \"$potlib\"; then\n\t\t  $ECHO \"*** with $libname but no candidates were found. (...for regex pattern test)\"\n\t\telse\n\t\t  $ECHO \"*** with $libname and none of the candidates passed a file format test\"\n\t\t  $ECHO \"*** using a regex pattern. Last file checked: $potlib\"\n\t\tfi\n\t      fi\n\t      ;;\n\t    *)\n\t      # Add a -L argument.\n\t      func_append newdeplibs \" $a_deplib\"\n\t      ;;\n\t    esac\n\t  done # Gone through all deplibs.\n\t  ;;\n\tnone | unknown | *)\n\t  newdeplibs=\n\t  tmp_deplibs=`$ECHO \" $deplibs\" | $SED 's/ -lc$//; s/ -[LR][^ ]*//g'`\n\t  if test yes = \"$allow_libtool_libs_with_static_runtimes\"; then\n\t    for i in $predeps $postdeps; do\n\t      # can't use Xsed below, because $i might contain '/'\n\t      tmp_deplibs=`$ECHO \" $tmp_deplibs\" | $SED \"s|$i||\"`\n\t    done\n\t  fi\n\t  case $tmp_deplibs in\n\t  *[!\\\t\\ ]*)\n\t    echo\n\t    if test none = \"$deplibs_check_method\"; then\n\t      echo \"*** Warning: inter-library dependencies are not supported in this platform.\"\n\t    else\n\t      echo \"*** Warning: inter-library dependencies are not known to be supported.\"\n\t    fi\n\t    echo \"*** All declared inter-library dependencies are being dropped.\"\n\t    droppeddeps=yes\n\t    ;;\n\t  esac\n\t  ;;\n\tesac\n\tversuffix=$versuffix_save\n\tmajor=$major_save\n\trelease=$release_save\n\tlibname=$libname_save\n\tname=$name_save\n\n\tcase $host in\n\t*-*-rhapsody* | *-*-darwin1.[012])\n\t  # On Rhapsody replace the C library with the System framework\n\t  newdeplibs=`$ECHO \" $newdeplibs\" | $SED 's/ -lc / System.ltframework /'`\n\t  ;;\n\tesac\n\n\tif test yes = \"$droppeddeps\"; then\n\t  if test yes = \"$module\"; then\n\t    echo\n\t    echo \"*** Warning: libtool could not satisfy all declared inter-library\"\n\t    $ECHO \"*** dependencies of module $libname.  Therefore, libtool will create\"\n\t    echo \"*** a static module, that should work as long as the dlopening\"\n\t    echo \"*** application is linked with the -dlopen flag.\"\n\t    if test -z \"$global_symbol_pipe\"; then\n\t      echo\n\t      echo \"*** However, this would only work if libtool was able to extract symbol\"\n\t      echo \"*** lists from a program, using 'nm' or equivalent, but libtool could\"\n\t      echo \"*** not find such a program.  So, this module is probably useless.\"\n\t      echo \"*** 'nm' from GNU binutils and a full rebuild may help.\"\n\t    fi\n\t    if test no = \"$build_old_libs\"; then\n\t      oldlibs=$output_objdir/$libname.$libext\n\t      build_libtool_libs=module\n\t      build_old_libs=yes\n\t    else\n\t      build_libtool_libs=no\n\t    fi\n\t  else\n\t    echo \"*** The inter-library dependencies that have been dropped here will be\"\n\t    echo \"*** automatically added whenever a program is linked with this library\"\n\t    echo \"*** or is declared to -dlopen it.\"\n\n\t    if test no = \"$allow_undefined\"; then\n\t      echo\n\t      echo \"*** Since this library must not contain undefined symbols,\"\n\t      echo \"*** because either the platform does not support them or\"\n\t      echo \"*** it was explicitly requested with -no-undefined,\"\n\t      echo \"*** libtool will only create a static version of it.\"\n\t      if test no = \"$build_old_libs\"; then\n\t\toldlibs=$output_objdir/$libname.$libext\n\t\tbuild_libtool_libs=module\n\t\tbuild_old_libs=yes\n\t      else\n\t\tbuild_libtool_libs=no\n\t      fi\n\t    fi\n\t  fi\n\tfi\n\t# Done checking deplibs!\n\tdeplibs=$newdeplibs\n      fi\n      # Time to change all our \"foo.ltframework\" stuff back to \"-framework foo\"\n      case $host in\n\t*-*-darwin*)\n\t  newdeplibs=`$ECHO \" $newdeplibs\" | $SED 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\t  new_inherited_linker_flags=`$ECHO \" $new_inherited_linker_flags\" | $SED 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\t  deplibs=`$ECHO \" $deplibs\" | $SED 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\t  ;;\n      esac\n\n      # move library search paths that coincide with paths to not yet\n      # installed libraries to the beginning of the library search list\n      new_libs=\n      for path in $notinst_path; do\n\tcase \" $new_libs \" in\n\t*\" -L$path/$objdir \"*) ;;\n\t*)\n\t  case \" $deplibs \" in\n\t  *\" -L$path/$objdir \"*)\n\t    func_append new_libs \" -L$path/$objdir\" ;;\n\t  esac\n\t  ;;\n\tesac\n      done\n      for deplib in $deplibs; do\n\tcase $deplib in\n\t-L*)\n\t  case \" $new_libs \" in\n\t  *\" $deplib \"*) ;;\n\t  *) func_append new_libs \" $deplib\" ;;\n\t  esac\n\t  ;;\n\t*) func_append new_libs \" $deplib\" ;;\n\tesac\n      done\n      deplibs=$new_libs\n\n      # All the library-specific variables (install_libdir is set above).\n      library_names=\n      old_library=\n      dlname=\n\n      # Test again, we may have decided not to build it any more\n      if test yes = \"$build_libtool_libs\"; then\n\t# Remove $wl instances when linking with ld.\n\t# FIXME: should test the right _cmds variable.\n\tcase $archive_cmds in\n\t  *\\$LD\\ *) wl= ;;\n        esac\n\tif test yes = \"$hardcode_into_libs\"; then\n\t  # Hardcode the library paths\n\t  hardcode_libdirs=\n\t  dep_rpath=\n\t  rpath=$finalize_rpath\n\t  test relink = \"$opt_mode\" || rpath=$compile_rpath$rpath\n\t  for libdir in $rpath; do\n\t    if test -n \"$hardcode_libdir_flag_spec\"; then\n\t      if test -n \"$hardcode_libdir_separator\"; then\n\t\tfunc_replace_sysroot \"$libdir\"\n\t\tlibdir=$func_replace_sysroot_result\n\t\tif test -z \"$hardcode_libdirs\"; then\n\t\t  hardcode_libdirs=$libdir\n\t\telse\n\t\t  # Just accumulate the unique libdirs.\n\t\t  case $hardcode_libdir_separator$hardcode_libdirs$hardcode_libdir_separator in\n\t\t  *\"$hardcode_libdir_separator$libdir$hardcode_libdir_separator\"*)\n\t\t    ;;\n\t\t  *)\n\t\t    func_append hardcode_libdirs \"$hardcode_libdir_separator$libdir\"\n\t\t    ;;\n\t\t  esac\n\t\tfi\n\t      else\n\t\teval flag=\\\"$hardcode_libdir_flag_spec\\\"\n\t\tfunc_append dep_rpath \" $flag\"\n\t      fi\n\t    elif test -n \"$runpath_var\"; then\n\t      case \"$perm_rpath \" in\n\t      *\" $libdir \"*) ;;\n\t      *) func_append perm_rpath \" $libdir\" ;;\n\t      esac\n\t    fi\n\t  done\n\t  # Substitute the hardcoded libdirs into the rpath.\n\t  if test -n \"$hardcode_libdir_separator\" &&\n\t     test -n \"$hardcode_libdirs\"; then\n\t    libdir=$hardcode_libdirs\n\t    eval \"dep_rpath=\\\"$hardcode_libdir_flag_spec\\\"\"\n\t  fi\n\t  if test -n \"$runpath_var\" && test -n \"$perm_rpath\"; then\n\t    # We should set the runpath_var.\n\t    rpath=\n\t    for dir in $perm_rpath; do\n\t      func_append rpath \"$dir:\"\n\t    done\n\t    eval \"$runpath_var='$rpath\\$$runpath_var'; export $runpath_var\"\n\t  fi\n\t  test -n \"$dep_rpath\" && deplibs=\"$dep_rpath $deplibs\"\n\tfi\n\n\tshlibpath=$finalize_shlibpath\n\ttest relink = \"$opt_mode\" || shlibpath=$compile_shlibpath$shlibpath\n\tif test -n \"$shlibpath\"; then\n\t  eval \"$shlibpath_var='$shlibpath\\$$shlibpath_var'; export $shlibpath_var\"\n\tfi\n\n\t# Get the real and link names of the library.\n\teval shared_ext=\\\"$shrext_cmds\\\"\n\teval library_names=\\\"$library_names_spec\\\"\n\tset dummy $library_names\n\tshift\n\trealname=$1\n\tshift\n\n\tif test -n \"$soname_spec\"; then\n\t  eval soname=\\\"$soname_spec\\\"\n\telse\n\t  soname=$realname\n\tfi\n\tif test -z \"$dlname\"; then\n\t  dlname=$soname\n\tfi\n\n\tlib=$output_objdir/$realname\n\tlinknames=\n\tfor link\n\tdo\n\t  func_append linknames \" $link\"\n\tdone\n\n\t# Use standard objects if they are pic\n\ttest -z \"$pic_flag\" && libobjs=`$ECHO \"$libobjs\" | $SP2NL | $SED \"$lo2o\" | $NL2SP`\n\ttest \"X$libobjs\" = \"X \" && libobjs=\n\n\tdelfiles=\n\tif test -n \"$export_symbols\" && test -n \"$include_expsyms\"; then\n\t  $opt_dry_run || cp \"$export_symbols\" \"$output_objdir/$libname.uexp\"\n\t  export_symbols=$output_objdir/$libname.uexp\n\t  func_append delfiles \" $export_symbols\"\n\tfi\n\n\torig_export_symbols=\n\tcase $host_os in\n\tcygwin* | mingw* | cegcc*)\n\t  if test -n \"$export_symbols\" && test -z \"$export_symbols_regex\"; then\n\t    # exporting using user supplied symfile\n\t    func_dll_def_p \"$export_symbols\" || {\n\t      # and it's NOT already a .def file. Must figure out\n\t      # which of the given symbols are data symbols and tag\n\t      # them as such. So, trigger use of export_symbols_cmds.\n\t      # export_symbols gets reassigned inside the \"prepare\n\t      # the list of exported symbols\" if statement, so the\n\t      # include_expsyms logic still works.\n\t      orig_export_symbols=$export_symbols\n\t      export_symbols=\n\t      always_export_symbols=yes\n\t    }\n\t  fi\n\t  ;;\n\tesac\n\n\t# Prepare the list of exported symbols\n\tif test -z \"$export_symbols\"; then\n\t  if test yes = \"$always_export_symbols\" || test -n \"$export_symbols_regex\"; then\n\t    func_verbose \"generating symbol list for '$libname.la'\"\n\t    export_symbols=$output_objdir/$libname.exp\n\t    $opt_dry_run || $RM $export_symbols\n\t    cmds=$export_symbols_cmds\n\t    save_ifs=$IFS; IFS='~'\n\t    for cmd1 in $cmds; do\n\t      IFS=$save_ifs\n\t      # Take the normal branch if the nm_file_list_spec branch\n\t      # doesn't work or if tool conversion is not needed.\n\t      case $nm_file_list_spec~$to_tool_file_cmd in\n\t\t*~func_convert_file_noop | *~func_convert_file_msys_to_w32 | ~*)\n\t\t  try_normal_branch=yes\n\t\t  eval cmd=\\\"$cmd1\\\"\n\t\t  func_len \" $cmd\"\n\t\t  len=$func_len_result\n\t\t  ;;\n\t\t*)\n\t\t  try_normal_branch=no\n\t\t  ;;\n\t      esac\n\t      if test yes = \"$try_normal_branch\" \\\n\t\t && { test \"$len\" -lt \"$max_cmd_len\" \\\n\t\t      || test \"$max_cmd_len\" -le -1; }\n\t      then\n\t\tfunc_show_eval \"$cmd\" 'exit $?'\n\t\tskipped_export=false\n\t      elif test -n \"$nm_file_list_spec\"; then\n\t\tfunc_basename \"$output\"\n\t\toutput_la=$func_basename_result\n\t\tsave_libobjs=$libobjs\n\t\tsave_output=$output\n\t\toutput=$output_objdir/$output_la.nm\n\t\tfunc_to_tool_file \"$output\"\n\t\tlibobjs=$nm_file_list_spec$func_to_tool_file_result\n\t\tfunc_append delfiles \" $output\"\n\t\tfunc_verbose \"creating $NM input file list: $output\"\n\t\tfor obj in $save_libobjs; do\n\t\t  func_to_tool_file \"$obj\"\n\t\t  $ECHO \"$func_to_tool_file_result\"\n\t\tdone > \"$output\"\n\t\teval cmd=\\\"$cmd1\\\"\n\t\tfunc_show_eval \"$cmd\" 'exit $?'\n\t\toutput=$save_output\n\t\tlibobjs=$save_libobjs\n\t\tskipped_export=false\n\t      else\n\t\t# The command line is too long to execute in one step.\n\t\tfunc_verbose \"using reloadable object file for export list...\"\n\t\tskipped_export=:\n\t\t# Break out early, otherwise skipped_export may be\n\t\t# set to false by a later but shorter cmd.\n\t\tbreak\n\t      fi\n\t    done\n\t    IFS=$save_ifs\n\t    if test -n \"$export_symbols_regex\" && test : != \"$skipped_export\"; then\n\t      func_show_eval '$EGREP -e \"$export_symbols_regex\" \"$export_symbols\" > \"${export_symbols}T\"'\n\t      func_show_eval '$MV \"${export_symbols}T\" \"$export_symbols\"'\n\t    fi\n\t  fi\n\tfi\n\n\tif test -n \"$export_symbols\" && test -n \"$include_expsyms\"; then\n\t  tmp_export_symbols=$export_symbols\n\t  test -n \"$orig_export_symbols\" && tmp_export_symbols=$orig_export_symbols\n\t  $opt_dry_run || eval '$ECHO \"$include_expsyms\" | $SP2NL >> \"$tmp_export_symbols\"'\n\tfi\n\n\tif test : != \"$skipped_export\" && test -n \"$orig_export_symbols\"; then\n\t  # The given exports_symbols file has to be filtered, so filter it.\n\t  func_verbose \"filter symbol list for '$libname.la' to tag DATA exports\"\n\t  # FIXME: $output_objdir/$libname.filter potentially contains lots of\n\t  # 's' commands, which not all seds can handle. GNU sed should be fine\n\t  # though. Also, the filter scales superlinearly with the number of\n\t  # global variables. join(1) would be nice here, but unfortunately\n\t  # isn't a blessed tool.\n\t  $opt_dry_run || $SED -e '/[ ,]DATA/!d;s,\\(.*\\)\\([ \\,].*\\),s|^\\1$|\\1\\2|,' < $export_symbols > $output_objdir/$libname.filter\n\t  func_append delfiles \" $export_symbols $output_objdir/$libname.filter\"\n\t  export_symbols=$output_objdir/$libname.def\n\t  $opt_dry_run || $SED -f $output_objdir/$libname.filter < $orig_export_symbols > $export_symbols\n\tfi\n\n\ttmp_deplibs=\n\tfor test_deplib in $deplibs; do\n\t  case \" $convenience \" in\n\t  *\" $test_deplib \"*) ;;\n\t  *)\n\t    func_append tmp_deplibs \" $test_deplib\"\n\t    ;;\n\t  esac\n\tdone\n\tdeplibs=$tmp_deplibs\n\n\tif test -n \"$convenience\"; then\n\t  if test -n \"$whole_archive_flag_spec\" &&\n\t    test yes = \"$compiler_needs_object\" &&\n\t    test -z \"$libobjs\"; then\n\t    # extract the archives, so we have objects to list.\n\t    # TODO: could optimize this to just extract one archive.\n\t    whole_archive_flag_spec=\n\t  fi\n\t  if test -n \"$whole_archive_flag_spec\"; then\n\t    save_libobjs=$libobjs\n\t    eval libobjs=\\\"\\$libobjs $whole_archive_flag_spec\\\"\n\t    test \"X$libobjs\" = \"X \" && libobjs=\n\t  else\n\t    gentop=$output_objdir/${outputname}x\n\t    func_append generated \" $gentop\"\n\n\t    func_extract_archives $gentop $convenience\n\t    func_append libobjs \" $func_extract_archives_result\"\n\t    test \"X$libobjs\" = \"X \" && libobjs=\n\t  fi\n\tfi\n\n\tif test yes = \"$thread_safe\" && test -n \"$thread_safe_flag_spec\"; then\n\t  eval flag=\\\"$thread_safe_flag_spec\\\"\n\t  func_append linker_flags \" $flag\"\n\tfi\n\n\t# Make a backup of the uninstalled library when relinking\n\tif test relink = \"$opt_mode\"; then\n\t  $opt_dry_run || eval '(cd $output_objdir && $RM ${realname}U && $MV $realname ${realname}U)' || exit $?\n\tfi\n\n\t# Do each of the archive commands.\n\tif test yes = \"$module\" && test -n \"$module_cmds\"; then\n\t  if test -n \"$export_symbols\" && test -n \"$module_expsym_cmds\"; then\n\t    eval test_cmds=\\\"$module_expsym_cmds\\\"\n\t    cmds=$module_expsym_cmds\n\t  else\n\t    eval test_cmds=\\\"$module_cmds\\\"\n\t    cmds=$module_cmds\n\t  fi\n\telse\n\t  if test -n \"$export_symbols\" && test -n \"$archive_expsym_cmds\"; then\n\t    eval test_cmds=\\\"$archive_expsym_cmds\\\"\n\t    cmds=$archive_expsym_cmds\n\t  else\n\t    eval test_cmds=\\\"$archive_cmds\\\"\n\t    cmds=$archive_cmds\n\t  fi\n\tfi\n\n\tif test : != \"$skipped_export\" &&\n\t   func_len \" $test_cmds\" &&\n\t   len=$func_len_result &&\n\t   test \"$len\" -lt \"$max_cmd_len\" || test \"$max_cmd_len\" -le -1; then\n\t  :\n\telse\n\t  # The command line is too long to link in one step, link piecewise\n\t  # or, if using GNU ld and skipped_export is not :, use a linker\n\t  # script.\n\n\t  # Save the value of $output and $libobjs because we want to\n\t  # use them later.  If we have whole_archive_flag_spec, we\n\t  # want to use save_libobjs as it was before\n\t  # whole_archive_flag_spec was expanded, because we can't\n\t  # assume the linker understands whole_archive_flag_spec.\n\t  # This may have to be revisited, in case too many\n\t  # convenience libraries get linked in and end up exceeding\n\t  # the spec.\n\t  if test -z \"$convenience\" || test -z \"$whole_archive_flag_spec\"; then\n\t    save_libobjs=$libobjs\n\t  fi\n\t  save_output=$output\n\t  func_basename \"$output\"\n\t  output_la=$func_basename_result\n\n\t  # Clear the reloadable object creation command queue and\n\t  # initialize k to one.\n\t  test_cmds=\n\t  concat_cmds=\n\t  objlist=\n\t  last_robj=\n\t  k=1\n\n\t  if test -n \"$save_libobjs\" && test : != \"$skipped_export\" && test yes = \"$with_gnu_ld\"; then\n\t    output=$output_objdir/$output_la.lnkscript\n\t    func_verbose \"creating GNU ld script: $output\"\n\t    echo 'INPUT (' > $output\n\t    for obj in $save_libobjs\n\t    do\n\t      func_to_tool_file \"$obj\"\n\t      $ECHO \"$func_to_tool_file_result\" >> $output\n\t    done\n\t    echo ')' >> $output\n\t    func_append delfiles \" $output\"\n\t    func_to_tool_file \"$output\"\n\t    output=$func_to_tool_file_result\n\t  elif test -n \"$save_libobjs\" && test : != \"$skipped_export\" && test -n \"$file_list_spec\"; then\n\t    output=$output_objdir/$output_la.lnk\n\t    func_verbose \"creating linker input file list: $output\"\n\t    : > $output\n\t    set x $save_libobjs\n\t    shift\n\t    firstobj=\n\t    if test yes = \"$compiler_needs_object\"; then\n\t      firstobj=\"$1 \"\n\t      shift\n\t    fi\n\t    for obj\n\t    do\n\t      func_to_tool_file \"$obj\"\n\t      $ECHO \"$func_to_tool_file_result\" >> $output\n\t    done\n\t    func_append delfiles \" $output\"\n\t    func_to_tool_file \"$output\"\n\t    output=$firstobj\\\"$file_list_spec$func_to_tool_file_result\\\"\n\t  else\n\t    if test -n \"$save_libobjs\"; then\n\t      func_verbose \"creating reloadable object files...\"\n\t      output=$output_objdir/$output_la-$k.$objext\n\t      eval test_cmds=\\\"$reload_cmds\\\"\n\t      func_len \" $test_cmds\"\n\t      len0=$func_len_result\n\t      len=$len0\n\n\t      # Loop over the list of objects to be linked.\n\t      for obj in $save_libobjs\n\t      do\n\t\tfunc_len \" $obj\"\n\t\tfunc_arith $len + $func_len_result\n\t\tlen=$func_arith_result\n\t\tif test -z \"$objlist\" ||\n\t\t   test \"$len\" -lt \"$max_cmd_len\"; then\n\t\t  func_append objlist \" $obj\"\n\t\telse\n\t\t  # The command $test_cmds is almost too long, add a\n\t\t  # command to the queue.\n\t\t  if test 1 -eq \"$k\"; then\n\t\t    # The first file doesn't have a previous command to add.\n\t\t    reload_objs=$objlist\n\t\t    eval concat_cmds=\\\"$reload_cmds\\\"\n\t\t  else\n\t\t    # All subsequent reloadable object files will link in\n\t\t    # the last one created.\n\t\t    reload_objs=\"$objlist $last_robj\"\n\t\t    eval concat_cmds=\\\"\\$concat_cmds~$reload_cmds~\\$RM $last_robj\\\"\n\t\t  fi\n\t\t  last_robj=$output_objdir/$output_la-$k.$objext\n\t\t  func_arith $k + 1\n\t\t  k=$func_arith_result\n\t\t  output=$output_objdir/$output_la-$k.$objext\n\t\t  objlist=\" $obj\"\n\t\t  func_len \" $last_robj\"\n\t\t  func_arith $len0 + $func_len_result\n\t\t  len=$func_arith_result\n\t\tfi\n\t      done\n\t      # Handle the remaining objects by creating one last\n\t      # reloadable object file.  All subsequent reloadable object\n\t      # files will link in the last one created.\n\t      test -z \"$concat_cmds\" || concat_cmds=$concat_cmds~\n\t      reload_objs=\"$objlist $last_robj\"\n\t      eval concat_cmds=\\\"\\$concat_cmds$reload_cmds\\\"\n\t      if test -n \"$last_robj\"; then\n\t        eval concat_cmds=\\\"\\$concat_cmds~\\$RM $last_robj\\\"\n\t      fi\n\t      func_append delfiles \" $output\"\n\n\t    else\n\t      output=\n\t    fi\n\n\t    ${skipped_export-false} && {\n\t      func_verbose \"generating symbol list for '$libname.la'\"\n\t      export_symbols=$output_objdir/$libname.exp\n\t      $opt_dry_run || $RM $export_symbols\n\t      libobjs=$output\n\t      # Append the command to create the export file.\n\t      test -z \"$concat_cmds\" || concat_cmds=$concat_cmds~\n\t      eval concat_cmds=\\\"\\$concat_cmds$export_symbols_cmds\\\"\n\t      if test -n \"$last_robj\"; then\n\t\teval concat_cmds=\\\"\\$concat_cmds~\\$RM $last_robj\\\"\n\t      fi\n\t    }\n\n\t    test -n \"$save_libobjs\" &&\n\t      func_verbose \"creating a temporary reloadable object file: $output\"\n\n\t    # Loop through the commands generated above and execute them.\n\t    save_ifs=$IFS; IFS='~'\n\t    for cmd in $concat_cmds; do\n\t      IFS=$save_ifs\n\t      $opt_quiet || {\n\t\t  func_quote_for_expand \"$cmd\"\n\t\t  eval \"func_echo $func_quote_for_expand_result\"\n\t      }\n\t      $opt_dry_run || eval \"$cmd\" || {\n\t\tlt_exit=$?\n\n\t\t# Restore the uninstalled library and exit\n\t\tif test relink = \"$opt_mode\"; then\n\t\t  ( cd \"$output_objdir\" && \\\n\t\t    $RM \"${realname}T\" && \\\n\t\t    $MV \"${realname}U\" \"$realname\" )\n\t\tfi\n\n\t\texit $lt_exit\n\t      }\n\t    done\n\t    IFS=$save_ifs\n\n\t    if test -n \"$export_symbols_regex\" && ${skipped_export-false}; then\n\t      func_show_eval '$EGREP -e \"$export_symbols_regex\" \"$export_symbols\" > \"${export_symbols}T\"'\n\t      func_show_eval '$MV \"${export_symbols}T\" \"$export_symbols\"'\n\t    fi\n\t  fi\n\n          ${skipped_export-false} && {\n\t    if test -n \"$export_symbols\" && test -n \"$include_expsyms\"; then\n\t      tmp_export_symbols=$export_symbols\n\t      test -n \"$orig_export_symbols\" && tmp_export_symbols=$orig_export_symbols\n\t      $opt_dry_run || eval '$ECHO \"$include_expsyms\" | $SP2NL >> \"$tmp_export_symbols\"'\n\t    fi\n\n\t    if test -n \"$orig_export_symbols\"; then\n\t      # The given exports_symbols file has to be filtered, so filter it.\n\t      func_verbose \"filter symbol list for '$libname.la' to tag DATA exports\"\n\t      # FIXME: $output_objdir/$libname.filter potentially contains lots of\n\t      # 's' commands, which not all seds can handle. GNU sed should be fine\n\t      # though. Also, the filter scales superlinearly with the number of\n\t      # global variables. join(1) would be nice here, but unfortunately\n\t      # isn't a blessed tool.\n\t      $opt_dry_run || $SED -e '/[ ,]DATA/!d;s,\\(.*\\)\\([ \\,].*\\),s|^\\1$|\\1\\2|,' < $export_symbols > $output_objdir/$libname.filter\n\t      func_append delfiles \" $export_symbols $output_objdir/$libname.filter\"\n\t      export_symbols=$output_objdir/$libname.def\n\t      $opt_dry_run || $SED -f $output_objdir/$libname.filter < $orig_export_symbols > $export_symbols\n\t    fi\n\t  }\n\n\t  libobjs=$output\n\t  # Restore the value of output.\n\t  output=$save_output\n\n\t  if test -n \"$convenience\" && test -n \"$whole_archive_flag_spec\"; then\n\t    eval libobjs=\\\"\\$libobjs $whole_archive_flag_spec\\\"\n\t    test \"X$libobjs\" = \"X \" && libobjs=\n\t  fi\n\t  # Expand the library linking commands again to reset the\n\t  # value of $libobjs for piecewise linking.\n\n\t  # Do each of the archive commands.\n\t  if test yes = \"$module\" && test -n \"$module_cmds\"; then\n\t    if test -n \"$export_symbols\" && test -n \"$module_expsym_cmds\"; then\n\t      cmds=$module_expsym_cmds\n\t    else\n\t      cmds=$module_cmds\n\t    fi\n\t  else\n\t    if test -n \"$export_symbols\" && test -n \"$archive_expsym_cmds\"; then\n\t      cmds=$archive_expsym_cmds\n\t    else\n\t      cmds=$archive_cmds\n\t    fi\n\t  fi\n\tfi\n\n\tif test -n \"$delfiles\"; then\n\t  # Append the command to remove temporary files to $cmds.\n\t  eval cmds=\\\"\\$cmds~\\$RM $delfiles\\\"\n\tfi\n\n\t# Add any objects from preloaded convenience libraries\n\tif test -n \"$dlprefiles\"; then\n\t  gentop=$output_objdir/${outputname}x\n\t  func_append generated \" $gentop\"\n\n\t  func_extract_archives $gentop $dlprefiles\n\t  func_append libobjs \" $func_extract_archives_result\"\n\t  test \"X$libobjs\" = \"X \" && libobjs=\n\tfi\n\n\tsave_ifs=$IFS; IFS='~'\n\tfor cmd in $cmds; do\n\t  IFS=$sp$nl\n\t  eval cmd=\\\"$cmd\\\"\n\t  IFS=$save_ifs\n\t  $opt_quiet || {\n\t    func_quote_for_expand \"$cmd\"\n\t    eval \"func_echo $func_quote_for_expand_result\"\n\t  }\n\t  $opt_dry_run || eval \"$cmd\" || {\n\t    lt_exit=$?\n\n\t    # Restore the uninstalled library and exit\n\t    if test relink = \"$opt_mode\"; then\n\t      ( cd \"$output_objdir\" && \\\n\t        $RM \"${realname}T\" && \\\n\t\t$MV \"${realname}U\" \"$realname\" )\n\t    fi\n\n\t    exit $lt_exit\n\t  }\n\tdone\n\tIFS=$save_ifs\n\n\t# Restore the uninstalled library and exit\n\tif test relink = \"$opt_mode\"; then\n\t  $opt_dry_run || eval '(cd $output_objdir && $RM ${realname}T && $MV $realname ${realname}T && $MV ${realname}U $realname)' || exit $?\n\n\t  if test -n \"$convenience\"; then\n\t    if test -z \"$whole_archive_flag_spec\"; then\n\t      func_show_eval '${RM}r \"$gentop\"'\n\t    fi\n\t  fi\n\n\t  exit $EXIT_SUCCESS\n\tfi\n\n\t# Create links to the real library.\n\tfor linkname in $linknames; do\n\t  if test \"$realname\" != \"$linkname\"; then\n\t    func_show_eval '(cd \"$output_objdir\" && $RM \"$linkname\" && $LN_S \"$realname\" \"$linkname\")' 'exit $?'\n\t  fi\n\tdone\n\n\t# If -module or -export-dynamic was specified, set the dlname.\n\tif test yes = \"$module\" || test yes = \"$export_dynamic\"; then\n\t  # On all known operating systems, these are identical.\n\t  dlname=$soname\n\tfi\n      fi\n      ;;\n\n    obj)\n      if test -n \"$dlfiles$dlprefiles\" || test no != \"$dlself\"; then\n\tfunc_warning \"'-dlopen' is ignored for objects\"\n      fi\n\n      case \" $deplibs\" in\n      *\\ -l* | *\\ -L*)\n\tfunc_warning \"'-l' and '-L' are ignored for objects\" ;;\n      esac\n\n      test -n \"$rpath\" && \\\n\tfunc_warning \"'-rpath' is ignored for objects\"\n\n      test -n \"$xrpath\" && \\\n\tfunc_warning \"'-R' is ignored for objects\"\n\n      test -n \"$vinfo\" && \\\n\tfunc_warning \"'-version-info' is ignored for objects\"\n\n      test -n \"$release\" && \\\n\tfunc_warning \"'-release' is ignored for objects\"\n\n      case $output in\n      *.lo)\n\ttest -n \"$objs$old_deplibs\" && \\\n\t  func_fatal_error \"cannot build library object '$output' from non-libtool objects\"\n\n\tlibobj=$output\n\tfunc_lo2o \"$libobj\"\n\tobj=$func_lo2o_result\n\t;;\n      *)\n\tlibobj=\n\tobj=$output\n\t;;\n      esac\n\n      # Delete the old objects.\n      $opt_dry_run || $RM $obj $libobj\n\n      # Objects from convenience libraries.  This assumes\n      # single-version convenience libraries.  Whenever we create\n      # different ones for PIC/non-PIC, this we'll have to duplicate\n      # the extraction.\n      reload_conv_objs=\n      gentop=\n      # if reload_cmds runs $LD directly, get rid of -Wl from\n      # whole_archive_flag_spec and hope we can get by with turning comma\n      # into space.\n      case $reload_cmds in\n        *\\$LD[\\ \\$]*) wl= ;;\n      esac\n      if test -n \"$convenience\"; then\n\tif test -n \"$whole_archive_flag_spec\"; then\n\t  eval tmp_whole_archive_flags=\\\"$whole_archive_flag_spec\\\"\n\t  test -n \"$wl\" || tmp_whole_archive_flags=`$ECHO \"$tmp_whole_archive_flags\" | $SED 's|,| |g'`\n\t  reload_conv_objs=$reload_objs\\ $tmp_whole_archive_flags\n\telse\n\t  gentop=$output_objdir/${obj}x\n\t  func_append generated \" $gentop\"\n\n\t  func_extract_archives $gentop $convenience\n\t  reload_conv_objs=\"$reload_objs $func_extract_archives_result\"\n\tfi\n      fi\n\n      # If we're not building shared, we need to use non_pic_objs\n      test yes = \"$build_libtool_libs\" || libobjs=$non_pic_objects\n\n      # Create the old-style object.\n      reload_objs=$objs$old_deplibs' '`$ECHO \"$libobjs\" | $SP2NL | $SED \"/\\.$libext$/d; /\\.lib$/d; $lo2o\" | $NL2SP`' '$reload_conv_objs\n\n      output=$obj\n      func_execute_cmds \"$reload_cmds\" 'exit $?'\n\n      # Exit if we aren't doing a library object file.\n      if test -z \"$libobj\"; then\n\tif test -n \"$gentop\"; then\n\t  func_show_eval '${RM}r \"$gentop\"'\n\tfi\n\n\texit $EXIT_SUCCESS\n      fi\n\n      test yes = \"$build_libtool_libs\" || {\n\tif test -n \"$gentop\"; then\n\t  func_show_eval '${RM}r \"$gentop\"'\n\tfi\n\n\t# Create an invalid libtool object if no PIC, so that we don't\n\t# accidentally link it into a program.\n\t# $show \"echo timestamp > $libobj\"\n\t# $opt_dry_run || eval \"echo timestamp > $libobj\" || exit $?\n\texit $EXIT_SUCCESS\n      }\n\n      if test -n \"$pic_flag\" || test default != \"$pic_mode\"; then\n\t# Only do commands if we really have different PIC objects.\n\treload_objs=\"$libobjs $reload_conv_objs\"\n\toutput=$libobj\n\tfunc_execute_cmds \"$reload_cmds\" 'exit $?'\n      fi\n\n      if test -n \"$gentop\"; then\n\tfunc_show_eval '${RM}r \"$gentop\"'\n      fi\n\n      exit $EXIT_SUCCESS\n      ;;\n\n    prog)\n      case $host in\n\t*cygwin*) func_stripname '' '.exe' \"$output\"\n\t          output=$func_stripname_result.exe;;\n      esac\n      test -n \"$vinfo\" && \\\n\tfunc_warning \"'-version-info' is ignored for programs\"\n\n      test -n \"$release\" && \\\n\tfunc_warning \"'-release' is ignored for programs\"\n\n      $preload \\\n\t&& test unknown,unknown,unknown = \"$dlopen_support,$dlopen_self,$dlopen_self_static\" \\\n\t&& func_warning \"'LT_INIT([dlopen])' not used. Assuming no dlopen support.\"\n\n      case $host in\n      *-*-rhapsody* | *-*-darwin1.[012])\n\t# On Rhapsody replace the C library is the System framework\n\tcompile_deplibs=`$ECHO \" $compile_deplibs\" | $SED 's/ -lc / System.ltframework /'`\n\tfinalize_deplibs=`$ECHO \" $finalize_deplibs\" | $SED 's/ -lc / System.ltframework /'`\n\t;;\n      esac\n\n      case $host in\n      *-*-darwin*)\n\t# Don't allow lazy linking, it breaks C++ global constructors\n\t# But is supposedly fixed on 10.4 or later (yay!).\n\tif test CXX = \"$tagname\"; then\n\t  case ${MACOSX_DEPLOYMENT_TARGET-10.0} in\n\t    10.[0123])\n\t      func_append compile_command \" $wl-bind_at_load\"\n\t      func_append finalize_command \" $wl-bind_at_load\"\n\t    ;;\n\t  esac\n\tfi\n\t# Time to change all our \"foo.ltframework\" stuff back to \"-framework foo\"\n\tcompile_deplibs=`$ECHO \" $compile_deplibs\" | $SED 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\tfinalize_deplibs=`$ECHO \" $finalize_deplibs\" | $SED 's% \\([^ $]*\\).ltframework% -framework \\1%g'`\n\t;;\n      esac\n\n\n      # move library search paths that coincide with paths to not yet\n      # installed libraries to the beginning of the library search list\n      new_libs=\n      for path in $notinst_path; do\n\tcase \" $new_libs \" in\n\t*\" -L$path/$objdir \"*) ;;\n\t*)\n\t  case \" $compile_deplibs \" in\n\t  *\" -L$path/$objdir \"*)\n\t    func_append new_libs \" -L$path/$objdir\" ;;\n\t  esac\n\t  ;;\n\tesac\n      done\n      for deplib in $compile_deplibs; do\n\tcase $deplib in\n\t-L*)\n\t  case \" $new_libs \" in\n\t  *\" $deplib \"*) ;;\n\t  *) func_append new_libs \" $deplib\" ;;\n\t  esac\n\t  ;;\n\t*) func_append new_libs \" $deplib\" ;;\n\tesac\n      done\n      compile_deplibs=$new_libs\n\n\n      func_append compile_command \" $compile_deplibs\"\n      func_append finalize_command \" $finalize_deplibs\"\n\n      if test -n \"$rpath$xrpath\"; then\n\t# If the user specified any rpath flags, then add them.\n\tfor libdir in $rpath $xrpath; do\n\t  # This is the magic to use -rpath.\n\t  case \"$finalize_rpath \" in\n\t  *\" $libdir \"*) ;;\n\t  *) func_append finalize_rpath \" $libdir\" ;;\n\t  esac\n\tdone\n      fi\n\n      # Now hardcode the library paths\n      rpath=\n      hardcode_libdirs=\n      for libdir in $compile_rpath $finalize_rpath; do\n\tif test -n \"$hardcode_libdir_flag_spec\"; then\n\t  if test -n \"$hardcode_libdir_separator\"; then\n\t    if test -z \"$hardcode_libdirs\"; then\n\t      hardcode_libdirs=$libdir\n\t    else\n\t      # Just accumulate the unique libdirs.\n\t      case $hardcode_libdir_separator$hardcode_libdirs$hardcode_libdir_separator in\n\t      *\"$hardcode_libdir_separator$libdir$hardcode_libdir_separator\"*)\n\t\t;;\n\t      *)\n\t\tfunc_append hardcode_libdirs \"$hardcode_libdir_separator$libdir\"\n\t\t;;\n\t      esac\n\t    fi\n\t  else\n\t    eval flag=\\\"$hardcode_libdir_flag_spec\\\"\n\t    func_append rpath \" $flag\"\n\t  fi\n\telif test -n \"$runpath_var\"; then\n\t  case \"$perm_rpath \" in\n\t  *\" $libdir \"*) ;;\n\t  *) func_append perm_rpath \" $libdir\" ;;\n\t  esac\n\tfi\n\tcase $host in\n\t*-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-os2* | *-cegcc*)\n\t  testbindir=`$ECHO \"$libdir\" | $SED -e 's*/lib$*/bin*'`\n\t  case :$dllsearchpath: in\n\t  *\":$libdir:\"*) ;;\n\t  ::) dllsearchpath=$libdir;;\n\t  *) func_append dllsearchpath \":$libdir\";;\n\t  esac\n\t  case :$dllsearchpath: in\n\t  *\":$testbindir:\"*) ;;\n\t  ::) dllsearchpath=$testbindir;;\n\t  *) func_append dllsearchpath \":$testbindir\";;\n\t  esac\n\t  ;;\n\tesac\n      done\n      # Substitute the hardcoded libdirs into the rpath.\n      if test -n \"$hardcode_libdir_separator\" &&\n\t test -n \"$hardcode_libdirs\"; then\n\tlibdir=$hardcode_libdirs\n\teval rpath=\\\" $hardcode_libdir_flag_spec\\\"\n      fi\n      compile_rpath=$rpath\n\n      rpath=\n      hardcode_libdirs=\n      for libdir in $finalize_rpath; do\n\tif test -n \"$hardcode_libdir_flag_spec\"; then\n\t  if test -n \"$hardcode_libdir_separator\"; then\n\t    if test -z \"$hardcode_libdirs\"; then\n\t      hardcode_libdirs=$libdir\n\t    else\n\t      # Just accumulate the unique libdirs.\n\t      case $hardcode_libdir_separator$hardcode_libdirs$hardcode_libdir_separator in\n\t      *\"$hardcode_libdir_separator$libdir$hardcode_libdir_separator\"*)\n\t\t;;\n\t      *)\n\t\tfunc_append hardcode_libdirs \"$hardcode_libdir_separator$libdir\"\n\t\t;;\n\t      esac\n\t    fi\n\t  else\n\t    eval flag=\\\"$hardcode_libdir_flag_spec\\\"\n\t    func_append rpath \" $flag\"\n\t  fi\n\telif test -n \"$runpath_var\"; then\n\t  case \"$finalize_perm_rpath \" in\n\t  *\" $libdir \"*) ;;\n\t  *) func_append finalize_perm_rpath \" $libdir\" ;;\n\t  esac\n\tfi\n      done\n      # Substitute the hardcoded libdirs into the rpath.\n      if test -n \"$hardcode_libdir_separator\" &&\n\t test -n \"$hardcode_libdirs\"; then\n\tlibdir=$hardcode_libdirs\n\teval rpath=\\\" $hardcode_libdir_flag_spec\\\"\n      fi\n      finalize_rpath=$rpath\n\n      if test -n \"$libobjs\" && test yes = \"$build_old_libs\"; then\n\t# Transform all the library objects into standard objects.\n\tcompile_command=`$ECHO \"$compile_command\" | $SP2NL | $SED \"$lo2o\" | $NL2SP`\n\tfinalize_command=`$ECHO \"$finalize_command\" | $SP2NL | $SED \"$lo2o\" | $NL2SP`\n      fi\n\n      func_generate_dlsyms \"$outputname\" \"@PROGRAM@\" false\n\n      # template prelinking step\n      if test -n \"$prelink_cmds\"; then\n\tfunc_execute_cmds \"$prelink_cmds\" 'exit $?'\n      fi\n\n      wrappers_required=:\n      case $host in\n      *cegcc* | *mingw32ce*)\n        # Disable wrappers for cegcc and mingw32ce hosts, we are cross compiling anyway.\n        wrappers_required=false\n        ;;\n      *cygwin* | *mingw* )\n        test yes = \"$build_libtool_libs\" || wrappers_required=false\n        ;;\n      *)\n        if test no = \"$need_relink\" || test yes != \"$build_libtool_libs\"; then\n          wrappers_required=false\n        fi\n        ;;\n      esac\n      $wrappers_required || {\n\t# Replace the output file specification.\n\tcompile_command=`$ECHO \"$compile_command\" | $SED 's%@OUTPUT@%'\"$output\"'%g'`\n\tlink_command=$compile_command$compile_rpath\n\n\t# We have no uninstalled library dependencies, so finalize right now.\n\texit_status=0\n\tfunc_show_eval \"$link_command\" 'exit_status=$?'\n\n\tif test -n \"$postlink_cmds\"; then\n\t  func_to_tool_file \"$output\"\n\t  postlink_cmds=`func_echo_all \"$postlink_cmds\" | $SED -e 's%@OUTPUT@%'\"$output\"'%g' -e 's%@TOOL_OUTPUT@%'\"$func_to_tool_file_result\"'%g'`\n\t  func_execute_cmds \"$postlink_cmds\" 'exit $?'\n\tfi\n\n\t# Delete the generated files.\n\tif test -f \"$output_objdir/${outputname}S.$objext\"; then\n\t  func_show_eval '$RM \"$output_objdir/${outputname}S.$objext\"'\n\tfi\n\n\texit $exit_status\n      }\n\n      if test -n \"$compile_shlibpath$finalize_shlibpath\"; then\n\tcompile_command=\"$shlibpath_var=\\\"$compile_shlibpath$finalize_shlibpath\\$$shlibpath_var\\\" $compile_command\"\n      fi\n      if test -n \"$finalize_shlibpath\"; then\n\tfinalize_command=\"$shlibpath_var=\\\"$finalize_shlibpath\\$$shlibpath_var\\\" $finalize_command\"\n      fi\n\n      compile_var=\n      finalize_var=\n      if test -n \"$runpath_var\"; then\n\tif test -n \"$perm_rpath\"; then\n\t  # We should set the runpath_var.\n\t  rpath=\n\t  for dir in $perm_rpath; do\n\t    func_append rpath \"$dir:\"\n\t  done\n\t  compile_var=\"$runpath_var=\\\"$rpath\\$$runpath_var\\\" \"\n\tfi\n\tif test -n \"$finalize_perm_rpath\"; then\n\t  # We should set the runpath_var.\n\t  rpath=\n\t  for dir in $finalize_perm_rpath; do\n\t    func_append rpath \"$dir:\"\n\t  done\n\t  finalize_var=\"$runpath_var=\\\"$rpath\\$$runpath_var\\\" \"\n\tfi\n      fi\n\n      if test yes = \"$no_install\"; then\n\t# We don't need to create a wrapper script.\n\tlink_command=$compile_var$compile_command$compile_rpath\n\t# Replace the output file specification.\n\tlink_command=`$ECHO \"$link_command\" | $SED 's%@OUTPUT@%'\"$output\"'%g'`\n\t# Delete the old output file.\n\t$opt_dry_run || $RM $output\n\t# Link the executable and exit\n\tfunc_show_eval \"$link_command\" 'exit $?'\n\n\tif test -n \"$postlink_cmds\"; then\n\t  func_to_tool_file \"$output\"\n\t  postlink_cmds=`func_echo_all \"$postlink_cmds\" | $SED -e 's%@OUTPUT@%'\"$output\"'%g' -e 's%@TOOL_OUTPUT@%'\"$func_to_tool_file_result\"'%g'`\n\t  func_execute_cmds \"$postlink_cmds\" 'exit $?'\n\tfi\n\n\texit $EXIT_SUCCESS\n      fi\n\n      case $hardcode_action,$fast_install in\n        relink,*)\n\t  # Fast installation is not supported\n\t  link_command=$compile_var$compile_command$compile_rpath\n\t  relink_command=$finalize_var$finalize_command$finalize_rpath\n\n\t  func_warning \"this platform does not like uninstalled shared libraries\"\n\t  func_warning \"'$output' will be relinked during installation\"\n\t  ;;\n        *,yes)\n\t  link_command=$finalize_var$compile_command$finalize_rpath\n\t  relink_command=`$ECHO \"$compile_var$compile_command$compile_rpath\" | $SED 's%@OUTPUT@%\\$progdir/\\$file%g'`\n          ;;\n\t*,no)\n\t  link_command=$compile_var$compile_command$compile_rpath\n\t  relink_command=$finalize_var$finalize_command$finalize_rpath\n          ;;\n\t*,needless)\n\t  link_command=$finalize_var$compile_command$finalize_rpath\n\t  relink_command=\n          ;;\n      esac\n\n      # Replace the output file specification.\n      link_command=`$ECHO \"$link_command\" | $SED 's%@OUTPUT@%'\"$output_objdir/$outputname\"'%g'`\n\n      # Delete the old output files.\n      $opt_dry_run || $RM $output $output_objdir/$outputname $output_objdir/lt-$outputname\n\n      func_show_eval \"$link_command\" 'exit $?'\n\n      if test -n \"$postlink_cmds\"; then\n\tfunc_to_tool_file \"$output_objdir/$outputname\"\n\tpostlink_cmds=`func_echo_all \"$postlink_cmds\" | $SED -e 's%@OUTPUT@%'\"$output_objdir/$outputname\"'%g' -e 's%@TOOL_OUTPUT@%'\"$func_to_tool_file_result\"'%g'`\n\tfunc_execute_cmds \"$postlink_cmds\" 'exit $?'\n      fi\n\n      # Now create the wrapper script.\n      func_verbose \"creating $output\"\n\n      # Quote the relink command for shipping.\n      if test -n \"$relink_command\"; then\n\t# Preserve any variables that may affect compiler behavior\n\tfor var in $variables_saved_for_relink; do\n\t  if eval test -z \\\"\\${$var+set}\\\"; then\n\t    relink_command=\"{ test -z \\\"\\${$var+set}\\\" || $lt_unset $var || { $var=; export $var; }; }; $relink_command\"\n\t  elif eval var_value=\\$$var; test -z \"$var_value\"; then\n\t    relink_command=\"$var=; export $var; $relink_command\"\n\t  else\n\t    func_quote_for_eval \"$var_value\"\n\t    relink_command=\"$var=$func_quote_for_eval_result; export $var; $relink_command\"\n\t  fi\n\tdone\n\trelink_command=\"(cd `pwd`; $relink_command)\"\n\trelink_command=`$ECHO \"$relink_command\" | $SED \"$sed_quote_subst\"`\n      fi\n\n      # Only actually do things if not in dry run mode.\n      $opt_dry_run || {\n\t# win32 will think the script is a binary if it has\n\t# a .exe suffix, so we strip it off here.\n\tcase $output in\n\t  *.exe) func_stripname '' '.exe' \"$output\"\n\t         output=$func_stripname_result ;;\n\tesac\n\t# test for cygwin because mv fails w/o .exe extensions\n\tcase $host in\n\t  *cygwin*)\n\t    exeext=.exe\n\t    func_stripname '' '.exe' \"$outputname\"\n\t    outputname=$func_stripname_result ;;\n\t  *) exeext= ;;\n\tesac\n\tcase $host in\n\t  *cygwin* | *mingw* )\n\t    func_dirname_and_basename \"$output\" \"\" \".\"\n\t    output_name=$func_basename_result\n\t    output_path=$func_dirname_result\n\t    cwrappersource=$output_path/$objdir/lt-$output_name.c\n\t    cwrapper=$output_path/$output_name.exe\n\t    $RM $cwrappersource $cwrapper\n\t    trap \"$RM $cwrappersource $cwrapper; exit $EXIT_FAILURE\" 1 2 15\n\n\t    func_emit_cwrapperexe_src > $cwrappersource\n\n\t    # The wrapper executable is built using the $host compiler,\n\t    # because it contains $host paths and files. If cross-\n\t    # compiling, it, like the target executable, must be\n\t    # executed on the $host or under an emulation environment.\n\t    $opt_dry_run || {\n\t      $LTCC $LTCFLAGS -o $cwrapper $cwrappersource\n\t      $STRIP $cwrapper\n\t    }\n\n\t    # Now, create the wrapper script for func_source use:\n\t    func_ltwrapper_scriptname $cwrapper\n\t    $RM $func_ltwrapper_scriptname_result\n\t    trap \"$RM $func_ltwrapper_scriptname_result; exit $EXIT_FAILURE\" 1 2 15\n\t    $opt_dry_run || {\n\t      # note: this script will not be executed, so do not chmod.\n\t      if test \"x$build\" = \"x$host\"; then\n\t\t$cwrapper --lt-dump-script > $func_ltwrapper_scriptname_result\n\t      else\n\t\tfunc_emit_wrapper no > $func_ltwrapper_scriptname_result\n\t      fi\n\t    }\n\t  ;;\n\t  * )\n\t    $RM $output\n\t    trap \"$RM $output; exit $EXIT_FAILURE\" 1 2 15\n\n\t    func_emit_wrapper no > $output\n\t    chmod +x $output\n\t  ;;\n\tesac\n      }\n      exit $EXIT_SUCCESS\n      ;;\n    esac\n\n    # See if we need to build an old-fashioned archive.\n    for oldlib in $oldlibs; do\n\n      case $build_libtool_libs in\n        convenience)\n\t  oldobjs=\"$libobjs_save $symfileobj\"\n\t  addlibs=$convenience\n\t  build_libtool_libs=no\n\t  ;;\n\tmodule)\n\t  oldobjs=$libobjs_save\n\t  addlibs=$old_convenience\n\t  build_libtool_libs=no\n          ;;\n\t*)\n\t  oldobjs=\"$old_deplibs $non_pic_objects\"\n\t  $preload && test -f \"$symfileobj\" \\\n\t    && func_append oldobjs \" $symfileobj\"\n\t  addlibs=$old_convenience\n\t  ;;\n      esac\n\n      if test -n \"$addlibs\"; then\n\tgentop=$output_objdir/${outputname}x\n\tfunc_append generated \" $gentop\"\n\n\tfunc_extract_archives $gentop $addlibs\n\tfunc_append oldobjs \" $func_extract_archives_result\"\n      fi\n\n      # Do each command in the archive commands.\n      if test -n \"$old_archive_from_new_cmds\" && test yes = \"$build_libtool_libs\"; then\n\tcmds=$old_archive_from_new_cmds\n      else\n\n\t# Add any objects from preloaded convenience libraries\n\tif test -n \"$dlprefiles\"; then\n\t  gentop=$output_objdir/${outputname}x\n\t  func_append generated \" $gentop\"\n\n\t  func_extract_archives $gentop $dlprefiles\n\t  func_append oldobjs \" $func_extract_archives_result\"\n\tfi\n\n\t# POSIX demands no paths to be encoded in archives.  We have\n\t# to avoid creating archives with duplicate basenames if we\n\t# might have to extract them afterwards, e.g., when creating a\n\t# static archive out of a convenience library, or when linking\n\t# the entirety of a libtool archive into another (currently\n\t# not supported by libtool).\n\tif (for obj in $oldobjs\n\t    do\n\t      func_basename \"$obj\"\n\t      $ECHO \"$func_basename_result\"\n\t    done | sort | sort -uc >/dev/null 2>&1); then\n\t  :\n\telse\n\t  echo \"copying selected object files to avoid basename conflicts...\"\n\t  gentop=$output_objdir/${outputname}x\n\t  func_append generated \" $gentop\"\n\t  func_mkdir_p \"$gentop\"\n\t  save_oldobjs=$oldobjs\n\t  oldobjs=\n\t  counter=1\n\t  for obj in $save_oldobjs\n\t  do\n\t    func_basename \"$obj\"\n\t    objbase=$func_basename_result\n\t    case \" $oldobjs \" in\n\t    \" \") oldobjs=$obj ;;\n\t    *[\\ /]\"$objbase \"*)\n\t      while :; do\n\t\t# Make sure we don't pick an alternate name that also\n\t\t# overlaps.\n\t\tnewobj=lt$counter-$objbase\n\t\tfunc_arith $counter + 1\n\t\tcounter=$func_arith_result\n\t\tcase \" $oldobjs \" in\n\t\t*[\\ /]\"$newobj \"*) ;;\n\t\t*) if test ! -f \"$gentop/$newobj\"; then break; fi ;;\n\t\tesac\n\t      done\n\t      func_show_eval \"ln $obj $gentop/$newobj || cp $obj $gentop/$newobj\"\n\t      func_append oldobjs \" $gentop/$newobj\"\n\t      ;;\n\t    *) func_append oldobjs \" $obj\" ;;\n\t    esac\n\t  done\n\tfi\n\tfunc_to_tool_file \"$oldlib\" func_convert_file_msys_to_w32\n\ttool_oldlib=$func_to_tool_file_result\n\teval cmds=\\\"$old_archive_cmds\\\"\n\n\tfunc_len \" $cmds\"\n\tlen=$func_len_result\n\tif test \"$len\" -lt \"$max_cmd_len\" || test \"$max_cmd_len\" -le -1; then\n\t  cmds=$old_archive_cmds\n\telif test -n \"$archiver_list_spec\"; then\n\t  func_verbose \"using command file archive linking...\"\n\t  for obj in $oldobjs\n\t  do\n\t    func_to_tool_file \"$obj\"\n\t    $ECHO \"$func_to_tool_file_result\"\n\t  done > $output_objdir/$libname.libcmd\n\t  func_to_tool_file \"$output_objdir/$libname.libcmd\"\n\t  oldobjs=\" $archiver_list_spec$func_to_tool_file_result\"\n\t  cmds=$old_archive_cmds\n\telse\n\t  # the command line is too long to link in one step, link in parts\n\t  func_verbose \"using piecewise archive linking...\"\n\t  save_RANLIB=$RANLIB\n\t  RANLIB=:\n\t  objlist=\n\t  concat_cmds=\n\t  save_oldobjs=$oldobjs\n\t  oldobjs=\n\t  # Is there a better way of finding the last object in the list?\n\t  for obj in $save_oldobjs\n\t  do\n\t    last_oldobj=$obj\n\t  done\n\t  eval test_cmds=\\\"$old_archive_cmds\\\"\n\t  func_len \" $test_cmds\"\n\t  len0=$func_len_result\n\t  len=$len0\n\t  for obj in $save_oldobjs\n\t  do\n\t    func_len \" $obj\"\n\t    func_arith $len + $func_len_result\n\t    len=$func_arith_result\n\t    func_append objlist \" $obj\"\n\t    if test \"$len\" -lt \"$max_cmd_len\"; then\n\t      :\n\t    else\n\t      # the above command should be used before it gets too long\n\t      oldobjs=$objlist\n\t      if test \"$obj\" = \"$last_oldobj\"; then\n\t\tRANLIB=$save_RANLIB\n\t      fi\n\t      test -z \"$concat_cmds\" || concat_cmds=$concat_cmds~\n\t      eval concat_cmds=\\\"\\$concat_cmds$old_archive_cmds\\\"\n\t      objlist=\n\t      len=$len0\n\t    fi\n\t  done\n\t  RANLIB=$save_RANLIB\n\t  oldobjs=$objlist\n\t  if test -z \"$oldobjs\"; then\n\t    eval cmds=\\\"\\$concat_cmds\\\"\n\t  else\n\t    eval cmds=\\\"\\$concat_cmds~\\$old_archive_cmds\\\"\n\t  fi\n\tfi\n      fi\n      func_execute_cmds \"$cmds\" 'exit $?'\n    done\n\n    test -n \"$generated\" && \\\n      func_show_eval \"${RM}r$generated\"\n\n    # Now create the libtool archive.\n    case $output in\n    *.la)\n      old_library=\n      test yes = \"$build_old_libs\" && old_library=$libname.$libext\n      func_verbose \"creating $output\"\n\n      # Preserve any variables that may affect compiler behavior\n      for var in $variables_saved_for_relink; do\n\tif eval test -z \\\"\\${$var+set}\\\"; then\n\t  relink_command=\"{ test -z \\\"\\${$var+set}\\\" || $lt_unset $var || { $var=; export $var; }; }; $relink_command\"\n\telif eval var_value=\\$$var; test -z \"$var_value\"; then\n\t  relink_command=\"$var=; export $var; $relink_command\"\n\telse\n\t  func_quote_for_eval \"$var_value\"\n\t  relink_command=\"$var=$func_quote_for_eval_result; export $var; $relink_command\"\n\tfi\n      done\n      # Quote the link command for shipping.\n      relink_command=\"(cd `pwd`; $SHELL \\\"$progpath\\\" $preserve_args --mode=relink $libtool_args @inst_prefix_dir@)\"\n      relink_command=`$ECHO \"$relink_command\" | $SED \"$sed_quote_subst\"`\n      if test yes = \"$hardcode_automatic\"; then\n\trelink_command=\n      fi\n\n      # Only create the output if not a dry run.\n      $opt_dry_run || {\n\tfor installed in no yes; do\n\t  if test yes = \"$installed\"; then\n\t    if test -z \"$install_libdir\"; then\n\t      break\n\t    fi\n\t    output=$output_objdir/${outputname}i\n\t    # Replace all uninstalled libtool libraries with the installed ones\n\t    newdependency_libs=\n\t    for deplib in $dependency_libs; do\n\t      case $deplib in\n\t      *.la)\n\t\tfunc_basename \"$deplib\"\n\t\tname=$func_basename_result\n\t\tfunc_resolve_sysroot \"$deplib\"\n\t\teval libdir=`$SED -n -e 's/^libdir=\\(.*\\)$/\\1/p' $func_resolve_sysroot_result`\n\t\ttest -z \"$libdir\" && \\\n\t\t  func_fatal_error \"'$deplib' is not a valid libtool archive\"\n\t\tfunc_append newdependency_libs \" ${lt_sysroot:+=}$libdir/$name\"\n\t\t;;\n\t      -L*)\n\t\tfunc_stripname -L '' \"$deplib\"\n\t\tfunc_replace_sysroot \"$func_stripname_result\"\n\t\tfunc_append newdependency_libs \" -L$func_replace_sysroot_result\"\n\t\t;;\n\t      -R*)\n\t\tfunc_stripname -R '' \"$deplib\"\n\t\tfunc_replace_sysroot \"$func_stripname_result\"\n\t\tfunc_append newdependency_libs \" -R$func_replace_sysroot_result\"\n\t\t;;\n\t      *) func_append newdependency_libs \" $deplib\" ;;\n\t      esac\n\t    done\n\t    dependency_libs=$newdependency_libs\n\t    newdlfiles=\n\n\t    for lib in $dlfiles; do\n\t      case $lib in\n\t      *.la)\n\t        func_basename \"$lib\"\n\t\tname=$func_basename_result\n\t\teval libdir=`$SED -n -e 's/^libdir=\\(.*\\)$/\\1/p' $lib`\n\t\ttest -z \"$libdir\" && \\\n\t\t  func_fatal_error \"'$lib' is not a valid libtool archive\"\n\t\tfunc_append newdlfiles \" ${lt_sysroot:+=}$libdir/$name\"\n\t\t;;\n\t      *) func_append newdlfiles \" $lib\" ;;\n\t      esac\n\t    done\n\t    dlfiles=$newdlfiles\n\t    newdlprefiles=\n\t    for lib in $dlprefiles; do\n\t      case $lib in\n\t      *.la)\n\t\t# Only pass preopened files to the pseudo-archive (for\n\t\t# eventual linking with the app. that links it) if we\n\t\t# didn't already link the preopened objects directly into\n\t\t# the library:\n\t\tfunc_basename \"$lib\"\n\t\tname=$func_basename_result\n\t\teval libdir=`$SED -n -e 's/^libdir=\\(.*\\)$/\\1/p' $lib`\n\t\ttest -z \"$libdir\" && \\\n\t\t  func_fatal_error \"'$lib' is not a valid libtool archive\"\n\t\tfunc_append newdlprefiles \" ${lt_sysroot:+=}$libdir/$name\"\n\t\t;;\n\t      esac\n\t    done\n\t    dlprefiles=$newdlprefiles\n\t  else\n\t    newdlfiles=\n\t    for lib in $dlfiles; do\n\t      case $lib in\n\t\t[\\\\/]* | [A-Za-z]:[\\\\/]*) abs=$lib ;;\n\t\t*) abs=`pwd`\"/$lib\" ;;\n\t      esac\n\t      func_append newdlfiles \" $abs\"\n\t    done\n\t    dlfiles=$newdlfiles\n\t    newdlprefiles=\n\t    for lib in $dlprefiles; do\n\t      case $lib in\n\t\t[\\\\/]* | [A-Za-z]:[\\\\/]*) abs=$lib ;;\n\t\t*) abs=`pwd`\"/$lib\" ;;\n\t      esac\n\t      func_append newdlprefiles \" $abs\"\n\t    done\n\t    dlprefiles=$newdlprefiles\n\t  fi\n\t  $RM $output\n\t  # place dlname in correct position for cygwin\n\t  # In fact, it would be nice if we could use this code for all target\n\t  # systems that can't hard-code library paths into their executables\n\t  # and that have no shared library path variable independent of PATH,\n\t  # but it turns out we can't easily determine that from inspecting\n\t  # libtool variables, so we have to hard-code the OSs to which it\n\t  # applies here; at the moment, that means platforms that use the PE\n\t  # object format with DLL files.  See the long comment at the top of\n\t  # tests/bindir.at for full details.\n\t  tdlname=$dlname\n\t  case $host,$output,$installed,$module,$dlname in\n\t    *cygwin*,*lai,yes,no,*.dll | *mingw*,*lai,yes,no,*.dll | *cegcc*,*lai,yes,no,*.dll)\n\t      # If a -bindir argument was supplied, place the dll there.\n\t      if test -n \"$bindir\"; then\n\t\tfunc_relative_path \"$install_libdir\" \"$bindir\"\n\t\ttdlname=$func_relative_path_result/$dlname\n\t      else\n\t\t# Otherwise fall back on heuristic.\n\t\ttdlname=../bin/$dlname\n\t      fi\n\t      ;;\n\t  esac\n\t  $ECHO > $output \"\\\n# $outputname - a libtool library file\n# Generated by $PROGRAM (GNU $PACKAGE) $VERSION\n#\n# Please DO NOT delete this file!\n# It is necessary for linking the library.\n\n# The name that we can dlopen(3).\ndlname='$tdlname'\n\n# Names of this library.\nlibrary_names='$library_names'\n\n# The name of the static archive.\nold_library='$old_library'\n\n# Linker flags that cannot go in dependency_libs.\ninherited_linker_flags='$new_inherited_linker_flags'\n\n# Libraries that this one depends upon.\ndependency_libs='$dependency_libs'\n\n# Names of additional weak libraries provided by this library\nweak_library_names='$weak_libs'\n\n# Version information for $libname.\ncurrent=$current\nage=$age\nrevision=$revision\n\n# Is this an already installed library?\ninstalled=$installed\n\n# Should we warn about portability when linking against -modules?\nshouldnotlink=$module\n\n# Files to dlopen/dlpreopen\ndlopen='$dlfiles'\ndlpreopen='$dlprefiles'\n\n# Directory that this library needs to be installed in:\nlibdir='$install_libdir'\"\n\t  if test no,yes = \"$installed,$need_relink\"; then\n\t    $ECHO >> $output \"\\\nrelink_command=\\\"$relink_command\\\"\"\n\t  fi\n\tdone\n      }\n\n      # Do a symbolic link so that the libtool archive can be found in\n      # LD_LIBRARY_PATH before the program is installed.\n      func_show_eval '( cd \"$output_objdir\" && $RM \"$outputname\" && $LN_S \"../$outputname\" \"$outputname\" )' 'exit $?'\n      ;;\n    esac\n    exit $EXIT_SUCCESS\n}\n\nif test link = \"$opt_mode\" || test relink = \"$opt_mode\"; then\n  func_mode_link ${1+\"$@\"}\nfi\n\n\n# func_mode_uninstall arg...\nfunc_mode_uninstall ()\n{\n    $debug_cmd\n\n    RM=$nonopt\n    files=\n    rmforce=false\n    exit_status=0\n\n    # This variable tells wrapper scripts just to set variables rather\n    # than running their programs.\n    libtool_install_magic=$magic\n\n    for arg\n    do\n      case $arg in\n      -f) func_append RM \" $arg\"; rmforce=: ;;\n      -*) func_append RM \" $arg\" ;;\n      *) func_append files \" $arg\" ;;\n      esac\n    done\n\n    test -z \"$RM\" && \\\n      func_fatal_help \"you must specify an RM program\"\n\n    rmdirs=\n\n    for file in $files; do\n      func_dirname \"$file\" \"\" \".\"\n      dir=$func_dirname_result\n      if test . = \"$dir\"; then\n\todir=$objdir\n      else\n\todir=$dir/$objdir\n      fi\n      func_basename \"$file\"\n      name=$func_basename_result\n      test uninstall = \"$opt_mode\" && odir=$dir\n\n      # Remember odir for removal later, being careful to avoid duplicates\n      if test clean = \"$opt_mode\"; then\n\tcase \" $rmdirs \" in\n\t  *\" $odir \"*) ;;\n\t  *) func_append rmdirs \" $odir\" ;;\n\tesac\n      fi\n\n      # Don't error if the file doesn't exist and rm -f was used.\n      if { test -L \"$file\"; } >/dev/null 2>&1 ||\n\t { test -h \"$file\"; } >/dev/null 2>&1 ||\n\t test -f \"$file\"; then\n\t:\n      elif test -d \"$file\"; then\n\texit_status=1\n\tcontinue\n      elif $rmforce; then\n\tcontinue\n      fi\n\n      rmfiles=$file\n\n      case $name in\n      *.la)\n\t# Possibly a libtool archive, so verify it.\n\tif func_lalib_p \"$file\"; then\n\t  func_source $dir/$name\n\n\t  # Delete the libtool libraries and symlinks.\n\t  for n in $library_names; do\n\t    func_append rmfiles \" $odir/$n\"\n\t  done\n\t  test -n \"$old_library\" && func_append rmfiles \" $odir/$old_library\"\n\n\t  case $opt_mode in\n\t  clean)\n\t    case \" $library_names \" in\n\t    *\" $dlname \"*) ;;\n\t    *) test -n \"$dlname\" && func_append rmfiles \" $odir/$dlname\" ;;\n\t    esac\n\t    test -n \"$libdir\" && func_append rmfiles \" $odir/$name $odir/${name}i\"\n\t    ;;\n\t  uninstall)\n\t    if test -n \"$library_names\"; then\n\t      # Do each command in the postuninstall commands.\n\t      func_execute_cmds \"$postuninstall_cmds\" '$rmforce || exit_status=1'\n\t    fi\n\n\t    if test -n \"$old_library\"; then\n\t      # Do each command in the old_postuninstall commands.\n\t      func_execute_cmds \"$old_postuninstall_cmds\" '$rmforce || exit_status=1'\n\t    fi\n\t    # FIXME: should reinstall the best remaining shared library.\n\t    ;;\n\t  esac\n\tfi\n\t;;\n\n      *.lo)\n\t# Possibly a libtool object, so verify it.\n\tif func_lalib_p \"$file\"; then\n\n\t  # Read the .lo file\n\t  func_source $dir/$name\n\n\t  # Add PIC object to the list of files to remove.\n\t  if test -n \"$pic_object\" && test none != \"$pic_object\"; then\n\t    func_append rmfiles \" $dir/$pic_object\"\n\t  fi\n\n\t  # Add non-PIC object to the list of files to remove.\n\t  if test -n \"$non_pic_object\" && test none != \"$non_pic_object\"; then\n\t    func_append rmfiles \" $dir/$non_pic_object\"\n\t  fi\n\tfi\n\t;;\n\n      *)\n\tif test clean = \"$opt_mode\"; then\n\t  noexename=$name\n\t  case $file in\n\t  *.exe)\n\t    func_stripname '' '.exe' \"$file\"\n\t    file=$func_stripname_result\n\t    func_stripname '' '.exe' \"$name\"\n\t    noexename=$func_stripname_result\n\t    # $file with .exe has already been added to rmfiles,\n\t    # add $file without .exe\n\t    func_append rmfiles \" $file\"\n\t    ;;\n\t  esac\n\t  # Do a test to see if this is a libtool program.\n\t  if func_ltwrapper_p \"$file\"; then\n\t    if func_ltwrapper_executable_p \"$file\"; then\n\t      func_ltwrapper_scriptname \"$file\"\n\t      relink_command=\n\t      func_source $func_ltwrapper_scriptname_result\n\t      func_append rmfiles \" $func_ltwrapper_scriptname_result\"\n\t    else\n\t      relink_command=\n\t      func_source $dir/$noexename\n\t    fi\n\n\t    # note $name still contains .exe if it was in $file originally\n\t    # as does the version of $file that was added into $rmfiles\n\t    func_append rmfiles \" $odir/$name $odir/${name}S.$objext\"\n\t    if test yes = \"$fast_install\" && test -n \"$relink_command\"; then\n\t      func_append rmfiles \" $odir/lt-$name\"\n\t    fi\n\t    if test \"X$noexename\" != \"X$name\"; then\n\t      func_append rmfiles \" $odir/lt-$noexename.c\"\n\t    fi\n\t  fi\n\tfi\n\t;;\n      esac\n      func_show_eval \"$RM $rmfiles\" 'exit_status=1'\n    done\n\n    # Try to remove the $objdir's in the directories where we deleted files\n    for dir in $rmdirs; do\n      if test -d \"$dir\"; then\n\tfunc_show_eval \"rmdir $dir >/dev/null 2>&1\"\n      fi\n    done\n\n    exit $exit_status\n}\n\nif test uninstall = \"$opt_mode\" || test clean = \"$opt_mode\"; then\n  func_mode_uninstall ${1+\"$@\"}\nfi\n\ntest -z \"$opt_mode\" && {\n  help=$generic_help\n  func_fatal_help \"you must specify a MODE\"\n}\n\ntest -z \"$exec_cmd\" && \\\n  func_fatal_help \"invalid operation mode '$opt_mode'\"\n\nif test -n \"$exec_cmd\"; then\n  eval exec \"$exec_cmd\"\n  exit $EXIT_FAILURE\nfi\n\nexit $exit_status\n\n\n# The TAGs below are defined such that we never get into a situation\n# where we disable both kinds of libraries.  Given conflicting\n# choices, we go for a static library, that is the most portable,\n# since we can't tell whether shared libraries were disabled because\n# the user asked for that or because the platform doesn't support\n# them.  This is particularly important on AIX, because we don't\n# support having both static and shared libraries enabled at the same\n# time on that platform, so we default to a shared-only configuration.\n# If a disable-shared tag is given, we'll fallback to a static-only\n# configuration.  But we'll never go from static-only to shared-only.\n\n# ### BEGIN LIBTOOL TAG CONFIG: disable-shared\nbuild_libtool_libs=no\nbuild_old_libs=yes\n# ### END LIBTOOL TAG CONFIG: disable-shared\n\n# ### BEGIN LIBTOOL TAG CONFIG: disable-static\nbuild_old_libs=`case $build_libtool_libs in yes) echo no;; *) echo yes;; esac`\n# ### END LIBTOOL TAG CONFIG: disable-static\n\n# Local Variables:\n# mode:shell-script\n# sh-indentation:2\n# End:\n",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/extra/libedit/libedit-20190324-3.1/m4/libtool.m4": "# libtool.m4 - Configure libtool for the host system. -*-Autoconf-*-\n#\n#   Copyright (C) 1996-2001, 2003-2015 Free Software Foundation, Inc.\n#   Written by Gordon Matzigkeit, 1996\n#\n# This file is free software; the Free Software Foundation gives\n# unlimited permission to copy and/or distribute it, with or without\n# modifications, as long as this notice is preserved.\n\nm4_define([_LT_COPYING], [dnl\n# Copyright (C) 2014 Free Software Foundation, Inc.\n# This is free software; see the source for copying conditions.  There is NO\n# warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\n# GNU Libtool is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation; either version 2 of of the License, or\n# (at your option) any later version.\n#\n# As a special exception to the GNU General Public License, if you\n# distribute this file as part of a program or library that is built\n# using GNU Libtool, you may include this file under the  same\n# distribution terms that you use for the rest of that program.\n#\n# GNU Libtool is distributed in the hope that it will be useful, but\n# WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n])\n\n# serial 58 LT_INIT\n\n\n# LT_PREREQ(VERSION)\n# ------------------\n# Complain and exit if this libtool version is less that VERSION.\nm4_defun([LT_PREREQ],\n[m4_if(m4_version_compare(m4_defn([LT_PACKAGE_VERSION]), [$1]), -1,\n       [m4_default([$3],\n\t\t   [m4_fatal([Libtool version $1 or higher is required],\n\t\t             63)])],\n       [$2])])\n\n\n# _LT_CHECK_BUILDDIR\n# ------------------\n# Complain if the absolute build directory name contains unusual characters\nm4_defun([_LT_CHECK_BUILDDIR],\n[case `pwd` in\n  *\\ * | *\\\t*)\n    AC_MSG_WARN([Libtool does not cope well with whitespace in `pwd`]) ;;\nesac\n])\n\n\n# LT_INIT([OPTIONS])\n# ------------------\nAC_DEFUN([LT_INIT],\n[AC_PREREQ([2.62])dnl We use AC_PATH_PROGS_FEATURE_CHECK\nAC_REQUIRE([AC_CONFIG_AUX_DIR_DEFAULT])dnl\nAC_BEFORE([$0], [LT_LANG])dnl\nAC_BEFORE([$0], [LT_OUTPUT])dnl\nAC_BEFORE([$0], [LTDL_INIT])dnl\nm4_require([_LT_CHECK_BUILDDIR])dnl\n\ndnl Autoconf doesn't catch unexpanded LT_ macros by default:\nm4_pattern_forbid([^_?LT_[A-Z_]+$])dnl\nm4_pattern_allow([^(_LT_EOF|LT_DLGLOBAL|LT_DLLAZY_OR_NOW|LT_MULTI_MODULE)$])dnl\ndnl aclocal doesn't pull ltoptions.m4, ltsugar.m4, or ltversion.m4\ndnl unless we require an AC_DEFUNed macro:\nAC_REQUIRE([LTOPTIONS_VERSION])dnl\nAC_REQUIRE([LTSUGAR_VERSION])dnl\nAC_REQUIRE([LTVERSION_VERSION])dnl\nAC_REQUIRE([LTOBSOLETE_VERSION])dnl\nm4_require([_LT_PROG_LTMAIN])dnl\n\n_LT_SHELL_INIT([SHELL=${CONFIG_SHELL-/bin/sh}])\n\ndnl Parse OPTIONS\n_LT_SET_OPTIONS([$0], [$1])\n\n# This can be used to rebuild libtool when needed\nLIBTOOL_DEPS=$ltmain\n\n# Always use our own libtool.\nLIBTOOL='$(SHELL) $(top_builddir)/libtool'\nAC_SUBST(LIBTOOL)dnl\n\n_LT_SETUP\n\n# Only expand once:\nm4_define([LT_INIT])\n])# LT_INIT\n\n# Old names:\nAU_ALIAS([AC_PROG_LIBTOOL], [LT_INIT])\nAU_ALIAS([AM_PROG_LIBTOOL], [LT_INIT])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_PROG_LIBTOOL], [])\ndnl AC_DEFUN([AM_PROG_LIBTOOL], [])\n\n\n# _LT_PREPARE_CC_BASENAME\n# -----------------------\nm4_defun([_LT_PREPARE_CC_BASENAME], [\n# Calculate cc_basename.  Skip known compiler wrappers and cross-prefix.\nfunc_cc_basename ()\n{\n    for cc_temp in @S|@*\"\"; do\n      case $cc_temp in\n        compile | *[[\\\\/]]compile | ccache | *[[\\\\/]]ccache ) ;;\n        distcc | *[[\\\\/]]distcc | purify | *[[\\\\/]]purify ) ;;\n        \\-*) ;;\n        *) break;;\n      esac\n    done\n    func_cc_basename_result=`$ECHO \"$cc_temp\" | $SED \"s%.*/%%; s%^$host_alias-%%\"`\n}\n])# _LT_PREPARE_CC_BASENAME\n\n\n# _LT_CC_BASENAME(CC)\n# -------------------\n# It would be clearer to call AC_REQUIREs from _LT_PREPARE_CC_BASENAME,\n# but that macro is also expanded into generated libtool script, which\n# arranges for $SED and $ECHO to be set by different means.\nm4_defun([_LT_CC_BASENAME],\n[m4_require([_LT_PREPARE_CC_BASENAME])dnl\nAC_REQUIRE([_LT_DECL_SED])dnl\nAC_REQUIRE([_LT_PROG_ECHO_BACKSLASH])dnl\nfunc_cc_basename $1\ncc_basename=$func_cc_basename_result\n])\n\n\n# _LT_FILEUTILS_DEFAULTS\n# ----------------------\n# It is okay to use these file commands and assume they have been set\n# sensibly after 'm4_require([_LT_FILEUTILS_DEFAULTS])'.\nm4_defun([_LT_FILEUTILS_DEFAULTS],\n[: ${CP=\"cp -f\"}\n: ${MV=\"mv -f\"}\n: ${RM=\"rm -f\"}\n])# _LT_FILEUTILS_DEFAULTS\n\n\n# _LT_SETUP\n# ---------\nm4_defun([_LT_SETUP],\n[AC_REQUIRE([AC_CANONICAL_HOST])dnl\nAC_REQUIRE([AC_CANONICAL_BUILD])dnl\nAC_REQUIRE([_LT_PREPARE_SED_QUOTE_VARS])dnl\nAC_REQUIRE([_LT_PROG_ECHO_BACKSLASH])dnl\n\n_LT_DECL([], [PATH_SEPARATOR], [1], [The PATH separator for the build system])dnl\ndnl\n_LT_DECL([], [host_alias], [0], [The host system])dnl\n_LT_DECL([], [host], [0])dnl\n_LT_DECL([], [host_os], [0])dnl\ndnl\n_LT_DECL([], [build_alias], [0], [The build system])dnl\n_LT_DECL([], [build], [0])dnl\n_LT_DECL([], [build_os], [0])dnl\ndnl\nAC_REQUIRE([AC_PROG_CC])dnl\nAC_REQUIRE([LT_PATH_LD])dnl\nAC_REQUIRE([LT_PATH_NM])dnl\ndnl\nAC_REQUIRE([AC_PROG_LN_S])dnl\ntest -z \"$LN_S\" && LN_S=\"ln -s\"\n_LT_DECL([], [LN_S], [1], [Whether we need soft or hard links])dnl\ndnl\nAC_REQUIRE([LT_CMD_MAX_LEN])dnl\n_LT_DECL([objext], [ac_objext], [0], [Object file suffix (normally \"o\")])dnl\n_LT_DECL([], [exeext], [0], [Executable file suffix (normally \"\")])dnl\ndnl\nm4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_CHECK_SHELL_FEATURES])dnl\nm4_require([_LT_PATH_CONVERSION_FUNCTIONS])dnl\nm4_require([_LT_CMD_RELOAD])dnl\nm4_require([_LT_CHECK_MAGIC_METHOD])dnl\nm4_require([_LT_CHECK_SHAREDLIB_FROM_LINKLIB])dnl\nm4_require([_LT_CMD_OLD_ARCHIVE])dnl\nm4_require([_LT_CMD_GLOBAL_SYMBOLS])dnl\nm4_require([_LT_WITH_SYSROOT])dnl\nm4_require([_LT_CMD_TRUNCATE])dnl\n\n_LT_CONFIG_LIBTOOL_INIT([\n# See if we are running on zsh, and set the options that allow our\n# commands through without removal of \\ escapes INIT.\nif test -n \"\\${ZSH_VERSION+set}\"; then\n   setopt NO_GLOB_SUBST\nfi\n])\nif test -n \"${ZSH_VERSION+set}\"; then\n   setopt NO_GLOB_SUBST\nfi\n\n_LT_CHECK_OBJDIR\n\nm4_require([_LT_TAG_COMPILER])dnl\n\ncase $host_os in\naix3*)\n  # AIX sometimes has problems with the GCC collect2 program.  For some\n  # reason, if we set the COLLECT_NAMES environment variable, the problems\n  # vanish in a puff of smoke.\n  if test set != \"${COLLECT_NAMES+set}\"; then\n    COLLECT_NAMES=\n    export COLLECT_NAMES\n  fi\n  ;;\nesac\n\n# Global variables:\nofile=libtool\ncan_build_shared=yes\n\n# All known linkers require a '.a' archive for static linking (except MSVC,\n# which needs '.lib').\nlibext=a\n\nwith_gnu_ld=$lt_cv_prog_gnu_ld\n\nold_CC=$CC\nold_CFLAGS=$CFLAGS\n\n# Set sane defaults for various variables\ntest -z \"$CC\" && CC=cc\ntest -z \"$LTCC\" && LTCC=$CC\ntest -z \"$LTCFLAGS\" && LTCFLAGS=$CFLAGS\ntest -z \"$LD\" && LD=ld\ntest -z \"$ac_objext\" && ac_objext=o\n\n_LT_CC_BASENAME([$compiler])\n\n# Only perform the check for file, if the check method requires it\ntest -z \"$MAGIC_CMD\" && MAGIC_CMD=file\ncase $deplibs_check_method in\nfile_magic*)\n  if test \"$file_magic_cmd\" = '$MAGIC_CMD'; then\n    _LT_PATH_MAGIC\n  fi\n  ;;\nesac\n\n# Use C for the default configuration in the libtool script\nLT_SUPPORTED_TAG([CC])\n_LT_LANG_C_CONFIG\n_LT_LANG_DEFAULT_CONFIG\n_LT_CONFIG_COMMANDS\n])# _LT_SETUP\n\n\n# _LT_PREPARE_SED_QUOTE_VARS\n# --------------------------\n# Define a few sed substitution that help us do robust quoting.\nm4_defun([_LT_PREPARE_SED_QUOTE_VARS],\n[# Backslashify metacharacters that are still active within\n# double-quoted strings.\nsed_quote_subst='s/\\([[\"`$\\\\]]\\)/\\\\\\1/g'\n\n# Same as above, but do not quote variable references.\ndouble_quote_subst='s/\\([[\"`\\\\]]\\)/\\\\\\1/g'\n\n# Sed substitution to delay expansion of an escaped shell variable in a\n# double_quote_subst'ed string.\ndelay_variable_subst='s/\\\\\\\\\\\\\\\\\\\\\\$/\\\\\\\\\\\\$/g'\n\n# Sed substitution to delay expansion of an escaped single quote.\ndelay_single_quote_subst='s/'\\''/'\\'\\\\\\\\\\\\\\'\\''/g'\n\n# Sed substitution to avoid accidental globbing in evaled expressions\nno_glob_subst='s/\\*/\\\\\\*/g'\n])\n\n# _LT_PROG_LTMAIN\n# ---------------\n# Note that this code is called both from 'configure', and 'config.status'\n# now that we use AC_CONFIG_COMMANDS to generate libtool.  Notably,\n# 'config.status' has no value for ac_aux_dir unless we are using Automake,\n# so we pass a copy along to make sure it has a sensible value anyway.\nm4_defun([_LT_PROG_LTMAIN],\n[m4_ifdef([AC_REQUIRE_AUX_FILE], [AC_REQUIRE_AUX_FILE([ltmain.sh])])dnl\n_LT_CONFIG_LIBTOOL_INIT([ac_aux_dir='$ac_aux_dir'])\nltmain=$ac_aux_dir/ltmain.sh\n])# _LT_PROG_LTMAIN\n\n\n## ------------------------------------- ##\n## Accumulate code for creating libtool. ##\n## ------------------------------------- ##\n\n# So that we can recreate a full libtool script including additional\n# tags, we accumulate the chunks of code to send to AC_CONFIG_COMMANDS\n# in macros and then make a single call at the end using the 'libtool'\n# label.\n\n\n# _LT_CONFIG_LIBTOOL_INIT([INIT-COMMANDS])\n# ----------------------------------------\n# Register INIT-COMMANDS to be passed to AC_CONFIG_COMMANDS later.\nm4_define([_LT_CONFIG_LIBTOOL_INIT],\n[m4_ifval([$1],\n          [m4_append([_LT_OUTPUT_LIBTOOL_INIT],\n                     [$1\n])])])\n\n# Initialize.\nm4_define([_LT_OUTPUT_LIBTOOL_INIT])\n\n\n# _LT_CONFIG_LIBTOOL([COMMANDS])\n# ------------------------------\n# Register COMMANDS to be passed to AC_CONFIG_COMMANDS later.\nm4_define([_LT_CONFIG_LIBTOOL],\n[m4_ifval([$1],\n          [m4_append([_LT_OUTPUT_LIBTOOL_COMMANDS],\n                     [$1\n])])])\n\n# Initialize.\nm4_define([_LT_OUTPUT_LIBTOOL_COMMANDS])\n\n\n# _LT_CONFIG_SAVE_COMMANDS([COMMANDS], [INIT_COMMANDS])\n# -----------------------------------------------------\nm4_defun([_LT_CONFIG_SAVE_COMMANDS],\n[_LT_CONFIG_LIBTOOL([$1])\n_LT_CONFIG_LIBTOOL_INIT([$2])\n])\n\n\n# _LT_FORMAT_COMMENT([COMMENT])\n# -----------------------------\n# Add leading comment marks to the start of each line, and a trailing\n# full-stop to the whole comment if one is not present already.\nm4_define([_LT_FORMAT_COMMENT],\n[m4_ifval([$1], [\nm4_bpatsubst([m4_bpatsubst([$1], [^ *], [# ])],\n              [['`$\\]], [\\\\\\&])]m4_bmatch([$1], [[!?.]$], [], [.])\n)])\n\n\n\n## ------------------------ ##\n## FIXME: Eliminate VARNAME ##\n## ------------------------ ##\n\n\n# _LT_DECL([CONFIGNAME], VARNAME, VALUE, [DESCRIPTION], [IS-TAGGED?])\n# -------------------------------------------------------------------\n# CONFIGNAME is the name given to the value in the libtool script.\n# VARNAME is the (base) name used in the configure script.\n# VALUE may be 0, 1 or 2 for a computed quote escaped value based on\n# VARNAME.  Any other value will be used directly.\nm4_define([_LT_DECL],\n[lt_if_append_uniq([lt_decl_varnames], [$2], [, ],\n    [lt_dict_add_subkey([lt_decl_dict], [$2], [libtool_name],\n\t[m4_ifval([$1], [$1], [$2])])\n    lt_dict_add_subkey([lt_decl_dict], [$2], [value], [$3])\n    m4_ifval([$4],\n\t[lt_dict_add_subkey([lt_decl_dict], [$2], [description], [$4])])\n    lt_dict_add_subkey([lt_decl_dict], [$2],\n\t[tagged?], [m4_ifval([$5], [yes], [no])])])\n])\n\n\n# _LT_TAGDECL([CONFIGNAME], VARNAME, VALUE, [DESCRIPTION])\n# --------------------------------------------------------\nm4_define([_LT_TAGDECL], [_LT_DECL([$1], [$2], [$3], [$4], [yes])])\n\n\n# lt_decl_tag_varnames([SEPARATOR], [VARNAME1...])\n# ------------------------------------------------\nm4_define([lt_decl_tag_varnames],\n[_lt_decl_filter([tagged?], [yes], $@)])\n\n\n# _lt_decl_filter(SUBKEY, VALUE, [SEPARATOR], [VARNAME1..])\n# ---------------------------------------------------------\nm4_define([_lt_decl_filter],\n[m4_case([$#],\n  [0], [m4_fatal([$0: too few arguments: $#])],\n  [1], [m4_fatal([$0: too few arguments: $#: $1])],\n  [2], [lt_dict_filter([lt_decl_dict], [$1], [$2], [], lt_decl_varnames)],\n  [3], [lt_dict_filter([lt_decl_dict], [$1], [$2], [$3], lt_decl_varnames)],\n  [lt_dict_filter([lt_decl_dict], $@)])[]dnl\n])\n\n\n# lt_decl_quote_varnames([SEPARATOR], [VARNAME1...])\n# --------------------------------------------------\nm4_define([lt_decl_quote_varnames],\n[_lt_decl_filter([value], [1], $@)])\n\n\n# lt_decl_dquote_varnames([SEPARATOR], [VARNAME1...])\n# ---------------------------------------------------\nm4_define([lt_decl_dquote_varnames],\n[_lt_decl_filter([value], [2], $@)])\n\n\n# lt_decl_varnames_tagged([SEPARATOR], [VARNAME1...])\n# ---------------------------------------------------\nm4_define([lt_decl_varnames_tagged],\n[m4_assert([$# <= 2])dnl\n_$0(m4_quote(m4_default([$1], [[, ]])),\n    m4_ifval([$2], [[$2]], [m4_dquote(lt_decl_tag_varnames)]),\n    m4_split(m4_normalize(m4_quote(_LT_TAGS)), [ ]))])\nm4_define([_lt_decl_varnames_tagged],\n[m4_ifval([$3], [lt_combine([$1], [$2], [_], $3)])])\n\n\n# lt_decl_all_varnames([SEPARATOR], [VARNAME1...])\n# ------------------------------------------------\nm4_define([lt_decl_all_varnames],\n[_$0(m4_quote(m4_default([$1], [[, ]])),\n     m4_if([$2], [],\n\t   m4_quote(lt_decl_varnames),\n\tm4_quote(m4_shift($@))))[]dnl\n])\nm4_define([_lt_decl_all_varnames],\n[lt_join($@, lt_decl_varnames_tagged([$1],\n\t\t\tlt_decl_tag_varnames([[, ]], m4_shift($@))))dnl\n])\n\n\n# _LT_CONFIG_STATUS_DECLARE([VARNAME])\n# ------------------------------------\n# Quote a variable value, and forward it to 'config.status' so that its\n# declaration there will have the same value as in 'configure'.  VARNAME\n# must have a single quote delimited value for this to work.\nm4_define([_LT_CONFIG_STATUS_DECLARE],\n[$1='`$ECHO \"$][$1\" | $SED \"$delay_single_quote_subst\"`'])\n\n\n# _LT_CONFIG_STATUS_DECLARATIONS\n# ------------------------------\n# We delimit libtool config variables with single quotes, so when\n# we write them to config.status, we have to be sure to quote all\n# embedded single quotes properly.  In configure, this macro expands\n# each variable declared with _LT_DECL (and _LT_TAGDECL) into:\n#\n#    <var>='`$ECHO \"$<var>\" | $SED \"$delay_single_quote_subst\"`'\nm4_defun([_LT_CONFIG_STATUS_DECLARATIONS],\n[m4_foreach([_lt_var], m4_quote(lt_decl_all_varnames),\n    [m4_n([_LT_CONFIG_STATUS_DECLARE(_lt_var)])])])\n\n\n# _LT_LIBTOOL_TAGS\n# ----------------\n# Output comment and list of tags supported by the script\nm4_defun([_LT_LIBTOOL_TAGS],\n[_LT_FORMAT_COMMENT([The names of the tagged configurations supported by this script])dnl\navailable_tags='_LT_TAGS'dnl\n])\n\n\n# _LT_LIBTOOL_DECLARE(VARNAME, [TAG])\n# -----------------------------------\n# Extract the dictionary values for VARNAME (optionally with TAG) and\n# expand to a commented shell variable setting:\n#\n#    # Some comment about what VAR is for.\n#    visible_name=$lt_internal_name\nm4_define([_LT_LIBTOOL_DECLARE],\n[_LT_FORMAT_COMMENT(m4_quote(lt_dict_fetch([lt_decl_dict], [$1],\n\t\t\t\t\t   [description])))[]dnl\nm4_pushdef([_libtool_name],\n    m4_quote(lt_dict_fetch([lt_decl_dict], [$1], [libtool_name])))[]dnl\nm4_case(m4_quote(lt_dict_fetch([lt_decl_dict], [$1], [value])),\n    [0], [_libtool_name=[$]$1],\n    [1], [_libtool_name=$lt_[]$1],\n    [2], [_libtool_name=$lt_[]$1],\n    [_libtool_name=lt_dict_fetch([lt_decl_dict], [$1], [value])])[]dnl\nm4_ifval([$2], [_$2])[]m4_popdef([_libtool_name])[]dnl\n])\n\n\n# _LT_LIBTOOL_CONFIG_VARS\n# -----------------------\n# Produce commented declarations of non-tagged libtool config variables\n# suitable for insertion in the LIBTOOL CONFIG section of the 'libtool'\n# script.  Tagged libtool config variables (even for the LIBTOOL CONFIG\n# section) are produced by _LT_LIBTOOL_TAG_VARS.\nm4_defun([_LT_LIBTOOL_CONFIG_VARS],\n[m4_foreach([_lt_var],\n    m4_quote(_lt_decl_filter([tagged?], [no], [], lt_decl_varnames)),\n    [m4_n([_LT_LIBTOOL_DECLARE(_lt_var)])])])\n\n\n# _LT_LIBTOOL_TAG_VARS(TAG)\n# -------------------------\nm4_define([_LT_LIBTOOL_TAG_VARS],\n[m4_foreach([_lt_var], m4_quote(lt_decl_tag_varnames),\n    [m4_n([_LT_LIBTOOL_DECLARE(_lt_var, [$1])])])])\n\n\n# _LT_TAGVAR(VARNAME, [TAGNAME])\n# ------------------------------\nm4_define([_LT_TAGVAR], [m4_ifval([$2], [$1_$2], [$1])])\n\n\n# _LT_CONFIG_COMMANDS\n# -------------------\n# Send accumulated output to $CONFIG_STATUS.  Thanks to the lists of\n# variables for single and double quote escaping we saved from calls\n# to _LT_DECL, we can put quote escaped variables declarations\n# into 'config.status', and then the shell code to quote escape them in\n# for loops in 'config.status'.  Finally, any additional code accumulated\n# from calls to _LT_CONFIG_LIBTOOL_INIT is expanded.\nm4_defun([_LT_CONFIG_COMMANDS],\n[AC_PROVIDE_IFELSE([LT_OUTPUT],\n\tdnl If the libtool generation code has been placed in $CONFIG_LT,\n\tdnl instead of duplicating it all over again into config.status,\n\tdnl then we will have config.status run $CONFIG_LT later, so it\n\tdnl needs to know what name is stored there:\n        [AC_CONFIG_COMMANDS([libtool],\n            [$SHELL $CONFIG_LT || AS_EXIT(1)], [CONFIG_LT='$CONFIG_LT'])],\n    dnl If the libtool generation code is destined for config.status,\n    dnl expand the accumulated commands and init code now:\n    [AC_CONFIG_COMMANDS([libtool],\n        [_LT_OUTPUT_LIBTOOL_COMMANDS], [_LT_OUTPUT_LIBTOOL_COMMANDS_INIT])])\n])#_LT_CONFIG_COMMANDS\n\n\n# Initialize.\nm4_define([_LT_OUTPUT_LIBTOOL_COMMANDS_INIT],\n[\n\n# The HP-UX ksh and POSIX shell print the target directory to stdout\n# if CDPATH is set.\n(unset CDPATH) >/dev/null 2>&1 && unset CDPATH\n\nsed_quote_subst='$sed_quote_subst'\ndouble_quote_subst='$double_quote_subst'\ndelay_variable_subst='$delay_variable_subst'\n_LT_CONFIG_STATUS_DECLARATIONS\nLTCC='$LTCC'\nLTCFLAGS='$LTCFLAGS'\ncompiler='$compiler_DEFAULT'\n\n# A function that is used when there is no print builtin or printf.\nfunc_fallback_echo ()\n{\n  eval 'cat <<_LTECHO_EOF\n\\$[]1\n_LTECHO_EOF'\n}\n\n# Quote evaled strings.\nfor var in lt_decl_all_varnames([[ \\\n]], lt_decl_quote_varnames); do\n    case \\`eval \\\\\\\\\\$ECHO \\\\\\\\\"\"\\\\\\\\\\$\\$var\"\\\\\\\\\"\\` in\n    *[[\\\\\\\\\\\\\\`\\\\\"\\\\\\$]]*)\n      eval \"lt_\\$var=\\\\\\\\\\\\\"\\\\\\`\\\\\\$ECHO \\\\\"\\\\\\$\\$var\\\\\" | \\\\\\$SED \\\\\"\\\\\\$sed_quote_subst\\\\\"\\\\\\`\\\\\\\\\\\\\"\" ## exclude from sc_prohibit_nested_quotes\n      ;;\n    *)\n      eval \"lt_\\$var=\\\\\\\\\\\\\"\\\\\\$\\$var\\\\\\\\\\\\\"\"\n      ;;\n    esac\ndone\n\n# Double-quote double-evaled strings.\nfor var in lt_decl_all_varnames([[ \\\n]], lt_decl_dquote_varnames); do\n    case \\`eval \\\\\\\\\\$ECHO \\\\\\\\\"\"\\\\\\\\\\$\\$var\"\\\\\\\\\"\\` in\n    *[[\\\\\\\\\\\\\\`\\\\\"\\\\\\$]]*)\n      eval \"lt_\\$var=\\\\\\\\\\\\\"\\\\\\`\\\\\\$ECHO \\\\\"\\\\\\$\\$var\\\\\" | \\\\\\$SED -e \\\\\"\\\\\\$double_quote_subst\\\\\" -e \\\\\"\\\\\\$sed_quote_subst\\\\\" -e \\\\\"\\\\\\$delay_variable_subst\\\\\"\\\\\\`\\\\\\\\\\\\\"\" ## exclude from sc_prohibit_nested_quotes\n      ;;\n    *)\n      eval \"lt_\\$var=\\\\\\\\\\\\\"\\\\\\$\\$var\\\\\\\\\\\\\"\"\n      ;;\n    esac\ndone\n\n_LT_OUTPUT_LIBTOOL_INIT\n])\n\n# _LT_GENERATED_FILE_INIT(FILE, [COMMENT])\n# ------------------------------------\n# Generate a child script FILE with all initialization necessary to\n# reuse the environment learned by the parent script, and make the\n# file executable.  If COMMENT is supplied, it is inserted after the\n# '#!' sequence but before initialization text begins.  After this\n# macro, additional text can be appended to FILE to form the body of\n# the child script.  The macro ends with non-zero status if the\n# file could not be fully written (such as if the disk is full).\nm4_ifdef([AS_INIT_GENERATED],\n[m4_defun([_LT_GENERATED_FILE_INIT],[AS_INIT_GENERATED($@)])],\n[m4_defun([_LT_GENERATED_FILE_INIT],\n[m4_require([AS_PREPARE])]dnl\n[m4_pushdef([AS_MESSAGE_LOG_FD])]dnl\n[lt_write_fail=0\ncat >$1 <<_ASEOF || lt_write_fail=1\n#! $SHELL\n# Generated by $as_me.\n$2\nSHELL=\\${CONFIG_SHELL-$SHELL}\nexport SHELL\n_ASEOF\ncat >>$1 <<\\_ASEOF || lt_write_fail=1\nAS_SHELL_SANITIZE\n_AS_PREPARE\nexec AS_MESSAGE_FD>&1\n_ASEOF\ntest 0 = \"$lt_write_fail\" && chmod +x $1[]dnl\nm4_popdef([AS_MESSAGE_LOG_FD])])])# _LT_GENERATED_FILE_INIT\n\n# LT_OUTPUT\n# ---------\n# This macro allows early generation of the libtool script (before\n# AC_OUTPUT is called), incase it is used in configure for compilation\n# tests.\nAC_DEFUN([LT_OUTPUT],\n[: ${CONFIG_LT=./config.lt}\nAC_MSG_NOTICE([creating $CONFIG_LT])\n_LT_GENERATED_FILE_INIT([\"$CONFIG_LT\"],\n[# Run this file to recreate a libtool stub with the current configuration.])\n\ncat >>\"$CONFIG_LT\" <<\\_LTEOF\nlt_cl_silent=false\nexec AS_MESSAGE_LOG_FD>>config.log\n{\n  echo\n  AS_BOX([Running $as_me.])\n} >&AS_MESSAGE_LOG_FD\n\nlt_cl_help=\"\\\n'$as_me' creates a local libtool stub from the current configuration,\nfor use in further configure time tests before the real libtool is\ngenerated.\n\nUsage: $[0] [[OPTIONS]]\n\n  -h, --help      print this help, then exit\n  -V, --version   print version number, then exit\n  -q, --quiet     do not print progress messages\n  -d, --debug     don't remove temporary files\n\nReport bugs to <bug-libtool@gnu.org>.\"\n\nlt_cl_version=\"\\\nm4_ifset([AC_PACKAGE_NAME], [AC_PACKAGE_NAME ])config.lt[]dnl\nm4_ifset([AC_PACKAGE_VERSION], [ AC_PACKAGE_VERSION])\nconfigured by $[0], generated by m4_PACKAGE_STRING.\n\nCopyright (C) 2011 Free Software Foundation, Inc.\nThis config.lt script is free software; the Free Software Foundation\ngives unlimited permision to copy, distribute and modify it.\"\n\nwhile test 0 != $[#]\ndo\n  case $[1] in\n    --version | --v* | -V )\n      echo \"$lt_cl_version\"; exit 0 ;;\n    --help | --h* | -h )\n      echo \"$lt_cl_help\"; exit 0 ;;\n    --debug | --d* | -d )\n      debug=: ;;\n    --quiet | --q* | --silent | --s* | -q )\n      lt_cl_silent=: ;;\n\n    -*) AC_MSG_ERROR([unrecognized option: $[1]\nTry '$[0] --help' for more information.]) ;;\n\n    *) AC_MSG_ERROR([unrecognized argument: $[1]\nTry '$[0] --help' for more information.]) ;;\n  esac\n  shift\ndone\n\nif $lt_cl_silent; then\n  exec AS_MESSAGE_FD>/dev/null\nfi\n_LTEOF\n\ncat >>\"$CONFIG_LT\" <<_LTEOF\n_LT_OUTPUT_LIBTOOL_COMMANDS_INIT\n_LTEOF\n\ncat >>\"$CONFIG_LT\" <<\\_LTEOF\nAC_MSG_NOTICE([creating $ofile])\n_LT_OUTPUT_LIBTOOL_COMMANDS\nAS_EXIT(0)\n_LTEOF\nchmod +x \"$CONFIG_LT\"\n\n# configure is writing to config.log, but config.lt does its own redirection,\n# appending to config.log, which fails on DOS, as config.log is still kept\n# open by configure.  Here we exec the FD to /dev/null, effectively closing\n# config.log, so it can be properly (re)opened and appended to by config.lt.\nlt_cl_success=:\ntest yes = \"$silent\" &&\n  lt_config_lt_args=\"$lt_config_lt_args --quiet\"\nexec AS_MESSAGE_LOG_FD>/dev/null\n$SHELL \"$CONFIG_LT\" $lt_config_lt_args || lt_cl_success=false\nexec AS_MESSAGE_LOG_FD>>config.log\n$lt_cl_success || AS_EXIT(1)\n])# LT_OUTPUT\n\n\n# _LT_CONFIG(TAG)\n# ---------------\n# If TAG is the built-in tag, create an initial libtool script with a\n# default configuration from the untagged config vars.  Otherwise add code\n# to config.status for appending the configuration named by TAG from the\n# matching tagged config vars.\nm4_defun([_LT_CONFIG],\n[m4_require([_LT_FILEUTILS_DEFAULTS])dnl\n_LT_CONFIG_SAVE_COMMANDS([\n  m4_define([_LT_TAG], m4_if([$1], [], [C], [$1]))dnl\n  m4_if(_LT_TAG, [C], [\n    # See if we are running on zsh, and set the options that allow our\n    # commands through without removal of \\ escapes.\n    if test -n \"${ZSH_VERSION+set}\"; then\n      setopt NO_GLOB_SUBST\n    fi\n\n    cfgfile=${ofile}T\n    trap \"$RM \\\"$cfgfile\\\"; exit 1\" 1 2 15\n    $RM \"$cfgfile\"\n\n    cat <<_LT_EOF >> \"$cfgfile\"\n#! $SHELL\n# Generated automatically by $as_me ($PACKAGE) $VERSION\n# Libtool was configured on host `(hostname || uname -n) 2>/dev/null | sed 1q`:\n# NOTE: Changes made to this file will be lost: look at ltmain.sh.\n\n# Provide generalized library-building support services.\n# Written by Gordon Matzigkeit, 1996\n\n_LT_COPYING\n_LT_LIBTOOL_TAGS\n\n# Configured defaults for sys_lib_dlsearch_path munging.\n: \\${LT_SYS_LIBRARY_PATH=\"$configure_time_lt_sys_library_path\"}\n\n# ### BEGIN LIBTOOL CONFIG\n_LT_LIBTOOL_CONFIG_VARS\n_LT_LIBTOOL_TAG_VARS\n# ### END LIBTOOL CONFIG\n\n_LT_EOF\n\n    cat <<'_LT_EOF' >> \"$cfgfile\"\n\n# ### BEGIN FUNCTIONS SHARED WITH CONFIGURE\n\n_LT_PREPARE_MUNGE_PATH_LIST\n_LT_PREPARE_CC_BASENAME\n\n# ### END FUNCTIONS SHARED WITH CONFIGURE\n\n_LT_EOF\n\n  case $host_os in\n  aix3*)\n    cat <<\\_LT_EOF >> \"$cfgfile\"\n# AIX sometimes has problems with the GCC collect2 program.  For some\n# reason, if we set the COLLECT_NAMES environment variable, the problems\n# vanish in a puff of smoke.\nif test set != \"${COLLECT_NAMES+set}\"; then\n  COLLECT_NAMES=\n  export COLLECT_NAMES\nfi\n_LT_EOF\n    ;;\n  esac\n\n  _LT_PROG_LTMAIN\n\n  # We use sed instead of cat because bash on DJGPP gets confused if\n  # if finds mixed CR/LF and LF-only lines.  Since sed operates in\n  # text mode, it properly converts lines to CR/LF.  This bash problem\n  # is reportedly fixed, but why not run on old versions too?\n  sed '$q' \"$ltmain\" >> \"$cfgfile\" \\\n     || (rm -f \"$cfgfile\"; exit 1)\n\n   mv -f \"$cfgfile\" \"$ofile\" ||\n    (rm -f \"$ofile\" && cp \"$cfgfile\" \"$ofile\" && rm -f \"$cfgfile\")\n  chmod +x \"$ofile\"\n],\n[cat <<_LT_EOF >> \"$ofile\"\n\ndnl Unfortunately we have to use $1 here, since _LT_TAG is not expanded\ndnl in a comment (ie after a #).\n# ### BEGIN LIBTOOL TAG CONFIG: $1\n_LT_LIBTOOL_TAG_VARS(_LT_TAG)\n# ### END LIBTOOL TAG CONFIG: $1\n_LT_EOF\n])dnl /m4_if\n],\n[m4_if([$1], [], [\n    PACKAGE='$PACKAGE'\n    VERSION='$VERSION'\n    RM='$RM'\n    ofile='$ofile'], [])\n])dnl /_LT_CONFIG_SAVE_COMMANDS\n])# _LT_CONFIG\n\n\n# LT_SUPPORTED_TAG(TAG)\n# ---------------------\n# Trace this macro to discover what tags are supported by the libtool\n# --tag option, using:\n#    autoconf --trace 'LT_SUPPORTED_TAG:$1'\nAC_DEFUN([LT_SUPPORTED_TAG], [])\n\n\n# C support is built-in for now\nm4_define([_LT_LANG_C_enabled], [])\nm4_define([_LT_TAGS], [])\n\n\n# LT_LANG(LANG)\n# -------------\n# Enable libtool support for the given language if not already enabled.\nAC_DEFUN([LT_LANG],\n[AC_BEFORE([$0], [LT_OUTPUT])dnl\nm4_case([$1],\n  [C],\t\t\t[_LT_LANG(C)],\n  [C++],\t\t[_LT_LANG(CXX)],\n  [Go],\t\t\t[_LT_LANG(GO)],\n  [Java],\t\t[_LT_LANG(GCJ)],\n  [Fortran 77],\t\t[_LT_LANG(F77)],\n  [Fortran],\t\t[_LT_LANG(FC)],\n  [Windows Resource],\t[_LT_LANG(RC)],\n  [m4_ifdef([_LT_LANG_]$1[_CONFIG],\n    [_LT_LANG($1)],\n    [m4_fatal([$0: unsupported language: \"$1\"])])])dnl\n])# LT_LANG\n\n\n# _LT_LANG(LANGNAME)\n# ------------------\nm4_defun([_LT_LANG],\n[m4_ifdef([_LT_LANG_]$1[_enabled], [],\n  [LT_SUPPORTED_TAG([$1])dnl\n  m4_append([_LT_TAGS], [$1 ])dnl\n  m4_define([_LT_LANG_]$1[_enabled], [])dnl\n  _LT_LANG_$1_CONFIG($1)])dnl\n])# _LT_LANG\n\n\nm4_ifndef([AC_PROG_GO], [\n############################################################\n# NOTE: This macro has been submitted for inclusion into   #\n#  GNU Autoconf as AC_PROG_GO.  When it is available in    #\n#  a released version of Autoconf we should remove this    #\n#  macro and use it instead.                               #\n############################################################\nm4_defun([AC_PROG_GO],\n[AC_LANG_PUSH(Go)dnl\nAC_ARG_VAR([GOC],     [Go compiler command])dnl\nAC_ARG_VAR([GOFLAGS], [Go compiler flags])dnl\n_AC_ARG_VAR_LDFLAGS()dnl\nAC_CHECK_TOOL(GOC, gccgo)\nif test -z \"$GOC\"; then\n  if test -n \"$ac_tool_prefix\"; then\n    AC_CHECK_PROG(GOC, [${ac_tool_prefix}gccgo], [${ac_tool_prefix}gccgo])\n  fi\nfi\nif test -z \"$GOC\"; then\n  AC_CHECK_PROG(GOC, gccgo, gccgo, false)\nfi\n])#m4_defun\n])#m4_ifndef\n\n\n# _LT_LANG_DEFAULT_CONFIG\n# -----------------------\nm4_defun([_LT_LANG_DEFAULT_CONFIG],\n[AC_PROVIDE_IFELSE([AC_PROG_CXX],\n  [LT_LANG(CXX)],\n  [m4_define([AC_PROG_CXX], defn([AC_PROG_CXX])[LT_LANG(CXX)])])\n\nAC_PROVIDE_IFELSE([AC_PROG_F77],\n  [LT_LANG(F77)],\n  [m4_define([AC_PROG_F77], defn([AC_PROG_F77])[LT_LANG(F77)])])\n\nAC_PROVIDE_IFELSE([AC_PROG_FC],\n  [LT_LANG(FC)],\n  [m4_define([AC_PROG_FC], defn([AC_PROG_FC])[LT_LANG(FC)])])\n\ndnl The call to [A][M_PROG_GCJ] is quoted like that to stop aclocal\ndnl pulling things in needlessly.\nAC_PROVIDE_IFELSE([AC_PROG_GCJ],\n  [LT_LANG(GCJ)],\n  [AC_PROVIDE_IFELSE([A][M_PROG_GCJ],\n    [LT_LANG(GCJ)],\n    [AC_PROVIDE_IFELSE([LT_PROG_GCJ],\n      [LT_LANG(GCJ)],\n      [m4_ifdef([AC_PROG_GCJ],\n\t[m4_define([AC_PROG_GCJ], defn([AC_PROG_GCJ])[LT_LANG(GCJ)])])\n       m4_ifdef([A][M_PROG_GCJ],\n\t[m4_define([A][M_PROG_GCJ], defn([A][M_PROG_GCJ])[LT_LANG(GCJ)])])\n       m4_ifdef([LT_PROG_GCJ],\n\t[m4_define([LT_PROG_GCJ], defn([LT_PROG_GCJ])[LT_LANG(GCJ)])])])])])\n\nAC_PROVIDE_IFELSE([AC_PROG_GO],\n  [LT_LANG(GO)],\n  [m4_define([AC_PROG_GO], defn([AC_PROG_GO])[LT_LANG(GO)])])\n\nAC_PROVIDE_IFELSE([LT_PROG_RC],\n  [LT_LANG(RC)],\n  [m4_define([LT_PROG_RC], defn([LT_PROG_RC])[LT_LANG(RC)])])\n])# _LT_LANG_DEFAULT_CONFIG\n\n# Obsolete macros:\nAU_DEFUN([AC_LIBTOOL_CXX], [LT_LANG(C++)])\nAU_DEFUN([AC_LIBTOOL_F77], [LT_LANG(Fortran 77)])\nAU_DEFUN([AC_LIBTOOL_FC], [LT_LANG(Fortran)])\nAU_DEFUN([AC_LIBTOOL_GCJ], [LT_LANG(Java)])\nAU_DEFUN([AC_LIBTOOL_RC], [LT_LANG(Windows Resource)])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_CXX], [])\ndnl AC_DEFUN([AC_LIBTOOL_F77], [])\ndnl AC_DEFUN([AC_LIBTOOL_FC], [])\ndnl AC_DEFUN([AC_LIBTOOL_GCJ], [])\ndnl AC_DEFUN([AC_LIBTOOL_RC], [])\n\n\n# _LT_TAG_COMPILER\n# ----------------\nm4_defun([_LT_TAG_COMPILER],\n[AC_REQUIRE([AC_PROG_CC])dnl\n\n_LT_DECL([LTCC], [CC], [1], [A C compiler])dnl\n_LT_DECL([LTCFLAGS], [CFLAGS], [1], [LTCC compiler flags])dnl\n_LT_TAGDECL([CC], [compiler], [1], [A language specific compiler])dnl\n_LT_TAGDECL([with_gcc], [GCC], [0], [Is the compiler the GNU compiler?])dnl\n\n# If no C compiler was specified, use CC.\nLTCC=${LTCC-\"$CC\"}\n\n# If no C compiler flags were specified, use CFLAGS.\nLTCFLAGS=${LTCFLAGS-\"$CFLAGS\"}\n\n# Allow CC to be a program name with arguments.\ncompiler=$CC\n])# _LT_TAG_COMPILER\n\n\n# _LT_COMPILER_BOILERPLATE\n# ------------------------\n# Check for compiler boilerplate output or warnings with\n# the simple compiler test code.\nm4_defun([_LT_COMPILER_BOILERPLATE],\n[m4_require([_LT_DECL_SED])dnl\nac_outfile=conftest.$ac_objext\necho \"$lt_simple_compile_test_code\" >conftest.$ac_ext\neval \"$ac_compile\" 2>&1 >/dev/null | $SED '/^$/d; /^ *+/d' >conftest.err\n_lt_compiler_boilerplate=`cat conftest.err`\n$RM conftest*\n])# _LT_COMPILER_BOILERPLATE\n\n\n# _LT_LINKER_BOILERPLATE\n# ----------------------\n# Check for linker boilerplate output or warnings with\n# the simple link test code.\nm4_defun([_LT_LINKER_BOILERPLATE],\n[m4_require([_LT_DECL_SED])dnl\nac_outfile=conftest.$ac_objext\necho \"$lt_simple_link_test_code\" >conftest.$ac_ext\neval \"$ac_link\" 2>&1 >/dev/null | $SED '/^$/d; /^ *+/d' >conftest.err\n_lt_linker_boilerplate=`cat conftest.err`\n$RM -r conftest*\n])# _LT_LINKER_BOILERPLATE\n\n# _LT_REQUIRED_DARWIN_CHECKS\n# -------------------------\nm4_defun_once([_LT_REQUIRED_DARWIN_CHECKS],[\n  case $host_os in\n    rhapsody* | darwin*)\n    AC_CHECK_TOOL([DSYMUTIL], [dsymutil], [:])\n    AC_CHECK_TOOL([NMEDIT], [nmedit], [:])\n    AC_CHECK_TOOL([LIPO], [lipo], [:])\n    AC_CHECK_TOOL([OTOOL], [otool], [:])\n    AC_CHECK_TOOL([OTOOL64], [otool64], [:])\n    _LT_DECL([], [DSYMUTIL], [1],\n      [Tool to manipulate archived DWARF debug symbol files on Mac OS X])\n    _LT_DECL([], [NMEDIT], [1],\n      [Tool to change global to local symbols on Mac OS X])\n    _LT_DECL([], [LIPO], [1],\n      [Tool to manipulate fat objects and archives on Mac OS X])\n    _LT_DECL([], [OTOOL], [1],\n      [ldd/readelf like tool for Mach-O binaries on Mac OS X])\n    _LT_DECL([], [OTOOL64], [1],\n      [ldd/readelf like tool for 64 bit Mach-O binaries on Mac OS X 10.4])\n\n    AC_CACHE_CHECK([for -single_module linker flag],[lt_cv_apple_cc_single_mod],\n      [lt_cv_apple_cc_single_mod=no\n      if test -z \"$LT_MULTI_MODULE\"; then\n\t# By default we will add the -single_module flag. You can override\n\t# by either setting the environment variable LT_MULTI_MODULE\n\t# non-empty at configure time, or by adding -multi_module to the\n\t# link flags.\n\trm -rf libconftest.dylib*\n\techo \"int foo(void){return 1;}\" > conftest.c\n\techo \"$LTCC $LTCFLAGS $LDFLAGS -o libconftest.dylib \\\n-dynamiclib -Wl,-single_module conftest.c\" >&AS_MESSAGE_LOG_FD\n\t$LTCC $LTCFLAGS $LDFLAGS -o libconftest.dylib \\\n\t  -dynamiclib -Wl,-single_module conftest.c 2>conftest.err\n        _lt_result=$?\n\t# If there is a non-empty error log, and \"single_module\"\n\t# appears in it, assume the flag caused a linker warning\n        if test -s conftest.err && $GREP single_module conftest.err; then\n\t  cat conftest.err >&AS_MESSAGE_LOG_FD\n\t# Otherwise, if the output was created with a 0 exit code from\n\t# the compiler, it worked.\n\telif test -f libconftest.dylib && test 0 = \"$_lt_result\"; then\n\t  lt_cv_apple_cc_single_mod=yes\n\telse\n\t  cat conftest.err >&AS_MESSAGE_LOG_FD\n\tfi\n\trm -rf libconftest.dylib*\n\trm -f conftest.*\n      fi])\n\n    AC_CACHE_CHECK([for -exported_symbols_list linker flag],\n      [lt_cv_ld_exported_symbols_list],\n      [lt_cv_ld_exported_symbols_list=no\n      save_LDFLAGS=$LDFLAGS\n      echo \"_main\" > conftest.sym\n      LDFLAGS=\"$LDFLAGS -Wl,-exported_symbols_list,conftest.sym\"\n      AC_LINK_IFELSE([AC_LANG_PROGRAM([],[])],\n\t[lt_cv_ld_exported_symbols_list=yes],\n\t[lt_cv_ld_exported_symbols_list=no])\n\tLDFLAGS=$save_LDFLAGS\n    ])\n\n    AC_CACHE_CHECK([for -force_load linker flag],[lt_cv_ld_force_load],\n      [lt_cv_ld_force_load=no\n      cat > conftest.c << _LT_EOF\nint forced_loaded() { return 2;}\n_LT_EOF\n      echo \"$LTCC $LTCFLAGS -c -o conftest.o conftest.c\" >&AS_MESSAGE_LOG_FD\n      $LTCC $LTCFLAGS -c -o conftest.o conftest.c 2>&AS_MESSAGE_LOG_FD\n      echo \"$AR cru libconftest.a conftest.o\" >&AS_MESSAGE_LOG_FD\n      $AR cru libconftest.a conftest.o 2>&AS_MESSAGE_LOG_FD\n      echo \"$RANLIB libconftest.a\" >&AS_MESSAGE_LOG_FD\n      $RANLIB libconftest.a 2>&AS_MESSAGE_LOG_FD\n      cat > conftest.c << _LT_EOF\nint main() { return 0;}\n_LT_EOF\n      echo \"$LTCC $LTCFLAGS $LDFLAGS -o conftest conftest.c -Wl,-force_load,./libconftest.a\" >&AS_MESSAGE_LOG_FD\n      $LTCC $LTCFLAGS $LDFLAGS -o conftest conftest.c -Wl,-force_load,./libconftest.a 2>conftest.err\n      _lt_result=$?\n      if test -s conftest.err && $GREP force_load conftest.err; then\n\tcat conftest.err >&AS_MESSAGE_LOG_FD\n      elif test -f conftest && test 0 = \"$_lt_result\" && $GREP forced_load conftest >/dev/null 2>&1; then\n\tlt_cv_ld_force_load=yes\n      else\n\tcat conftest.err >&AS_MESSAGE_LOG_FD\n      fi\n        rm -f conftest.err libconftest.a conftest conftest.c\n        rm -rf conftest.dSYM\n    ])\n    case $host_os in\n    rhapsody* | darwin1.[[012]])\n      _lt_dar_allow_undefined='$wl-undefined ${wl}suppress' ;;\n    darwin1.*)\n      _lt_dar_allow_undefined='$wl-flat_namespace $wl-undefined ${wl}suppress' ;;\n    darwin*) # darwin 5.x on\n      # if running on 10.5 or later, the deployment target defaults\n      # to the OS version, if on x86, and 10.4, the deployment\n      # target defaults to 10.4. Don't you love it?\n      case ${MACOSX_DEPLOYMENT_TARGET-10.0},$host in\n\t10.0,*86*-darwin8*|10.0,*-darwin[[91]]*)\n\t  _lt_dar_allow_undefined='$wl-undefined ${wl}dynamic_lookup' ;;\n\t10.[[012]][[,.]]*)\n\t  _lt_dar_allow_undefined='$wl-flat_namespace $wl-undefined ${wl}suppress' ;;\n\t10.*)\n\t  _lt_dar_allow_undefined='$wl-undefined ${wl}dynamic_lookup' ;;\n      esac\n    ;;\n  esac\n    if test yes = \"$lt_cv_apple_cc_single_mod\"; then\n      _lt_dar_single_mod='$single_module'\n    fi\n    if test yes = \"$lt_cv_ld_exported_symbols_list\"; then\n      _lt_dar_export_syms=' $wl-exported_symbols_list,$output_objdir/$libname-symbols.expsym'\n    else\n      _lt_dar_export_syms='~$NMEDIT -s $output_objdir/$libname-symbols.expsym $lib'\n    fi\n    if test : != \"$DSYMUTIL\" && test no = \"$lt_cv_ld_force_load\"; then\n      _lt_dsymutil='~$DSYMUTIL $lib || :'\n    else\n      _lt_dsymutil=\n    fi\n    ;;\n  esac\n])\n\n\n# _LT_DARWIN_LINKER_FEATURES([TAG])\n# ---------------------------------\n# Checks for linker and compiler features on darwin\nm4_defun([_LT_DARWIN_LINKER_FEATURES],\n[\n  m4_require([_LT_REQUIRED_DARWIN_CHECKS])\n  _LT_TAGVAR(archive_cmds_need_lc, $1)=no\n  _LT_TAGVAR(hardcode_direct, $1)=no\n  _LT_TAGVAR(hardcode_automatic, $1)=yes\n  _LT_TAGVAR(hardcode_shlibpath_var, $1)=unsupported\n  if test yes = \"$lt_cv_ld_force_load\"; then\n    _LT_TAGVAR(whole_archive_flag_spec, $1)='`for conv in $convenience\\\"\\\"; do test  -n \\\"$conv\\\" && new_convenience=\\\"$new_convenience $wl-force_load,$conv\\\"; done; func_echo_all \\\"$new_convenience\\\"`'\n    m4_case([$1], [F77], [_LT_TAGVAR(compiler_needs_object, $1)=yes],\n                  [FC],  [_LT_TAGVAR(compiler_needs_object, $1)=yes])\n  else\n    _LT_TAGVAR(whole_archive_flag_spec, $1)=''\n  fi\n  _LT_TAGVAR(link_all_deplibs, $1)=yes\n  _LT_TAGVAR(allow_undefined_flag, $1)=$_lt_dar_allow_undefined\n  case $cc_basename in\n     ifort*|nagfor*) _lt_dar_can_shared=yes ;;\n     *) _lt_dar_can_shared=$GCC ;;\n  esac\n  if test yes = \"$_lt_dar_can_shared\"; then\n    output_verbose_link_cmd=func_echo_all\n    _LT_TAGVAR(archive_cmds, $1)=\"\\$CC -dynamiclib \\$allow_undefined_flag -o \\$lib \\$libobjs \\$deplibs \\$compiler_flags -install_name \\$rpath/\\$soname \\$verstring $_lt_dar_single_mod$_lt_dsymutil\"\n    _LT_TAGVAR(module_cmds, $1)=\"\\$CC \\$allow_undefined_flag -o \\$lib -bundle \\$libobjs \\$deplibs \\$compiler_flags$_lt_dsymutil\"\n    _LT_TAGVAR(archive_expsym_cmds, $1)=\"sed 's|^|_|' < \\$export_symbols > \\$output_objdir/\\$libname-symbols.expsym~\\$CC -dynamiclib \\$allow_undefined_flag -o \\$lib \\$libobjs \\$deplibs \\$compiler_flags -install_name \\$rpath/\\$soname \\$verstring $_lt_dar_single_mod$_lt_dar_export_syms$_lt_dsymutil\"\n    _LT_TAGVAR(module_expsym_cmds, $1)=\"sed -e 's|^|_|' < \\$export_symbols > \\$output_objdir/\\$libname-symbols.expsym~\\$CC \\$allow_undefined_flag -o \\$lib -bundle \\$libobjs \\$deplibs \\$compiler_flags$_lt_dar_export_syms$_lt_dsymutil\"\n    m4_if([$1], [CXX],\n[   if test yes != \"$lt_cv_apple_cc_single_mod\"; then\n      _LT_TAGVAR(archive_cmds, $1)=\"\\$CC -r -keep_private_externs -nostdlib -o \\$lib-master.o \\$libobjs~\\$CC -dynamiclib \\$allow_undefined_flag -o \\$lib \\$lib-master.o \\$deplibs \\$compiler_flags -install_name \\$rpath/\\$soname \\$verstring$_lt_dsymutil\"\n      _LT_TAGVAR(archive_expsym_cmds, $1)=\"sed 's|^|_|' < \\$export_symbols > \\$output_objdir/\\$libname-symbols.expsym~\\$CC -r -keep_private_externs -nostdlib -o \\$lib-master.o \\$libobjs~\\$CC -dynamiclib \\$allow_undefined_flag -o \\$lib \\$lib-master.o \\$deplibs \\$compiler_flags -install_name \\$rpath/\\$soname \\$verstring$_lt_dar_export_syms$_lt_dsymutil\"\n    fi\n],[])\n  else\n  _LT_TAGVAR(ld_shlibs, $1)=no\n  fi\n])\n\n# _LT_SYS_MODULE_PATH_AIX([TAGNAME])\n# ----------------------------------\n# Links a minimal program and checks the executable\n# for the system default hardcoded library path. In most cases,\n# this is /usr/lib:/lib, but when the MPI compilers are used\n# the location of the communication and MPI libs are included too.\n# If we don't find anything, use the default library path according\n# to the aix ld manual.\n# Store the results from the different compilers for each TAGNAME.\n# Allow to override them for all tags through lt_cv_aix_libpath.\nm4_defun([_LT_SYS_MODULE_PATH_AIX],\n[m4_require([_LT_DECL_SED])dnl\nif test set = \"${lt_cv_aix_libpath+set}\"; then\n  aix_libpath=$lt_cv_aix_libpath\nelse\n  AC_CACHE_VAL([_LT_TAGVAR([lt_cv_aix_libpath_], [$1])],\n  [AC_LINK_IFELSE([AC_LANG_PROGRAM],[\n  lt_aix_libpath_sed='[\n      /Import File Strings/,/^$/ {\n\t  /^0/ {\n\t      s/^0  *\\([^ ]*\\) *$/\\1/\n\t      p\n\t  }\n      }]'\n  _LT_TAGVAR([lt_cv_aix_libpath_], [$1])=`dump -H conftest$ac_exeext 2>/dev/null | $SED -n -e \"$lt_aix_libpath_sed\"`\n  # Check for a 64-bit object if we didn't find anything.\n  if test -z \"$_LT_TAGVAR([lt_cv_aix_libpath_], [$1])\"; then\n    _LT_TAGVAR([lt_cv_aix_libpath_], [$1])=`dump -HX64 conftest$ac_exeext 2>/dev/null | $SED -n -e \"$lt_aix_libpath_sed\"`\n  fi],[])\n  if test -z \"$_LT_TAGVAR([lt_cv_aix_libpath_], [$1])\"; then\n    _LT_TAGVAR([lt_cv_aix_libpath_], [$1])=/usr/lib:/lib\n  fi\n  ])\n  aix_libpath=$_LT_TAGVAR([lt_cv_aix_libpath_], [$1])\nfi\n])# _LT_SYS_MODULE_PATH_AIX\n\n\n# _LT_SHELL_INIT(ARG)\n# -------------------\nm4_define([_LT_SHELL_INIT],\n[m4_divert_text([M4SH-INIT], [$1\n])])# _LT_SHELL_INIT\n\n\n\n# _LT_PROG_ECHO_BACKSLASH\n# -----------------------\n# Find how we can fake an echo command that does not interpret backslash.\n# In particular, with Autoconf 2.60 or later we add some code to the start\n# of the generated configure script that will find a shell with a builtin\n# printf (that we can use as an echo command).\nm4_defun([_LT_PROG_ECHO_BACKSLASH],\n[ECHO='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\nECHO=$ECHO$ECHO$ECHO$ECHO$ECHO\nECHO=$ECHO$ECHO$ECHO$ECHO$ECHO$ECHO\n\nAC_MSG_CHECKING([how to print strings])\n# Test print first, because it will be a builtin if present.\nif test \"X`( print -r -- -n ) 2>/dev/null`\" = X-n && \\\n   test \"X`print -r -- $ECHO 2>/dev/null`\" = \"X$ECHO\"; then\n  ECHO='print -r --'\nelif test \"X`printf %s $ECHO 2>/dev/null`\" = \"X$ECHO\"; then\n  ECHO='printf %s\\n'\nelse\n  # Use this function as a fallback that always works.\n  func_fallback_echo ()\n  {\n    eval 'cat <<_LTECHO_EOF\n$[]1\n_LTECHO_EOF'\n  }\n  ECHO='func_fallback_echo'\nfi\n\n# func_echo_all arg...\n# Invoke $ECHO with all args, space-separated.\nfunc_echo_all ()\n{\n    $ECHO \"$*\"\n}\n\ncase $ECHO in\n  printf*) AC_MSG_RESULT([printf]) ;;\n  print*) AC_MSG_RESULT([print -r]) ;;\n  *) AC_MSG_RESULT([cat]) ;;\nesac\n\nm4_ifdef([_AS_DETECT_SUGGESTED],\n[_AS_DETECT_SUGGESTED([\n  test -n \"${ZSH_VERSION+set}${BASH_VERSION+set}\" || (\n    ECHO='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'\n    ECHO=$ECHO$ECHO$ECHO$ECHO$ECHO\n    ECHO=$ECHO$ECHO$ECHO$ECHO$ECHO$ECHO\n    PATH=/empty FPATH=/empty; export PATH FPATH\n    test \"X`printf %s $ECHO`\" = \"X$ECHO\" \\\n      || test \"X`print -r -- $ECHO`\" = \"X$ECHO\" )])])\n\n_LT_DECL([], [SHELL], [1], [Shell to use when invoking shell scripts])\n_LT_DECL([], [ECHO], [1], [An echo program that protects backslashes])\n])# _LT_PROG_ECHO_BACKSLASH\n\n\n# _LT_WITH_SYSROOT\n# ----------------\nAC_DEFUN([_LT_WITH_SYSROOT],\n[AC_MSG_CHECKING([for sysroot])\nAC_ARG_WITH([sysroot],\n[AS_HELP_STRING([--with-sysroot@<:@=DIR@:>@],\n  [Search for dependent libraries within DIR (or the compiler's sysroot\n   if not specified).])],\n[], [with_sysroot=no])\n\ndnl lt_sysroot will always be passed unquoted.  We quote it here\ndnl in case the user passed a directory name.\nlt_sysroot=\ncase $with_sysroot in #(\n yes)\n   if test yes = \"$GCC\"; then\n     lt_sysroot=`$CC --print-sysroot 2>/dev/null`\n   fi\n   ;; #(\n /*)\n   lt_sysroot=`echo \"$with_sysroot\" | sed -e \"$sed_quote_subst\"`\n   ;; #(\n no|'')\n   ;; #(\n *)\n   AC_MSG_RESULT([$with_sysroot])\n   AC_MSG_ERROR([The sysroot must be an absolute path.])\n   ;;\nesac\n\n AC_MSG_RESULT([${lt_sysroot:-no}])\n_LT_DECL([], [lt_sysroot], [0], [The root where to search for ]dnl\n[dependent libraries, and where our libraries should be installed.])])\n\n# _LT_ENABLE_LOCK\n# ---------------\nm4_defun([_LT_ENABLE_LOCK],\n[AC_ARG_ENABLE([libtool-lock],\n  [AS_HELP_STRING([--disable-libtool-lock],\n    [avoid locking (might break parallel builds)])])\ntest no = \"$enable_libtool_lock\" || enable_libtool_lock=yes\n\n# Some flags need to be propagated to the compiler or linker for good\n# libtool support.\ncase $host in\nia64-*-hpux*)\n  # Find out what ABI is being produced by ac_compile, and set mode\n  # options accordingly.\n  echo 'int i;' > conftest.$ac_ext\n  if AC_TRY_EVAL(ac_compile); then\n    case `/usr/bin/file conftest.$ac_objext` in\n      *ELF-32*)\n\tHPUX_IA64_MODE=32\n\t;;\n      *ELF-64*)\n\tHPUX_IA64_MODE=64\n\t;;\n    esac\n  fi\n  rm -rf conftest*\n  ;;\n*-*-irix6*)\n  # Find out what ABI is being produced by ac_compile, and set linker\n  # options accordingly.\n  echo '[#]line '$LINENO' \"configure\"' > conftest.$ac_ext\n  if AC_TRY_EVAL(ac_compile); then\n    if test yes = \"$lt_cv_prog_gnu_ld\"; then\n      case `/usr/bin/file conftest.$ac_objext` in\n\t*32-bit*)\n\t  LD=\"${LD-ld} -melf32bsmip\"\n\t  ;;\n\t*N32*)\n\t  LD=\"${LD-ld} -melf32bmipn32\"\n\t  ;;\n\t*64-bit*)\n\t  LD=\"${LD-ld} -melf64bmip\"\n\t;;\n      esac\n    else\n      case `/usr/bin/file conftest.$ac_objext` in\n\t*32-bit*)\n\t  LD=\"${LD-ld} -32\"\n\t  ;;\n\t*N32*)\n\t  LD=\"${LD-ld} -n32\"\n\t  ;;\n\t*64-bit*)\n\t  LD=\"${LD-ld} -64\"\n\t  ;;\n      esac\n    fi\n  fi\n  rm -rf conftest*\n  ;;\n\nmips64*-*linux*)\n  # Find out what ABI is being produced by ac_compile, and set linker\n  # options accordingly.\n  echo '[#]line '$LINENO' \"configure\"' > conftest.$ac_ext\n  if AC_TRY_EVAL(ac_compile); then\n    emul=elf\n    case `/usr/bin/file conftest.$ac_objext` in\n      *32-bit*)\n\temul=\"${emul}32\"\n\t;;\n      *64-bit*)\n\temul=\"${emul}64\"\n\t;;\n    esac\n    case `/usr/bin/file conftest.$ac_objext` in\n      *MSB*)\n\temul=\"${emul}btsmip\"\n\t;;\n      *LSB*)\n\temul=\"${emul}ltsmip\"\n\t;;\n    esac\n    case `/usr/bin/file conftest.$ac_objext` in\n      *N32*)\n\temul=\"${emul}n32\"\n\t;;\n    esac\n    LD=\"${LD-ld} -m $emul\"\n  fi\n  rm -rf conftest*\n  ;;\n\nx86_64-*kfreebsd*-gnu|x86_64-*linux*|powerpc*-*linux*| \\\ns390*-*linux*|s390*-*tpf*|sparc*-*linux*)\n  # Find out what ABI is being produced by ac_compile, and set linker\n  # options accordingly.  Note that the listed cases only cover the\n  # situations where additional linker options are needed (such as when\n  # doing 32-bit compilation for a host where ld defaults to 64-bit, or\n  # vice versa); the common cases where no linker options are needed do\n  # not appear in the list.\n  echo 'int i;' > conftest.$ac_ext\n  if AC_TRY_EVAL(ac_compile); then\n    case `/usr/bin/file conftest.o` in\n      *32-bit*)\n\tcase $host in\n\t  x86_64-*kfreebsd*-gnu)\n\t    LD=\"${LD-ld} -m elf_i386_fbsd\"\n\t    ;;\n\t  x86_64-*linux*)\n\t    case `/usr/bin/file conftest.o` in\n\t      *x86-64*)\n\t\tLD=\"${LD-ld} -m elf32_x86_64\"\n\t\t;;\n\t      *)\n\t\tLD=\"${LD-ld} -m elf_i386\"\n\t\t;;\n\t    esac\n\t    ;;\n\t  powerpc64le-*linux*)\n\t    LD=\"${LD-ld} -m elf32lppclinux\"\n\t    ;;\n\t  powerpc64-*linux*)\n\t    LD=\"${LD-ld} -m elf32ppclinux\"\n\t    ;;\n\t  s390x-*linux*)\n\t    LD=\"${LD-ld} -m elf_s390\"\n\t    ;;\n\t  sparc64-*linux*)\n\t    LD=\"${LD-ld} -m elf32_sparc\"\n\t    ;;\n\tesac\n\t;;\n      *64-bit*)\n\tcase $host in\n\t  x86_64-*kfreebsd*-gnu)\n\t    LD=\"${LD-ld} -m elf_x86_64_fbsd\"\n\t    ;;\n\t  x86_64-*linux*)\n\t    LD=\"${LD-ld} -m elf_x86_64\"\n\t    ;;\n\t  powerpcle-*linux*)\n\t    LD=\"${LD-ld} -m elf64lppc\"\n\t    ;;\n\t  powerpc-*linux*)\n\t    LD=\"${LD-ld} -m elf64ppc\"\n\t    ;;\n\t  s390*-*linux*|s390*-*tpf*)\n\t    LD=\"${LD-ld} -m elf64_s390\"\n\t    ;;\n\t  sparc*-*linux*)\n\t    LD=\"${LD-ld} -m elf64_sparc\"\n\t    ;;\n\tesac\n\t;;\n    esac\n  fi\n  rm -rf conftest*\n  ;;\n\n*-*-sco3.2v5*)\n  # On SCO OpenServer 5, we need -belf to get full-featured binaries.\n  SAVE_CFLAGS=$CFLAGS\n  CFLAGS=\"$CFLAGS -belf\"\n  AC_CACHE_CHECK([whether the C compiler needs -belf], lt_cv_cc_needs_belf,\n    [AC_LANG_PUSH(C)\n     AC_LINK_IFELSE([AC_LANG_PROGRAM([[]],[[]])],[lt_cv_cc_needs_belf=yes],[lt_cv_cc_needs_belf=no])\n     AC_LANG_POP])\n  if test yes != \"$lt_cv_cc_needs_belf\"; then\n    # this is probably gcc 2.8.0, egcs 1.0 or newer; no need for -belf\n    CFLAGS=$SAVE_CFLAGS\n  fi\n  ;;\n*-*solaris*)\n  # Find out what ABI is being produced by ac_compile, and set linker\n  # options accordingly.\n  echo 'int i;' > conftest.$ac_ext\n  if AC_TRY_EVAL(ac_compile); then\n    case `/usr/bin/file conftest.o` in\n    *64-bit*)\n      case $lt_cv_prog_gnu_ld in\n      yes*)\n        case $host in\n        i?86-*-solaris*|x86_64-*-solaris*)\n          LD=\"${LD-ld} -m elf_x86_64\"\n          ;;\n        sparc*-*-solaris*)\n          LD=\"${LD-ld} -m elf64_sparc\"\n          ;;\n        esac\n        # GNU ld 2.21 introduced _sol2 emulations.  Use them if available.\n        if ${LD-ld} -V | grep _sol2 >/dev/null 2>&1; then\n          LD=${LD-ld}_sol2\n        fi\n        ;;\n      *)\n\tif ${LD-ld} -64 -r -o conftest2.o conftest.o >/dev/null 2>&1; then\n\t  LD=\"${LD-ld} -64\"\n\tfi\n\t;;\n      esac\n      ;;\n    esac\n  fi\n  rm -rf conftest*\n  ;;\nesac\n\nneed_locks=$enable_libtool_lock\n])# _LT_ENABLE_LOCK\n\n\n# _LT_PROG_AR\n# -----------\nm4_defun([_LT_PROG_AR],\n[AC_CHECK_TOOLS(AR, [ar], false)\n: ${AR=ar}\n: ${AR_FLAGS=cru}\n_LT_DECL([], [AR], [1], [The archiver])\n_LT_DECL([], [AR_FLAGS], [1], [Flags to create an archive])\n\nAC_CACHE_CHECK([for archiver @FILE support], [lt_cv_ar_at_file],\n  [lt_cv_ar_at_file=no\n   AC_COMPILE_IFELSE([AC_LANG_PROGRAM],\n     [echo conftest.$ac_objext > conftest.lst\n      lt_ar_try='$AR $AR_FLAGS libconftest.a @conftest.lst >&AS_MESSAGE_LOG_FD'\n      AC_TRY_EVAL([lt_ar_try])\n      if test 0 -eq \"$ac_status\"; then\n\t# Ensure the archiver fails upon bogus file names.\n\trm -f conftest.$ac_objext libconftest.a\n\tAC_TRY_EVAL([lt_ar_try])\n\tif test 0 -ne \"$ac_status\"; then\n          lt_cv_ar_at_file=@\n        fi\n      fi\n      rm -f conftest.* libconftest.a\n     ])\n  ])\n\nif test no = \"$lt_cv_ar_at_file\"; then\n  archiver_list_spec=\nelse\n  archiver_list_spec=$lt_cv_ar_at_file\nfi\n_LT_DECL([], [archiver_list_spec], [1],\n  [How to feed a file listing to the archiver])\n])# _LT_PROG_AR\n\n\n# _LT_CMD_OLD_ARCHIVE\n# -------------------\nm4_defun([_LT_CMD_OLD_ARCHIVE],\n[_LT_PROG_AR\n\nAC_CHECK_TOOL(STRIP, strip, :)\ntest -z \"$STRIP\" && STRIP=:\n_LT_DECL([], [STRIP], [1], [A symbol stripping program])\n\nAC_CHECK_TOOL(RANLIB, ranlib, :)\ntest -z \"$RANLIB\" && RANLIB=:\n_LT_DECL([], [RANLIB], [1],\n    [Commands used to install an old-style archive])\n\n# Determine commands to create old-style static archives.\nold_archive_cmds='$AR $AR_FLAGS $oldlib$oldobjs'\nold_postinstall_cmds='chmod 644 $oldlib'\nold_postuninstall_cmds=\n\nif test -n \"$RANLIB\"; then\n  case $host_os in\n  bitrig* | openbsd*)\n    old_postinstall_cmds=\"$old_postinstall_cmds~\\$RANLIB -t \\$tool_oldlib\"\n    ;;\n  *)\n    old_postinstall_cmds=\"$old_postinstall_cmds~\\$RANLIB \\$tool_oldlib\"\n    ;;\n  esac\n  old_archive_cmds=\"$old_archive_cmds~\\$RANLIB \\$tool_oldlib\"\nfi\n\ncase $host_os in\n  darwin*)\n    lock_old_archive_extraction=yes ;;\n  *)\n    lock_old_archive_extraction=no ;;\nesac\n_LT_DECL([], [old_postinstall_cmds], [2])\n_LT_DECL([], [old_postuninstall_cmds], [2])\n_LT_TAGDECL([], [old_archive_cmds], [2],\n    [Commands used to build an old-style archive])\n_LT_DECL([], [lock_old_archive_extraction], [0],\n    [Whether to use a lock for old archive extraction])\n])# _LT_CMD_OLD_ARCHIVE\n\n\n# _LT_COMPILER_OPTION(MESSAGE, VARIABLE-NAME, FLAGS,\n#\t\t[OUTPUT-FILE], [ACTION-SUCCESS], [ACTION-FAILURE])\n# ----------------------------------------------------------------\n# Check whether the given compiler option works\nAC_DEFUN([_LT_COMPILER_OPTION],\n[m4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_DECL_SED])dnl\nAC_CACHE_CHECK([$1], [$2],\n  [$2=no\n   m4_if([$4], , [ac_outfile=conftest.$ac_objext], [ac_outfile=$4])\n   echo \"$lt_simple_compile_test_code\" > conftest.$ac_ext\n   lt_compiler_flag=\"$3\"  ## exclude from sc_useless_quotes_in_assignment\n   # Insert the option either (1) after the last *FLAGS variable, or\n   # (2) before a word containing \"conftest.\", or (3) at the end.\n   # Note that $ac_compile itself does not contain backslashes and begins\n   # with a dollar sign (not a hyphen), so the echo should work correctly.\n   # The option is referenced via a variable to avoid confusing sed.\n   lt_compile=`echo \"$ac_compile\" | $SED \\\n   -e 's:.*FLAGS}\\{0,1\\} :&$lt_compiler_flag :; t' \\\n   -e 's: [[^ ]]*conftest\\.: $lt_compiler_flag&:; t' \\\n   -e 's:$: $lt_compiler_flag:'`\n   (eval echo \"\\\"\\$as_me:$LINENO: $lt_compile\\\"\" >&AS_MESSAGE_LOG_FD)\n   (eval \"$lt_compile\" 2>conftest.err)\n   ac_status=$?\n   cat conftest.err >&AS_MESSAGE_LOG_FD\n   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&AS_MESSAGE_LOG_FD\n   if (exit $ac_status) && test -s \"$ac_outfile\"; then\n     # The compiler can only warn and ignore the option if not recognized\n     # So say no if there are warnings other than the usual output.\n     $ECHO \"$_lt_compiler_boilerplate\" | $SED '/^$/d' >conftest.exp\n     $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2\n     if test ! -s conftest.er2 || diff conftest.exp conftest.er2 >/dev/null; then\n       $2=yes\n     fi\n   fi\n   $RM conftest*\n])\n\nif test yes = \"[$]$2\"; then\n    m4_if([$5], , :, [$5])\nelse\n    m4_if([$6], , :, [$6])\nfi\n])# _LT_COMPILER_OPTION\n\n# Old name:\nAU_ALIAS([AC_LIBTOOL_COMPILER_OPTION], [_LT_COMPILER_OPTION])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_COMPILER_OPTION], [])\n\n\n# _LT_LINKER_OPTION(MESSAGE, VARIABLE-NAME, FLAGS,\n#                  [ACTION-SUCCESS], [ACTION-FAILURE])\n# ----------------------------------------------------\n# Check whether the given linker option works\nAC_DEFUN([_LT_LINKER_OPTION],\n[m4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_DECL_SED])dnl\nAC_CACHE_CHECK([$1], [$2],\n  [$2=no\n   save_LDFLAGS=$LDFLAGS\n   LDFLAGS=\"$LDFLAGS $3\"\n   echo \"$lt_simple_link_test_code\" > conftest.$ac_ext\n   if (eval $ac_link 2>conftest.err) && test -s conftest$ac_exeext; then\n     # The linker can only warn and ignore the option if not recognized\n     # So say no if there are warnings\n     if test -s conftest.err; then\n       # Append any errors to the config.log.\n       cat conftest.err 1>&AS_MESSAGE_LOG_FD\n       $ECHO \"$_lt_linker_boilerplate\" | $SED '/^$/d' > conftest.exp\n       $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2\n       if diff conftest.exp conftest.er2 >/dev/null; then\n         $2=yes\n       fi\n     else\n       $2=yes\n     fi\n   fi\n   $RM -r conftest*\n   LDFLAGS=$save_LDFLAGS\n])\n\nif test yes = \"[$]$2\"; then\n    m4_if([$4], , :, [$4])\nelse\n    m4_if([$5], , :, [$5])\nfi\n])# _LT_LINKER_OPTION\n\n# Old name:\nAU_ALIAS([AC_LIBTOOL_LINKER_OPTION], [_LT_LINKER_OPTION])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_LINKER_OPTION], [])\n\n\n# LT_CMD_MAX_LEN\n#---------------\nAC_DEFUN([LT_CMD_MAX_LEN],\n[AC_REQUIRE([AC_CANONICAL_HOST])dnl\n# find the maximum length of command line arguments\nAC_MSG_CHECKING([the maximum length of command line arguments])\nAC_CACHE_VAL([lt_cv_sys_max_cmd_len], [dnl\n  i=0\n  teststring=ABCD\n\n  case $build_os in\n  msdosdjgpp*)\n    # On DJGPP, this test can blow up pretty badly due to problems in libc\n    # (any single argument exceeding 2000 bytes causes a buffer overrun\n    # during glob expansion).  Even if it were fixed, the result of this\n    # check would be larger than it should be.\n    lt_cv_sys_max_cmd_len=12288;    # 12K is about right\n    ;;\n\n  gnu*)\n    # Under GNU Hurd, this test is not required because there is\n    # no limit to the length of command line arguments.\n    # Libtool will interpret -1 as no limit whatsoever\n    lt_cv_sys_max_cmd_len=-1;\n    ;;\n\n  cygwin* | mingw* | cegcc*)\n    # On Win9x/ME, this test blows up -- it succeeds, but takes\n    # about 5 minutes as the teststring grows exponentially.\n    # Worse, since 9x/ME are not pre-emptively multitasking,\n    # you end up with a \"frozen\" computer, even though with patience\n    # the test eventually succeeds (with a max line length of 256k).\n    # Instead, let's just punt: use the minimum linelength reported by\n    # all of the supported platforms: 8192 (on NT/2K/XP).\n    lt_cv_sys_max_cmd_len=8192;\n    ;;\n\n  mint*)\n    # On MiNT this can take a long time and run out of memory.\n    lt_cv_sys_max_cmd_len=8192;\n    ;;\n\n  amigaos*)\n    # On AmigaOS with pdksh, this test takes hours, literally.\n    # So we just punt and use a minimum line length of 8192.\n    lt_cv_sys_max_cmd_len=8192;\n    ;;\n\n  bitrig* | darwin* | dragonfly* | freebsd* | netbsd* | openbsd*)\n    # This has been around since 386BSD, at least.  Likely further.\n    if test -x /sbin/sysctl; then\n      lt_cv_sys_max_cmd_len=`/sbin/sysctl -n kern.argmax`\n    elif test -x /usr/sbin/sysctl; then\n      lt_cv_sys_max_cmd_len=`/usr/sbin/sysctl -n kern.argmax`\n    else\n      lt_cv_sys_max_cmd_len=65536\t# usable default for all BSDs\n    fi\n    # And add a safety zone\n    lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \\/ 4`\n    lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \\* 3`\n    ;;\n\n  interix*)\n    # We know the value 262144 and hardcode it with a safety zone (like BSD)\n    lt_cv_sys_max_cmd_len=196608\n    ;;\n\n  os2*)\n    # The test takes a long time on OS/2.\n    lt_cv_sys_max_cmd_len=8192\n    ;;\n\n  osf*)\n    # Dr. Hans Ekkehard Plesser reports seeing a kernel panic running configure\n    # due to this test when exec_disable_arg_limit is 1 on Tru64. It is not\n    # nice to cause kernel panics so lets avoid the loop below.\n    # First set a reasonable default.\n    lt_cv_sys_max_cmd_len=16384\n    #\n    if test -x /sbin/sysconfig; then\n      case `/sbin/sysconfig -q proc exec_disable_arg_limit` in\n        *1*) lt_cv_sys_max_cmd_len=-1 ;;\n      esac\n    fi\n    ;;\n  sco3.2v5*)\n    lt_cv_sys_max_cmd_len=102400\n    ;;\n  sysv5* | sco5v6* | sysv4.2uw2*)\n    kargmax=`grep ARG_MAX /etc/conf/cf.d/stune 2>/dev/null`\n    if test -n \"$kargmax\"; then\n      lt_cv_sys_max_cmd_len=`echo $kargmax | sed 's/.*[[\t ]]//'`\n    else\n      lt_cv_sys_max_cmd_len=32768\n    fi\n    ;;\n  *)\n    lt_cv_sys_max_cmd_len=`(getconf ARG_MAX) 2> /dev/null`\n    if test -n \"$lt_cv_sys_max_cmd_len\" && \\\n       test undefined != \"$lt_cv_sys_max_cmd_len\"; then\n      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \\/ 4`\n      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \\* 3`\n    else\n      # Make teststring a little bigger before we do anything with it.\n      # a 1K string should be a reasonable start.\n      for i in 1 2 3 4 5 6 7 8; do\n        teststring=$teststring$teststring\n      done\n      SHELL=${SHELL-${CONFIG_SHELL-/bin/sh}}\n      # If test is not a shell built-in, we'll probably end up computing a\n      # maximum length that is only half of the actual maximum length, but\n      # we can't tell.\n      while { test X`env echo \"$teststring$teststring\" 2>/dev/null` \\\n\t         = \"X$teststring$teststring\"; } >/dev/null 2>&1 &&\n\t      test 17 != \"$i\" # 1/2 MB should be enough\n      do\n        i=`expr $i + 1`\n        teststring=$teststring$teststring\n      done\n      # Only check the string length outside the loop.\n      lt_cv_sys_max_cmd_len=`expr \"X$teststring\" : \".*\" 2>&1`\n      teststring=\n      # Add a significant safety factor because C++ compilers can tack on\n      # massive amounts of additional arguments before passing them to the\n      # linker.  It appears as though 1/2 is a usable value.\n      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \\/ 2`\n    fi\n    ;;\n  esac\n])\nif test -n \"$lt_cv_sys_max_cmd_len\"; then\n  AC_MSG_RESULT($lt_cv_sys_max_cmd_len)\nelse\n  AC_MSG_RESULT(none)\nfi\nmax_cmd_len=$lt_cv_sys_max_cmd_len\n_LT_DECL([], [max_cmd_len], [0],\n    [What is the maximum length of a command?])\n])# LT_CMD_MAX_LEN\n\n# Old name:\nAU_ALIAS([AC_LIBTOOL_SYS_MAX_CMD_LEN], [LT_CMD_MAX_LEN])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_SYS_MAX_CMD_LEN], [])\n\n\n# _LT_HEADER_DLFCN\n# ----------------\nm4_defun([_LT_HEADER_DLFCN],\n[AC_CHECK_HEADERS([dlfcn.h], [], [], [AC_INCLUDES_DEFAULT])dnl\n])# _LT_HEADER_DLFCN\n\n\n# _LT_TRY_DLOPEN_SELF (ACTION-IF-TRUE, ACTION-IF-TRUE-W-USCORE,\n#                      ACTION-IF-FALSE, ACTION-IF-CROSS-COMPILING)\n# ----------------------------------------------------------------\nm4_defun([_LT_TRY_DLOPEN_SELF],\n[m4_require([_LT_HEADER_DLFCN])dnl\nif test yes = \"$cross_compiling\"; then :\n  [$4]\nelse\n  lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n  lt_status=$lt_dlunknown\n  cat > conftest.$ac_ext <<_LT_EOF\n[#line $LINENO \"configure\"\n#include \"confdefs.h\"\n\n#if HAVE_DLFCN_H\n#include <dlfcn.h>\n#endif\n\n#include <stdio.h>\n\n#ifdef RTLD_GLOBAL\n#  define LT_DLGLOBAL\t\tRTLD_GLOBAL\n#else\n#  ifdef DL_GLOBAL\n#    define LT_DLGLOBAL\t\tDL_GLOBAL\n#  else\n#    define LT_DLGLOBAL\t\t0\n#  endif\n#endif\n\n/* We may have to define LT_DLLAZY_OR_NOW in the command line if we\n   find out it does not work in some platform. */\n#ifndef LT_DLLAZY_OR_NOW\n#  ifdef RTLD_LAZY\n#    define LT_DLLAZY_OR_NOW\t\tRTLD_LAZY\n#  else\n#    ifdef DL_LAZY\n#      define LT_DLLAZY_OR_NOW\t\tDL_LAZY\n#    else\n#      ifdef RTLD_NOW\n#        define LT_DLLAZY_OR_NOW\tRTLD_NOW\n#      else\n#        ifdef DL_NOW\n#          define LT_DLLAZY_OR_NOW\tDL_NOW\n#        else\n#          define LT_DLLAZY_OR_NOW\t0\n#        endif\n#      endif\n#    endif\n#  endif\n#endif\n\n/* When -fvisibility=hidden is used, assume the code has been annotated\n   correspondingly for the symbols needed.  */\n#if defined __GNUC__ && (((__GNUC__ == 3) && (__GNUC_MINOR__ >= 3)) || (__GNUC__ > 3))\nint fnord () __attribute__((visibility(\"default\")));\n#endif\n\nint fnord () { return 42; }\nint main ()\n{\n  void *self = dlopen (0, LT_DLGLOBAL|LT_DLLAZY_OR_NOW);\n  int status = $lt_dlunknown;\n\n  if (self)\n    {\n      if (dlsym (self,\"fnord\"))       status = $lt_dlno_uscore;\n      else\n        {\n\t  if (dlsym( self,\"_fnord\"))  status = $lt_dlneed_uscore;\n          else puts (dlerror ());\n\t}\n      /* dlclose (self); */\n    }\n  else\n    puts (dlerror ());\n\n  return status;\n}]\n_LT_EOF\n  if AC_TRY_EVAL(ac_link) && test -s \"conftest$ac_exeext\" 2>/dev/null; then\n    (./conftest; exit; ) >&AS_MESSAGE_LOG_FD 2>/dev/null\n    lt_status=$?\n    case x$lt_status in\n      x$lt_dlno_uscore) $1 ;;\n      x$lt_dlneed_uscore) $2 ;;\n      x$lt_dlunknown|x*) $3 ;;\n    esac\n  else :\n    # compilation failed\n    $3\n  fi\nfi\nrm -fr conftest*\n])# _LT_TRY_DLOPEN_SELF\n\n\n# LT_SYS_DLOPEN_SELF\n# ------------------\nAC_DEFUN([LT_SYS_DLOPEN_SELF],\n[m4_require([_LT_HEADER_DLFCN])dnl\nif test yes != \"$enable_dlopen\"; then\n  enable_dlopen=unknown\n  enable_dlopen_self=unknown\n  enable_dlopen_self_static=unknown\nelse\n  lt_cv_dlopen=no\n  lt_cv_dlopen_libs=\n\n  case $host_os in\n  beos*)\n    lt_cv_dlopen=load_add_on\n    lt_cv_dlopen_libs=\n    lt_cv_dlopen_self=yes\n    ;;\n\n  mingw* | pw32* | cegcc*)\n    lt_cv_dlopen=LoadLibrary\n    lt_cv_dlopen_libs=\n    ;;\n\n  cygwin*)\n    lt_cv_dlopen=dlopen\n    lt_cv_dlopen_libs=\n    ;;\n\n  darwin*)\n    # if libdl is installed we need to link against it\n    AC_CHECK_LIB([dl], [dlopen],\n\t\t[lt_cv_dlopen=dlopen lt_cv_dlopen_libs=-ldl],[\n    lt_cv_dlopen=dyld\n    lt_cv_dlopen_libs=\n    lt_cv_dlopen_self=yes\n    ])\n    ;;\n\n  tpf*)\n    # Don't try to run any link tests for TPF.  We know it's impossible\n    # because TPF is a cross-compiler, and we know how we open DSOs.\n    lt_cv_dlopen=dlopen\n    lt_cv_dlopen_libs=\n    lt_cv_dlopen_self=no\n    ;;\n\n  *)\n    AC_CHECK_FUNC([shl_load],\n\t  [lt_cv_dlopen=shl_load],\n      [AC_CHECK_LIB([dld], [shl_load],\n\t    [lt_cv_dlopen=shl_load lt_cv_dlopen_libs=-ldld],\n\t[AC_CHECK_FUNC([dlopen],\n\t      [lt_cv_dlopen=dlopen],\n\t  [AC_CHECK_LIB([dl], [dlopen],\n\t\t[lt_cv_dlopen=dlopen lt_cv_dlopen_libs=-ldl],\n\t    [AC_CHECK_LIB([svld], [dlopen],\n\t\t  [lt_cv_dlopen=dlopen lt_cv_dlopen_libs=-lsvld],\n\t      [AC_CHECK_LIB([dld], [dld_link],\n\t\t    [lt_cv_dlopen=dld_link lt_cv_dlopen_libs=-ldld])\n\t      ])\n\t    ])\n\t  ])\n\t])\n      ])\n    ;;\n  esac\n\n  if test no = \"$lt_cv_dlopen\"; then\n    enable_dlopen=no\n  else\n    enable_dlopen=yes\n  fi\n\n  case $lt_cv_dlopen in\n  dlopen)\n    save_CPPFLAGS=$CPPFLAGS\n    test yes = \"$ac_cv_header_dlfcn_h\" && CPPFLAGS=\"$CPPFLAGS -DHAVE_DLFCN_H\"\n\n    save_LDFLAGS=$LDFLAGS\n    wl=$lt_prog_compiler_wl eval LDFLAGS=\\\"\\$LDFLAGS $export_dynamic_flag_spec\\\"\n\n    save_LIBS=$LIBS\n    LIBS=\"$lt_cv_dlopen_libs $LIBS\"\n\n    AC_CACHE_CHECK([whether a program can dlopen itself],\n\t  lt_cv_dlopen_self, [dnl\n\t  _LT_TRY_DLOPEN_SELF(\n\t    lt_cv_dlopen_self=yes, lt_cv_dlopen_self=yes,\n\t    lt_cv_dlopen_self=no, lt_cv_dlopen_self=cross)\n    ])\n\n    if test yes = \"$lt_cv_dlopen_self\"; then\n      wl=$lt_prog_compiler_wl eval LDFLAGS=\\\"\\$LDFLAGS $lt_prog_compiler_static\\\"\n      AC_CACHE_CHECK([whether a statically linked program can dlopen itself],\n\t  lt_cv_dlopen_self_static, [dnl\n\t  _LT_TRY_DLOPEN_SELF(\n\t    lt_cv_dlopen_self_static=yes, lt_cv_dlopen_self_static=yes,\n\t    lt_cv_dlopen_self_static=no,  lt_cv_dlopen_self_static=cross)\n      ])\n    fi\n\n    CPPFLAGS=$save_CPPFLAGS\n    LDFLAGS=$save_LDFLAGS\n    LIBS=$save_LIBS\n    ;;\n  esac\n\n  case $lt_cv_dlopen_self in\n  yes|no) enable_dlopen_self=$lt_cv_dlopen_self ;;\n  *) enable_dlopen_self=unknown ;;\n  esac\n\n  case $lt_cv_dlopen_self_static in\n  yes|no) enable_dlopen_self_static=$lt_cv_dlopen_self_static ;;\n  *) enable_dlopen_self_static=unknown ;;\n  esac\nfi\n_LT_DECL([dlopen_support], [enable_dlopen], [0],\n\t [Whether dlopen is supported])\n_LT_DECL([dlopen_self], [enable_dlopen_self], [0],\n\t [Whether dlopen of programs is supported])\n_LT_DECL([dlopen_self_static], [enable_dlopen_self_static], [0],\n\t [Whether dlopen of statically linked programs is supported])\n])# LT_SYS_DLOPEN_SELF\n\n# Old name:\nAU_ALIAS([AC_LIBTOOL_DLOPEN_SELF], [LT_SYS_DLOPEN_SELF])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_DLOPEN_SELF], [])\n\n\n# _LT_COMPILER_C_O([TAGNAME])\n# ---------------------------\n# Check to see if options -c and -o are simultaneously supported by compiler.\n# This macro does not hard code the compiler like AC_PROG_CC_C_O.\nm4_defun([_LT_COMPILER_C_O],\n[m4_require([_LT_DECL_SED])dnl\nm4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_TAG_COMPILER])dnl\nAC_CACHE_CHECK([if $compiler supports -c -o file.$ac_objext],\n  [_LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)],\n  [_LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)=no\n   $RM -r conftest 2>/dev/null\n   mkdir conftest\n   cd conftest\n   mkdir out\n   echo \"$lt_simple_compile_test_code\" > conftest.$ac_ext\n\n   lt_compiler_flag=\"-o out/conftest2.$ac_objext\"\n   # Insert the option either (1) after the last *FLAGS variable, or\n   # (2) before a word containing \"conftest.\", or (3) at the end.\n   # Note that $ac_compile itself does not contain backslashes and begins\n   # with a dollar sign (not a hyphen), so the echo should work correctly.\n   lt_compile=`echo \"$ac_compile\" | $SED \\\n   -e 's:.*FLAGS}\\{0,1\\} :&$lt_compiler_flag :; t' \\\n   -e 's: [[^ ]]*conftest\\.: $lt_compiler_flag&:; t' \\\n   -e 's:$: $lt_compiler_flag:'`\n   (eval echo \"\\\"\\$as_me:$LINENO: $lt_compile\\\"\" >&AS_MESSAGE_LOG_FD)\n   (eval \"$lt_compile\" 2>out/conftest.err)\n   ac_status=$?\n   cat out/conftest.err >&AS_MESSAGE_LOG_FD\n   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&AS_MESSAGE_LOG_FD\n   if (exit $ac_status) && test -s out/conftest2.$ac_objext\n   then\n     # The compiler can only warn and ignore the option if not recognized\n     # So say no if there are warnings\n     $ECHO \"$_lt_compiler_boilerplate\" | $SED '/^$/d' > out/conftest.exp\n     $SED '/^$/d; /^ *+/d' out/conftest.err >out/conftest.er2\n     if test ! -s out/conftest.er2 || diff out/conftest.exp out/conftest.er2 >/dev/null; then\n       _LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)=yes\n     fi\n   fi\n   chmod u+w . 2>&AS_MESSAGE_LOG_FD\n   $RM conftest*\n   # SGI C++ compiler will create directory out/ii_files/ for\n   # template instantiation\n   test -d out/ii_files && $RM out/ii_files/* && rmdir out/ii_files\n   $RM out/* && rmdir out\n   cd ..\n   $RM -r conftest\n   $RM conftest*\n])\n_LT_TAGDECL([compiler_c_o], [lt_cv_prog_compiler_c_o], [1],\n\t[Does compiler simultaneously support -c and -o options?])\n])# _LT_COMPILER_C_O\n\n\n# _LT_COMPILER_FILE_LOCKS([TAGNAME])\n# ----------------------------------\n# Check to see if we can do hard links to lock some files if needed\nm4_defun([_LT_COMPILER_FILE_LOCKS],\n[m4_require([_LT_ENABLE_LOCK])dnl\nm4_require([_LT_FILEUTILS_DEFAULTS])dnl\n_LT_COMPILER_C_O([$1])\n\nhard_links=nottested\nif test no = \"$_LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)\" && test no != \"$need_locks\"; then\n  # do not overwrite the value of need_locks provided by the user\n  AC_MSG_CHECKING([if we can lock with hard links])\n  hard_links=yes\n  $RM conftest*\n  ln conftest.a conftest.b 2>/dev/null && hard_links=no\n  touch conftest.a\n  ln conftest.a conftest.b 2>&5 || hard_links=no\n  ln conftest.a conftest.b 2>/dev/null && hard_links=no\n  AC_MSG_RESULT([$hard_links])\n  if test no = \"$hard_links\"; then\n    AC_MSG_WARN(['$CC' does not support '-c -o', so 'make -j' may be unsafe])\n    need_locks=warn\n  fi\nelse\n  need_locks=no\nfi\n_LT_DECL([], [need_locks], [1], [Must we lock files when doing compilation?])\n])# _LT_COMPILER_FILE_LOCKS\n\n\n# _LT_CHECK_OBJDIR\n# ----------------\nm4_defun([_LT_CHECK_OBJDIR],\n[AC_CACHE_CHECK([for objdir], [lt_cv_objdir],\n[rm -f .libs 2>/dev/null\nmkdir .libs 2>/dev/null\nif test -d .libs; then\n  lt_cv_objdir=.libs\nelse\n  # MS-DOS does not allow filenames that begin with a dot.\n  lt_cv_objdir=_libs\nfi\nrmdir .libs 2>/dev/null])\nobjdir=$lt_cv_objdir\n_LT_DECL([], [objdir], [0],\n         [The name of the directory that contains temporary libtool files])dnl\nm4_pattern_allow([LT_OBJDIR])dnl\nAC_DEFINE_UNQUOTED([LT_OBJDIR], \"$lt_cv_objdir/\",\n  [Define to the sub-directory where libtool stores uninstalled libraries.])\n])# _LT_CHECK_OBJDIR\n\n\n# _LT_LINKER_HARDCODE_LIBPATH([TAGNAME])\n# --------------------------------------\n# Check hardcoding attributes.\nm4_defun([_LT_LINKER_HARDCODE_LIBPATH],\n[AC_MSG_CHECKING([how to hardcode library paths into programs])\n_LT_TAGVAR(hardcode_action, $1)=\nif test -n \"$_LT_TAGVAR(hardcode_libdir_flag_spec, $1)\" ||\n   test -n \"$_LT_TAGVAR(runpath_var, $1)\" ||\n   test yes = \"$_LT_TAGVAR(hardcode_automatic, $1)\"; then\n\n  # We can hardcode non-existent directories.\n  if test no != \"$_LT_TAGVAR(hardcode_direct, $1)\" &&\n     # If the only mechanism to avoid hardcoding is shlibpath_var, we\n     # have to relink, otherwise we might link with an installed library\n     # when we should be linking with a yet-to-be-installed one\n     ## test no != \"$_LT_TAGVAR(hardcode_shlibpath_var, $1)\" &&\n     test no != \"$_LT_TAGVAR(hardcode_minus_L, $1)\"; then\n    # Linking always hardcodes the temporary library directory.\n    _LT_TAGVAR(hardcode_action, $1)=relink\n  else\n    # We can link without hardcoding, and we can hardcode nonexisting dirs.\n    _LT_TAGVAR(hardcode_action, $1)=immediate\n  fi\nelse\n  # We cannot hardcode anything, or else we can only hardcode existing\n  # directories.\n  _LT_TAGVAR(hardcode_action, $1)=unsupported\nfi\nAC_MSG_RESULT([$_LT_TAGVAR(hardcode_action, $1)])\n\nif test relink = \"$_LT_TAGVAR(hardcode_action, $1)\" ||\n   test yes = \"$_LT_TAGVAR(inherit_rpath, $1)\"; then\n  # Fast installation is not supported\n  enable_fast_install=no\nelif test yes = \"$shlibpath_overrides_runpath\" ||\n     test no = \"$enable_shared\"; then\n  # Fast installation is not necessary\n  enable_fast_install=needless\nfi\n_LT_TAGDECL([], [hardcode_action], [0],\n    [How to hardcode a shared library path into an executable])\n])# _LT_LINKER_HARDCODE_LIBPATH\n\n\n# _LT_CMD_STRIPLIB\n# ----------------\nm4_defun([_LT_CMD_STRIPLIB],\n[m4_require([_LT_DECL_EGREP])\nstriplib=\nold_striplib=\nAC_MSG_CHECKING([whether stripping libraries is possible])\nif test -n \"$STRIP\" && $STRIP -V 2>&1 | $GREP \"GNU strip\" >/dev/null; then\n  test -z \"$old_striplib\" && old_striplib=\"$STRIP --strip-debug\"\n  test -z \"$striplib\" && striplib=\"$STRIP --strip-unneeded\"\n  AC_MSG_RESULT([yes])\nelse\n# FIXME - insert some real tests, host_os isn't really good enough\n  case $host_os in\n  darwin*)\n    if test -n \"$STRIP\"; then\n      striplib=\"$STRIP -x\"\n      old_striplib=\"$STRIP -S\"\n      AC_MSG_RESULT([yes])\n    else\n      AC_MSG_RESULT([no])\n    fi\n    ;;\n  *)\n    AC_MSG_RESULT([no])\n    ;;\n  esac\nfi\n_LT_DECL([], [old_striplib], [1], [Commands to strip libraries])\n_LT_DECL([], [striplib], [1])\n])# _LT_CMD_STRIPLIB\n\n\n# _LT_PREPARE_MUNGE_PATH_LIST\n# ---------------------------\n# Make sure func_munge_path_list() is defined correctly.\nm4_defun([_LT_PREPARE_MUNGE_PATH_LIST],\n[[# func_munge_path_list VARIABLE PATH\n# -----------------------------------\n# VARIABLE is name of variable containing _space_ separated list of\n# directories to be munged by the contents of PATH, which is string\n# having a format:\n# \"DIR[:DIR]:\"\n#       string \"DIR[ DIR]\" will be prepended to VARIABLE\n# \":DIR[:DIR]\"\n#       string \"DIR[ DIR]\" will be appended to VARIABLE\n# \"DIRP[:DIRP]::[DIRA:]DIRA\"\n#       string \"DIRP[ DIRP]\" will be prepended to VARIABLE and string\n#       \"DIRA[ DIRA]\" will be appended to VARIABLE\n# \"DIR[:DIR]\"\n#       VARIABLE will be replaced by \"DIR[ DIR]\"\nfunc_munge_path_list ()\n{\n    case x@S|@2 in\n    x)\n        ;;\n    *:)\n        eval @S|@1=\\\"`$ECHO @S|@2 | $SED 's/:/ /g'` \\@S|@@S|@1\\\"\n        ;;\n    x:*)\n        eval @S|@1=\\\"\\@S|@@S|@1 `$ECHO @S|@2 | $SED 's/:/ /g'`\\\"\n        ;;\n    *::*)\n        eval @S|@1=\\\"\\@S|@@S|@1\\ `$ECHO @S|@2 | $SED -e 's/.*:://' -e 's/:/ /g'`\\\"\n        eval @S|@1=\\\"`$ECHO @S|@2 | $SED -e 's/::.*//' -e 's/:/ /g'`\\ \\@S|@@S|@1\\\"\n        ;;\n    *)\n        eval @S|@1=\\\"`$ECHO @S|@2 | $SED 's/:/ /g'`\\\"\n        ;;\n    esac\n}\n]])# _LT_PREPARE_PATH_LIST\n\n\n# _LT_SYS_DYNAMIC_LINKER([TAG])\n# -----------------------------\n# PORTME Fill in your ld.so characteristics\nm4_defun([_LT_SYS_DYNAMIC_LINKER],\n[AC_REQUIRE([AC_CANONICAL_HOST])dnl\nm4_require([_LT_DECL_EGREP])dnl\nm4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_DECL_OBJDUMP])dnl\nm4_require([_LT_DECL_SED])dnl\nm4_require([_LT_CHECK_SHELL_FEATURES])dnl\nm4_require([_LT_PREPARE_MUNGE_PATH_LIST])dnl\nAC_MSG_CHECKING([dynamic linker characteristics])\nm4_if([$1],\n\t[], [\nif test yes = \"$GCC\"; then\n  case $host_os in\n    darwin*) lt_awk_arg='/^libraries:/,/LR/' ;;\n    *) lt_awk_arg='/^libraries:/' ;;\n  esac\n  case $host_os in\n    mingw* | cegcc*) lt_sed_strip_eq='s|=\\([[A-Za-z]]:\\)|\\1|g' ;;\n    *) lt_sed_strip_eq='s|=/|/|g' ;;\n  esac\n  lt_search_path_spec=`$CC -print-search-dirs | awk $lt_awk_arg | $SED -e \"s/^libraries://\" -e $lt_sed_strip_eq`\n  case $lt_search_path_spec in\n  *\\;*)\n    # if the path contains \";\" then we assume it to be the separator\n    # otherwise default to the standard path separator (i.e. \":\") - it is\n    # assumed that no part of a normal pathname contains \";\" but that should\n    # okay in the real world where \";\" in dirpaths is itself problematic.\n    lt_search_path_spec=`$ECHO \"$lt_search_path_spec\" | $SED 's/;/ /g'`\n    ;;\n  *)\n    lt_search_path_spec=`$ECHO \"$lt_search_path_spec\" | $SED \"s/$PATH_SEPARATOR/ /g\"`\n    ;;\n  esac\n  # Ok, now we have the path, separated by spaces, we can step through it\n  # and add multilib dir if necessary...\n  lt_tmp_lt_search_path_spec=\n  lt_multi_os_dir=/`$CC $CPPFLAGS $CFLAGS $LDFLAGS -print-multi-os-directory 2>/dev/null`\n  # ...but if some path component already ends with the multilib dir we assume\n  # that all is fine and trust -print-search-dirs as is (GCC 4.2? or newer).\n  case \"$lt_multi_os_dir; $lt_search_path_spec \" in\n  \"/; \"* | \"/.; \"* | \"/./; \"* | *\"$lt_multi_os_dir \"* | *\"$lt_multi_os_dir/ \"*)\n    lt_multi_os_dir=\n    ;;\n  esac\n  for lt_sys_path in $lt_search_path_spec; do\n    if test -d \"$lt_sys_path$lt_multi_os_dir\"; then\n      lt_tmp_lt_search_path_spec=\"$lt_tmp_lt_search_path_spec $lt_sys_path$lt_multi_os_dir\"\n    elif test -n \"$lt_multi_os_dir\"; then\n      test -d \"$lt_sys_path\" && \\\n\tlt_tmp_lt_search_path_spec=\"$lt_tmp_lt_search_path_spec $lt_sys_path\"\n    fi\n  done\n  lt_search_path_spec=`$ECHO \"$lt_tmp_lt_search_path_spec\" | awk '\nBEGIN {RS = \" \"; FS = \"/|\\n\";} {\n  lt_foo = \"\";\n  lt_count = 0;\n  for (lt_i = NF; lt_i > 0; lt_i--) {\n    if ($lt_i != \"\" && $lt_i != \".\") {\n      if ($lt_i == \"..\") {\n        lt_count++;\n      } else {\n        if (lt_count == 0) {\n          lt_foo = \"/\" $lt_i lt_foo;\n        } else {\n          lt_count--;\n        }\n      }\n    }\n  }\n  if (lt_foo != \"\") { lt_freq[[lt_foo]]++; }\n  if (lt_freq[[lt_foo]] == 1) { print lt_foo; }\n}'`\n  # AWK program above erroneously prepends '/' to C:/dos/paths\n  # for these hosts.\n  case $host_os in\n    mingw* | cegcc*) lt_search_path_spec=`$ECHO \"$lt_search_path_spec\" |\\\n      $SED 's|/\\([[A-Za-z]]:\\)|\\1|g'` ;;\n  esac\n  sys_lib_search_path_spec=`$ECHO \"$lt_search_path_spec\" | $lt_NL2SP`\nelse\n  sys_lib_search_path_spec=\"/lib /usr/lib /usr/local/lib\"\nfi])\nlibrary_names_spec=\nlibname_spec='lib$name'\nsoname_spec=\nshrext_cmds=.so\npostinstall_cmds=\npostuninstall_cmds=\nfinish_cmds=\nfinish_eval=\nshlibpath_var=\nshlibpath_overrides_runpath=unknown\nversion_type=none\ndynamic_linker=\"$host_os ld.so\"\nsys_lib_dlsearch_path_spec=\"/lib /usr/lib\"\nneed_lib_prefix=unknown\nhardcode_into_libs=no\n\n# when you set need_version to no, make sure it does not cause -set_version\n# flags to be left without arguments\nneed_version=unknown\n\nAC_ARG_VAR([LT_SYS_LIBRARY_PATH],\n[User-defined run-time library search path.])\n\ncase $host_os in\naix3*)\n  version_type=linux # correct to gnu/linux during the next big refactor\n  library_names_spec='$libname$release$shared_ext$versuffix $libname.a'\n  shlibpath_var=LIBPATH\n\n  # AIX 3 has no versioning support, so we append a major version to the name.\n  soname_spec='$libname$release$shared_ext$major'\n  ;;\n\naix[[4-9]]*)\n  version_type=linux # correct to gnu/linux during the next big refactor\n  need_lib_prefix=no\n  need_version=no\n  hardcode_into_libs=yes\n  if test ia64 = \"$host_cpu\"; then\n    # AIX 5 supports IA64\n    library_names_spec='$libname$release$shared_ext$major $libname$release$shared_ext$versuffix $libname$shared_ext'\n    shlibpath_var=LD_LIBRARY_PATH\n  else\n    # With GCC up to 2.95.x, collect2 would create an import file\n    # for dependence libraries.  The import file would start with\n    # the line '#! .'.  This would cause the generated library to\n    # depend on '.', always an invalid library.  This was fixed in\n    # development snapshots of GCC prior to 3.0.\n    case $host_os in\n      aix4 | aix4.[[01]] | aix4.[[01]].*)\n      if { echo '#if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 97)'\n\t   echo ' yes '\n\t   echo '#endif'; } | $CC -E - | $GREP yes > /dev/null; then\n\t:\n      else\n\tcan_build_shared=no\n      fi\n      ;;\n    esac\n    # Using Import Files as archive members, it is possible to support\n    # filename-based versioning of shared library archives on AIX. While\n    # this would work for both with and without runtime linking, it will\n    # prevent static linking of such archives. So we do filename-based\n    # shared library versioning with .so extension only, which is used\n    # when both runtime linking and shared linking is enabled.\n    # Unfortunately, runtime linking may impact performance, so we do\n    # not want this to be the default eventually. Also, we use the\n    # versioned .so libs for executables only if there is the -brtl\n    # linker flag in LDFLAGS as well, or --with-aix-soname=svr4 only.\n    # To allow for filename-based versioning support, we need to create\n    # libNAME.so.V as an archive file, containing:\n    # *) an Import File, referring to the versioned filename of the\n    #    archive as well as the shared archive member, telling the\n    #    bitwidth (32 or 64) of that shared object, and providing the\n    #    list of exported symbols of that shared object, eventually\n    #    decorated with the 'weak' keyword\n    # *) the shared object with the F_LOADONLY flag set, to really avoid\n    #    it being seen by the linker.\n    # At run time we better use the real file rather than another symlink,\n    # but for link time we create the symlink libNAME.so -> libNAME.so.V\n\n    case $with_aix_soname,$aix_use_runtimelinking in\n    # AIX (on Power*) has no versioning support, so currently we cannot hardcode correct\n    # soname into executable. Probably we can add versioning support to\n    # collect2, so additional links can be useful in future.\n    aix,yes) # traditional libtool\n      dynamic_linker='AIX unversionable lib.so'\n      # If using run time linking (on AIX 4.2 or later) use lib<name>.so\n      # instead of lib<name>.a to let people know that these are not\n      # typical AIX shared libraries.\n      library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'\n      ;;\n    aix,no) # traditional AIX only\n      dynamic_linker='AIX lib.a[(]lib.so.V[)]'\n      # We preserve .a as extension for shared libraries through AIX4.2\n      # and later when we are not doing run time linking.\n      library_names_spec='$libname$release.a $libname.a'\n      soname_spec='$libname$release$shared_ext$major'\n      ;;\n    svr4,*) # full svr4 only\n      dynamic_linker=\"AIX lib.so.V[(]$shared_archive_member_spec.o[)]\"\n      library_names_spec='$libname$release$shared_ext$major $libname$shared_ext'\n      # We do not specify a path in Import Files, so LIBPATH fires.\n      shlibpath_overrides_runpath=yes\n      ;;\n    *,yes) # both, prefer svr4\n      dynamic_linker=\"AIX lib.so.V[(]$shared_archive_member_spec.o[)], lib.a[(]lib.so.V[)]\"\n      library_names_spec='$libname$release$shared_ext$major $libname$shared_ext'\n      # unpreferred sharedlib libNAME.a needs extra handling\n      postinstall_cmds='test -n \"$linkname\" || linkname=\"$realname\"~func_stripname \"\" \".so\" \"$linkname\"~$install_shared_prog \"$dir/$func_stripname_result.$libext\" \"$destdir/$func_stripname_result.$libext\"~test -z \"$tstripme\" || test -z \"$striplib\" || $striplib \"$destdir/$func_stripname_result.$libext\"'\n      postuninstall_cmds='for n in $library_names $old_library; do :; done~func_stripname \"\" \".so\" \"$n\"~test \"$func_stripname_result\" = \"$n\" || func_append rmfiles \" $odir/$func_stripname_result.$libext\"'\n      # We do not specify a path in Import Files, so LIBPATH fires.\n      shlibpath_overrides_runpath=yes\n      ;;\n    *,no) # both, prefer aix\n      dynamic_linker=\"AIX lib.a[(]lib.so.V[)], lib.so.V[(]$shared_archive_member_spec.o[)]\"\n      library_names_spec='$libname$release.a $libname.a'\n      soname_spec='$libname$release$shared_ext$major'\n      # unpreferred sharedlib libNAME.so.V and symlink libNAME.so need extra handling\n      postinstall_cmds='test -z \"$dlname\" || $install_shared_prog $dir/$dlname $destdir/$dlname~test -z \"$tstripme\" || test -z \"$striplib\" || $striplib $destdir/$dlname~test -n \"$linkname\" || linkname=$realname~func_stripname \"\" \".a\" \"$linkname\"~(cd \"$destdir\" && $LN_S -f $dlname $func_stripname_result.so)'\n      postuninstall_cmds='test -z \"$dlname\" || func_append rmfiles \" $odir/$dlname\"~for n in $old_library $library_names; do :; done~func_stripname \"\" \".a\" \"$n\"~func_append rmfiles \" $odir/$func_stripname_result.so\"'\n      ;;\n    esac\n    shlibpath_var=LIBPATH\n  fi\n  ;;\n\namigaos*)\n  case $host_cpu in\n  powerpc)\n    # Since July 2007 AmigaOS4 officially supports .so libraries.\n    # When compiling the executable, add -use-dynld -Lsobjs: to the compileline.\n    library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'\n    ;;\n  m68k)\n    library_names_spec='$libname.ixlibrary $libname.a'\n    # Create ${libname}_ixlibrary.a entries in /sys/libs.\n    finish_eval='for lib in `ls $libdir/*.ixlibrary 2>/dev/null`; do libname=`func_echo_all \"$lib\" | $SED '\\''s%^.*/\\([[^/]]*\\)\\.ixlibrary$%\\1%'\\''`; $RM /sys/libs/${libname}_ixlibrary.a; $show \"cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a\"; cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a || exit 1; done'\n    ;;\n  esac\n  ;;\n\nbeos*)\n  library_names_spec='$libname$shared_ext'\n  dynamic_linker=\"$host_os ld.so\"\n  shlibpath_var=LIBRARY_PATH\n  ;;\n\nbsdi[[45]]*)\n  version_type=linux # correct to gnu/linux during the next big refactor\n  need_version=no\n  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'\n  soname_spec='$libname$release$shared_ext$major'\n  finish_cmds='PATH=\"\\$PATH:/sbin\" ldconfig $libdir'\n  shlibpath_var=LD_LIBRARY_PATH\n  sys_lib_search_path_spec=\"/shlib /usr/lib /usr/X11/lib /usr/contrib/lib /lib /usr/local/lib\"\n  sys_lib_dlsearch_path_spec=\"/shlib /usr/lib /usr/local/lib\"\n  # the default ld.so.conf also contains /usr/contrib/lib and\n  # /usr/X11R6/lib (/usr/X11 is a link to /usr/X11R6), but let us allow\n  # libtool to hard-code these into programs\n  ;;\n\ncygwin* | mingw* | pw32* | cegcc*)\n  version_type=windows\n  shrext_cmds=.dll\n  need_version=no\n  need_lib_prefix=no\n\n  case $GCC,$cc_basename in\n  yes,*)\n    # gcc\n    library_names_spec='$libname.dll.a'\n    # DLL is installed to $(libdir)/../bin by postinstall_cmds\n    postinstall_cmds='base_file=`basename \\$file`~\n      dlpath=`$SHELL 2>&1 -c '\\''. $dir/'\\''\\$base_file'\\''i; echo \\$dlname'\\''`~\n      dldir=$destdir/`dirname \\$dlpath`~\n      test -d \\$dldir || mkdir -p \\$dldir~\n      $install_prog $dir/$dlname \\$dldir/$dlname~\n      chmod a+x \\$dldir/$dlname~\n      if test -n '\\''$stripme'\\'' && test -n '\\''$striplib'\\''; then\n        eval '\\''$striplib \\$dldir/$dlname'\\'' || exit \\$?;\n      fi'\n    postuninstall_cmds='dldll=`$SHELL 2>&1 -c '\\''. $file; echo \\$dlname'\\''`~\n      dlpath=$dir/\\$dldll~\n       $RM \\$dlpath'\n    shlibpath_overrides_runpath=yes\n\n    case $host_os in\n    cygwin*)\n      # Cygwin DLLs use 'cyg' prefix rather than 'lib'\n      soname_spec='`echo $libname | sed -e 's/^lib/cyg/'``echo $release | $SED -e 's/[[.]]/-/g'`$versuffix$shared_ext'\nm4_if([$1], [],[\n      sys_lib_search_path_spec=\"$sys_lib_search_path_spec /usr/lib/w32api\"])\n      ;;\n    mingw* | cegcc*)\n      # MinGW DLLs use traditional 'lib' prefix\n      soname_spec='$libname`echo $release | $SED -e 's/[[.]]/-/g'`$versuffix$shared_ext'\n      ;;\n    pw32*)\n      # pw32 DLLs use 'pw' prefix rather than 'lib'\n      library_names_spec='`echo $libname | sed -e 's/^lib/pw/'``echo $release | $SED -e 's/[[.]]/-/g'`$versuffix$shared_ext'\n      ;;\n    esac\n    dynamic_linker='Win32 ld.exe'\n    ;;\n\n  *,cl*)\n    # Native MSVC\n    libname_spec='$name'\n    soname_spec='$libname`echo $release | $SED -e 's/[[.]]/-/g'`$versuffix$shared_ext'\n    library_names_spec='$libname.dll.lib'\n\n    case $build_os in\n    mingw*)\n      sys_lib_search_path_spec=\n      lt_save_ifs=$IFS\n      IFS=';'\n      for lt_path in $LIB\n      do\n        IFS=$lt_save_ifs\n        # Let DOS variable expansion print the short 8.3 style file name.\n        lt_path=`cd \"$lt_path\" 2>/dev/null && cmd //C \"for %i in (\".\") do @echo %~si\"`\n        sys_lib_search_path_spec=\"$sys_lib_search_path_spec $lt_path\"\n      done\n      IFS=$lt_save_ifs\n      # Convert to MSYS style.\n      sys_lib_search_path_spec=`$ECHO \"$sys_lib_search_path_spec\" | sed -e 's|\\\\\\\\|/|g' -e 's| \\\\([[a-zA-Z]]\\\\):| /\\\\1|g' -e 's|^ ||'`\n      ;;\n    cygwin*)\n      # Convert to unix form, then to dos form, then back to unix form\n      # but this time dos style (no spaces!) so that the unix form looks\n      # like /cygdrive/c/PROGRA~1:/cygdr...\n      sys_lib_search_path_spec=`cygpath --path --unix \"$LIB\"`\n      sys_lib_search_path_spec=`cygpath --path --dos \"$sys_lib_search_path_spec\" 2>/dev/null`\n      sys_lib_search_path_spec=`cygpath --path --unix \"$sys_lib_search_path_spec\" | $SED -e \"s/$PATH_SEPARATOR/ /g\"`\n      ;;\n    *)\n      sys_lib_search_path_spec=$LIB\n      if $ECHO \"$sys_lib_search_path_spec\" | [$GREP ';[c-zC-Z]:/' >/dev/null]; then\n        # It is most probably a Windows format PATH.\n        sys_lib_search_path_spec=`$ECHO \"$sys_lib_search_path_spec\" | $SED -e 's/;/ /g'`\n      else\n        sys_lib_search_path_spec=`$ECHO \"$sys_lib_search_path_spec\" | $SED -e \"s/$PATH_SEPARATOR/ /g\"`\n      fi\n      # FIXME: find the short name or the path components, as spaces are\n      # common. (e.g. \"Program Files\" -> \"PROGRA~1\")\n      ;;\n    esac\n\n    # DLL is installed to $(libdir)/../bin by postinstall_cmds\n    postinstall_cmds='base_file=`basename \\$file`~\n      dlpath=`$SHELL 2>&1 -c '\\''. $dir/'\\''\\$base_file'\\''i; echo \\$dlname'\\''`~\n      dldir=$destdir/`dirname \\$dlpath`~\n      test -d \\$dldir || mkdir -p \\$dldir~\n      $install_prog $dir/$dlname \\$dldir/$dlname'\n    postuninstall_cmds='dldll=`$SHELL 2>&1 -c '\\''. $file; echo \\$dlname'\\''`~\n      dlpath=$dir/\\$dldll~\n       $RM \\$dlpath'\n    shlibpath_overrides_runpath=yes\n    dynamic_linker='Win32 link.exe'\n    ;;\n\n  *)\n    # Assume MSVC wrapper\n    library_names_spec='$libname`echo $release | $SED -e 's/[[.]]/-/g'`$versuffix$shared_ext $libname.lib'\n    dynamic_linker='Win32 ld.exe'\n    ;;\n  esac\n  # FIXME: first we should search . and the directory the executable is in\n  shlibpath_var=PATH\n  ;;\n\ndarwin* | rhapsody*)\n  dynamic_linker=\"$host_os dyld\"\n  version_type=darwin\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='$libname$release$major$shared_ext $libname$shared_ext'\n  soname_spec='$libname$release$major$shared_ext'\n  shlibpath_overrides_runpath=yes\n  shlibpath_var=DYLD_LIBRARY_PATH\n  shrext_cmds='`test .$module = .yes && echo .so || echo .dylib`'\nm4_if([$1], [],[\n  sys_lib_search_path_spec=\"$sys_lib_search_path_spec /usr/local/lib\"])\n  sys_lib_dlsearch_path_spec='/usr/local/lib /lib /usr/lib'\n  ;;\n\ndgux*)\n  version_type=linux # correct to gnu/linux during the next big refactor\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'\n  soname_spec='$libname$release$shared_ext$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  ;;\n\nfreebsd* | dragonfly*)\n  # DragonFly does not have aout.  When/if they implement a new\n  # versioning mechanism, adjust this.\n  if test -x /usr/bin/objformat; then\n    objformat=`/usr/bin/objformat`\n  else\n    case $host_os in\n    freebsd[[23]].*) objformat=aout ;;\n    *) objformat=elf ;;\n    esac\n  fi\n  version_type=freebsd-$objformat\n  case $version_type in\n    freebsd-elf*)\n      library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'\n      soname_spec='$libname$release$shared_ext$major'\n      need_version=no\n      need_lib_prefix=no\n      ;;\n    freebsd-*)\n      library_names_spec='$libname$release$shared_ext$versuffix $libname$shared_ext$versuffix'\n      need_version=yes\n      ;;\n  esac\n  shlibpath_var=LD_LIBRARY_PATH\n  case $host_os in\n  freebsd2.*)\n    shlibpath_overrides_runpath=yes\n    ;;\n  freebsd3.[[01]]* | freebsdelf3.[[01]]*)\n    shlibpath_overrides_runpath=yes\n    hardcode_into_libs=yes\n    ;;\n  freebsd3.[[2-9]]* | freebsdelf3.[[2-9]]* | \\\n  freebsd4.[[0-5]] | freebsdelf4.[[0-5]] | freebsd4.1.1 | freebsdelf4.1.1)\n    shlibpath_overrides_runpath=no\n    hardcode_into_libs=yes\n    ;;\n  *) # from 4.6 on, and DragonFly\n    shlibpath_overrides_runpath=yes\n    hardcode_into_libs=yes\n    ;;\n  esac\n  ;;\n\nhaiku*)\n  version_type=linux # correct to gnu/linux during the next big refactor\n  need_lib_prefix=no\n  need_version=no\n  dynamic_linker=\"$host_os runtime_loader\"\n  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'\n  soname_spec='$libname$release$shared_ext$major'\n  shlibpath_var=LIBRARY_PATH\n  shlibpath_overrides_runpath=no\n  sys_lib_dlsearch_path_spec='/boot/home/config/lib /boot/common/lib /boot/system/lib'\n  hardcode_into_libs=yes\n  ;;\n\nhpux9* | hpux10* | hpux11*)\n  # Give a soname corresponding to the major version so that dld.sl refuses to\n  # link against other versions.\n  version_type=sunos\n  need_lib_prefix=no\n  need_version=no\n  case $host_cpu in\n  ia64*)\n    shrext_cmds='.so'\n    hardcode_into_libs=yes\n    dynamic_linker=\"$host_os dld.so\"\n    shlibpath_var=LD_LIBRARY_PATH\n    shlibpath_overrides_runpath=yes # Unless +noenvvar is specified.\n    library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'\n    soname_spec='$libname$release$shared_ext$major'\n    if test 32 = \"$HPUX_IA64_MODE\"; then\n      sys_lib_search_path_spec=\"/usr/lib/hpux32 /usr/local/lib/hpux32 /usr/local/lib\"\n      sys_lib_dlsearch_path_spec=/usr/lib/hpux32\n    else\n      sys_lib_search_path_spec=\"/usr/lib/hpux64 /usr/local/lib/hpux64\"\n      sys_lib_dlsearch_path_spec=/usr/lib/hpux64\n    fi\n    ;;\n  hppa*64*)\n    shrext_cmds='.sl'\n    hardcode_into_libs=yes\n    dynamic_linker=\"$host_os dld.sl\"\n    shlibpath_var=LD_LIBRARY_PATH # How should we handle SHLIB_PATH\n    shlibpath_overrides_runpath=yes # Unless +noenvvar is specified.\n    library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'\n    soname_spec='$libname$release$shared_ext$major'\n    sys_lib_search_path_spec=\"/usr/lib/pa20_64 /usr/ccs/lib/pa20_64\"\n    sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec\n    ;;\n  *)\n    shrext_cmds='.sl'\n    dynamic_linker=\"$host_os dld.sl\"\n    shlibpath_var=SHLIB_PATH\n    shlibpath_overrides_runpath=no # +s is required to enable SHLIB_PATH\n    library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'\n    soname_spec='$libname$release$shared_ext$major'\n    ;;\n  esac\n  # HP-UX runs *really* slowly unless shared libraries are mode 555, ...\n  postinstall_cmds='chmod 555 $lib'\n  # or fails outright, so override atomically:\n  install_override_mode=555\n  ;;\n\ninterix[[3-9]]*)\n  version_type=linux # correct to gnu/linux during the next big refactor\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'\n  soname_spec='$libname$release$shared_ext$major'\n  dynamic_linker='Interix 3.x ld.so.1 (PE, like ELF)'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=no\n  hardcode_into_libs=yes\n  ;;\n\nirix5* | irix6* | nonstopux*)\n  case $host_os in\n    nonstopux*) version_type=nonstopux ;;\n    *)\n\tif test yes = \"$lt_cv_prog_gnu_ld\"; then\n\t\tversion_type=linux # correct to gnu/linux during the next big refactor\n\telse\n\t\tversion_type=irix\n\tfi ;;\n  esac\n  need_lib_prefix=no\n  need_version=no\n  soname_spec='$libname$release$shared_ext$major'\n  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$release$shared_ext $libname$shared_ext'\n  case $host_os in\n  irix5* | nonstopux*)\n    libsuff= shlibsuff=\n    ;;\n  *)\n    case $LD in # libtool.m4 will add one of these switches to LD\n    *-32|*\"-32 \"|*-melf32bsmip|*\"-melf32bsmip \")\n      libsuff= shlibsuff= libmagic=32-bit;;\n    *-n32|*\"-n32 \"|*-melf32bmipn32|*\"-melf32bmipn32 \")\n      libsuff=32 shlibsuff=N32 libmagic=N32;;\n    *-64|*\"-64 \"|*-melf64bmip|*\"-melf64bmip \")\n      libsuff=64 shlibsuff=64 libmagic=64-bit;;\n    *) libsuff= shlibsuff= libmagic=never-match;;\n    esac\n    ;;\n  esac\n  shlibpath_var=LD_LIBRARY${shlibsuff}_PATH\n  shlibpath_overrides_runpath=no\n  sys_lib_search_path_spec=\"/usr/lib$libsuff /lib$libsuff /usr/local/lib$libsuff\"\n  sys_lib_dlsearch_path_spec=\"/usr/lib$libsuff /lib$libsuff\"\n  hardcode_into_libs=yes\n  ;;\n\n# No shared lib support for Linux oldld, aout, or coff.\nlinux*oldld* | linux*aout* | linux*coff*)\n  dynamic_linker=no\n  ;;\n\nlinux*android*)\n  version_type=none # Android doesn't support versioned libraries.\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='$libname$release$shared_ext'\n  soname_spec='$libname$release$shared_ext'\n  finish_cmds=\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=yes\n\n  # This implies no fast_install, which is unacceptable.\n  # Some rework will be needed to allow for fast_install\n  # before this can be enabled.\n  hardcode_into_libs=yes\n\n  dynamic_linker='Android linker'\n  # Don't embed -rpath directories since the linker doesn't support them.\n  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n  ;;\n\n# This must be glibc/ELF.\nlinux* | k*bsd*-gnu | kopensolaris*-gnu | gnu*)\n  version_type=linux # correct to gnu/linux during the next big refactor\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'\n  soname_spec='$libname$release$shared_ext$major'\n  finish_cmds='PATH=\"\\$PATH:/sbin\" ldconfig -n $libdir'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=no\n\n  # Some binutils ld are patched to set DT_RUNPATH\n  AC_CACHE_VAL([lt_cv_shlibpath_overrides_runpath],\n    [lt_cv_shlibpath_overrides_runpath=no\n    save_LDFLAGS=$LDFLAGS\n    save_libdir=$libdir\n    eval \"libdir=/foo; wl=\\\"$_LT_TAGVAR(lt_prog_compiler_wl, $1)\\\"; \\\n\t LDFLAGS=\\\"\\$LDFLAGS $_LT_TAGVAR(hardcode_libdir_flag_spec, $1)\\\"\"\n    AC_LINK_IFELSE([AC_LANG_PROGRAM([],[])],\n      [AS_IF([ ($OBJDUMP -p conftest$ac_exeext) 2>/dev/null | grep \"RUNPATH.*$libdir\" >/dev/null],\n\t [lt_cv_shlibpath_overrides_runpath=yes])])\n    LDFLAGS=$save_LDFLAGS\n    libdir=$save_libdir\n    ])\n  shlibpath_overrides_runpath=$lt_cv_shlibpath_overrides_runpath\n\n  # This implies no fast_install, which is unacceptable.\n  # Some rework will be needed to allow for fast_install\n  # before this can be enabled.\n  hardcode_into_libs=yes\n\n  # Ideally, we could use ldconfig to report *all* directores which are\n  # searched for libraries, however this is still not possible.  Aside from not\n  # being certain /sbin/ldconfig is available, command\n  # 'ldconfig -N -X -v | grep ^/' on 64bit Fedora does not report /usr/lib64,\n  # even though it is searched at run-time.  Try to do the best guess by\n  # appending ld.so.conf contents (and includes) to the search path.\n  if test -f /etc/ld.so.conf; then\n    lt_ld_extra=`awk '/^include / { system(sprintf(\"cd /etc; cat %s 2>/dev/null\", \\[$]2)); skip = 1; } { if (!skip) print \\[$]0; skip = 0; }' < /etc/ld.so.conf | $SED -e 's/#.*//;/^[\t ]*hwcap[\t ]/d;s/[:,\t]/ /g;s/=[^=]*$//;s/=[^= ]* / /g;s/\"//g;/^$/d' | tr '\\n' ' '`\n    sys_lib_dlsearch_path_spec=\"/lib /usr/lib $lt_ld_extra\"\n  fi\n\n  # We used to test for /lib/ld.so.1 and disable shared libraries on\n  # powerpc, because MkLinux only supported shared libraries with the\n  # GNU dynamic linker.  Since this was broken with cross compilers,\n  # most powerpc-linux boxes support dynamic linking these days and\n  # people can always --disable-shared, the test was removed, and we\n  # assume the GNU/Linux dynamic linker is in use.\n  dynamic_linker='GNU/Linux ld.so'\n  ;;\n\nnetbsd*)\n  version_type=sunos\n  need_lib_prefix=no\n  need_version=no\n  if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then\n    library_names_spec='$libname$release$shared_ext$versuffix $libname$shared_ext$versuffix'\n    finish_cmds='PATH=\"\\$PATH:/sbin\" ldconfig -m $libdir'\n    dynamic_linker='NetBSD (a.out) ld.so'\n  else\n    library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'\n    soname_spec='$libname$release$shared_ext$major'\n    dynamic_linker='NetBSD ld.elf_so'\n  fi\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=yes\n  hardcode_into_libs=yes\n  ;;\n\nnewsos6)\n  version_type=linux # correct to gnu/linux during the next big refactor\n  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=yes\n  ;;\n\n*nto* | *qnx*)\n  version_type=qnx\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'\n  soname_spec='$libname$release$shared_ext$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=no\n  hardcode_into_libs=yes\n  dynamic_linker='ldqnx.so'\n  ;;\n\nopenbsd* | bitrig*)\n  version_type=sunos\n  sys_lib_dlsearch_path_spec=/usr/lib\n  need_lib_prefix=no\n  if test -z \"`echo __ELF__ | $CC -E - | $GREP __ELF__`\"; then\n    need_version=no\n  else\n    need_version=yes\n  fi\n  library_names_spec='$libname$release$shared_ext$versuffix $libname$shared_ext$versuffix'\n  finish_cmds='PATH=\"\\$PATH:/sbin\" ldconfig -m $libdir'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=yes\n  ;;\n\nos2*)\n  libname_spec='$name'\n  version_type=windows\n  shrext_cmds=.dll\n  need_version=no\n  need_lib_prefix=no\n  # OS/2 can only load a DLL with a base name of 8 characters or less.\n  soname_spec='`test -n \"$os2dllname\" && libname=\"$os2dllname\";\n    v=$($ECHO $release$versuffix | tr -d .-);\n    n=$($ECHO $libname | cut -b -$((8 - ${#v})) | tr . _);\n    $ECHO $n$v`$shared_ext'\n  library_names_spec='${libname}_dll.$libext'\n  dynamic_linker='OS/2 ld.exe'\n  shlibpath_var=BEGINLIBPATH\n  sys_lib_search_path_spec=\"/lib /usr/lib /usr/local/lib\"\n  sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec\n  postinstall_cmds='base_file=`basename \\$file`~\n    dlpath=`$SHELL 2>&1 -c '\\''. $dir/'\\''\\$base_file'\\''i; $ECHO \\$dlname'\\''`~\n    dldir=$destdir/`dirname \\$dlpath`~\n    test -d \\$dldir || mkdir -p \\$dldir~\n    $install_prog $dir/$dlname \\$dldir/$dlname~\n    chmod a+x \\$dldir/$dlname~\n    if test -n '\\''$stripme'\\'' && test -n '\\''$striplib'\\''; then\n      eval '\\''$striplib \\$dldir/$dlname'\\'' || exit \\$?;\n    fi'\n  postuninstall_cmds='dldll=`$SHELL 2>&1 -c '\\''. $file; $ECHO \\$dlname'\\''`~\n    dlpath=$dir/\\$dldll~\n    $RM \\$dlpath'\n  ;;\n\nosf3* | osf4* | osf5*)\n  version_type=osf\n  need_lib_prefix=no\n  need_version=no\n  soname_spec='$libname$release$shared_ext$major'\n  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'\n  shlibpath_var=LD_LIBRARY_PATH\n  sys_lib_search_path_spec=\"/usr/shlib /usr/ccs/lib /usr/lib/cmplrs/cc /usr/lib /usr/local/lib /var/shlib\"\n  sys_lib_dlsearch_path_spec=$sys_lib_search_path_spec\n  ;;\n\nrdos*)\n  dynamic_linker=no\n  ;;\n\nsolaris*)\n  version_type=linux # correct to gnu/linux during the next big refactor\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'\n  soname_spec='$libname$release$shared_ext$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=yes\n  hardcode_into_libs=yes\n  # ldd complains unless libraries are executable\n  postinstall_cmds='chmod +x $lib'\n  ;;\n\nsunos4*)\n  version_type=sunos\n  library_names_spec='$libname$release$shared_ext$versuffix $libname$shared_ext$versuffix'\n  finish_cmds='PATH=\"\\$PATH:/usr/etc\" ldconfig $libdir'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=yes\n  if test yes = \"$with_gnu_ld\"; then\n    need_lib_prefix=no\n  fi\n  need_version=yes\n  ;;\n\nsysv4 | sysv4.3*)\n  version_type=linux # correct to gnu/linux during the next big refactor\n  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'\n  soname_spec='$libname$release$shared_ext$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  case $host_vendor in\n    sni)\n      shlibpath_overrides_runpath=no\n      need_lib_prefix=no\n      runpath_var=LD_RUN_PATH\n      ;;\n    siemens)\n      need_lib_prefix=no\n      ;;\n    motorola)\n      need_lib_prefix=no\n      need_version=no\n      shlibpath_overrides_runpath=no\n      sys_lib_search_path_spec='/lib /usr/lib /usr/ccs/lib'\n      ;;\n  esac\n  ;;\n\nsysv4*MP*)\n  if test -d /usr/nec; then\n    version_type=linux # correct to gnu/linux during the next big refactor\n    library_names_spec='$libname$shared_ext.$versuffix $libname$shared_ext.$major $libname$shared_ext'\n    soname_spec='$libname$shared_ext.$major'\n    shlibpath_var=LD_LIBRARY_PATH\n  fi\n  ;;\n\nsysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)\n  version_type=sco\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext $libname$shared_ext'\n  soname_spec='$libname$release$shared_ext$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=yes\n  hardcode_into_libs=yes\n  if test yes = \"$with_gnu_ld\"; then\n    sys_lib_search_path_spec='/usr/local/lib /usr/gnu/lib /usr/ccs/lib /usr/lib /lib'\n  else\n    sys_lib_search_path_spec='/usr/ccs/lib /usr/lib'\n    case $host_os in\n      sco3.2v5*)\n        sys_lib_search_path_spec=\"$sys_lib_search_path_spec /lib\"\n\t;;\n    esac\n  fi\n  sys_lib_dlsearch_path_spec='/usr/lib'\n  ;;\n\ntpf*)\n  # TPF is a cross-target only.  Preferred cross-host = GNU/Linux.\n  version_type=linux # correct to gnu/linux during the next big refactor\n  need_lib_prefix=no\n  need_version=no\n  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'\n  shlibpath_var=LD_LIBRARY_PATH\n  shlibpath_overrides_runpath=no\n  hardcode_into_libs=yes\n  ;;\n\nuts4*)\n  version_type=linux # correct to gnu/linux during the next big refactor\n  library_names_spec='$libname$release$shared_ext$versuffix $libname$release$shared_ext$major $libname$shared_ext'\n  soname_spec='$libname$release$shared_ext$major'\n  shlibpath_var=LD_LIBRARY_PATH\n  ;;\n\n*)\n  dynamic_linker=no\n  ;;\nesac\nAC_MSG_RESULT([$dynamic_linker])\ntest no = \"$dynamic_linker\" && can_build_shared=no\n\nvariables_saved_for_relink=\"PATH $shlibpath_var $runpath_var\"\nif test yes = \"$GCC\"; then\n  variables_saved_for_relink=\"$variables_saved_for_relink GCC_EXEC_PREFIX COMPILER_PATH LIBRARY_PATH\"\nfi\n\nif test set = \"${lt_cv_sys_lib_search_path_spec+set}\"; then\n  sys_lib_search_path_spec=$lt_cv_sys_lib_search_path_spec\nfi\n\nif test set = \"${lt_cv_sys_lib_dlsearch_path_spec+set}\"; then\n  sys_lib_dlsearch_path_spec=$lt_cv_sys_lib_dlsearch_path_spec\nfi\n\n# remember unaugmented sys_lib_dlsearch_path content for libtool script decls...\nconfigure_time_dlsearch_path=$sys_lib_dlsearch_path_spec\n\n# ... but it needs LT_SYS_LIBRARY_PATH munging for other configure-time code\nfunc_munge_path_list sys_lib_dlsearch_path_spec \"$LT_SYS_LIBRARY_PATH\"\n\n# to be used as default LT_SYS_LIBRARY_PATH value in generated libtool\nconfigure_time_lt_sys_library_path=$LT_SYS_LIBRARY_PATH\n\n_LT_DECL([], [variables_saved_for_relink], [1],\n    [Variables whose values should be saved in libtool wrapper scripts and\n    restored at link time])\n_LT_DECL([], [need_lib_prefix], [0],\n    [Do we need the \"lib\" prefix for modules?])\n_LT_DECL([], [need_version], [0], [Do we need a version for libraries?])\n_LT_DECL([], [version_type], [0], [Library versioning type])\n_LT_DECL([], [runpath_var], [0],  [Shared library runtime path variable])\n_LT_DECL([], [shlibpath_var], [0],[Shared library path variable])\n_LT_DECL([], [shlibpath_overrides_runpath], [0],\n    [Is shlibpath searched before the hard-coded library search path?])\n_LT_DECL([], [libname_spec], [1], [Format of library name prefix])\n_LT_DECL([], [library_names_spec], [1],\n    [[List of archive names.  First name is the real one, the rest are links.\n    The last name is the one that the linker finds with -lNAME]])\n_LT_DECL([], [soname_spec], [1],\n    [[The coded name of the library, if different from the real name]])\n_LT_DECL([], [install_override_mode], [1],\n    [Permission mode override for installation of shared libraries])\n_LT_DECL([], [postinstall_cmds], [2],\n    [Command to use after installation of a shared archive])\n_LT_DECL([], [postuninstall_cmds], [2],\n    [Command to use after uninstallation of a shared archive])\n_LT_DECL([], [finish_cmds], [2],\n    [Commands used to finish a libtool library installation in a directory])\n_LT_DECL([], [finish_eval], [1],\n    [[As \"finish_cmds\", except a single script fragment to be evaled but\n    not shown]])\n_LT_DECL([], [hardcode_into_libs], [0],\n    [Whether we should hardcode library paths into libraries])\n_LT_DECL([], [sys_lib_search_path_spec], [2],\n    [Compile-time system search path for libraries])\n_LT_DECL([sys_lib_dlsearch_path_spec], [configure_time_dlsearch_path], [2],\n    [Detected run-time system search path for libraries])\n_LT_DECL([], [configure_time_lt_sys_library_path], [2],\n    [Explicit LT_SYS_LIBRARY_PATH set during ./configure time])\n])# _LT_SYS_DYNAMIC_LINKER\n\n\n# _LT_PATH_TOOL_PREFIX(TOOL)\n# --------------------------\n# find a file program that can recognize shared library\nAC_DEFUN([_LT_PATH_TOOL_PREFIX],\n[m4_require([_LT_DECL_EGREP])dnl\nAC_MSG_CHECKING([for $1])\nAC_CACHE_VAL(lt_cv_path_MAGIC_CMD,\n[case $MAGIC_CMD in\n[[\\\\/*] |  ?:[\\\\/]*])\n  lt_cv_path_MAGIC_CMD=$MAGIC_CMD # Let the user override the test with a path.\n  ;;\n*)\n  lt_save_MAGIC_CMD=$MAGIC_CMD\n  lt_save_ifs=$IFS; IFS=$PATH_SEPARATOR\ndnl $ac_dummy forces splitting on constant user-supplied paths.\ndnl POSIX.2 word splitting is done only on the output of word expansions,\ndnl not every word.  This closes a longstanding sh security hole.\n  ac_dummy=\"m4_if([$2], , $PATH, [$2])\"\n  for ac_dir in $ac_dummy; do\n    IFS=$lt_save_ifs\n    test -z \"$ac_dir\" && ac_dir=.\n    if test -f \"$ac_dir/$1\"; then\n      lt_cv_path_MAGIC_CMD=$ac_dir/\"$1\"\n      if test -n \"$file_magic_test_file\"; then\n\tcase $deplibs_check_method in\n\t\"file_magic \"*)\n\t  file_magic_regex=`expr \"$deplibs_check_method\" : \"file_magic \\(.*\\)\"`\n\t  MAGIC_CMD=$lt_cv_path_MAGIC_CMD\n\t  if eval $file_magic_cmd \\$file_magic_test_file 2> /dev/null |\n\t    $EGREP \"$file_magic_regex\" > /dev/null; then\n\t    :\n\t  else\n\t    cat <<_LT_EOF 1>&2\n\n*** Warning: the command libtool uses to detect shared libraries,\n*** $file_magic_cmd, produces output that libtool cannot recognize.\n*** The result is that libtool may fail to recognize shared libraries\n*** as such.  This will affect the creation of libtool libraries that\n*** depend on shared libraries, but programs linked with such libtool\n*** libraries will work regardless of this problem.  Nevertheless, you\n*** may want to report the problem to your system manager and/or to\n*** bug-libtool@gnu.org\n\n_LT_EOF\n\t  fi ;;\n\tesac\n      fi\n      break\n    fi\n  done\n  IFS=$lt_save_ifs\n  MAGIC_CMD=$lt_save_MAGIC_CMD\n  ;;\nesac])\nMAGIC_CMD=$lt_cv_path_MAGIC_CMD\nif test -n \"$MAGIC_CMD\"; then\n  AC_MSG_RESULT($MAGIC_CMD)\nelse\n  AC_MSG_RESULT(no)\nfi\n_LT_DECL([], [MAGIC_CMD], [0],\n\t [Used to examine libraries when file_magic_cmd begins with \"file\"])dnl\n])# _LT_PATH_TOOL_PREFIX\n\n# Old name:\nAU_ALIAS([AC_PATH_TOOL_PREFIX], [_LT_PATH_TOOL_PREFIX])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_PATH_TOOL_PREFIX], [])\n\n\n# _LT_PATH_MAGIC\n# --------------\n# find a file program that can recognize a shared library\nm4_defun([_LT_PATH_MAGIC],\n[_LT_PATH_TOOL_PREFIX(${ac_tool_prefix}file, /usr/bin$PATH_SEPARATOR$PATH)\nif test -z \"$lt_cv_path_MAGIC_CMD\"; then\n  if test -n \"$ac_tool_prefix\"; then\n    _LT_PATH_TOOL_PREFIX(file, /usr/bin$PATH_SEPARATOR$PATH)\n  else\n    MAGIC_CMD=:\n  fi\nfi\n])# _LT_PATH_MAGIC\n\n\n# LT_PATH_LD\n# ----------\n# find the pathname to the GNU or non-GNU linker\nAC_DEFUN([LT_PATH_LD],\n[AC_REQUIRE([AC_PROG_CC])dnl\nAC_REQUIRE([AC_CANONICAL_HOST])dnl\nAC_REQUIRE([AC_CANONICAL_BUILD])dnl\nm4_require([_LT_DECL_SED])dnl\nm4_require([_LT_DECL_EGREP])dnl\nm4_require([_LT_PROG_ECHO_BACKSLASH])dnl\n\nAC_ARG_WITH([gnu-ld],\n    [AS_HELP_STRING([--with-gnu-ld],\n\t[assume the C compiler uses GNU ld @<:@default=no@:>@])],\n    [test no = \"$withval\" || with_gnu_ld=yes],\n    [with_gnu_ld=no])dnl\n\nac_prog=ld\nif test yes = \"$GCC\"; then\n  # Check if gcc -print-prog-name=ld gives a path.\n  AC_MSG_CHECKING([for ld used by $CC])\n  case $host in\n  *-*-mingw*)\n    # gcc leaves a trailing carriage return, which upsets mingw\n    ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\\015'` ;;\n  *)\n    ac_prog=`($CC -print-prog-name=ld) 2>&5` ;;\n  esac\n  case $ac_prog in\n    # Accept absolute paths.\n    [[\\\\/]]* | ?:[[\\\\/]]*)\n      re_direlt='/[[^/]][[^/]]*/\\.\\./'\n      # Canonicalize the pathname of ld\n      ac_prog=`$ECHO \"$ac_prog\"| $SED 's%\\\\\\\\%/%g'`\n      while $ECHO \"$ac_prog\" | $GREP \"$re_direlt\" > /dev/null 2>&1; do\n\tac_prog=`$ECHO $ac_prog| $SED \"s%$re_direlt%/%\"`\n      done\n      test -z \"$LD\" && LD=$ac_prog\n      ;;\n  \"\")\n    # If it fails, then pretend we aren't using GCC.\n    ac_prog=ld\n    ;;\n  *)\n    # If it is relative, then search for the first ld in PATH.\n    with_gnu_ld=unknown\n    ;;\n  esac\nelif test yes = \"$with_gnu_ld\"; then\n  AC_MSG_CHECKING([for GNU ld])\nelse\n  AC_MSG_CHECKING([for non-GNU ld])\nfi\nAC_CACHE_VAL(lt_cv_path_LD,\n[if test -z \"$LD\"; then\n  lt_save_ifs=$IFS; IFS=$PATH_SEPARATOR\n  for ac_dir in $PATH; do\n    IFS=$lt_save_ifs\n    test -z \"$ac_dir\" && ac_dir=.\n    if test -f \"$ac_dir/$ac_prog\" || test -f \"$ac_dir/$ac_prog$ac_exeext\"; then\n      lt_cv_path_LD=$ac_dir/$ac_prog\n      # Check to see if the program is GNU ld.  I'd rather use --version,\n      # but apparently some variants of GNU ld only accept -v.\n      # Break only if it was the GNU/non-GNU ld that we prefer.\n      case `\"$lt_cv_path_LD\" -v 2>&1 </dev/null` in\n      *GNU* | *'with BFD'*)\n\ttest no != \"$with_gnu_ld\" && break\n\t;;\n      *)\n\ttest yes != \"$with_gnu_ld\" && break\n\t;;\n      esac\n    fi\n  done\n  IFS=$lt_save_ifs\nelse\n  lt_cv_path_LD=$LD # Let the user override the test with a path.\nfi])\nLD=$lt_cv_path_LD\nif test -n \"$LD\"; then\n  AC_MSG_RESULT($LD)\nelse\n  AC_MSG_RESULT(no)\nfi\ntest -z \"$LD\" && AC_MSG_ERROR([no acceptable ld found in \\$PATH])\n_LT_PATH_LD_GNU\nAC_SUBST([LD])\n\n_LT_TAGDECL([], [LD], [1], [The linker used to build libraries])\n])# LT_PATH_LD\n\n# Old names:\nAU_ALIAS([AM_PROG_LD], [LT_PATH_LD])\nAU_ALIAS([AC_PROG_LD], [LT_PATH_LD])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AM_PROG_LD], [])\ndnl AC_DEFUN([AC_PROG_LD], [])\n\n\n# _LT_PATH_LD_GNU\n#- --------------\nm4_defun([_LT_PATH_LD_GNU],\n[AC_CACHE_CHECK([if the linker ($LD) is GNU ld], lt_cv_prog_gnu_ld,\n[# I'd rather use --version here, but apparently some GNU lds only accept -v.\ncase `$LD -v 2>&1 </dev/null` in\n*GNU* | *'with BFD'*)\n  lt_cv_prog_gnu_ld=yes\n  ;;\n*)\n  lt_cv_prog_gnu_ld=no\n  ;;\nesac])\nwith_gnu_ld=$lt_cv_prog_gnu_ld\n])# _LT_PATH_LD_GNU\n\n\n# _LT_CMD_RELOAD\n# --------------\n# find reload flag for linker\n#   -- PORTME Some linkers may need a different reload flag.\nm4_defun([_LT_CMD_RELOAD],\n[AC_CACHE_CHECK([for $LD option to reload object files],\n  lt_cv_ld_reload_flag,\n  [lt_cv_ld_reload_flag='-r'])\nreload_flag=$lt_cv_ld_reload_flag\ncase $reload_flag in\n\"\" | \" \"*) ;;\n*) reload_flag=\" $reload_flag\" ;;\nesac\nreload_cmds='$LD$reload_flag -o $output$reload_objs'\ncase $host_os in\n  cygwin* | mingw* | pw32* | cegcc*)\n    if test yes != \"$GCC\"; then\n      reload_cmds=false\n    fi\n    ;;\n  darwin*)\n    if test yes = \"$GCC\"; then\n      reload_cmds='$LTCC $LTCFLAGS -nostdlib $wl-r -o $output$reload_objs'\n    else\n      reload_cmds='$LD$reload_flag -o $output$reload_objs'\n    fi\n    ;;\nesac\n_LT_TAGDECL([], [reload_flag], [1], [How to create reloadable object files])dnl\n_LT_TAGDECL([], [reload_cmds], [2])dnl\n])# _LT_CMD_RELOAD\n\n\n# _LT_PATH_DD\n# -----------\n# find a working dd\nm4_defun([_LT_PATH_DD],\n[AC_CACHE_CHECK([for a working dd], [ac_cv_path_lt_DD],\n[printf 0123456789abcdef0123456789abcdef >conftest.i\ncat conftest.i conftest.i >conftest2.i\n: ${lt_DD:=$DD}\nAC_PATH_PROGS_FEATURE_CHECK([lt_DD], [dd],\n[if \"$ac_path_lt_DD\" bs=32 count=1 <conftest2.i >conftest.out 2>/dev/null; then\n  cmp -s conftest.i conftest.out \\\n  && ac_cv_path_lt_DD=\"$ac_path_lt_DD\" ac_path_lt_DD_found=:\nfi])\nrm -f conftest.i conftest2.i conftest.out])\n])# _LT_PATH_DD\n\n\n# _LT_CMD_TRUNCATE\n# ----------------\n# find command to truncate a binary pipe\nm4_defun([_LT_CMD_TRUNCATE],\n[m4_require([_LT_PATH_DD])\nAC_CACHE_CHECK([how to truncate binary pipes], [lt_cv_truncate_bin],\n[printf 0123456789abcdef0123456789abcdef >conftest.i\ncat conftest.i conftest.i >conftest2.i\nlt_cv_truncate_bin=\nif \"$ac_cv_path_lt_DD\" bs=32 count=1 <conftest2.i >conftest.out 2>/dev/null; then\n  cmp -s conftest.i conftest.out \\\n  && lt_cv_truncate_bin=\"$ac_cv_path_lt_DD bs=4096 count=1\"\nfi\nrm -f conftest.i conftest2.i conftest.out\ntest -z \"$lt_cv_truncate_bin\" && lt_cv_truncate_bin=\"$SED -e 4q\"])\n_LT_DECL([lt_truncate_bin], [lt_cv_truncate_bin], [1],\n  [Command to truncate a binary pipe])\n])# _LT_CMD_TRUNCATE\n\n\n# _LT_CHECK_MAGIC_METHOD\n# ----------------------\n# how to check for library dependencies\n#  -- PORTME fill in with the dynamic library characteristics\nm4_defun([_LT_CHECK_MAGIC_METHOD],\n[m4_require([_LT_DECL_EGREP])\nm4_require([_LT_DECL_OBJDUMP])\nAC_CACHE_CHECK([how to recognize dependent libraries],\nlt_cv_deplibs_check_method,\n[lt_cv_file_magic_cmd='$MAGIC_CMD'\nlt_cv_file_magic_test_file=\nlt_cv_deplibs_check_method='unknown'\n# Need to set the preceding variable on all platforms that support\n# interlibrary dependencies.\n# 'none' -- dependencies not supported.\n# 'unknown' -- same as none, but documents that we really don't know.\n# 'pass_all' -- all dependencies passed with no checks.\n# 'test_compile' -- check by making test program.\n# 'file_magic [[regex]]' -- check by looking for files in library path\n# that responds to the $file_magic_cmd with a given extended regex.\n# If you have 'file' or equivalent on your system and you're not sure\n# whether 'pass_all' will *always* work, you probably want this one.\n\ncase $host_os in\naix[[4-9]]*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nbeos*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nbsdi[[45]]*)\n  lt_cv_deplibs_check_method='file_magic ELF [[0-9]][[0-9]]*-bit [[ML]]SB (shared object|dynamic lib)'\n  lt_cv_file_magic_cmd='/usr/bin/file -L'\n  lt_cv_file_magic_test_file=/shlib/libc.so\n  ;;\n\ncygwin*)\n  # func_win32_libid is a shell function defined in ltmain.sh\n  lt_cv_deplibs_check_method='file_magic ^x86 archive import|^x86 DLL'\n  lt_cv_file_magic_cmd='func_win32_libid'\n  ;;\n\nmingw* | pw32*)\n  # Base MSYS/MinGW do not provide the 'file' command needed by\n  # func_win32_libid shell function, so use a weaker test based on 'objdump',\n  # unless we find 'file', for example because we are cross-compiling.\n  if ( file / ) >/dev/null 2>&1; then\n    lt_cv_deplibs_check_method='file_magic ^x86 archive import|^x86 DLL'\n    lt_cv_file_magic_cmd='func_win32_libid'\n  else\n    # Keep this pattern in sync with the one in func_win32_libid.\n    lt_cv_deplibs_check_method='file_magic file format (pei*-i386(.*architecture: i386)?|pe-arm-wince|pe-x86-64)'\n    lt_cv_file_magic_cmd='$OBJDUMP -f'\n  fi\n  ;;\n\ncegcc*)\n  # use the weaker test based on 'objdump'. See mingw*.\n  lt_cv_deplibs_check_method='file_magic file format pe-arm-.*little(.*architecture: arm)?'\n  lt_cv_file_magic_cmd='$OBJDUMP -f'\n  ;;\n\ndarwin* | rhapsody*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nfreebsd* | dragonfly*)\n  if echo __ELF__ | $CC -E - | $GREP __ELF__ > /dev/null; then\n    case $host_cpu in\n    i*86 )\n      # Not sure whether the presence of OpenBSD here was a mistake.\n      # Let's accept both of them until this is cleared up.\n      lt_cv_deplibs_check_method='file_magic (FreeBSD|OpenBSD|DragonFly)/i[[3-9]]86 (compact )?demand paged shared library'\n      lt_cv_file_magic_cmd=/usr/bin/file\n      lt_cv_file_magic_test_file=`echo /usr/lib/libc.so.*`\n      ;;\n    esac\n  else\n    lt_cv_deplibs_check_method=pass_all\n  fi\n  ;;\n\nhaiku*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nhpux10.20* | hpux11*)\n  lt_cv_file_magic_cmd=/usr/bin/file\n  case $host_cpu in\n  ia64*)\n    lt_cv_deplibs_check_method='file_magic (s[[0-9]][[0-9]][[0-9]]|ELF-[[0-9]][[0-9]]) shared object file - IA64'\n    lt_cv_file_magic_test_file=/usr/lib/hpux32/libc.so\n    ;;\n  hppa*64*)\n    [lt_cv_deplibs_check_method='file_magic (s[0-9][0-9][0-9]|ELF[ -][0-9][0-9])(-bit)?( [LM]SB)? shared object( file)?[, -]* PA-RISC [0-9]\\.[0-9]']\n    lt_cv_file_magic_test_file=/usr/lib/pa20_64/libc.sl\n    ;;\n  *)\n    lt_cv_deplibs_check_method='file_magic (s[[0-9]][[0-9]][[0-9]]|PA-RISC[[0-9]]\\.[[0-9]]) shared library'\n    lt_cv_file_magic_test_file=/usr/lib/libc.sl\n    ;;\n  esac\n  ;;\n\ninterix[[3-9]]*)\n  # PIC code is broken on Interix 3.x, that's why |\\.a not |_pic\\.a here\n  lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\\.so|\\.a)$'\n  ;;\n\nirix5* | irix6* | nonstopux*)\n  case $LD in\n  *-32|*\"-32 \") libmagic=32-bit;;\n  *-n32|*\"-n32 \") libmagic=N32;;\n  *-64|*\"-64 \") libmagic=64-bit;;\n  *) libmagic=never-match;;\n  esac\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\n# This must be glibc/ELF.\nlinux* | k*bsd*-gnu | kopensolaris*-gnu | gnu*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nnetbsd*)\n  if echo __ELF__ | $CC -E - | $GREP __ELF__ > /dev/null; then\n    lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\\.so\\.[[0-9]]+\\.[[0-9]]+|_pic\\.a)$'\n  else\n    lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\\.so|_pic\\.a)$'\n  fi\n  ;;\n\nnewos6*)\n  lt_cv_deplibs_check_method='file_magic ELF [[0-9]][[0-9]]*-bit [[ML]]SB (executable|dynamic lib)'\n  lt_cv_file_magic_cmd=/usr/bin/file\n  lt_cv_file_magic_test_file=/usr/lib/libnls.so\n  ;;\n\n*nto* | *qnx*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nopenbsd* | bitrig*)\n  if test -z \"`echo __ELF__ | $CC -E - | $GREP __ELF__`\"; then\n    lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\\.so\\.[[0-9]]+\\.[[0-9]]+|\\.so|_pic\\.a)$'\n  else\n    lt_cv_deplibs_check_method='match_pattern /lib[[^/]]+(\\.so\\.[[0-9]]+\\.[[0-9]]+|_pic\\.a)$'\n  fi\n  ;;\n\nosf3* | osf4* | osf5*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nrdos*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nsolaris*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nsysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\n\nsysv4 | sysv4.3*)\n  case $host_vendor in\n  motorola)\n    lt_cv_deplibs_check_method='file_magic ELF [[0-9]][[0-9]]*-bit [[ML]]SB (shared object|dynamic lib) M[[0-9]][[0-9]]* Version [[0-9]]'\n    lt_cv_file_magic_test_file=`echo /usr/lib/libc.so*`\n    ;;\n  ncr)\n    lt_cv_deplibs_check_method=pass_all\n    ;;\n  sequent)\n    lt_cv_file_magic_cmd='/bin/file'\n    lt_cv_deplibs_check_method='file_magic ELF [[0-9]][[0-9]]*-bit [[LM]]SB (shared object|dynamic lib )'\n    ;;\n  sni)\n    lt_cv_file_magic_cmd='/bin/file'\n    lt_cv_deplibs_check_method=\"file_magic ELF [[0-9]][[0-9]]*-bit [[LM]]SB dynamic lib\"\n    lt_cv_file_magic_test_file=/lib/libc.so\n    ;;\n  siemens)\n    lt_cv_deplibs_check_method=pass_all\n    ;;\n  pc)\n    lt_cv_deplibs_check_method=pass_all\n    ;;\n  esac\n  ;;\n\ntpf*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\nos2*)\n  lt_cv_deplibs_check_method=pass_all\n  ;;\nesac\n])\n\nfile_magic_glob=\nwant_nocaseglob=no\nif test \"$build\" = \"$host\"; then\n  case $host_os in\n  mingw* | pw32*)\n    if ( shopt | grep nocaseglob ) >/dev/null 2>&1; then\n      want_nocaseglob=yes\n    else\n      file_magic_glob=`echo aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ | $SED -e \"s/\\(..\\)/s\\/[[\\1]]\\/[[\\1]]\\/g;/g\"`\n    fi\n    ;;\n  esac\nfi\n\nfile_magic_cmd=$lt_cv_file_magic_cmd\ndeplibs_check_method=$lt_cv_deplibs_check_method\ntest -z \"$deplibs_check_method\" && deplibs_check_method=unknown\n\n_LT_DECL([], [deplibs_check_method], [1],\n    [Method to check whether dependent libraries are shared objects])\n_LT_DECL([], [file_magic_cmd], [1],\n    [Command to use when deplibs_check_method = \"file_magic\"])\n_LT_DECL([], [file_magic_glob], [1],\n    [How to find potential files when deplibs_check_method = \"file_magic\"])\n_LT_DECL([], [want_nocaseglob], [1],\n    [Find potential files using nocaseglob when deplibs_check_method = \"file_magic\"])\n])# _LT_CHECK_MAGIC_METHOD\n\n\n# LT_PATH_NM\n# ----------\n# find the pathname to a BSD- or MS-compatible name lister\nAC_DEFUN([LT_PATH_NM],\n[AC_REQUIRE([AC_PROG_CC])dnl\nAC_CACHE_CHECK([for BSD- or MS-compatible name lister (nm)], lt_cv_path_NM,\n[if test -n \"$NM\"; then\n  # Let the user override the test.\n  lt_cv_path_NM=$NM\nelse\n  lt_nm_to_check=${ac_tool_prefix}nm\n  if test -n \"$ac_tool_prefix\" && test \"$build\" = \"$host\"; then\n    lt_nm_to_check=\"$lt_nm_to_check nm\"\n  fi\n  for lt_tmp_nm in $lt_nm_to_check; do\n    lt_save_ifs=$IFS; IFS=$PATH_SEPARATOR\n    for ac_dir in $PATH /usr/ccs/bin/elf /usr/ccs/bin /usr/ucb /bin; do\n      IFS=$lt_save_ifs\n      test -z \"$ac_dir\" && ac_dir=.\n      tmp_nm=$ac_dir/$lt_tmp_nm\n      if test -f \"$tmp_nm\" || test -f \"$tmp_nm$ac_exeext\"; then\n\t# Check to see if the nm accepts a BSD-compat flag.\n\t# Adding the 'sed 1q' prevents false positives on HP-UX, which says:\n\t#   nm: unknown option \"B\" ignored\n\t# Tru64's nm complains that /dev/null is an invalid object file\n\t# MSYS converts /dev/null to NUL, MinGW nm treats NUL as empty\n\tcase $build_os in\n\tmingw*) lt_bad_file=conftest.nm/nofile ;;\n\t*) lt_bad_file=/dev/null ;;\n\tesac\n\tcase `\"$tmp_nm\" -B $lt_bad_file 2>&1 | sed '1q'` in\n\t*$lt_bad_file* | *'Invalid file or object type'*)\n\t  lt_cv_path_NM=\"$tmp_nm -B\"\n\t  break 2\n\t  ;;\n\t*)\n\t  case `\"$tmp_nm\" -p /dev/null 2>&1 | sed '1q'` in\n\t  */dev/null*)\n\t    lt_cv_path_NM=\"$tmp_nm -p\"\n\t    break 2\n\t    ;;\n\t  *)\n\t    lt_cv_path_NM=${lt_cv_path_NM=\"$tmp_nm\"} # keep the first match, but\n\t    continue # so that we can try to find one that supports BSD flags\n\t    ;;\n\t  esac\n\t  ;;\n\tesac\n      fi\n    done\n    IFS=$lt_save_ifs\n  done\n  : ${lt_cv_path_NM=no}\nfi])\nif test no != \"$lt_cv_path_NM\"; then\n  NM=$lt_cv_path_NM\nelse\n  # Didn't find any BSD compatible name lister, look for dumpbin.\n  if test -n \"$DUMPBIN\"; then :\n    # Let the user override the test.\n  else\n    AC_CHECK_TOOLS(DUMPBIN, [dumpbin \"link -dump\"], :)\n    case `$DUMPBIN -symbols -headers /dev/null 2>&1 | sed '1q'` in\n    *COFF*)\n      DUMPBIN=\"$DUMPBIN -symbols -headers\"\n      ;;\n    *)\n      DUMPBIN=:\n      ;;\n    esac\n  fi\n  AC_SUBST([DUMPBIN])\n  if test : != \"$DUMPBIN\"; then\n    NM=$DUMPBIN\n  fi\nfi\ntest -z \"$NM\" && NM=nm\nAC_SUBST([NM])\n_LT_DECL([], [NM], [1], [A BSD- or MS-compatible name lister])dnl\n\nAC_CACHE_CHECK([the name lister ($NM) interface], [lt_cv_nm_interface],\n  [lt_cv_nm_interface=\"BSD nm\"\n  echo \"int some_variable = 0;\" > conftest.$ac_ext\n  (eval echo \"\\\"\\$as_me:$LINENO: $ac_compile\\\"\" >&AS_MESSAGE_LOG_FD)\n  (eval \"$ac_compile\" 2>conftest.err)\n  cat conftest.err >&AS_MESSAGE_LOG_FD\n  (eval echo \"\\\"\\$as_me:$LINENO: $NM \\\\\\\"conftest.$ac_objext\\\\\\\"\\\"\" >&AS_MESSAGE_LOG_FD)\n  (eval \"$NM \\\"conftest.$ac_objext\\\"\" 2>conftest.err > conftest.out)\n  cat conftest.err >&AS_MESSAGE_LOG_FD\n  (eval echo \"\\\"\\$as_me:$LINENO: output\\\"\" >&AS_MESSAGE_LOG_FD)\n  cat conftest.out >&AS_MESSAGE_LOG_FD\n  if $GREP 'External.*some_variable' conftest.out > /dev/null; then\n    lt_cv_nm_interface=\"MS dumpbin\"\n  fi\n  rm -f conftest*])\n])# LT_PATH_NM\n\n# Old names:\nAU_ALIAS([AM_PROG_NM], [LT_PATH_NM])\nAU_ALIAS([AC_PROG_NM], [LT_PATH_NM])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AM_PROG_NM], [])\ndnl AC_DEFUN([AC_PROG_NM], [])\n\n# _LT_CHECK_SHAREDLIB_FROM_LINKLIB\n# --------------------------------\n# how to determine the name of the shared library\n# associated with a specific link library.\n#  -- PORTME fill in with the dynamic library characteristics\nm4_defun([_LT_CHECK_SHAREDLIB_FROM_LINKLIB],\n[m4_require([_LT_DECL_EGREP])\nm4_require([_LT_DECL_OBJDUMP])\nm4_require([_LT_DECL_DLLTOOL])\nAC_CACHE_CHECK([how to associate runtime and link libraries],\nlt_cv_sharedlib_from_linklib_cmd,\n[lt_cv_sharedlib_from_linklib_cmd='unknown'\n\ncase $host_os in\ncygwin* | mingw* | pw32* | cegcc*)\n  # two different shell functions defined in ltmain.sh;\n  # decide which one to use based on capabilities of $DLLTOOL\n  case `$DLLTOOL --help 2>&1` in\n  *--identify-strict*)\n    lt_cv_sharedlib_from_linklib_cmd=func_cygming_dll_for_implib\n    ;;\n  *)\n    lt_cv_sharedlib_from_linklib_cmd=func_cygming_dll_for_implib_fallback\n    ;;\n  esac\n  ;;\n*)\n  # fallback: assume linklib IS sharedlib\n  lt_cv_sharedlib_from_linklib_cmd=$ECHO\n  ;;\nesac\n])\nsharedlib_from_linklib_cmd=$lt_cv_sharedlib_from_linklib_cmd\ntest -z \"$sharedlib_from_linklib_cmd\" && sharedlib_from_linklib_cmd=$ECHO\n\n_LT_DECL([], [sharedlib_from_linklib_cmd], [1],\n    [Command to associate shared and link libraries])\n])# _LT_CHECK_SHAREDLIB_FROM_LINKLIB\n\n\n# _LT_PATH_MANIFEST_TOOL\n# ----------------------\n# locate the manifest tool\nm4_defun([_LT_PATH_MANIFEST_TOOL],\n[AC_CHECK_TOOL(MANIFEST_TOOL, mt, :)\ntest -z \"$MANIFEST_TOOL\" && MANIFEST_TOOL=mt\nAC_CACHE_CHECK([if $MANIFEST_TOOL is a manifest tool], [lt_cv_path_mainfest_tool],\n  [lt_cv_path_mainfest_tool=no\n  echo \"$as_me:$LINENO: $MANIFEST_TOOL '-?'\" >&AS_MESSAGE_LOG_FD\n  $MANIFEST_TOOL '-?' 2>conftest.err > conftest.out\n  cat conftest.err >&AS_MESSAGE_LOG_FD\n  if $GREP 'Manifest Tool' conftest.out > /dev/null; then\n    lt_cv_path_mainfest_tool=yes\n  fi\n  rm -f conftest*])\nif test yes != \"$lt_cv_path_mainfest_tool\"; then\n  MANIFEST_TOOL=:\nfi\n_LT_DECL([], [MANIFEST_TOOL], [1], [Manifest tool])dnl\n])# _LT_PATH_MANIFEST_TOOL\n\n\n# _LT_DLL_DEF_P([FILE])\n# ---------------------\n# True iff FILE is a Windows DLL '.def' file.\n# Keep in sync with func_dll_def_p in the libtool script\nAC_DEFUN([_LT_DLL_DEF_P],\n[dnl\n  test DEF = \"`$SED -n dnl\n    -e '\\''s/^[[\t ]]*//'\\'' dnl Strip leading whitespace\n    -e '\\''/^\\(;.*\\)*$/d'\\'' dnl      Delete empty lines and comments\n    -e '\\''s/^\\(EXPORTS\\|LIBRARY\\)\\([[\t ]].*\\)*$/DEF/p'\\'' dnl\n    -e q dnl                          Only consider the first \"real\" line\n    $1`\" dnl\n])# _LT_DLL_DEF_P\n\n\n# LT_LIB_M\n# --------\n# check for math library\nAC_DEFUN([LT_LIB_M],\n[AC_REQUIRE([AC_CANONICAL_HOST])dnl\nLIBM=\ncase $host in\n*-*-beos* | *-*-cegcc* | *-*-cygwin* | *-*-haiku* | *-*-pw32* | *-*-darwin*)\n  # These system don't have libm, or don't need it\n  ;;\n*-ncr-sysv4.3*)\n  AC_CHECK_LIB(mw, _mwvalidcheckl, LIBM=-lmw)\n  AC_CHECK_LIB(m, cos, LIBM=\"$LIBM -lm\")\n  ;;\n*)\n  AC_CHECK_LIB(m, cos, LIBM=-lm)\n  ;;\nesac\nAC_SUBST([LIBM])\n])# LT_LIB_M\n\n# Old name:\nAU_ALIAS([AC_CHECK_LIBM], [LT_LIB_M])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_CHECK_LIBM], [])\n\n\n# _LT_COMPILER_NO_RTTI([TAGNAME])\n# -------------------------------\nm4_defun([_LT_COMPILER_NO_RTTI],\n[m4_require([_LT_TAG_COMPILER])dnl\n\n_LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=\n\nif test yes = \"$GCC\"; then\n  case $cc_basename in\n  nvcc*)\n    _LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=' -Xcompiler -fno-builtin' ;;\n  *)\n    _LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=' -fno-builtin' ;;\n  esac\n\n  _LT_COMPILER_OPTION([if $compiler supports -fno-rtti -fno-exceptions],\n    lt_cv_prog_compiler_rtti_exceptions,\n    [-fno-rtti -fno-exceptions], [],\n    [_LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=\"$_LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1) -fno-rtti -fno-exceptions\"])\nfi\n_LT_TAGDECL([no_builtin_flag], [lt_prog_compiler_no_builtin_flag], [1],\n\t[Compiler flag to turn off builtin functions])\n])# _LT_COMPILER_NO_RTTI\n\n\n# _LT_CMD_GLOBAL_SYMBOLS\n# ----------------------\nm4_defun([_LT_CMD_GLOBAL_SYMBOLS],\n[AC_REQUIRE([AC_CANONICAL_HOST])dnl\nAC_REQUIRE([AC_PROG_CC])dnl\nAC_REQUIRE([AC_PROG_AWK])dnl\nAC_REQUIRE([LT_PATH_NM])dnl\nAC_REQUIRE([LT_PATH_LD])dnl\nm4_require([_LT_DECL_SED])dnl\nm4_require([_LT_DECL_EGREP])dnl\nm4_require([_LT_TAG_COMPILER])dnl\n\n# Check for command to grab the raw symbol name followed by C symbol from nm.\nAC_MSG_CHECKING([command to parse $NM output from $compiler object])\nAC_CACHE_VAL([lt_cv_sys_global_symbol_pipe],\n[\n# These are sane defaults that work on at least a few old systems.\n# [They come from Ultrix.  What could be older than Ultrix?!! ;)]\n\n# Character class describing NM global symbol codes.\nsymcode='[[BCDEGRST]]'\n\n# Regexp to match symbols that can be accessed directly from C.\nsympat='\\([[_A-Za-z]][[_A-Za-z0-9]]*\\)'\n\n# Define system-specific variables.\ncase $host_os in\naix*)\n  symcode='[[BCDT]]'\n  ;;\ncygwin* | mingw* | pw32* | cegcc*)\n  symcode='[[ABCDGISTW]]'\n  ;;\nhpux*)\n  if test ia64 = \"$host_cpu\"; then\n    symcode='[[ABCDEGRST]]'\n  fi\n  ;;\nirix* | nonstopux*)\n  symcode='[[BCDEGRST]]'\n  ;;\nosf*)\n  symcode='[[BCDEGQRST]]'\n  ;;\nsolaris*)\n  symcode='[[BDRT]]'\n  ;;\nsco3.2v5*)\n  symcode='[[DT]]'\n  ;;\nsysv4.2uw2*)\n  symcode='[[DT]]'\n  ;;\nsysv5* | sco5v6* | unixware* | OpenUNIX*)\n  symcode='[[ABDT]]'\n  ;;\nsysv4)\n  symcode='[[DFNSTU]]'\n  ;;\nesac\n\n# If we're using GNU nm, then use its standard symbol codes.\ncase `$NM -V 2>&1` in\n*GNU* | *'with BFD'*)\n  symcode='[[ABCDGIRSTW]]' ;;\nesac\n\nif test \"$lt_cv_nm_interface\" = \"MS dumpbin\"; then\n  # Gets list of data symbols to import.\n  lt_cv_sys_global_symbol_to_import=\"sed -n -e 's/^I .* \\(.*\\)$/\\1/p'\"\n  # Adjust the below global symbol transforms to fixup imported variables.\n  lt_cdecl_hook=\" -e 's/^I .* \\(.*\\)$/extern __declspec(dllimport) char \\1;/p'\"\n  lt_c_name_hook=\" -e 's/^I .* \\(.*\\)$/  {\\\"\\1\\\", (void *) 0},/p'\"\n  lt_c_name_lib_hook=\"\\\n  -e 's/^I .* \\(lib.*\\)$/  {\\\"\\1\\\", (void *) 0},/p'\\\n  -e 's/^I .* \\(.*\\)$/  {\\\"lib\\1\\\", (void *) 0},/p'\"\nelse\n  # Disable hooks by default.\n  lt_cv_sys_global_symbol_to_import=\n  lt_cdecl_hook=\n  lt_c_name_hook=\n  lt_c_name_lib_hook=\nfi\n\n# Transform an extracted symbol line into a proper C declaration.\n# Some systems (esp. on ia64) link data and code symbols differently,\n# so use this general approach.\nlt_cv_sys_global_symbol_to_cdecl=\"sed -n\"\\\n$lt_cdecl_hook\\\n\" -e 's/^T .* \\(.*\\)$/extern int \\1();/p'\"\\\n\" -e 's/^$symcode$symcode* .* \\(.*\\)$/extern char \\1;/p'\"\n\n# Transform an extracted symbol line into symbol name and symbol address\nlt_cv_sys_global_symbol_to_c_name_address=\"sed -n\"\\\n$lt_c_name_hook\\\n\" -e 's/^: \\(.*\\) .*$/  {\\\"\\1\\\", (void *) 0},/p'\"\\\n\" -e 's/^$symcode$symcode* .* \\(.*\\)$/  {\\\"\\1\\\", (void *) \\&\\1},/p'\"\n\n# Transform an extracted symbol line into symbol name with lib prefix and\n# symbol address.\nlt_cv_sys_global_symbol_to_c_name_address_lib_prefix=\"sed -n\"\\\n$lt_c_name_lib_hook\\\n\" -e 's/^: \\(.*\\) .*$/  {\\\"\\1\\\", (void *) 0},/p'\"\\\n\" -e 's/^$symcode$symcode* .* \\(lib.*\\)$/  {\\\"\\1\\\", (void *) \\&\\1},/p'\"\\\n\" -e 's/^$symcode$symcode* .* \\(.*\\)$/  {\\\"lib\\1\\\", (void *) \\&\\1},/p'\"\n\n# Handle CRLF in mingw tool chain\nopt_cr=\ncase $build_os in\nmingw*)\n  opt_cr=`$ECHO 'x\\{0,1\\}' | tr x '\\015'` # option cr in regexp\n  ;;\nesac\n\n# Try without a prefix underscore, then with it.\nfor ac_symprfx in \"\" \"_\"; do\n\n  # Transform symcode, sympat, and symprfx into a raw symbol and a C symbol.\n  symxfrm=\"\\\\1 $ac_symprfx\\\\2 \\\\2\"\n\n  # Write the raw and C identifiers.\n  if test \"$lt_cv_nm_interface\" = \"MS dumpbin\"; then\n    # Fake it for dumpbin and say T for any non-static function,\n    # D for any global variable and I for any imported variable.\n    # Also find C++ and __fastcall symbols from MSVC++,\n    # which start with @ or ?.\n    lt_cv_sys_global_symbol_pipe=\"$AWK ['\"\\\n\"     {last_section=section; section=\\$ 3};\"\\\n\"     /^COFF SYMBOL TABLE/{for(i in hide) delete hide[i]};\"\\\n\"     /Section length .*#relocs.*(pick any)/{hide[last_section]=1};\"\\\n\"     /^ *Symbol name *: /{split(\\$ 0,sn,\\\":\\\"); si=substr(sn[2],2)};\"\\\n\"     /^ *Type *: code/{print \\\"T\\\",si,substr(si,length(prfx))};\"\\\n\"     /^ *Type *: data/{print \\\"I\\\",si,substr(si,length(prfx))};\"\\\n\"     \\$ 0!~/External *\\|/{next};\"\\\n\"     / 0+ UNDEF /{next}; / UNDEF \\([^|]\\)*()/{next};\"\\\n\"     {if(hide[section]) next};\"\\\n\"     {f=\\\"D\\\"}; \\$ 0~/\\(\\).*\\|/{f=\\\"T\\\"};\"\\\n\"     {split(\\$ 0,a,/\\||\\r/); split(a[2],s)};\"\\\n\"     s[1]~/^[@?]/{print f,s[1],s[1]; next};\"\\\n\"     s[1]~prfx {split(s[1],t,\\\"@\\\"); print f,t[1],substr(t[1],length(prfx))}\"\\\n\"     ' prfx=^$ac_symprfx]\"\n  else\n    lt_cv_sys_global_symbol_pipe=\"sed -n -e 's/^.*[[\t ]]\\($symcode$symcode*\\)[[\t ]][[\t ]]*$ac_symprfx$sympat$opt_cr$/$symxfrm/p'\"\n  fi\n  lt_cv_sys_global_symbol_pipe=\"$lt_cv_sys_global_symbol_pipe | sed '/ __gnu_lto/d'\"\n\n  # Check to see that the pipe works correctly.\n  pipe_works=no\n\n  rm -f conftest*\n  cat > conftest.$ac_ext <<_LT_EOF\n#ifdef __cplusplus\nextern \"C\" {\n#endif\nchar nm_test_var;\nvoid nm_test_func(void);\nvoid nm_test_func(void){}\n#ifdef __cplusplus\n}\n#endif\nint main(){nm_test_var='a';nm_test_func();return(0);}\n_LT_EOF\n\n  if AC_TRY_EVAL(ac_compile); then\n    # Now try to grab the symbols.\n    nlist=conftest.nm\n    if AC_TRY_EVAL(NM conftest.$ac_objext \\| \"$lt_cv_sys_global_symbol_pipe\" \\> $nlist) && test -s \"$nlist\"; then\n      # Try sorting and uniquifying the output.\n      if sort \"$nlist\" | uniq > \"$nlist\"T; then\n\tmv -f \"$nlist\"T \"$nlist\"\n      else\n\trm -f \"$nlist\"T\n      fi\n\n      # Make sure that we snagged all the symbols we need.\n      if $GREP ' nm_test_var$' \"$nlist\" >/dev/null; then\n\tif $GREP ' nm_test_func$' \"$nlist\" >/dev/null; then\n\t  cat <<_LT_EOF > conftest.$ac_ext\n/* Keep this code in sync between libtool.m4, ltmain, lt_system.h, and tests.  */\n#if defined _WIN32 || defined __CYGWIN__ || defined _WIN32_WCE\n/* DATA imports from DLLs on WIN32 can't be const, because runtime\n   relocations are performed -- see ld's documentation on pseudo-relocs.  */\n# define LT@&t@_DLSYM_CONST\n#elif defined __osf__\n/* This system does not cope well with relocations in const data.  */\n# define LT@&t@_DLSYM_CONST\n#else\n# define LT@&t@_DLSYM_CONST const\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n_LT_EOF\n\t  # Now generate the symbol file.\n\t  eval \"$lt_cv_sys_global_symbol_to_cdecl\"' < \"$nlist\" | $GREP -v main >> conftest.$ac_ext'\n\n\t  cat <<_LT_EOF >> conftest.$ac_ext\n\n/* The mapping between symbol names and symbols.  */\nLT@&t@_DLSYM_CONST struct {\n  const char *name;\n  void       *address;\n}\nlt__PROGRAM__LTX_preloaded_symbols[[]] =\n{\n  { \"@PROGRAM@\", (void *) 0 },\n_LT_EOF\n\t  $SED \"s/^$symcode$symcode* .* \\(.*\\)$/  {\\\"\\1\\\", (void *) \\&\\1},/\" < \"$nlist\" | $GREP -v main >> conftest.$ac_ext\n\t  cat <<\\_LT_EOF >> conftest.$ac_ext\n  {0, (void *) 0}\n};\n\n/* This works around a problem in FreeBSD linker */\n#ifdef FREEBSD_WORKAROUND\nstatic const void *lt_preloaded_setup() {\n  return lt__PROGRAM__LTX_preloaded_symbols;\n}\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n_LT_EOF\n\t  # Now try linking the two files.\n\t  mv conftest.$ac_objext conftstm.$ac_objext\n\t  lt_globsym_save_LIBS=$LIBS\n\t  lt_globsym_save_CFLAGS=$CFLAGS\n\t  LIBS=conftstm.$ac_objext\n\t  CFLAGS=\"$CFLAGS$_LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)\"\n\t  if AC_TRY_EVAL(ac_link) && test -s conftest$ac_exeext; then\n\t    pipe_works=yes\n\t  fi\n\t  LIBS=$lt_globsym_save_LIBS\n\t  CFLAGS=$lt_globsym_save_CFLAGS\n\telse\n\t  echo \"cannot find nm_test_func in $nlist\" >&AS_MESSAGE_LOG_FD\n\tfi\n      else\n\techo \"cannot find nm_test_var in $nlist\" >&AS_MESSAGE_LOG_FD\n      fi\n    else\n      echo \"cannot run $lt_cv_sys_global_symbol_pipe\" >&AS_MESSAGE_LOG_FD\n    fi\n  else\n    echo \"$progname: failed program was:\" >&AS_MESSAGE_LOG_FD\n    cat conftest.$ac_ext >&5\n  fi\n  rm -rf conftest* conftst*\n\n  # Do not use the global_symbol_pipe unless it works.\n  if test yes = \"$pipe_works\"; then\n    break\n  else\n    lt_cv_sys_global_symbol_pipe=\n  fi\ndone\n])\nif test -z \"$lt_cv_sys_global_symbol_pipe\"; then\n  lt_cv_sys_global_symbol_to_cdecl=\nfi\nif test -z \"$lt_cv_sys_global_symbol_pipe$lt_cv_sys_global_symbol_to_cdecl\"; then\n  AC_MSG_RESULT(failed)\nelse\n  AC_MSG_RESULT(ok)\nfi\n\n# Response file support.\nif test \"$lt_cv_nm_interface\" = \"MS dumpbin\"; then\n  nm_file_list_spec='@'\nelif $NM --help 2>/dev/null | grep '[[@]]FILE' >/dev/null; then\n  nm_file_list_spec='@'\nfi\n\n_LT_DECL([global_symbol_pipe], [lt_cv_sys_global_symbol_pipe], [1],\n    [Take the output of nm and produce a listing of raw symbols and C names])\n_LT_DECL([global_symbol_to_cdecl], [lt_cv_sys_global_symbol_to_cdecl], [1],\n    [Transform the output of nm in a proper C declaration])\n_LT_DECL([global_symbol_to_import], [lt_cv_sys_global_symbol_to_import], [1],\n    [Transform the output of nm into a list of symbols to manually relocate])\n_LT_DECL([global_symbol_to_c_name_address],\n    [lt_cv_sys_global_symbol_to_c_name_address], [1],\n    [Transform the output of nm in a C name address pair])\n_LT_DECL([global_symbol_to_c_name_address_lib_prefix],\n    [lt_cv_sys_global_symbol_to_c_name_address_lib_prefix], [1],\n    [Transform the output of nm in a C name address pair when lib prefix is needed])\n_LT_DECL([nm_interface], [lt_cv_nm_interface], [1],\n    [The name lister interface])\n_LT_DECL([], [nm_file_list_spec], [1],\n    [Specify filename containing input files for $NM])\n]) # _LT_CMD_GLOBAL_SYMBOLS\n\n\n# _LT_COMPILER_PIC([TAGNAME])\n# ---------------------------\nm4_defun([_LT_COMPILER_PIC],\n[m4_require([_LT_TAG_COMPILER])dnl\n_LT_TAGVAR(lt_prog_compiler_wl, $1)=\n_LT_TAGVAR(lt_prog_compiler_pic, $1)=\n_LT_TAGVAR(lt_prog_compiler_static, $1)=\n\nm4_if([$1], [CXX], [\n  # C++ specific cases for pic, static, wl, etc.\n  if test yes = \"$GXX\"; then\n    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n    _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n\n    case $host_os in\n    aix*)\n      # All AIX code is PIC.\n      if test ia64 = \"$host_cpu\"; then\n\t# AIX 5 now supports IA64 processor\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      fi\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n      ;;\n\n    amigaos*)\n      case $host_cpu in\n      powerpc)\n            # see comment about AmigaOS4 .so support\n            _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n        ;;\n      m68k)\n            # FIXME: we need at least 68020 code to build shared libraries, but\n            # adding the '-m68020' flag to GCC prevents building anything better,\n            # like '-m68040'.\n            _LT_TAGVAR(lt_prog_compiler_pic, $1)='-m68020 -resident32 -malways-restore-a4'\n        ;;\n      esac\n      ;;\n\n    beos* | irix5* | irix6* | nonstopux* | osf3* | osf4* | osf5*)\n      # PIC is the default for these OSes.\n      ;;\n    mingw* | cygwin* | os2* | pw32* | cegcc*)\n      # This hack is so that the source file can tell whether it is being\n      # built for inclusion in a dll (and should export symbols for example).\n      # Although the cygwin gcc ignores -fPIC, still need this for old-style\n      # (--disable-auto-import) libraries\n      m4_if([$1], [GCJ], [],\n\t[_LT_TAGVAR(lt_prog_compiler_pic, $1)='-DDLL_EXPORT'])\n      case $host_os in\n      os2*)\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='$wl-static'\n\t;;\n      esac\n      ;;\n    darwin* | rhapsody*)\n      # PIC is the default on this platform\n      # Common symbols not allowed in MH_DYLIB files\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fno-common'\n      ;;\n    *djgpp*)\n      # DJGPP does not support shared libraries at all\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)=\n      ;;\n    haiku*)\n      # PIC is the default for Haiku.\n      # The \"-static\" flag exists, but is broken.\n      _LT_TAGVAR(lt_prog_compiler_static, $1)=\n      ;;\n    interix[[3-9]]*)\n      # Interix 3.x gcc -fpic/-fPIC options generate broken code.\n      # Instead, we relocate shared libraries at runtime.\n      ;;\n    sysv4*MP*)\n      if test -d /usr/nec; then\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)=-Kconform_pic\n      fi\n      ;;\n    hpux*)\n      # PIC is the default for 64-bit PA HP-UX, but not for 32-bit\n      # PA HP-UX.  On IA64 HP-UX, PIC is the default but the pic flag\n      # sets the default TLS model and affects inlining.\n      case $host_cpu in\n      hppa*64*)\n\t;;\n      *)\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n\t;;\n      esac\n      ;;\n    *qnx* | *nto*)\n      # QNX uses GNU C++, but need to define -shared option too, otherwise\n      # it will coredump.\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC -shared'\n      ;;\n    *)\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n      ;;\n    esac\n  else\n    case $host_os in\n      aix[[4-9]]*)\n\t# All AIX code is PIC.\n\tif test ia64 = \"$host_cpu\"; then\n\t  # AIX 5 now supports IA64 processor\n\t  _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\telse\n\t  _LT_TAGVAR(lt_prog_compiler_static, $1)='-bnso -bI:/lib/syscalls.exp'\n\tfi\n\t;;\n      chorus*)\n\tcase $cc_basename in\n\tcxch68*)\n\t  # Green Hills C++ Compiler\n\t  # _LT_TAGVAR(lt_prog_compiler_static, $1)=\"--no_auto_instantiation -u __main -u __premain -u _abort -r $COOL_DIR/lib/libOrb.a $MVME_DIR/lib/CC/libC.a $MVME_DIR/lib/classix/libcx.s.a\"\n\t  ;;\n\tesac\n\t;;\n      mingw* | cygwin* | os2* | pw32* | cegcc*)\n\t# This hack is so that the source file can tell whether it is being\n\t# built for inclusion in a dll (and should export symbols for example).\n\tm4_if([$1], [GCJ], [],\n\t  [_LT_TAGVAR(lt_prog_compiler_pic, $1)='-DDLL_EXPORT'])\n\t;;\n      dgux*)\n\tcase $cc_basename in\n\t  ec++*)\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t    ;;\n\t  ghcx*)\n\t    # Green Hills C++ Compiler\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      freebsd* | dragonfly*)\n\t# FreeBSD uses GNU C++\n\t;;\n      hpux9* | hpux10* | hpux11*)\n\tcase $cc_basename in\n\t  CC*)\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='$wl-a ${wl}archive'\n\t    if test ia64 != \"$host_cpu\"; then\n\t      _LT_TAGVAR(lt_prog_compiler_pic, $1)='+Z'\n\t    fi\n\t    ;;\n\t  aCC*)\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='$wl-a ${wl}archive'\n\t    case $host_cpu in\n\t    hppa*64*|ia64*)\n\t      # +Z the default\n\t      ;;\n\t    *)\n\t      _LT_TAGVAR(lt_prog_compiler_pic, $1)='+Z'\n\t      ;;\n\t    esac\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      interix*)\n\t# This is c89, which is MS Visual C++ (no shared libs)\n\t# Anyone wants to do a port?\n\t;;\n      irix5* | irix6* | nonstopux*)\n\tcase $cc_basename in\n\t  CC*)\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n\t    # CC pic flag -KPIC is the default.\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      linux* | k*bsd*-gnu | kopensolaris*-gnu | gnu*)\n\tcase $cc_basename in\n\t  KCC*)\n\t    # KAI C++ Compiler\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='--backend -Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n\t    ;;\n\t  ecpc* )\n\t    # old Intel C++ for x86_64, which still supported -KPIC.\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n\t    ;;\n\t  icpc* )\n\t    # Intel C++, used to be incompatible with GCC.\n\t    # ICC 10 doesn't accept -KPIC any more.\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n\t    ;;\n\t  pgCC* | pgcpp*)\n\t    # Portland Group C++ compiler\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fpic'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t    ;;\n\t  cxx*)\n\t    # Compaq C++\n\t    # Make sure the PIC flag is empty.  It appears that all Alpha\n\t    # Linux and Compaq Tru64 Unix objects are PIC.\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)=\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n\t    ;;\n\t  xlc* | xlC* | bgxl[[cC]]* | mpixl[[cC]]*)\n\t    # IBM XL 8.0, 9.0 on PPC and BlueGene\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-qpic'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-qstaticlink'\n\t    ;;\n\t  *)\n\t    case `$CC -V 2>&1 | sed 5q` in\n\t    *Sun\\ C*)\n\t      # Sun C++ 5.9\n\t      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld '\n\t      ;;\n\t    esac\n\t    ;;\n\tesac\n\t;;\n      lynxos*)\n\t;;\n      m88k*)\n\t;;\n      mvs*)\n\tcase $cc_basename in\n\t  cxx*)\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-W c,exportall'\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      netbsd*)\n\t;;\n      *qnx* | *nto*)\n        # QNX uses GNU C++, but need to define -shared option too, otherwise\n        # it will coredump.\n        _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC -shared'\n        ;;\n      osf3* | osf4* | osf5*)\n\tcase $cc_basename in\n\t  KCC*)\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='--backend -Wl,'\n\t    ;;\n\t  RCC*)\n\t    # Rational C++ 2.4.1\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'\n\t    ;;\n\t  cxx*)\n\t    # Digital/Compaq C++\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    # Make sure the PIC flag is empty.  It appears that all Alpha\n\t    # Linux and Compaq Tru64 Unix objects are PIC.\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)=\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      psos*)\n\t;;\n      solaris*)\n\tcase $cc_basename in\n\t  CC* | sunCC*)\n\t    # Sun C++ 4.2, 5.x and Centerline C++\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld '\n\t    ;;\n\t  gcx*)\n\t    # Green Hills C++ Compiler\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-PIC'\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      sunos4*)\n\tcase $cc_basename in\n\t  CC*)\n\t    # Sun C++ 4.x\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t    ;;\n\t  lcc*)\n\t    # Lucid\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      sysv5* | unixware* | sco3.2v5* | sco5v6* | OpenUNIX*)\n\tcase $cc_basename in\n\t  CC*)\n\t    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t    _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t    ;;\n\tesac\n\t;;\n      tandem*)\n\tcase $cc_basename in\n\t  NCC*)\n\t    # NonStop-UX NCC 3.20\n\t    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\t;;\n      vxworks*)\n\t;;\n      *)\n\t_LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no\n\t;;\n    esac\n  fi\n],\n[\n  if test yes = \"$GCC\"; then\n    _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n    _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n\n    case $host_os in\n      aix*)\n      # All AIX code is PIC.\n      if test ia64 = \"$host_cpu\"; then\n\t# AIX 5 now supports IA64 processor\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      fi\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n      ;;\n\n    amigaos*)\n      case $host_cpu in\n      powerpc)\n            # see comment about AmigaOS4 .so support\n            _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n        ;;\n      m68k)\n            # FIXME: we need at least 68020 code to build shared libraries, but\n            # adding the '-m68020' flag to GCC prevents building anything better,\n            # like '-m68040'.\n            _LT_TAGVAR(lt_prog_compiler_pic, $1)='-m68020 -resident32 -malways-restore-a4'\n        ;;\n      esac\n      ;;\n\n    beos* | irix5* | irix6* | nonstopux* | osf3* | osf4* | osf5*)\n      # PIC is the default for these OSes.\n      ;;\n\n    mingw* | cygwin* | pw32* | os2* | cegcc*)\n      # This hack is so that the source file can tell whether it is being\n      # built for inclusion in a dll (and should export symbols for example).\n      # Although the cygwin gcc ignores -fPIC, still need this for old-style\n      # (--disable-auto-import) libraries\n      m4_if([$1], [GCJ], [],\n\t[_LT_TAGVAR(lt_prog_compiler_pic, $1)='-DDLL_EXPORT'])\n      case $host_os in\n      os2*)\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='$wl-static'\n\t;;\n      esac\n      ;;\n\n    darwin* | rhapsody*)\n      # PIC is the default on this platform\n      # Common symbols not allowed in MH_DYLIB files\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fno-common'\n      ;;\n\n    haiku*)\n      # PIC is the default for Haiku.\n      # The \"-static\" flag exists, but is broken.\n      _LT_TAGVAR(lt_prog_compiler_static, $1)=\n      ;;\n\n    hpux*)\n      # PIC is the default for 64-bit PA HP-UX, but not for 32-bit\n      # PA HP-UX.  On IA64 HP-UX, PIC is the default but the pic flag\n      # sets the default TLS model and affects inlining.\n      case $host_cpu in\n      hppa*64*)\n\t# +Z the default\n\t;;\n      *)\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n\t;;\n      esac\n      ;;\n\n    interix[[3-9]]*)\n      # Interix 3.x gcc -fpic/-fPIC options generate broken code.\n      # Instead, we relocate shared libraries at runtime.\n      ;;\n\n    msdosdjgpp*)\n      # Just because we use GCC doesn't mean we suddenly get shared libraries\n      # on systems that don't support them.\n      _LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no\n      enable_shared=no\n      ;;\n\n    *nto* | *qnx*)\n      # QNX uses GNU C++, but need to define -shared option too, otherwise\n      # it will coredump.\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC -shared'\n      ;;\n\n    sysv4*MP*)\n      if test -d /usr/nec; then\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)=-Kconform_pic\n      fi\n      ;;\n\n    *)\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n      ;;\n    esac\n\n    case $cc_basename in\n    nvcc*) # Cuda Compiler Driver 2.2\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Xlinker '\n      if test -n \"$_LT_TAGVAR(lt_prog_compiler_pic, $1)\"; then\n        _LT_TAGVAR(lt_prog_compiler_pic, $1)=\"-Xcompiler $_LT_TAGVAR(lt_prog_compiler_pic, $1)\"\n      fi\n      ;;\n    esac\n  else\n    # PORTME Check for flag to pass linker flags through the system compiler.\n    case $host_os in\n    aix*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      if test ia64 = \"$host_cpu\"; then\n\t# AIX 5 now supports IA64 processor\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      else\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-bnso -bI:/lib/syscalls.exp'\n      fi\n      ;;\n\n    darwin* | rhapsody*)\n      # PIC is the default on this platform\n      # Common symbols not allowed in MH_DYLIB files\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fno-common'\n      case $cc_basename in\n      nagfor*)\n        # NAG Fortran compiler\n        _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,-Wl,,'\n        _LT_TAGVAR(lt_prog_compiler_pic, $1)='-PIC'\n        _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n        ;;\n      esac\n      ;;\n\n    mingw* | cygwin* | pw32* | os2* | cegcc*)\n      # This hack is so that the source file can tell whether it is being\n      # built for inclusion in a dll (and should export symbols for example).\n      m4_if([$1], [GCJ], [],\n\t[_LT_TAGVAR(lt_prog_compiler_pic, $1)='-DDLL_EXPORT'])\n      case $host_os in\n      os2*)\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='$wl-static'\n\t;;\n      esac\n      ;;\n\n    hpux9* | hpux10* | hpux11*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      # PIC is the default for IA64 HP-UX and 64-bit HP-UX, but\n      # not for PA HP-UX.\n      case $host_cpu in\n      hppa*64*|ia64*)\n\t# +Z the default\n\t;;\n      *)\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='+Z'\n\t;;\n      esac\n      # Is there a better lt_prog_compiler_static that works with the bundled CC?\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='$wl-a ${wl}archive'\n      ;;\n\n    irix5* | irix6* | nonstopux*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      # PIC (with -KPIC) is the default.\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n      ;;\n\n    linux* | k*bsd*-gnu | kopensolaris*-gnu | gnu*)\n      case $cc_basename in\n      # old Intel for x86_64, which still supported -KPIC.\n      ecc*)\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n        ;;\n      # icc used to be incompatible with GCC.\n      # ICC 10 doesn't accept -KPIC any more.\n      icc* | ifort*)\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n        ;;\n      # Lahey Fortran 8.1.\n      lf95*)\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='--shared'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='--static'\n\t;;\n      nagfor*)\n\t# NAG Fortran compiler\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,-Wl,,'\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-PIC'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t;;\n      tcc*)\n\t# Fabrice Bellard et al's Tiny C Compiler\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n\t;;\n      pgcc* | pgf77* | pgf90* | pgf95* | pgfortran*)\n        # Portland Group compilers (*not* the Pentium gcc compiler,\n\t# which looks to be a dead project)\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-fpic'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n        ;;\n      ccc*)\n        _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n        # All Alpha code is PIC.\n        _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n        ;;\n      xl* | bgxl* | bgf* | mpixl*)\n\t# IBM XL C 8.0/Fortran 10.1, 11.1 on PPC and BlueGene\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-qpic'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-qstaticlink'\n\t;;\n      *)\n\tcase `$CC -V 2>&1 | sed 5q` in\n\t*Sun\\ Ceres\\ Fortran* | *Sun*Fortran*\\ [[1-7]].* | *Sun*Fortran*\\ 8.[[0-3]]*)\n\t  # Sun Fortran 8.3 passes all unrecognized flags to the linker\n\t  _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t  _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t  _LT_TAGVAR(lt_prog_compiler_wl, $1)=''\n\t  ;;\n\t*Sun\\ F* | *Sun*Fortran*)\n\t  _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t  _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t  _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld '\n\t  ;;\n\t*Sun\\ C*)\n\t  # Sun C 5.9\n\t  _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n\t  _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t  _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t  ;;\n        *Intel*\\ [[CF]]*Compiler*)\n\t  _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t  _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC'\n\t  _LT_TAGVAR(lt_prog_compiler_static, $1)='-static'\n\t  ;;\n\t*Portland\\ Group*)\n\t  _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n\t  _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fpic'\n\t  _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n\t  ;;\n\tesac\n\t;;\n      esac\n      ;;\n\n    newsos6)\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      ;;\n\n    *nto* | *qnx*)\n      # QNX uses GNU C++, but need to define -shared option too, otherwise\n      # it will coredump.\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-fPIC -shared'\n      ;;\n\n    osf3* | osf4* | osf5*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      # All OSF/1 code is PIC.\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n      ;;\n\n    rdos*)\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-non_shared'\n      ;;\n\n    solaris*)\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      case $cc_basename in\n      f77* | f90* | f95* | sunf77* | sunf90* | sunf95*)\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld ';;\n      *)\n\t_LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,';;\n      esac\n      ;;\n\n    sunos4*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Qoption ld '\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-PIC'\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      ;;\n\n    sysv4 | sysv4.2uw2* | sysv4.3*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      ;;\n\n    sysv4*MP*)\n      if test -d /usr/nec; then\n\t_LT_TAGVAR(lt_prog_compiler_pic, $1)='-Kconform_pic'\n\t_LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      fi\n      ;;\n\n    sysv5* | unixware* | sco3.2v5* | sco5v6* | OpenUNIX*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-KPIC'\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      ;;\n\n    unicos*)\n      _LT_TAGVAR(lt_prog_compiler_wl, $1)='-Wl,'\n      _LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no\n      ;;\n\n    uts4*)\n      _LT_TAGVAR(lt_prog_compiler_pic, $1)='-pic'\n      _LT_TAGVAR(lt_prog_compiler_static, $1)='-Bstatic'\n      ;;\n\n    *)\n      _LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no\n      ;;\n    esac\n  fi\n])\ncase $host_os in\n  # For platforms that do not support PIC, -DPIC is meaningless:\n  *djgpp*)\n    _LT_TAGVAR(lt_prog_compiler_pic, $1)=\n    ;;\n  *)\n    _LT_TAGVAR(lt_prog_compiler_pic, $1)=\"$_LT_TAGVAR(lt_prog_compiler_pic, $1)@&t@m4_if([$1],[],[ -DPIC],[m4_if([$1],[CXX],[ -DPIC],[])])\"\n    ;;\nesac\n\nAC_CACHE_CHECK([for $compiler option to produce PIC],\n  [_LT_TAGVAR(lt_cv_prog_compiler_pic, $1)],\n  [_LT_TAGVAR(lt_cv_prog_compiler_pic, $1)=$_LT_TAGVAR(lt_prog_compiler_pic, $1)])\n_LT_TAGVAR(lt_prog_compiler_pic, $1)=$_LT_TAGVAR(lt_cv_prog_compiler_pic, $1)\n\n#\n# Check to make sure the PIC flag actually works.\n#\nif test -n \"$_LT_TAGVAR(lt_prog_compiler_pic, $1)\"; then\n  _LT_COMPILER_OPTION([if $compiler PIC flag $_LT_TAGVAR(lt_prog_compiler_pic, $1) works],\n    [_LT_TAGVAR(lt_cv_prog_compiler_pic_works, $1)],\n    [$_LT_TAGVAR(lt_prog_compiler_pic, $1)@&t@m4_if([$1],[],[ -DPIC],[m4_if([$1],[CXX],[ -DPIC],[])])], [],\n    [case $_LT_TAGVAR(lt_prog_compiler_pic, $1) in\n     \"\" | \" \"*) ;;\n     *) _LT_TAGVAR(lt_prog_compiler_pic, $1)=\" $_LT_TAGVAR(lt_prog_compiler_pic, $1)\" ;;\n     esac],\n    [_LT_TAGVAR(lt_prog_compiler_pic, $1)=\n     _LT_TAGVAR(lt_prog_compiler_can_build_shared, $1)=no])\nfi\n_LT_TAGDECL([pic_flag], [lt_prog_compiler_pic], [1],\n\t[Additional compiler flags for building library objects])\n\n_LT_TAGDECL([wl], [lt_prog_compiler_wl], [1],\n\t[How to pass a linker flag through the compiler])\n#\n# Check to make sure the static flag actually works.\n#\nwl=$_LT_TAGVAR(lt_prog_compiler_wl, $1) eval lt_tmp_static_flag=\\\"$_LT_TAGVAR(lt_prog_compiler_static, $1)\\\"\n_LT_LINKER_OPTION([if $compiler static flag $lt_tmp_static_flag works],\n  _LT_TAGVAR(lt_cv_prog_compiler_static_works, $1),\n  $lt_tmp_static_flag,\n  [],\n  [_LT_TAGVAR(lt_prog_compiler_static, $1)=])\n_LT_TAGDECL([link_static_flag], [lt_prog_compiler_static], [1],\n\t[Compiler flag to prevent dynamic linking])\n])# _LT_COMPILER_PIC\n\n\n# _LT_LINKER_SHLIBS([TAGNAME])\n# ----------------------------\n# See if the linker supports building shared libraries.\nm4_defun([_LT_LINKER_SHLIBS],\n[AC_REQUIRE([LT_PATH_LD])dnl\nAC_REQUIRE([LT_PATH_NM])dnl\nm4_require([_LT_PATH_MANIFEST_TOOL])dnl\nm4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_DECL_EGREP])dnl\nm4_require([_LT_DECL_SED])dnl\nm4_require([_LT_CMD_GLOBAL_SYMBOLS])dnl\nm4_require([_LT_TAG_COMPILER])dnl\nAC_MSG_CHECKING([whether the $compiler linker ($LD) supports shared libraries])\nm4_if([$1], [CXX], [\n  _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\\''s/.* //'\\'' | sort | uniq > $export_symbols'\n  _LT_TAGVAR(exclude_expsyms, $1)=['_GLOBAL_OFFSET_TABLE_|_GLOBAL__F[ID]_.*']\n  case $host_os in\n  aix[[4-9]]*)\n    # If we're using GNU nm, then we don't want the \"-C\" option.\n    # -C means demangle to GNU nm, but means don't demangle to AIX nm.\n    # Without the \"-l\" option, or with the \"-B\" option, AIX nm treats\n    # weak defined symbols like other global defined symbols, whereas\n    # GNU nm marks them as \"W\".\n    # While the 'weak' keyword is ignored in the Export File, we need\n    # it in the Import File for the 'aix-soname' feature, so we have\n    # to replace the \"-B\" option with \"-P\" for AIX nm.\n    if $NM -V 2>&1 | $GREP 'GNU' > /dev/null; then\n      _LT_TAGVAR(export_symbols_cmds, $1)='$NM -Bpg $libobjs $convenience | awk '\\''{ if (((\\$ 2 == \"T\") || (\\$ 2 == \"D\") || (\\$ 2 == \"B\") || (\\$ 2 == \"W\")) && ([substr](\\$ 3,1,1) != \".\")) { if (\\$ 2 == \"W\") { print \\$ 3 \" weak\" } else { print \\$ 3 } } }'\\'' | sort -u > $export_symbols'\n    else\n      _LT_TAGVAR(export_symbols_cmds, $1)='`func_echo_all $NM | $SED -e '\\''s/B\\([[^B]]*\\)$/P\\1/'\\''` -PCpgl $libobjs $convenience | awk '\\''{ if (((\\$ 2 == \"T\") || (\\$ 2 == \"D\") || (\\$ 2 == \"B\") || (\\$ 2 == \"W\") || (\\$ 2 == \"V\") || (\\$ 2 == \"Z\")) && ([substr](\\$ 1,1,1) != \".\")) { if ((\\$ 2 == \"W\") || (\\$ 2 == \"V\") || (\\$ 2 == \"Z\")) { print \\$ 1 \" weak\" } else { print \\$ 1 } } }'\\'' | sort -u > $export_symbols'\n    fi\n    ;;\n  pw32*)\n    _LT_TAGVAR(export_symbols_cmds, $1)=$ltdll_cmds\n    ;;\n  cygwin* | mingw* | cegcc*)\n    case $cc_basename in\n    cl*)\n      _LT_TAGVAR(exclude_expsyms, $1)='_NULL_IMPORT_DESCRIPTOR|_IMPORT_DESCRIPTOR_.*'\n      ;;\n    *)\n      _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED -e '\\''/^[[BCDGRS]][[ ]]/s/.*[[ ]]\\([[^ ]]*\\)/\\1 DATA/;s/^.*[[ ]]__nm__\\([[^ ]]*\\)[[ ]][[^ ]]*/\\1 DATA/;/^I[[ ]]/d;/^[[AITW]][[ ]]/s/.* //'\\'' | sort | uniq > $export_symbols'\n      _LT_TAGVAR(exclude_expsyms, $1)=['[_]+GLOBAL_OFFSET_TABLE_|[_]+GLOBAL__[FID]_.*|[_]+head_[A-Za-z0-9_]+_dll|[A-Za-z0-9_]+_dll_iname']\n      ;;\n    esac\n    ;;\n  *)\n    _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\\''s/.* //'\\'' | sort | uniq > $export_symbols'\n    ;;\n  esac\n], [\n  runpath_var=\n  _LT_TAGVAR(allow_undefined_flag, $1)=\n  _LT_TAGVAR(always_export_symbols, $1)=no\n  _LT_TAGVAR(archive_cmds, $1)=\n  _LT_TAGVAR(archive_expsym_cmds, $1)=\n  _LT_TAGVAR(compiler_needs_object, $1)=no\n  _LT_TAGVAR(enable_shared_with_static_runtimes, $1)=no\n  _LT_TAGVAR(export_dynamic_flag_spec, $1)=\n  _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\\''s/.* //'\\'' | sort | uniq > $export_symbols'\n  _LT_TAGVAR(hardcode_automatic, $1)=no\n  _LT_TAGVAR(hardcode_direct, $1)=no\n  _LT_TAGVAR(hardcode_direct_absolute, $1)=no\n  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)=\n  _LT_TAGVAR(hardcode_libdir_separator, $1)=\n  _LT_TAGVAR(hardcode_minus_L, $1)=no\n  _LT_TAGVAR(hardcode_shlibpath_var, $1)=unsupported\n  _LT_TAGVAR(inherit_rpath, $1)=no\n  _LT_TAGVAR(link_all_deplibs, $1)=unknown\n  _LT_TAGVAR(module_cmds, $1)=\n  _LT_TAGVAR(module_expsym_cmds, $1)=\n  _LT_TAGVAR(old_archive_from_new_cmds, $1)=\n  _LT_TAGVAR(old_archive_from_expsyms_cmds, $1)=\n  _LT_TAGVAR(thread_safe_flag_spec, $1)=\n  _LT_TAGVAR(whole_archive_flag_spec, $1)=\n  # include_expsyms should be a list of space-separated symbols to be *always*\n  # included in the symbol list\n  _LT_TAGVAR(include_expsyms, $1)=\n  # exclude_expsyms can be an extended regexp of symbols to exclude\n  # it will be wrapped by ' (' and ')$', so one must not match beginning or\n  # end of line.  Example: 'a|bc|.*d.*' will exclude the symbols 'a' and 'bc',\n  # as well as any symbol that contains 'd'.\n  _LT_TAGVAR(exclude_expsyms, $1)=['_GLOBAL_OFFSET_TABLE_|_GLOBAL__F[ID]_.*']\n  # Although _GLOBAL_OFFSET_TABLE_ is a valid symbol C name, most a.out\n  # platforms (ab)use it in PIC code, but their linkers get confused if\n  # the symbol is explicitly referenced.  Since portable code cannot\n  # rely on this symbol name, it's probably fine to never include it in\n  # preloaded symbol tables.\n  # Exclude shared library initialization/finalization symbols.\ndnl Note also adjust exclude_expsyms for C++ above.\n  extract_expsyms_cmds=\n\n  case $host_os in\n  cygwin* | mingw* | pw32* | cegcc*)\n    # FIXME: the MSVC++ port hasn't been tested in a loooong time\n    # When not using gcc, we currently assume that we are using\n    # Microsoft Visual C++.\n    if test yes != \"$GCC\"; then\n      with_gnu_ld=no\n    fi\n    ;;\n  interix*)\n    # we just hope/assume this is gcc and not c89 (= MSVC++)\n    with_gnu_ld=yes\n    ;;\n  openbsd* | bitrig*)\n    with_gnu_ld=no\n    ;;\n  esac\n\n  _LT_TAGVAR(ld_shlibs, $1)=yes\n\n  # On some targets, GNU ld is compatible enough with the native linker\n  # that we're better off using the native interface for both.\n  lt_use_gnu_ld_interface=no\n  if test yes = \"$with_gnu_ld\"; then\n    case $host_os in\n      aix*)\n\t# The AIX port of GNU ld has always aspired to compatibility\n\t# with the native linker.  However, as the warning in the GNU ld\n\t# block says, versions before 2.19.5* couldn't really create working\n\t# shared libraries, regardless of the interface used.\n\tcase `$LD -v 2>&1` in\n\t  *\\ \\(GNU\\ Binutils\\)\\ 2.19.5*) ;;\n\t  *\\ \\(GNU\\ Binutils\\)\\ 2.[[2-9]]*) ;;\n\t  *\\ \\(GNU\\ Binutils\\)\\ [[3-9]]*) ;;\n\t  *)\n\t    lt_use_gnu_ld_interface=yes\n\t    ;;\n\tesac\n\t;;\n      *)\n\tlt_use_gnu_ld_interface=yes\n\t;;\n    esac\n  fi\n\n  if test yes = \"$lt_use_gnu_ld_interface\"; then\n    # If archive_cmds runs LD, not CC, wlarc should be empty\n    wlarc='$wl'\n\n    # Set some defaults for GNU ld with shared library support. These\n    # are reset later if shared libraries are not supported. Putting them\n    # here allows them to be overridden if necessary.\n    runpath_var=LD_RUN_PATH\n    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath $wl$libdir'\n    _LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl--export-dynamic'\n    # ancient GNU ld didn't support --whole-archive et. al.\n    if $LD --help 2>&1 | $GREP 'no-whole-archive' > /dev/null; then\n      _LT_TAGVAR(whole_archive_flag_spec, $1)=$wlarc'--whole-archive$convenience '$wlarc'--no-whole-archive'\n    else\n      _LT_TAGVAR(whole_archive_flag_spec, $1)=\n    fi\n    supports_anon_versioning=no\n    case `$LD -v | $SED -e 's/([^)]\\+)\\s\\+//' 2>&1` in\n      *GNU\\ gold*) supports_anon_versioning=yes ;;\n      *\\ [[01]].* | *\\ 2.[[0-9]].* | *\\ 2.10.*) ;; # catch versions < 2.11\n      *\\ 2.11.93.0.2\\ *) supports_anon_versioning=yes ;; # RH7.3 ...\n      *\\ 2.11.92.0.12\\ *) supports_anon_versioning=yes ;; # Mandrake 8.2 ...\n      *\\ 2.11.*) ;; # other 2.11 versions\n      *) supports_anon_versioning=yes ;;\n    esac\n\n    # See if GNU ld supports shared libraries.\n    case $host_os in\n    aix[[3-9]]*)\n      # On AIX/PPC, the GNU linker is very broken\n      if test ia64 != \"$host_cpu\"; then\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n\tcat <<_LT_EOF 1>&2\n\n*** Warning: the GNU linker, at least up to release 2.19, is reported\n*** to be unable to reliably create shared libraries on AIX.\n*** Therefore, libtool is disabling shared libraries support.  If you\n*** really care for shared libraries, you may want to install binutils\n*** 2.20 or above, or modify your PATH so that a non-GNU linker is found.\n*** You will then need to restart the configuration process.\n\n_LT_EOF\n      fi\n      ;;\n\n    amigaos*)\n      case $host_cpu in\n      powerpc)\n            # see comment about AmigaOS4 .so support\n            _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags $wl-soname $wl$soname -o $lib'\n            _LT_TAGVAR(archive_expsym_cmds, $1)=''\n        ;;\n      m68k)\n            _LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/a2ixlibrary.data~$ECHO \"#define NAME $libname\" > $output_objdir/a2ixlibrary.data~$ECHO \"#define LIBRARY_ID 1\" >> $output_objdir/a2ixlibrary.data~$ECHO \"#define VERSION $major\" >> $output_objdir/a2ixlibrary.data~$ECHO \"#define REVISION $revision\" >> $output_objdir/a2ixlibrary.data~$AR $AR_FLAGS $lib $libobjs~$RANLIB $lib~(cd $output_objdir && a2ixlibrary -32)'\n            _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n            _LT_TAGVAR(hardcode_minus_L, $1)=yes\n        ;;\n      esac\n      ;;\n\n    beos*)\n      if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then\n\t_LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n\t# Joseph Beckenbach <jrb3@best.com> says some releases of gcc\n\t# support --undefined.  This deserves some investigation.  FIXME\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -nostart $libobjs $deplibs $compiler_flags $wl-soname $wl$soname -o $lib'\n      else\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n      fi\n      ;;\n\n    cygwin* | mingw* | pw32* | cegcc*)\n      # _LT_TAGVAR(hardcode_libdir_flag_spec, $1) is actually meaningless,\n      # as there is no search path for DLLs.\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl--export-all-symbols'\n      _LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n      _LT_TAGVAR(always_export_symbols, $1)=no\n      _LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes\n      _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED -e '\\''/^[[BCDGRS]][[ ]]/s/.*[[ ]]\\([[^ ]]*\\)/\\1 DATA/;s/^.*[[ ]]__nm__\\([[^ ]]*\\)[[ ]][[^ ]]*/\\1 DATA/;/^I[[ ]]/d;/^[[AITW]][[ ]]/s/.* //'\\'' | sort | uniq > $export_symbols'\n      _LT_TAGVAR(exclude_expsyms, $1)=['[_]+GLOBAL_OFFSET_TABLE_|[_]+GLOBAL__[FID]_.*|[_]+head_[A-Za-z0-9_]+_dll|[A-Za-z0-9_]+_dll_iname']\n\n      if $LD --help 2>&1 | $GREP 'auto-import' > /dev/null; then\n        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags -o $output_objdir/$soname $wl--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'\n\t# If the export-symbols file already is a .def file, use it as\n\t# is; otherwise, prepend EXPORTS...\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='if _LT_DLL_DEF_P([$export_symbols]); then\n          cp $export_symbols $output_objdir/$soname.def;\n        else\n          echo EXPORTS > $output_objdir/$soname.def;\n          cat $export_symbols >> $output_objdir/$soname.def;\n        fi~\n        $CC -shared $output_objdir/$soname.def $libobjs $deplibs $compiler_flags -o $output_objdir/$soname $wl--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'\n      else\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n      fi\n      ;;\n\n    haiku*)\n      _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags $wl-soname $wl$soname -o $lib'\n      _LT_TAGVAR(link_all_deplibs, $1)=yes\n      ;;\n\n    os2*)\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n      _LT_TAGVAR(hardcode_minus_L, $1)=yes\n      _LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n      shrext_cmds=.dll\n      _LT_TAGVAR(archive_cmds, $1)='$ECHO \"LIBRARY ${soname%$shared_ext} INITINSTANCE TERMINSTANCE\" > $output_objdir/$libname.def~\n\t$ECHO \"DESCRIPTION \\\"$libname\\\"\" >> $output_objdir/$libname.def~\n\t$ECHO \"DATA MULTIPLE NONSHARED\" >> $output_objdir/$libname.def~\n\t$ECHO EXPORTS >> $output_objdir/$libname.def~\n\temxexp $libobjs | $SED /\"_DLL_InitTerm\"/d >> $output_objdir/$libname.def~\n\t$CC -Zdll -Zcrtdll -o $output_objdir/$soname $libobjs $deplibs $compiler_flags $output_objdir/$libname.def~\n\temximp -o $lib $output_objdir/$libname.def'\n      _LT_TAGVAR(archive_expsym_cmds, $1)='$ECHO \"LIBRARY ${soname%$shared_ext} INITINSTANCE TERMINSTANCE\" > $output_objdir/$libname.def~\n\t$ECHO \"DESCRIPTION \\\"$libname\\\"\" >> $output_objdir/$libname.def~\n\t$ECHO \"DATA MULTIPLE NONSHARED\" >> $output_objdir/$libname.def~\n\t$ECHO EXPORTS >> $output_objdir/$libname.def~\n\tprefix_cmds=\"$SED\"~\n\tif test EXPORTS = \"`$SED 1q $export_symbols`\"; then\n\t  prefix_cmds=\"$prefix_cmds -e 1d\";\n\tfi~\n\tprefix_cmds=\"$prefix_cmds -e \\\"s/^\\(.*\\)$/_\\1/g\\\"\"~\n\tcat $export_symbols | $prefix_cmds >> $output_objdir/$libname.def~\n\t$CC -Zdll -Zcrtdll -o $output_objdir/$soname $libobjs $deplibs $compiler_flags $output_objdir/$libname.def~\n\temximp -o $lib $output_objdir/$libname.def'\n      _LT_TAGVAR(old_archive_From_new_cmds, $1)='emximp -o $output_objdir/${libname}_dll.a $output_objdir/$libname.def'\n      _LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes\n      ;;\n\n    interix[[3-9]]*)\n      _LT_TAGVAR(hardcode_direct, $1)=no\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath,$libdir'\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl-E'\n      # Hack: On Interix 3.x, we cannot compile PIC because of a broken gcc.\n      # Instead, shared libraries are loaded at an image base (0x10000000 by\n      # default) and relocated if they conflict, which is a slow very memory\n      # consuming and fragmenting process.  To avoid this, we pick a random,\n      # 256 KiB-aligned image base between 0x50000000 and 0x6FFC0000 at link\n      # time.  Moving up from 0x10000000 also allows more sbrk(2) space.\n      _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags $wl-h,$soname $wl--image-base,`expr ${RANDOM-$$} % 4096 / 2 \\* 262144 + 1342177280` -o $lib'\n      _LT_TAGVAR(archive_expsym_cmds, $1)='sed \"s|^|_|\" $export_symbols >$output_objdir/$soname.expsym~$CC -shared $pic_flag $libobjs $deplibs $compiler_flags $wl-h,$soname $wl--retain-symbols-file,$output_objdir/$soname.expsym $wl--image-base,`expr ${RANDOM-$$} % 4096 / 2 \\* 262144 + 1342177280` -o $lib'\n      ;;\n\n    gnu* | linux* | tpf* | k*bsd*-gnu | kopensolaris*-gnu)\n      tmp_diet=no\n      if test linux-dietlibc = \"$host_os\"; then\n\tcase $cc_basename in\n\t  diet\\ *) tmp_diet=yes;;\t# linux-dietlibc with static linking (!diet-dyn)\n\tesac\n      fi\n      if $LD --help 2>&1 | $EGREP ': supported targets:.* elf' > /dev/null \\\n\t && test no = \"$tmp_diet\"\n      then\n\ttmp_addflag=' $pic_flag'\n\ttmp_sharedflag='-shared'\n\tcase $cc_basename,$host_cpu in\n        pgcc*)\t\t\t\t# Portland Group C compiler\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='$wl--whole-archive`for conv in $convenience\\\"\\\"; do test  -n \\\"$conv\\\" && new_convenience=\\\"$new_convenience,$conv\\\"; done; func_echo_all \\\"$new_convenience\\\"` $wl--no-whole-archive'\n\t  tmp_addflag=' $pic_flag'\n\t  ;;\n\tpgf77* | pgf90* | pgf95* | pgfortran*)\n\t\t\t\t\t# Portland Group f77 and f90 compilers\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='$wl--whole-archive`for conv in $convenience\\\"\\\"; do test  -n \\\"$conv\\\" && new_convenience=\\\"$new_convenience,$conv\\\"; done; func_echo_all \\\"$new_convenience\\\"` $wl--no-whole-archive'\n\t  tmp_addflag=' $pic_flag -Mnomain' ;;\n\tecc*,ia64* | icc*,ia64*)\t# Intel C compiler on ia64\n\t  tmp_addflag=' -i_dynamic' ;;\n\tefc*,ia64* | ifort*,ia64*)\t# Intel Fortran compiler on ia64\n\t  tmp_addflag=' -i_dynamic -nofor_main' ;;\n\tifc* | ifort*)\t\t\t# Intel Fortran compiler\n\t  tmp_addflag=' -nofor_main' ;;\n\tlf95*)\t\t\t\t# Lahey Fortran 8.1\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)=\n\t  tmp_sharedflag='--shared' ;;\n        nagfor*)                        # NAGFOR 5.3\n          tmp_sharedflag='-Wl,-shared' ;;\n\txl[[cC]]* | bgxl[[cC]]* | mpixl[[cC]]*) # IBM XL C 8.0 on PPC (deal with xlf below)\n\t  tmp_sharedflag='-qmkshrobj'\n\t  tmp_addflag= ;;\n\tnvcc*)\t# Cuda Compiler Driver 2.2\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='$wl--whole-archive`for conv in $convenience\\\"\\\"; do test  -n \\\"$conv\\\" && new_convenience=\\\"$new_convenience,$conv\\\"; done; func_echo_all \\\"$new_convenience\\\"` $wl--no-whole-archive'\n\t  _LT_TAGVAR(compiler_needs_object, $1)=yes\n\t  ;;\n\tesac\n\tcase `$CC -V 2>&1 | sed 5q` in\n\t*Sun\\ C*)\t\t\t# Sun C 5.9\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='$wl--whole-archive`new_convenience=; for conv in $convenience\\\"\\\"; do test -z \\\"$conv\\\" || new_convenience=\\\"$new_convenience,$conv\\\"; done; func_echo_all \\\"$new_convenience\\\"` $wl--no-whole-archive'\n\t  _LT_TAGVAR(compiler_needs_object, $1)=yes\n\t  tmp_sharedflag='-G' ;;\n\t*Sun\\ F*)\t\t\t# Sun Fortran 8.3\n\t  tmp_sharedflag='-G' ;;\n\tesac\n\t_LT_TAGVAR(archive_cmds, $1)='$CC '\"$tmp_sharedflag\"\"$tmp_addflag\"' $libobjs $deplibs $compiler_flags $wl-soname $wl$soname -o $lib'\n\n        if test yes = \"$supports_anon_versioning\"; then\n          _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $output_objdir/$libname.ver~\n            cat $export_symbols | sed -e \"s/\\(.*\\)/\\1;/\" >> $output_objdir/$libname.ver~\n            echo \"local: *; };\" >> $output_objdir/$libname.ver~\n            $CC '\"$tmp_sharedflag\"\"$tmp_addflag\"' $libobjs $deplibs $compiler_flags $wl-soname $wl$soname $wl-version-script $wl$output_objdir/$libname.ver -o $lib'\n        fi\n\n\tcase $cc_basename in\n\ttcc*)\n\t  _LT_TAGVAR(export_dynamic_flag_spec, $1)='-rdynamic'\n\t  ;;\n\txlf* | bgf* | bgxlf* | mpixlf*)\n\t  # IBM XL Fortran 10.1 on PPC cannot create shared libs itself\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='--whole-archive$convenience --no-whole-archive'\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath $wl$libdir'\n\t  _LT_TAGVAR(archive_cmds, $1)='$LD -shared $libobjs $deplibs $linker_flags -soname $soname -o $lib'\n\t  if test yes = \"$supports_anon_versioning\"; then\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $output_objdir/$libname.ver~\n              cat $export_symbols | sed -e \"s/\\(.*\\)/\\1;/\" >> $output_objdir/$libname.ver~\n              echo \"local: *; };\" >> $output_objdir/$libname.ver~\n              $LD -shared $libobjs $deplibs $linker_flags -soname $soname -version-script $output_objdir/$libname.ver -o $lib'\n\t  fi\n\t  ;;\n\tesac\n      else\n        _LT_TAGVAR(ld_shlibs, $1)=no\n      fi\n      ;;\n\n    netbsd*)\n      if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then\n\t_LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable $libobjs $deplibs $linker_flags -o $lib'\n\twlarc=\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags $wl-soname $wl$soname -o $lib'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags $wl-soname $wl$soname $wl-retain-symbols-file $wl$export_symbols -o $lib'\n      fi\n      ;;\n\n    solaris*)\n      if $LD -v 2>&1 | $GREP 'BFD 2\\.8' > /dev/null; then\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n\tcat <<_LT_EOF 1>&2\n\n*** Warning: The releases 2.8.* of the GNU linker cannot reliably\n*** create shared libraries on Solaris systems.  Therefore, libtool\n*** is disabling shared libraries support.  We urge you to upgrade GNU\n*** binutils to release 2.9.1 or newer.  Another option is to modify\n*** your PATH or compiler configuration so that the native linker is\n*** used, and then restart.\n\n_LT_EOF\n      elif $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags $wl-soname $wl$soname -o $lib'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags $wl-soname $wl$soname $wl-retain-symbols-file $wl$export_symbols -o $lib'\n      else\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n      fi\n      ;;\n\n    sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX*)\n      case `$LD -v 2>&1` in\n        *\\ [[01]].* | *\\ 2.[[0-9]].* | *\\ 2.1[[0-5]].*)\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n\tcat <<_LT_EOF 1>&2\n\n*** Warning: Releases of the GNU linker prior to 2.16.91.0.3 cannot\n*** reliably create shared libraries on SCO systems.  Therefore, libtool\n*** is disabling shared libraries support.  We urge you to upgrade GNU\n*** binutils to release 2.16.91.0.3 or newer.  Another option is to modify\n*** your PATH or compiler configuration so that the native linker is\n*** used, and then restart.\n\n_LT_EOF\n\t;;\n\t*)\n\t  # For security reasons, it is highly recommended that you always\n\t  # use absolute paths for naming shared libraries, and exclude the\n\t  # DT_RUNPATH tag from executables and libraries.  But doing so\n\t  # requires that you compile everything twice, which is a pain.\n\t  if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath $wl$libdir'\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags $wl-soname $wl$soname -o $lib'\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags $wl-soname $wl$soname $wl-retain-symbols-file $wl$export_symbols -o $lib'\n\t  else\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t  fi\n\t;;\n      esac\n      ;;\n\n    sunos4*)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -assert pure-text -Bshareable -o $lib $libobjs $deplibs $linker_flags'\n      wlarc=\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    *)\n      if $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags $wl-soname $wl$soname -o $lib'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags $wl-soname $wl$soname $wl-retain-symbols-file $wl$export_symbols -o $lib'\n      else\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n      fi\n      ;;\n    esac\n\n    if test no = \"$_LT_TAGVAR(ld_shlibs, $1)\"; then\n      runpath_var=\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)=\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)=\n      _LT_TAGVAR(whole_archive_flag_spec, $1)=\n    fi\n  else\n    # PORTME fill in a description of your system's linker (not GNU ld)\n    case $host_os in\n    aix3*)\n      _LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n      _LT_TAGVAR(always_export_symbols, $1)=yes\n      _LT_TAGVAR(archive_expsym_cmds, $1)='$LD -o $output_objdir/$soname $libobjs $deplibs $linker_flags -bE:$export_symbols -T512 -H512 -bM:SRE~$AR $AR_FLAGS $lib $output_objdir/$soname'\n      # Note: this linker hardcodes the directories in LIBPATH if there\n      # are no directories specified by -L.\n      _LT_TAGVAR(hardcode_minus_L, $1)=yes\n      if test yes = \"$GCC\" && test -z \"$lt_prog_compiler_static\"; then\n\t# Neither direct hardcoding nor static linking is supported with a\n\t# broken collect2.\n\t_LT_TAGVAR(hardcode_direct, $1)=unsupported\n      fi\n      ;;\n\n    aix[[4-9]]*)\n      if test ia64 = \"$host_cpu\"; then\n\t# On IA64, the linker does run time linking by default, so we don't\n\t# have to do anything special.\n\taix_use_runtimelinking=no\n\texp_sym_flag='-Bexport'\n\tno_entry_flag=\n      else\n\t# If we're using GNU nm, then we don't want the \"-C\" option.\n\t# -C means demangle to GNU nm, but means don't demangle to AIX nm.\n\t# Without the \"-l\" option, or with the \"-B\" option, AIX nm treats\n\t# weak defined symbols like other global defined symbols, whereas\n\t# GNU nm marks them as \"W\".\n\t# While the 'weak' keyword is ignored in the Export File, we need\n\t# it in the Import File for the 'aix-soname' feature, so we have\n\t# to replace the \"-B\" option with \"-P\" for AIX nm.\n\tif $NM -V 2>&1 | $GREP 'GNU' > /dev/null; then\n\t  _LT_TAGVAR(export_symbols_cmds, $1)='$NM -Bpg $libobjs $convenience | awk '\\''{ if (((\\$ 2 == \"T\") || (\\$ 2 == \"D\") || (\\$ 2 == \"B\") || (\\$ 2 == \"W\")) && ([substr](\\$ 3,1,1) != \".\")) { if (\\$ 2 == \"W\") { print \\$ 3 \" weak\" } else { print \\$ 3 } } }'\\'' | sort -u > $export_symbols'\n\telse\n\t  _LT_TAGVAR(export_symbols_cmds, $1)='`func_echo_all $NM | $SED -e '\\''s/B\\([[^B]]*\\)$/P\\1/'\\''` -PCpgl $libobjs $convenience | awk '\\''{ if (((\\$ 2 == \"T\") || (\\$ 2 == \"D\") || (\\$ 2 == \"B\") || (\\$ 2 == \"W\") || (\\$ 2 == \"V\") || (\\$ 2 == \"Z\")) && ([substr](\\$ 1,1,1) != \".\")) { if ((\\$ 2 == \"W\") || (\\$ 2 == \"V\") || (\\$ 2 == \"Z\")) { print \\$ 1 \" weak\" } else { print \\$ 1 } } }'\\'' | sort -u > $export_symbols'\n\tfi\n\taix_use_runtimelinking=no\n\n\t# Test if we are trying to use run time linking or normal\n\t# AIX style linking. If -brtl is somewhere in LDFLAGS, we\n\t# have runtime linking enabled, and use it for executables.\n\t# For shared libraries, we enable/disable runtime linking\n\t# depending on the kind of the shared library created -\n\t# when \"with_aix_soname,aix_use_runtimelinking\" is:\n\t# \"aix,no\"   lib.a(lib.so.V) shared, rtl:no,  for executables\n\t# \"aix,yes\"  lib.so          shared, rtl:yes, for executables\n\t#            lib.a           static archive\n\t# \"both,no\"  lib.so.V(shr.o) shared, rtl:yes\n\t#            lib.a(lib.so.V) shared, rtl:no,  for executables\n\t# \"both,yes\" lib.so.V(shr.o) shared, rtl:yes, for executables\n\t#            lib.a(lib.so.V) shared, rtl:no\n\t# \"svr4,*\"   lib.so.V(shr.o) shared, rtl:yes, for executables\n\t#            lib.a           static archive\n\tcase $host_os in aix4.[[23]]|aix4.[[23]].*|aix[[5-9]]*)\n\t  for ld_flag in $LDFLAGS; do\n\t  if (test x-brtl = \"x$ld_flag\" || test x-Wl,-brtl = \"x$ld_flag\"); then\n\t    aix_use_runtimelinking=yes\n\t    break\n\t  fi\n\t  done\n\t  if test svr4,no = \"$with_aix_soname,$aix_use_runtimelinking\"; then\n\t    # With aix-soname=svr4, we create the lib.so.V shared archives only,\n\t    # so we don't have lib.a shared libs to link our executables.\n\t    # We have to force runtime linking in this case.\n\t    aix_use_runtimelinking=yes\n\t    LDFLAGS=\"$LDFLAGS -Wl,-brtl\"\n\t  fi\n\t  ;;\n\tesac\n\n\texp_sym_flag='-bexport'\n\tno_entry_flag='-bnoentry'\n      fi\n\n      # When large executables or shared objects are built, AIX ld can\n      # have problems creating the table of contents.  If linking a library\n      # or program results in \"error TOC overflow\" add -mminimal-toc to\n      # CXXFLAGS/CFLAGS for g++/gcc.  In the cases where that is not\n      # enough to fix the problem, add -Wl,-bbigtoc to LDFLAGS.\n\n      _LT_TAGVAR(archive_cmds, $1)=''\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=':'\n      _LT_TAGVAR(link_all_deplibs, $1)=yes\n      _LT_TAGVAR(file_list_spec, $1)='$wl-f,'\n      case $with_aix_soname,$aix_use_runtimelinking in\n      aix,*) ;; # traditional, no import file\n      svr4,* | *,yes) # use import file\n\t# The Import File defines what to hardcode.\n\t_LT_TAGVAR(hardcode_direct, $1)=no\n\t_LT_TAGVAR(hardcode_direct_absolute, $1)=no\n\t;;\n      esac\n\n      if test yes = \"$GCC\"; then\n\tcase $host_os in aix4.[[012]]|aix4.[[012]].*)\n\t# We only want to do this on AIX 4.2 and lower, the check\n\t# below for broken collect2 doesn't work under 4.3+\n\t  collect2name=`$CC -print-prog-name=collect2`\n\t  if test -f \"$collect2name\" &&\n\t   strings \"$collect2name\" | $GREP resolve_lib_name >/dev/null\n\t  then\n\t  # We have reworked collect2\n\t  :\n\t  else\n\t  # We have old collect2\n\t  _LT_TAGVAR(hardcode_direct, $1)=unsupported\n\t  # It fails to find uninstalled libraries when the uninstalled\n\t  # path is not listed in the libpath.  Setting hardcode_minus_L\n\t  # to unsupported forces relinking\n\t  _LT_TAGVAR(hardcode_minus_L, $1)=yes\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n\t  _LT_TAGVAR(hardcode_libdir_separator, $1)=\n\t  fi\n\t  ;;\n\tesac\n\tshared_flag='-shared'\n\tif test yes = \"$aix_use_runtimelinking\"; then\n\t  shared_flag=\"$shared_flag \"'$wl-G'\n\tfi\n\t# Need to ensure runtime linking is disabled for the traditional\n\t# shared library, or the linker may eventually find shared libraries\n\t# /with/ Import File - we do not want to mix them.\n\tshared_flag_aix='-shared'\n\tshared_flag_svr4='-shared $wl-G'\n      else\n\t# not using gcc\n\tif test ia64 = \"$host_cpu\"; then\n\t# VisualAge C++, Version 5.5 for AIX 5L for IA-64, Beta 3 Release\n\t# chokes on -Wl,-G. The following line is correct:\n\t  shared_flag='-G'\n\telse\n\t  if test yes = \"$aix_use_runtimelinking\"; then\n\t    shared_flag='$wl-G'\n\t  else\n\t    shared_flag='$wl-bM:SRE'\n\t  fi\n\t  shared_flag_aix='$wl-bM:SRE'\n\t  shared_flag_svr4='$wl-G'\n\tfi\n      fi\n\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl-bexpall'\n      # It seems that -bexpall does not export symbols beginning with\n      # underscore (_), so it is better to generate a list of symbols to export.\n      _LT_TAGVAR(always_export_symbols, $1)=yes\n      if test aix,yes = \"$with_aix_soname,$aix_use_runtimelinking\"; then\n\t# Warning - without using the other runtime loading flags (-brtl),\n\t# -berok will link without error, but may produce a broken library.\n\t_LT_TAGVAR(allow_undefined_flag, $1)='-berok'\n        # Determine the default libpath from the value encoded in an\n        # empty executable.\n        _LT_SYS_MODULE_PATH_AIX([$1])\n        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-blibpath:$libdir:'\"$aix_libpath\"\n        _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -o $output_objdir/$soname $libobjs $deplibs $wl'$no_entry_flag' $compiler_flags `if test -n \"$allow_undefined_flag\"; then func_echo_all \"$wl$allow_undefined_flag\"; else :; fi` $wl'$exp_sym_flag:\\$export_symbols' '$shared_flag\n      else\n\tif test ia64 = \"$host_cpu\"; then\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-R $libdir:/usr/lib:/lib'\n\t  _LT_TAGVAR(allow_undefined_flag, $1)=\"-z nodefs\"\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)=\"\\$CC $shared_flag\"' -o $output_objdir/$soname $libobjs $deplibs '\"\\$wl$no_entry_flag\"' $compiler_flags $wl$allow_undefined_flag '\"\\$wl$exp_sym_flag:\\$export_symbols\"\n\telse\n\t # Determine the default libpath from the value encoded in an\n\t # empty executable.\n\t _LT_SYS_MODULE_PATH_AIX([$1])\n\t _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-blibpath:$libdir:'\"$aix_libpath\"\n\t  # Warning - without using the other run time loading flags,\n\t  # -berok will link without error, but may produce a broken library.\n\t  _LT_TAGVAR(no_undefined_flag, $1)=' $wl-bernotok'\n\t  _LT_TAGVAR(allow_undefined_flag, $1)=' $wl-berok'\n\t  if test yes = \"$with_gnu_ld\"; then\n\t    # We only use this code for GNU lds that support --whole-archive.\n\t    _LT_TAGVAR(whole_archive_flag_spec, $1)='$wl--whole-archive$convenience $wl--no-whole-archive'\n\t  else\n\t    # Exported symbols can be pulled into shared objects from archives\n\t    _LT_TAGVAR(whole_archive_flag_spec, $1)='$convenience'\n\t  fi\n\t  _LT_TAGVAR(archive_cmds_need_lc, $1)=yes\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)='$RM -r $output_objdir/$realname.d~$MKDIR $output_objdir/$realname.d'\n\t  # -brtl affects multiple linker settings, -berok does not and is overridden later\n\t  compiler_flags_filtered='`func_echo_all \"$compiler_flags \" | $SED -e \"s%-brtl\\\\([[, ]]\\\\)%-berok\\\\1%g\"`'\n\t  if test svr4 != \"$with_aix_soname\"; then\n\t    # This is similar to how AIX traditionally builds its shared libraries.\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)=\"$_LT_TAGVAR(archive_expsym_cmds, $1)\"'~$CC '$shared_flag_aix' -o $output_objdir/$realname.d/$soname $libobjs $deplibs $wl-bnoentry '$compiler_flags_filtered'$wl-bE:$export_symbols$allow_undefined_flag~$AR $AR_FLAGS $output_objdir/$libname$release.a $output_objdir/$realname.d/$soname'\n\t  fi\n\t  if test aix != \"$with_aix_soname\"; then\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)=\"$_LT_TAGVAR(archive_expsym_cmds, $1)\"'~$CC '$shared_flag_svr4' -o $output_objdir/$realname.d/$shared_archive_member_spec.o $libobjs $deplibs $wl-bnoentry '$compiler_flags_filtered'$wl-bE:$export_symbols$allow_undefined_flag~$STRIP -e $output_objdir/$realname.d/$shared_archive_member_spec.o~( func_echo_all \"#! $soname($shared_archive_member_spec.o)\"; if test shr_64 = \"$shared_archive_member_spec\"; then func_echo_all \"# 64\"; else func_echo_all \"# 32\"; fi; cat $export_symbols ) > $output_objdir/$realname.d/$shared_archive_member_spec.imp~$AR $AR_FLAGS $output_objdir/$soname $output_objdir/$realname.d/$shared_archive_member_spec.o $output_objdir/$realname.d/$shared_archive_member_spec.imp'\n\t  else\n\t    # used by -dlpreopen to get the symbols\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)=\"$_LT_TAGVAR(archive_expsym_cmds, $1)\"'~$MV  $output_objdir/$realname.d/$soname $output_objdir'\n\t  fi\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)=\"$_LT_TAGVAR(archive_expsym_cmds, $1)\"'~$RM -r $output_objdir/$realname.d'\n\tfi\n      fi\n      ;;\n\n    amigaos*)\n      case $host_cpu in\n      powerpc)\n            # see comment about AmigaOS4 .so support\n            _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags $wl-soname $wl$soname -o $lib'\n            _LT_TAGVAR(archive_expsym_cmds, $1)=''\n        ;;\n      m68k)\n            _LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/a2ixlibrary.data~$ECHO \"#define NAME $libname\" > $output_objdir/a2ixlibrary.data~$ECHO \"#define LIBRARY_ID 1\" >> $output_objdir/a2ixlibrary.data~$ECHO \"#define VERSION $major\" >> $output_objdir/a2ixlibrary.data~$ECHO \"#define REVISION $revision\" >> $output_objdir/a2ixlibrary.data~$AR $AR_FLAGS $lib $libobjs~$RANLIB $lib~(cd $output_objdir && a2ixlibrary -32)'\n            _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n            _LT_TAGVAR(hardcode_minus_L, $1)=yes\n        ;;\n      esac\n      ;;\n\n    bsdi[[45]]*)\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)=-rdynamic\n      ;;\n\n    cygwin* | mingw* | pw32* | cegcc*)\n      # When not using gcc, we currently assume that we are using\n      # Microsoft Visual C++.\n      # hardcode_libdir_flag_spec is actually meaningless, as there is\n      # no search path for DLLs.\n      case $cc_basename in\n      cl*)\n\t# Native MSVC\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)=' '\n\t_LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n\t_LT_TAGVAR(always_export_symbols, $1)=yes\n\t_LT_TAGVAR(file_list_spec, $1)='@'\n\t# Tell ltmain to make .lib files, not .a files.\n\tlibext=lib\n\t# Tell ltmain to make .dll files, not .so files.\n\tshrext_cmds=.dll\n\t# FIXME: Setting linknames here is a bad hack.\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -o $output_objdir/$soname $libobjs $compiler_flags $deplibs -Wl,-DLL,-IMPLIB:\"$tool_output_objdir$libname.dll.lib\"~linknames='\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='if _LT_DLL_DEF_P([$export_symbols]); then\n            cp \"$export_symbols\" \"$output_objdir/$soname.def\";\n            echo \"$tool_output_objdir$soname.def\" > \"$output_objdir/$soname.exp\";\n          else\n            $SED -e '\\''s/^/-link -EXPORT:/'\\'' < $export_symbols > $output_objdir/$soname.exp;\n          fi~\n          $CC -o $tool_output_objdir$soname $libobjs $compiler_flags $deplibs \"@$tool_output_objdir$soname.exp\" -Wl,-DLL,-IMPLIB:\"$tool_output_objdir$libname.dll.lib\"~\n          linknames='\n\t# The linker will not automatically build a static lib if we build a DLL.\n\t# _LT_TAGVAR(old_archive_from_new_cmds, $1)='true'\n\t_LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes\n\t_LT_TAGVAR(exclude_expsyms, $1)='_NULL_IMPORT_DESCRIPTOR|_IMPORT_DESCRIPTOR_.*'\n\t_LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED -e '\\''/^[[BCDGRS]][[ ]]/s/.*[[ ]]\\([[^ ]]*\\)/\\1,DATA/'\\'' | $SED -e '\\''/^[[AITW]][[ ]]/s/.*[[ ]]//'\\'' | sort | uniq > $export_symbols'\n\t# Don't use ranlib\n\t_LT_TAGVAR(old_postinstall_cmds, $1)='chmod 644 $oldlib'\n\t_LT_TAGVAR(postlink_cmds, $1)='lt_outputfile=\"@OUTPUT@\"~\n          lt_tool_outputfile=\"@TOOL_OUTPUT@\"~\n          case $lt_outputfile in\n            *.exe|*.EXE) ;;\n            *)\n              lt_outputfile=$lt_outputfile.exe\n              lt_tool_outputfile=$lt_tool_outputfile.exe\n              ;;\n          esac~\n          if test : != \"$MANIFEST_TOOL\" && test -f \"$lt_outputfile.manifest\"; then\n            $MANIFEST_TOOL -manifest \"$lt_tool_outputfile.manifest\" -outputresource:\"$lt_tool_outputfile\" || exit 1;\n            $RM \"$lt_outputfile.manifest\";\n          fi'\n\t;;\n      *)\n\t# Assume MSVC wrapper\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)=' '\n\t_LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n\t# Tell ltmain to make .lib files, not .a files.\n\tlibext=lib\n\t# Tell ltmain to make .dll files, not .so files.\n\tshrext_cmds=.dll\n\t# FIXME: Setting linknames here is a bad hack.\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -o $lib $libobjs $compiler_flags `func_echo_all \"$deplibs\" | $SED '\\''s/ -lc$//'\\''` -link -dll~linknames='\n\t# The linker will automatically build a .lib file if we build a DLL.\n\t_LT_TAGVAR(old_archive_from_new_cmds, $1)='true'\n\t# FIXME: Should let the user specify the lib program.\n\t_LT_TAGVAR(old_archive_cmds, $1)='lib -OUT:$oldlib$oldobjs$old_deplibs'\n\t_LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes\n\t;;\n      esac\n      ;;\n\n    darwin* | rhapsody*)\n      _LT_DARWIN_LINKER_FEATURES($1)\n      ;;\n\n    dgux*)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    # FreeBSD 2.2.[012] allows us to include c++rt0.o to get C++ constructor\n    # support.  Future versions do this automatically, but an explicit c++rt0.o\n    # does not break anything, and helps significantly (at the cost of a little\n    # extra space).\n    freebsd2.2*)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags /usr/lib/c++rt0.o'\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    # Unfortunately, older versions of FreeBSD 2 do not have this feature.\n    freebsd2.*)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_minus_L, $1)=yes\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    # FreeBSD 3 and greater uses gcc -shared to do shared libraries.\n    freebsd* | dragonfly*)\n      _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    hpux9*)\n      if test yes = \"$GCC\"; then\n\t_LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/$soname~$CC -shared $pic_flag $wl+b $wl$install_libdir -o $output_objdir/$soname $libobjs $deplibs $compiler_flags~test \"x$output_objdir/$soname\" = \"x$lib\" || mv $output_objdir/$soname $lib'\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/$soname~$LD -b +b $install_libdir -o $output_objdir/$soname $libobjs $deplibs $linker_flags~test \"x$output_objdir/$soname\" = \"x$lib\" || mv $output_objdir/$soname $lib'\n      fi\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl+b $wl$libdir'\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n\n      # hardcode_minus_L: Not really in the search PATH,\n      # but as the default location of the library.\n      _LT_TAGVAR(hardcode_minus_L, $1)=yes\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl-E'\n      ;;\n\n    hpux10*)\n      if test yes,no = \"$GCC,$with_gnu_ld\"; then\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $wl+h $wl$soname $wl+b $wl$install_libdir -o $lib $libobjs $deplibs $compiler_flags'\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$LD -b +h $soname +b $install_libdir -o $lib $libobjs $deplibs $linker_flags'\n      fi\n      if test no = \"$with_gnu_ld\"; then\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl+b $wl$libdir'\n\t_LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\t_LT_TAGVAR(hardcode_direct, $1)=yes\n\t_LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n\t_LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl-E'\n\t# hardcode_minus_L: Not really in the search PATH,\n\t# but as the default location of the library.\n\t_LT_TAGVAR(hardcode_minus_L, $1)=yes\n      fi\n      ;;\n\n    hpux11*)\n      if test yes,no = \"$GCC,$with_gnu_ld\"; then\n\tcase $host_cpu in\n\thppa*64*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -shared $wl+h $wl$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\tia64*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $wl+h $wl$soname $wl+nodefaultrpath -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\t*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $wl+h $wl$soname $wl+b $wl$install_libdir -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\tesac\n      else\n\tcase $host_cpu in\n\thppa*64*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -b $wl+h $wl$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\tia64*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -b $wl+h $wl$soname $wl+nodefaultrpath -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\t*)\n\tm4_if($1, [], [\n\t  # Older versions of the 11.00 compiler do not understand -b yet\n\t  # (HP92453-01 A.11.01.20 doesn't, HP92453-01 B.11.X.35175-35176.GP does)\n\t  _LT_LINKER_OPTION([if $CC understands -b],\n\t    _LT_TAGVAR(lt_cv_prog_compiler__b, $1), [-b],\n\t    [_LT_TAGVAR(archive_cmds, $1)='$CC -b $wl+h $wl$soname $wl+b $wl$install_libdir -o $lib $libobjs $deplibs $compiler_flags'],\n\t    [_LT_TAGVAR(archive_cmds, $1)='$LD -b +h $soname +b $install_libdir -o $lib $libobjs $deplibs $linker_flags'])],\n\t  [_LT_TAGVAR(archive_cmds, $1)='$CC -b $wl+h $wl$soname $wl+b $wl$install_libdir -o $lib $libobjs $deplibs $compiler_flags'])\n\t  ;;\n\tesac\n      fi\n      if test no = \"$with_gnu_ld\"; then\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl+b $wl$libdir'\n\t_LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\n\tcase $host_cpu in\n\thppa*64*|ia64*)\n\t  _LT_TAGVAR(hardcode_direct, $1)=no\n\t  _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\t  ;;\n\t*)\n\t  _LT_TAGVAR(hardcode_direct, $1)=yes\n\t  _LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n\t  _LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl-E'\n\n\t  # hardcode_minus_L: Not really in the search PATH,\n\t  # but as the default location of the library.\n\t  _LT_TAGVAR(hardcode_minus_L, $1)=yes\n\t  ;;\n\tesac\n      fi\n      ;;\n\n    irix5* | irix6* | nonstopux*)\n      if test yes = \"$GCC\"; then\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags $wl-soname $wl$soname `test -n \"$verstring\" && func_echo_all \"$wl-set_version $wl$verstring\"` $wl-update_registry $wl$output_objdir/so_locations -o $lib'\n\t# Try to use the -exported_symbol ld option, if it does not\n\t# work, assume that -exports_file does not work either and\n\t# implicitly export all symbols.\n\t# This should be the same for all languages, so no per-tag cache variable.\n\tAC_CACHE_CHECK([whether the $host_os linker accepts -exported_symbol],\n\t  [lt_cv_irix_exported_symbol],\n\t  [save_LDFLAGS=$LDFLAGS\n\t   LDFLAGS=\"$LDFLAGS -shared $wl-exported_symbol ${wl}foo $wl-update_registry $wl/dev/null\"\n\t   AC_LINK_IFELSE(\n\t     [AC_LANG_SOURCE(\n\t        [AC_LANG_CASE([C], [[int foo (void) { return 0; }]],\n\t\t\t      [C++], [[int foo (void) { return 0; }]],\n\t\t\t      [Fortran 77], [[\n      subroutine foo\n      end]],\n\t\t\t      [Fortran], [[\n      subroutine foo\n      end]])])],\n\t      [lt_cv_irix_exported_symbol=yes],\n\t      [lt_cv_irix_exported_symbol=no])\n           LDFLAGS=$save_LDFLAGS])\n\tif test yes = \"$lt_cv_irix_exported_symbol\"; then\n          _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags $wl-soname $wl$soname `test -n \"$verstring\" && func_echo_all \"$wl-set_version $wl$verstring\"` $wl-update_registry $wl$output_objdir/so_locations $wl-exports_file $wl$export_symbols -o $lib'\n\tfi\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags -soname $soname `test -n \"$verstring\" && func_echo_all \"-set_version $verstring\"` -update_registry $output_objdir/so_locations -o $lib'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags -soname $soname `test -n \"$verstring\" && func_echo_all \"-set_version $verstring\"` -update_registry $output_objdir/so_locations -exports_file $export_symbols -o $lib'\n      fi\n      _LT_TAGVAR(archive_cmds_need_lc, $1)='no'\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath $wl$libdir'\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n      _LT_TAGVAR(inherit_rpath, $1)=yes\n      _LT_TAGVAR(link_all_deplibs, $1)=yes\n      ;;\n\n    linux*)\n      case $cc_basename in\n      tcc*)\n\t# Fabrice Bellard et al's Tiny C Compiler\n\t_LT_TAGVAR(ld_shlibs, $1)=yes\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'\n\t;;\n      esac\n      ;;\n\n    netbsd*)\n      if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then\n\t_LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable -o $lib $libobjs $deplibs $linker_flags'  # a.out\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$LD -shared -o $lib $libobjs $deplibs $linker_flags'      # ELF\n      fi\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    newsos6)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath $wl$libdir'\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    *nto* | *qnx*)\n      ;;\n\n    openbsd* | bitrig*)\n      if test -f /usr/libexec/ld.so; then\n\t_LT_TAGVAR(hardcode_direct, $1)=yes\n\t_LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\t_LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n\tif test -z \"`echo __ELF__ | $CC -E - | $GREP __ELF__`\"; then\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags $wl-retain-symbols-file,$export_symbols'\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath,$libdir'\n\t  _LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl-E'\n\telse\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags'\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath,$libdir'\n\tfi\n      else\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n      fi\n      ;;\n\n    os2*)\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n      _LT_TAGVAR(hardcode_minus_L, $1)=yes\n      _LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n      shrext_cmds=.dll\n      _LT_TAGVAR(archive_cmds, $1)='$ECHO \"LIBRARY ${soname%$shared_ext} INITINSTANCE TERMINSTANCE\" > $output_objdir/$libname.def~\n\t$ECHO \"DESCRIPTION \\\"$libname\\\"\" >> $output_objdir/$libname.def~\n\t$ECHO \"DATA MULTIPLE NONSHARED\" >> $output_objdir/$libname.def~\n\t$ECHO EXPORTS >> $output_objdir/$libname.def~\n\temxexp $libobjs | $SED /\"_DLL_InitTerm\"/d >> $output_objdir/$libname.def~\n\t$CC -Zdll -Zcrtdll -o $output_objdir/$soname $libobjs $deplibs $compiler_flags $output_objdir/$libname.def~\n\temximp -o $lib $output_objdir/$libname.def'\n      _LT_TAGVAR(archive_expsym_cmds, $1)='$ECHO \"LIBRARY ${soname%$shared_ext} INITINSTANCE TERMINSTANCE\" > $output_objdir/$libname.def~\n\t$ECHO \"DESCRIPTION \\\"$libname\\\"\" >> $output_objdir/$libname.def~\n\t$ECHO \"DATA MULTIPLE NONSHARED\" >> $output_objdir/$libname.def~\n\t$ECHO EXPORTS >> $output_objdir/$libname.def~\n\tprefix_cmds=\"$SED\"~\n\tif test EXPORTS = \"`$SED 1q $export_symbols`\"; then\n\t  prefix_cmds=\"$prefix_cmds -e 1d\";\n\tfi~\n\tprefix_cmds=\"$prefix_cmds -e \\\"s/^\\(.*\\)$/_\\1/g\\\"\"~\n\tcat $export_symbols | $prefix_cmds >> $output_objdir/$libname.def~\n\t$CC -Zdll -Zcrtdll -o $output_objdir/$soname $libobjs $deplibs $compiler_flags $output_objdir/$libname.def~\n\temximp -o $lib $output_objdir/$libname.def'\n      _LT_TAGVAR(old_archive_From_new_cmds, $1)='emximp -o $output_objdir/${libname}_dll.a $output_objdir/$libname.def'\n      _LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes\n      ;;\n\n    osf3*)\n      if test yes = \"$GCC\"; then\n\t_LT_TAGVAR(allow_undefined_flag, $1)=' $wl-expect_unresolved $wl\\*'\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared$allow_undefined_flag $libobjs $deplibs $compiler_flags $wl-soname $wl$soname `test -n \"$verstring\" && func_echo_all \"$wl-set_version $wl$verstring\"` $wl-update_registry $wl$output_objdir/so_locations -o $lib'\n      else\n\t_LT_TAGVAR(allow_undefined_flag, $1)=' -expect_unresolved \\*'\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared$allow_undefined_flag $libobjs $deplibs $compiler_flags -soname $soname `test -n \"$verstring\" && func_echo_all \"-set_version $verstring\"` -update_registry $output_objdir/so_locations -o $lib'\n      fi\n      _LT_TAGVAR(archive_cmds_need_lc, $1)='no'\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath $wl$libdir'\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n      ;;\n\n    osf4* | osf5*)\t# as osf3* with the addition of -msym flag\n      if test yes = \"$GCC\"; then\n\t_LT_TAGVAR(allow_undefined_flag, $1)=' $wl-expect_unresolved $wl\\*'\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared$allow_undefined_flag $pic_flag $libobjs $deplibs $compiler_flags $wl-msym $wl-soname $wl$soname `test -n \"$verstring\" && func_echo_all \"$wl-set_version $wl$verstring\"` $wl-update_registry $wl$output_objdir/so_locations -o $lib'\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath $wl$libdir'\n      else\n\t_LT_TAGVAR(allow_undefined_flag, $1)=' -expect_unresolved \\*'\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared$allow_undefined_flag $libobjs $deplibs $compiler_flags -msym -soname $soname `test -n \"$verstring\" && func_echo_all \"-set_version $verstring\"` -update_registry $output_objdir/so_locations -o $lib'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='for i in `cat $export_symbols`; do printf \"%s %s\\\\n\" -exported_symbol \"\\$i\" >> $lib.exp; done; printf \"%s\\\\n\" \"-hidden\">> $lib.exp~\n          $CC -shared$allow_undefined_flag $wl-input $wl$lib.exp $compiler_flags $libobjs $deplibs -soname $soname `test -n \"$verstring\" && $ECHO \"-set_version $verstring\"` -update_registry $output_objdir/so_locations -o $lib~$RM $lib.exp'\n\n\t# Both c and cxx compiler support -rpath directly\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-rpath $libdir'\n      fi\n      _LT_TAGVAR(archive_cmds_need_lc, $1)='no'\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n      ;;\n\n    solaris*)\n      _LT_TAGVAR(no_undefined_flag, $1)=' -z defs'\n      if test yes = \"$GCC\"; then\n\twlarc='$wl'\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $wl-z ${wl}text $wl-h $wl$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $lib.exp~cat $export_symbols | $SED -e \"s/\\(.*\\)/\\1;/\" >> $lib.exp~echo \"local: *; };\" >> $lib.exp~\n          $CC -shared $pic_flag $wl-z ${wl}text $wl-M $wl$lib.exp $wl-h $wl$soname -o $lib $libobjs $deplibs $compiler_flags~$RM $lib.exp'\n      else\n\tcase `$CC -V 2>&1` in\n\t*\"Compilers 5.0\"*)\n\t  wlarc=''\n\t  _LT_TAGVAR(archive_cmds, $1)='$LD -G$allow_undefined_flag -h $soname -o $lib $libobjs $deplibs $linker_flags'\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $lib.exp~cat $export_symbols | $SED -e \"s/\\(.*\\)/\\1;/\" >> $lib.exp~echo \"local: *; };\" >> $lib.exp~\n            $LD -G$allow_undefined_flag -M $lib.exp -h $soname -o $lib $libobjs $deplibs $linker_flags~$RM $lib.exp'\n\t  ;;\n\t*)\n\t  wlarc='$wl'\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -G$allow_undefined_flag -h $soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $lib.exp~cat $export_symbols | $SED -e \"s/\\(.*\\)/\\1;/\" >> $lib.exp~echo \"local: *; };\" >> $lib.exp~\n            $CC -G$allow_undefined_flag -M $lib.exp -h $soname -o $lib $libobjs $deplibs $compiler_flags~$RM $lib.exp'\n\t  ;;\n\tesac\n      fi\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      case $host_os in\n      solaris2.[[0-5]] | solaris2.[[0-5]].*) ;;\n      *)\n\t# The compiler driver will combine and reorder linker options,\n\t# but understands '-z linker_flag'.  GCC discards it without '$wl',\n\t# but is careful enough not to reorder.\n\t# Supported since Solaris 2.6 (maybe 2.5.1?)\n\tif test yes = \"$GCC\"; then\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='$wl-z ${wl}allextract$convenience $wl-z ${wl}defaultextract'\n\telse\n\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='-z allextract$convenience -z defaultextract'\n\tfi\n\t;;\n      esac\n      _LT_TAGVAR(link_all_deplibs, $1)=yes\n      ;;\n\n    sunos4*)\n      if test sequent = \"$host_vendor\"; then\n\t# Use $CC to link under sequent, because it throws in some extra .o\n\t# files that make .init and .fini sections work.\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -G $wl-h $soname -o $lib $libobjs $deplibs $compiler_flags'\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$LD -assert pure-text -Bstatic -o $lib $libobjs $deplibs $linker_flags'\n      fi\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n      _LT_TAGVAR(hardcode_direct, $1)=yes\n      _LT_TAGVAR(hardcode_minus_L, $1)=yes\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    sysv4)\n      case $host_vendor in\n\tsni)\n\t  _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n\t  _LT_TAGVAR(hardcode_direct, $1)=yes # is this really true???\n\t;;\n\tsiemens)\n\t  ## LD is ld it makes a PLAMLIB\n\t  ## CC just makes a GrossModule.\n\t  _LT_TAGVAR(archive_cmds, $1)='$LD -G -o $lib $libobjs $deplibs $linker_flags'\n\t  _LT_TAGVAR(reload_cmds, $1)='$CC -r -o $output$reload_objs'\n\t  _LT_TAGVAR(hardcode_direct, $1)=no\n        ;;\n\tmotorola)\n\t  _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n\t  _LT_TAGVAR(hardcode_direct, $1)=no #Motorola manual says yes, but my tests say they lie\n\t;;\n      esac\n      runpath_var='LD_RUN_PATH'\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    sysv4.3*)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)='-Bexport'\n      ;;\n\n    sysv4*MP*)\n      if test -d /usr/nec; then\n\t_LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n\t_LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\trunpath_var=LD_RUN_PATH\n\thardcode_runpath_var=yes\n\t_LT_TAGVAR(ld_shlibs, $1)=yes\n      fi\n      ;;\n\n    sysv4*uw2* | sysv5OpenUNIX* | sysv5UnixWare7.[[01]].[[10]]* | unixware7* | sco3.2v5.0.[[024]]*)\n      _LT_TAGVAR(no_undefined_flag, $1)='$wl-z,text'\n      _LT_TAGVAR(archive_cmds_need_lc, $1)=no\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      runpath_var='LD_RUN_PATH'\n\n      if test yes = \"$GCC\"; then\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $wl-Bexport:$export_symbols $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -G $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G $wl-Bexport:$export_symbols $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n      fi\n      ;;\n\n    sysv5* | sco3.2v5* | sco5v6*)\n      # Note: We CANNOT use -z defs as we might desire, because we do not\n      # link with -lc, and that would cause any symbols used from libc to\n      # always be unresolved, which means just about no library would\n      # ever link correctly.  If we're not using GNU ld we use -z text\n      # though, which does catch some bad symbols but isn't as heavy-handed\n      # as -z defs.\n      _LT_TAGVAR(no_undefined_flag, $1)='$wl-z,text'\n      _LT_TAGVAR(allow_undefined_flag, $1)='$wl-z,nodefs'\n      _LT_TAGVAR(archive_cmds_need_lc, $1)=no\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-R,$libdir'\n      _LT_TAGVAR(hardcode_libdir_separator, $1)=':'\n      _LT_TAGVAR(link_all_deplibs, $1)=yes\n      _LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl-Bexport'\n      runpath_var='LD_RUN_PATH'\n\n      if test yes = \"$GCC\"; then\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $wl-Bexport:$export_symbols $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n      else\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -G $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G $wl-Bexport:$export_symbols $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n      fi\n      ;;\n\n    uts4*)\n      _LT_TAGVAR(archive_cmds, $1)='$LD -G -h $soname -o $lib $libobjs $deplibs $linker_flags'\n      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      ;;\n\n    *)\n      _LT_TAGVAR(ld_shlibs, $1)=no\n      ;;\n    esac\n\n    if test sni = \"$host_vendor\"; then\n      case $host in\n      sysv4 | sysv4.2uw2* | sysv4.3* | sysv5*)\n\t_LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl-Blargedynsym'\n\t;;\n      esac\n    fi\n  fi\n])\nAC_MSG_RESULT([$_LT_TAGVAR(ld_shlibs, $1)])\ntest no = \"$_LT_TAGVAR(ld_shlibs, $1)\" && can_build_shared=no\n\n_LT_TAGVAR(with_gnu_ld, $1)=$with_gnu_ld\n\n_LT_DECL([], [libext], [0], [Old archive suffix (normally \"a\")])dnl\n_LT_DECL([], [shrext_cmds], [1], [Shared library suffix (normally \".so\")])dnl\n_LT_DECL([], [extract_expsyms_cmds], [2],\n    [The commands to extract the exported symbol list from a shared archive])\n\n#\n# Do we need to explicitly link libc?\n#\ncase \"x$_LT_TAGVAR(archive_cmds_need_lc, $1)\" in\nx|xyes)\n  # Assume -lc should be added\n  _LT_TAGVAR(archive_cmds_need_lc, $1)=yes\n\n  if test yes,yes = \"$GCC,$enable_shared\"; then\n    case $_LT_TAGVAR(archive_cmds, $1) in\n    *'~'*)\n      # FIXME: we may have to deal with multi-command sequences.\n      ;;\n    '$CC '*)\n      # Test whether the compiler implicitly links with -lc since on some\n      # systems, -lgcc has to come before -lc. If gcc already passes -lc\n      # to ld, don't add -lc before -lgcc.\n      AC_CACHE_CHECK([whether -lc should be explicitly linked in],\n\t[lt_cv_]_LT_TAGVAR(archive_cmds_need_lc, $1),\n\t[$RM conftest*\n\techo \"$lt_simple_compile_test_code\" > conftest.$ac_ext\n\n\tif AC_TRY_EVAL(ac_compile) 2>conftest.err; then\n\t  soname=conftest\n\t  lib=conftest\n\t  libobjs=conftest.$ac_objext\n\t  deplibs=\n\t  wl=$_LT_TAGVAR(lt_prog_compiler_wl, $1)\n\t  pic_flag=$_LT_TAGVAR(lt_prog_compiler_pic, $1)\n\t  compiler_flags=-v\n\t  linker_flags=-v\n\t  verstring=\n\t  output_objdir=.\n\t  libname=conftest\n\t  lt_save_allow_undefined_flag=$_LT_TAGVAR(allow_undefined_flag, $1)\n\t  _LT_TAGVAR(allow_undefined_flag, $1)=\n\t  if AC_TRY_EVAL(_LT_TAGVAR(archive_cmds, $1) 2\\>\\&1 \\| $GREP \\\" -lc \\\" \\>/dev/null 2\\>\\&1)\n\t  then\n\t    lt_cv_[]_LT_TAGVAR(archive_cmds_need_lc, $1)=no\n\t  else\n\t    lt_cv_[]_LT_TAGVAR(archive_cmds_need_lc, $1)=yes\n\t  fi\n\t  _LT_TAGVAR(allow_undefined_flag, $1)=$lt_save_allow_undefined_flag\n\telse\n\t  cat conftest.err 1>&5\n\tfi\n\t$RM conftest*\n\t])\n      _LT_TAGVAR(archive_cmds_need_lc, $1)=$lt_cv_[]_LT_TAGVAR(archive_cmds_need_lc, $1)\n      ;;\n    esac\n  fi\n  ;;\nesac\n\n_LT_TAGDECL([build_libtool_need_lc], [archive_cmds_need_lc], [0],\n    [Whether or not to add -lc for building shared libraries])\n_LT_TAGDECL([allow_libtool_libs_with_static_runtimes],\n    [enable_shared_with_static_runtimes], [0],\n    [Whether or not to disallow shared libs when runtime libs are static])\n_LT_TAGDECL([], [export_dynamic_flag_spec], [1],\n    [Compiler flag to allow reflexive dlopens])\n_LT_TAGDECL([], [whole_archive_flag_spec], [1],\n    [Compiler flag to generate shared objects directly from archives])\n_LT_TAGDECL([], [compiler_needs_object], [1],\n    [Whether the compiler copes with passing no objects directly])\n_LT_TAGDECL([], [old_archive_from_new_cmds], [2],\n    [Create an old-style archive from a shared archive])\n_LT_TAGDECL([], [old_archive_from_expsyms_cmds], [2],\n    [Create a temporary old-style archive to link instead of a shared archive])\n_LT_TAGDECL([], [archive_cmds], [2], [Commands used to build a shared archive])\n_LT_TAGDECL([], [archive_expsym_cmds], [2])\n_LT_TAGDECL([], [module_cmds], [2],\n    [Commands used to build a loadable module if different from building\n    a shared archive.])\n_LT_TAGDECL([], [module_expsym_cmds], [2])\n_LT_TAGDECL([], [with_gnu_ld], [1],\n    [Whether we are building with GNU ld or not])\n_LT_TAGDECL([], [allow_undefined_flag], [1],\n    [Flag that allows shared libraries with undefined symbols to be built])\n_LT_TAGDECL([], [no_undefined_flag], [1],\n    [Flag that enforces no undefined symbols])\n_LT_TAGDECL([], [hardcode_libdir_flag_spec], [1],\n    [Flag to hardcode $libdir into a binary during linking.\n    This must work even if $libdir does not exist])\n_LT_TAGDECL([], [hardcode_libdir_separator], [1],\n    [Whether we need a single \"-rpath\" flag with a separated argument])\n_LT_TAGDECL([], [hardcode_direct], [0],\n    [Set to \"yes\" if using DIR/libNAME$shared_ext during linking hardcodes\n    DIR into the resulting binary])\n_LT_TAGDECL([], [hardcode_direct_absolute], [0],\n    [Set to \"yes\" if using DIR/libNAME$shared_ext during linking hardcodes\n    DIR into the resulting binary and the resulting library dependency is\n    \"absolute\", i.e impossible to change by setting $shlibpath_var if the\n    library is relocated])\n_LT_TAGDECL([], [hardcode_minus_L], [0],\n    [Set to \"yes\" if using the -LDIR flag during linking hardcodes DIR\n    into the resulting binary])\n_LT_TAGDECL([], [hardcode_shlibpath_var], [0],\n    [Set to \"yes\" if using SHLIBPATH_VAR=DIR during linking hardcodes DIR\n    into the resulting binary])\n_LT_TAGDECL([], [hardcode_automatic], [0],\n    [Set to \"yes\" if building a shared library automatically hardcodes DIR\n    into the library and all subsequent libraries and executables linked\n    against it])\n_LT_TAGDECL([], [inherit_rpath], [0],\n    [Set to yes if linker adds runtime paths of dependent libraries\n    to runtime path list])\n_LT_TAGDECL([], [link_all_deplibs], [0],\n    [Whether libtool must link a program against all its dependency libraries])\n_LT_TAGDECL([], [always_export_symbols], [0],\n    [Set to \"yes\" if exported symbols are required])\n_LT_TAGDECL([], [export_symbols_cmds], [2],\n    [The commands to list exported symbols])\n_LT_TAGDECL([], [exclude_expsyms], [1],\n    [Symbols that should not be listed in the preloaded symbols])\n_LT_TAGDECL([], [include_expsyms], [1],\n    [Symbols that must always be exported])\n_LT_TAGDECL([], [prelink_cmds], [2],\n    [Commands necessary for linking programs (against libraries) with templates])\n_LT_TAGDECL([], [postlink_cmds], [2],\n    [Commands necessary for finishing linking programs])\n_LT_TAGDECL([], [file_list_spec], [1],\n    [Specify filename containing input files])\ndnl FIXME: Not yet implemented\ndnl _LT_TAGDECL([], [thread_safe_flag_spec], [1],\ndnl    [Compiler flag to generate thread safe objects])\n])# _LT_LINKER_SHLIBS\n\n\n# _LT_LANG_C_CONFIG([TAG])\n# ------------------------\n# Ensure that the configuration variables for a C compiler are suitably\n# defined.  These variables are subsequently used by _LT_CONFIG to write\n# the compiler configuration to 'libtool'.\nm4_defun([_LT_LANG_C_CONFIG],\n[m4_require([_LT_DECL_EGREP])dnl\nlt_save_CC=$CC\nAC_LANG_PUSH(C)\n\n# Source file extension for C test sources.\nac_ext=c\n\n# Object file extension for compiled C test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# Code to be used in simple compile tests\nlt_simple_compile_test_code=\"int some_variable = 0;\"\n\n# Code to be used in simple link tests\nlt_simple_link_test_code='int main(){return(0);}'\n\n_LT_TAG_COMPILER\n# Save the default compiler, since it gets overwritten when the other\n# tags are being tested, and _LT_TAGVAR(compiler, []) is a NOP.\ncompiler_DEFAULT=$CC\n\n# save warnings/boilerplate of simple test code\n_LT_COMPILER_BOILERPLATE\n_LT_LINKER_BOILERPLATE\n\n## CAVEAT EMPTOR:\n## There is no encapsulation within the following macros, do not change\n## the running order or otherwise move them around unless you know exactly\n## what you are doing...\nif test -n \"$compiler\"; then\n  _LT_COMPILER_NO_RTTI($1)\n  _LT_COMPILER_PIC($1)\n  _LT_COMPILER_C_O($1)\n  _LT_COMPILER_FILE_LOCKS($1)\n  _LT_LINKER_SHLIBS($1)\n  _LT_SYS_DYNAMIC_LINKER($1)\n  _LT_LINKER_HARDCODE_LIBPATH($1)\n  LT_SYS_DLOPEN_SELF\n  _LT_CMD_STRIPLIB\n\n  # Report what library types will actually be built\n  AC_MSG_CHECKING([if libtool supports shared libraries])\n  AC_MSG_RESULT([$can_build_shared])\n\n  AC_MSG_CHECKING([whether to build shared libraries])\n  test no = \"$can_build_shared\" && enable_shared=no\n\n  # On AIX, shared libraries and static libraries use the same namespace, and\n  # are all built from PIC.\n  case $host_os in\n  aix3*)\n    test yes = \"$enable_shared\" && enable_static=no\n    if test -n \"$RANLIB\"; then\n      archive_cmds=\"$archive_cmds~\\$RANLIB \\$lib\"\n      postinstall_cmds='$RANLIB $lib'\n    fi\n    ;;\n\n  aix[[4-9]]*)\n    if test ia64 != \"$host_cpu\"; then\n      case $enable_shared,$with_aix_soname,$aix_use_runtimelinking in\n      yes,aix,yes) ;;\t\t\t# shared object as lib.so file only\n      yes,svr4,*) ;;\t\t\t# shared object as lib.so archive member only\n      yes,*) enable_static=no ;;\t# shared object in lib.a archive as well\n      esac\n    fi\n    ;;\n  esac\n  AC_MSG_RESULT([$enable_shared])\n\n  AC_MSG_CHECKING([whether to build static libraries])\n  # Make sure either enable_shared or enable_static is yes.\n  test yes = \"$enable_shared\" || enable_static=yes\n  AC_MSG_RESULT([$enable_static])\n\n  _LT_CONFIG($1)\nfi\nAC_LANG_POP\nCC=$lt_save_CC\n])# _LT_LANG_C_CONFIG\n\n\n# _LT_LANG_CXX_CONFIG([TAG])\n# --------------------------\n# Ensure that the configuration variables for a C++ compiler are suitably\n# defined.  These variables are subsequently used by _LT_CONFIG to write\n# the compiler configuration to 'libtool'.\nm4_defun([_LT_LANG_CXX_CONFIG],\n[m4_require([_LT_FILEUTILS_DEFAULTS])dnl\nm4_require([_LT_DECL_EGREP])dnl\nm4_require([_LT_PATH_MANIFEST_TOOL])dnl\nif test -n \"$CXX\" && ( test no != \"$CXX\" &&\n    ( (test g++ = \"$CXX\" && `g++ -v >/dev/null 2>&1` ) ||\n    (test g++ != \"$CXX\"))); then\n  AC_PROG_CXXCPP\nelse\n  _lt_caught_CXX_error=yes\nfi\n\nAC_LANG_PUSH(C++)\n_LT_TAGVAR(archive_cmds_need_lc, $1)=no\n_LT_TAGVAR(allow_undefined_flag, $1)=\n_LT_TAGVAR(always_export_symbols, $1)=no\n_LT_TAGVAR(archive_expsym_cmds, $1)=\n_LT_TAGVAR(compiler_needs_object, $1)=no\n_LT_TAGVAR(export_dynamic_flag_spec, $1)=\n_LT_TAGVAR(hardcode_direct, $1)=no\n_LT_TAGVAR(hardcode_direct_absolute, $1)=no\n_LT_TAGVAR(hardcode_libdir_flag_spec, $1)=\n_LT_TAGVAR(hardcode_libdir_separator, $1)=\n_LT_TAGVAR(hardcode_minus_L, $1)=no\n_LT_TAGVAR(hardcode_shlibpath_var, $1)=unsupported\n_LT_TAGVAR(hardcode_automatic, $1)=no\n_LT_TAGVAR(inherit_rpath, $1)=no\n_LT_TAGVAR(module_cmds, $1)=\n_LT_TAGVAR(module_expsym_cmds, $1)=\n_LT_TAGVAR(link_all_deplibs, $1)=unknown\n_LT_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds\n_LT_TAGVAR(reload_flag, $1)=$reload_flag\n_LT_TAGVAR(reload_cmds, $1)=$reload_cmds\n_LT_TAGVAR(no_undefined_flag, $1)=\n_LT_TAGVAR(whole_archive_flag_spec, $1)=\n_LT_TAGVAR(enable_shared_with_static_runtimes, $1)=no\n\n# Source file extension for C++ test sources.\nac_ext=cpp\n\n# Object file extension for compiled C++ test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# No sense in running all these tests if we already determined that\n# the CXX compiler isn't working.  Some variables (like enable_shared)\n# are currently assumed to apply to all compilers on this platform,\n# and will be corrupted by setting them based on a non-working compiler.\nif test yes != \"$_lt_caught_CXX_error\"; then\n  # Code to be used in simple compile tests\n  lt_simple_compile_test_code=\"int some_variable = 0;\"\n\n  # Code to be used in simple link tests\n  lt_simple_link_test_code='int main(int, char *[[]]) { return(0); }'\n\n  # ltmain only uses $CC for tagged configurations so make sure $CC is set.\n  _LT_TAG_COMPILER\n\n  # save warnings/boilerplate of simple test code\n  _LT_COMPILER_BOILERPLATE\n  _LT_LINKER_BOILERPLATE\n\n  # Allow CC to be a program name with arguments.\n  lt_save_CC=$CC\n  lt_save_CFLAGS=$CFLAGS\n  lt_save_LD=$LD\n  lt_save_GCC=$GCC\n  GCC=$GXX\n  lt_save_with_gnu_ld=$with_gnu_ld\n  lt_save_path_LD=$lt_cv_path_LD\n  if test -n \"${lt_cv_prog_gnu_ldcxx+set}\"; then\n    lt_cv_prog_gnu_ld=$lt_cv_prog_gnu_ldcxx\n  else\n    $as_unset lt_cv_prog_gnu_ld\n  fi\n  if test -n \"${lt_cv_path_LDCXX+set}\"; then\n    lt_cv_path_LD=$lt_cv_path_LDCXX\n  else\n    $as_unset lt_cv_path_LD\n  fi\n  test -z \"${LDCXX+set}\" || LD=$LDCXX\n  CC=${CXX-\"c++\"}\n  CFLAGS=$CXXFLAGS\n  compiler=$CC\n  _LT_TAGVAR(compiler, $1)=$CC\n  _LT_CC_BASENAME([$compiler])\n\n  if test -n \"$compiler\"; then\n    # We don't want -fno-exception when compiling C++ code, so set the\n    # no_builtin_flag separately\n    if test yes = \"$GXX\"; then\n      _LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=' -fno-builtin'\n    else\n      _LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)=\n    fi\n\n    if test yes = \"$GXX\"; then\n      # Set up default GNU C++ configuration\n\n      LT_PATH_LD\n\n      # Check if GNU C++ uses GNU ld as the underlying linker, since the\n      # archiving commands below assume that GNU ld is being used.\n      if test yes = \"$with_gnu_ld\"; then\n        _LT_TAGVAR(archive_cmds, $1)='$CC $pic_flag -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-soname $wl$soname -o $lib'\n        _LT_TAGVAR(archive_expsym_cmds, $1)='$CC $pic_flag -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-soname $wl$soname $wl-retain-symbols-file $wl$export_symbols -o $lib'\n\n        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath $wl$libdir'\n        _LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl--export-dynamic'\n\n        # If archive_cmds runs LD, not CC, wlarc should be empty\n        # XXX I think wlarc can be eliminated in ltcf-cxx, but I need to\n        #     investigate it a little bit more. (MM)\n        wlarc='$wl'\n\n        # ancient GNU ld didn't support --whole-archive et. al.\n        if eval \"`$CC -print-prog-name=ld` --help 2>&1\" |\n\t  $GREP 'no-whole-archive' > /dev/null; then\n          _LT_TAGVAR(whole_archive_flag_spec, $1)=$wlarc'--whole-archive$convenience '$wlarc'--no-whole-archive'\n        else\n          _LT_TAGVAR(whole_archive_flag_spec, $1)=\n        fi\n      else\n        with_gnu_ld=no\n        wlarc=\n\n        # A generic and very simple default shared library creation\n        # command for GNU C++ for the case where it uses the native\n        # linker, instead of GNU ld.  If possible, this setting should\n        # overridden to take advantage of the native linker features on\n        # the platform it is being used on.\n        _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $lib'\n      fi\n\n      # Commands to make compiler produce verbose output that lists\n      # what \"hidden\" libraries, object files and flags are used when\n      # linking a shared library.\n      output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP -v \"^Configured with:\" | $GREP \"\\-L\"'\n\n    else\n      GXX=no\n      with_gnu_ld=no\n      wlarc=\n    fi\n\n    # PORTME: fill in a description of your system's C++ link characteristics\n    AC_MSG_CHECKING([whether the $compiler linker ($LD) supports shared libraries])\n    _LT_TAGVAR(ld_shlibs, $1)=yes\n    case $host_os in\n      aix3*)\n        # FIXME: insert proper C++ library support\n        _LT_TAGVAR(ld_shlibs, $1)=no\n        ;;\n      aix[[4-9]]*)\n        if test ia64 = \"$host_cpu\"; then\n          # On IA64, the linker does run time linking by default, so we don't\n          # have to do anything special.\n          aix_use_runtimelinking=no\n          exp_sym_flag='-Bexport'\n          no_entry_flag=\n        else\n          aix_use_runtimelinking=no\n\n          # Test if we are trying to use run time linking or normal\n          # AIX style linking. If -brtl is somewhere in LDFLAGS, we\n          # have runtime linking enabled, and use it for executables.\n          # For shared libraries, we enable/disable runtime linking\n          # depending on the kind of the shared library created -\n          # when \"with_aix_soname,aix_use_runtimelinking\" is:\n          # \"aix,no\"   lib.a(lib.so.V) shared, rtl:no,  for executables\n          # \"aix,yes\"  lib.so          shared, rtl:yes, for executables\n          #            lib.a           static archive\n          # \"both,no\"  lib.so.V(shr.o) shared, rtl:yes\n          #            lib.a(lib.so.V) shared, rtl:no,  for executables\n          # \"both,yes\" lib.so.V(shr.o) shared, rtl:yes, for executables\n          #            lib.a(lib.so.V) shared, rtl:no\n          # \"svr4,*\"   lib.so.V(shr.o) shared, rtl:yes, for executables\n          #            lib.a           static archive\n          case $host_os in aix4.[[23]]|aix4.[[23]].*|aix[[5-9]]*)\n\t    for ld_flag in $LDFLAGS; do\n\t      case $ld_flag in\n\t      *-brtl*)\n\t        aix_use_runtimelinking=yes\n\t        break\n\t        ;;\n\t      esac\n\t    done\n\t    if test svr4,no = \"$with_aix_soname,$aix_use_runtimelinking\"; then\n\t      # With aix-soname=svr4, we create the lib.so.V shared archives only,\n\t      # so we don't have lib.a shared libs to link our executables.\n\t      # We have to force runtime linking in this case.\n\t      aix_use_runtimelinking=yes\n\t      LDFLAGS=\"$LDFLAGS -Wl,-brtl\"\n\t    fi\n\t    ;;\n          esac\n\n          exp_sym_flag='-bexport'\n          no_entry_flag='-bnoentry'\n        fi\n\n        # When large executables or shared objects are built, AIX ld can\n        # have problems creating the table of contents.  If linking a library\n        # or program results in \"error TOC overflow\" add -mminimal-toc to\n        # CXXFLAGS/CFLAGS for g++/gcc.  In the cases where that is not\n        # enough to fix the problem, add -Wl,-bbigtoc to LDFLAGS.\n\n        _LT_TAGVAR(archive_cmds, $1)=''\n        _LT_TAGVAR(hardcode_direct, $1)=yes\n        _LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n        _LT_TAGVAR(hardcode_libdir_separator, $1)=':'\n        _LT_TAGVAR(link_all_deplibs, $1)=yes\n        _LT_TAGVAR(file_list_spec, $1)='$wl-f,'\n        case $with_aix_soname,$aix_use_runtimelinking in\n        aix,*) ;;\t# no import file\n        svr4,* | *,yes) # use import file\n          # The Import File defines what to hardcode.\n          _LT_TAGVAR(hardcode_direct, $1)=no\n          _LT_TAGVAR(hardcode_direct_absolute, $1)=no\n          ;;\n        esac\n\n        if test yes = \"$GXX\"; then\n          case $host_os in aix4.[[012]]|aix4.[[012]].*)\n          # We only want to do this on AIX 4.2 and lower, the check\n          # below for broken collect2 doesn't work under 4.3+\n\t  collect2name=`$CC -print-prog-name=collect2`\n\t  if test -f \"$collect2name\" &&\n\t     strings \"$collect2name\" | $GREP resolve_lib_name >/dev/null\n\t  then\n\t    # We have reworked collect2\n\t    :\n\t  else\n\t    # We have old collect2\n\t    _LT_TAGVAR(hardcode_direct, $1)=unsupported\n\t    # It fails to find uninstalled libraries when the uninstalled\n\t    # path is not listed in the libpath.  Setting hardcode_minus_L\n\t    # to unsupported forces relinking\n\t    _LT_TAGVAR(hardcode_minus_L, $1)=yes\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n\t    _LT_TAGVAR(hardcode_libdir_separator, $1)=\n\t  fi\n          esac\n          shared_flag='-shared'\n\t  if test yes = \"$aix_use_runtimelinking\"; then\n\t    shared_flag=$shared_flag' $wl-G'\n\t  fi\n\t  # Need to ensure runtime linking is disabled for the traditional\n\t  # shared library, or the linker may eventually find shared libraries\n\t  # /with/ Import File - we do not want to mix them.\n\t  shared_flag_aix='-shared'\n\t  shared_flag_svr4='-shared $wl-G'\n        else\n          # not using gcc\n          if test ia64 = \"$host_cpu\"; then\n\t  # VisualAge C++, Version 5.5 for AIX 5L for IA-64, Beta 3 Release\n\t  # chokes on -Wl,-G. The following line is correct:\n\t  shared_flag='-G'\n          else\n\t    if test yes = \"$aix_use_runtimelinking\"; then\n\t      shared_flag='$wl-G'\n\t    else\n\t      shared_flag='$wl-bM:SRE'\n\t    fi\n\t    shared_flag_aix='$wl-bM:SRE'\n\t    shared_flag_svr4='$wl-G'\n          fi\n        fi\n\n        _LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl-bexpall'\n        # It seems that -bexpall does not export symbols beginning with\n        # underscore (_), so it is better to generate a list of symbols to\n\t# export.\n        _LT_TAGVAR(always_export_symbols, $1)=yes\n\tif test aix,yes = \"$with_aix_soname,$aix_use_runtimelinking\"; then\n          # Warning - without using the other runtime loading flags (-brtl),\n          # -berok will link without error, but may produce a broken library.\n          # The \"-G\" linker flag allows undefined symbols.\n          _LT_TAGVAR(no_undefined_flag, $1)='-bernotok'\n          # Determine the default libpath from the value encoded in an empty\n          # executable.\n          _LT_SYS_MODULE_PATH_AIX([$1])\n          _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-blibpath:$libdir:'\"$aix_libpath\"\n\n          _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -o $output_objdir/$soname $libobjs $deplibs $wl'$no_entry_flag' $compiler_flags `if test -n \"$allow_undefined_flag\"; then func_echo_all \"$wl$allow_undefined_flag\"; else :; fi` $wl'$exp_sym_flag:\\$export_symbols' '$shared_flag\n        else\n          if test ia64 = \"$host_cpu\"; then\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-R $libdir:/usr/lib:/lib'\n\t    _LT_TAGVAR(allow_undefined_flag, $1)=\"-z nodefs\"\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)=\"\\$CC $shared_flag\"' -o $output_objdir/$soname $libobjs $deplibs '\"\\$wl$no_entry_flag\"' $compiler_flags $wl$allow_undefined_flag '\"\\$wl$exp_sym_flag:\\$export_symbols\"\n          else\n\t    # Determine the default libpath from the value encoded in an\n\t    # empty executable.\n\t    _LT_SYS_MODULE_PATH_AIX([$1])\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-blibpath:$libdir:'\"$aix_libpath\"\n\t    # Warning - without using the other run time loading flags,\n\t    # -berok will link without error, but may produce a broken library.\n\t    _LT_TAGVAR(no_undefined_flag, $1)=' $wl-bernotok'\n\t    _LT_TAGVAR(allow_undefined_flag, $1)=' $wl-berok'\n\t    if test yes = \"$with_gnu_ld\"; then\n\t      # We only use this code for GNU lds that support --whole-archive.\n\t      _LT_TAGVAR(whole_archive_flag_spec, $1)='$wl--whole-archive$convenience $wl--no-whole-archive'\n\t    else\n\t      # Exported symbols can be pulled into shared objects from archives\n\t      _LT_TAGVAR(whole_archive_flag_spec, $1)='$convenience'\n\t    fi\n\t    _LT_TAGVAR(archive_cmds_need_lc, $1)=yes\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='$RM -r $output_objdir/$realname.d~$MKDIR $output_objdir/$realname.d'\n\t    # -brtl affects multiple linker settings, -berok does not and is overridden later\n\t    compiler_flags_filtered='`func_echo_all \"$compiler_flags \" | $SED -e \"s%-brtl\\\\([[, ]]\\\\)%-berok\\\\1%g\"`'\n\t    if test svr4 != \"$with_aix_soname\"; then\n\t      # This is similar to how AIX traditionally builds its shared\n\t      # libraries. Need -bnortl late, we may have -brtl in LDFLAGS.\n\t      _LT_TAGVAR(archive_expsym_cmds, $1)=\"$_LT_TAGVAR(archive_expsym_cmds, $1)\"'~$CC '$shared_flag_aix' -o $output_objdir/$realname.d/$soname $libobjs $deplibs $wl-bnoentry '$compiler_flags_filtered'$wl-bE:$export_symbols$allow_undefined_flag~$AR $AR_FLAGS $output_objdir/$libname$release.a $output_objdir/$realname.d/$soname'\n\t    fi\n\t    if test aix != \"$with_aix_soname\"; then\n\t      _LT_TAGVAR(archive_expsym_cmds, $1)=\"$_LT_TAGVAR(archive_expsym_cmds, $1)\"'~$CC '$shared_flag_svr4' -o $output_objdir/$realname.d/$shared_archive_member_spec.o $libobjs $deplibs $wl-bnoentry '$compiler_flags_filtered'$wl-bE:$export_symbols$allow_undefined_flag~$STRIP -e $output_objdir/$realname.d/$shared_archive_member_spec.o~( func_echo_all \"#! $soname($shared_archive_member_spec.o)\"; if test shr_64 = \"$shared_archive_member_spec\"; then func_echo_all \"# 64\"; else func_echo_all \"# 32\"; fi; cat $export_symbols ) > $output_objdir/$realname.d/$shared_archive_member_spec.imp~$AR $AR_FLAGS $output_objdir/$soname $output_objdir/$realname.d/$shared_archive_member_spec.o $output_objdir/$realname.d/$shared_archive_member_spec.imp'\n\t    else\n\t      # used by -dlpreopen to get the symbols\n\t      _LT_TAGVAR(archive_expsym_cmds, $1)=\"$_LT_TAGVAR(archive_expsym_cmds, $1)\"'~$MV  $output_objdir/$realname.d/$soname $output_objdir'\n\t    fi\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)=\"$_LT_TAGVAR(archive_expsym_cmds, $1)\"'~$RM -r $output_objdir/$realname.d'\n          fi\n        fi\n        ;;\n\n      beos*)\n\tif $LD --help 2>&1 | $GREP ': supported targets:.* elf' > /dev/null; then\n\t  _LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n\t  # Joseph Beckenbach <jrb3@best.com> says some releases of gcc\n\t  # support --undefined.  This deserves some investigation.  FIXME\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -nostart $libobjs $deplibs $compiler_flags $wl-soname $wl$soname -o $lib'\n\telse\n\t  _LT_TAGVAR(ld_shlibs, $1)=no\n\tfi\n\t;;\n\n      chorus*)\n        case $cc_basename in\n          *)\n\t  # FIXME: insert proper C++ library support\n\t  _LT_TAGVAR(ld_shlibs, $1)=no\n\t  ;;\n        esac\n        ;;\n\n      cygwin* | mingw* | pw32* | cegcc*)\n\tcase $GXX,$cc_basename in\n\t,cl* | no,cl*)\n\t  # Native MSVC\n\t  # hardcode_libdir_flag_spec is actually meaningless, as there is\n\t  # no search path for DLLs.\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)=' '\n\t  _LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n\t  _LT_TAGVAR(always_export_symbols, $1)=yes\n\t  _LT_TAGVAR(file_list_spec, $1)='@'\n\t  # Tell ltmain to make .lib files, not .a files.\n\t  libext=lib\n\t  # Tell ltmain to make .dll files, not .so files.\n\t  shrext_cmds=.dll\n\t  # FIXME: Setting linknames here is a bad hack.\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -o $output_objdir/$soname $libobjs $compiler_flags $deplibs -Wl,-DLL,-IMPLIB:\"$tool_output_objdir$libname.dll.lib\"~linknames='\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)='if _LT_DLL_DEF_P([$export_symbols]); then\n              cp \"$export_symbols\" \"$output_objdir/$soname.def\";\n              echo \"$tool_output_objdir$soname.def\" > \"$output_objdir/$soname.exp\";\n            else\n              $SED -e '\\''s/^/-link -EXPORT:/'\\'' < $export_symbols > $output_objdir/$soname.exp;\n            fi~\n            $CC -o $tool_output_objdir$soname $libobjs $compiler_flags $deplibs \"@$tool_output_objdir$soname.exp\" -Wl,-DLL,-IMPLIB:\"$tool_output_objdir$libname.dll.lib\"~\n            linknames='\n\t  # The linker will not automatically build a static lib if we build a DLL.\n\t  # _LT_TAGVAR(old_archive_from_new_cmds, $1)='true'\n\t  _LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes\n\t  # Don't use ranlib\n\t  _LT_TAGVAR(old_postinstall_cmds, $1)='chmod 644 $oldlib'\n\t  _LT_TAGVAR(postlink_cmds, $1)='lt_outputfile=\"@OUTPUT@\"~\n            lt_tool_outputfile=\"@TOOL_OUTPUT@\"~\n            case $lt_outputfile in\n              *.exe|*.EXE) ;;\n              *)\n                lt_outputfile=$lt_outputfile.exe\n                lt_tool_outputfile=$lt_tool_outputfile.exe\n                ;;\n            esac~\n            func_to_tool_file \"$lt_outputfile\"~\n            if test : != \"$MANIFEST_TOOL\" && test -f \"$lt_outputfile.manifest\"; then\n              $MANIFEST_TOOL -manifest \"$lt_tool_outputfile.manifest\" -outputresource:\"$lt_tool_outputfile\" || exit 1;\n              $RM \"$lt_outputfile.manifest\";\n            fi'\n\t  ;;\n\t*)\n\t  # g++\n\t  # _LT_TAGVAR(hardcode_libdir_flag_spec, $1) is actually meaningless,\n\t  # as there is no search path for DLLs.\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n\t  _LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl--export-all-symbols'\n\t  _LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n\t  _LT_TAGVAR(always_export_symbols, $1)=no\n\t  _LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes\n\n\t  if $LD --help 2>&1 | $GREP 'auto-import' > /dev/null; then\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $output_objdir/$soname $wl--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'\n\t    # If the export-symbols file already is a .def file, use it as\n\t    # is; otherwise, prepend EXPORTS...\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='if _LT_DLL_DEF_P([$export_symbols]); then\n              cp $export_symbols $output_objdir/$soname.def;\n            else\n              echo EXPORTS > $output_objdir/$soname.def;\n              cat $export_symbols >> $output_objdir/$soname.def;\n            fi~\n            $CC -shared -nostdlib $output_objdir/$soname.def $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $output_objdir/$soname $wl--enable-auto-image-base -Xlinker --out-implib -Xlinker $lib'\n\t  else\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t  fi\n\t  ;;\n\tesac\n\t;;\n      darwin* | rhapsody*)\n        _LT_DARWIN_LINKER_FEATURES($1)\n\t;;\n\n      os2*)\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-L$libdir'\n\t_LT_TAGVAR(hardcode_minus_L, $1)=yes\n\t_LT_TAGVAR(allow_undefined_flag, $1)=unsupported\n\tshrext_cmds=.dll\n\t_LT_TAGVAR(archive_cmds, $1)='$ECHO \"LIBRARY ${soname%$shared_ext} INITINSTANCE TERMINSTANCE\" > $output_objdir/$libname.def~\n\t  $ECHO \"DESCRIPTION \\\"$libname\\\"\" >> $output_objdir/$libname.def~\n\t  $ECHO \"DATA MULTIPLE NONSHARED\" >> $output_objdir/$libname.def~\n\t  $ECHO EXPORTS >> $output_objdir/$libname.def~\n\t  emxexp $libobjs | $SED /\"_DLL_InitTerm\"/d >> $output_objdir/$libname.def~\n\t  $CC -Zdll -Zcrtdll -o $output_objdir/$soname $libobjs $deplibs $compiler_flags $output_objdir/$libname.def~\n\t  emximp -o $lib $output_objdir/$libname.def'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='$ECHO \"LIBRARY ${soname%$shared_ext} INITINSTANCE TERMINSTANCE\" > $output_objdir/$libname.def~\n\t  $ECHO \"DESCRIPTION \\\"$libname\\\"\" >> $output_objdir/$libname.def~\n\t  $ECHO \"DATA MULTIPLE NONSHARED\" >> $output_objdir/$libname.def~\n\t  $ECHO EXPORTS >> $output_objdir/$libname.def~\n\t  prefix_cmds=\"$SED\"~\n\t  if test EXPORTS = \"`$SED 1q $export_symbols`\"; then\n\t    prefix_cmds=\"$prefix_cmds -e 1d\";\n\t  fi~\n\t  prefix_cmds=\"$prefix_cmds -e \\\"s/^\\(.*\\)$/_\\1/g\\\"\"~\n\t  cat $export_symbols | $prefix_cmds >> $output_objdir/$libname.def~\n\t  $CC -Zdll -Zcrtdll -o $output_objdir/$soname $libobjs $deplibs $compiler_flags $output_objdir/$libname.def~\n\t  emximp -o $lib $output_objdir/$libname.def'\n\t_LT_TAGVAR(old_archive_From_new_cmds, $1)='emximp -o $output_objdir/${libname}_dll.a $output_objdir/$libname.def'\n\t_LT_TAGVAR(enable_shared_with_static_runtimes, $1)=yes\n\t;;\n\n      dgux*)\n        case $cc_basename in\n          ec++*)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          ghcx*)\n\t    # Green Hills C++ Compiler\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          *)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n        esac\n        ;;\n\n      freebsd2.*)\n        # C++ shared libraries reported to be fairly broken before\n\t# switch to ELF\n        _LT_TAGVAR(ld_shlibs, $1)=no\n        ;;\n\n      freebsd-elf*)\n        _LT_TAGVAR(archive_cmds_need_lc, $1)=no\n        ;;\n\n      freebsd* | dragonfly*)\n        # FreeBSD 3 and later use GNU C++ and GNU ld with standard ELF\n        # conventions\n        _LT_TAGVAR(ld_shlibs, $1)=yes\n        ;;\n\n      haiku*)\n        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags $wl-soname $wl$soname -o $lib'\n        _LT_TAGVAR(link_all_deplibs, $1)=yes\n        ;;\n\n      hpux9*)\n        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl+b $wl$libdir'\n        _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n        _LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl-E'\n        _LT_TAGVAR(hardcode_direct, $1)=yes\n        _LT_TAGVAR(hardcode_minus_L, $1)=yes # Not in the search PATH,\n\t\t\t\t             # but as the default\n\t\t\t\t             # location of the library.\n\n        case $cc_basename in\n          CC*)\n            # FIXME: insert proper C++ library support\n            _LT_TAGVAR(ld_shlibs, $1)=no\n            ;;\n          aCC*)\n            _LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/$soname~$CC -b $wl+b $wl$install_libdir -o $output_objdir/$soname $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~test \"x$output_objdir/$soname\" = \"x$lib\" || mv $output_objdir/$soname $lib'\n            # Commands to make compiler produce verbose output that lists\n            # what \"hidden\" libraries, object files and flags are used when\n            # linking a shared library.\n            #\n            # There doesn't appear to be a way to prevent this compiler from\n            # explicitly linking system object files so we need to strip them\n            # from the output so that they don't get included in the library\n            # dependencies.\n            output_verbose_link_cmd='templist=`($CC -b $CFLAGS -v conftest.$objext 2>&1) | $EGREP \"\\-L\"`; list= ; for z in $templist; do case $z in conftest.$objext) list=\"$list $z\";; *.$objext);; *) list=\"$list $z\";;esac; done; func_echo_all \"$list\"'\n            ;;\n          *)\n            if test yes = \"$GXX\"; then\n              _LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/$soname~$CC -shared -nostdlib $pic_flag $wl+b $wl$install_libdir -o $output_objdir/$soname $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~test \"x$output_objdir/$soname\" = \"x$lib\" || mv $output_objdir/$soname $lib'\n            else\n              # FIXME: insert proper C++ library support\n              _LT_TAGVAR(ld_shlibs, $1)=no\n            fi\n            ;;\n        esac\n        ;;\n\n      hpux10*|hpux11*)\n        if test no = \"$with_gnu_ld\"; then\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl+b $wl$libdir'\n\t  _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\n          case $host_cpu in\n            hppa*64*|ia64*)\n              ;;\n            *)\n\t      _LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl-E'\n              ;;\n          esac\n        fi\n        case $host_cpu in\n          hppa*64*|ia64*)\n            _LT_TAGVAR(hardcode_direct, $1)=no\n            _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n            ;;\n          *)\n            _LT_TAGVAR(hardcode_direct, $1)=yes\n            _LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n            _LT_TAGVAR(hardcode_minus_L, $1)=yes # Not in the search PATH,\n\t\t\t\t\t         # but as the default\n\t\t\t\t\t         # location of the library.\n            ;;\n        esac\n\n        case $cc_basename in\n          CC*)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          aCC*)\n\t    case $host_cpu in\n\t      hppa*64*)\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -b $wl+h $wl$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t        ;;\n\t      ia64*)\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -b $wl+h $wl$soname $wl+nodefaultrpath -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t        ;;\n\t      *)\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -b $wl+h $wl$soname $wl+b $wl$install_libdir -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t        ;;\n\t    esac\n\t    # Commands to make compiler produce verbose output that lists\n\t    # what \"hidden\" libraries, object files and flags are used when\n\t    # linking a shared library.\n\t    #\n\t    # There doesn't appear to be a way to prevent this compiler from\n\t    # explicitly linking system object files so we need to strip them\n\t    # from the output so that they don't get included in the library\n\t    # dependencies.\n\t    output_verbose_link_cmd='templist=`($CC -b $CFLAGS -v conftest.$objext 2>&1) | $GREP \"\\-L\"`; list= ; for z in $templist; do case $z in conftest.$objext) list=\"$list $z\";; *.$objext);; *) list=\"$list $z\";;esac; done; func_echo_all \"$list\"'\n\t    ;;\n          *)\n\t    if test yes = \"$GXX\"; then\n\t      if test no = \"$with_gnu_ld\"; then\n\t        case $host_cpu in\n\t          hppa*64*)\n\t            _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib -fPIC $wl+h $wl$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t            ;;\n\t          ia64*)\n\t            _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $pic_flag $wl+h $wl$soname $wl+nodefaultrpath -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t            ;;\n\t          *)\n\t            _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $pic_flag $wl+h $wl$soname $wl+b $wl$install_libdir -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t            ;;\n\t        esac\n\t      fi\n\t    else\n\t      # FIXME: insert proper C++ library support\n\t      _LT_TAGVAR(ld_shlibs, $1)=no\n\t    fi\n\t    ;;\n        esac\n        ;;\n\n      interix[[3-9]]*)\n\t_LT_TAGVAR(hardcode_direct, $1)=no\n\t_LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath,$libdir'\n\t_LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl-E'\n\t# Hack: On Interix 3.x, we cannot compile PIC because of a broken gcc.\n\t# Instead, shared libraries are loaded at an image base (0x10000000 by\n\t# default) and relocated if they conflict, which is a slow very memory\n\t# consuming and fragmenting process.  To avoid this, we pick a random,\n\t# 256 KiB-aligned image base between 0x50000000 and 0x6FFC0000 at link\n\t# time.  Moving up from 0x10000000 also allows more sbrk(2) space.\n\t_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags $wl-h,$soname $wl--image-base,`expr ${RANDOM-$$} % 4096 / 2 \\* 262144 + 1342177280` -o $lib'\n\t_LT_TAGVAR(archive_expsym_cmds, $1)='sed \"s|^|_|\" $export_symbols >$output_objdir/$soname.expsym~$CC -shared $pic_flag $libobjs $deplibs $compiler_flags $wl-h,$soname $wl--retain-symbols-file,$output_objdir/$soname.expsym $wl--image-base,`expr ${RANDOM-$$} % 4096 / 2 \\* 262144 + 1342177280` -o $lib'\n\t;;\n      irix5* | irix6*)\n        case $cc_basename in\n          CC*)\n\t    # SGI C++\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -shared -all -multigot $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -soname $soname `test -n \"$verstring\" && func_echo_all \"-set_version $verstring\"` -update_registry $output_objdir/so_locations -o $lib'\n\n\t    # Archives containing C++ object files must be created using\n\t    # \"CC -ar\", where \"CC\" is the IRIX C++ compiler.  This is\n\t    # necessary to make sure instantiated templates are included\n\t    # in the archive.\n\t    _LT_TAGVAR(old_archive_cmds, $1)='$CC -ar -WR,-u -o $oldlib $oldobjs'\n\t    ;;\n          *)\n\t    if test yes = \"$GXX\"; then\n\t      if test no = \"$with_gnu_ld\"; then\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-soname $wl$soname `test -n \"$verstring\" && func_echo_all \"$wl-set_version $wl$verstring\"` $wl-update_registry $wl$output_objdir/so_locations -o $lib'\n\t      else\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-soname $wl$soname `test -n \"$verstring\" && func_echo_all \"$wl-set_version $wl$verstring\"` -o $lib'\n\t      fi\n\t    fi\n\t    _LT_TAGVAR(link_all_deplibs, $1)=yes\n\t    ;;\n        esac\n        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath $wl$libdir'\n        _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n        _LT_TAGVAR(inherit_rpath, $1)=yes\n        ;;\n\n      linux* | k*bsd*-gnu | kopensolaris*-gnu | gnu*)\n        case $cc_basename in\n          KCC*)\n\t    # Kuck and Associates, Inc. (KAI) C++ Compiler\n\n\t    # KCC will only create a shared library if the output file\n\t    # ends with \".so\" (or \".sl\" for HP-UX), so rename the library\n\t    # to its proper name (with version) after linking.\n\t    _LT_TAGVAR(archive_cmds, $1)='tempext=`echo $shared_ext | $SED -e '\\''s/\\([[^()0-9A-Za-z{}]]\\)/\\\\\\\\\\1/g'\\''`; templib=`echo $lib | $SED -e \"s/\\$tempext\\..*/.so/\"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \\$templib; mv \\$templib $lib'\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='tempext=`echo $shared_ext | $SED -e '\\''s/\\([[^()0-9A-Za-z{}]]\\)/\\\\\\\\\\1/g'\\''`; templib=`echo $lib | $SED -e \"s/\\$tempext\\..*/.so/\"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \\$templib $wl-retain-symbols-file,$export_symbols; mv \\$templib $lib'\n\t    # Commands to make compiler produce verbose output that lists\n\t    # what \"hidden\" libraries, object files and flags are used when\n\t    # linking a shared library.\n\t    #\n\t    # There doesn't appear to be a way to prevent this compiler from\n\t    # explicitly linking system object files so we need to strip them\n\t    # from the output so that they don't get included in the library\n\t    # dependencies.\n\t    output_verbose_link_cmd='templist=`$CC $CFLAGS -v conftest.$objext -o libconftest$shared_ext 2>&1 | $GREP \"ld\"`; rm -f libconftest$shared_ext; list= ; for z in $templist; do case $z in conftest.$objext) list=\"$list $z\";; *.$objext);; *) list=\"$list $z\";;esac; done; func_echo_all \"$list\"'\n\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath,$libdir'\n\t    _LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl--export-dynamic'\n\n\t    # Archives containing C++ object files must be created using\n\t    # \"CC -Bstatic\", where \"CC\" is the KAI C++ compiler.\n\t    _LT_TAGVAR(old_archive_cmds, $1)='$CC -Bstatic -o $oldlib $oldobjs'\n\t    ;;\n\t  icpc* | ecpc* )\n\t    # Intel C++\n\t    with_gnu_ld=yes\n\t    # version 8.0 and above of icpc choke on multiply defined symbols\n\t    # if we add $predep_objects and $postdep_objects, however 7.1 and\n\t    # earlier do not add the objects themselves.\n\t    case `$CC -V 2>&1` in\n\t      *\"Version 7.\"*)\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-soname $wl$soname -o $lib'\n\t\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-soname $wl$soname $wl-retain-symbols-file $wl$export_symbols -o $lib'\n\t\t;;\n\t      *)  # Version 8.0 or newer\n\t        tmp_idyn=\n\t        case $host_cpu in\n\t\t  ia64*) tmp_idyn=' -i_dynamic';;\n\t\tesac\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared'\"$tmp_idyn\"' $libobjs $deplibs $compiler_flags $wl-soname $wl$soname -o $lib'\n\t\t_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared'\"$tmp_idyn\"' $libobjs $deplibs $compiler_flags $wl-soname $wl$soname $wl-retain-symbols-file $wl$export_symbols -o $lib'\n\t\t;;\n\t    esac\n\t    _LT_TAGVAR(archive_cmds_need_lc, $1)=no\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath,$libdir'\n\t    _LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl--export-dynamic'\n\t    _LT_TAGVAR(whole_archive_flag_spec, $1)='$wl--whole-archive$convenience $wl--no-whole-archive'\n\t    ;;\n          pgCC* | pgcpp*)\n            # Portland Group C++ compiler\n\t    case `$CC -V` in\n\t    *pgCC\\ [[1-5]].* | *pgcpp\\ [[1-5]].*)\n\t      _LT_TAGVAR(prelink_cmds, $1)='tpldir=Template.dir~\n               rm -rf $tpldir~\n               $CC --prelink_objects --instantiation_dir $tpldir $objs $libobjs $compile_deplibs~\n               compile_command=\"$compile_command `find $tpldir -name \\*.o | sort | $NL2SP`\"'\n\t      _LT_TAGVAR(old_archive_cmds, $1)='tpldir=Template.dir~\n                rm -rf $tpldir~\n                $CC --prelink_objects --instantiation_dir $tpldir $oldobjs$old_deplibs~\n                $AR $AR_FLAGS $oldlib$oldobjs$old_deplibs `find $tpldir -name \\*.o | sort | $NL2SP`~\n                $RANLIB $oldlib'\n\t      _LT_TAGVAR(archive_cmds, $1)='tpldir=Template.dir~\n                rm -rf $tpldir~\n                $CC --prelink_objects --instantiation_dir $tpldir $predep_objects $libobjs $deplibs $convenience $postdep_objects~\n                $CC -shared $pic_flag $predep_objects $libobjs $deplibs `find $tpldir -name \\*.o | sort | $NL2SP` $postdep_objects $compiler_flags $wl-soname $wl$soname -o $lib'\n\t      _LT_TAGVAR(archive_expsym_cmds, $1)='tpldir=Template.dir~\n                rm -rf $tpldir~\n                $CC --prelink_objects --instantiation_dir $tpldir $predep_objects $libobjs $deplibs $convenience $postdep_objects~\n                $CC -shared $pic_flag $predep_objects $libobjs $deplibs `find $tpldir -name \\*.o | sort | $NL2SP` $postdep_objects $compiler_flags $wl-soname $wl$soname $wl-retain-symbols-file $wl$export_symbols -o $lib'\n\t      ;;\n\t    *) # Version 6 and above use weak symbols\n\t      _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-soname $wl$soname -o $lib'\n\t      _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-soname $wl$soname $wl-retain-symbols-file $wl$export_symbols -o $lib'\n\t      ;;\n\t    esac\n\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl--rpath $wl$libdir'\n\t    _LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl--export-dynamic'\n\t    _LT_TAGVAR(whole_archive_flag_spec, $1)='$wl--whole-archive`for conv in $convenience\\\"\\\"; do test  -n \\\"$conv\\\" && new_convenience=\\\"$new_convenience,$conv\\\"; done; func_echo_all \\\"$new_convenience\\\"` $wl--no-whole-archive'\n            ;;\n\t  cxx*)\n\t    # Compaq C++\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-soname $wl$soname -o $lib'\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-soname $wl$soname  -o $lib $wl-retain-symbols-file $wl$export_symbols'\n\n\t    runpath_var=LD_RUN_PATH\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-rpath $libdir'\n\t    _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\n\t    # Commands to make compiler produce verbose output that lists\n\t    # what \"hidden\" libraries, object files and flags are used when\n\t    # linking a shared library.\n\t    #\n\t    # There doesn't appear to be a way to prevent this compiler from\n\t    # explicitly linking system object files so we need to strip them\n\t    # from the output so that they don't get included in the library\n\t    # dependencies.\n\t    output_verbose_link_cmd='templist=`$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP \"ld\"`; templist=`func_echo_all \"$templist\" | $SED \"s/\\(^.*ld.*\\)\\( .*ld .*$\\)/\\1/\"`; list= ; for z in $templist; do case $z in conftest.$objext) list=\"$list $z\";; *.$objext);; *) list=\"$list $z\";;esac; done; func_echo_all \"X$list\" | $Xsed'\n\t    ;;\n\t  xl* | mpixl* | bgxl*)\n\t    # IBM XL 8.0 on PPC, with GNU ld\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath $wl$libdir'\n\t    _LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl--export-dynamic'\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -qmkshrobj $libobjs $deplibs $compiler_flags $wl-soname $wl$soname -o $lib'\n\t    if test yes = \"$supports_anon_versioning\"; then\n\t      _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $output_objdir/$libname.ver~\n                cat $export_symbols | sed -e \"s/\\(.*\\)/\\1;/\" >> $output_objdir/$libname.ver~\n                echo \"local: *; };\" >> $output_objdir/$libname.ver~\n                $CC -qmkshrobj $libobjs $deplibs $compiler_flags $wl-soname $wl$soname $wl-version-script $wl$output_objdir/$libname.ver -o $lib'\n\t    fi\n\t    ;;\n\t  *)\n\t    case `$CC -V 2>&1 | sed 5q` in\n\t    *Sun\\ C*)\n\t      # Sun C++ 5.9\n\t      _LT_TAGVAR(no_undefined_flag, $1)=' -zdefs'\n\t      _LT_TAGVAR(archive_cmds, $1)='$CC -G$allow_undefined_flag -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t      _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G$allow_undefined_flag -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-retain-symbols-file $wl$export_symbols'\n\t      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n\t      _LT_TAGVAR(whole_archive_flag_spec, $1)='$wl--whole-archive`new_convenience=; for conv in $convenience\\\"\\\"; do test -z \\\"$conv\\\" || new_convenience=\\\"$new_convenience,$conv\\\"; done; func_echo_all \\\"$new_convenience\\\"` $wl--no-whole-archive'\n\t      _LT_TAGVAR(compiler_needs_object, $1)=yes\n\n\t      # Not sure whether something based on\n\t      # $CC $CFLAGS -v conftest.$objext -o libconftest$shared_ext 2>&1\n\t      # would be better.\n\t      output_verbose_link_cmd='func_echo_all'\n\n\t      # Archives containing C++ object files must be created using\n\t      # \"CC -xar\", where \"CC\" is the Sun C++ compiler.  This is\n\t      # necessary to make sure instantiated templates are included\n\t      # in the archive.\n\t      _LT_TAGVAR(old_archive_cmds, $1)='$CC -xar -o $oldlib $oldobjs'\n\t      ;;\n\t    esac\n\t    ;;\n\tesac\n\t;;\n\n      lynxos*)\n        # FIXME: insert proper C++ library support\n\t_LT_TAGVAR(ld_shlibs, $1)=no\n\t;;\n\n      m88k*)\n        # FIXME: insert proper C++ library support\n        _LT_TAGVAR(ld_shlibs, $1)=no\n\t;;\n\n      mvs*)\n        case $cc_basename in\n          cxx*)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n\t  *)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n\tesac\n\t;;\n\n      netbsd*)\n        if echo __ELF__ | $CC -E - | $GREP __ELF__ >/dev/null; then\n\t  _LT_TAGVAR(archive_cmds, $1)='$LD -Bshareable  -o $lib $predep_objects $libobjs $deplibs $postdep_objects $linker_flags'\n\t  wlarc=\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n\t  _LT_TAGVAR(hardcode_direct, $1)=yes\n\t  _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\tfi\n\t# Workaround some broken pre-1.5 toolchains\n\toutput_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP conftest.$objext | $SED -e \"s:-lgcc -lc -lgcc::\"'\n\t;;\n\n      *nto* | *qnx*)\n        _LT_TAGVAR(ld_shlibs, $1)=yes\n\t;;\n\n      openbsd* | bitrig*)\n\tif test -f /usr/libexec/ld.so; then\n\t  _LT_TAGVAR(hardcode_direct, $1)=yes\n\t  _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\t  _LT_TAGVAR(hardcode_direct_absolute, $1)=yes\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -o $lib'\n\t  _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath,$libdir'\n\t  if test -z \"`echo __ELF__ | $CC -E - | grep __ELF__`\"; then\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-retain-symbols-file,$export_symbols -o $lib'\n\t    _LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl-E'\n\t    _LT_TAGVAR(whole_archive_flag_spec, $1)=$wlarc'--whole-archive$convenience '$wlarc'--no-whole-archive'\n\t  fi\n\t  output_verbose_link_cmd=func_echo_all\n\telse\n\t  _LT_TAGVAR(ld_shlibs, $1)=no\n\tfi\n\t;;\n\n      osf3* | osf4* | osf5*)\n        case $cc_basename in\n          KCC*)\n\t    # Kuck and Associates, Inc. (KAI) C++ Compiler\n\n\t    # KCC will only create a shared library if the output file\n\t    # ends with \".so\" (or \".sl\" for HP-UX), so rename the library\n\t    # to its proper name (with version) after linking.\n\t    _LT_TAGVAR(archive_cmds, $1)='tempext=`echo $shared_ext | $SED -e '\\''s/\\([[^()0-9A-Za-z{}]]\\)/\\\\\\\\\\1/g'\\''`; templib=`echo \"$lib\" | $SED -e \"s/\\$tempext\\..*/.so/\"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \\$templib; mv \\$templib $lib'\n\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath,$libdir'\n\t    _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\n\t    # Archives containing C++ object files must be created using\n\t    # the KAI C++ compiler.\n\t    case $host in\n\t      osf3*) _LT_TAGVAR(old_archive_cmds, $1)='$CC -Bstatic -o $oldlib $oldobjs' ;;\n\t      *) _LT_TAGVAR(old_archive_cmds, $1)='$CC -o $oldlib $oldobjs' ;;\n\t    esac\n\t    ;;\n          RCC*)\n\t    # Rational C++ 2.4.1\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          cxx*)\n\t    case $host in\n\t      osf3*)\n\t        _LT_TAGVAR(allow_undefined_flag, $1)=' $wl-expect_unresolved $wl\\*'\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared$allow_undefined_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-soname $soname `test -n \"$verstring\" && func_echo_all \"$wl-set_version $verstring\"` -update_registry $output_objdir/so_locations -o $lib'\n\t        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath $wl$libdir'\n\t\t;;\n\t      *)\n\t        _LT_TAGVAR(allow_undefined_flag, $1)=' -expect_unresolved \\*'\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared$allow_undefined_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -msym -soname $soname `test -n \"$verstring\" && func_echo_all \"-set_version $verstring\"` -update_registry $output_objdir/so_locations -o $lib'\n\t        _LT_TAGVAR(archive_expsym_cmds, $1)='for i in `cat $export_symbols`; do printf \"%s %s\\\\n\" -exported_symbol \"\\$i\" >> $lib.exp; done~\n                  echo \"-hidden\">> $lib.exp~\n                  $CC -shared$allow_undefined_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -msym -soname $soname $wl-input $wl$lib.exp  `test -n \"$verstring\" && $ECHO \"-set_version $verstring\"` -update_registry $output_objdir/so_locations -o $lib~\n                  $RM $lib.exp'\n\t        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-rpath $libdir'\n\t\t;;\n\t    esac\n\n\t    _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\n\t    # Commands to make compiler produce verbose output that lists\n\t    # what \"hidden\" libraries, object files and flags are used when\n\t    # linking a shared library.\n\t    #\n\t    # There doesn't appear to be a way to prevent this compiler from\n\t    # explicitly linking system object files so we need to strip them\n\t    # from the output so that they don't get included in the library\n\t    # dependencies.\n\t    output_verbose_link_cmd='templist=`$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP \"ld\" | $GREP -v \"ld:\"`; templist=`func_echo_all \"$templist\" | $SED \"s/\\(^.*ld.*\\)\\( .*ld.*$\\)/\\1/\"`; list= ; for z in $templist; do case $z in conftest.$objext) list=\"$list $z\";; *.$objext);; *) list=\"$list $z\";;esac; done; func_echo_all \"$list\"'\n\t    ;;\n\t  *)\n\t    if test yes,no = \"$GXX,$with_gnu_ld\"; then\n\t      _LT_TAGVAR(allow_undefined_flag, $1)=' $wl-expect_unresolved $wl\\*'\n\t      case $host in\n\t        osf3*)\n\t          _LT_TAGVAR(archive_cmds, $1)='$CC -shared -nostdlib $allow_undefined_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-soname $wl$soname `test -n \"$verstring\" && func_echo_all \"$wl-set_version $wl$verstring\"` $wl-update_registry $wl$output_objdir/so_locations -o $lib'\n\t\t  ;;\n\t        *)\n\t          _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -nostdlib $allow_undefined_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-msym $wl-soname $wl$soname `test -n \"$verstring\" && func_echo_all \"$wl-set_version $wl$verstring\"` $wl-update_registry $wl$output_objdir/so_locations -o $lib'\n\t\t  ;;\n\t      esac\n\n\t      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-rpath $wl$libdir'\n\t      _LT_TAGVAR(hardcode_libdir_separator, $1)=:\n\n\t      # Commands to make compiler produce verbose output that lists\n\t      # what \"hidden\" libraries, object files and flags are used when\n\t      # linking a shared library.\n\t      output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP -v \"^Configured with:\" | $GREP \"\\-L\"'\n\n\t    else\n\t      # FIXME: insert proper C++ library support\n\t      _LT_TAGVAR(ld_shlibs, $1)=no\n\t    fi\n\t    ;;\n        esac\n        ;;\n\n      psos*)\n        # FIXME: insert proper C++ library support\n        _LT_TAGVAR(ld_shlibs, $1)=no\n        ;;\n\n      sunos4*)\n        case $cc_basename in\n          CC*)\n\t    # Sun C++ 4.x\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          lcc*)\n\t    # Lucid\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          *)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n        esac\n        ;;\n\n      solaris*)\n        case $cc_basename in\n          CC* | sunCC*)\n\t    # Sun C++ 4.2, 5.x and Centerline C++\n            _LT_TAGVAR(archive_cmds_need_lc,$1)=yes\n\t    _LT_TAGVAR(no_undefined_flag, $1)=' -zdefs'\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -G$allow_undefined_flag -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags'\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $lib.exp~cat $export_symbols | $SED -e \"s/\\(.*\\)/\\1;/\" >> $lib.exp~echo \"local: *; };\" >> $lib.exp~\n              $CC -G$allow_undefined_flag $wl-M $wl$lib.exp -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$RM $lib.exp'\n\n\t    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='-R$libdir'\n\t    _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\t    case $host_os in\n\t      solaris2.[[0-5]] | solaris2.[[0-5]].*) ;;\n\t      *)\n\t\t# The compiler driver will combine and reorder linker options,\n\t\t# but understands '-z linker_flag'.\n\t        # Supported since Solaris 2.6 (maybe 2.5.1?)\n\t\t_LT_TAGVAR(whole_archive_flag_spec, $1)='-z allextract$convenience -z defaultextract'\n\t        ;;\n\t    esac\n\t    _LT_TAGVAR(link_all_deplibs, $1)=yes\n\n\t    output_verbose_link_cmd='func_echo_all'\n\n\t    # Archives containing C++ object files must be created using\n\t    # \"CC -xar\", where \"CC\" is the Sun C++ compiler.  This is\n\t    # necessary to make sure instantiated templates are included\n\t    # in the archive.\n\t    _LT_TAGVAR(old_archive_cmds, $1)='$CC -xar -o $oldlib $oldobjs'\n\t    ;;\n          gcx*)\n\t    # Green Hills C++ Compiler\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-h $wl$soname -o $lib'\n\n\t    # The C++ compiler must be used to create the archive.\n\t    _LT_TAGVAR(old_archive_cmds, $1)='$CC $LDFLAGS -archive -o $oldlib $oldobjs'\n\t    ;;\n          *)\n\t    # GNU C++ compiler with Solaris linker\n\t    if test yes,no = \"$GXX,$with_gnu_ld\"; then\n\t      _LT_TAGVAR(no_undefined_flag, $1)=' $wl-z ${wl}defs'\n\t      if $CC --version | $GREP -v '^2\\.7' > /dev/null; then\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-h $wl$soname -o $lib'\n\t        _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $lib.exp~cat $export_symbols | $SED -e \"s/\\(.*\\)/\\1;/\" >> $lib.exp~echo \"local: *; };\" >> $lib.exp~\n                  $CC -shared $pic_flag -nostdlib $wl-M $wl$lib.exp $wl-h $wl$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$RM $lib.exp'\n\n\t        # Commands to make compiler produce verbose output that lists\n\t        # what \"hidden\" libraries, object files and flags are used when\n\t        # linking a shared library.\n\t        output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP -v \"^Configured with:\" | $GREP \"\\-L\"'\n\t      else\n\t        # g++ 2.7 appears to require '-G' NOT '-shared' on this\n\t        # platform.\n\t        _LT_TAGVAR(archive_cmds, $1)='$CC -G -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags $wl-h $wl$soname -o $lib'\n\t        _LT_TAGVAR(archive_expsym_cmds, $1)='echo \"{ global:\" > $lib.exp~cat $export_symbols | $SED -e \"s/\\(.*\\)/\\1;/\" >> $lib.exp~echo \"local: *; };\" >> $lib.exp~\n                  $CC -G -nostdlib $wl-M $wl$lib.exp $wl-h $wl$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$RM $lib.exp'\n\n\t        # Commands to make compiler produce verbose output that lists\n\t        # what \"hidden\" libraries, object files and flags are used when\n\t        # linking a shared library.\n\t        output_verbose_link_cmd='$CC -G $CFLAGS -v conftest.$objext 2>&1 | $GREP -v \"^Configured with:\" | $GREP \"\\-L\"'\n\t      fi\n\n\t      _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-R $wl$libdir'\n\t      case $host_os in\n\t\tsolaris2.[[0-5]] | solaris2.[[0-5]].*) ;;\n\t\t*)\n\t\t  _LT_TAGVAR(whole_archive_flag_spec, $1)='$wl-z ${wl}allextract$convenience $wl-z ${wl}defaultextract'\n\t\t  ;;\n\t      esac\n\t    fi\n\t    ;;\n        esac\n        ;;\n\n    sysv4*uw2* | sysv5OpenUNIX* | sysv5UnixWare7.[[01]].[[10]]* | unixware7* | sco3.2v5.0.[[024]]*)\n      _LT_TAGVAR(no_undefined_flag, $1)='$wl-z,text'\n      _LT_TAGVAR(archive_cmds_need_lc, $1)=no\n      _LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n      runpath_var='LD_RUN_PATH'\n\n      case $cc_basename in\n        CC*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -G $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G $wl-Bexport:$export_symbols $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n\t*)\n\t  _LT_TAGVAR(archive_cmds, $1)='$CC -shared $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $wl-Bexport:$export_symbols $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t  ;;\n      esac\n      ;;\n\n      sysv5* | sco3.2v5* | sco5v6*)\n\t# Note: We CANNOT use -z defs as we might desire, because we do not\n\t# link with -lc, and that would cause any symbols used from libc to\n\t# always be unresolved, which means just about no library would\n\t# ever link correctly.  If we're not using GNU ld we use -z text\n\t# though, which does catch some bad symbols but isn't as heavy-handed\n\t# as -z defs.\n\t_LT_TAGVAR(no_undefined_flag, $1)='$wl-z,text'\n\t_LT_TAGVAR(allow_undefined_flag, $1)='$wl-z,nodefs'\n\t_LT_TAGVAR(archive_cmds_need_lc, $1)=no\n\t_LT_TAGVAR(hardcode_shlibpath_var, $1)=no\n\t_LT_TAGVAR(hardcode_libdir_flag_spec, $1)='$wl-R,$libdir'\n\t_LT_TAGVAR(hardcode_libdir_separator, $1)=':'\n\t_LT_TAGVAR(link_all_deplibs, $1)=yes\n\t_LT_TAGVAR(export_dynamic_flag_spec, $1)='$wl-Bexport'\n\trunpath_var='LD_RUN_PATH'\n\n\tcase $cc_basename in\n          CC*)\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -G $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G $wl-Bexport:$export_symbols $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t    _LT_TAGVAR(old_archive_cmds, $1)='$CC -Tprelink_objects $oldobjs~\n              '\"$_LT_TAGVAR(old_archive_cmds, $1)\"\n\t    _LT_TAGVAR(reload_cmds, $1)='$CC -Tprelink_objects $reload_objs~\n              '\"$_LT_TAGVAR(reload_cmds, $1)\"\n\t    ;;\n\t  *)\n\t    _LT_TAGVAR(archive_cmds, $1)='$CC -shared $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $wl-Bexport:$export_symbols $wl-h,$soname -o $lib $libobjs $deplibs $compiler_flags'\n\t    ;;\n\tesac\n      ;;\n\n      tandem*)\n        case $cc_basename in\n          NCC*)\n\t    # NonStop-UX NCC 3.20\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n          *)\n\t    # FIXME: insert proper C++ library support\n\t    _LT_TAGVAR(ld_shlibs, $1)=no\n\t    ;;\n        esac\n        ;;\n\n      vxworks*)\n        # FIXME: insert proper C++ library support\n        _LT_TAGVAR(ld_shlibs, $1)=no\n        ;;\n\n      *)\n        # FIXME: insert proper C++ library support\n        _LT_TAGVAR(ld_shlibs, $1)=no\n        ;;\n    esac\n\n    AC_MSG_RESULT([$_LT_TAGVAR(ld_shlibs, $1)])\n    test no = \"$_LT_TAGVAR(ld_shlibs, $1)\" && can_build_shared=no\n\n    _LT_TAGVAR(GCC, $1)=$GXX\n    _LT_TAGVAR(LD, $1)=$LD\n\n    ## CAVEAT EMPTOR:\n    ## There is no encapsulation within the following macros, do not change\n    ## the running order or otherwise move them around unless you know exactly\n    ## what you are doing...\n    _LT_SYS_HIDDEN_LIBDEPS($1)\n    _LT_COMPILER_PIC($1)\n    _LT_COMPILER_C_O($1)\n    _LT_COMPILER_FILE_LOCKS($1)\n    _LT_LINKER_SHLIBS($1)\n    _LT_SYS_DYNAMIC_LINKER($1)\n    _LT_LINKER_HARDCODE_LIBPATH($1)\n\n    _LT_CONFIG($1)\n  fi # test -n \"$compiler\"\n\n  CC=$lt_save_CC\n  CFLAGS=$lt_save_CFLAGS\n  LDCXX=$LD\n  LD=$lt_save_LD\n  GCC=$lt_save_GCC\n  with_gnu_ld=$lt_save_with_gnu_ld\n  lt_cv_path_LDCXX=$lt_cv_path_LD\n  lt_cv_path_LD=$lt_save_path_LD\n  lt_cv_prog_gnu_ldcxx=$lt_cv_prog_gnu_ld\n  lt_cv_prog_gnu_ld=$lt_save_with_gnu_ld\nfi # test yes != \"$_lt_caught_CXX_error\"\n\nAC_LANG_POP\n])# _LT_LANG_CXX_CONFIG\n\n\n# _LT_FUNC_STRIPNAME_CNF\n# ----------------------\n# func_stripname_cnf prefix suffix name\n# strip PREFIX and SUFFIX off of NAME.\n# PREFIX and SUFFIX must not contain globbing or regex special\n# characters, hashes, percent signs, but SUFFIX may contain a leading\n# dot (in which case that matches only a dot).\n#\n# This function is identical to the (non-XSI) version of func_stripname,\n# except this one can be used by m4 code that may be executed by configure,\n# rather than the libtool script.\nm4_defun([_LT_FUNC_STRIPNAME_CNF],[dnl\nAC_REQUIRE([_LT_DECL_SED])\nAC_REQUIRE([_LT_PROG_ECHO_BACKSLASH])\nfunc_stripname_cnf ()\n{\n  case @S|@2 in\n  .*) func_stripname_result=`$ECHO \"@S|@3\" | $SED \"s%^@S|@1%%; s%\\\\\\\\@S|@2\\$%%\"`;;\n  *)  func_stripname_result=`$ECHO \"@S|@3\" | $SED \"s%^@S|@1%%; s%@S|@2\\$%%\"`;;\n  esac\n} # func_stripname_cnf\n])# _LT_FUNC_STRIPNAME_CNF\n\n\n# _LT_SYS_HIDDEN_LIBDEPS([TAGNAME])\n# ---------------------------------\n# Figure out \"hidden\" library dependencies from verbose\n# compiler output when linking a shared library.\n# Parse the compiler output and extract the necessary\n# objects, libraries and library flags.\nm4_defun([_LT_SYS_HIDDEN_LIBDEPS],\n[m4_require([_LT_FILEUTILS_DEFAULTS])dnl\nAC_REQUIRE([_LT_FUNC_STRIPNAME_CNF])dnl\n# Dependencies to place before and after the object being linked:\n_LT_TAGVAR(predep_objects, $1)=\n_LT_TAGVAR(postdep_objects, $1)=\n_LT_TAGVAR(predeps, $1)=\n_LT_TAGVAR(postdeps, $1)=\n_LT_TAGVAR(compiler_lib_search_path, $1)=\n\ndnl we can't use the lt_simple_compile_test_code here,\ndnl because it contains code intended for an executable,\ndnl not a library.  It's possible we should let each\ndnl tag define a new lt_????_link_test_code variable,\ndnl but it's only used here...\nm4_if([$1], [], [cat > conftest.$ac_ext <<_LT_EOF\nint a;\nvoid foo (void) { a = 0; }\n_LT_EOF\n], [$1], [CXX], [cat > conftest.$ac_ext <<_LT_EOF\nclass Foo\n{\npublic:\n  Foo (void) { a = 0; }\nprivate:\n  int a;\n};\n_LT_EOF\n], [$1], [F77], [cat > conftest.$ac_ext <<_LT_EOF\n      subroutine foo\n      implicit none\n      integer*4 a\n      a=0\n      return\n      end\n_LT_EOF\n], [$1], [FC], [cat > conftest.$ac_ext <<_LT_EOF\n      subroutine foo\n      implicit none\n      integer a\n      a=0\n      return\n      end\n_LT_EOF\n], [$1], [GCJ], [cat > conftest.$ac_ext <<_LT_EOF\npublic class foo {\n  private int a;\n  public void bar (void) {\n    a = 0;\n  }\n};\n_LT_EOF\n], [$1], [GO], [cat > conftest.$ac_ext <<_LT_EOF\npackage foo\nfunc foo() {\n}\n_LT_EOF\n])\n\n_lt_libdeps_save_CFLAGS=$CFLAGS\ncase \"$CC $CFLAGS \" in #(\n*\\ -flto*\\ *) CFLAGS=\"$CFLAGS -fno-lto\" ;;\n*\\ -fwhopr*\\ *) CFLAGS=\"$CFLAGS -fno-whopr\" ;;\n*\\ -fuse-linker-plugin*\\ *) CFLAGS=\"$CFLAGS -fno-use-linker-plugin\" ;;\nesac\n\ndnl Parse the compiler output and extract the necessary\ndnl objects, libraries and library flags.\nif AC_TRY_EVAL(ac_compile); then\n  # Parse the compiler output and extract the necessary\n  # objects, libraries and library flags.\n\n  # Sentinel used to keep track of whether or not we are before\n  # the conftest object file.\n  pre_test_object_deps_done=no\n\n  for p in `eval \"$output_verbose_link_cmd\"`; do\n    case $prev$p in\n\n    -L* | -R* | -l*)\n       # Some compilers place space between \"-{L,R}\" and the path.\n       # Remove the space.\n       if test x-L = \"$p\" ||\n          test x-R = \"$p\"; then\n\t prev=$p\n\t continue\n       fi\n\n       # Expand the sysroot to ease extracting the directories later.\n       if test -z \"$prev\"; then\n         case $p in\n         -L*) func_stripname_cnf '-L' '' \"$p\"; prev=-L; p=$func_stripname_result ;;\n         -R*) func_stripname_cnf '-R' '' \"$p\"; prev=-R; p=$func_stripname_result ;;\n         -l*) func_stripname_cnf '-l' '' \"$p\"; prev=-l; p=$func_stripname_result ;;\n         esac\n       fi\n       case $p in\n       =*) func_stripname_cnf '=' '' \"$p\"; p=$lt_sysroot$func_stripname_result ;;\n       esac\n       if test no = \"$pre_test_object_deps_done\"; then\n\t case $prev in\n\t -L | -R)\n\t   # Internal compiler library paths should come after those\n\t   # provided the user.  The postdeps already come after the\n\t   # user supplied libs so there is no need to process them.\n\t   if test -z \"$_LT_TAGVAR(compiler_lib_search_path, $1)\"; then\n\t     _LT_TAGVAR(compiler_lib_search_path, $1)=$prev$p\n\t   else\n\t     _LT_TAGVAR(compiler_lib_search_path, $1)=\"${_LT_TAGVAR(compiler_lib_search_path, $1)} $prev$p\"\n\t   fi\n\t   ;;\n\t # The \"-l\" case would never come before the object being\n\t # linked, so don't bother handling this case.\n\t esac\n       else\n\t if test -z \"$_LT_TAGVAR(postdeps, $1)\"; then\n\t   _LT_TAGVAR(postdeps, $1)=$prev$p\n\t else\n\t   _LT_TAGVAR(postdeps, $1)=\"${_LT_TAGVAR(postdeps, $1)} $prev$p\"\n\t fi\n       fi\n       prev=\n       ;;\n\n    *.lto.$objext) ;; # Ignore GCC LTO objects\n    *.$objext)\n       # This assumes that the test object file only shows up\n       # once in the compiler output.\n       if test \"$p\" = \"conftest.$objext\"; then\n\t pre_test_object_deps_done=yes\n\t continue\n       fi\n\n       if test no = \"$pre_test_object_deps_done\"; then\n\t if test -z \"$_LT_TAGVAR(predep_objects, $1)\"; then\n\t   _LT_TAGVAR(predep_objects, $1)=$p\n\t else\n\t   _LT_TAGVAR(predep_objects, $1)=\"$_LT_TAGVAR(predep_objects, $1) $p\"\n\t fi\n       else\n\t if test -z \"$_LT_TAGVAR(postdep_objects, $1)\"; then\n\t   _LT_TAGVAR(postdep_objects, $1)=$p\n\t else\n\t   _LT_TAGVAR(postdep_objects, $1)=\"$_LT_TAGVAR(postdep_objects, $1) $p\"\n\t fi\n       fi\n       ;;\n\n    *) ;; # Ignore the rest.\n\n    esac\n  done\n\n  # Clean up.\n  rm -f a.out a.exe\nelse\n  echo \"libtool.m4: error: problem compiling $1 test program\"\nfi\n\n$RM -f confest.$objext\nCFLAGS=$_lt_libdeps_save_CFLAGS\n\n# PORTME: override above test on systems where it is broken\nm4_if([$1], [CXX],\n[case $host_os in\ninterix[[3-9]]*)\n  # Interix 3.5 installs completely hosed .la files for C++, so rather than\n  # hack all around it, let's just trust \"g++\" to DTRT.\n  _LT_TAGVAR(predep_objects,$1)=\n  _LT_TAGVAR(postdep_objects,$1)=\n  _LT_TAGVAR(postdeps,$1)=\n  ;;\nesac\n])\n\ncase \" $_LT_TAGVAR(postdeps, $1) \" in\n*\" -lc \"*) _LT_TAGVAR(archive_cmds_need_lc, $1)=no ;;\nesac\n _LT_TAGVAR(compiler_lib_search_dirs, $1)=\nif test -n \"${_LT_TAGVAR(compiler_lib_search_path, $1)}\"; then\n _LT_TAGVAR(compiler_lib_search_dirs, $1)=`echo \" ${_LT_TAGVAR(compiler_lib_search_path, $1)}\" | $SED -e 's! -L! !g' -e 's!^ !!'`\nfi\n_LT_TAGDECL([], [compiler_lib_search_dirs], [1],\n    [The directories searched by this compiler when creating a shared library])\n_LT_TAGDECL([], [predep_objects], [1],\n    [Dependencies to place before and after the objects being linked to\n    create a shared library])\n_LT_TAGDECL([], [postdep_objects], [1])\n_LT_TAGDECL([], [predeps], [1])\n_LT_TAGDECL([], [postdeps], [1])\n_LT_TAGDECL([], [compiler_lib_search_path], [1],\n    [The library search path used internally by the compiler when linking\n    a shared library])\n])# _LT_SYS_HIDDEN_LIBDEPS\n\n\n# _LT_LANG_F77_CONFIG([TAG])\n# --------------------------\n# Ensure that the configuration variables for a Fortran 77 compiler are\n# suitably defined.  These variables are subsequently used by _LT_CONFIG\n# to write the compiler configuration to 'libtool'.\nm4_defun([_LT_LANG_F77_CONFIG],\n[AC_LANG_PUSH(Fortran 77)\nif test -z \"$F77\" || test no = \"$F77\"; then\n  _lt_disable_F77=yes\nfi\n\n_LT_TAGVAR(archive_cmds_need_lc, $1)=no\n_LT_TAGVAR(allow_undefined_flag, $1)=\n_LT_TAGVAR(always_export_symbols, $1)=no\n_LT_TAGVAR(archive_expsym_cmds, $1)=\n_LT_TAGVAR(export_dynamic_flag_spec, $1)=\n_LT_TAGVAR(hardcode_direct, $1)=no\n_LT_TAGVAR(hardcode_direct_absolute, $1)=no\n_LT_TAGVAR(hardcode_libdir_flag_spec, $1)=\n_LT_TAGVAR(hardcode_libdir_separator, $1)=\n_LT_TAGVAR(hardcode_minus_L, $1)=no\n_LT_TAGVAR(hardcode_automatic, $1)=no\n_LT_TAGVAR(inherit_rpath, $1)=no\n_LT_TAGVAR(module_cmds, $1)=\n_LT_TAGVAR(module_expsym_cmds, $1)=\n_LT_TAGVAR(link_all_deplibs, $1)=unknown\n_LT_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds\n_LT_TAGVAR(reload_flag, $1)=$reload_flag\n_LT_TAGVAR(reload_cmds, $1)=$reload_cmds\n_LT_TAGVAR(no_undefined_flag, $1)=\n_LT_TAGVAR(whole_archive_flag_spec, $1)=\n_LT_TAGVAR(enable_shared_with_static_runtimes, $1)=no\n\n# Source file extension for f77 test sources.\nac_ext=f\n\n# Object file extension for compiled f77 test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# No sense in running all these tests if we already determined that\n# the F77 compiler isn't working.  Some variables (like enable_shared)\n# are currently assumed to apply to all compilers on this platform,\n# and will be corrupted by setting them based on a non-working compiler.\nif test yes != \"$_lt_disable_F77\"; then\n  # Code to be used in simple compile tests\n  lt_simple_compile_test_code=\"\\\n      subroutine t\n      return\n      end\n\"\n\n  # Code to be used in simple link tests\n  lt_simple_link_test_code=\"\\\n      program t\n      end\n\"\n\n  # ltmain only uses $CC for tagged configurations so make sure $CC is set.\n  _LT_TAG_COMPILER\n\n  # save warnings/boilerplate of simple test code\n  _LT_COMPILER_BOILERPLATE\n  _LT_LINKER_BOILERPLATE\n\n  # Allow CC to be a program name with arguments.\n  lt_save_CC=$CC\n  lt_save_GCC=$GCC\n  lt_save_CFLAGS=$CFLAGS\n  CC=${F77-\"f77\"}\n  CFLAGS=$FFLAGS\n  compiler=$CC\n  _LT_TAGVAR(compiler, $1)=$CC\n  _LT_CC_BASENAME([$compiler])\n  GCC=$G77\n  if test -n \"$compiler\"; then\n    AC_MSG_CHECKING([if libtool supports shared libraries])\n    AC_MSG_RESULT([$can_build_shared])\n\n    AC_MSG_CHECKING([whether to build shared libraries])\n    test no = \"$can_build_shared\" && enable_shared=no\n\n    # On AIX, shared libraries and static libraries use the same namespace, and\n    # are all built from PIC.\n    case $host_os in\n      aix3*)\n        test yes = \"$enable_shared\" && enable_static=no\n        if test -n \"$RANLIB\"; then\n          archive_cmds=\"$archive_cmds~\\$RANLIB \\$lib\"\n          postinstall_cmds='$RANLIB $lib'\n        fi\n        ;;\n      aix[[4-9]]*)\n\tif test ia64 != \"$host_cpu\"; then\n\t  case $enable_shared,$with_aix_soname,$aix_use_runtimelinking in\n\t  yes,aix,yes) ;;\t\t# shared object as lib.so file only\n\t  yes,svr4,*) ;;\t\t# shared object as lib.so archive member only\n\t  yes,*) enable_static=no ;;\t# shared object in lib.a archive as well\n\t  esac\n\tfi\n        ;;\n    esac\n    AC_MSG_RESULT([$enable_shared])\n\n    AC_MSG_CHECKING([whether to build static libraries])\n    # Make sure either enable_shared or enable_static is yes.\n    test yes = \"$enable_shared\" || enable_static=yes\n    AC_MSG_RESULT([$enable_static])\n\n    _LT_TAGVAR(GCC, $1)=$G77\n    _LT_TAGVAR(LD, $1)=$LD\n\n    ## CAVEAT EMPTOR:\n    ## There is no encapsulation within the following macros, do not change\n    ## the running order or otherwise move them around unless you know exactly\n    ## what you are doing...\n    _LT_COMPILER_PIC($1)\n    _LT_COMPILER_C_O($1)\n    _LT_COMPILER_FILE_LOCKS($1)\n    _LT_LINKER_SHLIBS($1)\n    _LT_SYS_DYNAMIC_LINKER($1)\n    _LT_LINKER_HARDCODE_LIBPATH($1)\n\n    _LT_CONFIG($1)\n  fi # test -n \"$compiler\"\n\n  GCC=$lt_save_GCC\n  CC=$lt_save_CC\n  CFLAGS=$lt_save_CFLAGS\nfi # test yes != \"$_lt_disable_F77\"\n\nAC_LANG_POP\n])# _LT_LANG_F77_CONFIG\n\n\n# _LT_LANG_FC_CONFIG([TAG])\n# -------------------------\n# Ensure that the configuration variables for a Fortran compiler are\n# suitably defined.  These variables are subsequently used by _LT_CONFIG\n# to write the compiler configuration to 'libtool'.\nm4_defun([_LT_LANG_FC_CONFIG],\n[AC_LANG_PUSH(Fortran)\n\nif test -z \"$FC\" || test no = \"$FC\"; then\n  _lt_disable_FC=yes\nfi\n\n_LT_TAGVAR(archive_cmds_need_lc, $1)=no\n_LT_TAGVAR(allow_undefined_flag, $1)=\n_LT_TAGVAR(always_export_symbols, $1)=no\n_LT_TAGVAR(archive_expsym_cmds, $1)=\n_LT_TAGVAR(export_dynamic_flag_spec, $1)=\n_LT_TAGVAR(hardcode_direct, $1)=no\n_LT_TAGVAR(hardcode_direct_absolute, $1)=no\n_LT_TAGVAR(hardcode_libdir_flag_spec, $1)=\n_LT_TAGVAR(hardcode_libdir_separator, $1)=\n_LT_TAGVAR(hardcode_minus_L, $1)=no\n_LT_TAGVAR(hardcode_automatic, $1)=no\n_LT_TAGVAR(inherit_rpath, $1)=no\n_LT_TAGVAR(module_cmds, $1)=\n_LT_TAGVAR(module_expsym_cmds, $1)=\n_LT_TAGVAR(link_all_deplibs, $1)=unknown\n_LT_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds\n_LT_TAGVAR(reload_flag, $1)=$reload_flag\n_LT_TAGVAR(reload_cmds, $1)=$reload_cmds\n_LT_TAGVAR(no_undefined_flag, $1)=\n_LT_TAGVAR(whole_archive_flag_spec, $1)=\n_LT_TAGVAR(enable_shared_with_static_runtimes, $1)=no\n\n# Source file extension for fc test sources.\nac_ext=${ac_fc_srcext-f}\n\n# Object file extension for compiled fc test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# No sense in running all these tests if we already determined that\n# the FC compiler isn't working.  Some variables (like enable_shared)\n# are currently assumed to apply to all compilers on this platform,\n# and will be corrupted by setting them based on a non-working compiler.\nif test yes != \"$_lt_disable_FC\"; then\n  # Code to be used in simple compile tests\n  lt_simple_compile_test_code=\"\\\n      subroutine t\n      return\n      end\n\"\n\n  # Code to be used in simple link tests\n  lt_simple_link_test_code=\"\\\n      program t\n      end\n\"\n\n  # ltmain only uses $CC for tagged configurations so make sure $CC is set.\n  _LT_TAG_COMPILER\n\n  # save warnings/boilerplate of simple test code\n  _LT_COMPILER_BOILERPLATE\n  _LT_LINKER_BOILERPLATE\n\n  # Allow CC to be a program name with arguments.\n  lt_save_CC=$CC\n  lt_save_GCC=$GCC\n  lt_save_CFLAGS=$CFLAGS\n  CC=${FC-\"f95\"}\n  CFLAGS=$FCFLAGS\n  compiler=$CC\n  GCC=$ac_cv_fc_compiler_gnu\n\n  _LT_TAGVAR(compiler, $1)=$CC\n  _LT_CC_BASENAME([$compiler])\n\n  if test -n \"$compiler\"; then\n    AC_MSG_CHECKING([if libtool supports shared libraries])\n    AC_MSG_RESULT([$can_build_shared])\n\n    AC_MSG_CHECKING([whether to build shared libraries])\n    test no = \"$can_build_shared\" && enable_shared=no\n\n    # On AIX, shared libraries and static libraries use the same namespace, and\n    # are all built from PIC.\n    case $host_os in\n      aix3*)\n        test yes = \"$enable_shared\" && enable_static=no\n        if test -n \"$RANLIB\"; then\n          archive_cmds=\"$archive_cmds~\\$RANLIB \\$lib\"\n          postinstall_cmds='$RANLIB $lib'\n        fi\n        ;;\n      aix[[4-9]]*)\n\tif test ia64 != \"$host_cpu\"; then\n\t  case $enable_shared,$with_aix_soname,$aix_use_runtimelinking in\n\t  yes,aix,yes) ;;\t\t# shared object as lib.so file only\n\t  yes,svr4,*) ;;\t\t# shared object as lib.so archive member only\n\t  yes,*) enable_static=no ;;\t# shared object in lib.a archive as well\n\t  esac\n\tfi\n        ;;\n    esac\n    AC_MSG_RESULT([$enable_shared])\n\n    AC_MSG_CHECKING([whether to build static libraries])\n    # Make sure either enable_shared or enable_static is yes.\n    test yes = \"$enable_shared\" || enable_static=yes\n    AC_MSG_RESULT([$enable_static])\n\n    _LT_TAGVAR(GCC, $1)=$ac_cv_fc_compiler_gnu\n    _LT_TAGVAR(LD, $1)=$LD\n\n    ## CAVEAT EMPTOR:\n    ## There is no encapsulation within the following macros, do not change\n    ## the running order or otherwise move them around unless you know exactly\n    ## what you are doing...\n    _LT_SYS_HIDDEN_LIBDEPS($1)\n    _LT_COMPILER_PIC($1)\n    _LT_COMPILER_C_O($1)\n    _LT_COMPILER_FILE_LOCKS($1)\n    _LT_LINKER_SHLIBS($1)\n    _LT_SYS_DYNAMIC_LINKER($1)\n    _LT_LINKER_HARDCODE_LIBPATH($1)\n\n    _LT_CONFIG($1)\n  fi # test -n \"$compiler\"\n\n  GCC=$lt_save_GCC\n  CC=$lt_save_CC\n  CFLAGS=$lt_save_CFLAGS\nfi # test yes != \"$_lt_disable_FC\"\n\nAC_LANG_POP\n])# _LT_LANG_FC_CONFIG\n\n\n# _LT_LANG_GCJ_CONFIG([TAG])\n# --------------------------\n# Ensure that the configuration variables for the GNU Java Compiler compiler\n# are suitably defined.  These variables are subsequently used by _LT_CONFIG\n# to write the compiler configuration to 'libtool'.\nm4_defun([_LT_LANG_GCJ_CONFIG],\n[AC_REQUIRE([LT_PROG_GCJ])dnl\nAC_LANG_SAVE\n\n# Source file extension for Java test sources.\nac_ext=java\n\n# Object file extension for compiled Java test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# Code to be used in simple compile tests\nlt_simple_compile_test_code=\"class foo {}\"\n\n# Code to be used in simple link tests\nlt_simple_link_test_code='public class conftest { public static void main(String[[]] argv) {}; }'\n\n# ltmain only uses $CC for tagged configurations so make sure $CC is set.\n_LT_TAG_COMPILER\n\n# save warnings/boilerplate of simple test code\n_LT_COMPILER_BOILERPLATE\n_LT_LINKER_BOILERPLATE\n\n# Allow CC to be a program name with arguments.\nlt_save_CC=$CC\nlt_save_CFLAGS=$CFLAGS\nlt_save_GCC=$GCC\nGCC=yes\nCC=${GCJ-\"gcj\"}\nCFLAGS=$GCJFLAGS\ncompiler=$CC\n_LT_TAGVAR(compiler, $1)=$CC\n_LT_TAGVAR(LD, $1)=$LD\n_LT_CC_BASENAME([$compiler])\n\n# GCJ did not exist at the time GCC didn't implicitly link libc in.\n_LT_TAGVAR(archive_cmds_need_lc, $1)=no\n\n_LT_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds\n_LT_TAGVAR(reload_flag, $1)=$reload_flag\n_LT_TAGVAR(reload_cmds, $1)=$reload_cmds\n\n## CAVEAT EMPTOR:\n## There is no encapsulation within the following macros, do not change\n## the running order or otherwise move them around unless you know exactly\n## what you are doing...\nif test -n \"$compiler\"; then\n  _LT_COMPILER_NO_RTTI($1)\n  _LT_COMPILER_PIC($1)\n  _LT_COMPILER_C_O($1)\n  _LT_COMPILER_FILE_LOCKS($1)\n  _LT_LINKER_SHLIBS($1)\n  _LT_LINKER_HARDCODE_LIBPATH($1)\n\n  _LT_CONFIG($1)\nfi\n\nAC_LANG_RESTORE\n\nGCC=$lt_save_GCC\nCC=$lt_save_CC\nCFLAGS=$lt_save_CFLAGS\n])# _LT_LANG_GCJ_CONFIG\n\n\n# _LT_LANG_GO_CONFIG([TAG])\n# --------------------------\n# Ensure that the configuration variables for the GNU Go compiler\n# are suitably defined.  These variables are subsequently used by _LT_CONFIG\n# to write the compiler configuration to 'libtool'.\nm4_defun([_LT_LANG_GO_CONFIG],\n[AC_REQUIRE([LT_PROG_GO])dnl\nAC_LANG_SAVE\n\n# Source file extension for Go test sources.\nac_ext=go\n\n# Object file extension for compiled Go test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# Code to be used in simple compile tests\nlt_simple_compile_test_code=\"package main; func main() { }\"\n\n# Code to be used in simple link tests\nlt_simple_link_test_code='package main; func main() { }'\n\n# ltmain only uses $CC for tagged configurations so make sure $CC is set.\n_LT_TAG_COMPILER\n\n# save warnings/boilerplate of simple test code\n_LT_COMPILER_BOILERPLATE\n_LT_LINKER_BOILERPLATE\n\n# Allow CC to be a program name with arguments.\nlt_save_CC=$CC\nlt_save_CFLAGS=$CFLAGS\nlt_save_GCC=$GCC\nGCC=yes\nCC=${GOC-\"gccgo\"}\nCFLAGS=$GOFLAGS\ncompiler=$CC\n_LT_TAGVAR(compiler, $1)=$CC\n_LT_TAGVAR(LD, $1)=$LD\n_LT_CC_BASENAME([$compiler])\n\n# Go did not exist at the time GCC didn't implicitly link libc in.\n_LT_TAGVAR(archive_cmds_need_lc, $1)=no\n\n_LT_TAGVAR(old_archive_cmds, $1)=$old_archive_cmds\n_LT_TAGVAR(reload_flag, $1)=$reload_flag\n_LT_TAGVAR(reload_cmds, $1)=$reload_cmds\n\n## CAVEAT EMPTOR:\n## There is no encapsulation within the following macros, do not change\n## the running order or otherwise move them around unless you know exactly\n## what you are doing...\nif test -n \"$compiler\"; then\n  _LT_COMPILER_NO_RTTI($1)\n  _LT_COMPILER_PIC($1)\n  _LT_COMPILER_C_O($1)\n  _LT_COMPILER_FILE_LOCKS($1)\n  _LT_LINKER_SHLIBS($1)\n  _LT_LINKER_HARDCODE_LIBPATH($1)\n\n  _LT_CONFIG($1)\nfi\n\nAC_LANG_RESTORE\n\nGCC=$lt_save_GCC\nCC=$lt_save_CC\nCFLAGS=$lt_save_CFLAGS\n])# _LT_LANG_GO_CONFIG\n\n\n# _LT_LANG_RC_CONFIG([TAG])\n# -------------------------\n# Ensure that the configuration variables for the Windows resource compiler\n# are suitably defined.  These variables are subsequently used by _LT_CONFIG\n# to write the compiler configuration to 'libtool'.\nm4_defun([_LT_LANG_RC_CONFIG],\n[AC_REQUIRE([LT_PROG_RC])dnl\nAC_LANG_SAVE\n\n# Source file extension for RC test sources.\nac_ext=rc\n\n# Object file extension for compiled RC test sources.\nobjext=o\n_LT_TAGVAR(objext, $1)=$objext\n\n# Code to be used in simple compile tests\nlt_simple_compile_test_code='sample MENU { MENUITEM \"&Soup\", 100, CHECKED }'\n\n# Code to be used in simple link tests\nlt_simple_link_test_code=$lt_simple_compile_test_code\n\n# ltmain only uses $CC for tagged configurations so make sure $CC is set.\n_LT_TAG_COMPILER\n\n# save warnings/boilerplate of simple test code\n_LT_COMPILER_BOILERPLATE\n_LT_LINKER_BOILERPLATE\n\n# Allow CC to be a program name with arguments.\nlt_save_CC=$CC\nlt_save_CFLAGS=$CFLAGS\nlt_save_GCC=$GCC\nGCC=\nCC=${RC-\"windres\"}\nCFLAGS=\ncompiler=$CC\n_LT_TAGVAR(compiler, $1)=$CC\n_LT_CC_BASENAME([$compiler])\n_LT_TAGVAR(lt_cv_prog_compiler_c_o, $1)=yes\n\nif test -n \"$compiler\"; then\n  :\n  _LT_CONFIG($1)\nfi\n\nGCC=$lt_save_GCC\nAC_LANG_RESTORE\nCC=$lt_save_CC\nCFLAGS=$lt_save_CFLAGS\n])# _LT_LANG_RC_CONFIG\n\n\n# LT_PROG_GCJ\n# -----------\nAC_DEFUN([LT_PROG_GCJ],\n[m4_ifdef([AC_PROG_GCJ], [AC_PROG_GCJ],\n  [m4_ifdef([A][M_PROG_GCJ], [A][M_PROG_GCJ],\n    [AC_CHECK_TOOL(GCJ, gcj,)\n      test set = \"${GCJFLAGS+set}\" || GCJFLAGS=\"-g -O2\"\n      AC_SUBST(GCJFLAGS)])])[]dnl\n])\n\n# Old name:\nAU_ALIAS([LT_AC_PROG_GCJ], [LT_PROG_GCJ])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([LT_AC_PROG_GCJ], [])\n\n\n# LT_PROG_GO\n# ----------\nAC_DEFUN([LT_PROG_GO],\n[AC_CHECK_TOOL(GOC, gccgo,)\n])\n\n\n# LT_PROG_RC\n# ----------\nAC_DEFUN([LT_PROG_RC],\n[AC_CHECK_TOOL(RC, windres,)\n])\n\n# Old name:\nAU_ALIAS([LT_AC_PROG_RC], [LT_PROG_RC])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([LT_AC_PROG_RC], [])\n\n\n# _LT_DECL_EGREP\n# --------------\n# If we don't have a new enough Autoconf to choose the best grep\n# available, choose the one first in the user's PATH.\nm4_defun([_LT_DECL_EGREP],\n[AC_REQUIRE([AC_PROG_EGREP])dnl\nAC_REQUIRE([AC_PROG_FGREP])dnl\ntest -z \"$GREP\" && GREP=grep\n_LT_DECL([], [GREP], [1], [A grep program that handles long lines])\n_LT_DECL([], [EGREP], [1], [An ERE matcher])\n_LT_DECL([], [FGREP], [1], [A literal string matcher])\ndnl Non-bleeding-edge autoconf doesn't subst GREP, so do it here too\nAC_SUBST([GREP])\n])\n\n\n# _LT_DECL_OBJDUMP\n# --------------\n# If we don't have a new enough Autoconf to choose the best objdump\n# available, choose the one first in the user's PATH.\nm4_defun([_LT_DECL_OBJDUMP],\n[AC_CHECK_TOOL(OBJDUMP, objdump, false)\ntest -z \"$OBJDUMP\" && OBJDUMP=objdump\n_LT_DECL([], [OBJDUMP], [1], [An object symbol dumper])\nAC_SUBST([OBJDUMP])\n])\n\n# _LT_DECL_DLLTOOL\n# ----------------\n# Ensure DLLTOOL variable is set.\nm4_defun([_LT_DECL_DLLTOOL],\n[AC_CHECK_TOOL(DLLTOOL, dlltool, false)\ntest -z \"$DLLTOOL\" && DLLTOOL=dlltool\n_LT_DECL([], [DLLTOOL], [1], [DLL creation program])\nAC_SUBST([DLLTOOL])\n])\n\n# _LT_DECL_SED\n# ------------\n# Check for a fully-functional sed program, that truncates\n# as few characters as possible.  Prefer GNU sed if found.\nm4_defun([_LT_DECL_SED],\n[AC_PROG_SED\ntest -z \"$SED\" && SED=sed\nXsed=\"$SED -e 1s/^X//\"\n_LT_DECL([], [SED], [1], [A sed program that does not truncate output])\n_LT_DECL([], [Xsed], [\"\\$SED -e 1s/^X//\"],\n    [Sed that helps us avoid accidentally triggering echo(1) options like -n])\n])# _LT_DECL_SED\n\nm4_ifndef([AC_PROG_SED], [\n############################################################\n# NOTE: This macro has been submitted for inclusion into   #\n#  GNU Autoconf as AC_PROG_SED.  When it is available in   #\n#  a released version of Autoconf we should remove this    #\n#  macro and use it instead.                               #\n############################################################\n\nm4_defun([AC_PROG_SED],\n[AC_MSG_CHECKING([for a sed that does not truncate output])\nAC_CACHE_VAL(lt_cv_path_SED,\n[# Loop through the user's path and test for sed and gsed.\n# Then use that list of sed's as ones to test for truncation.\nas_save_IFS=$IFS; IFS=$PATH_SEPARATOR\nfor as_dir in $PATH\ndo\n  IFS=$as_save_IFS\n  test -z \"$as_dir\" && as_dir=.\n  for lt_ac_prog in sed gsed; do\n    for ac_exec_ext in '' $ac_executable_extensions; do\n      if $as_executable_p \"$as_dir/$lt_ac_prog$ac_exec_ext\"; then\n        lt_ac_sed_list=\"$lt_ac_sed_list $as_dir/$lt_ac_prog$ac_exec_ext\"\n      fi\n    done\n  done\ndone\nIFS=$as_save_IFS\nlt_ac_max=0\nlt_ac_count=0\n# Add /usr/xpg4/bin/sed as it is typically found on Solaris\n# along with /bin/sed that truncates output.\nfor lt_ac_sed in $lt_ac_sed_list /usr/xpg4/bin/sed; do\n  test ! -f \"$lt_ac_sed\" && continue\n  cat /dev/null > conftest.in\n  lt_ac_count=0\n  echo $ECHO_N \"0123456789$ECHO_C\" >conftest.in\n  # Check for GNU sed and select it if it is found.\n  if \"$lt_ac_sed\" --version 2>&1 < /dev/null | grep 'GNU' > /dev/null; then\n    lt_cv_path_SED=$lt_ac_sed\n    break\n  fi\n  while true; do\n    cat conftest.in conftest.in >conftest.tmp\n    mv conftest.tmp conftest.in\n    cp conftest.in conftest.nl\n    echo >>conftest.nl\n    $lt_ac_sed -e 's/a$//' < conftest.nl >conftest.out || break\n    cmp -s conftest.out conftest.nl || break\n    # 10000 chars as input seems more than enough\n    test 10 -lt \"$lt_ac_count\" && break\n    lt_ac_count=`expr $lt_ac_count + 1`\n    if test \"$lt_ac_count\" -gt \"$lt_ac_max\"; then\n      lt_ac_max=$lt_ac_count\n      lt_cv_path_SED=$lt_ac_sed\n    fi\n  done\ndone\n])\nSED=$lt_cv_path_SED\nAC_SUBST([SED])\nAC_MSG_RESULT([$SED])\n])#AC_PROG_SED\n])#m4_ifndef\n\n# Old name:\nAU_ALIAS([LT_AC_PROG_SED], [AC_PROG_SED])\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([LT_AC_PROG_SED], [])\n\n\n# _LT_CHECK_SHELL_FEATURES\n# ------------------------\n# Find out whether the shell is Bourne or XSI compatible,\n# or has some other useful features.\nm4_defun([_LT_CHECK_SHELL_FEATURES],\n[if ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then\n  lt_unset=unset\nelse\n  lt_unset=false\nfi\n_LT_DECL([], [lt_unset], [0], [whether the shell understands \"unset\"])dnl\n\n# test EBCDIC or ASCII\ncase `echo X|tr X '\\101'` in\n A) # ASCII based system\n    # \\n is not interpreted correctly by Solaris 8 /usr/ucb/tr\n  lt_SP2NL='tr \\040 \\012'\n  lt_NL2SP='tr \\015\\012 \\040\\040'\n  ;;\n *) # EBCDIC based system\n  lt_SP2NL='tr \\100 \\n'\n  lt_NL2SP='tr \\r\\n \\100\\100'\n  ;;\nesac\n_LT_DECL([SP2NL], [lt_SP2NL], [1], [turn spaces into newlines])dnl\n_LT_DECL([NL2SP], [lt_NL2SP], [1], [turn newlines into spaces])dnl\n])# _LT_CHECK_SHELL_FEATURES\n\n\n# _LT_PATH_CONVERSION_FUNCTIONS\n# -----------------------------\n# Determine what file name conversion functions should be used by\n# func_to_host_file (and, implicitly, by func_to_host_path).  These are needed\n# for certain cross-compile configurations and native mingw.\nm4_defun([_LT_PATH_CONVERSION_FUNCTIONS],\n[AC_REQUIRE([AC_CANONICAL_HOST])dnl\nAC_REQUIRE([AC_CANONICAL_BUILD])dnl\nAC_MSG_CHECKING([how to convert $build file names to $host format])\nAC_CACHE_VAL(lt_cv_to_host_file_cmd,\n[case $host in\n  *-*-mingw* )\n    case $build in\n      *-*-mingw* ) # actually msys\n        lt_cv_to_host_file_cmd=func_convert_file_msys_to_w32\n        ;;\n      *-*-cygwin* )\n        lt_cv_to_host_file_cmd=func_convert_file_cygwin_to_w32\n        ;;\n      * ) # otherwise, assume *nix\n        lt_cv_to_host_file_cmd=func_convert_file_nix_to_w32\n        ;;\n    esac\n    ;;\n  *-*-cygwin* )\n    case $build in\n      *-*-mingw* ) # actually msys\n        lt_cv_to_host_file_cmd=func_convert_file_msys_to_cygwin\n        ;;\n      *-*-cygwin* )\n        lt_cv_to_host_file_cmd=func_convert_file_noop\n        ;;\n      * ) # otherwise, assume *nix\n        lt_cv_to_host_file_cmd=func_convert_file_nix_to_cygwin\n        ;;\n    esac\n    ;;\n  * ) # unhandled hosts (and \"normal\" native builds)\n    lt_cv_to_host_file_cmd=func_convert_file_noop\n    ;;\nesac\n])\nto_host_file_cmd=$lt_cv_to_host_file_cmd\nAC_MSG_RESULT([$lt_cv_to_host_file_cmd])\n_LT_DECL([to_host_file_cmd], [lt_cv_to_host_file_cmd],\n         [0], [convert $build file names to $host format])dnl\n\nAC_MSG_CHECKING([how to convert $build file names to toolchain format])\nAC_CACHE_VAL(lt_cv_to_tool_file_cmd,\n[#assume ordinary cross tools, or native build.\nlt_cv_to_tool_file_cmd=func_convert_file_noop\ncase $host in\n  *-*-mingw* )\n    case $build in\n      *-*-mingw* ) # actually msys\n        lt_cv_to_tool_file_cmd=func_convert_file_msys_to_w32\n        ;;\n    esac\n    ;;\nesac\n])\nto_tool_file_cmd=$lt_cv_to_tool_file_cmd\nAC_MSG_RESULT([$lt_cv_to_tool_file_cmd])\n_LT_DECL([to_tool_file_cmd], [lt_cv_to_tool_file_cmd],\n         [0], [convert $build files to toolchain format])dnl\n])# _LT_PATH_CONVERSION_FUNCTIONS\n",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/extra/libedit/libedit-20190324-3.1/m4/ltoptions.m4": "# Helper functions for option handling.                    -*- Autoconf -*-\n#\n#   Copyright (C) 2004-2005, 2007-2009, 2011-2015 Free Software\n#   Foundation, Inc.\n#   Written by Gary V. Vaughan, 2004\n#\n# This file is free software; the Free Software Foundation gives\n# unlimited permission to copy and/or distribute it, with or without\n# modifications, as long as this notice is preserved.\n\n# serial 8 ltoptions.m4\n\n# This is to help aclocal find these macros, as it can't see m4_define.\nAC_DEFUN([LTOPTIONS_VERSION], [m4_if([1])])\n\n\n# _LT_MANGLE_OPTION(MACRO-NAME, OPTION-NAME)\n# ------------------------------------------\nm4_define([_LT_MANGLE_OPTION],\n[[_LT_OPTION_]m4_bpatsubst($1__$2, [[^a-zA-Z0-9_]], [_])])\n\n\n# _LT_SET_OPTION(MACRO-NAME, OPTION-NAME)\n# ---------------------------------------\n# Set option OPTION-NAME for macro MACRO-NAME, and if there is a\n# matching handler defined, dispatch to it.  Other OPTION-NAMEs are\n# saved as a flag.\nm4_define([_LT_SET_OPTION],\n[m4_define(_LT_MANGLE_OPTION([$1], [$2]))dnl\nm4_ifdef(_LT_MANGLE_DEFUN([$1], [$2]),\n        _LT_MANGLE_DEFUN([$1], [$2]),\n    [m4_warning([Unknown $1 option '$2'])])[]dnl\n])\n\n\n# _LT_IF_OPTION(MACRO-NAME, OPTION-NAME, IF-SET, [IF-NOT-SET])\n# ------------------------------------------------------------\n# Execute IF-SET if OPTION is set, IF-NOT-SET otherwise.\nm4_define([_LT_IF_OPTION],\n[m4_ifdef(_LT_MANGLE_OPTION([$1], [$2]), [$3], [$4])])\n\n\n# _LT_UNLESS_OPTIONS(MACRO-NAME, OPTION-LIST, IF-NOT-SET)\n# -------------------------------------------------------\n# Execute IF-NOT-SET unless all options in OPTION-LIST for MACRO-NAME\n# are set.\nm4_define([_LT_UNLESS_OPTIONS],\n[m4_foreach([_LT_Option], m4_split(m4_normalize([$2])),\n\t    [m4_ifdef(_LT_MANGLE_OPTION([$1], _LT_Option),\n\t\t      [m4_define([$0_found])])])[]dnl\nm4_ifdef([$0_found], [m4_undefine([$0_found])], [$3\n])[]dnl\n])\n\n\n# _LT_SET_OPTIONS(MACRO-NAME, OPTION-LIST)\n# ----------------------------------------\n# OPTION-LIST is a space-separated list of Libtool options associated\n# with MACRO-NAME.  If any OPTION has a matching handler declared with\n# LT_OPTION_DEFINE, dispatch to that macro; otherwise complain about\n# the unknown option and exit.\nm4_defun([_LT_SET_OPTIONS],\n[# Set options\nm4_foreach([_LT_Option], m4_split(m4_normalize([$2])),\n    [_LT_SET_OPTION([$1], _LT_Option)])\n\nm4_if([$1],[LT_INIT],[\n  dnl\n  dnl Simply set some default values (i.e off) if boolean options were not\n  dnl specified:\n  _LT_UNLESS_OPTIONS([LT_INIT], [dlopen], [enable_dlopen=no\n  ])\n  _LT_UNLESS_OPTIONS([LT_INIT], [win32-dll], [enable_win32_dll=no\n  ])\n  dnl\n  dnl If no reference was made to various pairs of opposing options, then\n  dnl we run the default mode handler for the pair.  For example, if neither\n  dnl 'shared' nor 'disable-shared' was passed, we enable building of shared\n  dnl archives by default:\n  _LT_UNLESS_OPTIONS([LT_INIT], [shared disable-shared], [_LT_ENABLE_SHARED])\n  _LT_UNLESS_OPTIONS([LT_INIT], [static disable-static], [_LT_ENABLE_STATIC])\n  _LT_UNLESS_OPTIONS([LT_INIT], [pic-only no-pic], [_LT_WITH_PIC])\n  _LT_UNLESS_OPTIONS([LT_INIT], [fast-install disable-fast-install],\n\t\t   [_LT_ENABLE_FAST_INSTALL])\n  _LT_UNLESS_OPTIONS([LT_INIT], [aix-soname=aix aix-soname=both aix-soname=svr4],\n\t\t   [_LT_WITH_AIX_SONAME([aix])])\n  ])\n])# _LT_SET_OPTIONS\n\n\n## --------------------------------- ##\n## Macros to handle LT_INIT options. ##\n## --------------------------------- ##\n\n# _LT_MANGLE_DEFUN(MACRO-NAME, OPTION-NAME)\n# -----------------------------------------\nm4_define([_LT_MANGLE_DEFUN],\n[[_LT_OPTION_DEFUN_]m4_bpatsubst(m4_toupper([$1__$2]), [[^A-Z0-9_]], [_])])\n\n\n# LT_OPTION_DEFINE(MACRO-NAME, OPTION-NAME, CODE)\n# -----------------------------------------------\nm4_define([LT_OPTION_DEFINE],\n[m4_define(_LT_MANGLE_DEFUN([$1], [$2]), [$3])[]dnl\n])# LT_OPTION_DEFINE\n\n\n# dlopen\n# ------\nLT_OPTION_DEFINE([LT_INIT], [dlopen], [enable_dlopen=yes\n])\n\nAU_DEFUN([AC_LIBTOOL_DLOPEN],\n[_LT_SET_OPTION([LT_INIT], [dlopen])\nAC_DIAGNOSE([obsolete],\n[$0: Remove this warning and the call to _LT_SET_OPTION when you\nput the 'dlopen' option into LT_INIT's first parameter.])\n])\n\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_DLOPEN], [])\n\n\n# win32-dll\n# ---------\n# Declare package support for building win32 dll's.\nLT_OPTION_DEFINE([LT_INIT], [win32-dll],\n[enable_win32_dll=yes\n\ncase $host in\n*-*-cygwin* | *-*-mingw* | *-*-pw32* | *-*-cegcc*)\n  AC_CHECK_TOOL(AS, as, false)\n  AC_CHECK_TOOL(DLLTOOL, dlltool, false)\n  AC_CHECK_TOOL(OBJDUMP, objdump, false)\n  ;;\nesac\n\ntest -z \"$AS\" && AS=as\n_LT_DECL([], [AS],      [1], [Assembler program])dnl\n\ntest -z \"$DLLTOOL\" && DLLTOOL=dlltool\n_LT_DECL([], [DLLTOOL], [1], [DLL creation program])dnl\n\ntest -z \"$OBJDUMP\" && OBJDUMP=objdump\n_LT_DECL([], [OBJDUMP], [1], [Object dumper program])dnl\n])# win32-dll\n\nAU_DEFUN([AC_LIBTOOL_WIN32_DLL],\n[AC_REQUIRE([AC_CANONICAL_HOST])dnl\n_LT_SET_OPTION([LT_INIT], [win32-dll])\nAC_DIAGNOSE([obsolete],\n[$0: Remove this warning and the call to _LT_SET_OPTION when you\nput the 'win32-dll' option into LT_INIT's first parameter.])\n])\n\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_WIN32_DLL], [])\n\n\n# _LT_ENABLE_SHARED([DEFAULT])\n# ----------------------------\n# implement the --enable-shared flag, and supports the 'shared' and\n# 'disable-shared' LT_INIT options.\n# DEFAULT is either 'yes' or 'no'.  If omitted, it defaults to 'yes'.\nm4_define([_LT_ENABLE_SHARED],\n[m4_define([_LT_ENABLE_SHARED_DEFAULT], [m4_if($1, no, no, yes)])dnl\nAC_ARG_ENABLE([shared],\n    [AS_HELP_STRING([--enable-shared@<:@=PKGS@:>@],\n\t[build shared libraries @<:@default=]_LT_ENABLE_SHARED_DEFAULT[@:>@])],\n    [p=${PACKAGE-default}\n    case $enableval in\n    yes) enable_shared=yes ;;\n    no) enable_shared=no ;;\n    *)\n      enable_shared=no\n      # Look at the argument we got.  We use all the common list separators.\n      lt_save_ifs=$IFS; IFS=$IFS$PATH_SEPARATOR,\n      for pkg in $enableval; do\n\tIFS=$lt_save_ifs\n\tif test \"X$pkg\" = \"X$p\"; then\n\t  enable_shared=yes\n\tfi\n      done\n      IFS=$lt_save_ifs\n      ;;\n    esac],\n    [enable_shared=]_LT_ENABLE_SHARED_DEFAULT)\n\n    _LT_DECL([build_libtool_libs], [enable_shared], [0],\n\t[Whether or not to build shared libraries])\n])# _LT_ENABLE_SHARED\n\nLT_OPTION_DEFINE([LT_INIT], [shared], [_LT_ENABLE_SHARED([yes])])\nLT_OPTION_DEFINE([LT_INIT], [disable-shared], [_LT_ENABLE_SHARED([no])])\n\n# Old names:\nAC_DEFUN([AC_ENABLE_SHARED],\n[_LT_SET_OPTION([LT_INIT], m4_if([$1], [no], [disable-])[shared])\n])\n\nAC_DEFUN([AC_DISABLE_SHARED],\n[_LT_SET_OPTION([LT_INIT], [disable-shared])\n])\n\nAU_DEFUN([AM_ENABLE_SHARED], [AC_ENABLE_SHARED($@)])\nAU_DEFUN([AM_DISABLE_SHARED], [AC_DISABLE_SHARED($@)])\n\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AM_ENABLE_SHARED], [])\ndnl AC_DEFUN([AM_DISABLE_SHARED], [])\n\n\n\n# _LT_ENABLE_STATIC([DEFAULT])\n# ----------------------------\n# implement the --enable-static flag, and support the 'static' and\n# 'disable-static' LT_INIT options.\n# DEFAULT is either 'yes' or 'no'.  If omitted, it defaults to 'yes'.\nm4_define([_LT_ENABLE_STATIC],\n[m4_define([_LT_ENABLE_STATIC_DEFAULT], [m4_if($1, no, no, yes)])dnl\nAC_ARG_ENABLE([static],\n    [AS_HELP_STRING([--enable-static@<:@=PKGS@:>@],\n\t[build static libraries @<:@default=]_LT_ENABLE_STATIC_DEFAULT[@:>@])],\n    [p=${PACKAGE-default}\n    case $enableval in\n    yes) enable_static=yes ;;\n    no) enable_static=no ;;\n    *)\n     enable_static=no\n      # Look at the argument we got.  We use all the common list separators.\n      lt_save_ifs=$IFS; IFS=$IFS$PATH_SEPARATOR,\n      for pkg in $enableval; do\n\tIFS=$lt_save_ifs\n\tif test \"X$pkg\" = \"X$p\"; then\n\t  enable_static=yes\n\tfi\n      done\n      IFS=$lt_save_ifs\n      ;;\n    esac],\n    [enable_static=]_LT_ENABLE_STATIC_DEFAULT)\n\n    _LT_DECL([build_old_libs], [enable_static], [0],\n\t[Whether or not to build static libraries])\n])# _LT_ENABLE_STATIC\n\nLT_OPTION_DEFINE([LT_INIT], [static], [_LT_ENABLE_STATIC([yes])])\nLT_OPTION_DEFINE([LT_INIT], [disable-static], [_LT_ENABLE_STATIC([no])])\n\n# Old names:\nAC_DEFUN([AC_ENABLE_STATIC],\n[_LT_SET_OPTION([LT_INIT], m4_if([$1], [no], [disable-])[static])\n])\n\nAC_DEFUN([AC_DISABLE_STATIC],\n[_LT_SET_OPTION([LT_INIT], [disable-static])\n])\n\nAU_DEFUN([AM_ENABLE_STATIC], [AC_ENABLE_STATIC($@)])\nAU_DEFUN([AM_DISABLE_STATIC], [AC_DISABLE_STATIC($@)])\n\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AM_ENABLE_STATIC], [])\ndnl AC_DEFUN([AM_DISABLE_STATIC], [])\n\n\n\n# _LT_ENABLE_FAST_INSTALL([DEFAULT])\n# ----------------------------------\n# implement the --enable-fast-install flag, and support the 'fast-install'\n# and 'disable-fast-install' LT_INIT options.\n# DEFAULT is either 'yes' or 'no'.  If omitted, it defaults to 'yes'.\nm4_define([_LT_ENABLE_FAST_INSTALL],\n[m4_define([_LT_ENABLE_FAST_INSTALL_DEFAULT], [m4_if($1, no, no, yes)])dnl\nAC_ARG_ENABLE([fast-install],\n    [AS_HELP_STRING([--enable-fast-install@<:@=PKGS@:>@],\n    [optimize for fast installation @<:@default=]_LT_ENABLE_FAST_INSTALL_DEFAULT[@:>@])],\n    [p=${PACKAGE-default}\n    case $enableval in\n    yes) enable_fast_install=yes ;;\n    no) enable_fast_install=no ;;\n    *)\n      enable_fast_install=no\n      # Look at the argument we got.  We use all the common list separators.\n      lt_save_ifs=$IFS; IFS=$IFS$PATH_SEPARATOR,\n      for pkg in $enableval; do\n\tIFS=$lt_save_ifs\n\tif test \"X$pkg\" = \"X$p\"; then\n\t  enable_fast_install=yes\n\tfi\n      done\n      IFS=$lt_save_ifs\n      ;;\n    esac],\n    [enable_fast_install=]_LT_ENABLE_FAST_INSTALL_DEFAULT)\n\n_LT_DECL([fast_install], [enable_fast_install], [0],\n\t [Whether or not to optimize for fast installation])dnl\n])# _LT_ENABLE_FAST_INSTALL\n\nLT_OPTION_DEFINE([LT_INIT], [fast-install], [_LT_ENABLE_FAST_INSTALL([yes])])\nLT_OPTION_DEFINE([LT_INIT], [disable-fast-install], [_LT_ENABLE_FAST_INSTALL([no])])\n\n# Old names:\nAU_DEFUN([AC_ENABLE_FAST_INSTALL],\n[_LT_SET_OPTION([LT_INIT], m4_if([$1], [no], [disable-])[fast-install])\nAC_DIAGNOSE([obsolete],\n[$0: Remove this warning and the call to _LT_SET_OPTION when you put\nthe 'fast-install' option into LT_INIT's first parameter.])\n])\n\nAU_DEFUN([AC_DISABLE_FAST_INSTALL],\n[_LT_SET_OPTION([LT_INIT], [disable-fast-install])\nAC_DIAGNOSE([obsolete],\n[$0: Remove this warning and the call to _LT_SET_OPTION when you put\nthe 'disable-fast-install' option into LT_INIT's first parameter.])\n])\n\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_ENABLE_FAST_INSTALL], [])\ndnl AC_DEFUN([AM_DISABLE_FAST_INSTALL], [])\n\n\n# _LT_WITH_AIX_SONAME([DEFAULT])\n# ----------------------------------\n# implement the --with-aix-soname flag, and support the `aix-soname=aix'\n# and `aix-soname=both' and `aix-soname=svr4' LT_INIT options. DEFAULT\n# is either `aix', `both' or `svr4'.  If omitted, it defaults to `aix'.\nm4_define([_LT_WITH_AIX_SONAME],\n[m4_define([_LT_WITH_AIX_SONAME_DEFAULT], [m4_if($1, svr4, svr4, m4_if($1, both, both, aix))])dnl\nshared_archive_member_spec=\ncase $host,$enable_shared in\npower*-*-aix[[5-9]]*,yes)\n  AC_MSG_CHECKING([which variant of shared library versioning to provide])\n  AC_ARG_WITH([aix-soname],\n    [AS_HELP_STRING([--with-aix-soname=aix|svr4|both],\n      [shared library versioning (aka \"SONAME\") variant to provide on AIX, @<:@default=]_LT_WITH_AIX_SONAME_DEFAULT[@:>@.])],\n    [case $withval in\n    aix|svr4|both)\n      ;;\n    *)\n      AC_MSG_ERROR([Unknown argument to --with-aix-soname])\n      ;;\n    esac\n    lt_cv_with_aix_soname=$with_aix_soname],\n    [AC_CACHE_VAL([lt_cv_with_aix_soname],\n      [lt_cv_with_aix_soname=]_LT_WITH_AIX_SONAME_DEFAULT)\n    with_aix_soname=$lt_cv_with_aix_soname])\n  AC_MSG_RESULT([$with_aix_soname])\n  if test aix != \"$with_aix_soname\"; then\n    # For the AIX way of multilib, we name the shared archive member\n    # based on the bitwidth used, traditionally 'shr.o' or 'shr_64.o',\n    # and 'shr.imp' or 'shr_64.imp', respectively, for the Import File.\n    # Even when GNU compilers ignore OBJECT_MODE but need '-maix64' flag,\n    # the AIX toolchain works better with OBJECT_MODE set (default 32).\n    if test 64 = \"${OBJECT_MODE-32}\"; then\n      shared_archive_member_spec=shr_64\n    else\n      shared_archive_member_spec=shr\n    fi\n  fi\n  ;;\n*)\n  with_aix_soname=aix\n  ;;\nesac\n\n_LT_DECL([], [shared_archive_member_spec], [0],\n    [Shared archive member basename, for filename based shared library versioning on AIX])dnl\n])# _LT_WITH_AIX_SONAME\n\nLT_OPTION_DEFINE([LT_INIT], [aix-soname=aix], [_LT_WITH_AIX_SONAME([aix])])\nLT_OPTION_DEFINE([LT_INIT], [aix-soname=both], [_LT_WITH_AIX_SONAME([both])])\nLT_OPTION_DEFINE([LT_INIT], [aix-soname=svr4], [_LT_WITH_AIX_SONAME([svr4])])\n\n\n# _LT_WITH_PIC([MODE])\n# --------------------\n# implement the --with-pic flag, and support the 'pic-only' and 'no-pic'\n# LT_INIT options.\n# MODE is either 'yes' or 'no'.  If omitted, it defaults to 'both'.\nm4_define([_LT_WITH_PIC],\n[AC_ARG_WITH([pic],\n    [AS_HELP_STRING([--with-pic@<:@=PKGS@:>@],\n\t[try to use only PIC/non-PIC objects @<:@default=use both@:>@])],\n    [lt_p=${PACKAGE-default}\n    case $withval in\n    yes|no) pic_mode=$withval ;;\n    *)\n      pic_mode=default\n      # Look at the argument we got.  We use all the common list separators.\n      lt_save_ifs=$IFS; IFS=$IFS$PATH_SEPARATOR,\n      for lt_pkg in $withval; do\n\tIFS=$lt_save_ifs\n\tif test \"X$lt_pkg\" = \"X$lt_p\"; then\n\t  pic_mode=yes\n\tfi\n      done\n      IFS=$lt_save_ifs\n      ;;\n    esac],\n    [pic_mode=m4_default([$1], [default])])\n\n_LT_DECL([], [pic_mode], [0], [What type of objects to build])dnl\n])# _LT_WITH_PIC\n\nLT_OPTION_DEFINE([LT_INIT], [pic-only], [_LT_WITH_PIC([yes])])\nLT_OPTION_DEFINE([LT_INIT], [no-pic], [_LT_WITH_PIC([no])])\n\n# Old name:\nAU_DEFUN([AC_LIBTOOL_PICMODE],\n[_LT_SET_OPTION([LT_INIT], [pic-only])\nAC_DIAGNOSE([obsolete],\n[$0: Remove this warning and the call to _LT_SET_OPTION when you\nput the 'pic-only' option into LT_INIT's first parameter.])\n])\n\ndnl aclocal-1.4 backwards compatibility:\ndnl AC_DEFUN([AC_LIBTOOL_PICMODE], [])\n\n## ----------------- ##\n## LTDL_INIT Options ##\n## ----------------- ##\n\nm4_define([_LTDL_MODE], [])\nLT_OPTION_DEFINE([LTDL_INIT], [nonrecursive],\n\t\t [m4_define([_LTDL_MODE], [nonrecursive])])\nLT_OPTION_DEFINE([LTDL_INIT], [recursive],\n\t\t [m4_define([_LTDL_MODE], [recursive])])\nLT_OPTION_DEFINE([LTDL_INIT], [subproject],\n\t\t [m4_define([_LTDL_MODE], [subproject])])\n\nm4_define([_LTDL_TYPE], [])\nLT_OPTION_DEFINE([LTDL_INIT], [installable],\n\t\t [m4_define([_LTDL_TYPE], [installable])])\nLT_OPTION_DEFINE([LTDL_INIT], [convenience],\n\t\t [m4_define([_LTDL_TYPE], [convenience])])\n",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/extra/icu/source/common/putil.cpp": "// \u00a9 2016 and later: Unicode, Inc. and others.\n// License & terms of use: http://www.unicode.org/copyright.html\n/*\n******************************************************************************\n*\n*   Copyright (C) 1997-2016, International Business Machines\n*   Corporation and others.  All Rights Reserved.\n*\n******************************************************************************\n*\n*  FILE NAME : putil.c (previously putil.cpp and ptypes.cpp)\n*\n*   Date        Name        Description\n*   04/14/97    aliu        Creation.\n*   04/24/97    aliu        Added getDefaultDataDirectory() and\n*                            getDefaultLocaleID().\n*   04/28/97    aliu        Rewritten to assume Unix and apply general methods\n*                            for assumed case.  Non-UNIX platforms must be\n*                            special-cased.  Rewrote numeric methods dealing\n*                            with NaN and Infinity to be platform independent\n*                             over all IEEE 754 platforms.\n*   05/13/97    aliu        Restored sign of timezone\n*                            (semantics are hours West of GMT)\n*   06/16/98    erm         Added IEEE_754 stuff, cleaned up isInfinite, isNan,\n*                             nextDouble..\n*   07/22/98    stephen     Added remainder, max, min, trunc\n*   08/13/98    stephen     Added isNegativeInfinity, isPositiveInfinity\n*   08/24/98    stephen     Added longBitsFromDouble\n*   09/08/98    stephen     Minor changes for Mac Port\n*   03/02/99    stephen     Removed openFile().  Added AS400 support.\n*                            Fixed EBCDIC tables\n*   04/15/99    stephen     Converted to C.\n*   06/28/99    stephen     Removed mutex locking in u_isBigEndian().\n*   08/04/99    jeffrey R.  Added OS/2 changes\n*   11/15/99    helena      Integrated S/390 IEEE support.\n*   04/26/01    Barry N.    OS/400 support for uprv_getDefaultLocaleID\n*   08/15/01    Steven H.   OS/400 support for uprv_getDefaultCodepage\n*   01/03/08    Steven L.   Fake Time Support\n******************************************************************************\n*/\n\n// Defines _XOPEN_SOURCE for access to POSIX functions.\n// Must be before any other #includes.\n#include \"uposixdefs.h\"\n\n// First, the platform type. Need this for U_PLATFORM.\n#include \"unicode/platform.h\"\n\n#if U_PLATFORM == U_PF_MINGW && defined __STRICT_ANSI__\n/* tzset isn't defined in strict ANSI on MinGW. */\n#undef __STRICT_ANSI__\n#endif\n\n/*\n * Cygwin with GCC requires inclusion of time.h after the above disabling strict asci mode statement.\n */\n#include <time.h>\n\n#if !U_PLATFORM_USES_ONLY_WIN32_API\n#include <sys/time.h>\n#endif\n\n/* include the rest of the ICU headers */\n#include \"unicode/putil.h\"\n#include \"unicode/ustring.h\"\n#include \"putilimp.h\"\n#include \"uassert.h\"\n#include \"umutex.h\"\n#include \"cmemory.h\"\n#include \"cstring.h\"\n#include \"locmap.h\"\n#include \"ucln_cmn.h\"\n#include \"charstr.h\"\n\n/* Include standard headers. */\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <locale.h>\n#include <float.h>\n\n#ifndef U_COMMON_IMPLEMENTATION\n#error U_COMMON_IMPLEMENTATION not set - must be set for all ICU source files in common/ - see http://userguide.icu-project.org/howtouseicu\n#endif\n\n\n/* include system headers */\n#if U_PLATFORM_USES_ONLY_WIN32_API\n    /*\n     * TODO: U_PLATFORM_USES_ONLY_WIN32_API includes MinGW.\n     * Should Cygwin be included as well (U_PLATFORM_HAS_WIN32_API)\n     * to use native APIs as much as possible?\n     */\n#ifndef WIN32_LEAN_AND_MEAN\n#   define WIN32_LEAN_AND_MEAN\n#endif\n#   define VC_EXTRALEAN\n#   define NOUSER\n#   define NOSERVICE\n#   define NOIME\n#   define NOMCX\n#   include <windows.h>\n#   include \"unicode\\uloc.h\"\n#if U_PLATFORM_HAS_WINUWP_API == 0\n#   include \"wintz.h\"\n#else // U_PLATFORM_HAS_WINUWP_API\ntypedef PVOID LPMSG; // TODO: figure out how to get rid of this typedef\n#include <Windows.Globalization.h>\n#include <windows.system.userprofile.h>\n#include <wrl\\wrappers\\corewrappers.h>\n#include <wrl\\client.h>\n\nusing namespace ABI::Windows::Foundation;\nusing namespace Microsoft::WRL;\nusing namespace Microsoft::WRL::Wrappers;\n#endif\n#elif U_PLATFORM == U_PF_OS400\n#   include <float.h>\n#   include <qusec.h>       /* error code structure */\n#   include <qusrjobi.h>\n#   include <qliept.h>      /* EPT_CALL macro  - this include must be after all other \"QSYSINCs\" */\n#   include <mih/testptr.h> /* For uprv_maximumPtr */\n#elif U_PLATFORM == U_PF_OS390\n#   include \"unicode/ucnv.h\"   /* Needed for UCNV_SWAP_LFNL_OPTION_STRING */\n#elif U_PLATFORM_IS_DARWIN_BASED || U_PLATFORM_IS_LINUX_BASED || U_PLATFORM == U_PF_BSD || U_PLATFORM == U_PF_SOLARIS\n#   include <limits.h>\n#   include <unistd.h>\n#   if U_PLATFORM == U_PF_SOLARIS\n#       ifndef _XPG4_2\n#           define _XPG4_2\n#       endif\n#   endif\n#elif U_PLATFORM == U_PF_QNX\n#   include <sys/neutrino.h>\n#endif\n\n/*\n * Only include langinfo.h if we have a way to get the codeset. If we later\n * depend on more feature, we can test on U_HAVE_NL_LANGINFO.\n *\n */\n\n#if U_HAVE_NL_LANGINFO_CODESET\n#include <langinfo.h>\n#endif\n\n/**\n * Simple things (presence of functions, etc) should just go in configure.in and be added to\n * icucfg.h via autoheader.\n */\n#if U_PLATFORM_IMPLEMENTS_POSIX\n#   if U_PLATFORM == U_PF_OS400\n#    define HAVE_DLFCN_H 0\n#    define HAVE_DLOPEN 0\n#   else\n#   ifndef HAVE_DLFCN_H\n#    define HAVE_DLFCN_H 1\n#   endif\n#   ifndef HAVE_DLOPEN\n#    define HAVE_DLOPEN 1\n#   endif\n#   endif\n#   ifndef HAVE_GETTIMEOFDAY\n#    define HAVE_GETTIMEOFDAY 1\n#   endif\n#else\n#   define HAVE_DLFCN_H 0\n#   define HAVE_DLOPEN 0\n#   define HAVE_GETTIMEOFDAY 0\n#endif\n\nU_NAMESPACE_USE\n\n/* Define the extension for data files, again... */\n#define DATA_TYPE \"dat\"\n\n/* Leave this copyright notice here! */\nstatic const char copyright[] = U_COPYRIGHT_STRING;\n\n/* floating point implementations ------------------------------------------- */\n\n/* We return QNAN rather than SNAN*/\n#define SIGN 0x80000000U\n\n/* Make it easy to define certain types of constants */\ntypedef union {\n    int64_t i64; /* This must be defined first in order to allow the initialization to work. This is a C89 feature. */\n    double d64;\n} BitPatternConversion;\nstatic const BitPatternConversion gNan = { (int64_t) INT64_C(0x7FF8000000000000) };\nstatic const BitPatternConversion gInf = { (int64_t) INT64_C(0x7FF0000000000000) };\n\n/*---------------------------------------------------------------------------\n  Platform utilities\n  Our general strategy is to assume we're on a POSIX platform.  Platforms which\n  are non-POSIX must declare themselves so.  The default POSIX implementation\n  will sometimes work for non-POSIX platforms as well (e.g., the NaN-related\n  functions).\n  ---------------------------------------------------------------------------*/\n\n#if U_PLATFORM_USES_ONLY_WIN32_API || U_PLATFORM == U_PF_OS400\n#   undef U_POSIX_LOCALE\n#else\n#   define U_POSIX_LOCALE    1\n#endif\n\n/*\n    WARNING! u_topNBytesOfDouble and u_bottomNBytesOfDouble\n    can't be properly optimized by the gcc compiler sometimes (i.e. gcc 3.2).\n*/\n#if !IEEE_754\nstatic char*\nu_topNBytesOfDouble(double* d, int n)\n{\n#if U_IS_BIG_ENDIAN\n    return (char*)d;\n#else\n    return (char*)(d + 1) - n;\n#endif\n}\n\nstatic char*\nu_bottomNBytesOfDouble(double* d, int n)\n{\n#if U_IS_BIG_ENDIAN\n    return (char*)(d + 1) - n;\n#else\n    return (char*)d;\n#endif\n}\n#endif   /* !IEEE_754 */\n\n#if IEEE_754\nstatic UBool\nu_signBit(double d) {\n    uint8_t hiByte;\n#if U_IS_BIG_ENDIAN\n    hiByte = *(uint8_t *)&d;\n#else\n    hiByte = *(((uint8_t *)&d) + sizeof(double) - 1);\n#endif\n    return (hiByte & 0x80) != 0;\n}\n#endif\n\n\n\n#if defined (U_DEBUG_FAKETIME)\n/* Override the clock to test things without having to move the system clock.\n * Assumes POSIX gettimeofday() will function\n */\nUDate fakeClock_t0 = 0; /** Time to start the clock from **/\nUDate fakeClock_dt = 0; /** Offset (fake time - real time) **/\nUBool fakeClock_set = FALSE; /** True if fake clock has spun up **/\nstatic UMutex fakeClockMutex = U_MUTEX_INTIALIZER;\n\nstatic UDate getUTCtime_real() {\n    struct timeval posixTime;\n    gettimeofday(&posixTime, NULL);\n    return (UDate)(((int64_t)posixTime.tv_sec * U_MILLIS_PER_SECOND) + (posixTime.tv_usec/1000));\n}\n\nstatic UDate getUTCtime_fake() {\n    umtx_lock(&fakeClockMutex);\n    if(!fakeClock_set) {\n        UDate real = getUTCtime_real();\n        const char *fake_start = getenv(\"U_FAKETIME_START\");\n        if((fake_start!=NULL) && (fake_start[0]!=0)) {\n            sscanf(fake_start,\"%lf\",&fakeClock_t0);\n            fakeClock_dt = fakeClock_t0 - real;\n            fprintf(stderr,\"U_DEBUG_FAKETIME was set at compile time, so the ICU clock will start at a preset value\\n\"\n                    \"env variable U_FAKETIME_START=%.0f (%s) for an offset of %.0f ms from the current time %.0f\\n\",\n                    fakeClock_t0, fake_start, fakeClock_dt, real);\n        } else {\n          fakeClock_dt = 0;\n            fprintf(stderr,\"U_DEBUG_FAKETIME was set at compile time, but U_FAKETIME_START was not set.\\n\"\n                    \"Set U_FAKETIME_START to the number of milliseconds since 1/1/1970 to set the ICU clock.\\n\");\n        }\n        fakeClock_set = TRUE;\n    }\n    umtx_unlock(&fakeClockMutex);\n\n    return getUTCtime_real() + fakeClock_dt;\n}\n#endif\n\n#if U_PLATFORM_USES_ONLY_WIN32_API\ntypedef union {\n    int64_t int64;\n    FILETIME fileTime;\n} FileTimeConversion;   /* This is like a ULARGE_INTEGER */\n\n/* Number of 100 nanoseconds from 1/1/1601 to 1/1/1970 */\n#define EPOCH_BIAS  INT64_C(116444736000000000)\n#define HECTONANOSECOND_PER_MILLISECOND   10000\n\n#endif\n\n/*---------------------------------------------------------------------------\n  Universal Implementations\n  These are designed to work on all platforms.  Try these, and if they\n  don't work on your platform, then special case your platform with new\n  implementations.\n---------------------------------------------------------------------------*/\n\nU_CAPI UDate U_EXPORT2\nuprv_getUTCtime()\n{\n#if defined(U_DEBUG_FAKETIME)\n    return getUTCtime_fake(); /* Hook for overriding the clock */\n#else\n    return uprv_getRawUTCtime();\n#endif\n}\n\n/* Return UTC (GMT) time measured in milliseconds since 0:00 on 1/1/70.*/\nU_CAPI UDate U_EXPORT2\nuprv_getRawUTCtime()\n{\n#if U_PLATFORM_USES_ONLY_WIN32_API\n\n    FileTimeConversion winTime;\n    GetSystemTimeAsFileTime(&winTime.fileTime);\n    return (UDate)((winTime.int64 - EPOCH_BIAS) / HECTONANOSECOND_PER_MILLISECOND);\n#else\n\n#if HAVE_GETTIMEOFDAY\n    struct timeval posixTime;\n    gettimeofday(&posixTime, NULL);\n    return (UDate)(((int64_t)posixTime.tv_sec * U_MILLIS_PER_SECOND) + (posixTime.tv_usec/1000));\n#else\n    time_t epochtime;\n    time(&epochtime);\n    return (UDate)epochtime * U_MILLIS_PER_SECOND;\n#endif\n\n#endif\n}\n\n/*-----------------------------------------------------------------------------\n  IEEE 754\n  These methods detect and return NaN and infinity values for doubles\n  conforming to IEEE 754.  Platforms which support this standard include X86,\n  Mac 680x0, Mac PowerPC, AIX RS/6000, and most others.\n  If this doesn't work on your platform, you have non-IEEE floating-point, and\n  will need to code your own versions.  A naive implementation is to return 0.0\n  for getNaN and getInfinity, and false for isNaN and isInfinite.\n  ---------------------------------------------------------------------------*/\n\nU_CAPI UBool U_EXPORT2\nuprv_isNaN(double number)\n{\n#if IEEE_754\n    BitPatternConversion convertedNumber;\n    convertedNumber.d64 = number;\n    /* Infinity is 0x7FF0000000000000U. Anything greater than that is a NaN */\n    return (UBool)((convertedNumber.i64 & U_INT64_MAX) > gInf.i64);\n\n#elif U_PLATFORM == U_PF_OS390\n    uint32_t highBits = *(uint32_t*)u_topNBytesOfDouble(&number,\n                        sizeof(uint32_t));\n    uint32_t lowBits  = *(uint32_t*)u_bottomNBytesOfDouble(&number,\n                        sizeof(uint32_t));\n\n    return ((highBits & 0x7F080000L) == 0x7F080000L) &&\n      (lowBits == 0x00000000L);\n\n#else\n    /* If your platform doesn't support IEEE 754 but *does* have an NaN value,*/\n    /* you'll need to replace this default implementation with what's correct*/\n    /* for your platform.*/\n    return number != number;\n#endif\n}\n\nU_CAPI UBool U_EXPORT2\nuprv_isInfinite(double number)\n{\n#if IEEE_754\n    BitPatternConversion convertedNumber;\n    convertedNumber.d64 = number;\n    /* Infinity is exactly 0x7FF0000000000000U. */\n    return (UBool)((convertedNumber.i64 & U_INT64_MAX) == gInf.i64);\n#elif U_PLATFORM == U_PF_OS390\n    uint32_t highBits = *(uint32_t*)u_topNBytesOfDouble(&number,\n                        sizeof(uint32_t));\n    uint32_t lowBits  = *(uint32_t*)u_bottomNBytesOfDouble(&number,\n                        sizeof(uint32_t));\n\n    return ((highBits  & ~SIGN) == 0x70FF0000L) && (lowBits == 0x00000000L);\n\n#else\n    /* If your platform doesn't support IEEE 754 but *does* have an infinity*/\n    /* value, you'll need to replace this default implementation with what's*/\n    /* correct for your platform.*/\n    return number == (2.0 * number);\n#endif\n}\n\nU_CAPI UBool U_EXPORT2\nuprv_isPositiveInfinity(double number)\n{\n#if IEEE_754 || U_PLATFORM == U_PF_OS390\n    return (UBool)(number > 0 && uprv_isInfinite(number));\n#else\n    return uprv_isInfinite(number);\n#endif\n}\n\nU_CAPI UBool U_EXPORT2\nuprv_isNegativeInfinity(double number)\n{\n#if IEEE_754 || U_PLATFORM == U_PF_OS390\n    return (UBool)(number < 0 && uprv_isInfinite(number));\n\n#else\n    uint32_t highBits = *(uint32_t*)u_topNBytesOfDouble(&number,\n                        sizeof(uint32_t));\n    return((highBits & SIGN) && uprv_isInfinite(number));\n\n#endif\n}\n\nU_CAPI double U_EXPORT2\nuprv_getNaN()\n{\n#if IEEE_754 || U_PLATFORM == U_PF_OS390\n    return gNan.d64;\n#else\n    /* If your platform doesn't support IEEE 754 but *does* have an NaN value,*/\n    /* you'll need to replace this default implementation with what's correct*/\n    /* for your platform.*/\n    return 0.0;\n#endif\n}\n\nU_CAPI double U_EXPORT2\nuprv_getInfinity()\n{\n#if IEEE_754 || U_PLATFORM == U_PF_OS390\n    return gInf.d64;\n#else\n    /* If your platform doesn't support IEEE 754 but *does* have an infinity*/\n    /* value, you'll need to replace this default implementation with what's*/\n    /* correct for your platform.*/\n    return 0.0;\n#endif\n}\n\nU_CAPI double U_EXPORT2\nuprv_floor(double x)\n{\n    return floor(x);\n}\n\nU_CAPI double U_EXPORT2\nuprv_ceil(double x)\n{\n    return ceil(x);\n}\n\nU_CAPI double U_EXPORT2\nuprv_round(double x)\n{\n    return uprv_floor(x + 0.5);\n}\n\nU_CAPI double U_EXPORT2\nuprv_fabs(double x)\n{\n    return fabs(x);\n}\n\nU_CAPI double U_EXPORT2\nuprv_modf(double x, double* y)\n{\n    return modf(x, y);\n}\n\nU_CAPI double U_EXPORT2\nuprv_fmod(double x, double y)\n{\n    return fmod(x, y);\n}\n\nU_CAPI double U_EXPORT2\nuprv_pow(double x, double y)\n{\n    /* This is declared as \"double pow(double x, double y)\" */\n    return pow(x, y);\n}\n\nU_CAPI double U_EXPORT2\nuprv_pow10(int32_t x)\n{\n    return pow(10.0, (double)x);\n}\n\nU_CAPI double U_EXPORT2\nuprv_fmax(double x, double y)\n{\n#if IEEE_754\n    /* first handle NaN*/\n    if(uprv_isNaN(x) || uprv_isNaN(y))\n        return uprv_getNaN();\n\n    /* check for -0 and 0*/\n    if(x == 0.0 && y == 0.0 && u_signBit(x))\n        return y;\n\n#endif\n\n    /* this should work for all flt point w/o NaN and Inf special cases */\n    return (x > y ? x : y);\n}\n\nU_CAPI double U_EXPORT2\nuprv_fmin(double x, double y)\n{\n#if IEEE_754\n    /* first handle NaN*/\n    if(uprv_isNaN(x) || uprv_isNaN(y))\n        return uprv_getNaN();\n\n    /* check for -0 and 0*/\n    if(x == 0.0 && y == 0.0 && u_signBit(y))\n        return y;\n\n#endif\n\n    /* this should work for all flt point w/o NaN and Inf special cases */\n    return (x > y ? y : x);\n}\n\n/**\n * Truncates the given double.\n * trunc(3.3) = 3.0, trunc (-3.3) = -3.0\n * This is different than calling floor() or ceil():\n * floor(3.3) = 3, floor(-3.3) = -4\n * ceil(3.3) = 4, ceil(-3.3) = -3\n */\nU_CAPI double U_EXPORT2\nuprv_trunc(double d)\n{\n#if IEEE_754\n    /* handle error cases*/\n    if(uprv_isNaN(d))\n        return uprv_getNaN();\n    if(uprv_isInfinite(d))\n        return uprv_getInfinity();\n\n    if(u_signBit(d))    /* Signbit() picks up -0.0;  d<0 does not. */\n        return ceil(d);\n    else\n        return floor(d);\n\n#else\n    return d >= 0 ? floor(d) : ceil(d);\n\n#endif\n}\n\n/**\n * Return the largest positive number that can be represented by an integer\n * type of arbitrary bit length.\n */\nU_CAPI double U_EXPORT2\nuprv_maxMantissa(void)\n{\n    return pow(2.0, DBL_MANT_DIG + 1.0) - 1.0;\n}\n\nU_CAPI double U_EXPORT2\nuprv_log(double d)\n{\n    return log(d);\n}\n\nU_CAPI void * U_EXPORT2\nuprv_maximumPtr(void * base)\n{\n#if U_PLATFORM == U_PF_OS400\n    /*\n     * With the provided function we should never be out of range of a given segment\n     * (a traditional/typical segment that is).  Our segments have 5 bytes for the\n     * id and 3 bytes for the offset.  The key is that the casting takes care of\n     * only retrieving the offset portion minus x1000.  Hence, the smallest offset\n     * seen in a program is x001000 and when casted to an int would be 0.\n     * That's why we can only add 0xffefff.  Otherwise, we would exceed the segment.\n     *\n     * Currently, 16MB is the current addressing limitation on i5/OS if the activation is\n     * non-TERASPACE.  If it is TERASPACE it is 2GB - 4k(header information).\n     * This function determines the activation based on the pointer that is passed in and\n     * calculates the appropriate maximum available size for\n     * each pointer type (TERASPACE and non-TERASPACE)\n     *\n     * Unlike other operating systems, the pointer model isn't determined at\n     * compile time on i5/OS.\n     */\n    if ((base != NULL) && (_TESTPTR(base, _C_TERASPACE_CHECK))) {\n        /* if it is a TERASPACE pointer the max is 2GB - 4k */\n        return ((void *)(((char *)base)-((uint32_t)(base))+((uint32_t)0x7fffefff)));\n    }\n    /* otherwise 16MB since NULL ptr is not checkable or the ptr is not TERASPACE */\n    return ((void *)(((char *)base)-((uint32_t)(base))+((uint32_t)0xffefff)));\n\n#else\n    return U_MAX_PTR(base);\n#endif\n}\n\n/*---------------------------------------------------------------------------\n  Platform-specific Implementations\n  Try these, and if they don't work on your platform, then special case your\n  platform with new implementations.\n  ---------------------------------------------------------------------------*/\n\n/* Generic time zone layer -------------------------------------------------- */\n\n/* Time zone utilities */\nU_CAPI void U_EXPORT2\nuprv_tzset()\n{\n#if defined(U_TZSET)\n    U_TZSET();\n#else\n    /* no initialization*/\n#endif\n}\n\nU_CAPI int32_t U_EXPORT2\nuprv_timezone()\n{\n#ifdef U_TIMEZONE\n    return U_TIMEZONE;\n#else\n    time_t t, t1, t2;\n    struct tm tmrec;\n    int32_t tdiff = 0;\n\n    time(&t);\n    uprv_memcpy( &tmrec, localtime(&t), sizeof(tmrec) );\n#if U_PLATFORM != U_PF_IPHONE\n    UBool dst_checked = (tmrec.tm_isdst != 0); /* daylight savings time is checked*/\n#endif\n    t1 = mktime(&tmrec);                 /* local time in seconds*/\n    uprv_memcpy( &tmrec, gmtime(&t), sizeof(tmrec) );\n    t2 = mktime(&tmrec);                 /* GMT (or UTC) in seconds*/\n    tdiff = t2 - t1;\n\n#if U_PLATFORM != U_PF_IPHONE\n    /* imitate NT behaviour, which returns same timezone offset to GMT for\n       winter and summer.\n       This does not work on all platforms. For instance, on glibc on Linux\n       and on Mac OS 10.5, tdiff calculated above remains the same\n       regardless of whether DST is in effect or not. iOS is another\n       platform where this does not work. Linux + glibc and Mac OS 10.5\n       have U_TIMEZONE defined so that this code is not reached.\n    */\n    if (dst_checked)\n        tdiff += 3600;\n#endif\n    return tdiff;\n#endif\n}\n\n/* Note that U_TZNAME does *not* have to be tzname, but if it is,\n   some platforms need to have it declared here. */\n\n#if defined(U_TZNAME) && (U_PLATFORM == U_PF_IRIX || U_PLATFORM_IS_DARWIN_BASED)\n/* RS6000 and others reject char **tzname.  */\nextern U_IMPORT char *U_TZNAME[];\n#endif\n\n#if !UCONFIG_NO_FILE_IO && ((U_PLATFORM_IS_DARWIN_BASED && (U_PLATFORM != U_PF_IPHONE || defined(U_TIMEZONE))) || U_PLATFORM_IS_LINUX_BASED || U_PLATFORM == U_PF_BSD || U_PLATFORM == U_PF_SOLARIS)\n/* These platforms are likely to use Olson timezone IDs. */\n#define CHECK_LOCALTIME_LINK 1\n#if U_PLATFORM_IS_DARWIN_BASED\n#include <tzfile.h>\n#define TZZONEINFO      (TZDIR \"/\")\n#elif U_PLATFORM == U_PF_SOLARIS\n#define TZDEFAULT       \"/etc/localtime\"\n#define TZZONEINFO      \"/usr/share/lib/zoneinfo/\"\n#define TZZONEINFO2     \"../usr/share/lib/zoneinfo/\"\n#define TZ_ENV_CHECK    \"localtime\"\n#else\n#define TZDEFAULT       \"/etc/localtime\"\n#define TZZONEINFO      \"/usr/share/zoneinfo/\"\n#endif\n#if U_HAVE_DIRENT_H\n#define TZFILE_SKIP     \"posixrules\" /* tz file to skip when searching. */\n/* Some Linux distributions have 'localtime' in /usr/share/zoneinfo\n   symlinked to /etc/localtime, which makes searchForTZFile return\n   'localtime' when it's the first match. */\n#define TZFILE_SKIP2    \"localtime\"\n#define SEARCH_TZFILE\n#include <dirent.h>  /* Needed to search through system timezone files */\n#endif\nstatic char gTimeZoneBuffer[PATH_MAX];\nstatic char *gTimeZoneBufferPtr = NULL;\n#endif\n\n#if !U_PLATFORM_USES_ONLY_WIN32_API\n#define isNonDigit(ch) (ch < '0' || '9' < ch)\nstatic UBool isValidOlsonID(const char *id) {\n    int32_t idx = 0;\n\n    /* Determine if this is something like Iceland (Olson ID)\n    or AST4ADT (non-Olson ID) */\n    while (id[idx] && isNonDigit(id[idx]) && id[idx] != ',') {\n        idx++;\n    }\n\n    /* If we went through the whole string, then it might be okay.\n    The timezone is sometimes set to \"CST-7CDT\", \"CST6CDT5,J129,J131/19:30\",\n    \"GRNLNDST3GRNLNDDT\" or similar, so we cannot use it.\n    The rest of the time it could be an Olson ID. George */\n    return (UBool)(id[idx] == 0\n        || uprv_strcmp(id, \"PST8PDT\") == 0\n        || uprv_strcmp(id, \"MST7MDT\") == 0\n        || uprv_strcmp(id, \"CST6CDT\") == 0\n        || uprv_strcmp(id, \"EST5EDT\") == 0);\n}\n\n/* On some Unix-like OS, 'posix' subdirectory in\n   /usr/share/zoneinfo replicates the top-level contents. 'right'\n   subdirectory has the same set of files, but individual files\n   are different from those in the top-level directory or 'posix'\n   because 'right' has files for TAI (Int'l Atomic Time) while 'posix'\n   has files for UTC.\n   When the first match for /etc/localtime is in either of them\n   (usually in posix because 'right' has different file contents),\n   or TZ environment variable points to one of them, createTimeZone\n   fails because, say, 'posix/America/New_York' is not an Olson\n   timezone id ('America/New_York' is). So, we have to skip\n   'posix/' and 'right/' at the beginning. */\nstatic void skipZoneIDPrefix(const char** id) {\n    if (uprv_strncmp(*id, \"posix/\", 6) == 0\n        || uprv_strncmp(*id, \"right/\", 6) == 0)\n    {\n        *id += 6;\n    }\n}\n#endif\n\n#if defined(U_TZNAME) && !U_PLATFORM_USES_ONLY_WIN32_API\n\n#define CONVERT_HOURS_TO_SECONDS(offset) (int32_t)(offset*3600)\ntypedef struct OffsetZoneMapping {\n    int32_t offsetSeconds;\n    int32_t daylightType; /* 0=U_DAYLIGHT_NONE, 1=daylight in June-U_DAYLIGHT_JUNE, 2=daylight in December=U_DAYLIGHT_DECEMBER*/\n    const char *stdID;\n    const char *dstID;\n    const char *olsonID;\n} OffsetZoneMapping;\n\nenum { U_DAYLIGHT_NONE=0,U_DAYLIGHT_JUNE=1,U_DAYLIGHT_DECEMBER=2 };\n\n/*\nThis list tries to disambiguate a set of abbreviated timezone IDs and offsets\nand maps it to an Olson ID.\nBefore adding anything to this list, take a look at\nicu/source/tools/tzcode/tz.alias\nSometimes no daylight savings (0) is important to define due to aliases.\nThis list can be tested with icu/source/test/compat/tzone.pl\nMore values could be added to daylightType to increase precision.\n*/\nstatic const struct OffsetZoneMapping OFFSET_ZONE_MAPPINGS[] = {\n    {-45900, 2, \"CHAST\", \"CHADT\", \"Pacific/Chatham\"},\n    {-43200, 1, \"PETT\", \"PETST\", \"Asia/Kamchatka\"},\n    {-43200, 2, \"NZST\", \"NZDT\", \"Pacific/Auckland\"},\n    {-43200, 1, \"ANAT\", \"ANAST\", \"Asia/Anadyr\"},\n    {-39600, 1, \"MAGT\", \"MAGST\", \"Asia/Magadan\"},\n    {-37800, 2, \"LHST\", \"LHST\", \"Australia/Lord_Howe\"},\n    {-36000, 2, \"EST\", \"EST\", \"Australia/Sydney\"},\n    {-36000, 1, \"SAKT\", \"SAKST\", \"Asia/Sakhalin\"},\n    {-36000, 1, \"VLAT\", \"VLAST\", \"Asia/Vladivostok\"},\n    {-34200, 2, \"CST\", \"CST\", \"Australia/South\"},\n    {-32400, 1, \"YAKT\", \"YAKST\", \"Asia/Yakutsk\"},\n    {-32400, 1, \"CHOT\", \"CHOST\", \"Asia/Choibalsan\"},\n    {-31500, 2, \"CWST\", \"CWST\", \"Australia/Eucla\"},\n    {-28800, 1, \"IRKT\", \"IRKST\", \"Asia/Irkutsk\"},\n    {-28800, 1, \"ULAT\", \"ULAST\", \"Asia/Ulaanbaatar\"},\n    {-28800, 2, \"WST\", \"WST\", \"Australia/West\"},\n    {-25200, 1, \"HOVT\", \"HOVST\", \"Asia/Hovd\"},\n    {-25200, 1, \"KRAT\", \"KRAST\", \"Asia/Krasnoyarsk\"},\n    {-21600, 1, \"NOVT\", \"NOVST\", \"Asia/Novosibirsk\"},\n    {-21600, 1, \"OMST\", \"OMSST\", \"Asia/Omsk\"},\n    {-18000, 1, \"YEKT\", \"YEKST\", \"Asia/Yekaterinburg\"},\n    {-14400, 1, \"SAMT\", \"SAMST\", \"Europe/Samara\"},\n    {-14400, 1, \"AMT\", \"AMST\", \"Asia/Yerevan\"},\n    {-14400, 1, \"AZT\", \"AZST\", \"Asia/Baku\"},\n    {-10800, 1, \"AST\", \"ADT\", \"Asia/Baghdad\"},\n    {-10800, 1, \"MSK\", \"MSD\", \"Europe/Moscow\"},\n    {-10800, 1, \"VOLT\", \"VOLST\", \"Europe/Volgograd\"},\n    {-7200, 0, \"EET\", \"CEST\", \"Africa/Tripoli\"},\n    {-7200, 1, \"EET\", \"EEST\", \"Europe/Athens\"}, /* Conflicts with Africa/Cairo */\n    {-7200, 1, \"IST\", \"IDT\", \"Asia/Jerusalem\"},\n    {-3600, 0, \"CET\", \"WEST\", \"Africa/Algiers\"},\n    {-3600, 2, \"WAT\", \"WAST\", \"Africa/Windhoek\"},\n    {0, 1, \"GMT\", \"IST\", \"Europe/Dublin\"},\n    {0, 1, \"GMT\", \"BST\", \"Europe/London\"},\n    {0, 0, \"WET\", \"WEST\", \"Africa/Casablanca\"},\n    {0, 0, \"WET\", \"WET\", \"Africa/El_Aaiun\"},\n    {3600, 1, \"AZOT\", \"AZOST\", \"Atlantic/Azores\"},\n    {3600, 1, \"EGT\", \"EGST\", \"America/Scoresbysund\"},\n    {10800, 1, \"PMST\", \"PMDT\", \"America/Miquelon\"},\n    {10800, 2, \"UYT\", \"UYST\", \"America/Montevideo\"},\n    {10800, 1, \"WGT\", \"WGST\", \"America/Godthab\"},\n    {10800, 2, \"BRT\", \"BRST\", \"Brazil/East\"},\n    {12600, 1, \"NST\", \"NDT\", \"America/St_Johns\"},\n    {14400, 1, \"AST\", \"ADT\", \"Canada/Atlantic\"},\n    {14400, 2, \"AMT\", \"AMST\", \"America/Cuiaba\"},\n    {14400, 2, \"CLT\", \"CLST\", \"Chile/Continental\"},\n    {14400, 2, \"FKT\", \"FKST\", \"Atlantic/Stanley\"},\n    {14400, 2, \"PYT\", \"PYST\", \"America/Asuncion\"},\n    {18000, 1, \"CST\", \"CDT\", \"America/Havana\"},\n    {18000, 1, \"EST\", \"EDT\", \"US/Eastern\"}, /* Conflicts with America/Grand_Turk */\n    {21600, 2, \"EAST\", \"EASST\", \"Chile/EasterIsland\"},\n    {21600, 0, \"CST\", \"MDT\", \"Canada/Saskatchewan\"},\n    {21600, 0, \"CST\", \"CDT\", \"America/Guatemala\"},\n    {21600, 1, \"CST\", \"CDT\", \"US/Central\"}, /* Conflicts with Mexico/General */\n    {25200, 1, \"MST\", \"MDT\", \"US/Mountain\"}, /* Conflicts with Mexico/BajaSur */\n    {28800, 0, \"PST\", \"PST\", \"Pacific/Pitcairn\"},\n    {28800, 1, \"PST\", \"PDT\", \"US/Pacific\"}, /* Conflicts with Mexico/BajaNorte */\n    {32400, 1, \"AKST\", \"AKDT\", \"US/Alaska\"},\n    {36000, 1, \"HAST\", \"HADT\", \"US/Aleutian\"}\n};\n\n/*#define DEBUG_TZNAME*/\n\nstatic const char* remapShortTimeZone(const char *stdID, const char *dstID, int32_t daylightType, int32_t offset)\n{\n    int32_t idx;\n#ifdef DEBUG_TZNAME\n    fprintf(stderr, \"TZ=%s std=%s dst=%s daylight=%d offset=%d\\n\", getenv(\"TZ\"), stdID, dstID, daylightType, offset);\n#endif\n    for (idx = 0; idx < UPRV_LENGTHOF(OFFSET_ZONE_MAPPINGS); idx++)\n    {\n        if (offset == OFFSET_ZONE_MAPPINGS[idx].offsetSeconds\n            && daylightType == OFFSET_ZONE_MAPPINGS[idx].daylightType\n            && strcmp(OFFSET_ZONE_MAPPINGS[idx].stdID, stdID) == 0\n            && strcmp(OFFSET_ZONE_MAPPINGS[idx].dstID, dstID) == 0)\n        {\n            return OFFSET_ZONE_MAPPINGS[idx].olsonID;\n        }\n    }\n    return NULL;\n}\n#endif\n\n#ifdef SEARCH_TZFILE\n#define MAX_READ_SIZE 512\n\ntypedef struct DefaultTZInfo {\n    char* defaultTZBuffer;\n    int64_t defaultTZFileSize;\n    FILE* defaultTZFilePtr;\n    UBool defaultTZstatus;\n    int32_t defaultTZPosition;\n} DefaultTZInfo;\n\n/*\n * This method compares the two files given to see if they are a match.\n * It is currently use to compare two TZ files.\n */\nstatic UBool compareBinaryFiles(const char* defaultTZFileName, const char* TZFileName, DefaultTZInfo* tzInfo) {\n    FILE* file; \n    int64_t sizeFile;\n    int64_t sizeFileLeft;\n    int32_t sizeFileRead;\n    int32_t sizeFileToRead;\n    char bufferFile[MAX_READ_SIZE];\n    UBool result = TRUE;\n\n    if (tzInfo->defaultTZFilePtr == NULL) {\n        tzInfo->defaultTZFilePtr = fopen(defaultTZFileName, \"r\");\n    }\n    file = fopen(TZFileName, \"r\");\n\n    tzInfo->defaultTZPosition = 0; /* reset position to begin search */\n\n    if (file != NULL && tzInfo->defaultTZFilePtr != NULL) {\n        /* First check that the file size are equal. */\n        if (tzInfo->defaultTZFileSize == 0) {\n            fseek(tzInfo->defaultTZFilePtr, 0, SEEK_END);\n            tzInfo->defaultTZFileSize = ftell(tzInfo->defaultTZFilePtr);\n        }\n        fseek(file, 0, SEEK_END);\n        sizeFile = ftell(file);\n        sizeFileLeft = sizeFile;\n\n        if (sizeFile != tzInfo->defaultTZFileSize) {\n            result = FALSE;\n        } else {\n            /* Store the data from the files in seperate buffers and\n             * compare each byte to determine equality.\n             */\n            if (tzInfo->defaultTZBuffer == NULL) {\n                rewind(tzInfo->defaultTZFilePtr);\n                tzInfo->defaultTZBuffer = (char*)uprv_malloc(sizeof(char) * tzInfo->defaultTZFileSize);\n                sizeFileRead = fread(tzInfo->defaultTZBuffer, 1, tzInfo->defaultTZFileSize, tzInfo->defaultTZFilePtr);\n            }\n            rewind(file);\n            while(sizeFileLeft > 0) {\n                uprv_memset(bufferFile, 0, MAX_READ_SIZE);\n                sizeFileToRead = sizeFileLeft < MAX_READ_SIZE ? sizeFileLeft : MAX_READ_SIZE;\n\n                sizeFileRead = fread(bufferFile, 1, sizeFileToRead, file);\n                if (memcmp(tzInfo->defaultTZBuffer + tzInfo->defaultTZPosition, bufferFile, sizeFileRead) != 0) {\n                    result = FALSE;\n                    break;\n                }\n                sizeFileLeft -= sizeFileRead;\n                tzInfo->defaultTZPosition += sizeFileRead;\n            }\n        }\n    } else {\n        result = FALSE;\n    }\n\n    if (file != NULL) {\n        fclose(file);\n    }\n\n    return result;\n}\n\n\n/* dirent also lists two entries: \".\" and \"..\" that we can safely ignore. */\n#define SKIP1 \".\"\n#define SKIP2 \"..\"\nstatic UBool U_CALLCONV putil_cleanup(void);\nstatic CharString *gSearchTZFileResult = NULL;\n\n/*\n * This method recursively traverses the directory given for a matching TZ file and returns the first match.\n * This function is not thread safe - it uses a global, gSearchTZFileResult, to hold its results.\n */\nstatic char* searchForTZFile(const char* path, DefaultTZInfo* tzInfo) {\n    DIR* dirp = opendir(path);\n    DIR* subDirp = NULL;\n    struct dirent* dirEntry = NULL;\n\n    char* result = NULL;\n    if (dirp == NULL) {\n        return result;\n    }\n\n    if (gSearchTZFileResult == NULL) {\n        gSearchTZFileResult = new CharString;\n        if (gSearchTZFileResult == NULL) {\n            return NULL;\n        }\n        ucln_common_registerCleanup(UCLN_COMMON_PUTIL, putil_cleanup);\n    }\n\n    /* Save the current path */\n    UErrorCode status = U_ZERO_ERROR;\n    CharString curpath(path, -1, status);\n    if (U_FAILURE(status)) {\n        return NULL;\n    }\n\n    /* Check each entry in the directory. */\n    while((dirEntry = readdir(dirp)) != NULL) {\n        const char* dirName = dirEntry->d_name;\n        if (uprv_strcmp(dirName, SKIP1) != 0 && uprv_strcmp(dirName, SKIP2) != 0) {\n            /* Create a newpath with the new entry to test each entry in the directory. */\n            CharString newpath(curpath, status);\n            newpath.append(dirName, -1, status);\n            if (U_FAILURE(status)) {\n                return NULL;\n            }\n\n            if ((subDirp = opendir(newpath.data())) != NULL) {\n                /* If this new path is a directory, make a recursive call with the newpath. */\n                closedir(subDirp);\n                newpath.append('/', status);\n                if (U_FAILURE(status)) {\n                    return NULL;\n                }\n                result = searchForTZFile(newpath.data(), tzInfo);\n                /*\n                 Have to get out here. Otherwise, we'd keep looking\n                 and return the first match in the top-level directory\n                 if there's a match in the top-level. If not, this function\n                 would return NULL and set gTimeZoneBufferPtr to NULL in initDefault().\n                 It worked without this in most cases because we have a fallback of calling\n                 localtime_r to figure out the default timezone.\n                */\n                if (result != NULL)\n                    break;\n            } else if (uprv_strcmp(TZFILE_SKIP, dirName) != 0 && uprv_strcmp(TZFILE_SKIP2, dirName) != 0) {\n                if(compareBinaryFiles(TZDEFAULT, newpath.data(), tzInfo)) {\n                    int32_t amountToSkip = sizeof(TZZONEINFO) - 1;\n                    if (amountToSkip > newpath.length()) {\n                        amountToSkip = newpath.length();\n                    }\n                    const char* zoneid = newpath.data() + amountToSkip;\n                    skipZoneIDPrefix(&zoneid);\n                    gSearchTZFileResult->clear();\n                    gSearchTZFileResult->append(zoneid, -1, status);\n                    if (U_FAILURE(status)) {\n                        return NULL;\n                    }\n                    result = gSearchTZFileResult->data();\n                    /* Get out after the first one found. */\n                    break;\n                }\n            }\n        }\n    }\n    closedir(dirp);\n    return result;\n}\n#endif\n\nU_CAPI void U_EXPORT2\nuprv_tzname_clear_cache()\n{\n#if defined(CHECK_LOCALTIME_LINK) && !defined(DEBUG_SKIP_LOCALTIME_LINK)\n    gTimeZoneBufferPtr = NULL;\n#endif\n}\n\n// With the Universal Windows Platform we can just ask Windows for the name\n#if U_PLATFORM_HAS_WINUWP_API\nU_CAPI const char* U_EXPORT2\nuprv_getWindowsTimeZone()\n{\n    // Get default Windows timezone.   \n    ComPtr<IInspectable> calendar;\n    HRESULT hr = RoActivateInstance(\n        HStringReference(RuntimeClass_Windows_Globalization_Calendar).Get(),\n        &calendar);\n    if (SUCCEEDED(hr))\n    {\n        ComPtr<ABI::Windows::Globalization::ITimeZoneOnCalendar> timezone;\n        hr = calendar.As(&timezone);\n        if (SUCCEEDED(hr))\n        {\n            HString timezoneString;\n            hr = timezone->GetTimeZone(timezoneString.GetAddressOf());\n            if (SUCCEEDED(hr))\n            {\n                int32_t length = wcslen(timezoneString.GetRawBuffer(NULL));\n                char* asciiId = (char*)uprv_calloc(length + 1, sizeof(char));\n                if (asciiId != nullptr)\n                {\n                    u_UCharsToChars((UChar*)timezoneString.GetRawBuffer(NULL), asciiId, length);\n                    return asciiId;\n                }\n            }\n        }\n    }\n\n    // Failed\n    return nullptr;\n}\n#endif\n\nU_CAPI const char* U_EXPORT2\nuprv_tzname(int n)\n{\n    const char *tzid = NULL;\n#if U_PLATFORM_USES_ONLY_WIN32_API\n#if U_PLATFORM_HAS_WINUWP_API > 0\n    tzid = uprv_getWindowsTimeZone();\n#else\n    tzid = uprv_detectWindowsTimeZone();\n#endif\n\n    if (tzid != NULL) {\n        return tzid;\n    }\n\n#ifndef U_TZNAME\n    // The return value is free'd in timezone.cpp on Windows because\n    // the other code path returns a pointer to a heap location.\n    // If we don't have a name already, then tzname wouldn't be any\n    // better, so just fall back.\n    return uprv_strdup(\"Etc/UTC\");\n#endif // !U_TZNAME\n\n#else\n\n/*#if U_PLATFORM_IS_DARWIN_BASED\n    int ret;\n\n    tzid = getenv(\"TZFILE\");\n    if (tzid != NULL) {\n        return tzid;\n    }\n#endif*/\n\n/* This code can be temporarily disabled to test tzname resolution later on. */\n#ifndef DEBUG_TZNAME\n    tzid = getenv(\"TZ\");\n    if (tzid != NULL && isValidOlsonID(tzid)\n#if U_PLATFORM == U_PF_SOLARIS\n    /* When TZ equals localtime on Solaris, check the /etc/localtime file. */\n        && uprv_strcmp(tzid, TZ_ENV_CHECK) != 0\n#endif\n    ) {\n        /* The colon forces tzset() to treat the remainder as zoneinfo path */ \n        if (tzid[0] == ':') { \n            tzid++; \n        } \n        /* This might be a good Olson ID. */\n        skipZoneIDPrefix(&tzid);\n        return tzid;\n    }\n    /* else U_TZNAME will give a better result. */\n#endif\n\n#if defined(CHECK_LOCALTIME_LINK) && !defined(DEBUG_SKIP_LOCALTIME_LINK)\n    /* Caller must handle threading issues */\n    if (gTimeZoneBufferPtr == NULL) {\n        /*\n        This is a trick to look at the name of the link to get the Olson ID\n        because the tzfile contents is underspecified.\n        This isn't guaranteed to work because it may not be a symlink.\n        */\n        int32_t ret = (int32_t)readlink(TZDEFAULT, gTimeZoneBuffer, sizeof(gTimeZoneBuffer)-1);\n        if (0 < ret) {\n            int32_t tzZoneInfoLen = uprv_strlen(TZZONEINFO);\n            gTimeZoneBuffer[ret] = 0;\n            if (uprv_strncmp(gTimeZoneBuffer, TZZONEINFO, tzZoneInfoLen) == 0\n                && isValidOlsonID(gTimeZoneBuffer + tzZoneInfoLen))\n            {\n                return (gTimeZoneBufferPtr = gTimeZoneBuffer + tzZoneInfoLen);\n            }\n#if U_PLATFORM == U_PF_SOLARIS\n            else\n            {\n                tzZoneInfoLen = uprv_strlen(TZZONEINFO2);\n                if (uprv_strncmp(gTimeZoneBuffer, TZZONEINFO2, tzZoneInfoLen) == 0\n                                && isValidOlsonID(gTimeZoneBuffer + tzZoneInfoLen))\n                {\n                    return (gTimeZoneBufferPtr = gTimeZoneBuffer + tzZoneInfoLen);\n                }\n            }\n#endif\n        } else {\n#if defined(SEARCH_TZFILE)\n            DefaultTZInfo* tzInfo = (DefaultTZInfo*)uprv_malloc(sizeof(DefaultTZInfo));\n            if (tzInfo != NULL) {\n                tzInfo->defaultTZBuffer = NULL;\n                tzInfo->defaultTZFileSize = 0;\n                tzInfo->defaultTZFilePtr = NULL;\n                tzInfo->defaultTZstatus = FALSE;\n                tzInfo->defaultTZPosition = 0;\n\n                gTimeZoneBufferPtr = searchForTZFile(TZZONEINFO, tzInfo);\n\n                /* Free previously allocated memory */\n                if (tzInfo->defaultTZBuffer != NULL) {\n                    uprv_free(tzInfo->defaultTZBuffer);\n                }\n                if (tzInfo->defaultTZFilePtr != NULL) {\n                    fclose(tzInfo->defaultTZFilePtr);\n                }\n                uprv_free(tzInfo);\n            }\n\n            if (gTimeZoneBufferPtr != NULL && isValidOlsonID(gTimeZoneBufferPtr)) {\n                return gTimeZoneBufferPtr;\n            }\n#endif\n        }\n    }\n    else {\n        return gTimeZoneBufferPtr;\n    }\n#endif\n#endif\n\n#ifdef U_TZNAME\n#if U_PLATFORM_USES_ONLY_WIN32_API\n    /* The return value is free'd in timezone.cpp on Windows because\n     * the other code path returns a pointer to a heap location. */\n    return uprv_strdup(U_TZNAME[n]);\n#else\n    /*\n    U_TZNAME is usually a non-unique abbreviation, which isn't normally usable.\n    So we remap the abbreviation to an olson ID.\n\n    Since Windows exposes a little more timezone information,\n    we normally don't use this code on Windows because\n    uprv_detectWindowsTimeZone should have already given the correct answer.\n    */\n    {\n        struct tm juneSol, decemberSol;\n        int daylightType;\n        static const time_t juneSolstice=1182478260; /*2007-06-21 18:11 UT*/\n        static const time_t decemberSolstice=1198332540; /*2007-12-22 06:09 UT*/\n\n        /* This probing will tell us when daylight savings occurs.  */\n        localtime_r(&juneSolstice, &juneSol);\n        localtime_r(&decemberSolstice, &decemberSol);\n        if(decemberSol.tm_isdst > 0) {\n          daylightType = U_DAYLIGHT_DECEMBER;\n        } else if(juneSol.tm_isdst > 0) {\n          daylightType = U_DAYLIGHT_JUNE;\n        } else {\n          daylightType = U_DAYLIGHT_NONE;\n        }\n        tzid = remapShortTimeZone(U_TZNAME[0], U_TZNAME[1], daylightType, uprv_timezone());\n        if (tzid != NULL) {\n            return tzid;\n        }\n    }\n    return U_TZNAME[n];\n#endif\n#else\n    return \"\";\n#endif\n}\n\n/* Get and set the ICU data directory --------------------------------------- */\n\nstatic icu::UInitOnce gDataDirInitOnce = U_INITONCE_INITIALIZER;\nstatic char *gDataDirectory = NULL;\n\nUInitOnce gTimeZoneFilesInitOnce = U_INITONCE_INITIALIZER;\nstatic CharString *gTimeZoneFilesDirectory = NULL;\n\n#if U_POSIX_LOCALE || U_PLATFORM_USES_ONLY_WIN32_API\n static char *gCorrectedPOSIXLocale = NULL; /* Sometimes heap allocated */\n static bool gCorrectedPOSIXLocaleHeapAllocated = false;\n#endif\n\nstatic UBool U_CALLCONV putil_cleanup(void)\n{\n    if (gDataDirectory && *gDataDirectory) {\n        uprv_free(gDataDirectory);\n    }\n    gDataDirectory = NULL;\n    gDataDirInitOnce.reset();\n\n    delete gTimeZoneFilesDirectory;\n    gTimeZoneFilesDirectory = NULL;\n    gTimeZoneFilesInitOnce.reset();\n\n#ifdef SEARCH_TZFILE\n    delete gSearchTZFileResult;\n    gSearchTZFileResult = NULL;\n#endif\n\n#if U_POSIX_LOCALE || U_PLATFORM_USES_ONLY_WIN32_API\n    if (gCorrectedPOSIXLocale && gCorrectedPOSIXLocaleHeapAllocated) {\n        uprv_free(gCorrectedPOSIXLocale);\n        gCorrectedPOSIXLocale = NULL;\n        gCorrectedPOSIXLocaleHeapAllocated = false;\n    }\n#endif\n    return TRUE;\n}\n\n/*\n * Set the data directory.\n *    Make a copy of the passed string, and set the global data dir to point to it.\n */\nU_CAPI void U_EXPORT2\nu_setDataDirectory(const char *directory) {\n    char *newDataDir;\n    int32_t length;\n\n    if(directory==NULL || *directory==0) {\n        /* A small optimization to prevent the malloc and copy when the\n        shared library is used, and this is a way to make sure that NULL\n        is never returned.\n        */\n        newDataDir = (char *)\"\";\n    }\n    else {\n        length=(int32_t)uprv_strlen(directory);\n        newDataDir = (char *)uprv_malloc(length + 2);\n        /* Exit out if newDataDir could not be created. */\n        if (newDataDir == NULL) {\n            return;\n        }\n        uprv_strcpy(newDataDir, directory);\n\n#if (U_FILE_SEP_CHAR != U_FILE_ALT_SEP_CHAR)\n        {\n            char *p;\n            while(p = uprv_strchr(newDataDir, U_FILE_ALT_SEP_CHAR)) {\n                *p = U_FILE_SEP_CHAR;\n            }\n        }\n#endif\n    }\n\n    if (gDataDirectory && *gDataDirectory) {\n        uprv_free(gDataDirectory);\n    }\n    gDataDirectory = newDataDir;\n    ucln_common_registerCleanup(UCLN_COMMON_PUTIL, putil_cleanup);\n}\n\nU_CAPI UBool U_EXPORT2\nuprv_pathIsAbsolute(const char *path)\n{\n  if(!path || !*path) {\n    return FALSE;\n  }\n\n  if(*path == U_FILE_SEP_CHAR) {\n    return TRUE;\n  }\n\n#if (U_FILE_SEP_CHAR != U_FILE_ALT_SEP_CHAR)\n  if(*path == U_FILE_ALT_SEP_CHAR) {\n    return TRUE;\n  }\n#endif\n\n#if U_PLATFORM_USES_ONLY_WIN32_API\n  if( (((path[0] >= 'A') && (path[0] <= 'Z')) ||\n       ((path[0] >= 'a') && (path[0] <= 'z'))) &&\n      path[1] == ':' ) {\n    return TRUE;\n  }\n#endif\n\n  return FALSE;\n}\n\n/* Temporary backup setting of ICU_DATA_DIR_PREFIX_ENV_VAR\n   until some client wrapper makefiles are updated */\n#if U_PLATFORM_IS_DARWIN_BASED && TARGET_IPHONE_SIMULATOR\n# if !defined(ICU_DATA_DIR_PREFIX_ENV_VAR)\n#  define ICU_DATA_DIR_PREFIX_ENV_VAR \"IPHONE_SIMULATOR_ROOT\"\n# endif\n#endif\n\nstatic void U_CALLCONV dataDirectoryInitFn() {\n    /* If we already have the directory, then return immediately. Will happen if user called\n     * u_setDataDirectory().\n     */\n    if (gDataDirectory) {\n        return;\n    }\n\n    const char *path = NULL;\n#if defined(ICU_DATA_DIR_PREFIX_ENV_VAR)\n    char datadir_path_buffer[PATH_MAX];\n#endif\n\n    /*\n    When ICU_NO_USER_DATA_OVERRIDE is defined, users aren't allowed to\n    override ICU's data with the ICU_DATA environment variable. This prevents\n    problems where multiple custom copies of ICU's specific version of data\n    are installed on a system. Either the application must define the data\n    directory with u_setDataDirectory, define ICU_DATA_DIR when compiling\n    ICU, set the data with udata_setCommonData or trust that all of the\n    required data is contained in ICU's data library that contains\n    the entry point defined by U_ICUDATA_ENTRY_POINT.\n\n    There may also be some platforms where environment variables\n    are not allowed.\n    */\n#   if !defined(ICU_NO_USER_DATA_OVERRIDE) && !UCONFIG_NO_FILE_IO\n    /* First try to get the environment variable */\n#       if U_PLATFORM_HAS_WINUWP_API == 0  // Windows UWP does not support getenv\n        path=getenv(\"ICU_DATA\");\n#       endif\n#   endif\n\n    /* ICU_DATA_DIR may be set as a compile option.\n     * U_ICU_DATA_DEFAULT_DIR is provided and is set by ICU at compile time\n     * and is used only when data is built in archive mode eliminating the need\n     * for ICU_DATA_DIR to be set. U_ICU_DATA_DEFAULT_DIR is set to the installation\n     * directory of the data dat file. Users should use ICU_DATA_DIR if they want to\n     * set their own path.\n     */\n#if defined(ICU_DATA_DIR) || defined(U_ICU_DATA_DEFAULT_DIR)\n    if(path==NULL || *path==0) {\n# if defined(ICU_DATA_DIR_PREFIX_ENV_VAR)\n        const char *prefix = getenv(ICU_DATA_DIR_PREFIX_ENV_VAR);\n# endif\n# ifdef ICU_DATA_DIR\n        path=ICU_DATA_DIR;\n# else\n        path=U_ICU_DATA_DEFAULT_DIR;\n# endif\n# if defined(ICU_DATA_DIR_PREFIX_ENV_VAR)\n        if (prefix != NULL) {\n            snprintf(datadir_path_buffer, PATH_MAX, \"%s%s\", prefix, path);\n            path=datadir_path_buffer;\n        }\n# endif\n    }\n#endif\n\n#if defined(ICU_DATA_DIR_WINDOWS) && U_PLATFORM_HAS_WINUWP_API != 0\n    // Use data from the %windir%\\globalization\\icu directory\n    // This is only available if ICU is built as a system component\n    char datadir_path_buffer[MAX_PATH];\n    UINT length = GetWindowsDirectoryA(datadir_path_buffer, UPRV_LENGTHOF(datadir_path_buffer));\n    if (length > 0 && length < (UPRV_LENGTHOF(datadir_path_buffer) - sizeof(ICU_DATA_DIR_WINDOWS) - 1))\n    {\n        if (datadir_path_buffer[length - 1] != '\\\\')\n        {\n            datadir_path_buffer[length++] = '\\\\';\n            datadir_path_buffer[length] = '\\0';\n        }\n\n        if ((length + 1 + sizeof(ICU_DATA_DIR_WINDOWS)) < UPRV_LENGTHOF(datadir_path_buffer))\n        {\n            uprv_strcat(datadir_path_buffer, ICU_DATA_DIR_WINDOWS);\n            path = datadir_path_buffer;\n        }\n    }\n#endif\n\n    if(path==NULL) {\n        /* It looks really bad, set it to something. */\n#if U_PLATFORM_HAS_WIN32_API\n        // Windows UWP will require icudtl.dat file in same directory as icuuc.dll\n        path = \".\\\\\";\n#else\n        path = \"\";\n#endif\n    }\n\n    u_setDataDirectory(path);\n    return;\n}\n\nU_CAPI const char * U_EXPORT2\nu_getDataDirectory(void) {\n    umtx_initOnce(gDataDirInitOnce, &dataDirectoryInitFn);\n    return gDataDirectory;\n}\n\nstatic void setTimeZoneFilesDir(const char *path, UErrorCode &status) {\n    if (U_FAILURE(status)) {\n        return;\n    }\n    gTimeZoneFilesDirectory->clear();\n    gTimeZoneFilesDirectory->append(path, status);\n#if (U_FILE_SEP_CHAR != U_FILE_ALT_SEP_CHAR)\n    char *p = gTimeZoneFilesDirectory->data();\n    while (p = uprv_strchr(p, U_FILE_ALT_SEP_CHAR)) {\n        *p = U_FILE_SEP_CHAR;\n    }\n#endif\n}\n\n#define TO_STRING(x) TO_STRING_2(x) \n#define TO_STRING_2(x) #x\n\nstatic void U_CALLCONV TimeZoneDataDirInitFn(UErrorCode &status) {\n    U_ASSERT(gTimeZoneFilesDirectory == NULL);\n    ucln_common_registerCleanup(UCLN_COMMON_PUTIL, putil_cleanup);\n    gTimeZoneFilesDirectory = new CharString();\n    if (gTimeZoneFilesDirectory == NULL) {\n        status = U_MEMORY_ALLOCATION_ERROR;\n        return;\n    }\n#if U_PLATFORM_HAS_WINUWP_API == 0\n    const char *dir = getenv(\"ICU_TIMEZONE_FILES_DIR\");\n#else\n    // TODO: UWP does not support alternate timezone data directories at this time\n    const char *dir = \"\";\n#endif // U_PLATFORM_HAS_WINUWP_API\n#if defined(U_TIMEZONE_FILES_DIR)\n    if (dir == NULL) {\n        dir = TO_STRING(U_TIMEZONE_FILES_DIR);\n    }\n#endif\n    if (dir == NULL) {\n        dir = \"\";\n    }\n    setTimeZoneFilesDir(dir, status);\n}\n\n\nU_CAPI const char * U_EXPORT2\nu_getTimeZoneFilesDirectory(UErrorCode *status) {\n    umtx_initOnce(gTimeZoneFilesInitOnce, &TimeZoneDataDirInitFn, *status);\n    return U_SUCCESS(*status) ? gTimeZoneFilesDirectory->data() : \"\";\n}\n\nU_CAPI void U_EXPORT2\nu_setTimeZoneFilesDirectory(const char *path, UErrorCode *status) {\n    umtx_initOnce(gTimeZoneFilesInitOnce, &TimeZoneDataDirInitFn, *status);\n    setTimeZoneFilesDir(path, *status);\n\n    // Note: this function does some extra churn, first setting based on the\n    //       environment, then immediately replacing with the value passed in.\n    //       The logic is simpler that way, and performance shouldn't be an issue.\n}\n\n\n#if U_POSIX_LOCALE\n/* A helper function used by uprv_getPOSIXIDForDefaultLocale and\n * uprv_getPOSIXIDForDefaultCodepage. Returns the posix locale id for\n * LC_CTYPE and LC_MESSAGES. It doesn't support other locale categories.\n */\nstatic const char *uprv_getPOSIXIDForCategory(int category)\n{\n    const char* posixID = NULL;\n    if (category == LC_MESSAGES || category == LC_CTYPE) {\n        /*\n        * On Solaris two different calls to setlocale can result in\n        * different values. Only get this value once.\n        *\n        * We must check this first because an application can set this.\n        *\n        * LC_ALL can't be used because it's platform dependent. The LANG\n        * environment variable seems to affect LC_CTYPE variable by default.\n        * Here is what setlocale(LC_ALL, NULL) can return.\n        * HPUX can return 'C C C C C C C'\n        * Solaris can return /en_US/C/C/C/C/C on the second try.\n        * Linux can return LC_CTYPE=C;LC_NUMERIC=C;...\n        *\n        * The default codepage detection also needs to use LC_CTYPE.\n        *\n        * Do not call setlocale(LC_*, \"\")! Using an empty string instead\n        * of NULL, will modify the libc behavior.\n        */\n        posixID = setlocale(category, NULL);\n        if ((posixID == 0)\n            || (uprv_strcmp(\"C\", posixID) == 0)\n            || (uprv_strcmp(\"POSIX\", posixID) == 0))\n        {\n            /* Maybe we got some garbage.  Try something more reasonable */\n            posixID = getenv(\"LC_ALL\");\n            /* Solaris speaks POSIX -  See IEEE Std 1003.1-2008 \n             * This is needed to properly handle empty env. variables\n             */\n#if U_PLATFORM == U_PF_SOLARIS\n            if ((posixID == 0) || (posixID[0] == '\\0')) {\n                posixID = getenv(category == LC_MESSAGES ? \"LC_MESSAGES\" : \"LC_CTYPE\");\n                if ((posixID == 0) || (posixID[0] == '\\0')) {\n#else\n            if (posixID == 0) {\n                posixID = getenv(category == LC_MESSAGES ? \"LC_MESSAGES\" : \"LC_CTYPE\");\n                if (posixID == 0) {\n#endif                    \n                    posixID = getenv(\"LANG\");\n                }\n            }\n        }\n    }\n    if ((posixID==0)\n        || (uprv_strcmp(\"C\", posixID) == 0)\n        || (uprv_strcmp(\"POSIX\", posixID) == 0))\n    {\n        /* Nothing worked.  Give it a nice POSIX default value. */\n        posixID = \"en_US_POSIX\";\n    }\n    return posixID;\n}\n\n/* Return just the POSIX id for the default locale, whatever happens to be in\n * it. It gets the value from LC_MESSAGES and indirectly from LC_ALL and LANG.\n */\nstatic const char *uprv_getPOSIXIDForDefaultLocale(void)\n{\n    static const char* posixID = NULL;\n    if (posixID == 0) {\n        posixID = uprv_getPOSIXIDForCategory(LC_MESSAGES);\n    }\n    return posixID;\n}\n\n#if !U_CHARSET_IS_UTF8\n/* Return just the POSIX id for the default codepage, whatever happens to be in\n * it. It gets the value from LC_CTYPE and indirectly from LC_ALL and LANG.\n */\nstatic const char *uprv_getPOSIXIDForDefaultCodepage(void)\n{\n    static const char* posixID = NULL;\n    if (posixID == 0) {\n        posixID = uprv_getPOSIXIDForCategory(LC_CTYPE);\n    }\n    return posixID;\n}\n#endif\n#endif\n\n/* NOTE: The caller should handle thread safety */\nU_CAPI const char* U_EXPORT2\nuprv_getDefaultLocaleID()\n{\n#if U_POSIX_LOCALE\n/*\n  Note that:  (a '!' means the ID is improper somehow)\n     LC_ALL  ---->     default_loc          codepage\n--------------------------------------------------------\n     ab.CD             ab                   CD\n     ab@CD             ab__CD               -\n     ab@CD.EF          ab__CD               EF\n\n     ab_CD.EF@GH       ab_CD_GH             EF\n\nSome 'improper' ways to do the same as above:\n  !  ab_CD@GH.EF       ab_CD_GH             EF\n  !  ab_CD.EF@GH.IJ    ab_CD_GH             EF\n  !  ab_CD@ZZ.EF@GH.IJ ab_CD_GH             EF\n\n     _CD@GH            _CD_GH               -\n     _CD.EF@GH         _CD_GH               EF\n\nThe variant cannot have dots in it.\nThe 'rightmost' variant (@xxx) wins.\nThe leftmost codepage (.xxx) wins.\n*/\n    char *correctedPOSIXLocale = 0;\n    const char* posixID = uprv_getPOSIXIDForDefaultLocale();\n    const char *p;\n    const char *q;\n    int32_t len;\n\n    /* Format: (no spaces)\n    ll [ _CC ] [ . MM ] [ @ VV]\n\n      l = lang, C = ctry, M = charmap, V = variant\n    */\n\n    if (gCorrectedPOSIXLocale != NULL) {\n        return gCorrectedPOSIXLocale;\n    }\n\n    if ((p = uprv_strchr(posixID, '.')) != NULL) {\n        /* assume new locale can't be larger than old one? */\n        correctedPOSIXLocale = static_cast<char *>(uprv_malloc(uprv_strlen(posixID)+1));\n        /* Exit on memory allocation error. */\n        if (correctedPOSIXLocale == NULL) {\n            return NULL;\n        }\n        uprv_strncpy(correctedPOSIXLocale, posixID, p-posixID);\n        correctedPOSIXLocale[p-posixID] = 0;\n\n        /* do not copy after the @ */\n        if ((p = uprv_strchr(correctedPOSIXLocale, '@')) != NULL) {\n            correctedPOSIXLocale[p-correctedPOSIXLocale] = 0;\n        }\n    }\n\n    /* Note that we scan the *uncorrected* ID. */\n    if ((p = uprv_strrchr(posixID, '@')) != NULL) {\n        if (correctedPOSIXLocale == NULL) {\n            correctedPOSIXLocale = static_cast<char *>(uprv_malloc(uprv_strlen(posixID)+1));\n            /* Exit on memory allocation error. */\n            if (correctedPOSIXLocale == NULL) {\n                return NULL;\n            }\n            uprv_strncpy(correctedPOSIXLocale, posixID, p-posixID);\n            correctedPOSIXLocale[p-posixID] = 0;\n        }\n        p++;\n\n        /* Take care of any special cases here.. */\n        if (!uprv_strcmp(p, \"nynorsk\")) {\n            p = \"NY\";\n            /* Don't worry about no__NY. In practice, it won't appear. */\n        }\n\n        if (uprv_strchr(correctedPOSIXLocale,'_') == NULL) {\n            uprv_strcat(correctedPOSIXLocale, \"__\"); /* aa@b -> aa__b */\n        }\n        else {\n            uprv_strcat(correctedPOSIXLocale, \"_\"); /* aa_CC@b -> aa_CC_b */\n        }\n\n        if ((q = uprv_strchr(p, '.')) != NULL) {\n            /* How big will the resulting string be? */\n            len = (int32_t)(uprv_strlen(correctedPOSIXLocale) + (q-p));\n            uprv_strncat(correctedPOSIXLocale, p, q-p);\n            correctedPOSIXLocale[len] = 0;\n        }\n        else {\n            /* Anything following the @ sign */\n            uprv_strcat(correctedPOSIXLocale, p);\n        }\n\n        /* Should there be a map from 'no@nynorsk' -> no_NO_NY here?\n         * How about 'russian' -> 'ru'?\n         * Many of the other locales using ISO codes will be handled by the\n         * canonicalization functions in uloc_getDefault.\n         */\n    }\n\n    /* Was a correction made? */\n    if (correctedPOSIXLocale != NULL) {\n        posixID = correctedPOSIXLocale;\n    }\n    else {\n        /* copy it, just in case the original pointer goes away.  See j2395 */\n        correctedPOSIXLocale = (char *)uprv_malloc(uprv_strlen(posixID) + 1);\n        /* Exit on memory allocation error. */\n        if (correctedPOSIXLocale == NULL) {\n            return NULL;\n        }\n        posixID = uprv_strcpy(correctedPOSIXLocale, posixID);\n    }\n\n    if (gCorrectedPOSIXLocale == NULL) {\n        gCorrectedPOSIXLocale = correctedPOSIXLocale;\n        gCorrectedPOSIXLocaleHeapAllocated = true;\n        ucln_common_registerCleanup(UCLN_COMMON_PUTIL, putil_cleanup);\n        correctedPOSIXLocale = NULL;\n    }\n\n    if (correctedPOSIXLocale != NULL) {  /* Was already set - clean up. */\n        uprv_free(correctedPOSIXLocale);\n    }\n\n    return posixID;\n\n#elif U_PLATFORM_USES_ONLY_WIN32_API\n#define POSIX_LOCALE_CAPACITY 64\n    UErrorCode status = U_ZERO_ERROR;\n    char *correctedPOSIXLocale = 0;\n\n    // If we have already figured this out just use the cached value\n    if (gCorrectedPOSIXLocale != NULL) {\n        return gCorrectedPOSIXLocale;\n    }\n\n    // No cached value, need to determine the current value\n    static WCHAR windowsLocale[LOCALE_NAME_MAX_LENGTH];\n#if U_PLATFORM_HAS_WINUWP_API == 0 \n    // If not a Universal Windows App, we'll need user default language.\n    // Vista and above should use Locale Names instead of LCIDs\n    int length = GetUserDefaultLocaleName(windowsLocale, UPRV_LENGTHOF(windowsLocale));\n#else\n    // In a UWP app, we want the top language that the application and user agreed upon\n    ComPtr<ABI::Windows::Foundation::Collections::IVectorView<HSTRING>> languageList;\n\n    ComPtr<ABI::Windows::Globalization::IApplicationLanguagesStatics> applicationLanguagesStatics;\n    HRESULT hr = GetActivationFactory(\n        HStringReference(RuntimeClass_Windows_Globalization_ApplicationLanguages).Get(),\n        &applicationLanguagesStatics);\n    if (SUCCEEDED(hr))\n    {\n        hr = applicationLanguagesStatics->get_Languages(&languageList);\n    }\n\n    if (FAILED(hr))\n    {\n        // If there is no application context, then use the top language from the user language profile\n        ComPtr<ABI::Windows::System::UserProfile::IGlobalizationPreferencesStatics> globalizationPreferencesStatics;\n        hr = GetActivationFactory(\n            HStringReference(RuntimeClass_Windows_System_UserProfile_GlobalizationPreferences).Get(),\n            &globalizationPreferencesStatics);\n        if (SUCCEEDED(hr))\n        {\n            hr = globalizationPreferencesStatics->get_Languages(&languageList);\n        }\n    }\n\n    // We have a list of languages, ICU knows one, so use the top one for our locale\n    HString topLanguage;\n    if (SUCCEEDED(hr))\n    {\n        hr = languageList->GetAt(0, topLanguage.GetAddressOf());\n    }\n\n    if (FAILED(hr))\n    {\n        // Unexpected, use en-US by default\n        if (gCorrectedPOSIXLocale == NULL) {\n            gCorrectedPOSIXLocale = \"en_US\";\n        }\n\n        return gCorrectedPOSIXLocale;\n    }\n\n    // ResolveLocaleName will get a likely subtags form consistent with Windows behavior.\n    int length = ResolveLocaleName(topLanguage.GetRawBuffer(NULL), windowsLocale, UPRV_LENGTHOF(windowsLocale));\n#endif\n    // Now we should have a Windows locale name that needs converted to the POSIX style,\n    if (length > 0)\n    {\n        // First we need to go from UTF-16 to char (and also convert from _ to - while we're at it.)\n        char modifiedWindowsLocale[LOCALE_NAME_MAX_LENGTH];\n\n        int32_t i;\n        for (i = 0; i < UPRV_LENGTHOF(modifiedWindowsLocale); i++)\n        {\n            if (windowsLocale[i] == '_')\n            {\n                modifiedWindowsLocale[i] = '-';\n            }\n            else\n            {\n                modifiedWindowsLocale[i] = static_cast<char>(windowsLocale[i]);\n            }\n\n            if (modifiedWindowsLocale[i] == '\\0')\n            {\n                break;\n            }\n        }\n\n        if (i >= UPRV_LENGTHOF(modifiedWindowsLocale))\n        {\n            // Ran out of room, can't really happen, maybe we'll be lucky about a matching\n            // locale when tags are dropped\n            modifiedWindowsLocale[UPRV_LENGTHOF(modifiedWindowsLocale) - 1] = '\\0';\n        }\n\n        // Now normalize the resulting name\n        if (correctedPOSIXLocale)\n        {\n            int32_t posixLen = uloc_canonicalize(modifiedWindowsLocale, correctedPOSIXLocale, POSIX_LOCALE_CAPACITY, &status);\n            if (U_SUCCESS(status))\n            {\n                *(correctedPOSIXLocale + posixLen) = 0;\n                gCorrectedPOSIXLocale = correctedPOSIXLocale;\n                gCorrectedPOSIXLocaleHeapAllocated = true;\n                ucln_common_registerCleanup(UCLN_COMMON_PUTIL, putil_cleanup);\n            }\n            else\n            {\n                uprv_free(correctedPOSIXLocale);\n            }\n        }\n    }\n\n    // If unable to find a locale we can agree upon, use en-US by default\n    if (gCorrectedPOSIXLocale == NULL) {\n        gCorrectedPOSIXLocale = \"en_US\";\n    }\n    return gCorrectedPOSIXLocale;\n\n#elif U_PLATFORM == U_PF_OS400\n    /* locales are process scoped and are by definition thread safe */\n    static char correctedLocale[64];\n    const  char *localeID = getenv(\"LC_ALL\");\n           char *p;\n\n    if (localeID == NULL)\n        localeID = getenv(\"LANG\");\n    if (localeID == NULL)\n        localeID = setlocale(LC_ALL, NULL);\n    /* Make sure we have something... */\n    if (localeID == NULL)\n        return \"en_US_POSIX\";\n\n    /* Extract the locale name from the path. */\n    if((p = uprv_strrchr(localeID, '/')) != NULL)\n    {\n        /* Increment p to start of locale name. */\n        p++;\n        localeID = p;\n    }\n\n    /* Copy to work location. */\n    uprv_strcpy(correctedLocale, localeID);\n\n    /* Strip off the '.locale' extension. */\n    if((p = uprv_strchr(correctedLocale, '.')) != NULL) {\n        *p = 0;\n    }\n\n    /* Upper case the locale name. */\n    T_CString_toUpperCase(correctedLocale);\n\n    /* See if we are using the POSIX locale.  Any of the\n    * following are equivalent and use the same QLGPGCMA\n    * (POSIX) locale.\n    * QLGPGCMA2 means UCS2\n    * QLGPGCMA_4 means UTF-32\n    * QLGPGCMA_8 means UTF-8\n    */\n    if ((uprv_strcmp(\"C\", correctedLocale) == 0) ||\n        (uprv_strcmp(\"POSIX\", correctedLocale) == 0) ||\n        (uprv_strncmp(\"QLGPGCMA\", correctedLocale, 8) == 0))\n    {\n        uprv_strcpy(correctedLocale, \"en_US_POSIX\");\n    }\n    else\n    {\n        int16_t LocaleLen;\n\n        /* Lower case the lang portion. */\n        for(p = correctedLocale; *p != 0 && *p != '_'; p++)\n        {\n            *p = uprv_tolower(*p);\n        }\n\n        /* Adjust for Euro.  After '_E' add 'URO'. */\n        LocaleLen = uprv_strlen(correctedLocale);\n        if (correctedLocale[LocaleLen - 2] == '_' &&\n            correctedLocale[LocaleLen - 1] == 'E')\n        {\n            uprv_strcat(correctedLocale, \"URO\");\n        }\n\n        /* If using Lotus-based locale then convert to\n         * equivalent non Lotus.\n         */\n        else if (correctedLocale[LocaleLen - 2] == '_' &&\n            correctedLocale[LocaleLen - 1] == 'L')\n        {\n            correctedLocale[LocaleLen - 2] = 0;\n        }\n\n        /* There are separate simplified and traditional\n         * locales called zh_HK_S and zh_HK_T.\n         */\n        else if (uprv_strncmp(correctedLocale, \"zh_HK\", 5) == 0)\n        {\n            uprv_strcpy(correctedLocale, \"zh_HK\");\n        }\n\n        /* A special zh_CN_GBK locale...\n        */\n        else if (uprv_strcmp(correctedLocale, \"zh_CN_GBK\") == 0)\n        {\n            uprv_strcpy(correctedLocale, \"zh_CN\");\n        }\n\n    }\n\n    return correctedLocale;\n#endif\n\n}\n\n#if !U_CHARSET_IS_UTF8\n#if U_POSIX_LOCALE\n/*\nDue to various platform differences, one platform may specify a charset,\nwhen they really mean a different charset. Remap the names so that they are\ncompatible with ICU. Only conflicting/ambiguous aliases should be resolved\nhere. Before adding anything to this function, please consider adding unique\nnames to the ICU alias table in the data directory.\n*/\nstatic const char*\nremapPlatformDependentCodepage(const char *locale, const char *name) {\n    if (locale != NULL && *locale == 0) {\n        /* Make sure that an empty locale is handled the same way. */\n        locale = NULL;\n    }\n    if (name == NULL) {\n        return NULL;\n    }\n#if U_PLATFORM == U_PF_AIX\n    if (uprv_strcmp(name, \"IBM-943\") == 0) {\n        /* Use the ASCII compatible ibm-943 */\n        name = \"Shift-JIS\";\n    }\n    else if (uprv_strcmp(name, \"IBM-1252\") == 0) {\n        /* Use the windows-1252 that contains the Euro */\n        name = \"IBM-5348\";\n    }\n#elif U_PLATFORM == U_PF_SOLARIS\n    if (locale != NULL && uprv_strcmp(name, \"EUC\") == 0) {\n        /* Solaris underspecifies the \"EUC\" name. */\n        if (uprv_strcmp(locale, \"zh_CN\") == 0) {\n            name = \"EUC-CN\";\n        }\n        else if (uprv_strcmp(locale, \"zh_TW\") == 0) {\n            name = \"EUC-TW\";\n        }\n        else if (uprv_strcmp(locale, \"ko_KR\") == 0) {\n            name = \"EUC-KR\";\n        }\n    }\n    else if (uprv_strcmp(name, \"eucJP\") == 0) {\n        /*\n        ibm-954 is the best match.\n        ibm-33722 is the default for eucJP (similar to Windows).\n        */\n        name = \"eucjis\";\n    }\n    else if (uprv_strcmp(name, \"646\") == 0) {\n        /*\n         * The default codepage given by Solaris is 646 but the C library routines treat it as if it was\n         * ISO-8859-1 instead of US-ASCII(646).\n         */\n        name = \"ISO-8859-1\";\n    }\n#elif U_PLATFORM_IS_DARWIN_BASED\n    if (locale == NULL && *name == 0) {\n        /*\n        No locale was specified, and an empty name was passed in.\n        This usually indicates that nl_langinfo didn't return valid information.\n        Mac OS X uses UTF-8 by default (especially the locale data and console).\n        */\n        name = \"UTF-8\";\n    }\n    else if (uprv_strcmp(name, \"CP949\") == 0) {\n        /* Remap CP949 to a similar codepage to avoid issues with backslash and won symbol. */\n        name = \"EUC-KR\";\n    }\n    else if (locale != NULL && uprv_strcmp(locale, \"en_US_POSIX\") != 0 && uprv_strcmp(name, \"US-ASCII\") == 0) {\n        /*\n         * For non C/POSIX locale, default the code page to UTF-8 instead of US-ASCII.\n         */\n        name = \"UTF-8\";\n    }\n#elif U_PLATFORM == U_PF_BSD\n    if (uprv_strcmp(name, \"CP949\") == 0) {\n        /* Remap CP949 to a similar codepage to avoid issues with backslash and won symbol. */\n        name = \"EUC-KR\";\n    }\n#elif U_PLATFORM == U_PF_HPUX\n    if (locale != NULL && uprv_strcmp(locale, \"zh_HK\") == 0 && uprv_strcmp(name, \"big5\") == 0) {\n        /* HP decided to extend big5 as hkbig5 even though it's not compatible :-( */\n        /* zh_TW.big5 is not the same charset as zh_HK.big5! */\n        name = \"hkbig5\";\n    }\n    else if (uprv_strcmp(name, \"eucJP\") == 0) {\n        /*\n        ibm-1350 is the best match, but unavailable.\n        ibm-954 is mostly a superset of ibm-1350.\n        ibm-33722 is the default for eucJP (similar to Windows).\n        */\n        name = \"eucjis\";\n    }\n#elif U_PLATFORM == U_PF_LINUX\n    if (locale != NULL && uprv_strcmp(name, \"euc\") == 0) {\n        /* Linux underspecifies the \"EUC\" name. */\n        if (uprv_strcmp(locale, \"korean\") == 0) {\n            name = \"EUC-KR\";\n        }\n        else if (uprv_strcmp(locale, \"japanese\") == 0) {\n            /* See comment below about eucJP */\n            name = \"eucjis\";\n        }\n    }\n    else if (uprv_strcmp(name, \"eucjp\") == 0) {\n        /*\n        ibm-1350 is the best match, but unavailable.\n        ibm-954 is mostly a superset of ibm-1350.\n        ibm-33722 is the default for eucJP (similar to Windows).\n        */\n        name = \"eucjis\";\n    }\n    else if (locale != NULL && uprv_strcmp(locale, \"en_US_POSIX\") != 0 &&\n            (uprv_strcmp(name, \"ANSI_X3.4-1968\") == 0 || uprv_strcmp(name, \"US-ASCII\") == 0)) {\n        /*\n         * For non C/POSIX locale, default the code page to UTF-8 instead of US-ASCII.\n         */\n        name = \"UTF-8\";\n    }\n    /*\n     * Linux returns ANSI_X3.4-1968 for C/POSIX, but the call site takes care of\n     * it by falling back to 'US-ASCII' when NULL is returned from this\n     * function. So, we don't have to worry about it here.\n     */\n#endif\n    /* return NULL when \"\" is passed in */\n    if (*name == 0) {\n        name = NULL;\n    }\n    return name;\n}\n\nstatic const char*\ngetCodepageFromPOSIXID(const char *localeName, char * buffer, int32_t buffCapacity)\n{\n    char localeBuf[100];\n    const char *name = NULL;\n    char *variant = NULL;\n\n    if (localeName != NULL && (name = (uprv_strchr(localeName, '.'))) != NULL) {\n        size_t localeCapacity = uprv_min(sizeof(localeBuf), (name-localeName)+1);\n        uprv_strncpy(localeBuf, localeName, localeCapacity);\n        localeBuf[localeCapacity-1] = 0; /* ensure NULL termination */\n        name = uprv_strncpy(buffer, name+1, buffCapacity);\n        buffer[buffCapacity-1] = 0; /* ensure NULL termination */\n        if ((variant = const_cast<char *>(uprv_strchr(name, '@'))) != NULL) {\n            *variant = 0;\n        }\n        name = remapPlatformDependentCodepage(localeBuf, name);\n    }\n    return name;\n}\n#endif\n\nstatic const char*\nint_getDefaultCodepage()\n{\n#if U_PLATFORM == U_PF_OS400\n    uint32_t ccsid = 37; /* Default to ibm-37 */\n    static char codepage[64];\n    Qwc_JOBI0400_t jobinfo;\n    Qus_EC_t error = { sizeof(Qus_EC_t) }; /* SPI error code */\n\n    EPT_CALL(QUSRJOBI)(&jobinfo, sizeof(jobinfo), \"JOBI0400\",\n        \"*                         \", \"                \", &error);\n\n    if (error.Bytes_Available == 0) {\n        if (jobinfo.Coded_Char_Set_ID != 0xFFFF) {\n            ccsid = (uint32_t)jobinfo.Coded_Char_Set_ID;\n        }\n        else if (jobinfo.Default_Coded_Char_Set_Id != 0xFFFF) {\n            ccsid = (uint32_t)jobinfo.Default_Coded_Char_Set_Id;\n        }\n        /* else use the default */\n    }\n    sprintf(codepage,\"ibm-%d\", ccsid);\n    return codepage;\n\n#elif U_PLATFORM == U_PF_OS390\n    static char codepage[64];\n\n    strncpy(codepage, nl_langinfo(CODESET),63-strlen(UCNV_SWAP_LFNL_OPTION_STRING));\n    strcat(codepage,UCNV_SWAP_LFNL_OPTION_STRING);\n    codepage[63] = 0; /* NULL terminate */\n\n    return codepage;\n\n#elif U_PLATFORM_USES_ONLY_WIN32_API\n    static char codepage[64];\n    DWORD codepageNumber = 0;\n\n#if U_PLATFORM_HAS_WINUWP_API > 0\n    // UWP doesn't have a direct API to get the default ACP as Microsoft would rather\n    // have folks use Unicode than a \"system\" code page, however this is the same\n    // codepage as the system default locale codepage.  (FWIW, the system locale is\n    // ONLY used for codepage, it should never be used for anything else)\n    GetLocaleInfoEx(LOCALE_NAME_SYSTEM_DEFAULT, LOCALE_IDEFAULTANSICODEPAGE | LOCALE_RETURN_NUMBER,\n        (LPWSTR)&codepageNumber, sizeof(codepageNumber) / sizeof(WCHAR));\n#else\n    // Win32 apps can call GetACP\n    codepageNumber = GetACP();\n#endif\n    // Special case for UTF-8\n    if (codepageNumber == 65001)\n    { \n        return \"UTF-8\";\n    }\n    // Windows codepages can look like windows-1252, so format the found number\n    // the numbers are eclectic, however all valid system code pages, besides UTF-8\n    // are between 3 and 19999\n    if (codepageNumber > 0 && codepageNumber < 20000)\n    {\n        sprintf(codepage, \"windows-%ld\", codepageNumber);\n        return codepage;\n    }\n    // If the codepage number call failed then return UTF-8\n    return \"UTF-8\";\n\n#elif U_POSIX_LOCALE\n    static char codesetName[100];\n    const char *localeName = NULL;\n    const char *name = NULL;\n\n    localeName = uprv_getPOSIXIDForDefaultCodepage();\n    uprv_memset(codesetName, 0, sizeof(codesetName));\n    /* On Solaris nl_langinfo returns C locale values unless setlocale\n     * was called earlier.\n     */\n#if (U_HAVE_NL_LANGINFO_CODESET && U_PLATFORM != U_PF_SOLARIS)\n    /* When available, check nl_langinfo first because it usually gives more\n       useful names. It depends on LC_CTYPE.\n       nl_langinfo may use the same buffer as setlocale. */\n    {\n        const char *codeset = nl_langinfo(U_NL_LANGINFO_CODESET);\n#if U_PLATFORM_IS_DARWIN_BASED || U_PLATFORM_IS_LINUX_BASED\n        /*\n         * On Linux and MacOSX, ensure that default codepage for non C/POSIX locale is UTF-8\n         * instead of ASCII.\n         */\n        if (uprv_strcmp(localeName, \"en_US_POSIX\") != 0) {\n            codeset = remapPlatformDependentCodepage(localeName, codeset);\n        } else\n#endif\n        {\n            codeset = remapPlatformDependentCodepage(NULL, codeset);\n        }\n\n        if (codeset != NULL) {\n            uprv_strncpy(codesetName, codeset, sizeof(codesetName));\n            codesetName[sizeof(codesetName)-1] = 0;\n            return codesetName;\n        }\n    }\n#endif\n\n    /* Use setlocale in a nice way, and then check some environment variables.\n       Maybe the application used setlocale already.\n    */\n    uprv_memset(codesetName, 0, sizeof(codesetName));\n    name = getCodepageFromPOSIXID(localeName, codesetName, sizeof(codesetName));\n    if (name) {\n        /* if we can find the codeset name from setlocale, return that. */\n        return name;\n    }\n\n    if (*codesetName == 0)\n    {\n        /* Everything failed. Return US ASCII (ISO 646). */\n        (void)uprv_strcpy(codesetName, \"US-ASCII\");\n    }\n    return codesetName;\n#else\n    return \"US-ASCII\";\n#endif\n}\n\n\nU_CAPI const char*  U_EXPORT2\nuprv_getDefaultCodepage()\n{\n    static char const  *name = NULL;\n    umtx_lock(NULL);\n    if (name == NULL) {\n        name = int_getDefaultCodepage();\n    }\n    umtx_unlock(NULL);\n    return name;\n}\n#endif  /* !U_CHARSET_IS_UTF8 */\n\n\n/* end of platform-specific implementation -------------- */\n\n/* version handling --------------------------------------------------------- */\n\nU_CAPI void U_EXPORT2\nu_versionFromString(UVersionInfo versionArray, const char *versionString) {\n    char *end;\n    uint16_t part=0;\n\n    if(versionArray==NULL) {\n        return;\n    }\n\n    if(versionString!=NULL) {\n        for(;;) {\n            versionArray[part]=(uint8_t)uprv_strtoul(versionString, &end, 10);\n            if(end==versionString || ++part==U_MAX_VERSION_LENGTH || *end!=U_VERSION_DELIMITER) {\n                break;\n            }\n            versionString=end+1;\n        }\n    }\n\n    while(part<U_MAX_VERSION_LENGTH) {\n        versionArray[part++]=0;\n    }\n}\n\nU_CAPI void U_EXPORT2\nu_versionFromUString(UVersionInfo versionArray, const UChar *versionString) {\n    if(versionArray!=NULL && versionString!=NULL) {\n        char versionChars[U_MAX_VERSION_STRING_LENGTH+1];\n        int32_t len = u_strlen(versionString);\n        if(len>U_MAX_VERSION_STRING_LENGTH) {\n            len = U_MAX_VERSION_STRING_LENGTH;\n        }\n        u_UCharsToChars(versionString, versionChars, len);\n        versionChars[len]=0;\n        u_versionFromString(versionArray, versionChars);\n    }\n}\n\nU_CAPI void U_EXPORT2\nu_versionToString(const UVersionInfo versionArray, char *versionString) {\n    uint16_t count, part;\n    uint8_t field;\n\n    if(versionString==NULL) {\n        return;\n    }\n\n    if(versionArray==NULL) {\n        versionString[0]=0;\n        return;\n    }\n\n    /* count how many fields need to be written */\n    for(count=4; count>0 && versionArray[count-1]==0; --count) {\n    }\n\n    if(count <= 1) {\n        count = 2;\n    }\n\n    /* write the first part */\n    /* write the decimal field value */\n    field=versionArray[0];\n    if(field>=100) {\n        *versionString++=(char)('0'+field/100);\n        field%=100;\n    }\n    if(field>=10) {\n        *versionString++=(char)('0'+field/10);\n        field%=10;\n    }\n    *versionString++=(char)('0'+field);\n\n    /* write the following parts */\n    for(part=1; part<count; ++part) {\n        /* write a dot first */\n        *versionString++=U_VERSION_DELIMITER;\n\n        /* write the decimal field value */\n        field=versionArray[part];\n        if(field>=100) {\n            *versionString++=(char)('0'+field/100);\n            field%=100;\n        }\n        if(field>=10) {\n            *versionString++=(char)('0'+field/10);\n            field%=10;\n        }\n        *versionString++=(char)('0'+field);\n    }\n\n    /* NUL-terminate */\n    *versionString=0;\n}\n\nU_CAPI void U_EXPORT2\nu_getVersion(UVersionInfo versionArray) {\n    (void)copyright;   // Suppress unused variable warning from clang.\n    u_versionFromString(versionArray, U_ICU_VERSION);\n}\n\n/**\n * icucfg.h dependent code \n */\n\n#if U_ENABLE_DYLOAD\n \n#if HAVE_DLOPEN && !U_PLATFORM_USES_ONLY_WIN32_API\n\n#if HAVE_DLFCN_H\n\n#ifdef __MVS__\n#ifndef __SUSV3\n#define __SUSV3 1\n#endif\n#endif\n#include <dlfcn.h>\n#endif\n\nU_INTERNAL void * U_EXPORT2\nuprv_dl_open(const char *libName, UErrorCode *status) {\n  void *ret = NULL;\n  if(U_FAILURE(*status)) return ret;\n  ret =  dlopen(libName, RTLD_NOW|RTLD_GLOBAL);\n  if(ret==NULL) {\n#ifdef U_TRACE_DYLOAD\n    printf(\"dlerror on dlopen(%s): %s\\n\", libName, dlerror());\n#endif\n    *status = U_MISSING_RESOURCE_ERROR;\n  }\n  return ret;\n}\n\nU_INTERNAL void U_EXPORT2\nuprv_dl_close(void *lib, UErrorCode *status) {\n  if(U_FAILURE(*status)) return;\n  dlclose(lib);\n}\n\nU_INTERNAL UVoidFunction* U_EXPORT2\nuprv_dlsym_func(void *lib, const char* sym, UErrorCode *status) {\n  union {\n      UVoidFunction *fp;\n      void *vp;\n  } uret;\n  uret.fp = NULL;\n  if(U_FAILURE(*status)) return uret.fp;\n  uret.vp = dlsym(lib, sym);\n  if(uret.vp == NULL) {\n#ifdef U_TRACE_DYLOAD\n    printf(\"dlerror on dlsym(%p,%s): %s\\n\", lib,sym, dlerror());\n#endif\n    *status = U_MISSING_RESOURCE_ERROR;\n  }\n  return uret.fp;\n}\n\n#else\n\n/* null (nonexistent) implementation. */\n\nU_INTERNAL void * U_EXPORT2\nuprv_dl_open(const char *libName, UErrorCode *status) {\n  if(U_FAILURE(*status)) return NULL;\n  *status = U_UNSUPPORTED_ERROR;\n  return NULL;\n}\n\nU_INTERNAL void U_EXPORT2\nuprv_dl_close(void *lib, UErrorCode *status) {\n  if(U_FAILURE(*status)) return;\n  *status = U_UNSUPPORTED_ERROR;\n  return;\n}\n\n\nU_INTERNAL UVoidFunction* U_EXPORT2\nuprv_dlsym_func(void *lib, const char* sym, UErrorCode *status) {\n  if(U_SUCCESS(*status)) {\n    *status = U_UNSUPPORTED_ERROR;\n  }\n  return (UVoidFunction*)NULL;\n}\n\n\n\n#endif\n\n#elif U_PLATFORM_USES_ONLY_WIN32_API\n\nU_INTERNAL void * U_EXPORT2\nuprv_dl_open(const char *libName, UErrorCode *status) {\n  HMODULE lib = NULL;\n  \n  if(U_FAILURE(*status)) return NULL;\n  \n  lib = LoadLibraryA(libName);\n  \n  if(lib==NULL) {\n    *status = U_MISSING_RESOURCE_ERROR;\n  }\n  \n  return (void*)lib;\n}\n\nU_INTERNAL void U_EXPORT2\nuprv_dl_close(void *lib, UErrorCode *status) {\n  HMODULE handle = (HMODULE)lib;\n  if(U_FAILURE(*status)) return;\n  \n  FreeLibrary(handle);\n  \n  return;\n}\n\n\nU_INTERNAL UVoidFunction* U_EXPORT2\nuprv_dlsym_func(void *lib, const char* sym, UErrorCode *status) {\n  HMODULE handle = (HMODULE)lib;\n  UVoidFunction* addr = NULL;\n  \n  if(U_FAILURE(*status) || lib==NULL) return NULL;\n  \n  addr = (UVoidFunction*)GetProcAddress(handle, sym);\n  \n  if(addr==NULL) {\n    DWORD lastError = GetLastError();\n    if(lastError == ERROR_PROC_NOT_FOUND) {\n      *status = U_MISSING_RESOURCE_ERROR;\n    } else {\n      *status = U_UNSUPPORTED_ERROR; /* other unknown error. */\n    }\n  }\n  \n  return addr;\n}\n\n\n#else\n\n/* No dynamic loading set. */\n\nU_INTERNAL void * U_EXPORT2\nuprv_dl_open(const char *libName, UErrorCode *status) {\n    (void)libName;\n    if(U_FAILURE(*status)) return NULL;\n    *status = U_UNSUPPORTED_ERROR;\n    return NULL;\n}\n\nU_INTERNAL void U_EXPORT2\nuprv_dl_close(void *lib, UErrorCode *status) {\n    (void)lib;\n    if(U_FAILURE(*status)) return;\n    *status = U_UNSUPPORTED_ERROR;\n    return;\n}\n\n\nU_INTERNAL UVoidFunction* U_EXPORT2\nuprv_dlsym_func(void *lib, const char* sym, UErrorCode *status) {\n  (void)lib;\n  (void)sym;\n  if(U_SUCCESS(*status)) {\n    *status = U_UNSUPPORTED_ERROR;\n  }\n  return (UVoidFunction*)NULL;\n}\n\n#endif /* U_ENABLE_DYLOAD */\n\n/*\n * Hey, Emacs, please set the following:\n *\n * Local Variables:\n * indent-tabs-mode: nil\n * End:\n *\n */\n",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/sql-common/client_plugin.cc": "/* Copyright (c) 2010, 2019, Oracle and/or its affiliates. All rights reserved.\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License, version 2.0,\n   as published by the Free Software Foundation.\n\n   This program is also distributed with certain software (including\n   but not limited to OpenSSL) that is licensed under separate terms,\n   as designated in a particular file or component or in included license\n   documentation.  The authors of MySQL hereby grant you an additional\n   permission to link the program and your derivative works with the\n   separately licensed software that they have included with MySQL.\n\n   Without limiting anything contained in the foregoing, this file,\n   which is part of C Driver for MySQL (Connector/C), is also subject to the\n   Universal FOSS Exception, version 1.0, a copy of which can be found at\n   http://oss.oracle.com/licenses/universal-foss-exception.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License, version 2.0, for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA */\n\n/**\n  @file\n\n  Support code for the client side (libmysql) plugins\n\n  Client plugins are somewhat different from server plugins, they are simpler.\n\n  They do not need to be installed or in any way explicitly loaded on the\n  client, they are loaded automatically on demand.\n  One client plugin per shared object, soname *must* match the plugin name.\n\n  There is no reference counting and no unloading either.\n*/\n\n#include \"my_config.h\"\n\n#include <mysql/client_plugin.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <sys/types.h>\n\n#include \"errmsg.h\"\n#include \"m_ctype.h\"\n#include \"m_string.h\"\n#include \"my_alloc.h\"\n#include \"my_dbug.h\"\n#include \"my_inttypes.h\"\n#include \"my_io.h\"\n#include \"my_macros.h\"\n#include \"my_psi_config.h\"\n#include \"my_sys.h\"\n#include \"my_thread.h\"\n#include \"mysql.h\"\n#include \"mysql/psi/mysql_memory.h\"\n#include \"mysql/psi/mysql_mutex.h\"\n#include \"mysql/service_mysql_alloc.h\"\n#include \"sql_common.h\"\n#include \"template_utils.h\"\n\n#ifdef HAVE_DLFCN_H\n#include <dlfcn.h>\n#endif\n\n#if defined(CLIENT_PROTOCOL_TRACING)\n#include <mysql/plugin_trace.h>\n#endif\n\nPSI_memory_key key_memory_root;\nPSI_memory_key key_memory_load_env_plugins;\n\nPSI_mutex_key key_mutex_LOCK_load_client_plugin;\n\n#ifdef HAVE_PSI_INTERFACE\nstatic PSI_mutex_info all_client_plugin_mutexes[] = {\n    {&key_mutex_LOCK_load_client_plugin, \"LOCK_load_client_plugin\",\n     PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME}};\n\nstatic PSI_memory_info all_client_plugin_memory[] = {\n    {&key_memory_root, \"root\", PSI_FLAG_ONLY_GLOBAL_STAT, 0, PSI_DOCUMENT_ME},\n    {&key_memory_load_env_plugins, \"load_env_plugins\",\n     PSI_FLAG_ONLY_GLOBAL_STAT, 0, PSI_DOCUMENT_ME}};\n\nstatic void init_client_plugin_psi_keys() {\n  const char *category = \"sql\";\n  int count;\n\n  count = array_elements(all_client_plugin_mutexes);\n  mysql_mutex_register(category, all_client_plugin_mutexes, count);\n\n  count = array_elements(all_client_plugin_memory);\n  mysql_memory_register(category, all_client_plugin_memory, count);\n}\n#endif /* HAVE_PSI_INTERFACE */\n\nstruct st_client_plugin_int {\n  struct st_client_plugin_int *next;\n  void *dlhandle;\n  struct st_mysql_client_plugin *plugin;\n};\n\nstatic bool initialized = false;\nstatic MEM_ROOT mem_root;\n\nstatic const char *plugin_declarations_sym =\n    \"_mysql_client_plugin_declaration_\";\nstatic uint plugin_version[MYSQL_CLIENT_MAX_PLUGINS] = {\n    0, /* these two are taken by Connector/C */\n    0, /* these two are taken by Connector/C */\n    MYSQL_CLIENT_AUTHENTICATION_PLUGIN_INTERFACE_VERSION,\n    MYSQL_CLIENT_TRACE_PLUGIN_INTERFACE_VERSION,\n};\n\n/*\n  Loaded plugins are stored in a linked list.\n  The list is append-only, the elements are added to the head (like in a stack).\n  The elements are added under a mutex, but the list can be read and traversed\n  without any mutex because once an element is added to the list, it stays\n  there. The main purpose of a mutex is to prevent two threads from\n  loading the same plugin twice in parallel.\n*/\nstruct st_client_plugin_int *plugin_list[MYSQL_CLIENT_MAX_PLUGINS];\nstatic mysql_mutex_t LOCK_load_client_plugin;\n\nstatic int is_not_initialized(MYSQL *mysql, const char *name) {\n  if (initialized) return 0;\n\n  set_mysql_extended_error(mysql, CR_AUTH_PLUGIN_CANNOT_LOAD, unknown_sqlstate,\n                           ER_CLIENT(CR_AUTH_PLUGIN_CANNOT_LOAD), name,\n                           \"not initialized\");\n  return 1;\n}\n\n/**\n  finds a plugin in the list\n\n  @param name   plugin name to search for\n  @param type   plugin type\n\n  @note this does NOT necessarily need a mutex, take care!\n\n  @retval a pointer to a found plugin or 0\n*/\nstatic struct st_mysql_client_plugin *find_plugin(const char *name, int type) {\n  struct st_client_plugin_int *p;\n\n  DBUG_ASSERT(initialized);\n  DBUG_ASSERT(type >= 0 && type < MYSQL_CLIENT_MAX_PLUGINS);\n  if (type < 0 || type >= MYSQL_CLIENT_MAX_PLUGINS) return nullptr;\n\n  for (p = plugin_list[type]; p; p = p->next) {\n    if (strcmp(p->plugin->name, name) == 0) return p->plugin;\n  }\n  return nullptr;\n}\n\n/**\n  verifies the plugin and adds it to the list\n\n  @param mysql          MYSQL structure (for error reporting)\n  @param plugin         plugin to install\n  @param dlhandle       a handle to the shared object (returned by dlopen)\n                        or 0 if the plugin was not dynamically loaded\n  @param argc           number of arguments in the 'va_list args'\n  @param args           arguments passed to the plugin initialization function\n\n  @retval a pointer to an installed plugin or 0\n*/\nstatic struct st_mysql_client_plugin *do_add_plugin(\n    MYSQL *mysql, struct st_mysql_client_plugin *plugin, void *dlhandle,\n    int argc, va_list args) {\n  const char *errmsg;\n  struct st_client_plugin_int plugin_int, *p;\n  char errbuf[1024];\n\n  DBUG_ASSERT(initialized);\n\n  plugin_int.plugin = plugin;\n  plugin_int.dlhandle = dlhandle;\n\n  if (plugin->type >= MYSQL_CLIENT_MAX_PLUGINS) {\n    errmsg = \"Unknown client plugin type\";\n    goto err1;\n  }\n\n  if (plugin->interface_version < plugin_version[plugin->type] ||\n      (plugin->interface_version >> 8) > (plugin_version[plugin->type] >> 8)) {\n    errmsg = \"Incompatible client plugin interface\";\n    goto err1;\n  }\n\n#if defined(CLIENT_PROTOCOL_TRACING) && !defined(MYSQL_SERVER)\n  /*\n    If we try to load a protocol trace plugin but one is already\n    loaded (global trace_plugin pointer is not NULL) then we ignore\n    the new trace plugin and give error. This is done before the\n    new plugin gets initialized.\n  */\n  if (plugin->type == MYSQL_CLIENT_TRACE_PLUGIN && nullptr != trace_plugin) {\n    errmsg = \"Can not load another trace plugin while one is already loaded\";\n    goto err1;\n  }\n#endif\n\n  /* Call the plugin initialization function, if any */\n  if (plugin->init && plugin->init(errbuf, sizeof(errbuf), argc, args)) {\n    errmsg = errbuf;\n    goto err1;\n  }\n\n  p = (struct st_client_plugin_int *)memdup_root(&mem_root, &plugin_int,\n                                                 sizeof(plugin_int));\n\n  if (!p) {\n    errmsg = \"Out of memory\";\n    goto err2;\n  }\n\n  mysql_mutex_assert_owner(&LOCK_load_client_plugin);\n\n  p->next = plugin_list[plugin->type];\n  plugin_list[plugin->type] = p;\n  net_clear_error(&mysql->net);\n\n#if defined(CLIENT_PROTOCOL_TRACING) && !defined(MYSQL_SERVER)\n  /*\n    If loaded plugin is a protocol trace one, then set the global\n    trace_plugin pointer to point at it. When trace_plugin is not NULL,\n    each new connection will be traced using the plugin pointed by it\n    (see MYSQL_TRACE_STAGE() macro in libmysql/mysql_trace.h).\n  */\n  if (plugin->type == MYSQL_CLIENT_TRACE_PLUGIN) {\n    trace_plugin = (struct st_mysql_client_plugin_TRACE *)plugin;\n  }\n#endif\n\n  return plugin;\n\nerr2:\n  if (plugin->deinit) plugin->deinit();\nerr1:\n  set_mysql_extended_error(mysql, CR_AUTH_PLUGIN_CANNOT_LOAD, unknown_sqlstate,\n                           ER_CLIENT(CR_AUTH_PLUGIN_CANNOT_LOAD), plugin->name,\n                           errmsg);\n  if (dlhandle) dlclose(dlhandle);\n  return nullptr;\n}\n\nstatic struct st_mysql_client_plugin *add_plugin_noargs(\n    MYSQL *mysql, struct st_mysql_client_plugin *plugin, void *dlhandle,\n    int argc, ...) {\n  struct st_mysql_client_plugin *retval = nullptr;\n  va_list ap;\n  va_start(ap, argc);\n  retval = do_add_plugin(mysql, plugin, dlhandle, argc, ap);\n  va_end(ap);\n  return retval;\n}\n\nstatic struct st_mysql_client_plugin *add_plugin_withargs(\n    MYSQL *mysql, struct st_mysql_client_plugin *plugin, void *dlhandle,\n    int argc, va_list args) {\n  return do_add_plugin(mysql, plugin, dlhandle, argc, args);\n}\n\n/**\n  Loads plugins which are specified in the environment variable\n  LIBMYSQL_PLUGINS.\n\n  Multiple plugins must be separated by semicolon. This function doesn't\n  return or log an error.\n\n  The function is be called by mysql_client_plugin_init\n\n  @todo\n  Support extended syntax, passing parameters to plugins, for example\n  LIBMYSQL_PLUGINS=\"plugin1(param1,param2);plugin2;...\"\n  or\n  LIBMYSQL_PLUGINS=\"plugin1=int:param1,str:param2;plugin2;...\"\n*/\nstatic void load_env_plugins(MYSQL *mysql) {\n  char *plugs, *free_env, *s = getenv(\"LIBMYSQL_PLUGINS\");\n  char *enable_cleartext_plugin = getenv(\"LIBMYSQL_ENABLE_CLEARTEXT_PLUGIN\");\n\n  if (enable_cleartext_plugin && strchr(\"1Yy\", enable_cleartext_plugin[0]))\n    libmysql_cleartext_plugin_enabled = true;\n\n  /* no plugins to load */\n  if (!s) return;\n\n  free_env = plugs = my_strdup(key_memory_load_env_plugins, s, MYF(MY_WME));\n\n  do {\n    if ((s = strchr(plugs, ';'))) *s = '\\0';\n    mysql_load_plugin(mysql, plugs, -1, 0);\n    plugs = s + 1;\n  } while (s);\n\n  my_free(free_env);\n}\n\n/********** extern functions to be used by libmysql *********************/\n\n/**\n  Initializes the client plugin layer.\n\n  This function must be called before any other client plugin function.\n\n  @retval 0    successful\n  @retval != 0 error occurred\n*/\nint mysql_client_plugin_init() {\n  MYSQL mysql;\n  struct st_mysql_client_plugin **builtin;\n\n  if (initialized) return 0;\n\n#ifdef HAVE_PSI_INTERFACE\n  init_client_plugin_psi_keys();\n#endif /* HAVE_PSI_INTERFACE */\n\n  memset(&mysql, 0,\n         sizeof(mysql)); /* dummy mysql for set_mysql_extended_error */\n\n  mysql_mutex_init(key_mutex_LOCK_load_client_plugin, &LOCK_load_client_plugin,\n                   MY_MUTEX_INIT_SLOW);\n  init_alloc_root(key_memory_root, &mem_root, 128, 128);\n\n  memset(&plugin_list, 0, sizeof(plugin_list));\n\n  initialized = true;\n\n  mysql_mutex_lock(&LOCK_load_client_plugin);\n\n  for (builtin = mysql_client_builtins; *builtin; builtin++)\n    add_plugin_noargs(&mysql, *builtin, nullptr, 0);\n\n  mysql_mutex_unlock(&LOCK_load_client_plugin);\n\n  load_env_plugins(&mysql);\n\n  mysql_close_free(&mysql);\n\n  return 0;\n}\n\n/**\n  Deinitializes the client plugin layer.\n\n  Unloades all client plugins and frees any associated resources.\n*/\nvoid mysql_client_plugin_deinit() {\n  int i;\n  struct st_client_plugin_int *p;\n\n  if (!initialized) return;\n\n  for (i = 0; i < MYSQL_CLIENT_MAX_PLUGINS; i++)\n    for (p = plugin_list[i]; p; p = p->next) {\n      if (p->plugin->deinit) p->plugin->deinit();\n      if (p->dlhandle) dlclose(p->dlhandle);\n    }\n\n  memset(&plugin_list, 0, sizeof(plugin_list));\n  initialized = false;\n  free_root(&mem_root, MYF(0));\n  mysql_mutex_destroy(&LOCK_load_client_plugin);\n}\n\n/************* public facing functions, for client consumption *********/\n\n/* see <mysql/client_plugin.h> for a full description */\nstruct st_mysql_client_plugin *mysql_client_register_plugin(\n    MYSQL *mysql, struct st_mysql_client_plugin *plugin) {\n  if (is_not_initialized(mysql, plugin->name)) return nullptr;\n\n  mysql_mutex_lock(&LOCK_load_client_plugin);\n\n  /* make sure the plugin wasn't loaded meanwhile */\n  if (find_plugin(plugin->name, plugin->type)) {\n    set_mysql_extended_error(mysql, CR_AUTH_PLUGIN_CANNOT_LOAD,\n                             unknown_sqlstate,\n                             ER_CLIENT(CR_AUTH_PLUGIN_CANNOT_LOAD),\n                             plugin->name, \"it is already loaded\");\n    plugin = nullptr;\n  } else\n    plugin = add_plugin_noargs(mysql, plugin, nullptr, 0);\n\n  mysql_mutex_unlock(&LOCK_load_client_plugin);\n  return plugin;\n}\n\n/* see <mysql/client_plugin.h> for a full description */\nstruct st_mysql_client_plugin *mysql_load_plugin_v(MYSQL *mysql,\n                                                   const char *name, int type,\n                                                   int argc, va_list args) {\n  const char *errmsg;\n  char dlpath[FN_REFLEN + 1];\n  void *sym, *dlhandle;\n  struct st_mysql_client_plugin *plugin;\n  const char *plugindir;\n  const CHARSET_INFO *cs = nullptr;\n  size_t len = (name ? strlen(name) : 0);\n  int well_formed_error;\n  size_t res = 0;\n#ifdef _WIN32\n  char win_errormsg[2048];\n#endif\n\n  DBUG_TRACE;\n  DBUG_PRINT(\"entry\", (\"name=%s type=%d int argc=%d\", name, type, argc));\n  if (is_not_initialized(mysql, name)) {\n    DBUG_PRINT(\"leave\", (\"mysql not initialized\"));\n    return nullptr;\n  }\n\n  mysql_mutex_lock(&LOCK_load_client_plugin);\n\n  /* make sure the plugin wasn't loaded meanwhile */\n  if (type >= 0 && find_plugin(name, type)) {\n    errmsg = \"it is already loaded\";\n    goto err;\n  }\n\n  if (mysql->options.extension && mysql->options.extension->plugin_dir) {\n    plugindir = mysql->options.extension->plugin_dir;\n  } else {\n    plugindir = getenv(\"LIBMYSQL_PLUGIN_DIR\");\n    if (!plugindir) {\n      plugindir = PLUGINDIR;\n    }\n  }\n  if (mysql && mysql->charset)\n    cs = mysql->charset;\n  else\n    cs = &my_charset_utf8mb4_bin;\n  /* check if plugin name does not have any directory separator character */\n  if ((my_strcspn(cs, name, name + len, FN_DIRSEP, strlen(FN_DIRSEP))) < len) {\n    errmsg = \"No paths allowed for shared library\";\n    goto err;\n  }\n  /* check if plugin name does not exceed its maximum length */\n  res = cs->cset->well_formed_len(cs, name, name + len, NAME_CHAR_LEN,\n                                  &well_formed_error);\n\n  if (well_formed_error || len != res) {\n    errmsg = \"Invalid plugin name\";\n    goto err;\n  }\n  /*\n    check if length of(plugin_dir + plugin name) does not exceed its maximum\n    length\n  */\n  if ((strlen(plugindir) + len + 1) >= FN_REFLEN) {\n    errmsg = \"Invalid path\";\n    goto err;\n  }\n\n  /* Compile dll path */\n  strxnmov(dlpath, sizeof(dlpath) - 1, plugindir, \"/\", name, SO_EXT, NullS);\n\n  DBUG_PRINT(\"info\", (\"dlopeninig %s\", dlpath));\n  /* Open new dll handle */\n  if (!(dlhandle = dlopen(dlpath, RTLD_NOW))) {\n#if defined(__APPLE__)\n    /* Apple supports plugins with .so also, so try this as well */\n    strxnmov(dlpath, sizeof(dlpath) - 1, plugindir, \"/\", name, \".so\", NullS);\n    if ((dlhandle = dlopen(dlpath, RTLD_NOW))) goto have_plugin;\n#endif\n\n#ifdef _WIN32\n    /* There should be no win32 calls between failed dlopen() and GetLastError()\n     */\n    if (FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, 0, GetLastError(), 0,\n                      win_errormsg, 2048, NULL))\n      errmsg = win_errormsg;\n    else\n      errmsg = \"\";\n#else\n    errmsg = dlerror();\n#endif\n    DBUG_PRINT(\"info\", (\"failed to dlopen\"));\n    goto err;\n  }\n\n#if defined(__APPLE__)\nhave_plugin:\n#endif\n  if (!(sym = dlsym(dlhandle, plugin_declarations_sym))) {\n    errmsg = \"not a plugin\";\n    dlclose(dlhandle);\n    goto err;\n  }\n\n  plugin = (struct st_mysql_client_plugin *)sym;\n\n  if (type >= 0 && type != plugin->type) {\n    errmsg = \"type mismatch\";\n    goto err;\n  }\n\n  if (strcmp(name, plugin->name)) {\n    errmsg = \"name mismatch\";\n    goto err;\n  }\n\n  if (type < 0 && find_plugin(name, plugin->type)) {\n    errmsg = \"it is already loaded\";\n    goto err;\n  }\n\n  plugin = add_plugin_withargs(mysql, plugin, dlhandle, argc, args);\n\n  mysql_mutex_unlock(&LOCK_load_client_plugin);\n\n  DBUG_PRINT(\"leave\", (\"plugin loaded ok\"));\n  return plugin;\n\nerr:\n  mysql_mutex_unlock(&LOCK_load_client_plugin);\n  DBUG_PRINT(\"leave\", (\"plugin load error : %s\", errmsg));\n  set_mysql_extended_error(mysql, CR_AUTH_PLUGIN_CANNOT_LOAD, unknown_sqlstate,\n                           ER_CLIENT(CR_AUTH_PLUGIN_CANNOT_LOAD), name, errmsg);\n  return nullptr;\n}\n\n/* see <mysql/client_plugin.h> for a full description */\nstruct st_mysql_client_plugin *mysql_load_plugin(MYSQL *mysql, const char *name,\n                                                 int type, int argc, ...) {\n  struct st_mysql_client_plugin *p;\n  va_list args;\n  va_start(args, argc);\n  p = mysql_load_plugin_v(mysql, name, type, argc, args);\n  va_end(args);\n  return p;\n}\n\n/* see <mysql/client_plugin.h> for a full description */\nstruct st_mysql_client_plugin *mysql_client_find_plugin(MYSQL *mysql,\n                                                        const char *name,\n                                                        int type) {\n  struct st_mysql_client_plugin *p;\n\n  DBUG_TRACE;\n  DBUG_PRINT(\"entry\", (\"name=%s, type=%d\", name, type));\n  if (is_not_initialized(mysql, name)) return nullptr;\n\n  if (type < 0 || type >= MYSQL_CLIENT_MAX_PLUGINS) {\n    set_mysql_extended_error(\n        mysql, CR_AUTH_PLUGIN_CANNOT_LOAD, unknown_sqlstate,\n        ER_CLIENT(CR_AUTH_PLUGIN_CANNOT_LOAD), name, \"invalid type\");\n  }\n\n  if ((p = find_plugin(name, type))) {\n    DBUG_PRINT(\"leave\", (\"found %p\", p));\n    return p;\n  }\n\n  /* not found, load it */\n  p = mysql_load_plugin(mysql, name, type, 0);\n  DBUG_PRINT(\"leave\", (\"loaded %p\", p));\n  return p;\n}\n\n/* see <mysql/client_plugin.h> for a full description */\nint mysql_plugin_options(struct st_mysql_client_plugin *plugin,\n                         const char *option, const void *value) {\n  DBUG_TRACE;\n  /* does the plugin support options call? */\n  if (!plugin || !plugin->options) return 1;\n  return plugin->options(option, value);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/valgrind.supp": "# Copyright (c) 2005, 2020, Oracle and/or its affiliates. All rights reserved.\n#\n# This program is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License, version 2.0,\n# as published by the Free Software Foundation.\n#\n# This program is also distributed with certain software (including\n# but not limited to OpenSSL) that is licensed under separate terms,\n# as designated in a particular file or component or in included license\n# documentation.  The authors of MySQL hereby grant you an additional\n# permission to link the program and your derivative works with the\n# separately licensed software that they have included with MySQL.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License, version 2.0, for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA\n\n#\n# Suppress some common (not fatal) errors in system libraries found by valgrind\n#\n\n#\n# Pthread doesn't free all thread specific memory before program exists\n#\n{\n   pthread allocate_tls memory loss\n   Memcheck:Leak\n   fun:calloc\n   ...\n   fun:_dl_allocate_tls\n   fun:allocate_stack\n   fun:pthread_create*\n}\n\n{\n   pthread allocate_tls memory loss\n   Memcheck:Leak\n   fun:calloc\n   fun:_dl_allocate_tls\n   fun:pthread_create*\n\n}\n\n{\n   semi_sync_master_plugin_init\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   ...\n   fun:tls_get_addr_tail\n}\n\n{\n   GCC never cleans up its TLS block\n   Memcheck:Leak\n   fun:memalign\n   ...\n   fun:tls_get_addr_tail\n}\n\n{\n   pthead_exit memory loss 1\n   Memcheck:Leak\n   fun:malloc\n   fun:_dl_new_object\n   fun:_dl_map_object_from_fd\n}\n\n{\n   pthread_exit memory loss 2\n   Memcheck:Leak\n   fun:malloc\n   fun:_dl_map_object\n   fun:dl_open_worker\n}\n\n{\n   pthread_exit memory loss 3\n   Memcheck:Leak\n   fun:malloc\n   fun:_dl_map_object_deps\n   fun:dl_open_worker\n}\n\n{\n   pthread_exit memory loss 4\n   Memcheck:Leak\n   fun:calloc\n   fun:_dl_check_map_versions\n   fun:dl_open_worker\n}\n\n{\n   pthread_exit memory loss 5\n   Memcheck:Leak\n   fun:calloc\n   fun:_dl_new_object\n   fun:_dl_map_object_from_fd\n}\n\n{\n   pthread allocate_dtv memory loss\n   Memcheck:Leak\n   fun:calloc\n   fun:allocate_dtv\n   fun:_dl_allocate_tls_storage\n   fun:__GI__dl_allocate_tls\n   fun:pthread_create\n}\n\n{\n   pthread allocate_dtv memory loss second\n   Memcheck:Leak\n   fun:calloc\n   fun:allocate_dtv\n   fun:_dl_allocate_tls\n   fun:pthread_create*\n}\n\n{\n   pthread memalign memory loss\n   Memcheck:Leak\n   fun:memalign\n   fun:_dl_allocate_tls_storage\n   fun:__GI__dl_allocate_tls\n   fun:pthread_create\n}\n\n{\n   pthread pthread_key_create\n   Memcheck:Leak\n   fun:malloc\n   fun:*\n   fun:*\n   fun:pthread_key_create\n   fun:my_thread_global_init\n}\n\n{\n   pthread strstr uninit\n   Memcheck:Cond\n   fun:strstr\n   obj:/lib/tls/libpthread.so.*\n   obj:/lib/tls/libpthread.so.*\n   fun:call_init\n   fun:_dl_init\n   obj:/lib/ld-*.so\n}\n\n{\n   pthread strstr uninit\n   Memcheck:Cond\n   fun:strstr\n   obj:/lib/tls/libpthread.so.*\n   obj:/lib/tls/libpthread.so.*\n   fun:call_init\n   fun:_dl_init\n   obj:/lib/ld-*.so\n}\n\n{\n   strlen/_dl_init_paths/dl_main/_dl_sysdep_start(Cond)\n   Memcheck:Cond\n   fun:strlen\n   fun:_dl_init_paths\n   fun:dl_main\n   fun:_dl_sysdep_start\n}\n\n{\n   pthread errno\n   Memcheck:Leak\n   fun:calloc\n   fun:_dlerror_run\n}\n\n{\n   pthread errno\n   Memcheck:Leak\n   fun:calloc\n   fun:_dlerror_run\n   fun:dlclose\n}\n\n\n#\n# Warnings in libz becasue it works with aligned memory(?)\n#\n\n{\n   libz tr_flush_block\n   Memcheck:Cond\n   fun:_tr_flush_block\n   fun:deflate_slow\n   fun:deflate\n   fun:do_flush\n   fun:gzclose\n}\n\n{\n   libz tr_flush_block2\n   Memcheck:Cond\n   fun:_tr_flush_block\n   fun:deflate_slow\n   fun:deflate\n   fun:compress2\n}\n\n{\n   libz longest_match\n   Memcheck:Cond\n   fun:longest_match\n   fun:deflate_slow\n   fun:deflate\n}\n\n{\n   libz deflate\n   Memcheck:Cond\n   obj:*/libz.so.*\n   obj:*/libz.so.*\n   fun:deflate\n   fun:compress2\n}\n\n{\n   libz deflate2\n   Memcheck:Cond\n   obj:*/libz.so.*\n   obj:*/libz.so.*\n   fun:deflate\n   obj:*/libz.so.*\n   fun:gzflush\n}\n\n{\n   libz deflate3\n   Memcheck:Cond\n   obj:*/libz.so.*\n   obj:*/libz.so.*\n   fun:deflate\n   fun:do_flush\n}\n\n{\n  libz deflate4\n  Memcheck:Param\n  write(buf)\n  fun:*\n  fun:my_write\n  fun:do_flush\n  fun:azclose\n}\n\n# Warning from zlib, cf. http://www.zlib.net/zlib_faq.html#faq36\n\n{\n   libz deflate5\n   Memcheck:Cond\n   fun:slide_hash\n   fun:fill_window\n   fun:deflate_fast\n   fun:deflate\n}\n\n#\n# Warning from my_thread_init becasue mysqld dies before kill thread exists\n#\n\n{\n   my_thread_init kill thread memory loss second\n   Memcheck:Leak\n   fun:calloc\n   fun:my_thread_init\n   fun:kill_server_thread\n}\n\n\n# Red Hat AS 4 32 bit\n{\n   dl_relocate_object\n   Memcheck:Cond\n   fun:_dl_relocate_object\n}\n\n#\n# Warning from my_thread_init becasue mysqld dies before kill thread exists\n#\n\n{\n   my_thread_init kill thread memory loss second\n   Memcheck:Leak\n   fun:calloc\n   fun:my_thread_init\n   fun:kill_server_thread\n}\n\n#\n# Leaks reported in _dl_* internal functions on Linux amd64 / glibc2.3.2.\n#\n\n{\n   _dl_start invalid write8\n   Memcheck:Addr8\n   fun:_dl_start\n}\n\n{\n   _dl_start invalid write4\n   Memcheck:Addr4\n   fun:_dl_start\n}\n\n{\n   _dl_start/_dl_setup_hash invalid read8\n   Memcheck:Addr8\n   fun:_dl_setup_hash\n   fun:_dl_start\n}\n\n{\n   _dl_sysdep_start invalid write8\n   Memcheck:Addr8\n   fun:_dl_sysdep_start\n}\n\n{\n   _dl_init invalid write8\n   Memcheck:Addr8\n   fun:_dl_init\n}\n\n{\n   _dl_init invalid write4\n   Memcheck:Addr4\n   fun:_dl_init\n}\n\n{\n   _dl_init/_dl_init invalid read8\n   Memcheck:Addr8\n   fun:_dl_debug_initialize\n   fun:_dl_init\n}\n\n{\n   _dl_init/_dl_debug_state invalid read8\n   Memcheck:Addr8\n   fun:_dl_debug_state\n   fun:_dl_init\n}\n\n{\n   init invalid write8\n   Memcheck:Addr8\n   fun:init\n}\n\n{\n   fixup invalid write8\n   Memcheck:Addr8\n   fun:fixup\n}\n\n{\n   fixup/_dl_lookup_versioned_symbol invalid read8\n   Memcheck:Addr8\n   fun:_dl_lookup_versioned_symbol\n   fun:fixup\n}\n\n{\n   _dl_runtime_resolve invalid read8\n   Memcheck:Addr8\n   fun:_dl_runtime_resolve\n}\n\n{\n   __libc_start_main invalid write8\n   Memcheck:Addr8\n   fun:__libc_start_main\n}\n\n{\n   __libc_start_main/__sigjmp_save invalid write4\n   Memcheck:Addr4\n   fun:__sigjmp_save\n   fun:__libc_start_main\n}\n\n#\n# These seem to be libc threading stuff, not related to MySQL code (allocations\n# during pthread_exit()). Googling shows other projects also using these\n# suppressions.\n#\n# Note that these all stem from pthread_exit() deeper in the call stack, but\n# Valgrind only allows the top four calls in the suppressions.\n#\n\n{\n   libc pthread_exit 1\n   Memcheck:Leak\n   fun:malloc\n   fun:_dl_new_object\n   fun:_dl_map_object_from_fd\n   fun:_dl_map_object\n}\n\n{\n   libc pthread_exit 2\n   Memcheck:Leak\n   fun:malloc\n   fun:_dl_map_object\n   fun:dl_open_worker\n   fun:_dl_catch_error\n}\n\n{\n   libc pthread_exit 3\n   Memcheck:Leak\n   fun:malloc\n   fun:_dl_map_object_deps\n   fun:dl_open_worker\n   fun:_dl_catch_error\n}\n\n{\n   libc pthread_exit 4\n   Memcheck:Leak\n   fun:calloc\n   fun:_dl_check_map_versions\n   fun:dl_open_worker\n   fun:_dl_catch_error\n}\n\n{\n   libc pthread_exit 5\n   Memcheck:Leak\n   fun:calloc\n   fun:_dl_new_object\n   fun:_dl_map_object_from_fd\n   fun:_dl_map_object\n}\n\n{\n   libc pthread_exit 6\n   Memcheck:Leak\n   fun:malloc\n   fun:_dl_map_object\n   fun:openaux\n   fun:_dl_catch_error\n}\n\n{\n   libc pthread_exit 7\n   Memcheck:Leak\n   fun:malloc\n   fun:dl_open_worker\n   fun:_dl_catch_error\n   fun:_dl_open\n}\n\n{\n   libc pthread_exit 8\n   Memcheck:Leak\n   fun:malloc\n   fun:local_strdup\n   fun:_dl_map_object\n   fun:dl_open_worker\n}\n\n# strdup can be inlined\n{\n   libc pthread_exit 9\n   Memcheck:Leak\n   fun:malloc\n   ...\n   fun:expand_dynamic_string_token\n   fun:_dl_map_object\n   fun:dl_open_worker\n}\n\n#\n# This is seen internally in the system libraries on 64-bit RHAS3.\n#\n\n{\n   __lll_mutex_unlock_wake uninitialized\n   Memcheck:Param\n   futex(utime)\n   fun:__lll_mutex_unlock_wake\n}\n\n#\n# BUG#19940: NDB sends uninitialized parts of field buffers across the wire.\n# This is \"works as designed\"; the uninitialized part is not used at the\n# other end (but Valgrind cannot see this).\n#\n{\n   bug19940\n   Memcheck:Param\n   socketcall.sendto(msg)\n   fun:send\n   fun:_ZN15TCP_Transporter6doSendEv\n   fun:_ZN19TransporterRegistry11performSendEv\n   fun:_ZN19TransporterRegistry14forceSendCheckEi\n}\n# Warning when printing stack trace (to suppress some not needed warnings)\n#\n\n{\n   vprintf on stacktrace\n   Memcheck:Cond\n   fun:vfprintf\n   fun:uffered_vfprintf\n   fun:vfprintf\n   fun:fprintf\n   fun:print_stacktrace\n}\n\n#\n# Safe warnings, that may happen because of thread scheduling\n#\n\n{\n   dbug initialization by kill_server\n   Memcheck:Leak\n   fun:malloc\n   fun:DbugMalloc\n   fun:code_state\n   fun:_db_enter_\n   fun:kill_server\n}\n\n#\n# Warning caused by small memory leak in threaded dlopen\n#\n\n{\n   dlopen threaded memory leak\n   Memcheck:Leak\n   fun:calloc\n   obj:*/libdl-*.so\n   fun:dlopen*\n}\n\n{\n   dlopen memory leak\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:calloc\n   fun:_dlerror_run\n   fun:dlsym\n}\n#\n# Pthread doesn't free all thread specific memory before program exists\n#\n{\n   pthread allocate_tls memory loss in 2.6.1.\n   Memcheck:Leak\n   fun:calloc\n   obj:*/ld-*.so\n   fun:_dl_allocate_tls\n   fun:pthread_create*\n}\n\n{\n   buf_buddy_relocate peeking (space,page) in potentially free blocks\n   Memcheck:Addr1\n   fun:buf_buddy_relocate\n}\n\n{\n   Bug 59874 Valgrind warning in InnoDB compression code\n   Memcheck:Cond\n   fun:*\n   fun:*\n   fun:deflate\n   fun:btr_store_big_rec_extern_fields_func\n   fun:row_ins_index_entry_low\n   fun:row_ins_index_entry\n   fun:row_ins_index_entry_step\n   fun:row_ins\n   fun:row_ins_step\n   fun:row_insert_for_mysql\n}\n\n{\n   In page0zip.c we have already checked that the memory is initialized before calling deflate()\n   Memcheck:Cond\n   fun:*\n   fun:*\n   fun:deflate\n   fun:page_zip_compress\n}\n\n{\n   In page0zip.c we have already checked that the memory is initialized before calling deflate()\n   Memcheck:Cond\n   fun:*\n   fun:*\n   fun:deflate\n   fun:page_zip_compress_deflate\n}\n\n{\n   In page0zip.c we have already checked that the memory is initialized before calling deflate()\n   Memcheck:Cond\n   obj:*/libz.so*\n   obj:*/libz.so*\n   fun:deflate\n   fun:page_zip_compress\n   fun:page_zip_reorganize\n   fun:page_cur_insert_rec_zip_reorg\n   fun:page_cur_insert_rec_zip\n   fun:page_cur_tuple_insert\n   fun:btr_cur_optimistic_insert\n   fun:btr_cur_pessimistic_insert\n   fun:row_ins_index_entry_low\n   fun:row_ins_index_entry\n   fun:row_ins_index_entry_step\n   fun:row_ins\n   fun:row_ins_step\n   fun:row_insert_for_mysql\n}\n\n{\n   In page0zip.c we have already checked that the memory is initialized before calling deflate()\n   Memcheck:Cond\n   obj:*/libz.so*\n   obj:*/libz.so*\n   fun:deflate\n   fun:page_zip_compress\n   fun:page_zip_reorganize\n   fun:page_cur_insert_rec_zip_reorg\n   fun:page_cur_insert_rec_zip\n   fun:page_cur_tuple_insert\n   fun:btr_cur_optimistic_insert\n   fun:row_ins_index_entry_low\n   fun:row_ins_index_entry\n   fun:row_ins_index_entry_step\n   fun:row_ins\n   fun:row_ins_step\n   fun:row_insert_for_mysql\n}\n\n{\n   In page0zip.c we have already checked that the memory is initialized before calling deflate()\n   Memcheck:Cond\n   obj:*/libz.so*\n   obj:*/libz.so*\n   fun:deflate\n   fun:page_zip_compress\n   fun:page_copy_rec_list_end\n   fun:page_move_rec_list_end\n   fun:btr_page_split_and_insert\n   fun:btr_root_raise_and_insert\n   fun:btr_cur_pessimistic_insert\n   fun:row_ins_index_entry_low\n   fun:row_ins_index_entry\n   fun:row_ins_index_entry_step\n   fun:row_ins\n   fun:row_ins_step\n   fun:row_insert_for_mysql\n}\n\n{\n   In page0zip.c we have already checked that the memory is initialized before calling deflate()\n   Memcheck:Cond\n   obj:*/libz.so*\n   obj:*/libz.so*\n   fun:deflate\n   fun:page_zip_compress\n   fun:page_cur_insert_rec_zip_reorg\n   fun:page_cur_insert_rec_zip\n   fun:page_cur_tuple_insert\n   fun:btr_cur_optimistic_insert\n   fun:btr_cur_pessimistic_insert\n   fun:row_ins_index_entry_low\n   fun:row_ins_index_entry\n   fun:row_ins_index_entry_step\n   fun:row_ins\n   fun:row_ins_step\n   fun:row_insert_for_mysql\n}\n\n{\n   Bug 59875 Valgrind warning in buf0buddy.c\n   Memcheck:Addr1\n   fun:mach_read_from_4\n   fun:buf_buddy_relocate\n   fun:buf_buddy_free_low\n   fun:buf_buddy_free\n}\n{\n   zlib longest_match false positive\n   Memcheck:Cond\n   fun:longest_match\n   fun:deflate_slow\n   fun:deflate\n   fun:compress\n   fun:my_compress_alloc\n}\n\n#\n# NDB packfrm vs deflate\n#\n{\n   NDB packfrm case 1\n   Memcheck:Cond\n   fun:deflate_slow\n   fun:deflate\n   fun:compress\n   fun:my_compress_alloc\n   fun:my_compress\n   fun:packfrm\n}\n\n{\n   NDB packfrm case 2\n   Memcheck:Cond\n   fun:longest_match\n   fun:deflate_slow\n   fun:deflate\n   fun:compress\n   fun:my_compress_alloc\n   fun:my_compress\n   fun:packfrm\n}\n\n#\n# pfs vs compress\n#\n{\n   pfs vs. compress case 1\n   Memcheck:Cond\n   fun:longest_match\n   fun:deflate_slow\n   fun:deflate\n   fun:compress\n   fun:my_compress_alloc\n   fun:my_compress\n}\n\n{\n   pfs vs. compress case 2\n   Memcheck:Cond\n   fun:deflate_slow\n   fun:deflate\n   fun:compress\n   fun:my_compress_alloc\n   fun:my_compress\n}\n\n# Note the wildcard in the (mangled) function signatures of\n# write_keys() and find_all_keys().\n# They both return ha_rows, which is platform dependent.\n#\n# The '...' wildcards are for 'fun:inline_mysql_file_write' which *may*\n# be inlined.\n{\n   Bug#12856915 VALGRIND FAILURE IN FILESORT/CREATE_SORT_INDEX / one\n   Memcheck:Param\n   write(buf)\n   ...\n   fun:_Z19my_b_flush_io_cacheP8IO_CACHEi\n   fun:_Z11_my_b_writeP8IO_CACHEPKhm\n   ...\n   fun:_Z*10write_keysP10Sort_paramP13Filesort_infojP8IO_CACHES4_\n   ...\n   fun:_Z8filesortP3THDP8Filesort*\n}\n\n{\n   Bug#12856915 VALGRIND FAILURE IN FILESORT/CREATE_SORT_INDEX / three\n   Memcheck:Param\n   write(buf)\n   ...\n   fun:_Z19my_b_flush_io_cacheP8IO_CACHEi\n   fun:_Z8filesortP3THDP8Filesort*\n}\n\n# http://www.openldap.org/its/index.cgi/Software%20Bugs?id=9081;page=23\n# Memory leak in ldap_initialize/ldap_unbind\n# Version: 2.4.48\n# Fixed in RE24 (2.4.49)\n{\n   OpenLDAP bug 9081\n   Memcheck:Leak\n   match-leak-kinds: definite\n   fun:calloc\n   fun:ber_memcalloc_x\n   fun:ber_memcalloc\n   fun:ber_sockbuf_alloc\n   fun:ldap_create\n   fun:ldap_initialize\n}\n\n# sasl_client_init will load all available plugins with _sasl_load_plugins().\n# It seems some of the SASL plugin have leaks.\n# We *do* call sasl_client_done, which calls _sasl_done_with_plugins\n# Both LSAN and Valgrind report leaks.\n{\n   Loading SASL plugins 1\n   Memcheck:Leak\n   match-leak-kinds: definite\n   fun:malloc\n   ...\n   fun:sasl_client_add_plugin\n}\n\n{\n   Loading SASL plugins 2\n   Memcheck:Leak\n   match-leak-kinds: indirect\n   fun:malloc\n   ...\n   fun:sasl_client_add_plugin\n}\n\n{\n   Unloading SASL plugins\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   ...\n   fun:dlclose\n   fun:_sasl_done_with_plugins\n}\n\n{\n   cyrus libsasl2 still reachable one\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   ...\n   fun:sasl_client_init\n}\n\n{\n   cyrus libsasl2 still reachable two\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:calloc\n   ...\n   fun:sasl_client_init\n}\n\n{\n   cyrus libsasl2 still reachable three\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   ...\n   fun:sasl_set_path\n}\n\n{\n   OpenSSL still reachable.\n   Memcheck:Leak\n   fun:malloc\n   ...\n   fun:CRYPTO_malloc\n   fun:sk_new\n   ...\n   fun:SSL_COMP_get_compression_methods\n   fun:SSL_library_init\n}\n\n{\n   OpenSSL still reachable.\n   Memcheck:Leak\n   fun:malloc\n   fun:CRYPTO_malloc\n   fun:engine_cleanup_add_last\n   fun:ENGINE_add\n}\n\n{\n   OpenSSL still reachable.\n   Memcheck:Leak\n   fun:malloc\n   fun:CRYPTO_malloc\n   fun:sk_new\n   fun:engine_cleanup_add_last\n   fun:ENGINE_add\n}\n\n{\n   OpenSSL still reachable.\n   Memcheck:Leak\n   fun:malloc\n   fun:CRYPTO_malloc\n   fun:ENGINE_new\n}\n\n{\n  OpenSSL still reachable.\n  Memcheck:Leak\n  match-leak-kinds: reachable\n  fun:malloc\n  fun:CRYPTO_malloc\n  ...\n  fun:ERR_peek_error\n  fun:vio_ssl_read\n  ...\n}\n\n{\n  OpenSSL still reachable.\n  Memcheck:Leak\n  match-leak-kinds: reachable\n  fun:malloc\n  fun:CRYPTO_malloc\n  ...\n  fun:ERR_peek_error\n  ...\n  fun:sslaccept\n  ...\n  fun:server_mpvio_read_packet\n  ...\n}\n\n{\n   Bug#16039908 \"BYTES STILL REACHABLE\" IN VALGRIND TEST ON 5.6/TRUNK\n   Memcheck:Leak\n   fun:calloc\n   fun:_dlerror_run\n   fun:dlclose\n   fun:_ZL15free_plugin_memP12st_plugin_dl\n   fun:_ZL13plugin_dl_delPK16MYSQL_LEX_STRING\n   fun:_ZL10plugin_delP13st_plugin_int\n   fun:_ZL12reap_pluginsv\n   fun:_Z15plugin_shutdownv\n   fun:_Z*8clean_upb*\n}\n\n{\n   main.udf gives similar warning as Bug#16039908\n   Memcheck:Leak\n   fun:calloc\n   fun:_dlerror_run\n   fun:dlclose\n   fun:_Z*udf_deinitv\n   fun:_Z*8clean_upb*\n}\n\n#Suppress warnings from glibc implementation of 'malloc_info'\n{\n   Malloc_info uninitialised value of size 8\n   Memcheck:Value8\n   fun:_itoa_word\n   fun:vfprintf\n   fun:fprintf\n   fun:mi_arena.*\n   fun:malloc_info\n}\n\n{\n   Malloc_info conditional jump depends on uninitialised values\n   Memcheck:Cond\n   ...\n   fun:mi_arena.*\n   fun:malloc_info\n}\n\n# TokuDB suppressions\n{\n   tls_variables_1\n   Memcheck:Leak\n   fun:memalign\n   fun:__tls_get_addr\n}\n\n{\n   tls_variables_2\n   Memcheck:Leak\n   fun:memalign\n   fun:tls_get_addr_tail\n}\n\n{\n   lzma encoder prepare bug\n   Memcheck:Cond\n   fun:lz_encoder_prepare\n   fun:lzma_lz_encoder_init\n}\n\n#supress warnings from openssl random generator\n\n{\n   OpenSSL conditional jump in ssl3_ctx_ctrl\n   Memcheck:Cond\n   ...\n   fun:ssl3_ctx_ctrl\n   fun:new_VioSSLFd\n}\n\n{\n   OpenSSL conditional jump in RAND_DRBG_generate\n   Memcheck:Cond\n   ...\n   fun:RAND_DRBG_generate\n}\n\n{\n   OpenSSL uninitialised value of size 8 in new_VioSSLFd\n   Memcheck:Value8\n   fun:BN_num_bits_word\n   fun:BN_num_bits\n   ...\n   fun:new_VioSSLFd\n}\n\n{\n   OpenSSL uninitialised value of size 8 in new_VioSSLFd\n   Memcheck:Value8\n   fun:BN_mod_exp_mont_consttime\n   ...\n   fun:new_VioSSLFd\n}\n\n{\n   OpenSSL PB2 / 1\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   fun:CRYPTO_malloc\n   fun:sk_new\n   fun:SSL_COMP_get_compression_methods\n   fun:SSL_library_init\n   fun:ssl_start\n   fun:_Z8init_sslv\n   fun:_Z11mysqld_mainiPPc\n   fun:main\n}\n\n{\n   OpenSSL PB2 / 2\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   fun:CRYPTO_malloc\n   fun:sk_new\n   fun:SSL_COMP_get_compression_methods\n   fun:SSL_library_init\n   fun:ssl_start\n   fun:_ZL8init_sslv\n   fun:_Z11mysqld_mainiPPc\n   fun:main\n}\n\n\n{\n   OpenSSL libstdc++ version 5 / one\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   fun:CRYPTO_malloc\n   fun:sk_new\n   obj:/lib/x86_64-linux-gnu/libssl.so.1.0.0\n   fun:SSL_COMP_get_compression_methods\n   fun:SSL_library_init\n   fun:ssl_start\n   fun:_ZL8init_sslv\n   fun:_Z11mysqld_mainiPPc\n   fun:main\n}\n\n{\n   OpenSSL libstdc++ version 5 / two\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   fun:CRYPTO_malloc\n   fun:sk_new\n   obj:/lib/x86_64-linux-gnu/libssl.so.1.0.0\n   fun:SSL_COMP_get_compression_methods\n   fun:SSL_library_init\n   fun:ssl_start\n   fun:_ZL8init_sslv\n   fun:_Z11mysqld_mainiPPc\n   fun:main\n}\n\n{\n   OpenSSL libstdc++ version 5 / three\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   ...\n   fun:call_init.part.0\n   fun:call_init\n   fun:_dl_init\n}\n\n# supress uninitialized because some SSL libraries do random like that\n{\n   OpenSSL conditional jump in generate_user_salt due to randomness 1\n   Memcheck:Cond\n   fun:generate_user_salt\n   fun:native_password_authenticate\n}\n\n{\n   OpenSSL conditional jump in generate_user_salt due to randomness 2\n   Memcheck:Cond\n   fun:_Z18generate_user_saltPci\n   fun:_ZL34caching_sha2_password_authenticateP16MYSQL_PLUGIN_VIOP22MYSQL_SERVER_AUTH_INFO\n}\n\n# Remove the NUMA ones below when https://github.com/numactl/numactl/issues/3\n# is resolved.\n\n{\n   libnuma fails to free its internally allocated memory 1\n   Memcheck:Leak\n   fun:malloc\n   fun:numa_bitmask_alloc\n}\n\n{\n   libnuma fails to free its internally allocated memory 2\n   Memcheck:Leak\n   fun:calloc\n   fun:numa_bitmask_alloc\n}\n\n{\n   libnuma fails to free its internally allocated memory 3\n   Memcheck:Leak\n   fun:calloc\n   ...\n   fun:numa_node_*_cpu*\n}\n\n{\n   General protobuf globals\n   Memcheck:Leak\n   fun:_Znwm\n   ...\n   fun:_GLOBAL__sub_I_mysqlx*.pb.cc\n   ...\n}\n\n{\n   General protobuf globals\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:_Znwm\n   ...\n   fun:_Z41__static_initialization_and_destruction_0ii\n}\n\n{\n   General protobuf globals\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:_Znwm\n   ...\n   fun:_ZN6Mysqlx23protobuf_mysqlx_2eproto27StaticDescriptorInitializerC1Ev\n}\n\n{\n   mysqlx plugin install\n   Memcheck:Leak\n   fun:*alloc\n   ...\n   fun:_dl_catch_error\n   ...\n   fun:dlopen*\n   ...\n   fun:_ZL13plugin_dl_addPK16MYSQL_LEX_STRINGi*\n   ...\n}\n\n# supress inability to cleanup OpenSSL error contexts in GR\n{\n   OpenSSL GR suppress leak 1\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   fun:CRYPTO_malloc\n   fun:ERR_get_state\n   fun:ERR_clear_error\n   obj:*\n   obj:*\n   obj:*\n   obj:*\n   obj:*\n   obj:*\n   obj:*\n   obj:*\n   obj:*\n   fun:_ZN14Trans_delegate13before_commitEP3THDbP8IO_CACHES3_y\n   fun:_ZN13MYSQL_BIN_LOG6commitEP3THDb\n   fun:_Z17trans_commit_stmtP3THD\n}\n\n{\n   OpenSSL GR suppress leak 2\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   fun:CRYPTO_malloc\n   fun:ERR_get_state\n   fun:ERR_clear_error\n   obj:*\n   obj:*\n   obj:*\n   obj:*\n   obj:*\n   obj:*\n   obj:*\n   obj:*\n   obj:*\n   fun:_ZN14Trans_delegate13before_commitEP3THDbP8IO_CACHES3_y\n   fun:_ZN13MYSQL_BIN_LOG6commitEP3THDb\n   fun:_Z15ha_commit_transP3THDbb\n}\n\n{\n   OpenSSL GR suppress leak 3\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   ...\n   fun:CRYPTO_malloc\n   fun:lh_insert\n   fun:int_thread_set_item\n   fun:ERR_get_state\n   fun:ERR_clear_error\n   obj:*\n   obj:*\n   obj:*\n   obj:*\n   obj:*\n   obj:*\n   obj:*\n   obj:*\n   obj:*\n   fun:_ZN14Trans_delegate13before_commitEP3THDbP8IO_CACHES3_y\n}\n\n{\n   OpenSSL GR suppress leak 4\n   Memcheck:Leak\n   match-leak-kinds: all\n   fun:malloc\n   ...\n   fun:CRYPTO_malloc\n   fun:lh_new\n   obj:*\n   obj:*\n   fun:ERR_get_state\n   fun:ERR_put_error\n   fun:PEM_read_bio\n   fun:PEM_X509_INFO_read_bio\n   fun:X509_load_cert_crl_file\n   obj:*\n   fun:X509_STORE_load_locations\n   ...\n}\n\n{\n   Spurious dlerror_run errors on main.udf\n   Memcheck:Leak\n   ...\n   fun:dlerror_run\n}\n\n{\n  OpenSSL still reachable.\n  Memcheck:Leak\n  match-leak-kinds: reachable\n  fun:malloc\n  fun:CRYPTO_malloc\n  ...\n  fun:ERR_peek_error\n  fun:vio_ssl_read\n  ...\n}\n\n{\n  OpenSSL still reachable.\n  Memcheck:Leak\n  match-leak-kinds: reachable\n  fun:malloc\n  fun:CRYPTO_malloc\n  ...\n  fun:ERR_peek_error\n  ...\n  fun:sslaccept\n  ...\n  fun:server_mpvio_read_packet\n  ...\n}\n\n#\n# Rules to suppress leaks from plugin dependencies\n#\n\n{\n  TPL leak 1\n  Memcheck:Leak\n  match-leak-kinds: reachable\n  fun:malloc\n  fun:CRYPTO_malloc\n  fun:BUF_strndup\n  fun:CONF_module_add\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  fun:_ZL17plugin_initializeP13st_plugin_int\n  ...\n}\n\n{\n  TPL leak 2\n  Memcheck:Leak\n  match-leak-kinds: reachable\n  fun:malloc\n  fun:CRYPTO_malloc\n  fun:BUF_strndup\n  fun:CONF_module_add\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  fun:_ZL17plugin_initializeP13st_plugin_int\n  ...\n}\n\n{\n  TPL leak 3\n  Memcheck:Leak\n  match-leak-kinds: reachable\n  fun:malloc\n  ...\n  fun:CRYPTO_malloc\n  fun:lh_insert\n  fun:int_thread_set_item\n  fun:ERR_get_state\n  fun:ERR_clear_error\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  fun:_ZL17plugin_initializeP13st_plugin_int\n  ...\n}\n\n{\n  TPL leak 4\n  Memcheck:Leak\n  match-leak-kinds: reachable\n  fun:malloc\n  fun:CRYPTO_malloc\n  fun:sk_new\n  fun:CONF_module_add\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  fun:_ZL17plugin_initializeP13st_plugin_int\n  ...\n}\n\n{\n  TPL leak 5\n  Memcheck:Leak\n  match-leak-kinds: reachable\n  fun:malloc\n  fun:CRYPTO_malloc\n  fun:sk_new\n  fun:SSL_COMP_get_compression_methods\n  fun:SSL_library_init\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  fun:_ZL17plugin_initializeP13st_plugin_int\n  ...\n}\n\n{\n  TPL leak 6\n  Memcheck:Leak\n  match-leak-kinds: reachable\n  fun:malloc\n  fun:CRYPTO_malloc\n  fun:CONF_module_add\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  fun:_ZL17plugin_initializeP13st_plugin_int\n  ...\n}\n\n{\n  TPL leak 7\n  Memcheck:Leak\n  match-leak-kinds: reachable\n  fun:malloc\n  fun:CRYPTO_malloc\n  fun:CONF_module_add\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  fun:_ZL17plugin_initializeP13st_plugin_int\n  ...\n}\n\n{\n  TPL leak 8\n  Memcheck:Leak\n  match-leak-kinds: reachable\n  fun:malloc\n  ...\n  fun:CRYPTO_malloc\n  fun:lh_new\n  fun:int_thread_get\n  fun:int_thread_set_item\n  fun:ERR_get_state\n  fun:ERR_clear_error\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  fun:_ZL17plugin_initializeP13st_plugin_int\n  ...\n}\n\n{\n  TPL leak 9\n  Memcheck:Leak\n  match-leak-kinds: reachable\n  fun:malloc\n  fun:CRYPTO_malloc\n  fun:ERR_get_state\n  fun:ERR_clear_error\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  fun:_ZL17plugin_initializeP13st_plugin_int\n  ...\n}\n\n{\n  TPL leak 10\n  Memcheck:Leak\n  match-leak-kinds: definite\n  fun:malloc\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  fun:_ZL17plugin_initializeP13st_plugin_int\n  ...\n}\n\n{\n  TPL leak 11\n  Memcheck:Leak\n  match-leak-kinds: reachable\n  fun:malloc\n  ...\n  fun:CRYPTO_malloc\n  fun:ERR_get_state\n  fun:ERR_put_error\n  fun:PEM_read_bio\n  fun:PEM_X509_INFO_read_bio\n  fun:X509_load_cert_crl_file\n  fun:by_file_ctrl\n  fun:X509_STORE_load_locations\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  fun:_ZL17plugin_initializeP13st_plugin_int\n}\n\n{\n  TPL leak 12\n  Memcheck:Leak\n  match-leak-kinds: reachable\n  fun:malloc\n  fun:CRYPTO_malloc\n  fun:BUF_strndup\n  fun:CONF_module_add\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n}\n\n{\n  TPL leak 13\n  Memcheck:Leak\n  match-leak-kinds: reachable\n  fun:malloc\n  fun:CRYPTO_malloc\n  fun:CONF_module_add\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n}\n\n{\n  TPL leak 14\n  Memcheck:Leak\n  match-leak-kinds: reachable\n  fun:malloc\n  fun:CRYPTO_malloc\n  fun:sk_new\n  fun:SSL_COMP_get_compression_methods\n  fun:SSL_library_init\n  obj:*\n  fun:_ZL17plugin_initializeP13st_plugin_int\n  ...\n}\n\n{\n  TPL leak 15\n  Memcheck:Leak\n  match-leak-kinds: all\n  fun:malloc\n  ...\n  fun:CRYPTO_malloc\n  fun:lh_insert\n  obj:*\n  fun:ERR_get_state\n  fun:ERR_put_error\n  fun:PEM_read_bio\n  fun:PEM_X509_INFO_read_bio\n  fun:X509_load_cert_crl_file\n  obj:*\n  fun:X509_STORE_load_locations\n  ...\n}\n\n{\n  TPL leak 16\n  Memcheck:Leak\n  match-leak-kinds: reachable\n  fun:realloc\n  fun:CRYPTO_realloc\n  fun:sk_insert\n  fun:CONF_module_add\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  fun:_ZL17plugin_initializeP13st_plugin_int\n  ...\n}\n\n{\n  TPL leak 17\n  Memcheck:Leak\n  match-leak-kinds: reachable\n  fun:malloc\n  ...\n  fun:CRYPTO_malloc\n  fun:lh_insert\n  fun:int_thread_set_item\n  fun:ERR_get_state\n  fun:ERR_clear_error\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n}\n\n{\n  TPL leak 18\n  Memcheck:Leak\n  match-leak-kinds: reachable\n  fun:malloc\n  ...\n  fun:CRYPTO_malloc\n  fun:lh_insert\n  fun:int_thread_set_item\n  fun:ERR_get_state\n  fun:ERR_clear_error\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n}\n\n{\n  TPL leak 19\n  Memcheck:Leak\n  match-leak-kinds: reachable\n  fun:malloc\n  fun:CRYPTO_malloc\n  fun:ERR_get_state\n  fun:ERR_clear_error\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n}\n\n{\n  TPL leak 20\n  Memcheck:Leak\n  match-leak-kinds: definite\n  fun:malloc\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  fun:_ZL17plugin_initializeP13st_plugin_int\n  ...\n}\n\n{\n  TPL leak 21\n  Memcheck:Leak\n  match-leak-kinds: possible\n  fun:malloc\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  fun:_ZL17plugin_initializeP13st_plugin_int\n  ...\n}\n\n{\n  TPL leak 22\n  Memcheck:Leak\n  match-leak-kinds: possible\n  fun:malloc\n  ...\n  fun:CRYPTO_malloc\n  fun:lh_new\n  fun:int_thread_get\n  fun:int_thread_set_item\n  fun:ERR_get_state\n  fun:ERR_clear_error\n  fun:ENGINE_load_builtin_engines\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n  obj:*\n}\n\n{\n   TPL leak 23\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:malloc\n   fun:_ZL13my_raw_mallocmi\n   fun:_Z9my_mallocjmi\n   fun:_ZL17my_openssl_mallocm\n   fun:CRYPTO_malloc\n   ...\n}\n\n# Workarounds for\n#\n# Bug#26116237 SYSCALL PARAM PPOLL(SIGMASK) POINTS TO UNADDRESSABLE BYTE\n{\n   RPL workaround 1\n   Memcheck:Param\n   ppoll(sigmask)\n   fun:ppoll\n   fun:vio_io_wait\n}\n\n{\n   RPL workaround 2\n   Memcheck:Param\n   ppoll(sigmask)\n   fun:ppoll\n   fun:_Z11vio_io_waitP3Vio17enum_vio_io_eventi\n}\n\n# Workarounds for\n#\n# Bug#22833138 KEYRING_OKV : MEMORY LEAKS FROM OKV CLIENT LIB\n{\n   Keyring_OKV_workaround_addtoTagObj\n   Memcheck:Leak\n   fun:malloc\n   fun:okimem_nat_malloc\n   fun:OKIMemAlloc\n   fun:addtoTagObj\n}\n{\n   Keyring_OKV_workaround_OKIGetKey\n   Memcheck:Leak\n   fun:malloc\n   fun:okimem_nat_malloc\n   fun:OKIMemAlloc\n   fun:OKIAPIResultAlloc\n   fun:OKIGetKey\n}\n{\n   Keyring_OKV_workaround_OKICreateKey\n   Memcheck:Leak\n   fun:malloc\n   fun:okimem_nat_malloc\n   fun:OKIMemAlloc\n   fun:OKIAPIResultAlloc\n   fun:OKICreateKey\n}\n{\n   Keyring_OKV_workaround_okiconn_ssl_send_recv\n   Memcheck:Leak\n   fun:calloc\n   ...\n   fun:OKIConnSendRecvBytes\n   fun:OKIOpsExecuteOp\n}\n{\n   Keyring_OKV_workaround_OKIGetAttributes\n   Memcheck:Leak\n   fun:malloc\n   fun:okimem_nat_malloc\n   fun:OKIMemAlloc\n   fun:OKIAPIResultAlloc\n   fun:OKIGetAttributes\n}\n{\n   Keyring_OKV_workaround_OKIGetAttributes2\n   Memcheck:Leak\n   fun:malloc\n   fun:okimem_nat_malloc\n   fun:OKIMemAlloc\n   fun:OKIPostGetUIDTTLV\n   fun:OKIAPIPostProcessing\n   fun:OKIGetAttributes\n}\n{\n   Keyring_OKV_workaround_OKIAddAttribute\n   Memcheck:Leak\n   fun:malloc\n   fun:okimem_nat_malloc\n   fun:OKIMemAlloc\n   fun:OKIAPIResultAlloc\n   fun:OKIAddAttribute\n}\n{\n   Keyring_OKV_workaround_OKIAddAttribute2\n   Memcheck:Leak\n   match-leak-kinds: definite\n   fun:malloc\n   fun:okimem_nat_malloc\n   fun:OKIMemAlloc\n   fun:OKIOpsCreate\n   fun:OKIAddAttribute\n}\n{\n   Keyring_OKV_workaround_OKILocate\n   Memcheck:Leak\n   fun:malloc\n   fun:okimem_nat_malloc\n   fun:OKIMemAlloc\n   fun:OKIAPIResultAlloc\n   fun:OKILocate\n}\n{\n   Keyring_OKV_workaround_OKIActivate\n   Memcheck:Leak\n   fun:malloc\n   fun:okimem_nat_malloc\n   fun:OKIMemAlloc\n   fun:OKIAPIResultAlloc\n   fun:OKIActivate\n}\n{\n   Keyring_OKV_workaround_OKIRegKey\n   Memcheck:Leak\n   match-leak-kinds: definite\n   fun:malloc\n   fun:okimem_nat_malloc\n   fun:OKIMemAlloc\n   fun:OKIAPIResultAlloc\n   fun:OKIRegKey\n}\n{\n   Keyring_OKV_workaround_OKIRevoke\n   Memcheck:Leak\n   fun:malloc\n   fun:okimem_nat_malloc\n   fun:OKIMemAlloc\n   fun:OKIAPIResultAlloc\n   fun:OKIRevoke\n}\n{\n   Keyring_OKV_workaround_OKIEnvCreate\n   Memcheck:Leak\n   fun:malloc\n   fun:okimem_nat_malloc\n   fun:OKIMemAlloc\n   fun:OKIEnvCreate\n}\n{\n   Keyring_OKV_workaround_OKITTLVMoveChildWithTag\n   Memcheck:Leak\n   fun:malloc\n   fun:okimem_nat_malloc\n   fun:OKIMemAlloc\n   fun:OKITTLVMoveChildWithTag\n}\n{\n   Keyring_OKV_workaround_OKIParseUnpackTTLVFromBuffer\n   Memcheck:Leak\n   fun:malloc\n   fun:okimem_nat_malloc\n   fun:OKIMemAlloc\n   fun:OKIParseUnpackTTLVFromBuffer\n}\n{\n   Keyring_OKV_workaround_OKITTLVAddChildObject\n   Memcheck:Leak\n   fun:malloc\n   fun:okimem_nat_malloc\n   fun:OKIMemAlloc\n   fun:OKITTLVAddChildObject\n}\n\n# Bug#27209265 Suppress all issues relating to communication with AWS KMS server.\n\n{\n   OpenSSL still reachable.\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   ...\n   fun:CRYPTO_malloc\n   fun:ERR_get_state\n   fun:ERR_put_error\n   fun:PEM_read_bio\n   fun:PEM_X509_INFO_read_bio\n   fun:X509_load_cert_crl_file\n   fun:by_file_ctrl\n   fun:X509_STORE_load_locations\n   obj:*\n   obj:*\n   obj:*\n   obj:*\n   obj:*\n   obj:*\n   obj:*\n}\n\n# Bug #25964438  LDAP: ASAN AND VALGRIND ISSUES\n\n{\n   LDAP_TLS_workaround1\n   Memcheck:Leak\n   fun:calloc\n   ...\n   ...\n   ...\n   ...\n   ...\n   fun:ldap_int_tls_start\n   fun:ldap_start_tls_s\n   fun:*establish_tls*\n   fun:*create*\n}\n{\n   LDAP_TLS_workaround2\n   Memcheck:Leak\n   fun:malloc\n   ...\n   ...\n   ...\n   ...\n   ...\n   fun:ldap_int_tls_start\n   fun:ldap_start_tls_s\n   fun:*establish_tls*\n   fun:*create*\n}\n{\n   LDAP_TLS_workaround3\n   Memcheck:Leak\n   fun:calloc\n   fun:PR_LoadLibraryWithFlags\n   ...\n   ...\n   ...\n   fun:PR_CallOnce\n   ...\n   ...\n   fun:_dl_init\n}\n{\n   LDAP_TLS_workaround4\n   Memcheck:Leak\n   fun:malloc\n   fun:PR_ErrorInstallTable\n   fun:PR_CallOnce\n   ...\n   ...\n   fun:PR_CallOnceWithArg\n   ...\n   fun:NSS_SetDomesticPolicy\n   ...\n   fun:PR_CallOnceWithArg\n   ...\n   ...\n   ...\n   fun:ldap_int_tls_start\n   fun:ldap_start_tls_s\n   fun:*establish_tls*\n}\n{\n   LDAP_TLS_workaround5\n   Memcheck:Leak\n   fun:malloc\n   ...\n   fun:PR_LoadLibraryWithFlags\n   ...\n   ...\n   ...\n   fun:PR_CallOnce\n   ...\n   ...\n   ...\n   ...\n   fun:_dl_catch_error\n   fun:_dl_open\n   fun:dlopen_doit\n   fun:_dl_catch_error\n   fun:_dlerror_run\n}\n{\n   LDAP_TLS_workaround6\n   Memcheck:Leak\n   fun:malloc\n   fun:ber_memalloc_x\n   fun:ber_strdup_x\n   ...\n   fun:ldap_int_initialize\n   fun:ldap_create\n   fun:ldap_initialize\n   fun:*create*\n}\n{\n   LDAP_TLS_workaround7\n   Memcheck:Leak\n   fun:malloc\n   fun:*dl_close_worker*\n   fun:*dl_close*\n   fun:*dl_catch_error*\n   ...\n   fun:*free_mem*\n   fun:*libc_freeres*\n   fun:*vgnU_freeres*\n   fun:*run_exit_handlers*\n   fun:exit*\n   fun:*mysqld_exit*\n   fun:*mysqld_main*\n   fun:*main*\n}\n{\n   LDAP_TLS_workaround8\n   Memcheck:Leak\n   fun:malloc\n   fun:ber_memalloc_x\n   fun:ber_strdup_x\n   ...\n   fun:ldap_int_initialize\n   fun:ldap_set_option\n   fun:*configure_tls*\n}\n{\n   LDAP_TLS_workaround9\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   fun:PR_ErrorInstallTable\n   ...\n   ...\n   ...\n   ...\n   ...\n   ...  \n   ...\n   ...\n   ...\n   ...\n   ...\n   ...\n   fun:ldap_int_tls_start\n   fun:ldap_start_tls_s\n}\n# The issue with GNU libc version 2.17 when linux hosts doesn't have IPv6 configured.\n# This is because libc points the cache (that is freed on exit) to a static variable\n# if there is no ipv6 address, which later results in freeing an invalid pointer.\n{\n   libc_217_ipv6_issue\n   Memcheck:Free\n   fun:free\n   fun:__libc_freeres\n   fun:_vgnU_freeres\n   fun:__run_exit_handlers\n   fun:exit\n   fun:*mysqld_exit*\n   fun:*mysqld_main*\n   fun:*main*\n}\n{\n   SIGSTOP_and_SIGCONT in gr tests\n   Memcheck:Cond\n   fun:signal_hand\n   fun:pfs_spawn_thread\n   fun:start_thread\n   fun:clone\n}\n{\n   Mysqlx: OpenSSL cert file still possible.\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:malloc\n   ...\n   fun:CRYPTO_malloc\n   fun:ERR_get_state\n   fun:ERR_put_error\n   fun:PEM_read_bio\n   fun:PEM_X509_INFO_read_bio\n   fun:X509_load_cert_crl_file\n   fun:*\n   fun:X509_STORE_load_locations\n   fun:*\n   fun:*\n   fun:*\n   fun:*\n}\n\n{\n   LDAP_1\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   fun:PORT_Alloc_Util\n   obj:/usr/lib64/libnss3.so\n   obj:/usr/lib64/libnss3.so\n   fun:SECMOD_LoadModule\n   ...\n   fun:ldap_int_tls_start\n   fun:ldap_start_tls_s\n   ...\n}\n\n\n{\n   LDAP_2\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   fun:NSSRWLock_New_Util\n   fun:SECOID_Init\n   obj:/usr/lib64/libsoftokn3.so\n   ...\n   fun:dlopen_doit\n   fun:_dl_catch_error\n   fun:_dlerror_run\n   ...\n}\n\n\n{\n   LDAP_3\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   fun:strdup\n   fun:PR_LoadLibraryWithFlags\n   ...\n   fun:tlsmc_open_nssdb\n   fun:tlsmc_convert\n   fun:tlsmc_intercept_initialization\n   obj:/usr/lib64/libldap-2.4.so.2.10.7\n   ...\n}\n\n{\n   LDAP_4\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   fun:strdup\n   fun:_dl_load_cache_lookup\n   fun:_dl_map_object\n   fun:openaux\n   ...\n   fun:PR_LoadLibraryWithFlags\n   obj:/usr/lib64/libnssutil3.so\n}\n\n{\n   LDAP_5\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:calloc\n   fun:PR_LoadLibraryWithFlags\n   ...\n   obj:/usr/lib64/libnss3.so\n   ...\n   fun:tlsmc_open_nssdb\n   fun:tlsmc_convert\n   fun:tlsmc_intercept_initialization\n   obj:/usr/lib64/libldap-2.4.so.2.10.7\n   ...\n}\n\n{\n   LDAP_6\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   fun:PL_NewHashTable\n   fun:SECOID_Init\n   obj:/usr/lib64/libsoftokn3.so\n   ...\n   fun:PR_LoadLibraryWithFlags\n   obj:/usr/lib64/libnssutil3.so\n   fun:PORT_LoadLibraryFromOrigin\n   ...\n}\n\n{\n   LDAP_7\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   fun:PL_HashTableRawAdd\n   fun:SECOID_Init\n   ...\n   fun:PR_LoadLibraryWithFlags\n   obj:/usr/lib64/libnssutil3.so\n   fun:PORT_LoadLibraryFromOrigin\n   ...\n}\n\n{\n   LDAP_8\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   fun:_dl_close_worker\n   fun:_dl_close\n   fun:_dl_catch_error\n   fun:_dlerror_run\n   ...\n   obj:*\n   fun:_ZL35authsm_run_second_authenticate_userP16mysql_async_auth\n   fun:run_plugin_auth\n   ...\n}\n\n{\n   LDAP_9\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:calloc\n   fun:NSSRWLock_New_Util\n   fun:SECOID_Init\n   ...\n   fun:dl_open_worker\n   fun:_dl_catch_error\n   fun:_dl_open\n   ...\n   fun:PR_LoadLibraryWithFlags\n   obj:/usr/lib64/libnssutil3.so\n   ...\n}\n\n{\n   LDAP_10\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   fun:PR_NewCondVar\n   ...\n   fun:SECMOD_LoadModule\n   obj:/usr/lib64/libnss3.so\n   ...\n   obj:/usr/lib64/libldap-2.4.so.2.10.7\n   fun:ldap_int_tls_start\n   fun:ldap_start_tls_s\n   fun:_ZN23Ldap_connection_creator13establish_tlsER9Ldap_info\n}\n\n{\n   LDAP_11\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:calloc\n   fun:PORT_ZAlloc_Util\n   obj:/usr/lib64/libfreeblpriv3.so\n   ...\n   fun:_dlerror_run\n   fun:dlopen@@GLIBC_2.2.5\n   fun:PR_LoadLibraryWithFlags\n   ...\n}\n\n{\n   LDAP_12\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:calloc\n   fun:PR_NewLock\n   fun:NSSRWLock_New_Util\n   ...\n   fun:ldap_int_tls_start\n   fun:ldap_start_tls_s\n   ...\n}\n\n{\n   LDAP_13\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   fun:PORT_Alloc_Util\n   fun:SECITEM_CopyItem_Util\n   obj:/usr/lib64/libfreeblpriv3.so\n   ...\n   fun:dlopen_doit\n   fun:_dl_catch_error\n   fun:_dlerror_run\n   ...\n}\n\n{\n   LDAP_14\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:calloc\n   obj:/usr/lib64/libfreeblpriv3.so\n   ...\n   fun:_dl_catch_error\n   fun:_dlerror_run\n   fun:dlopen@@GLIBC_2.2.5\n   fun:PR_LoadLibraryWithFlags\n   ...\n}\n\n{\n   LDAP_15\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:malloc\n   fun:PL_ArenaAllocate\n   fun:PORT_ArenaAlloc_Util\n   ...\n   fun:ldap_int_tls_start\n   fun:ldap_start_tls_s\n   ...\n}\n\n{\n   LDAP_16\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:calloc\n   fun:PORT_ZAlloc_Util\n   ...\n   fun:SECOID_Init\n   obj:/usr/lib64/libsoftokn3.so\n   fun:_dl_init\n   fun:dl_open_worker\n   ...\n   fun:PR_LoadLibraryWithFlags\n   obj:/usr/lib64/libnssutil3.so\n   ...\n}\n\n{\n   LDAP_17\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:calloc\n   fun:PR_NewLock\n   ...\n   fun:SECMOD_LoadModule\n   obj:/usr/lib64/libnss3.so\n   ...\n   fun:ldap_int_tls_start\n   fun:ldap_start_tls_s\n   ...\n}\n\n{\n   LDAP_18\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   fun:PR_NewCondVar\n   fun:NSSRWLock_New_Util\n   ...\n   fun:dl_open_worker\n   fun:_dl_catch_error\n   fun:_dl_open\n   ...\n   fun:PR_LoadLibraryWithFlags\n   obj:/usr/lib64/libnssutil3.so\n   fun:PORT_LoadLibraryFromOrigin\n}\n\n{\n   LDAP_19\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   fun:PR_NewCondVar\n   ...\n   fun:PR_CallOnce\n   ...\n   fun:dlopen_doit\n   fun:_dl_catch_error\n   fun:_dlerror_run\n   fun:dlopen@@GLIBC_2.2.5\n   fun:PR_LoadLibraryWithFlags\n}\n\n{\n   LDAP_20\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:calloc\n   fun:PORT_ZAlloc_Util\n   ...\n   fun:SECMOD_CreateModuleEx\n   fun:SECMOD_LoadModule\n   ...\n   fun:ldap_int_tls_start\n   fun:ldap_start_tls_s\n   ...\n}\n\n{\n   LDAP_21\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:calloc\n   fun:PR_NewLock\n   ...\n   fun:SECOID_Init\n   ...\n   fun:PR_LoadLibraryWithFlags\n   obj:/usr/lib64/libnssutil3.so\n   fun:PORT_LoadLibraryFromOrigin\n   ...\n}\n\n{\n   LDAP_22\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:calloc\n   fun:PR_NewLock\n   obj:/usr/lib64/libfreeblpriv3.so\n   fun:PR_CallOnce\n   ...\n   fun:_dlerror_run\n   fun:dlopen@@GLIBC_2.2.5\n   fun:PR_LoadLibraryWithFlags\n   ...\n}\n\n{\n   LDAP_23\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:calloc\n   fun:PR_NewLock\n   obj:/usr/lib64/libnssdbm3.so\n   ...\n   fun:legacy_Open\n   ...\n   fun:SECMOD_LoadModule\n   fun:SECMOD_LoadModule\n   ...\n}\n\n{\n   LDAP_24\n   Memcheck:Leak\n   match-leak-kinds: possible\n   fun:malloc\n   fun:PL_ArenaAllocate\n   fun:PORT_ArenaAlloc_Util\n   ...\n   fun:tlsmc_convert\n   fun:tlsmc_intercept_initialization\n   obj:/usr/lib64/libldap-2.4.so.2.10.7\n   ...\n}\n\n{\n   LDAP_25\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:malloc\n   fun:_dl_close_worker\n   fun:_dl_close\n   fun:_dl_catch_error\n   fun:_dlerror_run\n   fun:dlclose\n   fun:mysql_client_plugin_deinit\n   fun:_ZL8clean_upb\n   fun:_Z11mysqld_mainiPPc\n   fun:main\n}\n\n{\n   LDAP_26\n   Memcheck:Leak\n   match-leak-kinds: reachable\n   fun:calloc\n   fun:PORT_ZAlloc_Util\n   fun:PORT_NewArena_Util\n   fun:SECOID_Init\n   ...\n   fun:dlopen_doit\n   fun:_dl_catch_error\n   fun:_dlerror_run\n   ...\n   obj:/usr/lib64/libnssutil3.so\n   fun:PORT_LoadLibraryFromOrigin\n   ...\n}\n\n# Suppress all issues related to libcrypto library\n{\n   Conditional jump or move in BN_bin2bn\n   Memcheck:Cond\n   fun:BN_bin2bn\n   ...\n}\n{\n   Conditional jump or move in BN_ucmp\n   Memcheck:Cond\n   fun:BN_ucmp\n   ...\n}\n{\n   Conditional jump or move in libcrypto\n   Memcheck:Cond\n   obj:/usr/lib64/libcrypto.so.*\n   fun:*\n   ...\n}\n{\n   Conditional jump or move in BN_mod_exp_mont\n   Memcheck:Cond\n   fun:BN_mod_exp_mont\n   ...\n}\n{\n   Use of uninitialised value of size 8 in libcrypto\n   Memcheck:Value8\n   obj:/usr/lib64/libcrypto.so.*\n   ...\n}\n{\n   Conditional jump or move in BN_mod_mul_montgomery\n   Memcheck:Cond\n   fun:BN_mod_mul_montgomery\n   fun:BN_mod_exp_mont\n   ...\n}\n{\n   Conditional jump or move in bn_bn2binpad\n   Memcheck:Cond\n   fun:bn_bn2binpad\n   ...\n}\n{\n   Conditional jump or move in BN_from_montgomery\n   Memcheck:Cond\n   fun:BN_from_montgomery\n   ...\n}\n{\n   Use of uninitialised value of size 8 in libcrypto\n   Memcheck:Value8\n   obj:/usr/lib64/libcrypto.so.*\n   fun:BN_from_montgomery\n   fun:BN_mod_exp_mont\n   obj:*\n   ...\n}\n{\n   Use of uninitialised value of size 8 in BN_from_montgomery/BN_mod_exp_mont\n   Memcheck:Value8\n   fun:BN_from_montgomery\n   fun:BN_mod_exp_mont\n   obj:*\n   ...\n}\n{\n   Conditional jump or move in BN_num_bits_word\n   Memcheck:Cond\n   fun:BN_num_bits_word\n   fun:BN_num_bits\n   ...\n}\n{\n   Use of uninitialised value of size 8 in BN_num_bits_word\n   Memcheck:Value8\n   fun:BN_num_bits_word\n   fun:BN_num_bits\n   fun:BN_bn2bin\n   ...\n}\n{\n   Syscall param socketcall.sendto(msg) points to uninitialised byte(s)\n   Memcheck:Param\n   socketcall.sendto(msg)\n   ...\n   fun:send\n   fun:*\n   ...\n}\n{\n   Conditional jump or move in RSA_eay_public_encrypt\n   Memcheck:Cond\n   fun:RSA_eay_public_encrypt\n   fun:*\n   ...\n}\n\n# Sporadic error in GR tests\n\n{\n   Syscall param socketcall.sendto(msg) points to uninitialised byte(s)\n   Memcheck:Param\n   socketcall.sendto(msg)\n   obj:*\n   fun:__netlink_request\n   fun:getifaddrs_internal\n   fun:getifaddrs\n}\n\n# We might end up writing uninitialised NULL flags out to chunk files during\n# hash join. These flags are never used, so suppress the warnings.\n\n{\n   Syscall param write(buf) points to uninitialised byte(s)\n   Memcheck:Param\n   write(buf)\n   ...\n   fun:_Z19my_b_flush_io_cacheP8IO_CACHEi\n   fun:_ZN13HashJoinChunk6RewindEv\n}\n\n{\n   Syscall param write(buf) points to uninitialised byte(s)\n   Memcheck:Param\n   write(buf)\n   ...\n   fun:_Z19my_b_flush_io_cacheP8IO_CACHEi\n   ...\n   fun:_ZN16HashJoinIterator4InitEv\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/t/sp-error.test": "#\n# Stored PROCEDURE error tests\n#\n\n# ER_STACK_OVERRUN_NEED_MORE does not currenly work well with TSan\n--source include/not_tsan.inc\n\ndelimiter |;\n\n# This should give three syntax errors (sometimes crashed; bug #643)\n# (Unfortunately, this is not a 100% test, on some platforms this\n#  passed despite the bug.)\n--error 1064\ncreate procedure syntaxerror(t int)|\n--error 1064\ncreate procedure syntaxerror(t int)|\n--error 1064\ncreate procedure syntaxerror(t int)|\n\n# Check that we get the right error, i.e. UDF declaration parses correctly,\n# but foo.so doesn't exist.\n#    This generates an error message containing a misleading errno which\n#    might vary between systems (it usually doesn't have anything to do with\n#    the actual failing dlopen()).\n#--error 1126\n#create function foo returns real soname \"foo.so\"|\n\n\ncreate table t3 ( x int )|\ninsert into t3 values (2), (3)|\n\ncreate procedure bad_into(out param int)\n  select x from t3 into param|\n\n--error 1172\ncall bad_into(@x)|\n\ndrop procedure bad_into|\ndrop table t3|\n\n\ncreate procedure proc1()\n  set @x = 42|\n\ncreate function func1() returns int\n  return 42|\n\n# Can't create recursively\n--error 1303\ncreate procedure foo()\n  create procedure bar() set @x=3|\n--error 1303\ncreate procedure foo()\n  create function bar() returns double return 2.3|\n\n# Already exists\n--error 1304\ncreate procedure proc1()\n  set @x = 42|\n--error 1304\ncreate function func1() returns int\n  return 42|\n\ndrop procedure proc1|\ndrop function func1|\n\n# Does not exist\n--error 1305\nalter procedure foo|\n--error 1305\nalter function foo|\n--error 1305\ndrop procedure foo|\n--error 1305\ndrop function foo|\n--error 1305\ncall foo()|\ndrop procedure if exists foo|\n--error 1305\nshow create procedure foo|\n--error 1305\nshow create function foo|\n\n# LEAVE/ITERATE with no match\n--error 1308\ncreate procedure foo()\nfoo: loop\n  leave bar;\nend loop|\n--error 1308\ncreate procedure foo()\nfoo: loop\n  iterate bar;\nend loop|\n--error 1308\ncreate procedure foo()\nfoo: begin\n  iterate foo;\nend|\n\n# Redefining label\n--error 1309\ncreate procedure foo()\nfoo: loop\n  foo: loop\n    set @x=2;\n  end loop foo;\nend loop foo|\n\n# End label mismatch\n--error 1310\ncreate procedure foo()\nfoo: loop\n  set @x=2;\nend loop bar|\n\n# RETURN in FUNCTION only\n--error 1313\ncreate procedure foo()\n  return 42|\n\n# Wrong number of arguments\ncreate procedure p(x int)\n  set @x = x|\ncreate function f(x int) returns int\n  return x+42|\n\n--error 1318\ncall p()|\n--error 1318\ncall p(1, 2)|\n--error 1318\nselect f()|\n--error 1318\nselect f(1, 2)|\n\ndrop procedure p|\ndrop function f|\n\n--error 1319 \ncreate procedure p(val int, out res int)\nbegin\n  declare x int default 0;\n  declare continue handler for foo set x = 1;\n\n  insert into test.t1 values (val);\n  if (x) then\n    set res = 0;\n  else\n    set res = 1;\n  end if;\nend|\n\n--error 1319 \ncreate procedure p(val int, out res int)\nbegin\n  declare x int default 0;\n  declare foo condition for 1146;\n  declare continue handler for bar set x = 1;\n\n  insert into test.t1 values (val);\n  if (x) then\n    set res = 0;\n  else\n    set res = 1;\n  end if;\nend|\n\n--error 1320\ncreate function f(val int) returns int\nbegin\n  declare x int;\n\n  set x = val+3;\nend|\n\ncreate function f(val int) returns int\nbegin\n  declare x int;\n\n  set x = val+3;\n  if x < 4 then\n    return x;\n  end if;\nend|\n\n--error 1321\nselect f(10)|\n\ndrop function f|\n\n--error ER_PARSE_ERROR\ncreate procedure p()\nbegin\n  declare c cursor for insert into test.t1 values (\"foo\", 42);\n\n  open c;\n  close c;\nend|\n\n--error 1323\ncreate procedure p()\nbegin\n  declare x int;\n  declare c cursor for select * into x from test.t limit 1;\n\n  open c;\n  close c;\nend|\n\n--error 1324\ncreate procedure p()\nbegin\n  declare c cursor for select * from test.t;\n\n  open cc;\n  close c;\nend|\n\ncreate table t1 (val int)|\n\ncreate procedure p()\nbegin\n  declare c cursor for select * from test.t1;\n\n  open c;\n  open c;\n  close c;\nend|\n--error 1325\ncall p()|\ndrop procedure p|\n\ncreate procedure p()\nbegin\n  declare c cursor for select * from test.t1;\n\n  open c;\n  close c;\n  close c;\nend|\n--error 1326\ncall p()|\ndrop procedure p|\n\n--error 1305\nalter procedure bar3 sql security invoker|\n\ndrop table t1|\n\ncreate table t1 (val int, x float)|\ninsert into t1 values (42, 3.1), (19, 1.2)|\n\n--error 1327\ncreate procedure p()\nbegin\n  declare x int;\n  declare c cursor for select * from t1;\n\n  open c;\n  fetch c into x, y;\n  close c;\nend|\n\ncreate procedure p()\nbegin\n  declare x int;\n  declare c cursor for select * from t1;\n\n  open c;\n  fetch c into x;\n  close c;\nend|\n--error 1328\ncall p()|\ndrop procedure p|\n\ncreate procedure p()\nbegin\n  declare x int;\n  declare y float;\n  declare z int;\n  declare c cursor for select * from t1;\n\n  open c;\n  fetch c into x, y, z;\n  close c;\nend|\n--error 1328\ncall p()|\ndrop procedure p|\n\n--error 1330\ncreate procedure p(in x int, x char(10))\nbegin\nend|\n--error 1330\ncreate function p(x int, x char(10))\nbegin\nend|\n\n--error 1331\ncreate procedure p()\nbegin\n  declare x float;\n  declare x int;\nend|\n\n--error 1332\ncreate procedure p()\nbegin\n  declare c condition for 1064;\n  declare c condition for 1065;\nend|\n\n--error 1333\ncreate procedure p()\nbegin\n  declare c cursor for select * from t1;\n  declare c cursor for select field from t1;\nend|\n\n# USE is not allowed\n--error ER_SP_BADSTATEMENT \ncreate procedure u()\n  use sptmp|\n\n# Enforced standard order of declarations\n--error 1337\ncreate procedure p()\nbegin\n  declare c cursor for select * from t1;\n  declare x int;\nend|\n--error 1337\ncreate procedure p()\nbegin\n  declare x int;\n  declare continue handler for sqlstate '42S99' set x = 1;\n  declare foo condition for sqlstate '42S99';\nend|\n\n--error 1338\ncreate procedure p()\nbegin\n  declare x int;\n  declare continue handler for sqlstate '42S99' set x = 1;\n  declare c cursor for select * from t1;\nend|\n\n# Check in and inout arguments.\ncreate procedure p(in x int, inout y int, out z int)\nbegin\n  set y = x+y;\n  set z = x+y;\nend|\n\nset @tmp_x = 42|\nset @tmp_y = 3|\nset @tmp_z = 0|\n# For reference: this is ok\ncall p(@tmp_x, @tmp_y, @tmp_z)|\nselect @tmp_x, @tmp_y, @tmp_z|\n\n--error ER_SP_NOT_VAR_ARG\ncall p(42, 43, @tmp_z)|\n--error ER_SP_NOT_VAR_ARG\ncall p(42, @tmp_y, 43)|\n\ndrop procedure p|\n\n\n#\n# Let us test that we can access routines definitions in LOCK TABLE mode.\n#\ncreate procedure p() begin end|\nlock table t1 read|\n# This should succeed\ncall p()|\nunlock tables|\ndrop procedure p|\n\n\n#\n# Check that in functions we don't allow to update tables which\n# are used by statements which invoke these functions.\n#\ncreate function f1(i int) returns int\nbegin\n  insert into t1 (val) values (i);\n  return 0;\nend|\n--error ER_CANT_UPDATE_USED_TABLE_IN_SF_OR_TRG\nselect val, f1(val) from t1|\n# Table alias should not matter\n--error ER_CANT_UPDATE_USED_TABLE_IN_SF_OR_TRG\nselect val, f1(val) from t1 as tab|\nselect * from t1|\n--error ER_CANT_UPDATE_USED_TABLE_IN_SF_OR_TRG\nupdate t1 set val= f1(val)|\nselect * from t1|\n# But this should be OK\nselect f1(17)|\nselect * from t1|\n# Cleanup\ndelete from t1 where val= 17|\ndrop function f1|\n\n\n#\n# BUG#1965\n#\ncreate procedure bug1965()\nbegin\n  declare c cursor for select val from t1 order by valname;\n  open c;\n  close c;\nend|\n\n--error 1054\ncall bug1965()|\ndrop procedure bug1965|\n\n#\n# BUG#1966\n#\n--error 1327\nselect 1 into a|\n\n#\n# BUG#1653\n#\ncreate table t3 (column_1_0 int)|\n\ncreate procedure bug1653()\n  update t3 set column_1 = 0|\n\n--error 1054\ncall bug1653()|\ndrop table t3|\ncreate table t3 (column_1 int)|\ncall bug1653()|\n\ndrop procedure bug1653|\ndrop table t3|\n\n#\n# BUG#2259\n#\n# Note: When this bug existed, it did not necessarily cause a crash\n#       in all builds, but valgrind did give warnings.\ncreate procedure bug2259()\nbegin\n  declare v1 int;\n  declare c1 cursor for select s1 from t1;\n\n  fetch c1 into v1;\nend|\n\n--error 1326\ncall bug2259()|\ndrop procedure bug2259|\n\n#\n# BUG#2272\n#\ncreate procedure bug2272()\nbegin\n  declare v int;\n\n  update t1 set v = 42;\nend|\n\ninsert into t1 values (666, 51.3)|\n--error 1054\ncall bug2272()|\ntruncate table t1|\ndrop procedure bug2272|\n\n#\n# BUG#2329\n#\ncreate procedure bug2329_1()\nbegin\n  declare v int;\n\n  insert into t1 (v) values (5);\nend|\n\ncreate procedure bug2329_2()\nbegin\n  declare v int;\n\n  replace t1 set v = 5;\nend|\n\n--error 1054\ncall bug2329_1()|\n--error 1054\ncall bug2329_2()|\ndrop procedure bug2329_1|\ndrop procedure bug2329_2|\n\n#\n# BUG#3287\n#\ncreate function bug3287() returns int\nbegin\n  declare v int default null;\n\n  case\n    when v is not null then return 1;\n  end case;\n  return 2;\nend|\n--error 1339\nselect bug3287()|\ndrop function bug3287|\n\ncreate procedure bug3287(x int)\ncase x\nwhen 0 then\n  insert into test.t1 values (x, 0.1);\nwhen 1 then\n  insert into test.t1 values (x, 1.1);\nend case|\n--error 1339\ncall bug3287(2)|\ndrop procedure bug3287|\n\n#\n# BUG#3297\n#\ncreate table t3 (s1 int, primary key (s1))|\ninsert into t3 values (5),(6)|\n\ncreate procedure bug3279(out y int) \nbegin\n  declare x int default 0;\n  begin\n    declare exit handler for sqlexception set x = x+1;\n    insert into t3 values (5);\n  end;\n  if x < 2 then\n    set x = x+1;\n    insert into t3 values (6);\n  end if;\n  set y = x;\nend|\n\nset @x = 0|\n--error ER_DUP_ENTRY\ncall bug3279(@x)|\nselect @x|\ndrop procedure bug3279|\ndrop table t3|\n\n#\n# BUG#3339\n#\n--error 1049\ncreate procedure nodb.bug3339() begin end|\n\n#\n# BUG#2653\n#\ncreate procedure bug2653_1(a int, out b int)\n  set b = aa|\n\ncreate procedure bug2653_2(a int, out b int)\nbegin\n  if aa < 0 then\n    set b = - a;\n  else\n    set b = a;\n  end if;\nend|\n\n--error 1054\ncall bug2653_1(1, @b)|\n--error 1054\ncall bug2653_2(2, @b)|\n\ndrop procedure bug2653_1|\ndrop procedure bug2653_2|\n\n#\n# BUG#4344\n#\n--error 1357\ncreate procedure bug4344() drop procedure bug4344|\n--error 1357\ncreate procedure bug4344() drop function bug4344|\n\n#\n# BUG#3294: Stored procedure crash if table dropped before use\n# (Actually, when an error occurs within an error handler.)\ncreate procedure bug3294()\nbegin\n  declare continue handler for sqlexception drop table t5;\n  drop table t5;\n  drop table t5;\nend|\n\ncreate table t5 (x int)|\n--error 1051\ncall bug3294()|\ndrop procedure bug3294|\n\n#\n# BUG#876: Stored Procedures: Invalid SQLSTATE is allowed in \n#          a DECLARE ? HANDLER FOR stmt.\n#\n--disable_warnings\ndrop procedure if exists bug8776_1|\ndrop procedure if exists bug8776_2|\ndrop procedure if exists bug8776_3|\ndrop procedure if exists bug8776_4|\n--enable_warnings\n--error ER_SP_BAD_SQLSTATE\ncreate procedure bug8776_1()\nbegin\n  declare continue handler for sqlstate '42S0200test' begin end;\n  begin end;\nend|\n\n--error ER_SP_BAD_SQLSTATE\ncreate procedure bug8776_2()\nbegin\n  declare continue handler for sqlstate '4200' begin end;\n  begin end;\nend|\n\n--error ER_SP_BAD_SQLSTATE\ncreate procedure bug8776_3()\nbegin\n  declare continue handler for sqlstate '420000' begin end;\n  begin end;\nend|\n\n--error ER_SP_BAD_SQLSTATE\ncreate procedure bug8776_4()\nbegin\n  declare continue handler for sqlstate '42x00' begin end;\n  begin end;\nend|\n\n\n#\n# BUG#6600: Stored procedure crash after repeated calls with check table\n#\n--error ER_SP_BADSTATEMENT\ncreate procedure bug6600()\n  check table t1|\n\n# Check these two as well, while we're at it. (Although it isn't really\n# related to the bug report, but to the fix.)\n--error ER_SP_BADSTATEMENT\ncreate procedure bug6600()\n  lock table t1 read|\n--error ER_SP_BADSTATEMENT\ncreate procedure bug6600()\n  unlock table t1|\n\n\n#\n# BUG#7299: Stored procedures: exception handler catches not-found conditions\n#\ncreate procedure bug7299()\nbegin\n  declare v int;\n  declare c cursor for select val from t1;\n  declare exit handler for sqlexception select 'Error!'; \n\n  open c;\n  fetch c into v;\nend|\n\ntruncate table t1|\n--error ER_SP_FETCH_NO_DATA\ncall bug7299()|\ndrop procedure bug7299|\n\n\n#\n# BUG#9073: Able to declare two handlers for same condition in same scope\n#\n--error ER_SP_DUP_HANDLER\ncreate procedure bug9073()\nbegin\n  declare continue handler for sqlexception select 1;\n  declare continue handler for sqlexception select 2;\nend|\n--error ER_SP_DUP_HANDLER\ncreate procedure bug9073()\nbegin\n  declare condname1 condition for 1234;\n  declare continue handler for condname1 select 1;\n  declare exit handler for condname1 select 2;\nend|\n--error ER_SP_DUP_HANDLER\ncreate procedure bug9073()\nbegin\n  declare condname1 condition for sqlstate '42000';\n  declare condname2 condition for sqlstate '42000';\n  declare exit handler for condname1 select 1;\n  declare continue handler for condname2 select 2;\nend|\n--error ER_SP_DUP_HANDLER\ncreate procedure bug9073()\nbegin\n  declare condname1 condition for sqlstate '42000';\n  declare exit handler for condname1 select 1;\n  declare exit handler for sqlstate '42000' select 2;\nend|\n\n# This should still work.\ncreate procedure bug9073()\nbegin\n  declare condname1 condition for sqlstate '42000';\n  declare continue handler for condname1 select 1;\n  begin\n    declare exit handler for sqlstate '42000' select 2;\n    begin\n      declare continue handler for sqlstate '42000' select 3;\n    end;\n  end;\nend|\ndrop procedure bug9073|\n\n\n#\n# BUG#7047: Stored procedure crash if alter procedure\n#\n--error ER_SP_NO_DROP_SP\ncreate procedure bug7047()\n  alter procedure bug7047|\n--error ER_SP_NO_DROP_SP\ncreate function bug7047() returns int\nbegin\n  alter function bug7047;\n  return 0;\nend|\n\n\n#\n# BUG#8408: Stored procedure crash if function contains SHOW\n# BUG#9058: Stored Procedures: Crash if function included SELECT\n#\n\n# Some things are caught when parsing\n--error ER_SP_NO_RETSET\ncreate function bug8408() returns int\nbegin\n  select * from t1;\n  return 0;\nend|\n--error ER_SP_NO_RETSET\ncreate function bug8408() returns int\nbegin\n  show warnings;\n  return 0;\nend|\n--error ER_SP_NO_RETSET\ncreate function bug8408(a int) returns int\nbegin\n  declare b int;\n  select b;\n  return b;\nend|\n\n--disable_warnings\ndrop function if exists bug8408_f|\ndrop procedure if exists bug8408_p|\n--enable_warnings\n\n# Some things must be caught at invokation time\ncreate function bug8408_f() returns int\nbegin\n  call bug8408_p();\n  return 0;\nend|\ncreate procedure bug8408_p()\n  select * from t1|\n\ncall bug8408_p()|\n--error ER_SP_NO_RETSET\nselect bug8408_f()|\n\ndrop procedure bug8408_p|\ndrop function bug8408_f|\n\n# But this is ok\ncreate function bug8408() returns int\nbegin\n  declare n int default 0;\n  select count(*) into n from t1;\n  return n;\nend|\n\ninsert into t1 value (2, 2.7), (3, 3.14), (7, 7.0)|\nselect *,bug8408() from t1|\n\ndrop function bug8408|\ntruncate table t1|\n\n\n#\n# BUG#10537: Server crashes while loading data file into table through\n#            procedure.\n# Disable load until it's PS and SP safe\n--error ER_SP_BADSTATEMENT\ncreate procedure bug10537()\n  load data local infile '/tmp/somefile' into table t1|\n\n\n#\n# BUG#8409: Stored procedure crash if function contains FLUSH\n#\n--error ER_STMT_NOT_ALLOWED_IN_SF_OR_TRG\ncreate function bug8409()\n  returns int\nbegin\n  flush tables;\n  return 5;\nend|\n--error ER_STMT_NOT_ALLOWED_IN_SF_OR_TRG\ncreate function bug8409() returns int begin reset master;\nreturn 1; end|\n--error ER_STMT_NOT_ALLOWED_IN_SF_OR_TRG\ncreate function bug8409() returns int begin reset slave;\nreturn 1; end|\n--error ER_STMT_NOT_ALLOWED_IN_SF_OR_TRG\ncreate function bug8409() returns int begin flush hosts;\nreturn 1; end|\n--error ER_STMT_NOT_ALLOWED_IN_SF_OR_TRG\ncreate function bug8409() returns int begin flush privileges;\nreturn 1; end|\n--error ER_STMT_NOT_ALLOWED_IN_SF_OR_TRG\ncreate function bug8409() returns int begin flush tables with read lock;\nreturn 1; end|\n--error ER_STMT_NOT_ALLOWED_IN_SF_OR_TRG\ncreate function bug8409() returns int begin flush tables;\nreturn 1; end|\n--error ER_STMT_NOT_ALLOWED_IN_SF_OR_TRG\ncreate function bug8409() returns int begin flush logs;\nreturn 1; end|\n--error ER_STMT_NOT_ALLOWED_IN_SF_OR_TRG\ncreate function bug8409() returns int begin flush status;\nreturn 1; end|\n--error ER_STMT_NOT_ALLOWED_IN_SF_OR_TRG\ncreate function bug8409() returns int begin flush user_resources;\nreturn 1; end|\n\n\n#\n# BUG#9529: Stored Procedures: No Warning on truncation of procedure name\n#           during creation.\n# BUG#17015: Routine name truncation not an error\n#            When we started using utf8 for mysql.proc, this limit appeared\n#            to be higher, but in reality the names were truncated.\n--error ER_TOO_LONG_IDENT\ncreate procedure bug9529_901234567890123456789012345678901234567890123456789012345()\nbegin\nend|\n\n# Check the upper limit, just to make sure.\ncreate procedure bug17015_0123456789012345678901234567890123456789012345678901234()\nbegin\nend|\n\n--replace_column 5 '0000-00-00 00:00:00' 6 '0000-00-00 00:00:00'\nshow procedure status like 'bug17015%'|\ndrop procedure bug17015_0123456789012345678901234567890123456789012345678901234|\n\n\n#\n# BUG#10969: Stored procedures: crash if default() function\n#\n--error ER_WRONG_COLUMN_NAME\ncreate procedure bug10969()\nbegin\n  declare s1 int default 0;\n  select default(s1) from t30;\nend|\n\n# This should work\ncreate procedure bug10969()\nbegin\n  declare s1 int default 0;\n  select default(t30.s1) from t30;\nend|\n\ndrop procedure bug10969|\n\n\ndrop table t1|\n\ndelimiter ;|\n\n# BUG#9814: Closing a cursor that is not open \ncreate table t1(f1 int);\ncreate table t2(f1 int);\n \ndelimiter |;\nCREATE PROCEDURE SP001()\nP1: BEGIN\n  DECLARE ENDTABLE INT DEFAULT 0;\n  DECLARE TEMP_NUM INT;\n  DECLARE TEMP_SUM INT;\n  DECLARE C1 CURSOR FOR SELECT F1 FROM t1;\n  DECLARE C2 CURSOR FOR SELECT F1 FROM t2;\n  DECLARE CONTINUE HANDLER FOR NOT FOUND SET ENDTABLE = 1;\n\n  SET ENDTABLE=0;\n  SET TEMP_SUM=0;\n  SET TEMP_NUM=0;\n  \n  OPEN C1;\n\n  FETCH C1 INTO TEMP_NUM;\n  WHILE ENDTABLE = 0 DO\n          SET TEMP_SUM=TEMP_NUM+TEMP_SUM;\n          FETCH C1 INTO TEMP_NUM;\n  END WHILE;\n  SELECT TEMP_SUM;\n  CLOSE C1;\n  CLOSE C1;\n  SELECT 'end of proc';\nEND P1|\ndelimiter ;|\n--error 1326\ncall SP001();\ndrop procedure SP001;\ndrop table t1, t2;\n\n# Bug #11394 \"Recursion in SP crash server\" and bug #11600 \"Stored\n# procedures: crash with function calling itself\".\n# We have to disable recursion since in many cases LEX and many\n# Item's can't be used in reentrant way nowdays.\ndelimiter |;\n--disable_warnings\ndrop function if exists bug11394|\ndrop function if exists bug11394_1|\ndrop function if exists bug11394_2|\ndrop procedure if exists bug11394|\n--enable_warnings\ncreate function bug11394(i int) returns int\nbegin\n  if i <= 0 then\n    return 0;\n  else\n    return (i in (100, 200, bug11394(i-1), 400));\n  end if;\nend|\n# If we allow recursive functions without additional modifications\n# this will crash server since Item for \"IN\" is not reenterable.\n--error 1424\nselect bug11394(2)|\ndrop function bug11394|\ncreate function bug11394_1(i int) returns int\nbegin\n  if i <= 0 then\n    return 0;\n  else\n    return (select bug11394_1(i-1));\n  end if;\nend|\n# The following statement will crash because some LEX members responsible\n# for selects cannot be used in reentrant fashion.\n--error 1424\nselect bug11394_1(2)|\ndrop function bug11394_1|\n# Note that the following should be allowed since it does not contains\n# recursion\ncreate function bug11394_2(i int) returns int return i|\nselect bug11394_2(bug11394_2(10))|\ndrop function bug11394_2|\ncreate procedure bug11394(i int, j int)\nbegin\n  if i > 0 then\n    call bug11394(i - 1,(select 1));\n  end if;\nend|\n--error ER_SP_RECURSION_LIMIT\ncall bug11394(2, 1)|\nset @@max_sp_recursion_depth=10|\ncall bug11394(2, 1)|\nset @@max_sp_recursion_depth=default|\ndrop procedure bug11394|\ndelimiter ;|\n\n\n#\n# BUG 12490 (Packets out of order if calling HELP CONTENTS from Stored Procedure)\n#\n--error ER_SP_BADSTATEMENT\nCREATE PROCEDURE BUG_12490() HELP CONTENTS;\n--error ER_SP_BADSTATEMENT\nCREATE FUNCTION BUG_12490() RETURNS INT HELP CONTENTS;\nCREATE TABLE t_bug_12490(a int);\n--error ER_SP_BADSTATEMENT\nCREATE TRIGGER BUG_12490 BEFORE UPDATE ON t_bug_12490 FOR EACH ROW HELP CONTENTS;\nDROP TABLE t_bug_12490;\n\n#\n# Bug#11834 \"Re-execution of prepared statement with dropped function\n# crashes server\". Also tests handling of prepared stmts which use\n# stored functions but does not require prelocking.\n#\n--disable_warnings\ndrop function if exists bug11834_1;\ndrop function if exists bug11834_2;\n--enable_warnings\ncreate function bug11834_1() returns int return 10;\ncreate function bug11834_2() returns int return bug11834_1();\nprepare stmt from \"select bug11834_2()\";\nexecute stmt;\n# Re-execution of statement should not crash server.\nexecute stmt;\ndrop function bug11834_1;\n# Attempt to execute statement should return proper error and \n# should not crash server.\n\n# NOTE! The error we get from the below query indicates that the sp bug11834_2\n# does not exist(this is wrong but can be accepted)\n# This behaviour has been reported as bug#21294\n--error ER_SP_DOES_NOT_EXIST\nexecute stmt;\ndeallocate prepare stmt;\ndrop function bug11834_2;\n\n#\n# Bug#12953 \"Stored procedures: crash if OPTIMIZE TABLE in function\"\n#\ndelimiter |;\n--error ER_SP_NO_RETSET\nCREATE FUNCTION bug12953() RETURNS INT\nBEGIN\n  OPTIMIZE TABLE t1;\n  RETURN 1;\nEND|\ndelimiter ;|\n\n#\n# Bug##12995 \"Inside function \"Table 't4' was not locked with LOCK TABLES\"\n#\ndelimiter |;\n--error ER_SP_BADSTATEMENT\nCREATE FUNCTION bug12995() RETURNS INT\nBEGIN\n  HANDLER t1 OPEN;\n  RETURN 1;\nEND|\n--error ER_SP_BADSTATEMENT\nCREATE FUNCTION bug12995() RETURNS INT\nBEGIN\n  HANDLER t1 READ FIRST;\n  RETURN 1;\nEND|\n--error ER_SP_BADSTATEMENT\nCREATE FUNCTION bug12995() RETURNS INT\nBEGIN\n  HANDLER t1 CLOSE;\n  RETURN 1;\nEND|\n--error 1305\nSELECT bug12995()|\ndelimiter ;|\n\n\n#\n# BUG#12712: SET AUTOCOMMIT should fail within SP/functions/triggers\n#\n--disable_warnings\ndrop procedure if exists bug12712;\ndrop function if exists bug12712;\n--enable_warnings\n# Can...\ncreate procedure bug12712()\n  set session autocommit = 0;\n\nselect @@autocommit;\nset @au = @@autocommit;\ncall bug12712();\nselect @@autocommit;\nset session autocommit = @au;\n\ndelimiter |;\ncreate function bug12712()\n  returns int\nbegin\n  call bug12712();\n  return 0;\nend|\n\n# Can't...\n--error ER_SP_CANT_SET_AUTOCOMMIT\nset @x = bug12712()|\ndrop procedure bug12712|\ndrop function bug12712|\n--error ER_SP_CANT_SET_AUTOCOMMIT\ncreate function bug12712()\n    returns int\nbegin\n  set session autocommit = 0;\n  return 0;\nend|\n--error ER_SP_CANT_SET_AUTOCOMMIT\ncreate function bug12712()\n    returns int\nbegin\n  set @@autocommit = 0;\n  return 0;\nend|\n--error ER_SP_CANT_SET_AUTOCOMMIT\ncreate function bug12712()\n    returns int\nbegin\n  set local autocommit = 0;\n  return 0;\nend|\ndelimiter ;|\n--error ER_SP_CANT_SET_AUTOCOMMIT\ncreate trigger bug12712\n  before insert on t1 for each row set session autocommit = 0;\n\n#\n# BUG#9367: Stored procedures: client hang after \"show warnings\"\n#\n--disable_testcase BUG#0000\ncreate table t1 (s1 int);\nselect s1 from t1;\ndelimiter |;\ncreate procedure bug9367()\nbegin\n  declare v int;\n  declare c cursor for select s1 from t1;\n  open c;\n  show warnings;\n  fetch c into v;\n  select v;\nend|\ndelimiter ;|\ncall bug9367();\ndrop procedure bug9367;\ndrop table t1;\n--enable_testcase\n\n#\n# BUG#13510: Setting password local variable changes current password\n#\ndelimiter |;\n--disable_warnings\ndrop procedure if exists bug13510_1|\ndrop procedure if exists bug13510_2|\ndrop procedure if exists bug13510_3|\ndrop procedure if exists bug13510_4|\n--enable_warnings\n\n--error ER_SP_BAD_VAR_SHADOW\ncreate procedure bug13510_1()\nbegin\n  declare password varchar(10);\n\n  set password = 'foo1';\n  select password;\nend|\n\n# Check that an error message is sent\n--error ER_PARSE_ERROR\nset names='foo2'|\n\n--error ER_SP_BAD_VAR_SHADOW\ncreate procedure bug13510_2()\nbegin\n  declare names varchar(10);\n\n  set names = 'foo2';\n  select names;\nend|\n\ncreate procedure bug13510_3()\nbegin\n  declare password varchar(10);\n\n  set `password` = 'foo3';\n  select password;\nend|\n\ncreate procedure bug13510_4()\nbegin\n  declare names varchar(10);\n\n  set `names` = 'foo4';\n  select names;\nend|\n\ncall bug13510_3()|\ncall bug13510_4()|\n\ndrop procedure bug13510_3|\ndrop procedure bug13510_4|\n\n\n#\n# Test that statements which implicitly commit transaction are prohibited\n# in stored function and triggers. Attempt to create function or trigger\n# containing such statement should produce error (includes test for\n# bug #13627).\n#\n\nCREATE TABLE t1 (a int)|\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN DROP TRIGGER test1; END |\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE FUNCTION bug_13627_f() returns int BEGIN DROP TRIGGER test1; return 1; END |\n\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN create table t2 (a int); END |\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE FUNCTION bug_13627_f() returns int BEGIN create table t2 (a int); return 1; END |\n\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN create index t1_i on t1 (a); END |\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE FUNCTION bug_13627_f() returns int BEGIN create index t1_i on t1 (a); return 1; END |\n\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN alter table t1 add column  b int; END |\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE FUNCTION bug_13627_f() returns int BEGIN alter table t1 add column  b int; return 1; END |\n\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN rename table t1 to t2; END |\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE FUNCTION bug_13627_f() returns int BEGIN rename table t1 to t2; return 1; END |\n\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN truncate table t1; END |\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE FUNCTION bug_13627_f() returns int BEGIN truncate table t1; return 1; END |\n\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN drop table t1; END |\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE FUNCTION bug_13627_f() returns int BEGIN drop table t1; return 1; END |\n\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN drop index t1_i on t1; END |\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE FUNCTION bug_13627_f() returns int BEGIN drop index t1_i on t1; return 1; END |\n\n-- error ER_SP_BADSTATEMENT\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN unlock tables; END |\n-- error ER_SP_BADSTATEMENT\nCREATE FUNCTION bug_13627_f() returns int BEGIN unlock tables; return 1; END |\n\n-- error ER_SP_BADSTATEMENT\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN LOCK TABLE t1 READ; END |\n-- error ER_SP_BADSTATEMENT\nCREATE FUNCTION bug_13627_f() returns int BEGIN LOCK TABLE t1 READ; return 1; END |\n\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN create database mysqltest; END |\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE FUNCTION bug_13627_f() returns int BEGIN create database mysqltest; return 1; END |\n\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN drop database mysqltest; END |\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE FUNCTION bug_13627_f() returns int BEGIN drop database mysqltest; return 1; END |\n\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN create user 'mysqltest_1'; END |\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE FUNCTION bug_13627_f() returns int BEGIN create user 'mysqltest_1'; return 1; END |\n\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE TRIGGER bug21975 BEFORE INSERT ON t1 FOR EACH ROW BEGIN grant select on t1 to 'mysqltest_1'; END |\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE FUNCTION bug21975() returns int BEGIN grant select on t1 to 'mysqltest_1'; return 1; END |\n\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE TRIGGER bug21975 BEFORE INSERT ON t1 FOR EACH ROW BEGIN revoke select on t1 from 'mysqltest_1'; END |\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE FUNCTION bug21975() returns int BEGIN revoke select on t1 from 'mysqltest_1'; return 1; END |\n\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE TRIGGER bug21975 BEFORE INSERT ON t1 FOR EACH ROW BEGIN revoke all privileges on *.* from 'mysqltest_1'; END |\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE FUNCTION bug21975() returns int BEGIN revoke all privileges on *.* from 'mysqltest_1'; return 1; END |\n\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN drop user 'mysqltest_1'; END |\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE FUNCTION bug_13627_f() returns int BEGIN drop user 'mysqltest_1'; return 1; END |\n\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN rename user 'mysqltest_2' to 'mysqltest_1'; END |\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE FUNCTION bug_13627_f() returns int BEGIN rename user 'mysqltest_2' to 'mysqltest_1'; return 1; END |\n\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN create view v1 as select 1; END |\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE FUNCTION bug_13627_f() returns int BEGIN create view v1 as select 1; return 1; END |\n\n-- error ER_SP_BADSTATEMENT\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN alter view v1 as select 1; END |\n-- error ER_SP_BADSTATEMENT\nCREATE FUNCTION bug_13627_f() returns int BEGIN alter view v1 as select 1; return 1; END |\n\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN drop view v1; END |\n-- error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nCREATE FUNCTION bug_13627_f() returns int BEGIN drop view v1; return 1; END |\n\n-- error ER_SP_NO_RECURSIVE_CREATE\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN create trigger tr2 before insert on t1 for each row do select 1; END |\n-- error ER_SP_NO_RECURSIVE_CREATE\nCREATE FUNCTION bug_13627_f() returns int BEGIN create trigger tr2 before insert on t1 for each row do select 1; return 1; END |\n\n-- error ER_SP_NO_DROP_SP\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN drop function bug_13627_f; END |\n-- error ER_SP_NO_DROP_SP\nCREATE FUNCTION bug_13627_f() returns int BEGIN drop function bug_13627_f; return 1; END |\n\n-- error ER_SP_NO_RECURSIVE_CREATE\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW BEGIN create function f2 () returns int return 1; END |\n-- error ER_SP_NO_RECURSIVE_CREATE\nCREATE FUNCTION bug_13627_f() returns int BEGIN create function f2 () returns int return 1; return 1; END |\n\nCREATE TRIGGER tr1 BEFORE INSERT ON t1 FOR EACH ROW\n  BEGIN\n    CREATE TEMPORARY TABLE t2 (a int);\n    DROP TEMPORARY TABLE t2;\n  END |\nCREATE FUNCTION bug_13627_f() returns int\n  BEGIN\n    CREATE TEMPORARY TABLE t2 (a int);\n    DROP TEMPORARY TABLE t2;\n    return 1;\n  END |\n\ndrop table t1|\ndrop function bug_13627_f|\n\ndelimiter ;|\n\n# BUG#12329: \"Bogus error msg when executing PS with stored procedure after\n# SP was re-created\". See also test for related bug#13399 in trigger.test\ndrop function if exists bug12329;\ncreate table t1 as select 1 a;\ncreate table t2 as select 1 a;\ncreate function bug12329() returns int return (select a from t1);\nprepare stmt1 from 'select bug12329()';\nexecute stmt1;\ndrop function bug12329;\ncreate function bug12329() returns int return (select a+100 from t2);\nselect bug12329();\nexecute stmt1;\ndeallocate prepare stmt1;\ndrop function bug12329; \ndrop table t1, t2;\n\n#\n# Bug#13514 \"server crash when create a stored procedure before choose a\n# database\" and\n# Bug#13587 \"Server crash when SP is created without database\n# selected\"\n#\ncreate database mysqltest1;\nuse mysqltest1;\ndrop database mysqltest1;\n--error ER_NO_DB_ERROR \ncreate function f1() returns int return 1;\ndelimiter |;\n--error ER_NO_DB_ERROR \ncreate procedure p1(out param1 int)\nbegin\n  select count(*) into param1 from t3;\nend|\ndelimiter ;|\nuse test;\n\n\n#\n# BUG#13037: undefined variable in IF cause erroneous error-message\n#\n\n--disable_warnings\nDROP PROCEDURE IF EXISTS bug13037_p1;\nDROP PROCEDURE IF EXISTS bug13037_p2;\nDROP PROCEDURE IF EXISTS bug13037_p3;\n--enable_warnings\n\ndelimiter |;\n\nCREATE PROCEDURE bug13037_p1()\nBEGIN\n  IF bug13037_foo THEN\n    SELECT 1;\n  END IF;\nEND|\n\nCREATE PROCEDURE bug13037_p2()\nBEGIN\n  SET @bug13037_foo = bug13037_bar;\nEND|\n\nCREATE PROCEDURE bug13037_p3()\nBEGIN\n  SELECT bug13037_foo;\nEND|\n\ndelimiter ;|\n\n--echo\n\n--error 1054\nCALL bug13037_p1();\n--error 1054\nCALL bug13037_p2();\n--error 1054\nCALL bug13037_p3();\n\n--error 1054\nCALL bug13037_p1();\n--error 1054\nCALL bug13037_p2();\n--error 1054\nCALL bug13037_p3();\n\nDROP PROCEDURE bug13037_p1;\nDROP PROCEDURE bug13037_p2;\nDROP PROCEDURE bug13037_p3;\n\n#\n# Bug#14569 \"editing a stored procedure kills mysqld-nt\"\n#\ncreate database mysqltest1;\ncreate database mysqltest2;\nuse mysqltest1;\ndrop database mysqltest1;\ncreate procedure mysqltest2.p1() select version();\n--error ER_NO_DB_ERROR \ncreate procedure p2() select version();\nuse mysqltest2;\n--replace_column 5 '0000-00-00 00:00:00' 6 '0000-00-00 00:00:00'\nshow procedure status like 'p1';\ndrop database mysqltest2;\nuse test;\n\n#\n# Bug#13012 \"SP: REPAIR/BACKUP/RESTORE TABLE crashes the server\"\n#\ndelimiter |;\n--error ER_SP_NO_RETSET\nCREATE FUNCTION bug13012() RETURNS INT\nBEGIN\n  REPAIR TABLE t1;\n  RETURN 1;\nEND|\ncreate table t1 (a int)|\nCREATE PROCEDURE bug13012_1() REPAIR TABLE t1|\nCREATE FUNCTION bug13012_2() RETURNS INT\nBEGIN\n  CALL bug13012_1();\n  RETURN 1;\nEND|\n--error ER_SP_NO_RETSET\nSELECT bug13012_2()|\ndrop table t1|\ndrop procedure bug13012_1|\ndrop function bug13012_2|\ndelimiter ;|\n\n#\n# BUG#11555 \"Stored procedures: current SP tables locking make \n# impossible view security\". We should not expose names of tables\n# which are implicitly used by view (via stored routines/triggers).\n#\n# Note that SQL standard assumes that you simply won't be able drop table\n# and leave some objects (routines/views/triggers) which were depending on\n# it. Such objects should be dropped in advance (by default) or will be\n# dropped simultaneously with table (DROP TABLE with CASCADE clause).\n# So these tests probably should go away once we will implement standard\n# behavior.\n--disable_warnings\ndrop function if exists bug11555_1;\ndrop function if exists bug11555_2;\ndrop view if exists v1, v2, v3, v4;\n--enable_warnings\ncreate function bug11555_1() returns int return (select max(i) from t1);\ncreate function bug11555_2() returns int return bug11555_1();\n# It is OK to report name of implicitly used table which is missing\n# when we create view.\n# For stored functions however, because of exceptions handlers, there is\n# no easy way to find out if a missing table makes the view invalid.\ncreate view v1 as select bug11555_1();\ndrop view v1;\ncreate view v2 as select bug11555_2();\ndrop view v2;\n# But we should hide name of missing implicitly used table when we use view\ncreate table t1 (i int);\ncreate view v1 as select bug11555_1();\ncreate view v2 as select bug11555_2();\ncreate view v3 as select * from v1;\ndrop table t1;\n--error ER_VIEW_INVALID\nselect * from v1;\n--error ER_VIEW_INVALID\nselect * from v2;\n--error ER_VIEW_INVALID\nselect * from v3;\n# Note that creation of view which depends on broken view is yet \n# another form of view usage.\ncreate view v4 as select * from v1;\ndrop view v1, v2, v3, v4;\n# We also should hide details about broken triggers which are\n# invoked for view.\ndrop function bug11555_1;\ndrop function bug11555_2;\ncreate table t1 (i int);\ncreate table t2 (i int);\ncreate trigger t1_ai after insert on t1 for each row insert into t2 values (new.i);\ncreate view v1 as select * from t1;\ndrop table t2;\n# Limitation, the desired error is ER_VIEW_INVALID\n--error ER_NO_SUCH_TABLE\ninsert into v1 values (1);\ndrop trigger t1_ai;\ncreate function bug11555_1() returns int return (select max(i) from t2);\ncreate trigger t1_ai after insert on t1 for each row set @a:=bug11555_1();\n# Limitation, the desired error is ER_VIEW_INVALID\n--error ER_NO_SUCH_TABLE \ninsert into v1 values (2);\ndrop function bug11555_1;\ndrop table t1;\ndrop view v1;\n\n#\n# BUG#15658: Server crashes after creating function as empty string\n#\n\n--error ER_SP_WRONG_NAME\ncreate procedure ``() select 1;\n--error ER_SP_WRONG_NAME\ncreate procedure ` `() select 1;\n--error ER_SP_WRONG_NAME\ncreate procedure `bug15658 `() select 1;\n--error ER_WRONG_DB_NAME\ncreate procedure ``.bug15658() select 1;\n--error ER_WRONG_DB_NAME\ncreate procedure `x `.bug15658() select 1;\n\n# This should work\ncreate procedure ` bug15658`() select 1;\ncall ` bug15658`();\n--replace_column 5 '0000-00-00 00:00:00' 6 '0000-00-00 00:00:00'\nshow procedure status like '%bug15658';\ndrop procedure ` bug15658`;\n\n\n#\n# BUG#14270: Stored procedures: crash if load index\n#\n--disable_warnings\ndrop function if exists bug14270;\ndrop table if exists t1;\n--enable_warnings\n\ncreate table t1 (s1 int primary key);\n\ndelimiter |;\n--error ER_SP_NO_RETSET\ncreate function bug14270() returns int\nbegin\n  load index into cache t1;\n  return 1;\nend|\n\n--error ER_SP_NO_RETSET\ncreate function bug14270() returns int\nbegin\n  cache index t1 key (`primary`) in keycache1;\n  return 1;\nend|\ndelimiter ;|\n\ndrop table t1;\n\n\n#\n# BUG#15091: Sp Returns Unknown error in order clause....and \n#            there is no order by clause\n#\n\ndelimiter |;\ncreate procedure bug15091()\nbegin\n  declare selectstr varchar(6000) default ' ';\n  declare conditionstr varchar(5000)  default '';\n\n  set selectstr = concat(selectstr,\n                         ' and ',\n                         c.operatorid,\n                         'in (',conditionstr, ')');\nend|\ndelimiter ;|\n\n# The error message used to be:\n#   ERROR 1109 (42S02): Unknown table 'c' in order clause\n# but is now rephrased to something less misleading:\n#   ERROR 1109 (42S02): Unknown table 'c' in field list\n--error ER_UNKNOWN_TABLE\ncall bug15091();\n\ndrop procedure bug15091;\n\n\n#\n# BUG#16896: Stored function: unused AGGREGATE-clause in CREATE FUNCTION\n#\n\n--error ER_PARSE_ERROR\ncreate aggregate function bug16896() returns int return 1;\n\n#\n#\n# BUG#14702: misleading error message when syntax error in CREATE\n# PROCEDURE\n#\n# Misleading error message was given when IF NOT EXISTS was used in\n# CREATE PROCEDURE.\n#\n\n--error ER_PARSE_ERROR\nCREATE IF NOT EXISTS PROCEDURE bug14702()\nBEGIN\nEND;\n\n--error ER_PARSE_ERROR\nCREATE PROCEDURE IF NOT EXISTS bug14702()\nBEGIN\nEND;\n\n\n#\n# BUG#20953: create proc with a create view that uses local\n# vars/params should fail to create\n#\n# See test case for what syntax is forbidden in a view.\n#\n\nCREATE TABLE t1 (i INT);\n\n# We do not have to drop this procedure and view because they won't be\n# created.\n--error ER_VIEW_SELECT_CLAUSE\nCREATE PROCEDURE bug20953() CREATE VIEW v AS SELECT 1 INTO @a;\n--error ER_VIEW_SELECT_CLAUSE\nCREATE PROCEDURE bug20953() CREATE VIEW v AS SELECT 1 INTO DUMPFILE \"file\";\n--error ER_VIEW_SELECT_CLAUSE\nCREATE PROCEDURE bug20953() CREATE VIEW v AS SELECT 1 INTO OUTFILE \"file\";\nCREATE PROCEDURE bug20953() CREATE VIEW v AS SELECT 1 FROM (SELECT 1) AS d1;\nDROP PROCEDURE bug20953;\n--error ER_VIEW_SELECT_VARIABLE\nCREATE PROCEDURE bug20953(i INT) CREATE VIEW v AS SELECT i;\ndelimiter |;\n--error ER_VIEW_SELECT_VARIABLE\nCREATE PROCEDURE bug20953()\nBEGIN\n  DECLARE i INT;\n  CREATE VIEW v AS SELECT i;\nEND |\ndelimiter ;|\n--error ER_VIEW_SELECT_VARIABLE\nPREPARE stmt FROM \"CREATE VIEW v AS SELECT ?\";\n\nDROP TABLE t1;\n\n\n#\n# BUG#24491 \"using alias from source table in insert ... on duplicate key\"\n#\n--disable_warnings\ndrop tables if exists t1;\ndrop procedure if exists bug24491;\n--enable_warnings\ncreate table t1 (id int primary key auto_increment, value varchar(10));\ninsert into t1 (id, value) values (1, 'FIRST'), (2, 'SECOND'), (3, 'THIRD');\n# Let us create routine with INSERT ... SELECT ... ON DUPLICATE KEY UPDATE \n# statement which in its ON DUPLICATE KEY clause erroneously tries to assign\n# value to a column which is mentioned only in SELECT part.\ncreate procedure bug24491()\n  insert into t1 (id, value) select * from (select 4 as i, 'FOURTH' as v) as y on duplicate key update v = 'DUP';\n# Both first and second calls to it should fail\n--error ER_BAD_FIELD_ERROR \ncall bug24491();\n--error ER_BAD_FIELD_ERROR\ncall bug24491();\ndrop procedure bug24491;\n# And now the same test for more complex case which is more close\n# to the one that was reported originally.\ncreate procedure bug24491()\n  insert into t1 (id, value) select * from (select 4 as id, 'FOURTH' as value) as y on duplicate key update y.value = 'DUP';\n--error ER_BAD_FIELD_ERROR \ncall bug24491();\n--error ER_BAD_FIELD_ERROR\ncall bug24491();\ndrop procedure bug24491;\ndrop tables t1;\n\n#\n# BUG#18914: Calling certain SPs from triggers fail\n#\n# Failing to call a procedure that does implicit commit from a trigger\n# is a correct behaviour, however the error message was misleading.\n#\n# DROP TABLE IF EXISTS is also fixed to give correct error instead of\n# \"Table doesn't exist\". \n#\n--disable_warnings\nDROP FUNCTION IF EXISTS bug18914_f1;\nDROP FUNCTION IF EXISTS bug18914_f2;\nDROP PROCEDURE IF EXISTS bug18914_p1;\nDROP PROCEDURE IF EXISTS bug18914_p2;\nDROP TABLE IF EXISTS t1, t2;\n--enable_warnings\n\nCREATE TABLE t1 (i INT);\n\nCREATE PROCEDURE bug18914_p1() CREATE TABLE t2 (i INT);\nCREATE PROCEDURE bug18914_p2() DROP TABLE IF EXISTS no_such_table;\n\ndelimiter |;\nCREATE FUNCTION bug18914_f1() RETURNS INT\nBEGIN\n  CALL bug18914_p1();\n  RETURN 1;\nEND |\n\nCREATE FUNCTION bug18914_f2() RETURNS INT\nBEGIN\n  CALL bug18914_p2();\n  RETURN 1;\nEND |\ndelimiter ;|\n\nCREATE TRIGGER t1_bi BEFORE INSERT ON t1 FOR EACH ROW\n  CALL bug18914_p1();\n\n--error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nINSERT INTO t1 VALUES (1);\n\n--error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nSELECT bug18914_f1();\n\n--error ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG\nSELECT bug18914_f2();\n\n--error ER_NO_SUCH_TABLE\nSELECT * FROM t2;\n\nDROP FUNCTION bug18914_f1;\nDROP FUNCTION bug18914_f2;\nDROP PROCEDURE bug18914_p1;\nDROP PROCEDURE bug18914_p2;\nDROP TABLE t1;\n\n#\n# Bug#20713 (Functions will not not continue for SQLSTATE VALUE '42S02')\n#\n\n--disable_warnings\ndrop table if exists bogus_table_20713;\ndrop function if exists func_20713_a;\ndrop function if exists func_20713_b;\n--enable_warnings\n\ncreate table bogus_table_20713( id int(10) not null primary key);\ninsert into bogus_table_20713 values (1), (2), (3);\n\ndelimiter //;\n\ncreate function func_20713_a() returns int(11)\nbegin\n  declare id int;\n\n  declare continue handler for sqlexception set id=null;\n\n  set @in_func := 1;\n  set id = (select id from bogus_table_20713 where id = 3);\n  set @in_func := 2;\n\n  return id;\nend//\n\ncreate function func_20713_b() returns int(11)\nbegin\n  declare id int;\n\n  declare continue handler for sqlstate value '42S02' set id=null;\n\n  set @in_func := 1;\n  set id = (select id from bogus_table_20713 where id = 3);\n  set @in_func := 2;\n\n  return id;\nend//\n\ndelimiter ;//\n\nset @in_func := 0;\nselect func_20713_a();\nselect @in_func;\n\nset @in_func := 0;\nselect func_20713_b();\nselect @in_func;\n\ndrop table bogus_table_20713;\n\nset @in_func := 0;\nselect func_20713_a();\nselect @in_func;\n\nset @in_func := 0;\nselect func_20713_b();\nselect @in_func;\n\ndrop function if exists func_20713_a;\ndrop function if exists func_20713_b;\n\n#\n# Bug#25345 (Cursors from Functions)\n#\n\n--disable_warnings\ndrop table if exists table_25345_a;\ndrop table if exists table_25345_b;\ndrop procedure if exists proc_25345;\ndrop function if exists func_25345;\ndrop function if exists func_25345_b;\n--enable_warnings\n\ncreate table table_25345_a (a int);\ncreate table table_25345_b (b int);\n\ndelimiter ||;\n\ncreate procedure proc_25345()\nbegin\n  declare c1 cursor for select a from table_25345_a;\n  declare c2 cursor for select b from table_25345_b;\n\n  select 1 as result;\nend ||\n\ncreate function func_25345() returns int(11)\nbegin\n  call proc_25345();\n  return 1;\nend ||\n\ncreate function func_25345_b() returns int(11)\nbegin\n  declare c1 cursor for select a from table_25345_a;\n  declare c2 cursor for select b from table_25345_b;\n\n  return 1;\nend ||\n\ndelimiter ;||\n\ncall proc_25345();\n--error ER_SP_NO_RETSET\nselect func_25345();\nselect func_25345_b();\n\ndrop table table_25345_a;\n\ncall proc_25345();\n--error ER_SP_NO_RETSET\nselect func_25345();\nselect func_25345_b();\n\ndrop table table_25345_b;\ndrop procedure proc_25345;\ndrop function func_25345;\ndrop function func_25345_b;\n\n#\n# End of 5.0 tests\n#\n--echo End of 5.0 tests\n\n#\n# BUG#20701: BINARY keyword should be forbidden in stored routines\n#\n#\n# This was disabled in 5.1.12. See bug #20701\n# When collation support in SP is implemented, then this test should\n# be removed.\n#\n--error ER_NOT_SUPPORTED_YET\ncreate function bug20701() returns varchar(25) binary return \"test\";\ncreate function bug20701() returns varchar(25) return \"test\";\ndrop function bug20701;\n\n#\n# Bug#26503 (Illegal SQL exception handler code causes the server to crash)\n#\n\ndelimiter //;\n\n--error ER_SP_LILABEL_MISMATCH\ncreate procedure proc_26503_error_1()\nbegin\nretry:\n  repeat\n    begin\n      declare continue handler for sqlexception\n      begin\n        iterate retry;\n      end\n\n      select \"do something\";\n    end\n  until true end repeat retry;\nend//\n\n--error ER_SP_LILABEL_MISMATCH\ncreate procedure proc_26503_error_2()\nbegin\nretry:\n  repeat\n    begin\n      declare continue handler for sqlexception\n        iterate retry;\n\n      select \"do something\";\n    end\n  until true end repeat retry;\nend//\n\n--error ER_SP_LILABEL_MISMATCH\ncreate procedure proc_26503_error_3()\nbegin\nretry:\n  repeat\n    begin\n      declare continue handler for sqlexception\n      begin\n        leave retry;\n      end\n\n      select \"do something\";\n    end\n  until true end repeat retry;\nend//\n\n--error ER_SP_LILABEL_MISMATCH\ncreate procedure proc_26503_error_4()\nbegin\nretry:\n  repeat\n    begin\n      declare continue handler for sqlexception\n        leave retry;\n\n      select \"do something\";\n    end\n  until true end repeat retry;\nend//\n\ndelimiter ;//\n\n\n#\n# Bug#29223 declare cursor c for SHOW .....\n#\n\n--delimiter |\n--error ER_PARSE_ERROR\nCREATE PROCEDURE p1()\nBEGIN\n  DECLARE c char(100);\n  DECLARE cur1 CURSOR FOR SHOW TABLES;\n\n  OPEN cur1;\n  FETCH cur1 INTO c;\n  select c;\n  CLOSE cur1;\nEND|\n--delimiter ;\n\n#\n# Bug#29816 Syntactically wrong query fails with misleading error message\n#\n\nCREATE DATABASE mysqltest;\nUSE mysqltest;\nDROP DATABASE mysqltest;\n# Both ER_SP_DOES_NOT_EXIST and ER_PARSE_ERROR are valid here, the result is\n# implementation dependent: See Bug#29816 for details.  \n# ER_SP_DOES_NOT_EXIST has been replaced by ER_NO_DB_ERROR since it is valid in\n# this scenario. See Bug# 13864485 for details.\n--error ER_PARSE_ERROR\nSELECT inexistent(), 1 + ,;\n--error ER_NO_DB_ERROR\nSELECT inexistent();\n--error ER_PARSE_ERROR\nSELECT .inexistent();\n--error ER_PARSE_ERROR\nSELECT ..inexistent();\nUSE test;\n\n#\n# Bug#30904 SET PASSWORD statement is non-transactional\n#\n\ndelimiter |;\n\n--error ER_SP_CANT_SET_AUTOCOMMIT\ncreate function f1() returns int\nbegin\n set password = 'foo';\n  return 1;\nend|\n\n--error ER_SP_CANT_SET_AUTOCOMMIT\ncreate trigger t1\n  before insert on t2 for each row set password = 'foo';|\n\ndelimiter ;|\n\n#\n# Bug#30882 Dropping a temporary table inside a stored function may cause a server crash\n#\n\n--disable_warnings\ndrop function if exists f1;\ndrop function if exists f2;\ndrop table if exists t1, t2;\n--enable_warnings\n\ndelimiter |;\ncreate function f1() returns int\nbegin\n drop temporary table t1;\n return 1;\nend|\ndelimiter ;|\n--error ER_CANT_REOPEN_TABLE\ncreate temporary table t1 as select f1();\n\ndelimiter |;\ncreate function f2() returns int\nbegin\n create temporary table t2 as select f1();\n return 1;\nend|\ndelimiter ;|\n--error ER_CANT_REOPEN_TABLE\ncreate temporary table t1 as select f2();\n\ndrop function f1;\ndrop function f2;\n\ndelimiter |;\ncreate function f1() returns int\nbegin\n drop temporary table t2,t1;\n return 1;\nend|\ncreate function f2() returns int\nbegin\n create temporary table t2 as select f1();\n return 1;\nend|\ndelimiter ;|\n--error ER_CANT_REOPEN_TABLE\ncreate temporary table t1 as select f2();\n\ndrop function f1;\ndrop function f2;\n\ncreate temporary table t2(a int);\nselect * from t2;\ndelimiter |;\ncreate function f2() returns int\nbegin\n drop temporary table t2;\n return 1;\nend|\ndelimiter ;|\nselect f2();\n\ndrop function f2;\n--error ER_BAD_TABLE_ERROR\ndrop table t2;\n\n--echo End of 5.1 tests\n\n#\n# Bug#33983 (Stored Procedures: wrong end <label> syntax is accepted)\n#\n\n--disable_warnings\ndrop procedure if exists proc_33983_a;\ndrop procedure if exists proc_33983_b;\ndrop procedure if exists proc_33983_c;\ndrop procedure if exists proc_33983_d;\n--enable_warnings\n\ndelimiter |;\n\n--error ER_SP_LABEL_MISMATCH\ncreate procedure proc_33983_a()\nbegin\n  label1:\n    begin\n      label2:\n      begin\n        select 1;\n      end label1;\n    end;\nend|\n\n--error ER_SP_LABEL_MISMATCH\ncreate procedure proc_33983_b()\nbegin\n  label1:\n    repeat\n      label2:\n      repeat\n        select 1;\n      until FALSE end repeat label1;\n    until FALSE end repeat;\nend|\n\n--error ER_SP_LABEL_MISMATCH\ncreate procedure proc_33983_c()\nbegin\n  label1:\n    while TRUE do\n      label2:\n      while TRUE do\n        select 1;\n      end while label1;\n    end while;\nend|\n\n--error ER_SP_LABEL_MISMATCH\ncreate procedure proc_33983_d()\nbegin\n  label1:\n    loop\n      label2:\n      loop\n        select 1;\n      end loop label1;\n    end loop;\nend|\n\nCREATE TABLE t1 (a INT)|\nINSERT INTO t1 VALUES (1),(2)|\nCREATE PROCEDURE p1(a INT) BEGIN END|\n--error ER_SUBQUERY_NO_1_ROW\nCALL p1((SELECT * FROM t1))|\nDROP PROCEDURE IF EXISTS p1|\nDROP TABLE t1|\n\ndelimiter ;|\n\n#\n# Bug#21801: SQL exception handlers and warnings\n#\n\ndelimiter |;\ncreate procedure p1()\nbegin\n  create table t1 (a int);\n  drop table t1;\nend|\ndelimiter ;|\ncall p1();\ncall p1();\ndrop procedure p1;\n\n#\n# Bug#8759 (Stored Procedures: SQLSTATE '00000' should be illegal)\n#\n\ndelimiter $$;\n\n--error ER_SP_BAD_SQLSTATE\ncreate procedure proc_8759()\nbegin\n  declare should_be_illegal condition for sqlstate '00000';\n  declare continue handler for should_be_illegal set @x=0;\nend$$\n\n--error ER_SP_BAD_SQLSTATE\ncreate procedure proc_8759()\nbegin\n  declare continue handler for sqlstate '00000' set @x=0;\nend$$\n\ndelimiter ;$$\n\n#\n# Bug#36510 (Stored Procedures: mysql_error_code 0 should be illegal)\n#\n\ndelimiter $$;\n\n--error ER_SP_BAD_SQLSTATE\ncreate procedure proc_36510()\nbegin\n  declare should_be_illegal condition for sqlstate '00123';\n  declare continue handler for should_be_illegal set @x=0;\nend$$\n\n--error ER_SP_BAD_SQLSTATE\ncreate procedure proc_36510()\nbegin\n  declare continue handler for sqlstate '00123' set @x=0;\nend$$\n\n--error ER_WRONG_VALUE\ncreate procedure proc_36510()\nbegin\n  declare should_be_illegal condition for 0;\n  declare continue handler for should_be_illegal set @x=0;\nend$$\n\n--error ER_WRONG_VALUE\ncreate procedure proc_36510()\nbegin\n  declare continue handler for 0 set @x=0;\nend$$\ndelimiter ;$$\n\n#\n# Bug#15192: \"fatal errors\" are caught by handlers in stored procedures\n#\n\nset @old_recursion_depth = @@max_sp_recursion_depth;\nset @@max_sp_recursion_depth = 255;\ndelimiter |;\ncreate procedure p1(a int)\nbegin\n  declare continue handler for 1436 -- ER_STACK_OVERRUN_NEED_MORE\n    select 'exception';\n  call p1(a+1);\nend|\ndelimiter ;|\n--error 0,ER_STACK_OVERRUN_NEED_MORE,ER_SP_RECURSION_LIMIT\ncall p1(1);\nset @@max_sp_recursion_depth = @old_recursion_depth;\ndrop procedure p1;\n\n#\n# BUG#NNNN: New bug synopsis\n#\n#--disable_warnings\n#drop procedure if exists bugNNNN;\n#drop function if exists bugNNNN;\n#--enable_warnings\n#create procedure bugNNNN...\n#create function bugNNNN...\n\n\n#\n# Bug #38159: Function parsing problem generates misleading error message\n#\n\nCREATE TABLE t1 (a INT, b INT);\nINSERT INTO t1 VALUES (1,1), (2,2);\n--error ER_FUNC_INEXISTENT_NAME_COLLISION\nSELECT MAX (a) FROM t1 WHERE b = 999999;\nSELECT AVG (a) FROM t1 WHERE b = 999999;\n--error ER_SP_DOES_NOT_EXIST\nSELECT non_existent (a) FROM t1 WHERE b = 999999;\nDROP TABLE t1;\n\n\n#\n# Bug #46374 crash, INSERT INTO t1 uses function, function modifies t1\n#\nCREATE TABLE t1 ( f2 INTEGER, f3 INTEGER );\nINSERT INTO t1 VALUES  ( 1, 1 );\n\ndelimiter |;\n\nCREATE FUNCTION func_1 () RETURNS INTEGER\nBEGIN\n  INSERT INTO t1 SELECT * FROM t1 ;\n  RETURN 1 ;\nEND|\n\ndelimiter ;|\n\n# The bug caused the following INSERT statement to trigger\n# an assertion.   Error 1442 is the correct response\n#\n--error 1442\nINSERT INTO t1 SELECT * FROM (SELECT 2 AS f1, 2 AS f2) AS A WHERE func_1() = 5;\n\n# Cleanup\nDROP FUNCTION func_1;\nDROP TABLE t1;\n\n\n\n--echo #\n--echo # Bug #47788: Crash in TABLE_LIST::hide_view_error on UPDATE + VIEW + \n--echo #   SP + MERGE + ALTER\n--echo #\n\nCREATE TABLE t1 (pk INT, b INT, KEY (b));\nCREATE ALGORITHM = TEMPTABLE VIEW v1 AS SELECT * FROM t1;\n\nCREATE PROCEDURE p1 (a int) UPDATE IGNORE v1 SET b = a; \n\n--error ER_NON_UPDATABLE_TABLE\nCALL p1(5);\n\nALTER TABLE t1 CHANGE COLUMN b b2 INT;\n\n--error ER_VIEW_INVALID\nCALL p1(7);\n\nDROP PROCEDURE p1;\nDROP VIEW v1;\nDROP TABLE t1;\n\n--echo #\n--echo # Bug#12428824 - PARSER STACK OVERFLOW AND CRASH IN SP_ADD_USED_ROUTINE\n--echo #                WITH OBSCURE QUERY\n--echo #\n\n--error ER_TOO_LONG_IDENT\nSELECT very_long_fn_name_1111111111111111111111111111111111111111111111111111111111111111111111111222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222225555555555555555555555555577777777777777777777777777777777777777777777777777777777777777777777777788888888999999999999999999999();\n\n--error ER_TOO_LONG_IDENT\nCALL very_long_pr_name_1111111111111111111111111111111111111111111111111111111111111111111111111222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222225555555555555555555555555577777777777777777777777777777777777777777777777777777777777777777777777788888888999999999999999999999();\n\n--error ER_WRONG_DB_NAME\nSELECT very_long_db_name_1111111111111111111111111111111111111111111111111111111111111111111111111222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222225555555555555555555555555577777777777777777777777777777777777777777777777777777777777777777777777788888888999999999999999999999.simple_func();\n\n--error ER_WRONG_DB_NAME\nCALL very_long_db_name_1111111111111111111111111111111111111111111111111111111111111111111111111222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222225555555555555555555555555577777777777777777777777777777777777777777777777777777777777777777777777788888888999999999999999999999.simple_proc();\n\n--error ER_TOO_LONG_IDENT\nSELECT db_name.very_long_fn_name_111111111111111111111111111111111111111111111111111111111111111111111111122222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999999999999999999();\n\n--error ER_TOO_LONG_IDENT\nCALL db_name.very_long_pr_name_111111111111111111111111111111111111111111111111111111111111111111111111122222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999999999999999999();\n--echo End of 5.1 tests\n\n--echo #\n--echo # Bug#23032: Handlers declared in a SP do not handle warnings generated in sub-SP\n--echo #\n\n--echo\n--echo # - Case 1\n--echo\n\n--disable_warnings\nDROP PROCEDURE IF EXISTS p1;\nDROP PROCEDURE IF EXISTS p2;\nDROP PROCEDURE IF EXISTS p3;\nDROP PROCEDURE IF EXISTS p4;\nDROP PROCEDURE IF EXISTS p5;\nDROP PROCEDURE IF EXISTS p6;\n--enable_warnings\nSET sql_mode = 'NO_ENGINE_SUBSTITUTION';\ndelimiter |;\n\nCREATE PROCEDURE p1()\n  BEGIN\n    SELECT CAST('10 ' as unsigned integer);\n    SELECT 1;\n    CALL p2();\n  END|\n\nCREATE PROCEDURE p2()\n  BEGIN\n    SELECT CAST('10 ' as unsigned integer);\n  END|\n\ndelimiter ;|\n\nCALL p1();\n\nDROP PROCEDURE p1;\nDROP PROCEDURE p2;\n\n--echo\n--echo # - Case 2\n--echo\n\nCREATE TABLE t1(a INT);\n\ndelimiter |;\n\nCREATE PROCEDURE p1()\n  BEGIN\n    DECLARE c INT DEFAULT 0;\n    DECLARE CONTINUE HANDLER FOR SQLWARNING\n    BEGIN\n      SET c = c + 1;\n      SELECT 'Warning caught!' AS Msg;\n    END;\n    CALL p2(); # 1 warning\n    CALL p3(); # 1 warning\n    CALL p4(); # No warnings\n    CALL p5(); # 1 warning\n    SELECT c;\n    SELECT @@warning_count;\n    SHOW WARNINGS;\n  END|\n\nCREATE PROCEDURE p2()\n  BEGIN\n    SELECT CAST('2 ' as unsigned integer);\n  END| # 1 warning is passed to the caller\n\nCREATE PROCEDURE p3()\n  BEGIN\n    SELECT CAST('3 ' as unsigned integer);\n    GET DIAGNOSTICS @n = NUMBER; # does not clear the warning\n  END| # 1 warning is passed to the caller\n\nCREATE PROCEDURE p4()\n  BEGIN\n    SELECT CAST('4 ' as unsigned integer);\n    INSERT INTO t1 VALUES(1); # Clears the warning\n  END| # No warnings to pass\n\nCREATE PROCEDURE p5()\n  BEGIN\n    SELECT CAST('5 ' as unsigned integer);\n    CALL p2();\n  END|\n\nCREATE PROCEDURE p6()\n  BEGIN\n    SELECT CAST('6 ' as unsigned integer);\n    SHOW WARNINGS;\n  END|\n\nCREATE PROCEDURE p7()\n  BEGIN\n    DECLARE c INT DEFAULT 0;\n    DECLARE CONTINUE HANDLER FOR SQLWARNING\n    BEGIN\n      SET c = c + 1;\n      SELECT 'Warning caught!' AS Msg;\n    END;\n    CALL p6();\n    SELECT c;\n  END|\n\ndelimiter ;|\n\n--echo\nCALL p1();\n\n--echo\nCALL p7();\n\n--echo\n\nDROP PROCEDURE p1;\nDROP PROCEDURE p2;\nDROP PROCEDURE p3;\nDROP PROCEDURE p4;\nDROP PROCEDURE p5;\nDROP PROCEDURE p6;\nDROP PROCEDURE p7;\n\nDROP TABLE t1;\nSET sql_mode = default;\n--echo\n--echo # - Case 3: check that \"Exception trumps No Data\".\n--echo\n\nCREATE TABLE t1(a INT);\nINSERT INTO t1 VALUES (1), (2), (3);\n\ndelimiter |;\n\nCREATE PROCEDURE p1()\nBEGIN\n  DECLARE c CURSOR FOR SELECT a FROM t1;\n\n  OPEN c;\n  \n  BEGIN\n    DECLARE v1 INT;\n    DECLARE v2 INT;\n\n    DECLARE EXIT HANDLER FOR SQLEXCEPTION\n      SELECT \"Error caught (expected)\";\n\n    DECLARE EXIT HANDLER FOR NOT FOUND\n      SELECT \"End of Result Set found!\";\n\n    WHILE TRUE DO\n      FETCH c INTO v1, v2;\n    END WHILE;\n  END;\n\n  CLOSE c;\n\n  SELECT a INTO @foo FROM t1 LIMIT 1; # Clear warning stack\nEND|\n\ndelimiter ;|\n\nCALL p1();\n\nDROP PROCEDURE p1;\nDROP TABLE t1;\n\n--echo #\n--echo # Bug#36185: Incorrect precedence for warning and exception handlers\n--echo #\n\n--disable_warnings\nDROP TABLE IF EXISTS t1;\nDROP PROCEDURE IF EXISTS p1;\n--enable_warnings\n\nCREATE TABLE t1 (a INT, b INT NOT NULL);\n\ndelimiter |;\n\nCREATE PROCEDURE p1()\nBEGIN\n  DECLARE CONTINUE HANDLER FOR SQLWARNING SELECT 'warning';\n  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SELECT 'exception';\n  INSERT INTO t1 VALUES (CAST('10 ' AS SIGNED), NULL);\nEND|\n\ndelimiter ;|\n\nCALL p1();\n\nDROP TABLE t1;\nDROP PROCEDURE p1;\n\n--echo #\n--echo # Bug#5889: Exit handler for a warning doesn't hide the warning in trigger\n--echo #\nSET sql_mode = 'NO_ENGINE_SUBSTITUTION';\nCREATE TABLE t1(a INT, b INT);\nINSERT INTO t1 VALUES (1, 2);\n\ndelimiter |;\n\nCREATE TRIGGER t1_bu BEFORE UPDATE ON t1 FOR EACH ROW\nBEGIN\n  DECLARE EXIT HANDLER FOR SQLWARNING\n    SET NEW.a = 10;\n\n  SET NEW.a = 99999999999;\nEND|\n\ndelimiter ;|\n\nUPDATE t1 SET b = 20;\n\nSHOW WARNINGS;\n\nSELECT * FROM t1;\n\nDROP TRIGGER t1_bu;\nDROP TABLE t1;\nSET sql_mode = default;\n--echo #\n--echo # Bug#9857: Stored procedures: handler for sqlwarning ignored\n--echo #\n\nCREATE TABLE t1(a INT PRIMARY KEY);\nINSERT INTO t1 VALUES(1);\nSET @sql_mode_saved = @@sql_mode;\nSET sql_mode = traditional;\n\ndelimiter |;\n\nCREATE PROCEDURE p1()\nBEGIN\n  DECLARE CONTINUE HANDLER FOR SQLWARNING\n    SELECT 'warning caught (expected)';\n  \n  INSERT IGNORE INTO t1 VALUES (1);\nEND|\n\nCREATE PROCEDURE p2()\nBEGIN\n  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION\n    SELECT 'error caught (unexpected)';\n  \n  INSERT IGNORE INTO t1 VALUES (1);\nEND|\n\ndelimiter ;|\n\nCALL p1();\nSHOW WARNINGS;\n\nCALL p2();\nSHOW WARNINGS;\n\nDROP PROCEDURE p1;\nDROP PROCEDURE p2;\nDROP TABLE t1;\nSET sql_mode = @sql_mode_saved;\n\n--echo #\n--echo # Bug#55850: Trigger warnings not cleared.\n--echo #\nSET sql_mode = 'NO_ENGINE_SUBSTITUTION';\n--disable_warnings\nDROP TABLE IF EXISTS t1;\nDROP TABLE IF EXISTS t2;\nDROP PROCEDURE IF EXISTS p1;\n--enable_warnings\n\nCREATE TABLE t1(x SMALLINT, y SMALLINT, z SMALLINT);\nCREATE TABLE t2(a SMALLINT, b SMALLINT, c SMALLINT,\n                d SMALLINT, e SMALLINT, f SMALLINT);\n\nCREATE TRIGGER t1_bi BEFORE INSERT ON t1 FOR EACH ROW\n  INSERT INTO t2(a, b, c) VALUES(99999, 99999, 99999);\n\nCREATE TRIGGER t1_ai AFTER INSERT ON t1 FOR EACH ROW\n  INSERT INTO t2(d, e, f) VALUES(99999, 99999, 99999);\n\nCREATE PROCEDURE p1()\n  INSERT INTO t1 VALUES(99999, 99999, 99999);\n\n# What happened before the patch was:\n#  - INSERT INTO t1 added 3 warnings about overflow in 'x', 'y' and 'z' columns;\n#  - t1_bi run and added 3 warnings about overflow in 'a', 'b' and 'c' columns;\n#  - t1_ai run and added 3 warnings about overflow in 'd', 'e' and 'f' columns;\n# => we had 9 warnings.\n#\n# Now what happens is:\n#  - INSERT INTO t1 adds 3 warnings about overflow in 'x', 'y' and 'z' columns;\n#  - t1_bi adds 3 warnings about overflow in 'a', 'b' and 'c' columns;\n#  - The warnings added by triggers are cleared;\n#  - t1_ai run and added 3 warnings about overflow in 'd', 'e' and 'f' columns;\n#  - The warnings added by triggers are cleared;\n# => we have 3 warnings.\n\n--echo\nCALL p1();\n\n--echo\nSHOW WARNINGS;\n\n--echo\nDROP TABLE t1;\nDROP TABLE t2;\nDROP PROCEDURE p1;\n\n--echo # ----------------------------------------------------------------------\n\nCREATE TABLE t1(x SMALLINT, y SMALLINT, z SMALLINT);\nCREATE TABLE t2(a SMALLINT, b SMALLINT, c SMALLINT NOT NULL);\n\ndelimiter |;\n\nCREATE TRIGGER t1_bi BEFORE INSERT ON t1 FOR EACH ROW\nBEGIN\n  INSERT INTO t2 VALUES(\n    CAST('111111 ' AS SIGNED),\n    CAST('222222 ' AS SIGNED),\n    NULL);\nEND|\n\ndelimiter ;|\n\nCREATE PROCEDURE p1()\n  INSERT INTO t1 VALUES(99999, 99999, 99999);\n\n--echo\n--error ER_BAD_NULL_ERROR\nCALL p1();\n\n--echo\nSHOW WARNINGS;\n\n--echo\nDROP TABLE t1;\nDROP TABLE t2;\nDROP PROCEDURE p1;\nSET sql_mode = default;\n--echo\n--echo ###################################################################\n--echo # Tests for the following bugs:\n--echo #   - Bug#11763171: 55852 - Possibly inappropriate handler activation.\n--echo #   - Bug#11749343: 38806 - Wrong scope for SQL HANDLERS in SP.\n--echo ###################################################################\n--echo\n\n#\n# Structure of SQL-block:\n# BEGIN\n#   <Handler declaration block>\n#   <Statement block>\n# END\n#\n# Scope of Handler-decl-block is Statement-block.\n# I.e. SQL-conditions thrown in the Handler-decl-block can not be handled by\n# the same block, only by outer SQL-blocks.\n#\n# This rule is recursive, i.e. if a Handler-decl-block has nested SQL-blocks,\n# the SQL-conditions from those nested blocks can not be handled by the this\n# Handler-decl-block, only by outer SQL-blocks.\n#\n\ndelimiter |;\n\n--echo\n--echo # -- Check that SQL-conditions thrown by Statement-blocks are\n--echo # -- handled by Handler-decl blocks properly.\n--echo\n\nCREATE PROCEDURE p1()\nBEGIN\n  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION\n    SELECT 'H1' AS HandlerId;\n\n  DECLARE CONTINUE HANDLER FOR SQLWARNING\n    SELECT 'H2' AS HandlerId;\n\n  SIGNAL SQLSTATE '01000'; # Should be handled by H2.\nEND|\n\n--echo\nCALL p1()|\n\n--echo\n--echo # -- Check that SQL-conditions thrown by Statement-blocks are\n--echo # -- handled by Handler-decl blocks properly in case of nested\n--echo # -- SQL-blocks.\n--echo\n\nCREATE PROCEDURE p2()\nBEGIN\n  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION\n    SELECT 'H1' AS HandlerId;\n\n  DECLARE CONTINUE HANDLER FOR SQLWARNING\n    SELECT 'H2' AS HandlerId;\n\n  BEGIN\n\n    SELECT 'B1' AS BlockId;\n    BEGIN\n\n      SELECT 'B2' AS BlockId;\n      BEGIN\n        SELECT 'B3' AS BlockId;\n        SIGNAL SQLSTATE '01000'; # Should be handled by H2.\n      END;\n\n    END;\n\n  END;\n\nEND|\n\n--echo\nCALL p2()|\n\n--echo\n--echo # -- Check SQL-handler resolution rules.\n--echo\n\nCREATE PROCEDURE p3()\nBEGIN\n  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION\n    SELECT 'H1' AS HandlerId;\n\n  DECLARE CONTINUE HANDLER FOR SQLWARNING\n    SELECT 'H2' AS HandlerId;\n\n  DECLARE CONTINUE HANDLER FOR SQLSTATE '01000'\n    SELECT 'H3' AS HandlerId;\n\n  SIGNAL SQLSTATE '01000'; # Should be handled by H3.\nEND|\n\n--echo\nCALL p3()|\n--echo\n\nCREATE PROCEDURE p4()\nBEGIN\n  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION\n    SELECT 'H1' AS HandlerId;\n\n  DECLARE CONTINUE HANDLER FOR SQLSTATE '01000'\n    SELECT 'H2' AS HandlerId;\n\n  DECLARE CONTINUE HANDLER FOR SQLWARNING\n    SELECT 'H3' AS HandlerId;\n\n  SIGNAL SQLSTATE '01000'; # Should be handled by H2.\nEND|\n\n--echo\nCALL p4()|\n--echo\n\nCREATE PROCEDURE p5()\nBEGIN\n  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION\n    SELECT 'H1' AS HandlerId;\n\n  DECLARE CONTINUE HANDLER FOR SQLSTATE '01000'\n    SELECT 'H2' AS HandlerId;\n\n  BEGIN\n    DECLARE CONTINUE HANDLER FOR SQLWARNING\n      SELECT 'H3' AS HandlerId;\n\n    SIGNAL SQLSTATE '01000'; # Should be handled by H3.\n  END;\nEND|\n\n--echo\nCALL p5()|\n\n--echo\n--echo # -- Check that handlers don't handle its own exceptions.\n--echo\n\nCREATE PROCEDURE p6()\nBEGIN\n  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION\n  BEGIN\n    SELECT 'H1' AS HandlerId;\n    SIGNAL SQLSTATE 'HY000'; # Should *not* be handled by H1.\n  END;\n\n  SELECT 'S1' AS SignalId;\n  SIGNAL SQLSTATE 'HY000'; # Should be handled by H1.\nEND|\n\n--echo\n--error ER_SIGNAL_EXCEPTION\nCALL p6()|\n\n--echo\n--echo # -- Check that handlers don't handle its own warnings.\n--echo\n\nCREATE PROCEDURE p7()\nBEGIN\n  DECLARE CONTINUE HANDLER FOR SQLWARNING\n  BEGIN\n    SELECT 'H1' AS HandlerId;\n    SIGNAL SQLSTATE '01000'; # Should *not* be handled by H1.\n  END;\n\n  SELECT 'S1' AS SignalId;\n  SIGNAL SQLSTATE '01000'; # Should be handled by H1.\nEND|\n\n--echo\nCALL p7()|\n\n--echo\n--echo # -- Check that conditions for handlers are not handled by the handlers\n--echo # -- from the same block.\n--echo\n\nCREATE PROCEDURE p8()\nBEGIN\n  DECLARE CONTINUE HANDLER FOR SQLWARNING\n    SELECT 'H1' AS HandlerId;\n\n  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION\n  BEGIN\n    SELECT 'H2' AS HandlerId;\n    SIGNAL SQLSTATE '01000'; # Should *not* be handled by H1.\n  END;\n\n  SELECT 'S1' AS SignalId;\n  SIGNAL SQLSTATE 'HY000'; # Should be handled by H2.\nEND|\n\n--echo\nCALL p8()|\n\n--echo\n--echo # -- Check that conditions for handlers are not handled by the handlers\n--echo # -- from the same block even if they are thrown deep down the stack.\n--echo\n\nCREATE PROCEDURE p9()\nBEGIN\n\n  DECLARE CONTINUE HANDLER FOR SQLSTATE '01000'\n    SELECT 'Wrong:H1:1' AS HandlerId;\n\n  DECLARE CONTINUE HANDLER FOR SQLWARNING\n    SELECT 'Wrong:H1:2' AS HandlerId;\n\n  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION\n  BEGIN\n\n    DECLARE CONTINUE HANDLER FOR SQLSTATE '01000'\n      SELECT 'Wrong:H2:1' AS HandlerId;\n\n    DECLARE CONTINUE HANDLER FOR SQLWARNING\n      SELECT 'Wrong:H2:2' AS HandlerId;\n\n    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION\n    BEGIN\n\n      DECLARE CONTINUE HANDLER FOR SQLSTATE '01000'\n        SELECT 'Wrong:H3:1' AS HandlerId;\n\n      DECLARE CONTINUE HANDLER FOR SQLWARNING\n        SELECT 'Wrong:H3:2' AS HandlerId;\n\n      DECLARE CONTINUE HANDLER FOR SQLEXCEPTION\n      BEGIN\n\n        DECLARE CONTINUE HANDLER FOR SQLSTATE '01000'\n          SELECT 'Wrong:H4:1' AS HandlerId;\n\n        DECLARE CONTINUE HANDLER FOR SQLWARNING\n          SELECT 'Wrong:H4:2' AS HandlerId;\n\n        DECLARE CONTINUE HANDLER FOR SQLEXCEPTION\n        BEGIN\n\n          DECLARE CONTINUE HANDLER FOR SQLSTATE '01000'\n            SELECT 'Wrong:H5:1' AS HandlerId;\n\n          DECLARE CONTINUE HANDLER FOR SQLWARNING\n            SELECT 'Wrong:H5:2' AS HandlerId;\n\n          DECLARE CONTINUE HANDLER FOR SQLEXCEPTION\n          BEGIN\n\n            DECLARE CONTINUE HANDLER FOR SQLSTATE '01000'\n              SELECT 'Wrong:H6:1' AS HandlerId;\n\n            DECLARE CONTINUE HANDLER FOR SQLWARNING\n              SELECT 'Wrong:H6:2' AS HandlerId;\n\n            DECLARE CONTINUE HANDLER FOR SQLEXCEPTION\n            BEGIN\n              SELECT 'H2' AS HandlerId;\n              SIGNAL SQLSTATE '01000'; # Should *not* be handled by H1.\n            END;\n\n            SELECT 'S6' AS SignalId;\n            SIGNAL SQLSTATE 'HY000';\n          END;\n\n          SELECT 'S5' AS SignalId;\n          SIGNAL SQLSTATE 'HY000';\n\n        END;\n\n        SELECT 'S4' AS SignalId;\n        SIGNAL SQLSTATE 'HY000';\n\n      END;\n\n      SELECT 'S3' AS SignalId;\n      SIGNAL SQLSTATE 'HY000';\n\n    END;\n\n    SELECT 'S2' AS SignalId;\n    SIGNAL SQLSTATE 'HY000';\n\n  END;\n\n  SELECT 'S1' AS SignalId;\n  SIGNAL SQLSTATE 'HY000'; # Should be handled by H2.\n\nEND|\n\n--echo\nCALL p9()|\n\n--echo\n--echo # -- Check that handlers are choosen properly in case of deep stack and\n--echo # -- nested SQL-blocks.\n--echo\n\nCREATE PROCEDURE p10()\nBEGIN\n  DECLARE CONTINUE HANDLER FOR SQLSTATE '01000'\n    SELECT 'H1' AS HandlerId;\n\n  DECLARE CONTINUE HANDLER FOR SQLWARNING\n    SELECT 'H2' AS HandlerId;\n\n  BEGIN\n    BEGIN\n      BEGIN\n\n        DECLARE CONTINUE HANDLER FOR SQLSTATE '01000'\n          SELECT 'Wrong:H1:1' AS HandlerId;\n\n        DECLARE CONTINUE HANDLER FOR SQLWARNING\n          SELECT 'Wrong:H1:2' AS HandlerId;\n\n        DECLARE CONTINUE HANDLER FOR SQLEXCEPTION\n        BEGIN\n\n          DECLARE CONTINUE HANDLER FOR SQLSTATE '01000'\n            SELECT 'Wrong:H2:1' AS HandlerId;\n\n          DECLARE CONTINUE HANDLER FOR SQLWARNING\n            SELECT 'Wrong:H2:2' AS HandlerId;\n\n          DECLARE CONTINUE HANDLER FOR SQLEXCEPTION\n          BEGIN\n\n            DECLARE CONTINUE HANDLER FOR SQLSTATE '01000'\n              SELECT 'Wrong:H3:1' AS HandlerId;\n\n            DECLARE CONTINUE HANDLER FOR SQLWARNING\n              SELECT 'Wrong:H3:2' AS HandlerId;\n\n            DECLARE CONTINUE HANDLER FOR SQLEXCEPTION\n            BEGIN\n\n              DECLARE CONTINUE HANDLER FOR SQLSTATE '01000'\n                SELECT 'Wrong:H4:1' AS HandlerId;\n\n              DECLARE CONTINUE HANDLER FOR SQLWARNING\n                SELECT 'Wrong:H4:2' AS HandlerId;\n\n              DECLARE CONTINUE HANDLER FOR SQLEXCEPTION\n              BEGIN\n\n                DECLARE CONTINUE HANDLER FOR SQLSTATE '01000'\n                  SELECT 'Wrong:H5:1' AS HandlerId;\n\n                DECLARE CONTINUE HANDLER FOR SQLWARNING\n                  SELECT 'Wrong:H5:2' AS HandlerId;\n\n                DECLARE CONTINUE HANDLER FOR SQLEXCEPTION\n                BEGIN\n\n                  DECLARE CONTINUE HANDLER FOR SQLSTATE '01000'\n                    SELECT 'Wrong:H6:1' AS HandlerId;\n\n                  DECLARE CONTINUE HANDLER FOR SQLWARNING\n                    SELECT 'Wrong:H6:2' AS HandlerId;\n\n                  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION\n                  BEGIN\n                    SELECT 'H2' AS HandlerId;\n                    SIGNAL SQLSTATE '01000'; # Should be handled by H1.\n                  END;\n\n                  SELECT 'S6' AS SignalId;\n                  SIGNAL SQLSTATE 'HY000';\n                END;\n\n                SELECT 'S5' AS SignalId;\n                SIGNAL SQLSTATE 'HY000';\n\n              END;\n\n              SELECT 'S4' AS SignalId;\n              SIGNAL SQLSTATE 'HY000';\n\n            END;\n\n            SELECT 'S3' AS SignalId;\n            SIGNAL SQLSTATE 'HY000';\n\n          END;\n\n          SELECT 'S2' AS SignalId;\n          SIGNAL SQLSTATE 'HY000';\n\n        END;\n\n        SELECT 'S1' AS SignalId;\n        SIGNAL SQLSTATE 'HY000'; # Should be handled by H2.\n\n      END;\n    END;\n  END;\nEND|\n\n--echo\nCALL p10()|\n\n--echo\n--echo # -- Test stored procedure from Peter's mail.\n--echo\n\nCREATE PROCEDURE p11()\nBEGIN\n  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION\n    SELECT 'H1' AS HandlerId;\n\n  DECLARE CONTINUE HANDLER FOR SQLWARNING\n    SELECT 'H2' AS HandlerId;\n\n  BEGIN\n    DECLARE CONTINUE HANDLER FOR SQLSTATE '01000', 1249\n    BEGIN\n      DECLARE CONTINUE HANDLER FOR SQLEXCEPTION\n        SELECT 'H3' AS HandlerId;\n\n      DECLARE CONTINUE HANDLER FOR SQLWARNING\n        SELECT 'H4' AS HandlerId;\n\n      BEGIN\n        SELECT 'H5' AS HandlerId;\n\n        SELECT 'S3' AS SignalId;\n        SIGNAL SQLSTATE 'HY000'; # H3\n\n        SELECT 'S4' AS SignalId;\n        SIGNAL SQLSTATE '22003'; # H3\n\n        SELECT 'S5' AS SignalId;\n        SIGNAL SQLSTATE '01000' SET MYSQL_ERRNO = 1249; # H4\n      END;\n    END;\n\n    SELECT 'S6' AS SignalId;\n    SIGNAL SQLSTATE 'HY000'; # H1\n\n    SELECT 'S7' AS SignalId;\n    SIGNAL SQLSTATE '22003'; # H1\n\n    SELECT 'S8' AS SignalId;\n    SIGNAL SQLSTATE '01000' SET MYSQL_ERRNO = 1249; # H5\n  END;\n\n  SELECT 'S1' AS SignalId;\n  SIGNAL SQLSTATE 'HY000'; # H1\n\n  SELECT 'S2' AS SignalId;\n  SIGNAL SQLSTATE '01000' SET MYSQL_ERRNO = 1249; # H2\nEND|\n\n--echo\nCALL p11()|\n\n--echo\n--echo # -- Check that runtime stack-trace can be deeper than parsing-time one.\n--echo\n\nCREATE PROCEDURE p12()\nBEGIN\n  DECLARE CONTINUE HANDLER FOR SQLSTATE '01001'\n  BEGIN\n    DECLARE CONTINUE HANDLER FOR SQLSTATE '01001'\n    BEGIN\n      DECLARE CONTINUE HANDLER FOR SQLSTATE '01001'\n      BEGIN\n        DECLARE CONTINUE HANDLER FOR SQLSTATE '01001'\n        BEGIN\n          DECLARE CONTINUE HANDLER FOR SQLSTATE '01001'\n          BEGIN\n            SELECT 'H1:5' AS HandlerId;\n            SIGNAL SQLSTATE '01002';\n          END;\n          SELECT 'H1:4' AS HandlerId;\n          SIGNAL SQLSTATE '01001';\n        END;\n        SELECT 'H1:3' AS HandlerId;\n        SIGNAL SQLSTATE '01001';\n      END;\n      SELECT 'H1:2' AS HandlerId;\n      SIGNAL SQLSTATE '01001';\n    END;\n    SELECT 'H1:1' AS HandlerId;\n    SIGNAL SQLSTATE '01001';\n  END;\n\n  #########################################################\n\n  DECLARE CONTINUE HANDLER FOR SQLSTATE '01002'\n    SELECT 'OK' AS Msg;\n\n  #########################################################\n\n  BEGIN\n\n    DECLARE CONTINUE HANDLER FOR SQLWARNING\n    BEGIN\n      DECLARE CONTINUE HANDLER FOR SQLWARNING\n      BEGIN\n        DECLARE CONTINUE HANDLER FOR SQLWARNING\n        BEGIN\n          DECLARE CONTINUE HANDLER FOR SQLWARNING\n          BEGIN\n            DECLARE CONTINUE HANDLER FOR SQLWARNING\n            BEGIN\n              SELECT 'H2:5' AS HandlerId;\n              SIGNAL SQLSTATE '01001';\n            END;\n            SELECT 'H2:4' AS HandlerId;\n            SIGNAL SQLSTATE '01000';\n          END;\n          SELECT 'H2:3' AS HandlerId;\n          SIGNAL SQLSTATE '01000';\n        END;\n        SELECT 'H2:2' AS HandlerId;\n        SIGNAL SQLSTATE '01000';\n      END;\n      SELECT 'H2:1' AS HandlerId;\n      SIGNAL SQLSTATE '01000';\n    END;\n\n    #######################################################\n\n    SELECT 'Throw 01000' AS Msg;\n    SIGNAL SQLSTATE '01000';\n  END;\n\nEND|\n\n--echo\nCALL p12()|\n\n--echo\n--echo # -- Check that handler-call-frames are removed properly for EXIT\n--echo # -- handlers.\n--echo\n\nCREATE PROCEDURE p13()\nBEGIN\n  \n  DECLARE CONTINUE HANDLER FOR SQLWARNING\n  BEGIN\n    DECLARE CONTINUE HANDLER FOR SQLWARNING\n    BEGIN\n      DECLARE EXIT HANDLER FOR SQLWARNING\n      BEGIN\n        SELECT 'EXIT handler 3' AS Msg;\n      END;\n\n      SELECT 'CONTINUE handler 2: 1' AS Msg;\n      SIGNAL SQLSTATE '01000';\n      SELECT 'CONTINUE handler 2: 2' AS Msg;\n    END;\n\n    SELECT 'CONTINUE handler 1: 1' AS Msg;\n    SIGNAL SQLSTATE '01000';\n    SELECT 'CONTINUE handler 1: 2' AS Msg;\n  END;\n\n  SELECT 'Throw 01000' AS Msg;\n  SIGNAL SQLSTATE '01000';\nEND|\n\n--echo\nCALL p13()|\n\ndelimiter ;|\n\n--echo\n--echo # That's it. Cleanup.\n--echo\n\nDROP PROCEDURE p1;\nDROP PROCEDURE p2;\nDROP PROCEDURE p3;\nDROP PROCEDURE p4;\nDROP PROCEDURE p5;\nDROP PROCEDURE p6;\nDROP PROCEDURE p7;\nDROP PROCEDURE p8;\nDROP PROCEDURE p9;\nDROP PROCEDURE p10;\nDROP PROCEDURE p11;\nDROP PROCEDURE p12;\nDROP PROCEDURE p13;\n\n--echo\n--echo # Bug#12731619: NESTED SP HANDLERS CAN TRIGGER ASSERTION\n--echo\nSET sql_mode = 'NO_ENGINE_SUBSTITUTION';\n--disable_warnings\nDROP FUNCTION IF EXISTS f1;\nDROP TABLE IF EXISTS t1;\n--enable_warnings\n\nCREATE TABLE t1(msg VARCHAR(255));\n\ndelimiter |;\nCREATE FUNCTION f1() RETURNS INT\nBEGIN\n\n  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION               # handler 1\n  BEGIN\n    DECLARE CONTINUE HANDLER FOR SQLEXCEPTION             # handler 2\n    BEGIN\n      INSERT INTO t1 VALUE('WRONG: Inside H2');\n      RETURN 2;\n    END;\n\n    INSERT INTO t1 VALUE('CORRECT: Inside H1');\n    RETURN 1;\n  END;\n\n  BEGIN\n    DECLARE CONTINUE HANDLER FOR SQLWARNING               # handler 3\n    BEGIN\n      INSERT INTO t1 VALUE('WRONG: Inside H3');\n      RETURN 3;\n    END;\n\n    INSERT INTO t1 VALUE('CORRECT: Calling f1()');\n    RETURN f1(); # -- exception here\n  END;\n\n  INSERT INTO t1 VALUE('WRONG: Returning 10');\n  RETURN 10;\n\nEND|\n\ndelimiter ;|\n\n--echo\nSELECT f1();\n--echo\nSELECT * FROM t1;\n--echo\n\nDROP FUNCTION f1;\nDROP TABLE t1;\n\n\n--echo\n--echo # Check that handled SQL-conditions are properly cleared from DA.\n--echo\n\n--disable_warnings\nDROP TABLE IF EXISTS t1;\nDROP TABLE IF EXISTS t2;\nDROP PROCEDURE IF EXISTS p1;\nDROP PROCEDURE IF EXISTS p2;\nDROP PROCEDURE IF EXISTS p3;\nDROP PROCEDURE IF EXISTS p4;\nDROP PROCEDURE IF EXISTS p5;\n--enable_warnings\n\nCREATE TABLE t1(a CHAR, b CHAR, c CHAR);\nCREATE TABLE t2(a SMALLINT, b SMALLINT, c SMALLINT);\n\ndelimiter |;\n\n--echo\n--echo # Check that SQL-conditions for which SQL-handler has been invoked,\n--echo # are cleared from the Diagnostics Area. Note, there might be several\n--echo # SQL-conditions, but SQL-handler must be invoked only once.\n--echo\n\nCREATE PROCEDURE p1()\nBEGIN\n  DECLARE EXIT HANDLER FOR SQLWARNING\n    SELECT 'Warning caught' AS msg;\n\n  # The INSERT below raises 3 SQL-conditions (warnings). The EXIT HANDLER\n  # above must be invoked once (for one condition), but all three conditions\n  # must be cleared from the Diagnostics Area.\n\n  INSERT INTO t1 VALUES('qqqq', 'ww', 'eee');\n\n  # The following INSERT will not be executed, because of the EXIT HANDLER.\n\n  INSERT INTO t1 VALUES('zzz', 'xx', 'yyyy');\nEND|\n\n--echo\nCALL p1()|\n--echo\nSELECT * FROM t1|\n\n--echo\n--echo # Check that SQL-conditions for which SQL-handler has *not* been\n--echo # invoked, are *still* cleared from the Diagnostics Area.\n--echo\n\nCREATE PROCEDURE p2()\nBEGIN\n  DECLARE CONTINUE HANDLER FOR 1292\n    SELECT 'Warning 1292 caught' AS msg;\n\n  # The following INSERT raises 6 SQL-warnings with code 1292,\n  # and 3 SQL-warnings with code 1264. The CONTINUE HANDLER above must be\n  # invoked once, and all nine SQL-warnings must be cleared from\n  # the Diagnostics Area.\n\n  INSERT INTO t2\n  SELECT\n    CAST(CONCAT(CAST('1 ' AS UNSIGNED INTEGER), '999999  ') AS SIGNED INTEGER),\n    CAST(CONCAT(CAST('2 ' AS UNSIGNED INTEGER), '999999  ') AS SIGNED INTEGER),\n    CAST(CONCAT(CAST('3 ' AS UNSIGNED INTEGER), '999999  ') AS SIGNED INTEGER);\nEND|\n\n--echo\nCALL p2()|\n\n--echo\n--echo # Check that if there are two equally ranked SQL-handlers to handle\n--echo # SQL-conditions from SQL-statement, only one of them will be invoked.\n--echo\n\nCREATE PROCEDURE p3()\nBEGIN\n  DECLARE CONTINUE HANDLER FOR 1292\n    SELECT 'Warning 1292 caught' AS msg;\n\n  DECLARE CONTINUE HANDLER FOR 1264\n    SELECT 'Warning 1264 caught' AS msg;\n\n  # The following INSERT raises 6 SQL-warnings with code 1292,\n  # and 3 SQL-warnings with code 1264. Only one of the CONTINUE HANDLERs above\n  # must be called, and only once. The SQL Standard does not define, which one\n  # should be invoked.\n\n  INSERT INTO t2\n  SELECT\n    CAST(CONCAT(CAST('1 ' AS UNSIGNED INTEGER), '999999  ') AS SIGNED INTEGER),\n    CAST(CONCAT(CAST('2 ' AS UNSIGNED INTEGER), '999999  ') AS SIGNED INTEGER),\n    CAST(CONCAT(CAST('3 ' AS UNSIGNED INTEGER), '999999  ') AS SIGNED INTEGER);\nEND|\n\n--echo\nCALL p3()|\n\n--echo\n--echo # The same as p3, but 1264 comes first.\n--echo\n\nCREATE PROCEDURE p4()\nBEGIN\n  DECLARE CONTINUE HANDLER FOR 1292\n    SELECT 'Warning 1292 caught' AS msg;\n\n  DECLARE CONTINUE HANDLER FOR 1264\n    SELECT 'Warning 1264 caught' AS msg;\n\n  # The following INSERT raises 4 SQL-warnings with code 1292,\n  # and 3 SQL-warnings with code 1264. Only one of the CONTINUE HANDLERs above\n  # must be called, and only once. The SQL Standard does not define, which one\n  # should be invoked.\n\n  INSERT INTO t2\n  SELECT\n    CAST(999999 AS SIGNED INTEGER),\n    CAST(CONCAT(CAST('2 ' AS UNSIGNED INTEGER), '999999  ') AS SIGNED INTEGER),\n    CAST(CONCAT(CAST('3 ' AS UNSIGNED INTEGER), '999999  ') AS SIGNED INTEGER);\nEND|\n\n--echo\nCALL p4()|\n\n--echo\n--echo # Check that if a SQL-handler raised its own SQL-conditions, there are\n--echo # preserved after handler exit.\n--echo\n\nCREATE PROCEDURE p5()\nBEGIN\n  DECLARE EXIT HANDLER FOR 1292\n  BEGIN\n    SELECT 'Handler for 1292' AS Msg;\n    SIGNAL SQLSTATE '01000' SET MYSQL_ERRNO = 1234;\n    SHOW WARNINGS;\n  END;\n\n  INSERT INTO t2\n  SELECT\n    CAST(999999 AS SIGNED INTEGER),\n    CAST(CONCAT(CAST('2 ' AS UNSIGNED INTEGER), '999999  ') AS SIGNED INTEGER),\n    CAST(CONCAT(CAST('3 ' AS UNSIGNED INTEGER), '999999  ') AS SIGNED INTEGER);\nEND|\n\n--echo\nCALL p5()|\n\n--echo\n--echo # Check that SQL-conditions are available inside the handler, but\n--echo # cleared after the handler exits.\n--echo\n\nCREATE PROCEDURE p6()\nBEGIN\n  DECLARE CONTINUE HANDLER FOR 1292\n  BEGIN\n    SHOW WARNINGS;\n    SELECT 'Handler for 1292' Msg;\n  END;\n\n  INSERT INTO t2\n  SELECT\n    CAST(CONCAT(CAST('1 ' AS UNSIGNED INTEGER), '999999  ') AS SIGNED INTEGER),\n    CAST(CONCAT(CAST('2 ' AS UNSIGNED INTEGER), '999999  ') AS SIGNED INTEGER),\n    CAST(CONCAT(CAST('3 ' AS UNSIGNED INTEGER), '999999  ') AS SIGNED INTEGER);\nEND|\n\n--echo\nCALL p6()|\n\ndelimiter ;|\n\n--echo\nDROP PROCEDURE p1;\nDROP PROCEDURE p2;\nDROP PROCEDURE p3;\nDROP PROCEDURE p4;\nDROP PROCEDURE p5;\nDROP PROCEDURE p6;\nDROP TABLE t1;\nDROP TABLE t2;\nSET sql_mode = default;\n--echo\n--echo # Bug#13059316: ASSERTION FAILURE IN SP_RCONTEXT.CC \n--echo # Check DECLARE statements that raise conditions before handlers\n--echo # are declared.\n--echo\nSET sql_mode = 'NO_ENGINE_SUBSTITUTION';\n--disable_warnings\nDROP PROCEDURE IF EXISTS p1;\nDROP PROCEDURE IF EXISTS p2;\n--enable_warnings\n\ndelimiter |;\n\nCREATE PROCEDURE p1()\nBEGIN\n  DECLARE var1 INTEGER DEFAULT 'string';\n  DECLARE EXIT HANDLER FOR SQLWARNING SELECT 'H1';\nEND|\n\n--echo\nCALL p1()|\n--echo\n\nCREATE PROCEDURE p2()\nBEGIN\n  DECLARE EXIT HANDLER FOR SQLWARNING SELECT 'H2';\n  CALL p1();\nEND|\n\n--echo\nCALL p2()|\n\ndelimiter ;|\n\n--echo\nDROP PROCEDURE p1;\nDROP PROCEDURE p2;\nSET sql_mode = default;\n\n--echo #\n--echo # Bug#13113222 RQG_SIGNAL_RESIGNAL FAILED WITH ASSERTION.\n--echo #\n\n--disable_warnings\nDROP PROCEDURE IF EXISTS p1;\nDROP PROCEDURE IF EXISTS p2;\n--enable_warnings\n\ndelimiter |;\nCREATE PROCEDURE p1()\nBEGIN\n  DECLARE CONTINUE HANDLER FOR SQLEXCEPTION SELECT 'triggered p1';\n  # This will trigger an error.\n  SIGNAL SQLSTATE 'HY000';\nEND|\n\nCREATE PROCEDURE p2()\nBEGIN\n  DECLARE CONTINUE HANDLER FOR SQLWARNING SELECT 'triggered p2';\n  # This will trigger a warning.\n  SIGNAL SQLSTATE '01000';\nEND|\ndelimiter ;|\n\nSET @old_max_error_count=  @@session.max_error_count;\nSET SESSION max_error_count= 0;\nCALL p1();\nCALL p2();\nSET SESSION max_error_count= @old_max_error_count;\n\nDROP PROCEDURE p1;\nDROP PROCEDURE p2;\n\n--echo\n--echo # Bug#12652873: 61392: Continue handler for NOT FOUND being triggered\n--echo # from internal stored function.\n--echo\n\n--disable_warnings\nDROP FUNCTION IF EXISTS f1;\nDROP FUNCTION IF EXISTS f2;\nDROP TABLE IF EXISTS t1;\n--enable_warnings\n\n--echo\n\nCREATE TABLE t1 (a INT, b INT);\nINSERT INTO t1 VALUES (1, 2);\n\ndelimiter |;\n\n--echo\n--echo # f1() raises NOT_FOUND condition.\n--echo # Raising NOT_FOUND can not be simulated by SIGNAL,\n--echo # because SIGNAL would raise SQL-error in that case.\n--echo\n\nCREATE FUNCTION f1() RETURNS INTEGER\nBEGIN\n  DECLARE v VARCHAR(5) DEFAULT -1;\n  SELECT b FROM t1 WHERE a = 2 INTO v;\n  RETURN v;\nEND|\n\n--echo\n--echo # Here we check that the NOT_FOUND condition raised in f1()\n--echo # is not visible in the outer function (f2), i.e. the continue\n--echo # handler in f2() will not be called.\n--echo\n\nCREATE FUNCTION f2() RETURNS INTEGER\nBEGIN\n  DECLARE v INTEGER;\n\n  DECLARE CONTINUE HANDLER FOR NOT FOUND\n    SET @msg = 'Handler activated.';\n\n  SELECT f1() INTO v;\n\n  RETURN v;\nEND|\n\ndelimiter ;|\n\nSET @msg = '';\n\n--echo\nSELECT f2();\n--echo\nSELECT @msg;\n--echo\n\nDROP FUNCTION f1;\nDROP FUNCTION f2;\nDROP TABLE t1;\n\n\n--echo #\n--echo # Bug #17903490 \"ASSERT FAILURE IN MDL.H WHEN DROP FUNCTION CALLED\n--echo #                WITH INVALID FUNCTION NAME\".\n--echo #\n--error ER_TOO_LONG_IDENT\ndrop function f111111111122222222223333333333444444444455555555556666666666777777777788888888889999999999aaaaaaaaaabbbbbbbbbbccccccccccddddddddddeeeeeeeeeeffffffffffgggggggggghhhhhhhhhhiiiiiiiiiijjjjjjjjjjkk;\n--error ER_TOO_LONG_IDENT\ndrop function test.f111111111122222222223333333333444444444455555555556666666666777777777788888888889999999999aaaaaaaaaabbbbbbbbbbccccccccccddddddddddeeeeeeeeeeffffffffffgggggggggghhhhhhhhhhiiiiiiiiiijjjjjjjjjjkk;\n--error ER_WRONG_DB_NAME \ndrop function mysqltest111111111122222222223333333333444444444455555555556666666666777777777788888888889999999999aaaaaaaaaabbbbbbbbbbccccccccccddddddddddeeeeeeeeeeffffffffffgggggggggghhhhhhhhhhiiiiiiiiiijjjj.test;\n\n--echo #\n--echo # WL#7897 -- Use DD API for Stored Routines.\n--echo # Test cases to verify error scenarios.\n--echo #\n\n--disable_query_log\n\nSET @orig_character_set_client = @@character_set_client;\nSET character_set_client = utf8;\n\n--echo # Case 1. Test case to verify length of stored routine name length.\nlet $object_name_64= oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo;\nlet $object_name_65= ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo;\n--echo #         STORED PROCEDURE -- name with maximum length\neval CREATE PROCEDURE $object_name_64() SELECT 1 AS my_column;\neval ALTER PROCEDURE $object_name_64 COMMENT 'Changed';\neval CALL $object_name_64();\neval DROP PROCEDURE $object_name_64;\n--echo #         STORED PROCEDURE -- name with maximum length + 1 --> expect a fail\n--error ER_TOO_LONG_IDENT\neval CREATE PROCEDURE $object_name_65() SELECT 1 AS my_column;\n--error ER_TOO_LONG_IDENT\neval ALTER PROCEDURE $object_name_65 COMMENT 'Changed';\n--error ER_TOO_LONG_IDENT\neval CALL $object_name_65();\n--error ER_TOO_LONG_IDENT\neval DROP PROCEDURE $object_name_65;\n#\n--echo #         STORED FUNCTION -- name with maximum length\neval CREATE FUNCTION $object_name_64() RETURNS INT RETURN 1;\neval ALTER FUNCTION $object_name_64 COMMENT 'Changed';\neval SELECT $object_name_64() AS my_column;\neval DROP FUNCTION $object_name_64;\n--echo #         STORED FUNCTION -- name with maximum length + 1 --> expect a fail\n--error ER_TOO_LONG_IDENT\neval CREATE FUNCTION $object_name_65() RETURNS INT RETURN 1;\n--error ER_TOO_LONG_IDENT\neval ALTER FUNCTION $object_name_65 COMMENT 'Changed';\n--error ER_TOO_LONG_IDENT\neval SELECT $object_name_65() AS my_column;\n--error ER_TOO_LONG_IDENT\neval DROP FUNCTION $object_name_65;\n\n--echo # Case 2: Test case to validate stored routine name.\n--error ER_INVALID_CHARACTER_STRING\nCREATE PROCEDURE test\ud834\udf06() SELECT 1;\n--error ER_INVALID_CHARACTER_STRING\nCREATE FUNCTION test\ud834\udf06() RETURNS INT RETURN 1;\n\n--echo # Case 3: Test case to verify routine's parameter length.\neval CREATE PROCEDURE p(IN $object_name_64 INT) SELECT 1 AS my_column;\nDROP PROCEDURE p;\n--error ER_TOO_LONG_IDENT\neval CREATE PROCEDURE p(IN $object_name_65 INT) SELECT 1 AS my_column;\n#\neval CREATE FUNCTION f($object_name_64 INT) RETURNS INT RETURN 1;\nDROP FUNCTION f;\n--error ER_TOO_LONG_IDENT\neval CREATE FUNCTION f($object_name_65 INT) RETURNS INT RETURN 1;\n\n--echo # Case 4: Test case to validate routine's parameter name.\n--error ER_INVALID_CHARACTER_STRING\nCREATE PROCEDURE p(IN test\ud834\udf06 INT) SELECT 1;\n--error ER_INVALID_CHARACTER_STRING\nCREATE FUNCTION f(test\ud834\udf06 INT) RETURNS INT RETURN 1;\n\n--echo # Case 5: Test case to verify comment string length.\nlet $string_65535= `SELECT REPEAT('n', 65535)`;\nlet $string_65536= `SELECT REPEAT('n', 65536)`;\neval CREATE PROCEDURE p1() COMMENT '$string_65535' SELECT 1;\nDROP PROCEDURE p1;\n--error ER_TOO_LONG_ROUTINE_COMMENT\neval CREATE PROCEDURE p1() COMMENT '$string_65536' SELECT 1;\n#\neval CREATE FUNCTION f1() RETURNS INT COMMENT '$string_65535' RETURN 1;\nDROP FUNCTION f1;\n--error ER_TOO_LONG_ROUTINE_COMMENT\neval CREATE FUNCTION f1() RETURNS INT COMMENT '$string_65536' RETURN 1;\n\nCREATE PROCEDURE p1() SELECT 1;\neval ALTER PROCEDURE p1 COMMENT '$string_65535';\n--error ER_TOO_LONG_ROUTINE_COMMENT\neval ALTER PROCEDURE p1 COMMENT '$string_65536';\nDROP PROCEDURE p1;\n#\nCREATE FUNCTION f1() RETURNS INT RETURN 1;\neval ALTER FUNCTION f1 COMMENT '$string_65535';\n--error ER_TOO_LONG_ROUTINE_COMMENT\neval ALTER FUNCTION f1 COMMENT '$string_65536';\nDROP FUNCTION f1;\n\n--echo # Case 6: Test case to validate comment string.\n--error ER_INVALID_CHARACTER_STRING\nCREATE PROCEDURE p2() COMMENT 'test\ud834\udf06' SELECT 1;\n#\n--error ER_INVALID_CHARACTER_STRING\nCREATE FUNCTION f2() RETURNS INT COMMENT 'test\ud834\udf06' RETURN 1;\n\n\nCREATE PROCEDURE p2() SELECT 1;\n--error ER_INVALID_CHARACTER_STRING\nALTER PROCEDURE p2 COMMENT 'test\ud834\udf06';\nDROP PROCEDURE p2;\n#\nCREATE FUNCTION f2() RETURNS INT RETURN 1;\n--error ER_INVALID_CHARACTER_STRING\nALTER FUNCTION f2 COMMENT 'test\ud834\udf06';\nDROP FUNCTION f2;\n\n--echo # Cleanup\nSET character_set_client = @orig_character_set_client;\n\n--enable_query_log\n\n--echo #\n--echo # Bug #24357244: CANNOT CREATE A STORED FUNCTION IF A DATABASE IS NOT\n--echo #                SELECTED\n--echo #\n\nCREATE DATABASE mysqltest;\nUSE mysqltest;\nDROP DATABASE mysqltest;\n\n# Should return NULL\nSELECT DATABASE();\n\nCREATE DATABASE mysqltest;\nCREATE FUNCTION mysqltest.f1() RETURNS INT RETURN 0;\nCREATE FUNCTION mysqltest.f2() RETURNS INT RETURN f1();\n\nUSE mysqltest;\nSELECT f1();\nSELECT f2();\n\nDROP FUNCTION IF EXISTS f2;\nDROP FUNCTION IF EXISTS f1;\nDROP DATABASE mysqltest;\n",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/components/libminchassis/dynamic_loader_scheme_file_imp.h": "/* Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.\n\nThis program is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License, version 2.0,\nas published by the Free Software Foundation.\n\nThis program is also distributed with certain software (including\nbut not limited to OpenSSL) that is licensed under separate terms,\nas designated in a particular file or component or in included license\ndocumentation.  The authors of MySQL hereby grant you an additional\npermission to link the program and your derivative works with the\nseparately licensed software that they have included with MySQL.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License, version 2.0, for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA */\n\n#ifndef MYSQL_SERVER_DYNAMIC_LOADER_SCHEMA_FILE_H\n#define MYSQL_SERVER_DYNAMIC_LOADER_SCHEMA_FILE_H\n\n#include <mysql/components/component_implementation.h>\n#include <mysql/components/service_implementation.h>\n#include <mysql/components/services/dynamic_loader.h>\n#include <mysql/components/services/dynamic_loader_scheme_file.h>\n#include <mysql/components/services/mysql_rwlock_service.h>\n#include <map>\n#include <unordered_set>\n\n#if defined(_WIN32)\n#define dlsym(lib, name) (void *)GetProcAddress((HMODULE)lib, name)\n#define dlopen(libname, unused) LoadLibraryEx(libname, NULL, 0)\n#define dlclose(lib) FreeLibrary((HMODULE)lib)\n#define RTLD_NOW 0x00002\n#define DLERROR_GENERATE(errmsg, error_number)                          \\\n  char win_errormsg[2048];                                              \\\n  if (FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, 0, error_number, 0,     \\\n                    win_errormsg, 2048, NULL)) {                        \\\n    char *ptr;                                                          \\\n    for (ptr = &win_errormsg[0] + strlen(win_errormsg) - 1;             \\\n         ptr >= &win_errormsg[0] && strchr(\"\\r\\n\\t\\0x20\", *ptr); ptr--) \\\n      *ptr = 0;                                                         \\\n    errmsg = win_errormsg;                                              \\\n  } else                                                                \\\n    errmsg = \"\"\n#define dlerror() \"\"\n#define dlopen_errno GetLastError()\n\n#else /* _WIN32 */\n\n#ifndef MYSQL_ABI_CHECK\n#include <dlfcn.h>\n#include <errno.h>\n#endif\n\n#define DLERROR_GENERATE(errmsg, error_number) errmsg = dlerror()\n#define dlopen_errno errno\n#endif\n\nclass mysql_dynamic_loader_scheme_file_imp {\n  typedef std::map<std::string, void *> my_registry;\n  typedef mysql_component_t *(*list_components_func)();\n\n  static my_registry object_files_list;\n  static std::unordered_set<list_components_func> library_entry_set;\n  static mysql_rwlock_t LOCK_dynamic_loader_scheme_file;\n\n public:\n  /**\n    Initializes file:// scheme for dynamic loader for usage. Initializes\n    RW lock, all other structures should be empty. Shouldn't be called multiple\n    times.\n  */\n  static void init();\n  /**\n    De-initializes RW lock, all other structures doesn't require any action.\n  */\n  static void deinit();\n\n public:\n  /**\n    Loads components that are located in executable file specified by URN.\n    We assume that URN starts with file://, but accept any. Will not success\n    when called multiple times on the same file.\n\n    @param urn URN to file to load components from.\n    @param [out] out_data Pointer to pointer to MySQL component data structures\n      to set result components data retrieved from specified file.\n    @return Status of performed operation\n    @retval false success\n    @retval true Failure, may be caused when name does not contain ://, cannot\n      be located, is not proper executable file or does not contain proper\n      initialization function.\n  */\n  static DEFINE_BOOL_METHOD(load,\n                            (const char *urn, mysql_component_t **out_data));\n\n  /**\n    Unloads file that was previously loaded. The URN string must be exactly\n    the same as one used during call to load. Although you can call load() on\n    specified URN multiple times, subsequent calls unload() will always fail,\n    and all components from specified file will be invalid after first call to\n    unload().\n\n    @param urn URN to file to unload all components from.\n    @return Status of performed operation\n    @retval false success\n    @retval true failure\n  */\n  static DEFINE_BOOL_METHOD(unload, (const char *urn));\n};\n\n#endif /* MYSQL_SERVER_DYNAMIC_LOADER_SCHEMA_FILE_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/components/libminchassis/dynamic_loader_scheme_file.cc": "/* Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.\n\nThis program is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License, version 2.0,\nas published by the Free Software Foundation.\n\nThis program is also distributed with certain software (including\nbut not limited to OpenSSL) that is licensed under separate terms,\nas designated in a particular file or component or in included license\ndocumentation.  The authors of MySQL hereby grant you an additional\npermission to link the program and your derivative works with the\nseparately licensed software that they have included with MySQL.\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License, version 2.0, for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA */\n\n#include <mysql/components/component_implementation.h>\n#include <mysql/components/service_implementation.h>\n#include <mysql/components/services/dynamic_loader.h>\n#include <mysql/components/services/dynamic_loader_scheme_file.h>\n#include <mysql/components/services/mysql_psi_system.h>\n#include <mysql/components/services/mysql_runtime_error_service.h>\n#include <mysql/components/services/mysql_rwlock.h>\n#include <mysqld_error.h>\n\n#ifndef _WIN32\n#include <dlfcn.h>\n#endif\n#include <string.h>\n#include <map>\n#include <string>\n#include <unordered_set>\n\n#include \"component_common.h\"\n#include \"dynamic_loader_scheme_file_imp.h\"\n#include \"rwlock_scoped_lock.h\"  // rwlock_scoped_lock\n#include \"scope_guard.h\"         // create_scope_guard\n\nstatic PSI_rwlock_key key_rwlock_LOCK_dynamic_loader_scheme_file;\n\nstatic PSI_rwlock_info all_dynamic_loader_scheme_file_rwlocks[] = {\n    {&key_rwlock_LOCK_dynamic_loader_scheme_file,\n     \"LOCK_dynamic_loader_scheme_file\", PSI_FLAG_SINGLETON, 0,\n     PSI_DOCUMENT_ME}};\n\nstatic void init_dynamic_loader_scheme_file_psi_keys(void) {\n  const char *category = \"components\";\n  int count;\n\n  count =\n      static_cast<int>(array_elements(all_dynamic_loader_scheme_file_rwlocks));\n  mysql_rwlock_register(category, all_dynamic_loader_scheme_file_rwlocks,\n                        count);\n}\n\n/**\n  Initializes file:// scheme for dynamic loader for usage. Initializes\n  RW lock, all other structures should be empty. Shouldn't be called multiple\n  times.\n*/\nvoid mysql_dynamic_loader_scheme_file_imp::init() {\n  init_dynamic_loader_scheme_file_psi_keys();\n  mysql_rwlock_init(\n      key_rwlock_LOCK_dynamic_loader_scheme_file,\n      &mysql_dynamic_loader_scheme_file_imp::LOCK_dynamic_loader_scheme_file);\n}\n/**\n  De-initializes RW lock, all other structures doesn't require any action.\n*/\nvoid mysql_dynamic_loader_scheme_file_imp::deinit() {\n  mysql_rwlock_destroy(\n      &mysql_dynamic_loader_scheme_file_imp::LOCK_dynamic_loader_scheme_file);\n}\n\n/**\n  Loads components that are located in executable file specified by URN.\n  We assume that URN starts with file://, but accept any. Will not success\n  when called multiple times on the same file.\n\n  @param urn URN to file to load components from.\n  @param [out] out_data Pointer to pointer to MySQL component data structures\n    to set result components data retrieved from specified file.\n  @return Status of performed operation\n  @retval false success\n  @retval true Failure, may be caused when name does not contain ://, cannot\n    be located, is not proper executable file or does not contain proper\n    initialization function.\n*/\nDEFINE_BOOL_METHOD(mysql_dynamic_loader_scheme_file_imp::load,\n                   (const char *urn, mysql_component_t **out_data)) {\n  try {\n    if (urn == nullptr) {\n      return true;\n    }\n\n    std::string urn_string = urn;\n\n    /* Check if library is not already loaded, by comparing URNs. */\n    minimal_chassis::rwlock_scoped_lock lock(\n        &mysql_dynamic_loader_scheme_file_imp::LOCK_dynamic_loader_scheme_file,\n        true, __FILE__, __LINE__);\n\n    if (object_files_list.find(urn_string) != object_files_list.end()) {\n      return true;\n    }\n\n    /* Omit scheme prefix to get filename. */\n    const char *file = strstr(urn, \"://\");\n    if (file == nullptr) {\n      return true;\n    }\n    /* Offset by \"://\" */\n    file += 3;\n    std::string file_name = std::string(file);\n#ifdef _WIN32\n    file_name += \".dll\";\n#else\n    file_name += \".so\";\n#endif\n\n    /* Open library. */\n    void *handle = dlopen(file_name.c_str(), RTLD_NOW);\n    if (handle == NULL) {\n      const char *errmsg;\n      int error_number = dlopen_errno;\n      DLERROR_GENERATE(errmsg, error_number);\n      mysql_error_service_printf(ER_CANT_OPEN_LIBRARY, MYF(0),\n                                 file_name.c_str(), error_number, errmsg);\n      return true;\n    }\n    auto guard_library = create_scope_guard([&handle]() {\n      /* In case we need to rollback we close the opened library. */\n      dlclose(handle);\n    });\n\n    /* Look for \"list_components\" function. */\n    list_components_func list_func = reinterpret_cast<list_components_func>(\n        dlsym(handle, COMPONENT_ENTRY_FUNC));\n    if (list_func == NULL) {\n      return true;\n    }\n\n    /* Check if library is not already loaded, by comparing \"list_components\"\n      function address. */\n    if (library_entry_set.insert(list_func).second == false) {\n      return true;\n    }\n\n    auto guard_library_set = create_scope_guard([&list_func]() {\n      /* In case we need to rollback we remove library handle from set. */\n      library_entry_set.erase(list_func);\n    });\n\n    /* Get components data from library.\n       It is ok for not copying the data even the mutex is released at the\n       function exit, since it is used under the registry\n       services (as they take another mutex) */\n    *out_data = list_func();\n\n    /* Add library and it's handle to list of loaded libraries. */\n\n    if (object_files_list.emplace(urn_string, handle).second == false) {\n      return true;\n    }\n\n    guard_library.commit();\n    guard_library_set.commit();\n\n    return false;\n  } catch (...) {\n  }\n  return true;\n}\n\n/**\n  Unloads file that was previously loaded. The URN string must be exactly\n  the same as one used during call to load. Although you can call load() on\n  specified URN multiple times, subsequent calls unload() will always fail,\n  and all components from specified file will be invalid after first call to\n  unload().\n\n  @param urn URN to file to unload all components from.\n  @return Status of performed operation\n  @retval false success\n  @retval true failure\n*/\nDEFINE_BOOL_METHOD(mysql_dynamic_loader_scheme_file_imp::unload,\n                   (const char *urn)) {\n  try {\n    /* Find library matching URN specified. */\n    minimal_chassis::rwlock_scoped_lock lock(\n        &mysql_dynamic_loader_scheme_file_imp::LOCK_dynamic_loader_scheme_file,\n        true, __FILE__, __LINE__);\n\n    /* This will happen when load() is not called for a component */\n    if (object_files_list.size() == 0) return false;\n\n    my_registry::iterator it = object_files_list.find(std::string(urn));\n    if (it == object_files_list.end()) {\n      return true;\n    }\n\n    /* Delete entry from library entry points list. */\n    list_components_func list_func = reinterpret_cast<list_components_func>(\n        dlsym(it->second, \"list_components\"));\n    library_entry_set.erase(list_func);\n\n    /* Calling psi system unload plugin event */\n    mysql_unload_plugin(it->first.c_str());\n\n    /* Close library and delete entry from libraries list. */\n    dlclose(it->second);\n    object_files_list.erase(it);\n    return false;\n  } catch (...) {\n  }\n  return true;\n}\n\n/* static members for mysql_dynamic_loader_scheme_file_imp */\nmysql_dynamic_loader_scheme_file_imp::my_registry\n    mysql_dynamic_loader_scheme_file_imp::object_files_list;\nstd::unordered_set<mysql_dynamic_loader_scheme_file_imp::list_components_func>\n    mysql_dynamic_loader_scheme_file_imp::library_entry_set;\nmysql_rwlock_t\n    mysql_dynamic_loader_scheme_file_imp::LOCK_dynamic_loader_scheme_file;\n",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/sql/mysqld.cc": "/* Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License, version 2.0,\n   as published by the Free Software Foundation.\n\n   This program is also distributed with certain software (including\n   but not limited to OpenSSL) that is licensed under separate terms,\n   as designated in a particular file or component or in included license\n   documentation.  The authors of MySQL hereby grant you an additional\n   permission to link the program and your derivative works with the\n   separately licensed software that they have included with MySQL.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License, version 2.0, for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA */\n\n/**\n  @file sql/mysqld.cc\n  MySQL server daemon.\n*/\n\n/* clang-format off */\n/**\n  @mainpage Welcome\n\n  Welcome to the MySQL source code documentation.\n\n  This documentation covers primarily the MySQL server,\n  for the @c mysqld process.\n\n  Other programs, like the MySQL Router, are also documented,\n  see the @ref PAGE_SERVER_TOOLS section.\n\n  The order chosen to present the content is to start with low level components,\n  and build upon previous sections, so that code is presented in a logical order.\n\n  For some sections, a full article (Doxygen 'page') presents the component in detail.\n\n  For other sections, only links are provided, as a starting point into the component.\n\n  For the user manual, see http://dev.mysql.com/doc/refman/8.0/en/\n\n  For the internals manual, see https://dev.mysql.com/doc/internals/en/index.html\n\n  This documentation is published for each release, starting with MySQL 8.0.\n\n  The present document corresponds to:\n\n  Document generated on: ${DOXYGEN_GENERATION_DATE},\n  branch: ${DOXYGEN_GENERATION_BRANCH},\n  revision: ${DOXYGEN_GENERATION_REVISION}\n\n  For the latest available version, see https://dev.mysql.com/doc/dev/mysql-server/latest/\n\n  For other versions, see https://dev.mysql.com/doc/index-archive.html\n*/\n\n/**\n  @page PAGE_GET_STARTED Getting Started\n\n  - @ref start_source\n  - @subpage PAGE_CODING_GUIDELINES\n  - @ref start_debug\n\n  @section start_source Build from source\n\n  See https://dev.mysql.com/doc/refman/8.0/en/source-installation.html\n\n  @section start_debug Debugging\n\n  The easiest way to install a server, and attach a debugger to it,\n  is to start the mysql-test-run (MTR) tool with debugging options\n\n  @verbatim\n  cd mysql-test\n  ./mtr --ddd main.parser\n  @endverbatim\n\n  The following functions are good candidates for breakpoints:\n  - #my_message_sql\n  - #dispatch_command\n\n  Replace 'main.parser' with another test script, or write your own, to debug a specific area.\n*/\n\n/**\n  @page PAGE_CODING_GUIDELINES Coding Guidelines\n\n  This section shows the guidelines that MySQL developers\n  follow when writing new code.\n\n  New MySQL code uses the Google C++ coding style\n  (https://google.github.io/styleguide/cppguide.html), with one\n  exception:\n\n  - Member variable names: Do not use foo_. Instead, use\n    m_foo (non-static) or s_foo (static).\n\n  Old projects and modifications to old code use an older MySQL-specific\n  style for the time being. Since 8.0, MySQL style uses the same formatting\n  rules as Google coding style (e.g., brace placement, indentation, line\n  lengths, etc.), but differs in a few important aspects:\n\n  - Class names: Do not use MyClass. Instead, use My_class.\n\n  - Function names: Use snake_case().\n\n  - Comment Style: Use either the // or <em>/</em>* *<em>/</em> syntax. // is\n    much more common but both syntaxes are permitted for the time being.\n\n  - Doxygen comments: Use <em>/</em>** ... *<em>/</em> syntax and not ///.\n\n  - Doxygen commands: Use '@' and not '\\' for doxygen commands.\n\n  - You may see structs starting with st_ and being typedef-ed to some\n    UPPERCASE (e.g. typedef struct st_foo { ... } FOO). However,\n    this is legacy from when the codebase contained C. Do not make such new\n    typedefs nor structs with st_ prefixes, and feel free to remove those that\n    already exist, except in public header files that are part of libmysql\n    (which need to be parseable as C99).\n\n\n  Code formatting is enforced by use of clang-format throughout the code\n  base. However, note that formatting is only one part of coding style;\n  you are required to take care of non-formatting issues yourself, such as\n  following naming conventions, having clear ownership of code or minimizing\n  the use of macros. See the Google coding style guide for the entire list.\n\n  Consistent style is important for us, because everyone must know what to\n  expect. Knowing our rules, you'll find it easier to read our code, and when\n  you decide to contribute (which we hope you'll consider!) we'll find it\n  easier to read and review your code.\n\n  - @subpage GENERAL_DEVELOPMENT_GUIDELINES\n  - @subpage CPP_CODING_GUIDELINES_FOR_NDB_SE\n  - @subpage DBUG_TAGS\n\n*/\n\n/**\n  @page PAGE_INFRASTRUCTURE Infrastructure\n\n  @section infra_basic Basic classes and templates\n\n  @subsection infra_basic_container Container\n\n  See #DYNAMIC_ARRAY, #List, #I_P_List, #LF_HASH.\n\n  @subsection infra_basic_syncho Synchronization\n\n  See #native_mutex_t, #native_rw_lock_t, #native_cond_t.\n\n  @subsection infra_basic_fileio File IO\n\n  See #my_open, #my_dir.\n\n  @section infra_server_blocks Server building blocs\n\n  @subsection infra_server_blocks_vio Virtual Input Output\n\n  See #Vio, #vio_init.\n\n  @section deployment Deployment\n\n  @subsection deploy_install Installation\n\n  See #opt_initialize, #bootstrap::run_bootstrap_thread.\n\n  @subsection deploy_startup Startup\n\n  See #mysqld_main.\n\n  @subsection deploy_shutdown Shutdown\n\n  See #handle_fatal_signal, #signal_hand.\n\n  @subsection deploy_upgrade Upgrade\n\n  See #Mysql::Tools::Upgrade::Program.\n\n*/\n\n/**\n  @page PAGE_PROTOCOL Client/Server Protocol\n\n  @section protocol_overview Overview\n\n  The MySQL protocol is used between MySQL Clients and a MySQL Server.\n  It is implemented by:\n    - Connectors (Connector/C, Connector/J, and so forth)\n    - MySQL Proxy\n    - Communication between master and slave replication servers\n\n  The protocol supports these features:\n    - Transparent encryption using SSL\n    - Transparent compression\n    - A @ref page_protocol_connection_phase where capabilities and\n      authentication data are exchanged\n    - A @ref page_protocol_command_phase which accepts commands\n      from the client and executes them\n\n  Further reading:\n    - @subpage page_protocol_basics\n    - @subpage page_protocol_connection_lifecycle\n*/\n\n\n/** @page mysqlx_protocol X %Protocol\n\n@par Topics in this section:\n\n- @subpage mysqlx_protocol_lifecycle\n- @subpage mysqlx_protocol_authentication\n- @subpage mysqlx_protocol_messages\n- @subpage mysqlx_protocol_expectations\n- @subpage mysqlx_protocol_notices\n- @subpage mysqlx_protocol_xplugin\n- @subpage mysqlx_protocol_use_cases\n- @subpage mysqlx_protocol_implementation\n- @subpage mysqlx_protocol_comparison\n\n\nThe X %Protocol is implemented by the X Plugin and the following\nMySQL clients support the protocol:\n\n-  MYSQLXSHELL\n\n-  MySQL for Visual Studio 2.0.2 or higher\n\n-  MySQL Connector/J 6.0.2 or higher\n\n-  MySQL Connector/Net 7.0.2 or higher\n\n-  MySQL Connector/Node.js\n\n@section xprotocol_community_connector How to build a Community Connector\n\nMySQL provides a set of official MySQL Connectors for several popular\ndevelopment frameworks and languages like Node.js, .Net, Python, Java, C,\nC++ and more. At the same time, we also encourage community developers to\ncreate native connectors for their favorite languages. To improve the process\nand encourage creating a community connector going forward, and allow for more\nrapid new feature support within the MySQL communications protocol, we created\na new protocol called the MySQL X Protocol.\n\nThe new X Protocol leverages current industry standards. One of those standards\nin use is protobuf (more formally know as Google Protobuffers).\nThe .proto formatted files provide the complete message definitions of the\nX Protocol. Another feature of protobuf is the automatic code generation based\non those .proto files across a variety of languages for use in community\ndeveloped connectors for MySQL.\n\nThese language specific generated files can be used with no restrictions under\nyour own terms.\n\nThe X Protocol use of .proto makes our protocol design clear and concise,\nno longer requiring the efforts previously required \u2013 no longer will you need\nto directly analyze our message format. In addition to the layout of\nthe message format, the .proto also defines and documents message sequence\nand flow between the connectors and the MySQL server. The information defined\nin the .proto file makes it easy to implement X protocol support in connector\ncode. As those who have written a MySQL connector know, coding the protocol\nis only a small part of the effort required.\n\nFinally, you can focus on the big task of creating a MySQL community\nconnector - designing apis, coding, testing, selecting your license, packaging,\ndocumentation. And, promoting and speaking about your work.\n\n@section xprotocol_mysqlxshell_example X Protocol example\n\nThe following figure shows usage of the X %Protocol between MYSQLXSHELL and\nMySQL Server 5.7.12 or higher with the X %Plugin enabled.\nThe object _X %Protocol_ on this figure represents rather some concept\nthan an implementation object. The aim is to show its role in the process\nof information exchange between the client and the server.\n\n@startuml \"X Protocol Overview\"\nactor \"User\"\nbox \"MySQLx Shell\"\nparticipant \"X DevAPI\" as devapi\nparticipant \"X Protocol\" as xclproto\nend box\n\nbox \"MySQL Server\"\nparticipant \"X Plugin\" as xpl\nparticipant \"X Protocol\" as xplproto\nparticipant \"Server\" as serv\nend box\n\nUser -> devapi: Request\nactivate devapi\ndevapi -> xclproto: Encode request\nactivate xclproto\n\nxclproto --> devapi\ndeactivate xclproto\n\ndevapi -> xpl: Receive request << Network (TCP) >>\nactivate xpl\n\nxpl -> xplproto: Decode request\nactivate xplproto\n\nxplproto --> xpl\ndeactivate xplproto\n\nxpl -> serv: Execute request\nactivate serv\n\nserv --> xpl\ndeactivate serv\n\nxpl --> devapi: << Network (TCP) >>\ndeactivate xpl\n\ndevapi --> User\ndeactivate devapi\n...\n@enduml\n\nThe documentation is based on the source files such as:\n\n-  [``mysqlx.proto``](https://github.com/mysql/mysql-server/tree/5.7/rapid/plugin/x/protocol/mysqlx.proto)\n-  [``mysqlx_connection.proto``](https://github.com/mysql/mysql-server/tree/5.7/rapid/plugin/x/protocol/mysqlx_connection.proto)\n-  [``mysqlx_session.proto``](https://github.com/mysql/mysql-server/tree/5.7/rapid/plugin/x/protocol/mysqlx_session.proto>)\n-  [``mysqlx_crud.proto``](https://github.com/mysql/mysql-server/tree/5.7/rapid/plugin/x/protocol/mysqlx_crud.proto>)\n-  [``mysqlx_sql.proto``](https://github.com/mysql/mysql-server/tree/5.7/rapid/plugin/x/protocol/mysqlx_sql.proto>)\n-  [``mysqlx_resultset.proto``](https://github.com/mysql/mysql-server/tree/5.7/rapid/plugin/x/protocol/mysqlx_resultset.proto>)\n-  [``mysqlx_expr.proto``](https://github.com/mysql/mysql-server/tree/5.7/rapid/plugin/x/protocol/mysqlx_expr.proto>)\n-  [``mysqlx_datatypes.proto``](https://github.com/mysql/mysql-server/tree/5.7/rapid/plugin/x/protocol/mysqlx_datatypes.proto>)\n-  [``mysqlx_expect.proto``](https://github.com/mysql/mysql-server/tree/5.7/rapid/plugin/x/protocol/mysqlx_expect.proto>)\n-  [``mysqlx_notice.proto``](https://github.com/mysql/mysql-server/tree/5.7/rapid/plugin/x/protocol/mysqlx_notice.proto>)\n\n*/\n\n\n/**\n  @page PAGE_SQL_EXECUTION SQL Query Execution\n\n  @section sql_query_exec_parsing SQL Parsing\n\n  The parser processes SQL strings and builds a tree representation of them.\n\n  See @ref GROUP_PARSER.\n\n  @subpage PAGE_SQL_Optimizer\n\n  @subpage stored_programs\n\n  @section sql_query_exec_prepared Prepared statements\n\n  See #mysql_stmt_prepare\n\n  @section func_stored_proc Stored procedures\n\n  See #sp_head, #sp_instr.\n\n  @section sql_query_exec_sql_functions SQL Functions\n\n  See #Item_func\n\n  @section sql_query_exec_error_handling Error handling\n\n  See #my_message, #my_error\n\n  @subpage PAGE_TXN\n\n*/\n\n/**\n  @page PAGE_STORAGE Data Storage\n\n  @section storage_innodb Innodb\n\n  See #ha_innobase or read details about InnoDB internals:\n  - @subpage PAGE_INNODB_PFS\n  - @subpage PAGE_INNODB_REDO_LOG\n  - @subpage PAGE_INNODB_LOCK_SYS\n  - @subpage PAGE_INNODB_UTILS\n\n  @section storage_temptable Temp table\n\n  Before 8.0, temporary tables were handled by heap engine.\n  The heap engine had no feature to store bigger tables on disk.\n\n  Since 8.0, there is a brand new temptable engine, which\n  is written from scratch using c++11. It has following advantages:\n  - it is able to store bigger tables on disk (in temporary files),\n  - it uses row format with variable size (can save memory for varchars),\n  - it is better designed (easier to maintain).\n\n  @subpage PAGE_TEMPTABLE\n\n*/\n\n\n/**\n  @page PAGE_REPLICATION Replication\n\n  @subpage PAGE_RPL_FIELD_METADATA\n\n*/\n\n/**\n  @page PAGE_TXN Transactions\n\n  See #trans_begin, #trans_commit, #trans_rollback.\n*/\n\n/**\n  @page PAGE_SECURITY Security\n\n  @subpage AUTHORIZATION_PAGE\n*/\n\n\n/**\n  @page PAGE_MONITORING Monitoring\n\n  @subpage PAGE_PFS\n*/\n\n/**\n  @page PAGE_EXTENDING Extending MySQL\n\n  Components\n  ----------\n\n  MySQL 8.0 introduces support for extending the server through components.\n  Components can communicate with other components through service APIs.\n  And can provide implementations of service APIs for other components to use.\n  All components are equal and can communicate with all other components.\n  Service implementations can be found by name via a registry service handle\n  which is passed to the component initialization function.\n  There can be multiple service API implementations for a single service API.\n  One of them is the default implementation.\n  Service API are stateless by definition. If they need to handle state or\n  object instances they need to do so by using factory methods and instance\n  handles.\n\n  To ease up transition to the component model the current server\n  functionality (server proper and plugins) is contained within\n  a dedicated built in server component. The server component currently\n  contains all of the functionality provided by the server and\n  classical server plugins.\n\n  More components can be installed via the \"INSTALL COMPONENT\" SQL command.\n\n  The component infrastructure is designed as a replacement for the classical\n  MySQL plugin system as it does not suffer from some of the limitations of it\n  and provides better isolation for the component code.\n\n  See @subpage PAGE_COMPONENTS.\n\n  Plugins and Services\n  --------------------\n\n  As of MySQL 5.1 the server functionality can be extended through\n  installing (dynamically or statically linked) extra code modules\n  called plugins.\n\n  The server defines a set of well known plugin APIs that the modules\n  can implement.\n\n  To allow plugins to reuse server code the server exposes a pre-defined\n  set of functions to plugins called plugin services.\n\n  See the following for more details:\n  - @subpage page_ext_plugins\n  - @subpage page_ext_plugin_services\n\n\n  User Defined Functions\n  ----------------------\n\n  Native code user defined functions can be added to MySQL server using\n  the CREATE FUNCTION ... SONAME syntax.\n\n  These can co-exit with @ref page_ext_plugins or reside in their own\n  separate binaries.\n\n  To learn how to create these user defined functions see @subpage page_ext_udf\n*/\n\n\n/**\n  @page PAGE_SERVER_TOOLS Server tools\n\n  - @subpage PAGE_MYSQL_ROUTER\n*/\n\n\n/**\n  @page PAGE_CLIENT_TOOLS Client tools\n\n  See mysqldump.cc mysql.cc\n*/\n\n\n/**\n  @page PAGE_TESTING_TOOLS Testing Tools\n\n  - @subpage PAGE_MYSQL_TEST_RUN\n*/\n\n/**\n  @page PAGE_DEV_TOOLS Development Tools\n\n  - @subpage PAGE_LOCK_ORDER\n*/\n\n\n/**\n  @page PAGE_SQL_Optimizer SQL Optimizer\n\n  The task of query optimizer is to determine the most efficient means for\n  executing queries. The query optimizer consists of the following\n  sub-modules:\n\n  - @ref Query_Resolver\n  - @ref Query_Optimizer\n  - @ref Query_Planner\n  - @ref Query_Executor\n\n  @subpage PAGE_OPT_TRACE\n\n  Additional articles about the query optimizer:\n\n  - @ref PAGE_OPT_TRACE\n  - @ref AGGREGATE_CHECKS\n*/\n/* clang-format on */\n\n#include \"sql/mysqld.h\"\n\n#include \"my_config.h\"\n\n#include \"errmsg.h\"  // init_client_errs\n#include \"ft_global.h\"\n#include \"keycache.h\"  // KEY_CACHE\n#include \"libbinlogevents/include/binlog_event.h\"\n#include \"libbinlogevents/include/control_events.h\"\n#include \"m_string.h\"\n#include \"migrate_keyring.h\"  // Migrate_keyring\n#include \"my_alloc.h\"\n#include \"my_base.h\"\n#include \"my_bitmap.h\"  // MY_BITMAP\n#include \"my_command.h\"\n#include \"my_dbug.h\"\n#include \"my_default.h\"  // print_defaults\n#include \"my_dir.h\"\n#include \"my_getpwnam.h\"\n#include \"my_loglevel.h\"\n#include \"my_macros.h\"\n#include \"my_shm_defaults.h\"  // IWYU pragma: keep\n#include \"my_stacktrace.h\"    // my_set_exception_pointers\n#include \"my_thread_local.h\"\n#include \"my_time.h\"\n#include \"my_timer.h\"  // my_timer_initialize\n#include \"myisam.h\"\n#include \"mysql/components/services/log_builtins.h\"\n#include \"mysql/components/services/log_shared.h\"\n#include \"mysql/components/services/mysql_runtime_error_service.h\"\n#include \"mysql/plugin.h\"\n#include \"mysql/plugin_audit.h\"\n#include \"mysql/psi/mysql_cond.h\"\n#include \"mysql/psi/mysql_file.h\"\n#include \"mysql/psi/mysql_memory.h\"  // mysql_memory_init\n#include \"mysql/psi/mysql_mutex.h\"\n#include \"mysql/psi/mysql_rwlock.h\"\n#include \"mysql/psi/mysql_socket.h\"\n#include \"mysql/psi/mysql_stage.h\"\n#include \"mysql/psi/mysql_statement.h\"\n#include \"mysql/psi/mysql_thread.h\"\n#include \"mysql/psi/psi_base.h\"\n#include \"mysql/psi/psi_cond.h\"\n#include \"mysql/psi/psi_data_lock.h\"\n#include \"mysql/psi/psi_error.h\"\n#include \"mysql/psi/psi_file.h\"\n#include \"mysql/psi/psi_idle.h\"\n#include \"mysql/psi/psi_mdl.h\"\n#include \"mysql/psi/psi_memory.h\"\n#include \"mysql/psi/psi_mutex.h\"\n#include \"mysql/psi/psi_rwlock.h\"\n#include \"mysql/psi/psi_socket.h\"\n#include \"mysql/psi/psi_stage.h\"\n#include \"mysql/psi/psi_statement.h\"\n#include \"mysql/psi/psi_system.h\"\n#include \"mysql/psi/psi_table.h\"\n#include \"mysql/psi/psi_thread.h\"\n#include \"mysql/psi/psi_transaction.h\"\n#include \"mysql/service_mysql_alloc.h\"\n#include \"mysql/thread_type.h\"\n#include \"mysql_com.h\"\n#include \"mysql_time.h\"\n#include \"mysql_version.h\"\n#include \"mysqld_error.h\"\n#include \"mysys_err.h\"  // EXIT_OUT_OF_MEMORY\n#include \"pfs_thread_provider.h\"\n#include \"print_version.h\"\n#ifdef _WIN32\n#include <shellapi.h>\n#endif\n#include \"sql/auth/auth_common.h\"         // grant_init\n#include \"sql/auth/sql_authentication.h\"  // init_rsa_keys\n#include \"sql/auth/sql_security_ctx.h\"\n#include \"sql/auto_thd.h\"   // Auto_THD\n#include \"sql/binlog.h\"     // mysql_bin_log\n#include \"sql/bootstrap.h\"  // bootstrap\n#include \"sql/check_stack.h\"\n#include \"sql/conn_handler/connection_acceptor.h\"  // Connection_acceptor\n#include \"sql/conn_handler/connection_handler_impl.h\"  // Per_thread_connection_handler\n#include \"sql/conn_handler/connection_handler_manager.h\"  // Connection_handler_manager\n#include \"sql/conn_handler/socket_connection.h\"  // stmt_info_new_packet\n#include \"sql/current_thd.h\"                     // current_thd\n#include \"sql/dd/cache/dictionary_client.h\"\n#include \"sql/debug_sync.h\"  // debug_sync_end\n#include \"sql/derror.h\"\n#include \"sql/event_data_objects.h\"  // init_scheduler_psi_keys\n#include \"sql/events.h\"              // Events\n#include \"sql/handler.h\"\n#include \"sql/hostname_cache.h\"  // hostname_cache_init\n#include \"sql/init.h\"            // unireg_init\n#include \"sql/item.h\"\n#include \"sql/item_cmpfunc.h\"  // Arg_comparator\n#include \"sql/item_create.h\"\n#include \"sql/item_func.h\"\n#include \"sql/item_strfunc.h\"  // Item_func_uuid\n#include \"sql/keycaches.h\"     // get_or_create_key_cache\n#include \"sql/log.h\"\n#include \"sql/log_event.h\"  // Rows_log_event\n#include \"sql/log_resource.h\"\n#include \"sql/mdl.h\"\n#include \"sql/mdl_context_backup.h\"  // mdl_context_backup_manager\n#include \"sql/my_decimal.h\"\n#include \"sql/mysqld_daemon.h\"\n#include \"sql/mysqld_thd_manager.h\"              // Global_THD_manager\n#include \"sql/opt_costconstantcache.h\"           // delete_optimizer_cost_module\n#include \"sql/opt_range.h\"                       // range_optimizer_init\n#include \"sql/options_mysqld.h\"                  // OPT_THREAD_CACHE_SIZE\n#include \"sql/partitioning/partition_handler.h\"  // partitioning_init\n#include \"sql/persisted_variable.h\"              // Persisted_variables_cache\n#include \"sql/plugin_table.h\"\n#include \"sql/protocol.h\"\n#include \"sql/psi_memory_key.h\"  // key_memory_MYSQL_RELAY_LOG_index\n#include \"sql/query_options.h\"\n#include \"sql/replication.h\"                        // thd_enter_cond\n#include \"sql/resourcegroups/resource_group_mgr.h\"  // init, post_init\n#ifdef _WIN32\n#include \"sql/restart_monitor_win.h\"\n#endif\n#include \"sql/rpl_filter.h\"\n#include \"sql/rpl_gtid.h\"\n#include \"sql/rpl_gtid_persist.h\"  // Gtid_table_persistor\n#include \"sql/rpl_handler.h\"       // RUN_HOOK\n#include \"sql/rpl_info_factory.h\"\n#include \"sql/rpl_info_handler.h\"\n#include \"sql/rpl_injector.h\"  // injector\n#include \"sql/rpl_log_encryption.h\"\n#include \"sql/rpl_master.h\"  // max_binlog_dump_events\n#include \"sql/rpl_mi.h\"\n#include \"sql/rpl_msr.h\"    // Multisource_info\n#include \"sql/rpl_rli.h\"    // Relay_log_info\n#include \"sql/rpl_slave.h\"  // slave_load_tmpdir\n#include \"sql/rpl_trx_tracking.h\"\n#include \"sql/sd_notify.h\"  // sd_notify_connect\n#include \"sql/session_tracker.h\"\n#include \"sql/set_var.h\"\n#include \"sql/sp_head.h\"    // init_sp_psi_keys\n#include \"sql/sql_audit.h\"  // mysql_audit_general\n#include \"sql/sql_base.h\"\n#include \"sql/sql_callback.h\"  // MUSQL_CALLBACK\n#include \"sql/sql_class.h\"     // THD\n#include \"sql/sql_connect.h\"\n#include \"sql/sql_error.h\"\n#include \"sql/sql_initialize.h\"  // opt_initialize_insecure\n#include \"sql/sql_lex.h\"\n#include \"sql/sql_list.h\"\n#include \"sql/sql_locale.h\"   // MY_LOCALE\n#include \"sql/sql_manager.h\"  // start_handle_manager\n#include \"sql/sql_parse.h\"    // check_stack_overrun\n#include \"sql/sql_plugin.h\"   // opt_plugin_dir\n#include \"sql/sql_plugin_ref.h\"\n#include \"sql/sql_reload.h\"          // handle_reload_request\n#include \"sql/sql_restart_server.h\"  // is_mysqld_managed\n#include \"sql/sql_servers.h\"\n#include \"sql/sql_show.h\"\n#include \"sql/sql_table.h\"  // build_table_filename\n#include \"sql/sql_udf.h\"\n#include \"sql/ssl_acceptor_context.h\"\n#include \"sql/sys_vars.h\"         // fixup_enforce_gtid_consistency_...\n#include \"sql/sys_vars_shared.h\"  // intern_find_sys_var\n#include \"sql/table_cache.h\"      // table_cache_manager\n#include \"sql/tc_log.h\"           // tc_log\n#include \"sql/thd_raii.h\"\n#include \"sql/thr_malloc.h\"\n#include \"sql/threadpool.h\"\n#include \"sql/transaction.h\"\n#include \"sql/tztime.h\"  // Time_zone\n#include \"sql/xa.h\"\n#include \"sql_common.h\"  // mysql_client_plugin_init\n#include \"sql_string.h\"\n#include \"storage/myisam/ha_myisam.h\"  // HA_RECOVER_OFF\n#include \"storage/perfschema/pfs_services.h\"\n#include \"thr_lock.h\"\n#include \"thr_mutex.h\"\n#include \"typelib.h\"\n#include \"violite.h\"\n\n#ifdef WITH_PERFSCHEMA_STORAGE_ENGINE\n#include \"storage/perfschema/pfs_server.h\"\n#endif /* WITH_PERFSCHEMA_STORAGE_ENGINE */\n\n#ifdef _WIN32\n#include \"sql/conn_handler/named_pipe_connection.h\"\n#include \"sql/conn_handler/shared_memory_connection.h\"\n#include \"sql/named_pipe.h\"\n#endif\n\n#ifdef HAVE_ARPA_INET_H\n#include <arpa/inet.h>\n#endif\n#ifdef MY_MSCRT_DEBUG\n#include <crtdbg.h>\n#endif\n#include <errno.h>\n#include <fcntl.h>\n#include <fenv.h>\n#include <limits.h>\n#ifdef HAVE_GRP_H\n#include <grp.h>\n#endif\n#ifndef _WIN32\n#include <netdb.h>\n#endif\n#ifdef HAVE_NETINET_IN_H\n#include <netinet/in.h>\n#endif\n#include <signal.h>\n#include <stdarg.h>\n#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n#ifdef HAVE_SYS_MMAN_H\n#include <sys/mman.h>\n#endif\n#ifdef HAVE_SYS_PRCTL_H\n#include <sys/prctl.h>\n#endif\n#ifdef HAVE_SYS_RESOURCE_H\n#include <sys/resource.h>\n#endif\n#include <sys/stat.h>\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n#ifdef _WIN32\n#include <crtdbg.h>\n#include <process.h>\n#endif\n#include \"unicode/uclean.h\"  // u_cleanup()\n\n#include <algorithm>\n#include <atomic>\n#include <functional>\n#include <new>\n#include <string>\n#include <vector>\n\n#ifndef EMBEDDED_LIBRARY\n#ifdef WITH_LOCK_ORDER\n#include \"sql/debug_lock_order.h\"\n#endif /* WITH_LOCK_ORDER */\n#endif /* EMBEDDED_LIBRARY */\n\n#ifndef EMBEDDED_LIBRARY\n#include \"srv_session.h\"\n#endif\n\n#include <mysql/components/minimal_chassis.h>\n#include <mysql/components/services/dynamic_loader_scheme_file.h>\n#include <mysql/components/services/mysql_psi_system_service.h>\n#include <mysql/components/services/mysql_rwlock_service.h>\n#include <mysql/components/services/ongoing_transaction_query_service.h>\n#include \"sql/auth/dynamic_privileges_impl.h\"\n#include \"sql/dd/dd.h\"                   // dd::shutdown\n#include \"sql/dd/dd_kill_immunizer.h\"    // dd::DD_kill_immunizer\n#include \"sql/dd/dictionary.h\"           // dd::get_dictionary\n#include \"sql/dd/ndbinfo_schema/init.h\"  // dd::ndbinfo::init_schema_and_tables()\n#include \"sql/dd/performance_schema/init.h\"  // performance_schema::init\n#include \"sql/dd/upgrade/server.h\"      // dd::upgrade::upgrade_system_schemas\n#include \"sql/dd/upgrade_57/upgrade.h\"  // dd::upgrade_57::in_progress\n#include \"sql/server_component/component_sys_var_service_imp.h\"\n#include \"sql/server_component/log_builtins_filter_imp.h\"\n#include \"sql/server_component/log_builtins_imp.h\"\n#include \"sql/server_component/persistent_dynamic_loader_imp.h\"\n#include \"sql/srv_session.h\"\n\nusing std::max;\nusing std::min;\nusing std::vector;\n\n#define mysqld_charset &my_charset_latin1\n#define mysqld_default_locale_name \"en_US\"\n\n#ifdef HAVE_FPU_CONTROL_H\n#include <fpu_control.h>  // IWYU pragma: keep\n#elif defined(__i386__)\n#define fpu_control_t unsigned int\n#define _FPU_EXTENDED 0x300\n#define _FPU_DOUBLE 0x200\n#if defined(__GNUC__) || defined(__SUNPRO_CC)\n#define _FPU_GETCW(cw) asm volatile(\"fnstcw %0\" : \"=m\"(*&cw))\n#define _FPU_SETCW(cw) asm volatile(\"fldcw %0\" : : \"m\"(*&cw))\n#else\n#define _FPU_GETCW(cw) (cw = 0)\n#define _FPU_SETCW(cw)\n#endif\n#endif\ninline void setup_fpu() {\n#ifdef HAVE_FEDISABLEEXCEPT\n  fedisableexcept(FE_ALL_EXCEPT);\n#endif\n\n  /* Set FPU rounding mode to \"round-to-nearest\" */\n  fesetround(FE_TONEAREST);\n\n  /*\n    x86 (32-bit) requires FPU precision to be explicitly set to 64 bit\n    (double precision) for portable results of floating point operations.\n    However, there is no need to do so if compiler is using SSE2 for floating\n    point, double values will be stored and processed in 64 bits anyway.\n  */\n#if defined(__i386__) && !defined(__SSE2_MATH__)\n#if !defined(_WIN32)\n  fpu_control_t cw;\n  _FPU_GETCW(cw);\n  cw = (cw & ~_FPU_EXTENDED) | _FPU_DOUBLE;\n  _FPU_SETCW(cw);\n#endif /* _WIN32 && */\n#endif /* __i386__ */\n}\n\nextern \"C\" void handle_fatal_signal(int sig);\n\n/* Constants */\n\n#include \"welcome_copyright_notice.h\"  // ORACLE_WELCOME_COPYRIGHT_NOTICE\n\nconst char *show_comp_option_name[] = {\"YES\", \"NO\", \"DISABLED\"};\n\nstatic const char *tc_heuristic_recover_names[] = {\"OFF\", \"COMMIT\", \"ROLLBACK\",\n                                                   NullS};\nstatic TYPELIB tc_heuristic_recover_typelib = {\n    array_elements(tc_heuristic_recover_names) - 1, \"\",\n    tc_heuristic_recover_names, nullptr};\n\nconst char *first_keyword = \"first\", *binary_keyword = \"BINARY\";\nconst char *my_localhost = \"localhost\";\n\nbool opt_large_files = sizeof(my_off_t) > 4;\nstatic bool opt_autocommit;  ///< for --autocommit command-line option\nstatic get_opt_arg_source source_autocommit;\n\n/*\n  Used with --help for detailed option\n*/\nbool opt_help = false, opt_verbose = false, opt_validate_config = false;\n\narg_cmp_func Arg_comparator::comparator_matrix[5] = {\n    &Arg_comparator::compare_string,      // Compare strings\n    &Arg_comparator::compare_real,        // Compare float values\n    &Arg_comparator::compare_int_signed,  // Compare signed int values\n    &Arg_comparator::compare_row,         // Compare row values\n    &Arg_comparator::compare_decimal};    // Compare decimal values\n\nPSI_file_key key_file_binlog_cache;\nPSI_file_key key_file_binlog_index_cache;\n\n#ifdef HAVE_PSI_INTERFACE\nstatic PSI_mutex_key key_LOCK_status;\nstatic PSI_mutex_key key_LOCK_manager;\nstatic PSI_mutex_key key_LOCK_crypt;\nstatic PSI_mutex_key key_LOCK_user_conn;\nstatic PSI_mutex_key key_LOCK_global_system_variables;\nstatic PSI_mutex_key key_LOCK_prepared_stmt_count;\nstatic PSI_mutex_key key_LOCK_sql_slave_skip_counter;\nstatic PSI_mutex_key key_LOCK_slave_net_timeout;\nstatic PSI_mutex_key key_LOCK_slave_trans_dep_tracker;\nstatic PSI_mutex_key key_LOCK_uuid_generator;\nstatic PSI_mutex_key key_LOCK_error_messages;\nstatic PSI_mutex_key key_LOCK_default_password_lifetime;\nstatic PSI_mutex_key key_LOCK_mandatory_roles;\nstatic PSI_mutex_key key_LOCK_password_history;\nstatic PSI_mutex_key key_LOCK_password_reuse_interval;\nstatic PSI_mutex_key key_LOCK_sql_rand;\nstatic PSI_mutex_key key_LOCK_log_throttle_qni;\nstatic PSI_mutex_key key_LOCK_reset_gtid_table;\nstatic PSI_mutex_key key_LOCK_compress_gtid_table;\nstatic PSI_mutex_key key_LOCK_collect_instance_log;\nstatic PSI_mutex_key key_BINLOG_LOCK_commit;\nstatic PSI_mutex_key key_BINLOG_LOCK_commit_queue;\nstatic PSI_mutex_key key_BINLOG_LOCK_done;\nstatic PSI_mutex_key key_BINLOG_LOCK_flush_queue;\nstatic PSI_mutex_key key_BINLOG_LOCK_index;\nstatic PSI_mutex_key key_BINLOG_LOCK_log;\nstatic PSI_mutex_key key_BINLOG_LOCK_binlog_end_pos;\nstatic PSI_mutex_key key_BINLOG_LOCK_sync;\nstatic PSI_mutex_key key_BINLOG_LOCK_sync_queue;\nstatic PSI_mutex_key key_BINLOG_LOCK_xids;\nstatic PSI_rwlock_key key_rwlock_global_sid_lock;\nstatic PSI_rwlock_key key_rwlock_gtid_mode_lock;\nstatic PSI_rwlock_key key_rwlock_LOCK_system_variables_hash;\nstatic PSI_rwlock_key key_rwlock_LOCK_sys_init_connect;\nstatic PSI_rwlock_key key_rwlock_LOCK_sys_init_slave;\nstatic PSI_cond_key key_BINLOG_COND_done;\nstatic PSI_cond_key key_BINLOG_update_cond;\nstatic PSI_cond_key key_BINLOG_prep_xids_cond;\nstatic PSI_cond_key key_COND_manager;\nstatic PSI_cond_key key_COND_compress_gtid_table;\nstatic PSI_thread_key key_thread_signal_hand;\nstatic PSI_thread_key key_thread_main;\nstatic PSI_file_key key_file_casetest;\nstatic PSI_file_key key_file_pid;\n#if defined(_WIN32)\nstatic PSI_thread_key key_thread_handle_con_namedpipes;\nstatic PSI_thread_key key_thread_handle_con_sharedmem;\nstatic PSI_thread_key key_thread_handle_con_sockets;\nstatic PSI_mutex_key key_LOCK_handler_count;\nstatic PSI_cond_key key_COND_handler_count;\nstatic PSI_thread_key key_thread_handle_shutdown_restart;\nstatic PSI_rwlock_key key_rwlock_LOCK_named_pipe_full_access_group;\n#else\nstatic PSI_mutex_key key_LOCK_socket_listener_active;\nstatic PSI_cond_key key_COND_socket_listener_active;\nstatic PSI_mutex_key key_LOCK_start_signal_handler;\nstatic PSI_cond_key key_COND_start_signal_handler;\n#endif  // _WIN32\nstatic PSI_mutex_key key_LOCK_server_started;\nstatic PSI_cond_key key_COND_server_started;\nstatic PSI_mutex_key key_LOCK_keyring_operations;\nstatic PSI_mutex_key key_LOCK_tls_ctx_options;\nstatic PSI_mutex_key key_LOCK_rotate_binlog_master_key;\n#endif /* HAVE_PSI_INTERFACE */\n\n/**\n  Statement instrumentation key for replication.\n*/\n#ifdef HAVE_PSI_STATEMENT_INTERFACE\nPSI_statement_info stmt_info_rpl;\n#endif\n\n/* the default log output is log tables */\nstatic bool lower_case_table_names_used = false;\n#if !defined(_WIN32)\nstatic bool socket_listener_active = false;\nstatic int pipe_write_fd = -1;\nstatic bool opt_daemonize = false;\n#endif\nbool opt_debugging = false;\nstatic bool opt_external_locking = false, opt_console = false;\nstatic bool opt_short_log_format = false;\nstatic char *mysqld_user, *mysqld_chroot;\nstatic const char *default_character_set_name;\nstatic const char *character_set_filesystem_name;\nstatic const char *lc_messages;\nstatic const char *lc_time_names_name;\nchar *my_bind_addr_str;\nchar *my_admin_bind_addr_str;\nuint mysqld_admin_port;\nbool listen_admin_interface_in_separate_thread;\nchar *my_proxy_protocol_networks;\nstatic const char *default_collation_name;\nconst char *default_storage_engine;\nconst char *default_tmp_storage_engine;\nulonglong temptable_max_ram;\nbool temptable_use_mmap;\nstatic char compiled_default_collation_name[] = MYSQL_DEFAULT_COLLATION_NAME;\nstatic bool binlog_format_used = false;\n\nLEX_STRING opt_init_connect, opt_init_slave;\n\n/* Global variables */\n\nLEX_STRING opt_mandatory_roles;\nbool opt_mandatory_roles_cache = false;\nbool opt_always_activate_granted_roles = false;\nbool opt_bin_log;\nbool opt_general_log, opt_slow_log, opt_general_log_raw;\nulonglong slow_query_log_always_write_time = 10000000;\nulonglong log_output_options;\nbool opt_log_queries_not_using_indexes = false;\nulong opt_log_throttle_queries_not_using_indexes = 0;\nbool opt_log_slow_extra = false;\nbool opt_disable_networking = false, opt_skip_show_db = false;\nbool opt_skip_name_resolve = false;\nbool opt_character_set_client_handshake = true;\nbool server_id_supplied = false;\nstatic bool opt_endinfo;\nbool using_udf_functions;\nbool locked_in_memory;\nbool opt_using_transactions;\nulong opt_tc_log_size;\nstd::atomic<int32> connection_events_loop_aborted_flag;\nstatic std::atomic<enum_server_operational_state> server_operational_state{\n    SERVER_BOOTING};\nchar *opt_log_error_suppression_list;\nchar *opt_log_error_services;\nchar *opt_keyring_migration_user = nullptr;\nchar *opt_keyring_migration_host = nullptr;\nchar *opt_keyring_migration_password = nullptr;\nchar *opt_keyring_migration_socket = nullptr;\nchar *opt_keyring_migration_source = nullptr;\nchar *opt_keyring_migration_destination = nullptr;\nulong opt_keyring_migration_port = 0;\nbool migrate_connect_options = false;\nuint host_cache_size;\nulong log_error_verbosity = 3;  // have a non-zero value during early start-up\n\n#if defined(_WIN32)\n/*\n  Thread handle of shutdown event handler thread.\n  It is used as argument during thread join.\n*/\nmy_thread_handle shutdown_restart_thr_handle;\n\nulong slow_start_timeout;\nbool opt_no_monitor = false;\n#endif\n\nbool opt_no_dd_upgrade = false;\nlong opt_upgrade_mode = UPGRADE_AUTO;\nbool opt_initialize = false;\nbool opt_skip_slave_start = false;  ///< If set, slave is not autostarted\nbool opt_enable_named_pipe = false;\nbool opt_local_infile, opt_slave_compressed_protocol;\nbool opt_safe_user_create = false;\nbool opt_show_slave_auth_info;\nbool opt_log_slave_updates = false;\nchar *opt_slave_skip_errors;\nbool opt_slave_allow_batching = false;\n\n/**\n  compatibility option:\n    - index usage hints (USE INDEX without a FOR clause) behave as in 5.0\n*/\nbool old_mode;\n\n/*\n  Legacy global handlerton. These will be removed (please do not add more).\n*/\nhandlerton *heap_hton;\nhandlerton *temptable_hton;\nhandlerton *myisam_hton;\nhandlerton *innodb_hton;\n\nchar *opt_disabled_storage_engines;\nuint opt_server_id_bits = 0;\nulong opt_server_id_mask = 0;\nbool read_only = false, opt_readonly = false;\nbool super_read_only = false, opt_super_readonly = false;\nbool opt_require_secure_transport = false;\nbool relay_log_purge;\nbool relay_log_recovery;\nbool opt_allow_suspicious_udfs;\nconst char *opt_secure_file_priv;\nbool opt_log_slow_admin_statements = false;\nbool opt_log_slow_slave_statements = false;\nbool lower_case_file_system = false;\nbool opt_large_pages = false;\nbool opt_super_large_pages = false;\nbool opt_myisam_use_mmap = false;\nstd::atomic<bool> offline_mode;\nuint opt_large_page_size = 0;\nuint default_password_lifetime = 0;\nulonglong opt_slow_query_log_use_global_control = 0;\nulong opt_slow_query_log_rate_type = 0;\nbool password_require_current = false;\nstd::atomic<bool> partial_revokes;\nbool opt_partial_revokes;\n\nmysql_mutex_t LOCK_default_password_lifetime;\nmysql_mutex_t LOCK_mandatory_roles;\nmysql_mutex_t LOCK_password_history;\nmysql_mutex_t LOCK_password_reuse_interval;\nmysql_mutex_t LOCK_tls_ctx_options;\n\n#if defined(ENABLED_DEBUG_SYNC)\nMYSQL_PLUGIN_IMPORT uint opt_debug_sync_timeout = 0;\n#endif /* defined(ENABLED_DEBUG_SYNC) */\nbool opt_old_style_user_limits = false, trust_function_creators = false;\nbool check_proxy_users = false, mysql_native_password_proxy_users = false,\n     sha256_password_proxy_users = false;\nbool opt_userstat = false;\nbool opt_thread_statistics = false;\n/*\n  True if there is at least one per-hour limit for some user, so we should\n  check them before each query (and possibly reset counters when hour is\n  changed). False otherwise.\n*/\nvolatile bool mqh_used = false;\nbool opt_noacl = false;\nbool sp_automatic_privileges = true;\n\nint32_t opt_regexp_time_limit;\nint32_t opt_regexp_stack_limit;\n\n/** True, if restarted from a cloned database. This information\nis needed by GR to set some configurations right after clone. */\nbool clone_startup = false;\n\n/** True, if clone recovery has failed. For managed server we\nrestart server again with old databse files. */\nbool clone_recovery_error = false;\n\nulong binlog_row_event_max_size;\nulong binlog_checksum_options;\nulong binlog_row_metadata;\nbool opt_master_verify_checksum = false;\nbool opt_slave_sql_verify_checksum = true;\nconst char *binlog_format_names[] = {\"MIXED\", \"STATEMENT\", \"ROW\", NullS};\nbool binlog_gtid_simple_recovery;\nulong binlog_error_action;\nconst char *binlog_error_action_list[] = {\"IGNORE_ERROR\", \"ABORT_SERVER\",\n                                          NullS};\nbool opt_binlog_skip_flush_commands = false;\nuint32 gtid_executed_compression_period = 0;\nbool opt_log_unsafe_statements;\n\nconst char *timestamp_type_names[] = {\"UTC\", \"SYSTEM\", NullS};\nulong opt_log_timestamps;\nuint mysqld_port, test_flags = 0, select_errors, ha_open_options;\nuint mysqld_port_timeout;\nulong delay_key_write_options;\nuint protocol_version;\nuint lower_case_table_names;\nlong tc_heuristic_recover;\nulong back_log, connect_timeout, server_id;\nulong table_cache_size;\nulong table_cache_instances;\nulong table_cache_size_per_instance;\nulong schema_def_size;\nulong stored_program_def_size;\nulong table_def_size;\nulong tablespace_def_size;\nulong what_to_log;\nulong slow_launch_time;\nstd::atomic<int32> atomic_slave_open_temp_tables{0};\nulong open_files_limit, max_binlog_size, max_relay_log_size;\nulong slave_trans_retries;\nuint slave_net_timeout;\nulong slave_exec_mode_options;\nulonglong slave_type_conversions_options;\nulong opt_mts_slave_parallel_workers;\nulonglong opt_mts_pending_jobs_size_max;\nulonglong slave_rows_search_algorithms_options;\nbool opt_slave_preserve_commit_order;\n#ifndef DBUG_OFF\nuint slave_rows_last_search_algorithm_used;\n#endif\nulong mts_parallel_option;\nulong binlog_cache_size = 0;\nulonglong max_binlog_cache_size = 0;\nulong slave_max_allowed_packet = 0;\nulong binlog_stmt_cache_size = 0;\nint32 opt_binlog_max_flush_queue_time = 0;\nlong opt_binlog_group_commit_sync_delay = 0;\nulong opt_binlog_group_commit_sync_no_delay_count = 0;\nulonglong max_binlog_stmt_cache_size = 0;\nulong refresh_version; /* Increments on each reload */\nstd::atomic<query_id_t> atomic_global_query_id{1};\nulong aborted_threads;\nulong delayed_insert_timeout, delayed_insert_limit, delayed_queue_size;\nulong delayed_insert_threads, delayed_insert_writes, delayed_rows_in_use;\nulong delayed_insert_errors, flush_time;\nulong specialflag = 0;\nulong binlog_cache_use = 0, binlog_cache_disk_use = 0;\nulong binlog_stmt_cache_use = 0, binlog_stmt_cache_disk_use = 0;\nulong max_connections, max_connect_errors;\nulong rpl_stop_slave_timeout = LONG_TIMEOUT;\nbool log_bin_use_v1_row_events = false;\nbool thread_cache_size_specified = false;\nbool host_cache_size_specified = false;\nbool table_definition_cache_specified = false;\nulong locked_account_connection_count = 0;\n\nulonglong denied_connections = 0;\n\n/**\n  Limit of the total number of prepared statements in the server.\n  Is necessary to protect the server against out-of-memory attacks.\n*/\nulong max_prepared_stmt_count;\n/**\n  Current total number of prepared statements in the server. This number\n  is exact, and therefore may not be equal to the difference between\n  `com_stmt_prepare' and `com_stmt_close' (global status variables), as\n  the latter ones account for all registered attempts to prepare\n  a statement (including unsuccessful ones).  Prepared statements are\n  currently connection-local: if the same SQL query text is prepared in\n  two different connections, this counts as two distinct prepared\n  statements.\n*/\nulong prepared_stmt_count = 0;\nulong current_pid;\nuint sync_binlog_period = 0, sync_relaylog_period = 0,\n     sync_relayloginfo_period = 0, sync_masterinfo_period = 0,\n     opt_mts_checkpoint_period, opt_mts_checkpoint_group;\nulong expire_logs_days = 0;\nulong binlog_expire_logs_seconds = 0;\n/**\n  Soft upper limit for number of sp_head objects that can be stored\n  in the sp_cache for one connection.\n*/\nulong stored_program_cache_size = 0;\n/**\n  Compatibility option to prevent auto upgrade of old temporals\n  during certain ALTER TABLE operations.\n*/\nbool avoid_temporal_upgrade;\n\nbool persisted_globals_load = true;\n\nbool opt_keyring_operations = true;\n\nbool opt_table_encryption_privilege_check = false;\n\nconst double log_10[] = {\n    1e000, 1e001, 1e002, 1e003, 1e004, 1e005, 1e006, 1e007, 1e008, 1e009, 1e010,\n    1e011, 1e012, 1e013, 1e014, 1e015, 1e016, 1e017, 1e018, 1e019, 1e020, 1e021,\n    1e022, 1e023, 1e024, 1e025, 1e026, 1e027, 1e028, 1e029, 1e030, 1e031, 1e032,\n    1e033, 1e034, 1e035, 1e036, 1e037, 1e038, 1e039, 1e040, 1e041, 1e042, 1e043,\n    1e044, 1e045, 1e046, 1e047, 1e048, 1e049, 1e050, 1e051, 1e052, 1e053, 1e054,\n    1e055, 1e056, 1e057, 1e058, 1e059, 1e060, 1e061, 1e062, 1e063, 1e064, 1e065,\n    1e066, 1e067, 1e068, 1e069, 1e070, 1e071, 1e072, 1e073, 1e074, 1e075, 1e076,\n    1e077, 1e078, 1e079, 1e080, 1e081, 1e082, 1e083, 1e084, 1e085, 1e086, 1e087,\n    1e088, 1e089, 1e090, 1e091, 1e092, 1e093, 1e094, 1e095, 1e096, 1e097, 1e098,\n    1e099, 1e100, 1e101, 1e102, 1e103, 1e104, 1e105, 1e106, 1e107, 1e108, 1e109,\n    1e110, 1e111, 1e112, 1e113, 1e114, 1e115, 1e116, 1e117, 1e118, 1e119, 1e120,\n    1e121, 1e122, 1e123, 1e124, 1e125, 1e126, 1e127, 1e128, 1e129, 1e130, 1e131,\n    1e132, 1e133, 1e134, 1e135, 1e136, 1e137, 1e138, 1e139, 1e140, 1e141, 1e142,\n    1e143, 1e144, 1e145, 1e146, 1e147, 1e148, 1e149, 1e150, 1e151, 1e152, 1e153,\n    1e154, 1e155, 1e156, 1e157, 1e158, 1e159, 1e160, 1e161, 1e162, 1e163, 1e164,\n    1e165, 1e166, 1e167, 1e168, 1e169, 1e170, 1e171, 1e172, 1e173, 1e174, 1e175,\n    1e176, 1e177, 1e178, 1e179, 1e180, 1e181, 1e182, 1e183, 1e184, 1e185, 1e186,\n    1e187, 1e188, 1e189, 1e190, 1e191, 1e192, 1e193, 1e194, 1e195, 1e196, 1e197,\n    1e198, 1e199, 1e200, 1e201, 1e202, 1e203, 1e204, 1e205, 1e206, 1e207, 1e208,\n    1e209, 1e210, 1e211, 1e212, 1e213, 1e214, 1e215, 1e216, 1e217, 1e218, 1e219,\n    1e220, 1e221, 1e222, 1e223, 1e224, 1e225, 1e226, 1e227, 1e228, 1e229, 1e230,\n    1e231, 1e232, 1e233, 1e234, 1e235, 1e236, 1e237, 1e238, 1e239, 1e240, 1e241,\n    1e242, 1e243, 1e244, 1e245, 1e246, 1e247, 1e248, 1e249, 1e250, 1e251, 1e252,\n    1e253, 1e254, 1e255, 1e256, 1e257, 1e258, 1e259, 1e260, 1e261, 1e262, 1e263,\n    1e264, 1e265, 1e266, 1e267, 1e268, 1e269, 1e270, 1e271, 1e272, 1e273, 1e274,\n    1e275, 1e276, 1e277, 1e278, 1e279, 1e280, 1e281, 1e282, 1e283, 1e284, 1e285,\n    1e286, 1e287, 1e288, 1e289, 1e290, 1e291, 1e292, 1e293, 1e294, 1e295, 1e296,\n    1e297, 1e298, 1e299, 1e300, 1e301, 1e302, 1e303, 1e304, 1e305, 1e306, 1e307,\n    1e308};\n\n/* Index extention. */\nconst int index_ext_length = 6;\nconst char *index_ext = \".index\";\nconst int relay_ext_length = 10;\nconst char *relay_ext = \"-relay-bin\";\n/* True if --log-bin option is used. */\nbool log_bin_supplied = false;\n\ntime_t server_start_time, flush_status_time;\n\nchar server_uuid[UUID_LENGTH + 1];\nconst char *server_uuid_ptr;\nchar mysql_home[FN_REFLEN], pidfile_name[FN_REFLEN], system_time_zone[30];\nchar default_logfile_name[FN_REFLEN];\nchar default_binlogfile_name[FN_REFLEN];\nchar default_binlog_index_name[FN_REFLEN + index_ext_length];\nchar default_relaylogfile_name[FN_REFLEN + relay_ext_length];\nchar default_relaylog_index_name[FN_REFLEN + relay_ext_length +\n                                 index_ext_length];\nchar *default_tz_name;\nstatic char errorlog_filename_buff[FN_REFLEN];\nconst char *log_error_dest;\nconst char *my_share_dir[FN_REFLEN];\nchar glob_hostname[HOSTNAME_LENGTH + 1];\nchar mysql_real_data_home[FN_REFLEN], lc_messages_dir[FN_REFLEN],\n    reg_ext[FN_EXTLEN], mysql_charsets_dir[FN_REFLEN], *opt_init_file;\nconst char *opt_tc_log_file;\nchar *lc_messages_dir_ptr;\nchar mysql_unpacked_real_data_home[FN_REFLEN];\nsize_t mysql_unpacked_real_data_home_len;\nsize_t mysql_data_home_len = 1;\nuint reg_ext_length;\nchar logname_path[FN_REFLEN];\nchar slow_logname_path[FN_REFLEN];\nchar secure_file_real_path[FN_REFLEN];\nTime_zone *default_tz;\nchar *mysql_data_home = const_cast<char *>(\".\");\nconst char *mysql_real_data_home_ptr = mysql_real_data_home;\nchar *opt_protocol_compression_algorithms;\nchar server_version[SERVER_VERSION_LENGTH];\nchar server_version_suffix[SERVER_VERSION_LENGTH];\nconst char *mysqld_unix_port;\nchar *opt_mysql_tmpdir;\n\nbool encrypt_tmp_files;\n\nulonglong tf_sequence_table_max_upper_bound = 0;\n\n/** name of reference on left expression in rewritten IN subquery */\nconst char *in_left_expr_name = \"<left expr>\";\n\nmy_decimal decimal_zero;\n/** Number of connection errors from internal server errors. */\nulong connection_errors_internal = 0;\n/** Number of errors when reading the peer address. */\nulong connection_errors_peer_addr = 0;\n\n/* classes for comparation parsing/processing */\nEq_creator eq_creator;\nNe_creator ne_creator;\nEqual_creator equal_creator;\nGt_creator gt_creator;\nLt_creator lt_creator;\nGe_creator ge_creator;\nLe_creator le_creator;\n\nRpl_global_filter rpl_global_filter;\nRpl_filter *binlog_filter;\n\nstruct System_variables global_system_variables;\nstruct System_variables max_system_variables;\nstruct System_status_var global_status_var;\n\nMY_TMPDIR mysql_tmpdir_list;\n\nCHARSET_INFO *system_charset_info, *files_charset_info;\nCHARSET_INFO *national_charset_info, *table_alias_charset;\nCHARSET_INFO *character_set_filesystem;\n\nMY_LOCALE *my_default_lc_messages;\nMY_LOCALE *my_default_lc_time_names;\n\nSHOW_COMP_OPTION have_symlink, have_dlopen, have_query_cache;\nSHOW_COMP_OPTION have_geometry, have_rtree_keys;\nSHOW_COMP_OPTION have_compress;\nSHOW_COMP_OPTION have_profiling;\nSHOW_COMP_OPTION have_statement_timeout = SHOW_OPTION_DISABLED;\nSHOW_COMP_OPTION have_backup_locks;\nSHOW_COMP_OPTION have_backup_safe_binlog_info;\nSHOW_COMP_OPTION have_snapshot_cloning;\n\nchar *enforce_storage_engine = nullptr;\n\nchar *utility_user = nullptr;\nchar *utility_user_password = nullptr;\nchar *utility_user_schema_access = nullptr;\n\n/* Plucking this from sql/sql_acl.cc for an array of privilege names */\nextern TYPELIB utility_user_privileges_typelib;\nulonglong utility_user_privileges = 0;\nchar *utility_user_dynamic_privileges = nullptr;\n\n/* Thread specific variables */\n\nthread_local MEM_ROOT **THR_MALLOC = nullptr;\n\nmysql_mutex_t LOCK_status, LOCK_uuid_generator, LOCK_crypt,\n    LOCK_global_system_variables, LOCK_user_conn, LOCK_error_messages;\nmysql_mutex_t LOCK_sql_rand;\n\nmysql_mutex_t LOCK_global_user_client_stats, LOCK_global_table_stats,\n    LOCK_global_index_stats;\n/**\n  The below lock protects access to two global server variables:\n  max_prepared_stmt_count and prepared_stmt_count. These variables\n  set the limit and hold the current total number of prepared statements\n  in the server, respectively. As PREPARE/DEALLOCATE rate in a loaded\n  server may be fairly high, we need a dedicated lock.\n*/\nmysql_mutex_t LOCK_prepared_stmt_count;\n\n/*\n The below two locks are introduced as guards (second mutex) for\n  the global variables sql_slave_skip_counter and slave_net_timeout\n  respectively. See fix_slave_skip_counter/fix_slave_net_timeout\n  for more details\n*/\nmysql_mutex_t LOCK_sql_slave_skip_counter;\nmysql_mutex_t LOCK_slave_net_timeout;\nmysql_mutex_t LOCK_slave_trans_dep_tracker;\nmysql_mutex_t LOCK_log_throttle_qni;\nmysql_rwlock_t LOCK_sys_init_connect, LOCK_sys_init_slave;\nmysql_rwlock_t LOCK_system_variables_hash;\nmy_thread_handle signal_thread_id;\nsigset_t mysqld_signal_mask;\nmy_thread_attr_t connection_attrib;\nmysql_mutex_t LOCK_server_started;\nmysql_cond_t COND_server_started;\nmysql_mutex_t LOCK_reset_gtid_table;\nmysql_mutex_t LOCK_compress_gtid_table;\nmysql_cond_t COND_compress_gtid_table;\nmysql_mutex_t LOCK_collect_instance_log;\n#if !defined(_WIN32)\nmysql_mutex_t LOCK_socket_listener_active;\nmysql_cond_t COND_socket_listener_active;\nmysql_mutex_t LOCK_start_signal_handler;\nmysql_cond_t COND_start_signal_handler;\n#endif\nmysql_rwlock_t LOCK_consistent_snapshot;\n\n/*\n  The below lock protects access to global server variable\n  keyring_operations.\n*/\nmysql_mutex_t LOCK_keyring_operations;\n/*\n  The below lock protects to execute commands 'ALTER INSTANCE ROTATE BINLOG\n  MASTER KEY' and 'SET @@GLOBAL.binlog_encryption=ON/OFF' in parallel.\n*/\nmysql_mutex_t LOCK_rotate_binlog_master_key;\n\nbool mysqld_server_started = false;\n/**\n  Set to true to signal at startup if the process must die.\n\n  Needed because kill_mysql() will not do anything before\n  the server is fully initialized. Thus it now just sets this\n  flag to on and exits. And then mysqld_main() will check if\n  the flag is on at the right place and exit the process if it\n  is.\n*/\nstatic bool mysqld_process_must_end_at_startup = false;\n\n/* replication parameters, if master_host is not NULL, we are a slave */\nuint report_port = 0;\nulong master_retry_count = 0;\nconst char *master_info_file;\nconst char *relay_log_info_file;\nchar *report_user, *report_password, *report_host;\nchar *opt_relay_logname = nullptr, *opt_relaylog_index_name = nullptr;\n/*\n  True if the --relay-log-index is set by users from\n  config file or command line.\n*/\nbool opt_relaylog_index_name_supplied = false;\n/*\n  True if the --relay-log is set by users from\n  config file or command line.\n*/\nbool opt_relay_logname_supplied = false;\n/*\n  True if --log-slave-updates option is set explicitly\n  on command line or configuration file.\n*/\nbool log_slave_updates_supplied = false;\n\n/*\n  True if --slave-preserve-commit-order-supplied option is set explicitly\n  on command line or configuration file.\n*/\nbool slave_preserve_commit_order_supplied = false;\nchar *opt_general_logname, *opt_slow_logname, *opt_bin_logname;\n\n/*\n  True if expire_logs_days and binlog_expire_logs_seconds is set\n  explictly.\n*/\nbool expire_logs_days_supplied = false;\nbool binlog_expire_logs_seconds_supplied = false;\n/* Static variables */\n\nstatic bool opt_myisam_log;\nstatic int cleanup_done;\nstatic ulong opt_specialflag;\nchar *opt_binlog_index_name;\nchar *mysql_home_ptr, *pidfile_name_ptr;\nchar *default_auth_plugin;\n/**\n  Memory for allocating command line arguments, after load_defaults().\n*/\nstatic MEM_ROOT argv_alloc{PSI_NOT_INSTRUMENTED, 512};\n/** Remaining command line arguments (count), filtered by handle_options().*/\nstatic int remaining_argc;\n/** Remaining command line arguments (arguments), filtered by\n * handle_options().*/\nstatic char **remaining_argv;\n\n/**\n Holds the \"original\" (i.e. as on startup) set of arguments.\n\n The argument processing goes as follows:\n 1. At startup the \"original\" set of arguments is shallow-copied into\n the read only list @ref orig_argv.\n 2. The config file arguments are read from the config files (.cnf and\n   persisted read-only) and are appended as command line arguments.\n   In the process the argv is deep copied because of the expansion\n 3. The result from 2 is set into @ref remaining_argv / @ref remaining_argc.\n 4. Then remaining_argv is fed into various consumers:\n   - the server compiled in set of arguments\n   - the early plugins\n   - the rest of the plugins\n   - the error log\n   - the components from the persisted dynamic loader init.\n   All of the above \"take away\" the values they match from the extended\n   command line set. And vary the values of @ref my_getopt_skip_unknown\n   according to their needs (mostly keep it set).\n   As a result, when the server is done booting up the things that remain\n   in remaining_argv become less and less.\n 5. When the bootstrap process is done a check is run:\n    my_getopt_skip_unknown is set to off and the argument parser is called\n    on remaining_argv with an empty set of argument definitions.\n    This ensures that all of the remaining argument values in remaining_argv\n    are either marked as \"loose\" (i.e. optional) or are \"consumed\" by prior\n    argument list processings.\n    The side effect of this is that all --loose arguments are also consumed\n    out of remaining_argv.\n 6. A check is made if the remaining_argv is an empty list. If not the server\n    exits.\n 7. At this point the server is marked as succesfully started.\n 8. Subsequent argument processings happen when e.g. a plugin is loaded via\n    @ref mysql_install_plugin or a component registers system variables via\n    @ref mysql_component_sys_variable_imp::register_variable. However, since\n    remaining_argv is empty these need to run over the orig_argc/orig_argv.\n    But argument value assignment would normally \"eat\" out the values found.\n    This would mean that the orig_argv array will get shortened and if you\n    load the same plugin twice for example its system variables will not have\n    the values supplied the second time they start.\n    Thus once the server is started (@ref mysqld_server_started is on) any\n    argument value parsing should happen over a *copy* of orig_argc/orig_argv\n    that should subsequently be discarded.\n    @ref remaining_argv should not be consulted anymore at this point.\n*/\nint orig_argc;\nchar **orig_argv;\nnamespace {\nFILE *nstdout = nullptr;\nchar my_progpath[FN_REFLEN];\nconst char *my_orig_progname = nullptr;\n\n/**\n  This variable holds the exit value of the signal handler thread.\n*/\nstd::atomic<int> signal_hand_thr_exit_code(MYSQLD_SUCCESS_EXIT);\n\n/**\n  Inspects the program name in argv[0] and substitutes the full path\n  of the executable.\n\n  @param argv argument vector (array) for executable.\n */\nvoid substitute_progpath(char **argv) {\n  if (test_if_hard_path(argv[0])) return;\n\n#if defined(_WIN32)\n  if (GetModuleFileName(NULL, my_progpath, sizeof(my_progpath))) {\n    my_orig_progname = argv[0];\n    argv[0] = my_progpath;\n  }\n#else\n  /* If the path has a directory component, use my_realpath()\n     (implicitly relative to cwd) */\n  if (strchr(argv[0], FN_LIBCHAR) != nullptr &&\n      !my_realpath(my_progpath, argv[0], MYF(0))) {\n    my_orig_progname = argv[0];\n    argv[0] = my_progpath;\n    return;\n  }\n\n  // my_realpath() cannot resolve it, it must be a bare executable\n  // name in path\n  DBUG_ASSERT(strchr(argv[0], FN_LIBCHAR) == nullptr);\n\n  const char *spbegin = getenv(\"PATH\");\n  if (spbegin == nullptr) spbegin = \"\";\n  const char *spend = spbegin + strlen(spbegin);\n\n  while (true) {\n    const char *colonend = std::find(spbegin, spend, ':');\n    std::string cand{spbegin, colonend};\n    spbegin = colonend + 1;\n\n    cand.append(1, '/');\n    cand.append(argv[0]);\n\n    if (my_access(cand.c_str(), X_OK) == 0) {\n      if (my_realpath(my_progpath, cand.c_str(), MYF(0))) {\n        // Fallback to raw cand\n        DBUG_ASSERT(cand.length() < FN_REFLEN);\n        std::copy(cand.begin(), cand.end(), my_progpath);\n        my_progpath[cand.length()] = '\\0';\n      }\n      my_orig_progname = argv[0];\n      argv[0] = my_progpath;\n      break;\n    }\n    if (colonend == spend) {\n      DBUG_ASSERT(false);\n      break;\n    }\n  }  // while (true)\n#endif  // defined(_WIN32)\n  if (my_orig_progname == nullptr) {\n    LogErr(WARNING_LEVEL, ER_FAILED_TO_GET_ABSOLUTE_PATH, argv[0]);\n  }\n}\n}  // namespace\n\nstatic Connection_acceptor<Mysqld_socket_listener> *mysqld_socket_acceptor =\n    nullptr;\n#ifdef _WIN32\nstatic Named_pipe_listener *named_pipe_listener = NULL;\nConnection_acceptor<Named_pipe_listener> *named_pipe_acceptor = NULL;\nConnection_acceptor<Shared_mem_listener> *shared_mem_acceptor = NULL;\nmysql_rwlock_t LOCK_named_pipe_full_access_group;\nchar *named_pipe_full_access_group;\n#endif\n\nCheckable_rwlock *global_sid_lock = nullptr;\nSid_map *global_sid_map = nullptr;\nGtid_state *gtid_state = nullptr;\nGtid_table_persistor *gtid_table_persistor = nullptr;\n\n/* cache for persisted variables */\nstatic Persisted_variables_cache persisted_variables_cache;\n\nvoid set_remaining_args(int argc, char **argv) {\n  remaining_argc = argc;\n  remaining_argv = argv;\n}\n\nint *get_remaining_argc() { return &remaining_argc; }\n\nchar ***get_remaining_argv() { return &remaining_argv; }\n\n/*\n  Multiple threads of execution use the random state maintained in global\n  sql_rand to generate random numbers. sql_rnd_with_mutex use mutex\n  LOCK_sql_rand to protect sql_rand across multiple instantiations that use\n  sql_rand to generate random numbers.\n */\nulong sql_rnd_with_mutex() {\n  mysql_mutex_lock(&LOCK_sql_rand);\n  ulong tmp =\n      (ulong)(my_rnd(&sql_rand) * 0xffffffff); /* make all bits random */\n  mysql_mutex_unlock(&LOCK_sql_rand);\n  return tmp;\n}\n\nstruct System_status_var *get_thd_status_var(THD *thd, bool *aggregated) {\n  *aggregated = thd->status_var_aggregated;\n  return &thd->status_var;\n}\n\nstatic void option_error_reporter(enum loglevel level, uint ecode, ...) {\n  va_list args;\n  va_start(args, ecode);\n\n  /*\n    Don't print warnings for --loose options during initialize.\n  */\n  if (level == ERROR_LEVEL || !opt_initialize || (log_error_verbosity > 1)) {\n    error_log_print(level, ecode, args);\n  }\n  va_end(args);\n}\n\n/**\n  Character set and collation error reporter that prints to sql error log.\n  @param level          log message level\n  @param ecode          Error code of the error message.\n\n  This routine is used to print character set and collation\n  warnings and errors inside an already running mysqld server,\n  e.g. when a character set or collation is requested for the very first time\n  and its initialization does not go well for some reasons.\n*/\n\nstatic void charset_error_reporter(enum loglevel level, uint ecode, ...) {\n  va_list args;\n  va_start(args, ecode);\n  error_log_print(level, ecode, args);\n  va_end(args);\n}\n\nstruct rand_struct sql_rand;  ///< used by sql_class.cc:THD::THD()\n\n#ifndef _WIN32\nPasswdValue user_info;\nstatic my_thread_t main_thread_id;\n#endif  // !_WIN32\n\n/* OS specific variables */\n\n#ifdef _WIN32\nstatic bool mysqld_early_option = false;\nstatic bool windows_service = false;\nstatic bool use_opt_args;\nstatic int opt_argc;\nstatic char **opt_argv;\nstatic char **my_global_argv = nullptr;\nstatic int my_global_argc;\n\nstatic mysql_mutex_t LOCK_handler_count;\nstatic mysql_cond_t COND_handler_count;\nstatic HANDLE hEventShutdown;\nstatic HANDLE hEventRestart;\nconst char *shared_memory_base_name = default_shared_memory_base_name;\nbool opt_enable_shared_memory;\nstatic char shutdown_event_name[40];\nstatic char restart_event_name[40];\nstatic NTService Service;  ///< Service object for WinNT\n#endif                     /* _WIN32 */\n\nstatic bool dynamic_plugins_are_initialized = false;\n\n#ifndef DBUG_OFF\nstatic const char *default_dbug_option;\n#endif\n\nbool opt_use_ssl = true;\nulong opt_ssl_fips_mode = SSL_FIPS_MODE_OFF;\n\n/* Function declarations */\n\nstatic int mysql_init_variables();\nstatic int get_options(int *argc_ptr, char ***argv_ptr);\nstatic void add_terminator(vector<my_option> *options);\nextern \"C\" bool mysqld_get_one_option(int, const struct my_option *, char *);\nstatic void set_server_version(void);\nstatic int init_thread_environment();\nstatic const char *get_relative_path(const char *path);\nstatic int fix_paths(void);\nstatic int test_if_case_insensitive(const char *dir_name);\nstatic void end_ssl();\nstatic void delete_dictionary_tablespace();\n\nextern \"C\" void *signal_hand(void *arg);\nstatic bool pid_file_created = false;\nstatic void usage(void);\nstatic void clean_up_mutexes(void);\nstatic bool create_pid_file();\nstatic void mysqld_exit(int exit_code) MY_ATTRIBUTE((noreturn));\nstatic void delete_pid_file(myf flags);\nstatic void clean_up(bool print_message);\nstatic int handle_early_options();\nstatic void adjust_related_options(ulong *requested_open_files);\nstatic void process_bootstrap();\n#ifdef HAVE_PSI_INTERFACE\nstatic void init_server_psi_keys();\n#endif\n\n/**\n  Notify any waiters that the server components have been initialized.\n  Used by the signal handler thread and by Cluster.\n\n  @see signal_hand\n*/\n\nstatic void server_components_initialized() {\n  mysql_mutex_lock(&LOCK_server_started);\n  mysqld_server_started = true;\n  mysql_cond_broadcast(&COND_server_started);\n  mysql_mutex_unlock(&LOCK_server_started);\n}\n\nSERVICE_TYPE(mysql_runtime_error) * error_service;\nSERVICE_TYPE(mysql_psi_system_v1) * system_service;\nSERVICE_TYPE(mysql_rwlock_v1) * rwlock_service;\nSERVICE_TYPE_NO_CONST(registry) * srv_registry;\nSERVICE_TYPE(dynamic_loader_scheme_file) * scheme_file_srv;\nusing loader_type_t = SERVICE_TYPE_NO_CONST(dynamic_loader);\nusing runtime_error_type_t = SERVICE_TYPE_NO_CONST(mysql_runtime_error);\nusing psi_system_type_t = SERVICE_TYPE_NO_CONST(mysql_psi_system_v1);\nusing rwlock_type_t = SERVICE_TYPE_NO_CONST(mysql_rwlock_v1);\nusing loader_scheme_type_t = SERVICE_TYPE_NO_CONST(dynamic_loader_scheme_file);\nextern REQUIRES_SERVICE_PLACEHOLDER(mysql_rwlock_v1);\nextern REQUIRES_SERVICE_PLACEHOLDER(mysql_psi_system_v1);\nextern bool initialize_minimal_chassis(SERVICE_TYPE_NO_CONST(registry) *\n                                       *registry);\nextern bool deinitialize_minimal_chassis(SERVICE_TYPE_NO_CONST(registry) *\n                                         registry);\n\n/**\n  Initializes component infrastructure by bootstrapping core component\n  subsystem.\n\n  @return Status of performed operation\n  @retval false success\n  @retval true failure\n*/\nstatic bool component_infrastructure_init() {\n  if (initialize_minimal_chassis(&srv_registry)) {\n    LogErr(ERROR_LEVEL, ER_COMPONENTS_INFRASTRUCTURE_BOOTSTRAP);\n    return true;\n  }\n  /* Here minimal_chassis dynamic_loader_scheme_file service has\n     to be acquired */\n  srv_registry->acquire(\n      \"dynamic_loader_scheme_file.mysql_minimal_chassis\",\n      reinterpret_cast<my_h_service *>(\n          const_cast<loader_scheme_type_t **>(&scheme_file_srv)));\n\n  srv_registry->acquire(\"dynamic_loader\",\n                        reinterpret_cast<my_h_service *>(\n                            const_cast<loader_type_t **>(&dynamic_loader_srv)));\n\n  my_service<SERVICE_TYPE(registry_registration)> registrator(\n      \"registry_registration\", srv_registry);\n\n  // Sets default file scheme loader for MySQL server.\n  registrator->set_default(\n      \"dynamic_loader_scheme_file.mysql_server_path_filter\");\n\n  // Sets default rw_lock for MySQL server.\n  registrator->set_default(\"mysql_rwlock_v1.mysql_server\");\n  srv_registry->acquire(\"mysql_rwlock_v1.mysql_server\",\n                        reinterpret_cast<my_h_service *>(\n                            const_cast<rwlock_type_t **>(&rwlock_service)));\n  mysql_service_mysql_rwlock_v1 =\n      reinterpret_cast<SERVICE_TYPE(mysql_rwlock_v1) *>(rwlock_service);\n\n  // Sets default psi_system event service for MySQL server.\n  registrator->set_default(\"mysql_psi_system_v1.mysql_server\");\n  srv_registry->acquire(\"mysql_psi_system_v1.mysql_server\",\n                        reinterpret_cast<my_h_service *>(\n                            const_cast<psi_system_type_t **>(&system_service)));\n  /* This service variable is needed for mysql_unload_plugin */\n  mysql_service_mysql_psi_system_v1 =\n      reinterpret_cast<SERVICE_TYPE(mysql_psi_system_v1) *>(system_service);\n\n  // Sets default mysql_runtime_error for MySQL server.\n  registrator->set_default(\"mysql_runtime_error.mysql_server\");\n  srv_registry->acquire(\n      \"mysql_runtime_error.mysql_server\",\n      reinterpret_cast<my_h_service *>(\n          const_cast<runtime_error_type_t **>(&error_service)));\n  /* This service variable is needed where ever mysql_error_service_printf()\n     service api is used */\n  mysql_service_mysql_runtime_error =\n      reinterpret_cast<SERVICE_TYPE(mysql_runtime_error) *>(error_service);\n\n  return false;\n}\n\n/**\n  This function is used to initialize the mysql_server component services.\n*/\nstatic void server_component_init() { mysql_comp_sys_var_services_init(); }\n\n/**\n  Initializes MySQL Server component infrastructure part by initialize of\n  dynamic loader persistence.\n\n  @return Status of performed operation\n  @retval false success\n  @retval true failure\n*/\n\nstatic bool mysql_component_infrastructure_init() {\n  /* We need a temporary THD during boot */\n  Auto_THD thd;\n  Disable_autocommit_guard autocommit_guard(thd.thd);\n  dd::cache::Dictionary_client::Auto_releaser scope_releaser(\n      thd.thd->dd_client());\n  if (persistent_dynamic_loader_init(thd.thd)) {\n    LogErr(ERROR_LEVEL, ER_COMPONENTS_PERSIST_LOADER_BOOTSTRAP);\n    trans_rollback_stmt(thd.thd);\n    // Full rollback in case we have THD::transaction_rollback_request.\n    trans_rollback(thd.thd);\n    return true;\n  }\n  server_component_init();\n  return trans_commit_stmt(thd.thd) || trans_commit(thd.thd);\n}\n\n/**\n  De-initializes Component infrastructure by de-initialization of the MySQL\n  Server services (persistent dynamic loader) followed by de-initailization of\n  the core Components infrostructure.\n\n  @return Status of performed operation\n  @retval false success\n  @retval true failure\n*/\nstatic bool component_infrastructure_deinit() {\n  persistent_dynamic_loader_deinit();\n\n  srv_registry->release(reinterpret_cast<my_h_service>(\n      const_cast<loader_scheme_type_t *>(scheme_file_srv)));\n  srv_registry->release(reinterpret_cast<my_h_service>(\n      const_cast<loader_type_t *>(dynamic_loader_srv)));\n  srv_registry->release(reinterpret_cast<my_h_service>(\n      const_cast<runtime_error_type_t *>(error_service)));\n  srv_registry->release(reinterpret_cast<my_h_service>(\n      const_cast<psi_system_type_t *>(system_service)));\n  srv_registry->release(reinterpret_cast<my_h_service>(\n      const_cast<rwlock_type_t *>(rwlock_service)));\n\n  if (deinitialize_minimal_chassis(srv_registry)) {\n    LogErr(ERROR_LEVEL, ER_COMPONENTS_INFRASTRUCTURE_SHUTDOWN);\n    return true;\n  }\n  return false;\n}\n\n/**\n  Block and wait until server components have been initialized.\n*/\n\nstatic void server_components_init_wait() {\n  mysql_mutex_lock(&LOCK_server_started);\n  while (!mysqld_server_started)\n    mysql_cond_wait(&COND_server_started, &LOCK_server_started);\n  mysql_mutex_unlock(&LOCK_server_started);\n}\n\n/****************************************************************************\n** Code to end mysqld\n****************************************************************************/\n\n/**\n  This class implements callback function used by close_connections()\n  to set KILL_CONNECTION flag on all thds in thd list.\n  If m_kill_dump_thread_flag is not set it kills all other threads\n  except dump threads. If this flag is set, it kills dump threads.\n*/\nclass Set_kill_conn : public Do_THD_Impl {\n private:\n  int m_dump_thread_count;\n  bool m_kill_dump_threads_flag;\n\n public:\n  Set_kill_conn() : m_dump_thread_count(0), m_kill_dump_threads_flag(false) {}\n\n  void set_dump_thread_flag() { m_kill_dump_threads_flag = true; }\n\n  int get_dump_thread_count() const { return m_dump_thread_count; }\n\n  virtual void operator()(THD *killing_thd) {\n    DBUG_PRINT(\"quit\", (\"Informing thread %u that it's time to die\",\n                        killing_thd->thread_id()));\n    if (!m_kill_dump_threads_flag) {\n      // We skip slave threads & scheduler on this first loop through.\n      if (killing_thd->slave_thread) return;\n\n      if (killing_thd->get_command() == COM_BINLOG_DUMP ||\n          killing_thd->get_command() == COM_BINLOG_DUMP_GTID) {\n        ++m_dump_thread_count;\n        return;\n      }\n      DBUG_EXECUTE_IF(\"Check_dump_thread_is_alive\", {\n        DBUG_ASSERT(killing_thd->get_command() != COM_BINLOG_DUMP &&\n                    killing_thd->get_command() != COM_BINLOG_DUMP_GTID);\n      };);\n    }\n    mysql_mutex_lock(&killing_thd->LOCK_thd_data);\n\n    if (killing_thd->kill_immunizer) {\n      /*\n        If killing_thd is in kill immune mode (i.e. operation on new DD tables\n        is in progress) then just save state_to_set with THD::kill_immunizer\n        object.\n\n        While exiting kill immune mode, awake() is called again with the killed\n        state saved in THD::kill_immunizer object.\n      */\n      killing_thd->kill_immunizer->save_killed_state(THD::KILL_CONNECTION);\n    } else {\n      killing_thd->killed = THD::KILL_CONNECTION;\n\n      MYSQL_CALLBACK(killing_thd->scheduler, post_kill_notification,\n                     (killing_thd));\n    }\n\n    if (killing_thd->is_killable && killing_thd->kill_immunizer == nullptr) {\n      mysql_mutex_lock(&killing_thd->LOCK_current_cond);\n      if (killing_thd->current_cond.load()) {\n        mysql_mutex_lock(killing_thd->current_mutex);\n        mysql_cond_broadcast(killing_thd->current_cond);\n        mysql_mutex_unlock(killing_thd->current_mutex);\n      }\n      mysql_mutex_unlock(&killing_thd->LOCK_current_cond);\n    }\n    mysql_mutex_unlock(&killing_thd->LOCK_thd_data);\n  }\n};\n\n/**\n  This class implements callback function used by close_connections()\n  to close vio connection for all thds in thd list\n*/\nclass Call_close_conn : public Do_THD_Impl {\n public:\n  Call_close_conn(bool server_shutdown) : is_server_shutdown(server_shutdown) {}\n\n  virtual void operator()(THD *closing_thd) {\n    if (closing_thd->get_protocol()->connection_alive()) {\n      LEX_CSTRING main_sctx_user = closing_thd->m_main_security_ctx.user();\n      LogErr(WARNING_LEVEL, ER_FORCE_CLOSE_THREAD, my_progname,\n             (long)closing_thd->thread_id(),\n             (main_sctx_user.length ? main_sctx_user.str : \"\"));\n      /*\n        Do not generate MYSQL_AUDIT_CONNECTION_DISCONNECT event, when closing\n        thread close sessions. Each session will generate DISCONNECT event by\n        itself.\n      */\n      close_connection(closing_thd, 0, is_server_shutdown, false);\n    }\n  }\n\n private:\n  bool is_server_shutdown;\n};\n\nstatic void close_connections(void) {\n  DBUG_TRACE;\n  (void)RUN_HOOK(server_state, before_server_shutdown, (nullptr));\n\n  Per_thread_connection_handler::kill_blocked_pthreads();\n\n  uint dump_thread_count = 0;\n  uint dump_thread_kill_retries = 8;\n\n  // Close listeners.\n  if (mysqld_socket_acceptor != nullptr)\n    mysqld_socket_acceptor->close_listener();\n#ifdef _WIN32\n  if (named_pipe_acceptor != NULL) named_pipe_acceptor->close_listener();\n\n  if (shared_mem_acceptor != NULL) shared_mem_acceptor->close_listener();\n#endif\n\n  /*\n    First signal all threads that it's time to die\n    This will give the threads some time to gracefully abort their\n    statements and inform their clients that the server is about to die.\n  */\n\n  Global_THD_manager *thd_manager = Global_THD_manager::get_instance();\n  LogErr(INFORMATION_LEVEL, ER_DEPART_WITH_GRACE,\n         static_cast<int>(thd_manager->get_thd_count()));\n\n  Set_kill_conn set_kill_conn;\n  thd_manager->do_for_all_thd(&set_kill_conn);\n  LogErr(INFORMATION_LEVEL, ER_SHUTTING_DOWN_SLAVE_THREADS);\n  end_slave();\n\n  if (set_kill_conn.get_dump_thread_count()) {\n    /*\n      Replication dump thread should be terminated after the clients are\n      terminated. Wait for few more seconds for other sessions to end.\n     */\n    while (thd_manager->get_thd_count() > dump_thread_count &&\n           dump_thread_kill_retries) {\n      sleep(1);\n      dump_thread_kill_retries--;\n    }\n    set_kill_conn.set_dump_thread_flag();\n    thd_manager->do_for_all_thd(&set_kill_conn);\n  }\n\n  // Disable the event scheduler\n  Events::stop();\n\n  if (thd_manager->get_thd_count() > 0) sleep(2);  // Give threads time to die\n\n  /*\n    Force remaining threads to die by closing the connection to the client\n    This will ensure that threads that are waiting for a command from the\n    client on a blocking read call are aborted.\n  */\n\n  LogErr(INFORMATION_LEVEL, ER_DISCONNECTING_REMAINING_CLIENTS,\n         static_cast<int>(thd_manager->get_thd_count()));\n\n  Call_close_conn call_close_conn(true);\n  thd_manager->do_for_all_thd(&call_close_conn);\n\n  (void)RUN_HOOK(server_state, after_server_shutdown, (nullptr));\n\n  /*\n    All threads have now been aborted. Stop event scheduler thread\n    after aborting all client connections, otherwise user may\n    start/stop event scheduler after Events::deinit() deallocates\n    scheduler object(static member in Events class)\n  */\n  Events::deinit();\n  DBUG_PRINT(\"quit\", (\"Waiting for threads to die (count=%u)\",\n                      thd_manager->get_thd_count()));\n  thd_manager->wait_till_no_thd();\n  /*\n    Connection threads might take a little while to go down after removing from\n    global thread list. Give it some time.\n  */\n  Connection_handler_manager::wait_till_no_connection();\n\n  delete_slave_info_objects();\n  DBUG_PRINT(\"quit\", (\"close_connections thread\"));\n}\n\nbool signal_restart_server() {\n  if (!is_mysqld_managed()) {\n    my_error(ER_RESTART_SERVER_FAILED, MYF(0),\n             \"mysqld is not managed by supervisor process\");\n    return true;\n  }\n\n#ifdef _WIN32\n  if (!SetEvent(hEventRestart)) {\n    LogErr(ERROR_LEVEL, ER_SET_EVENT_FAILED, GetLastError());\n    my_error(ER_RESTART_SERVER_FAILED, MYF(0), \"Internal operation failure\");\n    return true;\n  }\n#else\n\n  if (pthread_kill(signal_thread_id.thread, SIGUSR2)) {\n    DBUG_PRINT(\"error\", (\"Got error %d from pthread_kill\", errno));\n    my_error(ER_RESTART_SERVER_FAILED, MYF(0), \"Internal operation failure\");\n    return true;\n  }\n#endif\n  return false;\n}\n\nvoid kill_mysql(void) {\n  DBUG_TRACE;\n\n  if (!mysqld_server_started) {\n    mysqld_process_must_end_at_startup = true;\n    return;\n  }\n#if defined(_WIN32)\n  {\n    if (!SetEvent(hEventShutdown)) {\n      DBUG_PRINT(\"error\", (\"Got error: %ld from SetEvent\", GetLastError()));\n    }\n    /*\n      or:\n      HANDLE hEvent=OpenEvent(0, false, \"MySqlShutdown\");\n      SetEvent(hEventShutdown);\n      CloseHandle(hEvent);\n    */\n  }\n#else\n  if (pthread_kill(signal_thread_id.thread, SIGTERM)) {\n    DBUG_PRINT(\"error\", (\"Got error %d from pthread_kill\",\n                         errno)); /* purecov: inspected */\n  }\n#endif\n  DBUG_PRINT(\"quit\", (\"After pthread_kill\"));\n}\n\nstatic void unireg_abort(int exit_code) {\n  DBUG_TRACE;\n\n  if (errno) {\n    sysd::notify(\"ERRNO=\", errno, \"\\n\");\n  }\n\n  if (opt_initialize && exit_code && !opt_validate_config)\n    LogErr(ERROR_LEVEL,\n           mysql_initialize_directory_freshly_created\n               ? ER_DATA_DIRECTORY_UNUSABLE_DELETABLE\n               : ER_DATA_DIRECTORY_UNUSABLE,\n           mysql_real_data_home);\n\n  // At this point it does not make sense to buffer more messages.\n  // Just flush what we have and write directly to stderr.\n  flush_error_log_messages();\n\n  if (opt_help) usage();\n\n  bool daemon_launcher_quiet =\n      (IF_WIN(false, opt_daemonize) && !mysqld::runtime::is_daemon() &&\n       !is_help_or_validate_option());\n\n  if (!daemon_launcher_quiet && exit_code) LogErr(ERROR_LEVEL, ER_ABORTING);\n\n  mysql_audit_notify(MYSQL_AUDIT_SERVER_SHUTDOWN_SHUTDOWN,\n                     MYSQL_AUDIT_SERVER_SHUTDOWN_REASON_ABORT, exit_code);\n#ifndef _WIN32\n  if (signal_thread_id.thread != 0) {\n    // Make sure the signal thread isn't blocked when we are trying to exit.\n    server_components_initialized();\n\n    pthread_kill(signal_thread_id.thread, SIGTERM);\n    my_thread_join(&signal_thread_id, nullptr);\n  }\n  signal_thread_id.thread = 0;\n\n  if (mysqld::runtime::is_daemon()) {\n    mysqld::runtime::signal_parent(pipe_write_fd, 0);\n  }\n#endif\n  clean_up(!is_help_or_validate_option() && !daemon_launcher_quiet &&\n           (exit_code || !opt_initialize)); /* purecov: inspected */\n  DBUG_PRINT(\"quit\", (\"done with cleanup in unireg_abort\"));\n  mysqld_exit(exit_code);\n}\n\nvoid clean_up_mysqld_mutexes() { clean_up_mutexes(); }\n\nstatic void mysqld_exit(int exit_code) {\n  DBUG_ASSERT(\n      (exit_code >= MYSQLD_SUCCESS_EXIT && exit_code <= MYSQLD_ABORT_EXIT) ||\n      exit_code == MYSQLD_RESTART_EXIT);\n  mysql_audit_finalize();\n  Srv_session::module_deinit();\n  delete_optimizer_cost_module();\n  clean_up_mutexes();\n  my_end(opt_endinfo ? MY_CHECK_ERROR | MY_GIVE_INFO : 0);\n  destroy_error_log();\n#ifdef WITH_PERFSCHEMA_STORAGE_ENGINE\n  shutdown_performance_schema();\n#endif\n\n#ifdef WITH_LOCK_ORDER\n  LO_cleanup();\n#endif\n\n#if defined(_WIN32)\n  if (hEventShutdown) CloseHandle(hEventShutdown);\n  close_service_status_pipe_in_mysqld();\n#endif  // _WIN32\n\n  exit(exit_code); /* purecov: inspected */\n}\n\n/**\n   GTID cleanup destroys objects and reset their pointer.\n   Function is reentrant.\n*/\nvoid gtid_server_cleanup() {\n  if (gtid_state != nullptr) {\n    delete gtid_state;\n    gtid_state = nullptr;\n  }\n  if (global_sid_map != nullptr) {\n    delete global_sid_map;\n    global_sid_map = nullptr;\n  }\n  if (global_sid_lock != nullptr) {\n    delete global_sid_lock;\n    global_sid_lock = nullptr;\n  }\n  if (gtid_table_persistor != nullptr) {\n    delete gtid_table_persistor;\n    gtid_table_persistor = nullptr;\n  }\n  if (gtid_mode_lock) {\n    delete gtid_mode_lock;\n    gtid_mode_lock = nullptr;\n  }\n}\n\n/**\n   GTID initialization.\n\n   @return true if allocation does not succeed\n           false if OK\n*/\nbool gtid_server_init() {\n  bool res = (!(global_sid_lock = new Checkable_rwlock(\n#ifdef HAVE_PSI_INTERFACE\n                    key_rwlock_global_sid_lock\n#endif\n                    )) ||\n              !(gtid_mode_lock = new Checkable_rwlock(\n#ifdef HAVE_PSI_INTERFACE\n                    key_rwlock_gtid_mode_lock\n#endif\n                    )) ||\n              !(global_sid_map = new Sid_map(global_sid_lock)) ||\n              !(gtid_state = new Gtid_state(global_sid_lock, global_sid_map)) ||\n              !(gtid_table_persistor = new Gtid_table_persistor()));\n\n  gtid_mode_counter = 1;\n\n  if (res) {\n    gtid_server_cleanup();\n  }\n  return res;\n}\n\n// Free connection acceptors\nstatic void free_connection_acceptors() {\n  delete mysqld_socket_acceptor;\n  mysqld_socket_acceptor = nullptr;\n\n#ifdef _WIN32\n  delete named_pipe_acceptor;\n  named_pipe_acceptor = NULL;\n  delete shared_mem_acceptor;\n  shared_mem_acceptor = NULL;\n#endif\n}\n\nstatic void clean_up(bool print_message) {\n  DBUG_PRINT(\"exit\", (\"clean_up\"));\n  if (cleanup_done++) return; /* purecov: inspected */\n\n  ha_pre_dd_shutdown();\n  dd::shutdown();\n\n  Events::deinit();\n  stop_handle_manager();\n\n  memcached_shutdown();\n\n  /*\n    make sure that handlers finish up\n    what they have that is dependent on the binlog\n  */\n  if (print_message && (!is_help_or_validate_option() || opt_verbose))\n    LogErr(INFORMATION_LEVEL, ER_BINLOG_END);\n  ha_binlog_end(current_thd);\n\n  injector::free_instance();\n  mysql_bin_log.cleanup();\n\n  if (use_slave_mask) bitmap_free(&slave_error_mask);\n  my_tz_free();\n  servers_free(true);\n  acl_free(true);\n  grant_free();\n  hostname_cache_free();\n  range_optimizer_free();\n  item_func_sleep_free();\n  lex_free(); /* Free some memory */\n  item_create_cleanup();\n  if (!opt_noacl) udf_unload_udfs();\n  table_def_start_shutdown();\n  plugin_shutdown();\n  gtid_server_cleanup();  // after plugin_shutdown\n  delete_optimizer_cost_module();\n  ha_end();\n  if (tc_log) {\n    tc_log->close();\n    tc_log = nullptr;\n  }\n\n  if (dd::upgrade_57::in_progress()) delete_dictionary_tablespace();\n\n  Recovered_xa_transactions::destroy();\n  delegates_destroy();\n  transaction_cache_free();\n  MDL_context_backup_manager::destroy();\n  table_def_free();\n  mdl_destroy();\n  key_caches.delete_elements();\n  multi_keycache_free();\n  query_logger.cleanup();\n  free_tmpdir(&mysql_tmpdir_list);\n  my_free(opt_bin_logname);\n  free_max_user_conn();\n  free_global_user_stats();\n  free_global_client_stats();\n  free_global_thread_stats();\n  free_global_table_stats();\n  free_global_index_stats();\n  end_slave_list();\n  delete binlog_filter;\n  rpl_channel_filters.clean_up();\n  end_ssl();\n  vio_end();\n  u_cleanup();\n#if defined(ENABLED_DEBUG_SYNC)\n  /* End the debug sync facility. See debug_sync.cc. */\n  debug_sync_end();\n#endif /* defined(ENABLED_DEBUG_SYNC) */\n\n  delete_pid_file(MYF(0));\n\n  if (print_message && my_default_lc_messages && server_start_time)\n    LogErr(SYSTEM_LEVEL, ER_SERVER_SHUTDOWN_COMPLETE, my_progname,\n           server_version, MYSQL_COMPILATION_COMMENT_SERVER);\n  cleanup_errmsgs();\n\n  free_connection_acceptors();\n  Connection_handler_manager::destroy_instance();\n\n  if (!is_help_or_validate_option() && !opt_initialize)\n    resourcegroups::Resource_group_mgr::destroy_instance();\n  mysql_client_plugin_deinit();\n  finish_client_errs();\n  deinit_errmessage();  // finish server errs\n  DBUG_PRINT(\"quit\", (\"Error messages freed\"));\n\n  Global_THD_manager::destroy_instance();\n\n  my_free(const_cast<char *>(log_bin_basename));\n  my_free(const_cast<char *>(log_bin_index));\n  my_free(const_cast<char *>(relay_log_basename));\n  my_free(const_cast<char *>(relay_log_index));\n  free_list(opt_early_plugin_load_list_ptr);\n  free_list(opt_plugin_load_list_ptr);\n\n  /*\n    Is this the best place for components deinit? It may be changed when new\n    dependencies are discovered, possibly being divided into separate points\n    where all dependencies are still ok.\n  */\n  log_error_stage_set(LOG_ERROR_STAGE_SHUTTING_DOWN);\n  log_builtins_error_stack(LOG_ERROR_SERVICES_DEFAULT, false, nullptr);\n#ifdef HAVE_PSI_THREAD_INTERFACE\n  if (!is_help_or_validate_option() && !opt_initialize) {\n    unregister_pfs_notification_service();\n    unregister_pfs_resource_group_service();\n  }\n#endif\n  component_infrastructure_deinit();\n  /*\n    component unregister_variable() api depends on system_variable_hash.\n    component_infrastructure_deinit() interns calls the deinit funtion\n    of components which are loaded, and the deinit functions can have\n    the component system unregister_ variable()  api's, hence we need\n    to call the sys_var_end() after component_infrastructure_deinit()\n  */\n  sys_var_end();\n  free_status_vars();\n\n  if (have_statement_timeout == SHOW_OPTION_YES) my_timer_deinitialize();\n\n  have_statement_timeout = SHOW_OPTION_DISABLED;\n\n  persisted_variables_cache.cleanup();\n\n  udf_deinit_globals();\n  /*\n    The following lines may never be executed as the main thread may have\n    killed us\n  */\n  DBUG_PRINT(\"quit\", (\"done with cleanup\"));\n} /* clean_up */\n\nstatic void clean_up_mutexes() {\n  mysql_mutex_destroy(&LOCK_log_throttle_qni);\n  mysql_mutex_destroy(&LOCK_status);\n  mysql_mutex_destroy(&LOCK_manager);\n  mysql_mutex_destroy(&LOCK_crypt);\n  mysql_mutex_destroy(&LOCK_user_conn);\n  mysql_rwlock_destroy(&LOCK_sys_init_connect);\n  mysql_rwlock_destroy(&LOCK_sys_init_slave);\n  mysql_mutex_destroy(&LOCK_global_system_variables);\n  mysql_rwlock_destroy(&LOCK_system_variables_hash);\n  mysql_mutex_destroy(&LOCK_uuid_generator);\n  mysql_mutex_destroy(&LOCK_sql_rand);\n  mysql_mutex_destroy(&LOCK_prepared_stmt_count);\n  mysql_mutex_destroy(&LOCK_sql_slave_skip_counter);\n  mysql_mutex_destroy(&LOCK_slave_net_timeout);\n  mysql_mutex_destroy(&LOCK_slave_trans_dep_tracker);\n  mysql_mutex_destroy(&LOCK_error_messages);\n  mysql_mutex_destroy(&LOCK_default_password_lifetime);\n  mysql_mutex_destroy(&LOCK_mandatory_roles);\n  mysql_mutex_destroy(&LOCK_server_started);\n  mysql_cond_destroy(&COND_server_started);\n  mysql_mutex_destroy(&LOCK_reset_gtid_table);\n  mysql_mutex_destroy(&LOCK_compress_gtid_table);\n  mysql_cond_destroy(&COND_compress_gtid_table);\n  mysql_mutex_destroy(&LOCK_collect_instance_log);\n  mysql_mutex_destroy(&LOCK_password_history);\n  mysql_mutex_destroy(&LOCK_password_reuse_interval);\n  mysql_cond_destroy(&COND_manager);\n#ifdef _WIN32\n  mysql_cond_destroy(&COND_handler_count);\n  mysql_mutex_destroy(&LOCK_handler_count);\n  mysql_rwlock_destroy(&LOCK_named_pipe_full_access_group);\n#endif\n#ifndef _WIN32\n  mysql_cond_destroy(&COND_socket_listener_active);\n  mysql_mutex_destroy(&LOCK_socket_listener_active);\n  mysql_cond_destroy(&COND_start_signal_handler);\n  mysql_mutex_destroy(&LOCK_start_signal_handler);\n#endif\n  mysql_mutex_destroy(&LOCK_keyring_operations);\n  mysql_mutex_destroy(&LOCK_tls_ctx_options);\n  mysql_mutex_destroy(&LOCK_rotate_binlog_master_key);\n  mysql_mutex_destroy(&LOCK_global_user_client_stats);\n  mysql_mutex_destroy(&LOCK_global_table_stats);\n  mysql_mutex_destroy(&LOCK_global_index_stats);\n  mysql_rwlock_destroy(&LOCK_consistent_snapshot);\n}\n\n/****************************************************************************\n** Init IP and UNIX socket\n****************************************************************************/\n\n/* Initialise proxy protocol. */\nstatic void set_proxy() {\n  if (opt_disable_networking) return;\n\n  struct st_vio_network net;\n\n  /* Check for special case '*'. */\n  if (strcmp(my_proxy_protocol_networks, \"*\") == 0) {\n    memset(&net, 0, sizeof(net));\n    net.family = AF_INET;\n    vio_proxy_protocol_add(net);\n    net.family = AF_INET6;\n    vio_proxy_protocol_add(net);\n    return;\n  }\n\n  const char *p = my_proxy_protocol_networks;\n\n  while (1) {\n    /* jump spaces. */\n    while (*p == ' ') p++;\n    if (*p == '\\0') break;\n    const char *start = p;\n\n    /* look for separator */\n    while (*p != ',' && *p != '/' && *p != ' ' && *p != '\\0') p++;\n    if (p - start > INET6_ADDRSTRLEN) {\n      sql_print_error(\n          \"Too long network in 'proxy_protocol_networks' \"\n          \"directive.\");\n      unireg_abort(1);\n    }\n    char buffer[INET6_ADDRSTRLEN + 1 + 3 + 1];\n    memcpy(buffer, start, p - start);\n    buffer[p - start] = '\\0';\n\n    /* Try to convert to ipv4. */\n    if (inet_pton(AF_INET, buffer, &net.addr.in)) net.family = AF_INET;\n\n    /* Try to convert to ipv6. */\n    else if (inet_pton(AF_INET6, buffer, &net.addr.in6))\n      net.family = AF_INET6;\n\n    else {\n      sql_print_error(\n          \"Bad network '%s' in 'proxy_protocol_networks' \"\n          \"directive.\",\n          buffer);\n      unireg_abort(1);\n    }\n\n    /* Look for network. */\n    unsigned bits;\n    if (*p == '/') {\n      if (!my_isdigit(&my_charset_bin, *++p)) {\n        sql_print_error(\n            \"Missing network prefix in 'proxy_protocol_networks' \"\n            \"directive.\");\n        unireg_abort(1);\n      }\n      start = p;\n      bits = 0;\n      while (my_isdigit(&my_charset_bin, *p) && p - start < 3)\n        bits = bits * 10 + *p++ - '0';\n\n      /* Check bits value. */\n      if (net.family == AF_INET && bits > 32) {\n        sql_print_error(\n            \"Bad IPv4 mask in 'proxy_protocol_networks' \"\n            \"directive.\");\n        unireg_abort(1);\n      }\n      if (net.family == AF_INET6 && bits > 128) {\n        sql_print_error(\n            \"Bad IPv6 mask in 'proxy_protocol_networks' \"\n            \"directive.\");\n        unireg_abort(1);\n      }\n    } else {\n      if (net.family == AF_INET)\n        bits = 32;\n      else {\n        DBUG_ASSERT(net.family == AF_INET6);\n        bits = 128;\n      }\n    }\n\n    /* Build binary mask. */\n    if (net.family == AF_INET) {\n      /* Process IPv4 mask. */\n      if (bits == 0)\n        net.mask.in.s_addr = 0x00000000;\n      else if (bits == 32)\n        net.mask.in.s_addr = 0xffffffff;\n      else\n        net.mask.in.s_addr = ~((0x80000000 >> (bits - 1)) - 1);\n      net.mask.in.s_addr = htonl(net.mask.in.s_addr);\n\n      /* Apply mask */\n      struct in_addr check = net.addr.in;\n      check.s_addr &= net.mask.in.s_addr;\n\n      /* Check network. */\n      if (check.s_addr != net.addr.in.s_addr)\n        sql_print_warning(\n            \"The network mask hides a part of the address for \"\n            \"'%s/%d' in 'proxy_protocol_networks' directive.\",\n            buffer, bits);\n    } else {\n      /* Process IPv6 mask */\n      memset(&net.mask.in6, 0, sizeof(net.mask.in6));\n      if (bits > 0 && bits < 32) {\n        net.mask.in6.s6_addr32[0] = ~((0x80000000 >> (bits - 1)) - 1);\n      } else if (bits == 32) {\n        net.mask.in6.s6_addr32[0] = 0xffffffff;\n      } else if (bits > 32 && bits <= 64) {\n        net.mask.in6.s6_addr32[0] = 0xffffffff;\n        net.mask.in6.s6_addr32[1] =\n            (bits == 64) ? 0xffffffff : ~((0x80000000 >> (bits - 32 - 1)) - 1);\n      } else if (bits > 64 && bits <= 96) {\n        net.mask.in6.s6_addr32[0] = 0xffffffff;\n        net.mask.in6.s6_addr32[1] = 0xffffffff;\n        net.mask.in6.s6_addr32[2] =\n            (bits == 96) ? 0xffffffff : ~((0x80000000 >> (bits - 64 - 1)) - 1);\n      } else if (bits > 96) {\n        DBUG_ASSERT(bits <= 128);\n        net.mask.in6.s6_addr32[0] = 0xffffffff;\n        net.mask.in6.s6_addr32[1] = 0xffffffff;\n        net.mask.in6.s6_addr32[2] = 0xffffffff;\n        net.mask.in6.s6_addr32[3] =\n            (bits == 128) ? 0xffffffff : ~((0x80000000 >> (bits - 96 - 1)) - 1);\n      }\n\n      net.mask.in6.s6_addr32[0] = htonl(net.mask.in6.s6_addr32[0]);\n      net.mask.in6.s6_addr32[1] = htonl(net.mask.in6.s6_addr32[1]);\n      net.mask.in6.s6_addr32[2] = htonl(net.mask.in6.s6_addr32[2]);\n      net.mask.in6.s6_addr32[3] = htonl(net.mask.in6.s6_addr32[3]);\n\n      /* Apply mask */\n      struct in6_addr check = net.addr.in6;\n      check.s6_addr32[0] &= net.mask.in6.s6_addr32[0];\n      check.s6_addr32[1] &= net.mask.in6.s6_addr32[1];\n      check.s6_addr32[2] &= net.mask.in6.s6_addr32[2];\n      check.s6_addr32[3] &= net.mask.in6.s6_addr32[3];\n\n      /* Check network. */\n      if (memcmp(check.s6_addr, net.addr.in6.s6_addr, 16)) {\n        sql_print_warning(\n            \"The network mask hides a part of the address for \"\n            \"'%s/%d' in 'proxy_protocol_networks' directive.\",\n            buffer, bits);\n      }\n    }\n\n    if (*p != '\\0' && *p != ',') {\n      sql_print_error(\"Bad syntax in 'proxy_protocol_networks' directive.\");\n      unireg_abort(1);\n    }\n\n    /* add network. */\n    vio_proxy_protocol_add(net);\n\n    /* stop the parsing. */\n    if (*p == '\\0') break;\n    p++;\n  }\n}\n\nstatic void set_ports() {\n  char *env;\n  if (!mysqld_port &&\n      !opt_disable_networking) {  // Get port if not from commandline\n    mysqld_port = MYSQL_PORT;\n\n    /*\n      if builder specifically requested a default port, use that\n      (even if it coincides with our factory default).\n      only if they didn't do we check /etc/services (and, failing\n      on that, fall back to the factory default of 3306).\n      either default can be overridden by the environment variable\n      MYSQL_TCP_PORT, which in turn can be overridden with command\n      line options.\n    */\n\n#if MYSQL_PORT_DEFAULT == 0\n    struct servent *serv_ptr;\n    if ((serv_ptr = getservbyname(\"mysql\", \"tcp\")))\n      mysqld_port = ntohs((u_short)serv_ptr->s_port); /* purecov: inspected */\n#endif\n    if ((env = getenv(\"MYSQL_TCP_PORT\")))\n      mysqld_port = (uint)atoi(env); /* purecov: inspected */\n  }\n  if (!mysqld_unix_port) {\n#ifdef _WIN32\n    mysqld_unix_port = (char *)MYSQL_NAMEDPIPE;\n#else\n    mysqld_unix_port = MYSQL_UNIX_ADDR;\n#endif\n    if ((env = getenv(\"MYSQL_UNIX_PORT\")))\n      mysqld_unix_port = env; /* purecov: inspected */\n  }\n}\n\n#if !defined(_WIN32)\n/* Change to run as another user if started with --user */\n\nstatic PasswdValue check_user(const char *user) {\n  uid_t user_id = geteuid();\n\n  PasswdValue tmp_user_info =\n      (user == nullptr ? PasswdValue{} : my_getpwnam(user));\n\n  // Don't bother if we aren't superuser\n  if (user_id) {\n    if (user) {\n      /* Don't give a warning, if real user is same as given with --user */\n      if ((tmp_user_info.IsVoid() || user_id != tmp_user_info.pw_uid))\n        LogErr(WARNING_LEVEL, ER_USER_REQUIRES_ROOT);\n    }\n    return PasswdValue{};\n  }\n  DBUG_ASSERT(user_id == 0);  // we are running as root\n\n  if (!user) {\n    if (!opt_initialize && !is_help_or_validate_option()) {\n      LogErr(ERROR_LEVEL, ER_REALLY_RUN_AS_ROOT);\n      unireg_abort(MYSQLD_ABORT_EXIT);\n    }\n    return PasswdValue{};\n  }\n  /* purecov: begin tested */\n  if (!strcmp(user, \"root\"))\n    return PasswdValue{};  // Avoid problem with dynamic libraries\n\n  if (tmp_user_info.IsVoid()) {\n    // Allow a numeric uid to be used\n    const char *pos;\n    for (pos = user; my_isdigit(mysqld_charset, *pos); pos++)\n      ;\n    if (*pos)  // Not numeric id\n      goto err;\n\n    tmp_user_info = my_getpwuid(atoi(user));\n    if (tmp_user_info.IsVoid()) goto err;\n  }\n  return tmp_user_info;\n  /* purecov: end */\n\nerr:\n  LogErr(ERROR_LEVEL, ER_USER_WHAT_USER, user);\n  unireg_abort(MYSQLD_ABORT_EXIT);\n\n  return PasswdValue{};\n}\n\nnamespace mysqld_funcs_unit_test {\nPasswdValue check_user_drv(const char *user) { return check_user(user); }\n}  // namespace mysqld_funcs_unit_test\n\nstatic void set_user(const char *user, const PasswdValue &user_info_arg) {\n  /* purecov: begin tested */\n  DBUG_ASSERT(user_info_arg.IsVoid() == false);\n#ifdef HAVE_INITGROUPS\n  initgroups(user, user_info_arg.pw_gid);\n#endif\n  if (setgid(user_info_arg.pw_gid) == -1) {\n    LogErr(ERROR_LEVEL, ER_FAIL_SETGID, strerror(errno));\n    unireg_abort(MYSQLD_ABORT_EXIT);\n  }\n  if (setuid(user_info_arg.pw_uid) == -1) {\n    LogErr(ERROR_LEVEL, ER_FAIL_SETUID, strerror(errno));\n    unireg_abort(MYSQLD_ABORT_EXIT);\n  }\n\n#ifdef HAVE_SYS_PRCTL_H\n  if (test_flags & TEST_CORE_ON_SIGNAL) {\n    /* inform kernel that process is dumpable */\n    (void)prctl(PR_SET_DUMPABLE, 1);\n  }\n#endif\n\n  /* purecov: end */\n}\n\nstatic void set_effective_user(const PasswdValue &user_info_arg) {\n  DBUG_ASSERT(user_info_arg.IsVoid() == false);\n  if (setregid((gid_t)-1, user_info_arg.pw_gid) == -1) {\n    LogErr(ERROR_LEVEL, ER_FAIL_SETREGID, strerror(errno));\n    unireg_abort(MYSQLD_ABORT_EXIT);\n  }\n  if (setreuid((uid_t)-1, user_info_arg.pw_uid) == -1) {\n    LogErr(ERROR_LEVEL, ER_FAIL_SETREUID, strerror(errno));\n    unireg_abort(MYSQLD_ABORT_EXIT);\n  }\n}\n\n/** Change root user if started with @c --chroot . */\nstatic void set_root(const char *path) {\n  if (chroot(path) == -1) {\n    LogErr(ERROR_LEVEL, ER_FAIL_CHROOT, strerror(errno));\n    unireg_abort(MYSQLD_ABORT_EXIT);\n  }\n  my_setwd(\"/\", MYF(0));\n}\n#endif  // !_WIN32\n\n/**\n  Check that an address value is a wildcard IP value,\n  that is it has either the value 0.0.0.0 for IPv4 or the value ::1 in\n  case IPv6, or has the specially treated symbol * as its value.\n\n  @param address_value   Address value to check\n  @param address_length  Address length\n\n  @return true in case the address value is a wildcard value, else false.\n*/\nbool check_address_is_wildcard(const char *address_value,\n                               size_t address_length) {\n  return\n      // Wildcard is not allowed in case a comma separated list of\n      // addresses is specified\n      native_strncasecmp(address_value, MY_BIND_ALL_ADDRESSES,\n                         address_length) == 0 ||\n      // The specially treated address :: is not allowed in case\n      // a comma separated list of addresses is specified\n      native_strncasecmp(address_value, ipv6_all_addresses, address_length) ==\n          0 ||\n      // The specially treated address 0.0.0.0 is not allowed in case\n      // a comma separated list of addresses is specified\n      native_strncasecmp(address_value, ipv4_all_addresses, address_length) ==\n          0;\n}\n\n/**\n  Take a string representing host or ip address followed by\n  optional delimiter '/' and namespace name and put address part\n  and namespace part into corresponding output parameters.\n\n  @param begin_address_value  start of a string containing an address value\n  @param end_address_value  pointer to an end of string containing\n                            an address value. Has the value nullptr in case\n                            address value not continue\n  @param [out] address_value  address value extracted from address string\n  @param [out] network_namespace  network namespace extracted from\n                                  the address string value if any\n\n  @return false on success, true on address format error\n*/\nstatic bool parse_address_string(const char *begin_address_value,\n                                 const char *end_address_value,\n                                 std::string *address_value,\n                                 std::string *network_namespace) {\n  const char *namespace_separator = strchr(begin_address_value, '/');\n\n  if (namespace_separator != nullptr) {\n    if (begin_address_value == namespace_separator)\n      /*\n        Parse error: there is no character before '/',\n        that is missed address value\n      */\n      return true;\n\n    if (namespace_separator < end_address_value) {\n      if (end_address_value - namespace_separator == 1)\n        /*\n          Parse error: there is no character immediately after '/',\n          that is missed namespace name.\n        */\n        return true;\n\n      /*\n        Found namespace delimiter. Extract namespace and address values\n      */\n      *address_value = std::string(begin_address_value, namespace_separator);\n      *network_namespace =\n          std::string(namespace_separator + 1, end_address_value);\n    } else if (end_address_value != nullptr)\n      /*\n        This branch corresponds to the case when namespace separator is located\n        after the last character of the address subvalue being processed.\n        For example, if the following string '192.168.1.1,172.1.1.1/red'\n        passed into the function create_bind_address_info_from_string(),\n        then during handling of the address 192.168.1.1 search of '/'\n        will return a position after the end of the sub string 192.168.1.1\n        (in the next sub string 172.1.1.1/red) that should be ignored.\n      */\n      *address_value = std::string(begin_address_value, end_address_value);\n    else {\n      /*\n        This branch corresponds to the case when namespace separator is located\n        at the last part of address values. For example,\n        this branch is executed during handling of the following value\n        192.168.1.1,::1,::1/greeen for the option --bind-address.\n      */\n      *address_value = std::string(begin_address_value, namespace_separator);\n      *network_namespace = std::string(namespace_separator + 1);\n      if (*(namespace_separator + 1) == 0)\n        /*\n          Parse error: there is no character immediately\n          after '/' - a namespace name missed.\n        */\n        return true;\n    }\n  } else {\n    /*\n      Regular address without network namespace found.\n    */\n    *address_value = end_address_value != nullptr\n                         ? std::string(begin_address_value, end_address_value)\n                         : std::string(begin_address_value);\n  }\n\n  return false;\n}\n\n/**\n  Parse a value of address sub string with checking of address string format,\n  extract address part and namespace part of the address value, and store\n  their values into the argument valid_bind_addresses.\n\n  @return false on success, true on address format error\n*/\nstatic bool create_bind_address_info_from_string(\n    const char *begin_address_value, const char *end_address_value,\n    std::list<Bind_address_info> *valid_bind_addresses) {\n  Bind_address_info bind_address_info;\n  std::string address_value, network_namespace;\n\n  if (parse_address_string(begin_address_value, end_address_value,\n                           &address_value, &network_namespace))\n    return true;\n\n  if (network_namespace.empty())\n    bind_address_info = Bind_address_info(address_value);\n  else {\n    /*\n      Wildcard value is not allowed in case network namespace specified\n      for address value in the option bind-address.\n    */\n    if (check_address_is_wildcard(address_value.c_str(),\n                                  address_value.length())) {\n      LogErr(ERROR_LEVEL,\n             ER_NETWORK_NAMESPACE_NOT_ALLOWED_FOR_WILDCARD_ADDRESS);\n      return true;\n    }\n\n    bind_address_info = Bind_address_info(address_value, network_namespace);\n  }\n\n  valid_bind_addresses->emplace_back(bind_address_info);\n\n  return false;\n}\n\n/**\n  Check acceptable value(s) of parameter bind-address\n\n  @param      bind_address          Value of the parameter bind-address\n  @param[out] valid_bind_addresses  List of addresses to listen and their\n                                    corresponding network namespaces if set.\n\n  @return false on success, true on failure\n*/\nstatic bool check_bind_address_has_valid_value(\n    const char *bind_address,\n    std::list<Bind_address_info> *valid_bind_addresses) {\n  if (strlen(bind_address) == 0)\n    // Empty value for bind_address is an error\n    return true;\n\n  const char *comma_separator = strchr(bind_address, ',');\n  const char *begin_of_value = bind_address;\n  const bool multiple_bind_addresses = (comma_separator != nullptr);\n\n  if (comma_separator == begin_of_value)\n    // Return an error if a value of bind_address begins with comma\n    return true;\n\n  while (comma_separator != nullptr) {\n    Bind_address_info bind_address_info;\n    std::string address_value, network_namespace;\n    /*\n      Wildcard value is not allowed in case multi-addresses value specified\n      for the option bind-address.\n    */\n    if (check_address_is_wildcard(begin_of_value,\n                                  comma_separator - begin_of_value)) {\n      LogErr(ERROR_LEVEL, ER_WILDCARD_NOT_ALLOWED_FOR_MULTIADDRESS_BIND);\n\n      return true;\n    }\n\n    if (create_bind_address_info_from_string(begin_of_value, comma_separator,\n                                             valid_bind_addresses))\n      return true;\n\n    begin_of_value = comma_separator + 1;\n    comma_separator = strchr(begin_of_value, ',');\n    if (comma_separator == begin_of_value)\n      // Return an error if a value of bind_address has two adjacent commas\n      return true;\n  }\n\n  /*\n    Wildcard value is not allowed in case multi-addresses value specified\n    for the option bind-address.\n  */\n  if (multiple_bind_addresses &&\n      (check_address_is_wildcard(begin_of_value, strlen(begin_of_value)) ||\n       strlen(begin_of_value) == 0))\n    return true;\n\n  if (create_bind_address_info_from_string(begin_of_value, comma_separator,\n                                           valid_bind_addresses))\n    return true;\n\n  return false;\n}\n\n/**\n  Check acceptable value(s) of the parameter admin-address\n\n  @param      admin_bind_addr_str   Value of the parameter admin-address\n  @param[out] admin_address_info    List of addresses to listen and their\n                                    corresponding network namespaces if set.\n\n  @return false on success, true on failure\n*/\nstatic bool check_admin_address_has_valid_value(\n    const char *admin_bind_addr_str, Bind_address_info *admin_address_info) {\n  std::string address_value, network_namespace;\n\n  if (parse_address_string(admin_bind_addr_str, nullptr, &address_value,\n                           &network_namespace))\n    return true;\n\n  if (check_address_is_wildcard(address_value.c_str(),\n                                address_value.length())) {\n    if (!network_namespace.empty())\n      LogErr(ERROR_LEVEL,\n             ER_NETWORK_NAMESPACE_NOT_ALLOWED_FOR_WILDCARD_ADDRESS);\n\n    return true;\n  }\n\n  if (network_namespace.empty())\n    *admin_address_info = Bind_address_info(address_value);\n  else\n    *admin_address_info = Bind_address_info(address_value, network_namespace);\n\n  return false;\n}\n\nstatic bool network_init(void) {\n  if (opt_initialize) return false;\n\n  set_proxy();\n#ifdef HAVE_SYS_UN_H\n  std::string const unix_sock_name(mysqld_unix_port ? mysqld_unix_port : \"\");\n#else\n  std::string const unix_sock_name(\"\");\n#endif\n\n  std::list<Bind_address_info> bind_addresses_info;\n\n  if (!opt_disable_networking || unix_sock_name != \"\") {\n    if (my_bind_addr_str != nullptr &&\n        check_bind_address_has_valid_value(my_bind_addr_str,\n                                           &bind_addresses_info)) {\n      LogErr(ERROR_LEVEL, ER_INVALID_VALUE_OF_BIND_ADDRESSES, my_bind_addr_str);\n      return true;\n    }\n\n    Bind_address_info admin_address_info;\n    if (!opt_disable_networking) {\n      if (my_admin_bind_addr_str != nullptr &&\n          check_admin_address_has_valid_value(my_admin_bind_addr_str,\n                                              &admin_address_info)) {\n        LogErr(ERROR_LEVEL, ER_INVALID_ADMIN_ADDRESS, my_admin_bind_addr_str);\n        return true;\n      }\n      /*\n        Port 0 is interpreted by implementations of TCP protocol\n        as a hint to find a first free port value to use and bind to it.\n        On the other hand, the option mysqld_admin_port can be assigned\n        the value 0 if a user specified a value that is out of allowable\n        range of values. Therefore, to avoid a case when an operating\n        system binds admin interface to am arbitrary selected port value,\n        set it explicitly to the value MYSQL_ADMIN_PORT in case it has value 0.\n      */\n      if (mysqld_admin_port == 0) mysqld_admin_port = MYSQL_ADMIN_PORT;\n    }\n    Mysqld_socket_listener *mysqld_socket_listener = new (std::nothrow)\n        Mysqld_socket_listener(bind_addresses_info, mysqld_port,\n                               admin_address_info, mysqld_admin_port,\n                               admin_address_info.address.empty()\n                                   ? false\n                                   : listen_admin_interface_in_separate_thread,\n                               back_log, mysqld_port_timeout, unix_sock_name);\n    if (mysqld_socket_listener == nullptr) return true;\n\n    mysqld_socket_acceptor = new (std::nothrow)\n        Connection_acceptor<Mysqld_socket_listener>(mysqld_socket_listener);\n    if (mysqld_socket_acceptor == nullptr) {\n      delete mysqld_socket_listener;\n      mysqld_socket_listener = nullptr;\n      return true;\n    }\n\n    if (mysqld_socket_acceptor->init_connection_acceptor())\n      return true;  // mysqld_socket_acceptor would be freed in unireg_abort.\n\n    if (report_port == 0) report_port = mysqld_port;\n\n    if (!opt_disable_networking) DBUG_ASSERT(report_port != 0);\n  }\n#ifdef _WIN32\n  // Create named pipe\n  if (opt_enable_named_pipe) {\n    std::string pipe_name = mysqld_unix_port ? mysqld_unix_port : \"\";\n\n    named_pipe_listener = new (std::nothrow) Named_pipe_listener(&pipe_name);\n    if (named_pipe_listener == NULL) return true;\n\n    named_pipe_acceptor = new (std::nothrow)\n        Connection_acceptor<Named_pipe_listener>(named_pipe_listener);\n    if (named_pipe_acceptor == NULL) {\n      delete named_pipe_listener;\n      named_pipe_listener = NULL;\n      return true;\n    }\n\n    if (named_pipe_acceptor->init_connection_acceptor())\n      return true;  // named_pipe_acceptor would be freed in unireg_abort.\n  }\n\n  // Setup shared_memory acceptor\n  if (opt_enable_shared_memory) {\n    std::string shared_mem_base_name =\n        shared_memory_base_name ? shared_memory_base_name : \"\";\n\n    Shared_mem_listener *shared_mem_listener =\n        new (std::nothrow) Shared_mem_listener(&shared_mem_base_name);\n    if (shared_mem_listener == NULL) return true;\n\n    shared_mem_acceptor = new (std::nothrow)\n        Connection_acceptor<Shared_mem_listener>(shared_mem_listener);\n    if (shared_mem_acceptor == NULL) {\n      delete shared_mem_listener;\n      shared_mem_listener = NULL;\n      return true;\n    }\n\n    if (shared_mem_acceptor->init_connection_acceptor())\n      return true;  // shared_mem_acceptor would be freed in unireg_abort.\n  }\n#endif  // _WIN32\n  return false;\n}\n\n#ifdef _WIN32\nstatic uint handler_count = 0;\n\nstatic inline void decrement_handler_count() {\n  mysql_mutex_lock(&LOCK_handler_count);\n  handler_count--;\n  mysql_cond_signal(&COND_handler_count);\n  mysql_mutex_unlock(&LOCK_handler_count);\n}\n\nextern \"C\" void *socket_conn_event_handler(void *arg) {\n  my_thread_init();\n\n  Connection_acceptor<Mysqld_socket_listener> *conn_acceptor =\n      static_cast<Connection_acceptor<Mysqld_socket_listener> *>(arg);\n  conn_acceptor->connection_event_loop();\n\n  decrement_handler_count();\n  my_thread_end();\n  return 0;\n}\n\nextern \"C\" void *named_pipe_conn_event_handler(void *arg) {\n  my_thread_init();\n\n  Connection_acceptor<Named_pipe_listener> *conn_acceptor =\n      static_cast<Connection_acceptor<Named_pipe_listener> *>(arg);\n  conn_acceptor->connection_event_loop();\n\n  decrement_handler_count();\n  my_thread_end();\n  return 0;\n}\n\nextern \"C\" void *shared_mem_conn_event_handler(void *arg) {\n  my_thread_init();\n\n  Connection_acceptor<Shared_mem_listener> *conn_acceptor =\n      static_cast<Connection_acceptor<Shared_mem_listener> *>(arg);\n  conn_acceptor->connection_event_loop();\n\n  decrement_handler_count();\n  my_thread_end();\n  return 0;\n}\n\nvoid setup_conn_event_handler_threads() {\n  my_thread_handle hThread;\n\n  DBUG_TRACE;\n\n  if ((!have_tcpip || opt_disable_networking) && !opt_enable_shared_memory &&\n      !opt_enable_named_pipe) {\n    LogErr(ERROR_LEVEL, ER_WIN_LISTEN_BUT_HOW);\n    unireg_abort(MYSQLD_ABORT_EXIT);  // Will not return\n  }\n\n  mysql_mutex_lock(&LOCK_handler_count);\n  handler_count = 0;\n\n  if (opt_enable_named_pipe) {\n    int error = mysql_thread_create(\n        key_thread_handle_con_namedpipes, &hThread, &connection_attrib,\n        named_pipe_conn_event_handler, named_pipe_acceptor);\n    if (!error)\n      handler_count++;\n    else\n      LogErr(WARNING_LEVEL, ER_CANT_CREATE_NAMED_PIPES_THREAD, error);\n  }\n\n  if (have_tcpip && !opt_disable_networking) {\n    int error = mysql_thread_create(\n        key_thread_handle_con_sockets, &hThread, &connection_attrib,\n        socket_conn_event_handler, mysqld_socket_acceptor);\n    if (!error)\n      handler_count++;\n    else\n      LogErr(WARNING_LEVEL, ER_CANT_CREATE_TCPIP_THREAD, error);\n  }\n\n  if (opt_enable_shared_memory) {\n    int error = mysql_thread_create(\n        key_thread_handle_con_sharedmem, &hThread, &connection_attrib,\n        shared_mem_conn_event_handler, shared_mem_acceptor);\n    if (!error)\n      handler_count++;\n    else\n      LogErr(WARNING_LEVEL, ER_CANT_CREATE_SHM_THREAD, error);\n  }\n\n  // Block until all connection listener threads have exited.\n  while (handler_count > 0)\n    mysql_cond_wait(&COND_handler_count, &LOCK_handler_count);\n  mysql_mutex_unlock(&LOCK_handler_count);\n}\n\n/*\n  On Windows, we use native SetConsoleCtrlHandler for handle events like Ctrl-C\n  with graceful shutdown.\n  Also, we do not use signal(), but SetUnhandledExceptionFilter instead - as it\n  provides possibility to pass the exception to just-in-time debugger, collect\n  dumps and potentially also the exception and thread context used to output\n  callstack.\n*/\n\nstatic BOOL WINAPI console_event_handler(DWORD type) {\n  DBUG_TRACE;\n  if (type == CTRL_C_EVENT) {\n    /*\n      Do not shutdown before startup is finished and shutdown\n      thread is initialized. Otherwise there is a race condition\n      between main thread doing initialization and CTRL-C thread doing\n      cleanup, which can result into crash.\n    */\n    if (hEventShutdown)\n      kill_mysql();\n    else\n      LogErr(WARNING_LEVEL, ER_NOT_RIGHT_NOW);\n    return true;\n  }\n  return false;\n}\n\n#ifdef DEBUG_UNHANDLED_EXCEPTION_FILTER\n#define DEBUGGER_ATTACH_TIMEOUT 120\n/*\n  Wait for debugger to attach and break into debugger. If debugger is not\n  attached, resume after timeout.\n*/\nstatic void wait_for_debugger(int timeout_sec) {\n  if (!IsDebuggerPresent()) {\n    int i;\n    printf(\"Waiting for debugger to attach, pid=%u\\n\", GetCurrentProcessId());\n    fflush(stdout);\n    for (i = 0; i < timeout_sec; i++) {\n      Sleep(1000);\n      if (IsDebuggerPresent()) {\n        /* Break into debugger */\n        __debugbreak();\n        return;\n      }\n    }\n    printf(\"pid=%u, debugger not attached after %d seconds, resuming\\n\",\n           GetCurrentProcessId(), timeout_sec);\n    fflush(stdout);\n  }\n}\n#endif /* DEBUG_UNHANDLED_EXCEPTION_FILTER */\n\nLONG WINAPI my_unhandler_exception_filter(EXCEPTION_POINTERS *ex_pointers) {\n  static BOOL first_time = true;\n  if (!first_time) {\n    /*\n      This routine can be called twice, typically\n      when detaching in JIT debugger.\n      Return EXCEPTION_EXECUTE_HANDLER to terminate process.\n    */\n    return EXCEPTION_EXECUTE_HANDLER;\n  }\n  first_time = false;\n#ifdef DEBUG_UNHANDLED_EXCEPTION_FILTER\n  /*\n   Unfortunately there is no clean way to debug unhandled exception filters,\n   as debugger does not stop there(also documented in MSDN)\n   To overcome, one could put a MessageBox, but this will not work in service.\n   Better solution is to print error message and sleep some minutes\n   until debugger is attached\n */\n  wait_for_debugger(DEBUGGER_ATTACH_TIMEOUT);\n#endif /* DEBUG_UNHANDLED_EXCEPTION_FILTER */\n  __try {\n    my_set_exception_pointers(ex_pointers);\n    handle_fatal_signal(ex_pointers->ExceptionRecord->ExceptionCode);\n  } __except (EXCEPTION_EXECUTE_HANDLER) {\n    DWORD written;\n    const char msg[] = \"Got exception in exception handler!\\n\";\n    WriteFile(GetStdHandle(STD_OUTPUT_HANDLE), msg, sizeof(msg) - 1, &written,\n              NULL);\n  }\n  /*\n    Return EXCEPTION_CONTINUE_SEARCH to give JIT debugger\n    (drwtsn32 or vsjitdebugger) possibility to attach,\n    if JIT debugger is configured.\n    Windows Error reporting might generate a dump here.\n  */\n  return EXCEPTION_CONTINUE_SEARCH;\n}\n\nvoid my_init_signals() {\n  if (opt_console) SetConsoleCtrlHandler(console_event_handler, true);\n\n  /* Avoid MessageBox()es*/\n  _CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE);\n  _CrtSetReportFile(_CRT_WARN, _CRTDBG_FILE_STDERR);\n  _CrtSetReportMode(_CRT_ERROR, _CRTDBG_MODE_FILE);\n  _CrtSetReportFile(_CRT_ERROR, _CRTDBG_FILE_STDERR);\n  _CrtSetReportMode(_CRT_ASSERT, _CRTDBG_MODE_FILE);\n  _CrtSetReportFile(_CRT_ASSERT, _CRTDBG_FILE_STDERR);\n\n  /*\n    Do not use SEM_NOGPFAULTERRORBOX in the following SetErrorMode (),\n    because it would prevent JIT debugger and Windows error reporting\n    from working. We need WER or JIT-debugging, since our own unhandled\n    exception filter is not guaranteed to work in all situation\n    (like heap corruption or stack overflow)\n  */\n  SetErrorMode(SetErrorMode(0) | SEM_FAILCRITICALERRORS |\n               SEM_NOOPENFILEERRORBOX);\n  SetUnhandledExceptionFilter(my_unhandler_exception_filter);\n}\n\n#else  // !_WIN32\n\nextern \"C\" {\nstatic void empty_signal_handler(int sig MY_ATTRIBUTE((unused))) {}\n}\n\nvoid my_init_signals() {\n  DBUG_TRACE;\n  struct sigaction sa;\n  (void)sigemptyset(&sa.sa_mask);\n\n  if (!(test_flags & TEST_NO_STACKTRACE) ||\n      (test_flags & TEST_CORE_ON_SIGNAL)) {\n#ifdef HAVE_STACKTRACE\n    my_init_stacktrace();\n#endif\n\n    if (test_flags & TEST_CORE_ON_SIGNAL) {\n      // Change limits so that we will get a core file.\n      struct rlimit rl;\n      rl.rlim_cur = rl.rlim_max = RLIM_INFINITY;\n      if (setrlimit(RLIMIT_CORE, &rl)) LogErr(WARNING_LEVEL, ER_CORE_VALUES);\n    }\n\n    /*\n      SA_RESETHAND resets handler action to default when entering handler.\n      SA_NODEFER allows receiving the same signal during handler.\n      E.g. SIGABRT during our signal handler will dump core (default action).\n    */\n    sa.sa_flags = SA_RESETHAND | SA_NODEFER;\n    sa.sa_handler = handle_fatal_signal;\n    // Treat all these as fatal and handle them.\n    (void)sigaction(SIGSEGV, &sa, nullptr);\n    (void)sigaction(SIGABRT, &sa, nullptr);\n    (void)sigaction(SIGBUS, &sa, nullptr);\n    (void)sigaction(SIGILL, &sa, nullptr);\n    (void)sigaction(SIGFPE, &sa, nullptr);\n  }\n\n  // Ignore SIGPIPE\n  sa.sa_flags = 0;\n  sa.sa_handler = SIG_IGN;\n  (void)sigaction(SIGPIPE, &sa, nullptr);\n\n  // SIGALRM is used to interrupt the socket listener.\n  sa.sa_handler = empty_signal_handler;\n  (void)sigaction(SIGALRM, &sa, nullptr);\n\n  // Fix signals if ignored by parents (can happen on Mac OS X).\n  sa.sa_handler = SIG_DFL;\n  (void)sigaction(SIGTERM, &sa, nullptr);\n  (void)sigaction(SIGHUP, &sa, nullptr);\n  (void)sigaction(SIGUSR1, &sa, nullptr);\n\n  (void)sigemptyset(&mysqld_signal_mask);\n  /*\n    Block SIGQUIT, SIGHUP, SIGTERM, SIGUSR1 and SIGUSR2.\n    The signal handler thread does sigwait() on these.\n  */\n  (void)sigaddset(&mysqld_signal_mask, SIGQUIT);\n  (void)sigaddset(&mysqld_signal_mask, SIGHUP);\n  (void)sigaddset(&mysqld_signal_mask, SIGTERM);\n  (void)sigaddset(&mysqld_signal_mask, SIGTSTP);\n  (void)sigaddset(&mysqld_signal_mask, SIGUSR1);\n  (void)sigaddset(&mysqld_signal_mask, SIGUSR2);\n  /*\n    Block SIGINT unless debugging to prevent Ctrl+C from causing\n    unclean shutdown of the server.\n  */\n  if (!(test_flags & TEST_SIGINT)) (void)sigaddset(&mysqld_signal_mask, SIGINT);\n  pthread_sigmask(SIG_SETMASK, &mysqld_signal_mask, nullptr);\n}\n\nstatic void start_signal_handler() {\n  int error;\n  my_thread_attr_t thr_attr;\n  DBUG_TRACE;\n\n  (void)my_thread_attr_init(&thr_attr);\n  (void)pthread_attr_setscope(&thr_attr, PTHREAD_SCOPE_SYSTEM);\n  (void)my_thread_attr_setdetachstate(&thr_attr, MY_THREAD_CREATE_JOINABLE);\n\n  size_t guardize = 0;\n  (void)pthread_attr_getguardsize(&thr_attr, &guardize);\n#if defined(__ia64__) || defined(__ia64)\n  /*\n    Peculiar things with ia64 platforms - it seems we only have half the\n    stack size in reality, so we have to double it here\n  */\n  guardize = my_thread_stack_size;\n#endif\n  if (0 !=\n      my_thread_attr_setstacksize(&thr_attr, my_thread_stack_size + guardize)) {\n    DBUG_ASSERT(false);\n  }\n\n  /*\n    Set main_thread_id so that SIGTERM/SIGQUIT/SIGKILL/SIGUSR2 can interrupt\n    the socket listener successfully.\n  */\n  main_thread_id = my_thread_self();\n\n  mysql_mutex_lock(&LOCK_start_signal_handler);\n  if ((error = mysql_thread_create(key_thread_signal_hand, &signal_thread_id,\n                                   &thr_attr, signal_hand, nullptr))) {\n    LogErr(ERROR_LEVEL, ER_CANT_CREATE_INTERRUPT_THREAD, error, errno);\n    flush_error_log_messages();\n    exit(MYSQLD_ABORT_EXIT);\n  }\n  mysql_cond_wait(&COND_start_signal_handler, &LOCK_start_signal_handler);\n  mysql_mutex_unlock(&LOCK_start_signal_handler);\n\n  (void)my_thread_attr_destroy(&thr_attr);\n}\n\n/** This thread handles SIGTERM, SIGQUIT, SIGHUP, SIGUSR1 and SIGUSR2 signals.\n */\n/* ARGSUSED */\nextern \"C\" void *signal_hand(void *arg MY_ATTRIBUTE((unused))) {\n  my_thread_init();\n\n  sigset_t set;\n  (void)sigemptyset(&set);\n  (void)sigaddset(&set, SIGTERM);\n  (void)sigaddset(&set, SIGQUIT);\n  (void)sigaddset(&set, SIGHUP);\n  (void)sigaddset(&set, SIGUSR1);\n  (void)sigaddset(&set, SIGUSR2);\n\n  /*\n    Signal to start_signal_handler that we are ready.\n    This works by waiting for start_signal_handler to free mutex,\n    after which we signal it that we are ready.\n  */\n  mysql_mutex_lock(&LOCK_start_signal_handler);\n  mysql_cond_broadcast(&COND_start_signal_handler);\n  mysql_mutex_unlock(&LOCK_start_signal_handler);\n\n  /*\n    Wait until that all server components have been successfully initialized.\n    This step is mandatory since signal processing can be done safely only when\n    all server components have been initialized.\n  */\n  server_components_init_wait();\n  for (;;) {\n    int sig = 0;\n    int rc;\n    bool error;\n#ifdef __APPLE__\n    while ((rc = sigwait(&set, &sig)) == EINTR) {\n    }\n    error = rc != 0;\n#else\n    siginfo_t sig_info;\n    while ((rc = sigwaitinfo(&set, &sig_info)) == -1 && errno == EINTR) {\n    }\n    error = rc == -1;\n    if (!error) sig = sig_info.si_signo;\n#endif             // __APPLE__\n    if (error)\n      sql_print_error(\n          \"Fatal error in signal handling thread. sigwait/sigwaitinfo returned \"\n          \"error  %d\\n. Exiting signal handler \"\n          \"thread.\",\n          errno);\n\n    if (error || cleanup_done) {\n      my_thread_end();\n      my_thread_exit(nullptr);  // Safety\n      return nullptr;           // Avoid compiler warnings\n    }\n    switch (sig) {\n      case SIGUSR2:\n        signal_hand_thr_exit_code = MYSQLD_RESTART_EXIT;\n#ifndef __APPLE__  // Mac OS doesn't have sigwaitinfo.\n        //  Log a note if mysqld is restarted via kill command.\n        if (sig_info.si_pid != getpid()) {\n          sql_print_information(\n              \"Received signal SIGUSR2.\"\n              \" Restarting mysqld (Version %s)\",\n              server_version);\n        }\n#endif             // __APPLE__\n        // fall through\n      case SIGTERM:\n      case SIGQUIT:\n        // Switch to the file log message processing.\n        query_logger.set_handlers((log_output_options != LOG_NONE) ? LOG_FILE\n                                                                   : LOG_NONE);\n        DBUG_PRINT(\"info\",\n                   (\"Got signal: %d  connection_events_loop_aborted: %d\", sig,\n                    connection_events_loop_aborted()));\n        if (!connection_events_loop_aborted()) {\n          // Mark abort for threads.\n          set_connection_events_loop_aborted(true);\n#ifdef HAVE_PSI_THREAD_INTERFACE\n          // Delete the instrumentation for the signal thread.\n          PSI_THREAD_CALL(delete_current_thread)();\n#endif /* HAVE_PSI_THREAD_INTERFACE */\n          /*\n            Kill the socket listener.\n            The main thread will then set socket_listener_active= false,\n            and wait for us to finish all the cleanup below.\n          */\n          mysql_mutex_lock(&LOCK_socket_listener_active);\n          while (socket_listener_active) {\n            DBUG_PRINT(\"info\", (\"Killing socket listener\"));\n            if (pthread_kill(main_thread_id, SIGALRM)) {\n              DBUG_ASSERT(false);\n              break;\n            }\n            mysql_cond_wait(&COND_socket_listener_active,\n                            &LOCK_socket_listener_active);\n          }\n          mysql_mutex_unlock(&LOCK_socket_listener_active);\n\n          close_connections();\n        }\n        my_thread_end();\n        my_thread_exit(nullptr);\n        return nullptr;  // Avoid compiler warnings\n        break;\n      case SIGHUP:\n        if (!connection_events_loop_aborted()) {\n          int not_used;\n          DBUG_EXECUTE_IF(\"simulate_sighup_print_status\", {\n            printf(\"\\nStatus information:\\n\\n\");\n            fflush(stdout);\n          });\n          handle_reload_request(\n              nullptr,\n              (REFRESH_LOG | REFRESH_TABLES | REFRESH_FAST | REFRESH_GRANT |\n               REFRESH_THREADS | REFRESH_HOSTS),\n              nullptr, &not_used);  // Flush logs\n          // Reenable query logs after the options were reloaded.\n          query_logger.set_handlers(log_output_options);\n        }\n        break;\n      case SIGUSR1:\n        if (!connection_events_loop_aborted()) {\n          int not_used;\n          handle_reload_request(\n              nullptr,\n              (REFRESH_ERROR_LOG |   /**< Rotate only the error log */\n               REFRESH_GENERAL_LOG | /**< Flush the general log */\n               REFRESH_SLOW_LOG),    /**< Flush the slow query log */\n              nullptr, &not_used);   // Flush logs\n          // Reenable query logs after the options were reloaded.\n          query_logger.set_handlers(log_output_options);\n        }\n        break;\n      default:\n        break; /* purecov: tested */\n    }\n  }\n  return nullptr; /* purecov: deadcode */\n}\n\n#endif  // !_WIN32\n\n/**\n  All global error messages are sent here where the first one is stored\n  for the client.\n*/\n/* ARGSUSED */\nextern \"C\" void my_message_sql(uint error, const char *str, myf MyFlags);\n\nvoid my_message_sql(uint error, const char *str, myf MyFlags) {\n  THD *thd = current_thd;\n  DBUG_TRACE;\n  DBUG_PRINT(\"error\", (\"error: %u  message: '%s'\", error, str));\n\n  DBUG_ASSERT(str != nullptr);\n  /*\n    An error should have a valid error number (!= 0), so it can be caught\n    in stored procedures by SQL exception handlers.\n    Calling my_error() with error == 0 is a bug.\n    Remaining known places to fix:\n    - storage/myisam/mi_create.c, my_printf_error()\n    TODO:\n    DBUG_ASSERT(error != 0);\n  */\n\n  if (error == 0) {\n    /* At least, prevent new abuse ... */\n    DBUG_ASSERT(strncmp(str, \"MyISAM table\", 12) == 0);\n    error = ER_UNKNOWN_ERROR;\n  }\n\n  /* Caller wishes to inform client, and one is attached. */\n  if (thd) {\n    (void)thd->raise_condition(error, nullptr, Sql_condition::SL_ERROR, str,\n                               MyFlags & ME_FATALERROR);\n\n    /*\n      Now for an argument check.\n      We're asserting after rather than before raising the\n      condition to make the culprit easier to track down.\n\n      Messages intended for the error-log are in the range\n      starting at ER_SERVER_RANGE_START (error_code 10,000);\n      messages intended for sending to a client are in the\n      range below ER_SERVER_RANGE_START. If a message is to\n      be sent to both a client and the error log, it must\n      be added twice (once in each range), and two separate\n      calls (e.g. my_error() and LogErr()) must be added to\n      the code.\n\n      Only error-codes from the client range should be seen\n      in this if(). If your patch asserts here, one of two\n      things probably happened:\n\n      - You added a new message to messages_to_error_log.txt:\n        The message was added to the server range, but code\n        was added that tries to send the message to a client\n        (my_error(), push_warning_printf(), etc.).\n\n        => Move the new message to messages_to_clients.txt.\n           The copied message should be added at the end of\n           the range for the lowest server version you're adding\n           the message to.\n           Rebuild the server; rerun your test.\n\n      - You used an existing message:\n        The existing message is intended for use with\n        the error-log (it appears in messages_to_error_log.txt),\n        but the new code tries to send it to a client (my_error(),\n        push_warning_printf(), etc.).\n\n        => Copy the existing message to messages_to_clients.txt.\n           - The copied message should be added at the end of\n             the range for the lowest server version you're adding\n             the message to.\n           - The copied message will need its own symbol;\n             if in doubt, call the copy of ER_EXAMPLE_MESSAGE\n             ER_DA_EXAMPLE_MESSAGE (as this version is for use\n             with the diagnostics area).\n           Then make sure that your new code references\n           this new symbol when it sends the message\n           to a client.\n           Rebuild the server; rerun your test.\n\n      We'll assert this here (rather than in raise_condition) as\n      SQL's SIGNAL command also calls raise_condition, and SIGNAL\n      is currently allowed to set any error-code (regardless of\n      range). SIGNALing an error-code from the error-log range\n      will not result in writing to that log to prevent abuse.\n    */\n    DBUG_ASSERT(error < ER_SERVER_RANGE_START);\n  }\n\n  /* When simulating OOM, skip writing to error log to avoid mtr errors */\n  DBUG_EXECUTE_IF(\"simulate_out_of_memory\", return;);\n\n  /*\n    Caller wishes to send to both the client and the error-log.\n    This is legacy behaviour that is no longer legal as errors flagged\n    to a client and those sent to the error-log are in different\n    numeric ranges now. If you own code that does this, see about\n    updating it by splitting it into two calls, one sending status\n    to the client, the other sending it to the error-log using\n    LogErr() and friends.\n  */\n  if (MyFlags & ME_ERRORLOG) {\n    /*\n      We've removed most uses of ME_ERRORLOG in the server.\n      This leaves three possible cases, in which we'll rewrite\n      the error-code from one in the client-range to one in\n      the error-log range here:\n\n      - EE_OUTOFMEMORY: Correct to ER_SERVER_OUT_OF_RESOURCES so\n                        mysys can remain logger-agnostic.\n\n      - HA_* range:     Correct to catch-all ER_SERVER_HANDLER_ERROR.\n\n      - otherwise:      Flag as using info from the diagnostics area\n                        (ER_ERROR_INFO_FROM_DA). This is a failsafe;\n                        if your code triggers it, your code is probably\n                        wrong.\n    */\n    if ((error == EE_OUTOFMEMORY) || (error == HA_ERR_OUT_OF_MEM))\n      error = ER_SERVER_OUT_OF_RESOURCES;\n    else if (error <= HA_ERR_LAST)\n      error = ER_SERVER_HANDLER_ERROR;\n\n    if (error < ER_SERVER_RANGE_START)\n      LogEvent()\n          .type(LOG_TYPE_ERROR)\n          .prio(ERROR_LEVEL)\n          .errcode(ER_ERROR_INFO_FROM_DA)\n          .lookup(ER_ERROR_INFO_FROM_DA, error, str);\n    else\n      LogEvent()\n          .type(LOG_TYPE_ERROR)\n          .prio(ERROR_LEVEL)\n          .errcode(error)\n          .verbatim(str);\n\n    /*\n      This is no longer supported behaviour except for the cases\n      outlined above, so flag anything else in debug builds!\n      (We're bailing after rather than before printing to make the\n      culprit easier to track down.)\n    */\n    DBUG_ASSERT((error == ER_FEATURE_NOT_AVAILABLE) ||\n                (error >= ER_SERVER_RANGE_START));\n  }\n\n  /*\n    Caller wishes to send to client, but none is attached, so we send\n    to error-log instead.\n  */\n  else if (!thd) {\n    LogEvent()\n        .type(LOG_TYPE_ERROR)\n        .subsys(LOG_SUBSYSTEM_TAG)\n        .prio(ERROR_LEVEL)\n        .errcode((error < ER_SERVER_RANGE_START)\n                     ? ER_SERVER_NO_SESSION_TO_SEND_TO\n                     : error)\n        .lookup(ER_SERVER_NO_SESSION_TO_SEND_TO, error, str);\n  }\n}\n\nextern \"C\" void *my_str_malloc_mysqld(size_t size);\nextern \"C\" void my_str_free_mysqld(void *ptr);\nextern \"C\" void *my_str_realloc_mysqld(void *ptr, size_t size);\n\nvoid *my_str_malloc_mysqld(size_t size) {\n  return my_malloc(key_memory_my_str_malloc, size, MYF(MY_FAE));\n}\n\nvoid my_str_free_mysqld(void *ptr) { my_free(ptr); }\n\nvoid *my_str_realloc_mysqld(void *ptr, size_t size) {\n  return my_realloc(key_memory_my_str_malloc, ptr, size, MYF(MY_FAE));\n}\n\nconst char *load_default_groups[] = {\n#ifdef WITH_NDBCLUSTER_STORAGE_ENGINE\n    \"mysql_cluster\",\n#endif\n    \"mysqld\",        \"server\", MYSQL_BASE_VERSION, nullptr, nullptr};\n\n#if defined(_WIN32)\nstatic const int load_default_groups_sz =\n    sizeof(load_default_groups) / sizeof(load_default_groups[0]);\n#endif\n\n/**\n  This function is used to check for stack overrun for pathological\n  cases of regular expressions and 'like' expressions.\n  The call to current_thd is quite expensive, so we try to avoid it\n  for the normal cases.\n  The size of each stack frame for the wildcmp() routines is ~128 bytes,\n  so checking *every* recursive call is not necessary.\n */\nextern \"C\" {\nstatic int check_enough_stack_size(int recurse_level) {\n  uchar stack_top;\n  if (recurse_level % 16 != 0) return 0;\n\n  THD *my_thd = current_thd;\n  if (my_thd != nullptr)\n    return check_stack_overrun(my_thd, STACK_MIN_SIZE * 4, &stack_top);\n  return 0;\n}\n}  // extern \"C\"\n\nSHOW_VAR com_status_vars[] = {\n    {\"admin_commands\", (char *)offsetof(System_status_var, com_other),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"assign_to_keycache\",\n     (char *)offsetof(System_status_var,\n                      com_stat[(uint)SQLCOM_ASSIGN_TO_KEYCACHE]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"alter_db\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_ALTER_DB]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"alter_event\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_ALTER_EVENT]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"alter_function\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_ALTER_FUNCTION]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"alter_instance\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_ALTER_INSTANCE]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"alter_procedure\",\n     (char *)offsetof(System_status_var,\n                      com_stat[(uint)SQLCOM_ALTER_PROCEDURE]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"alter_resource_group\",\n     (char *)offsetof(System_status_var,\n                      com_stat[(uint)SQLCOM_ALTER_RESOURCE_GROUP]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"alter_server\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_ALTER_SERVER]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"alter_table\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_ALTER_TABLE]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"alter_tablespace\",\n     (char *)offsetof(System_status_var,\n                      com_stat[(uint)SQLCOM_ALTER_TABLESPACE]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"alter_user\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_ALTER_USER]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"alter_user_default_role\",\n     (char *)offsetof(System_status_var,\n                      com_stat[(uint)SQLCOM_ALTER_USER_DEFAULT_ROLE]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"analyze\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_ANALYZE]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"begin\", (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_BEGIN]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"binlog\",\n     (char *)offsetof(System_status_var,\n                      com_stat[(uint)SQLCOM_BINLOG_BASE64_EVENT]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"call_procedure\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_CALL]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"change_db\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_CHANGE_DB]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"change_master\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_CHANGE_MASTER]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"change_repl_filter\",\n     (char *)offsetof(System_status_var,\n                      com_stat[(uint)SQLCOM_CHANGE_REPLICATION_FILTER]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"check\", (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_CHECK]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"checksum\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_CHECKSUM]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"clone\", (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_CLONE]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"commit\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_COMMIT]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"create_compression_dictionary\",\n     (char *)offsetof(System_status_var,\n                      com_stat[(uint)SQLCOM_CREATE_COMPRESSION_DICTIONARY]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"create_db\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_CREATE_DB]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"create_event\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_CREATE_EVENT]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"create_function\",\n     (char *)offsetof(System_status_var,\n                      com_stat[(uint)SQLCOM_CREATE_SPFUNCTION]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"create_index\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_CREATE_INDEX]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"create_procedure\",\n     (char *)offsetof(System_status_var,\n                      com_stat[(uint)SQLCOM_CREATE_PROCEDURE]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"create_role\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_CREATE_ROLE]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"create_server\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_CREATE_SERVER]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"create_table\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_CREATE_TABLE]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"create_resource_group\",\n     (char *)offsetof(System_status_var,\n                      com_stat[(uint)SQLCOM_CREATE_RESOURCE_GROUP]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"create_trigger\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_CREATE_TRIGGER]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"create_udf\",\n     (char *)offsetof(System_status_var,\n                      com_stat[(uint)SQLCOM_CREATE_FUNCTION]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"create_user\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_CREATE_USER]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"create_view\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_CREATE_VIEW]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"create_spatial_reference_system\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_CREATE_SRS]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"dealloc_sql\",\n     (char *)offsetof(System_status_var,\n                      com_stat[(uint)SQLCOM_DEALLOCATE_PREPARE]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"delete\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_DELETE]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"delete_multi\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_DELETE_MULTI]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"do\", (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_DO]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"drop_compression_dictionary\",\n     (char *)offsetof(System_status_var,\n                      com_stat[(uint)SQLCOM_DROP_COMPRESSION_DICTIONARY]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"drop_db\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_DROP_DB]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"drop_event\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_DROP_EVENT]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"drop_function\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_DROP_FUNCTION]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"drop_index\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_DROP_INDEX]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"drop_procedure\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_DROP_PROCEDURE]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"drop_resource_group\",\n     (char *)offsetof(System_status_var,\n                      com_stat[(uint)SQLCOM_DROP_RESOURCE_GROUP]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"drop_role\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_DROP_ROLE]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"drop_server\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_DROP_SERVER]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"drop_spatial_reference_system\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_DROP_SRS]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"drop_table\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_DROP_TABLE]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"drop_trigger\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_DROP_TRIGGER]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"drop_user\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_DROP_USER]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"drop_view\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_DROP_VIEW]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"empty_query\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_EMPTY_QUERY]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"execute_sql\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_EXECUTE]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"explain_other\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_EXPLAIN_OTHER]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"flush\", (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_FLUSH]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"get_diagnostics\",\n     (char *)offsetof(System_status_var,\n                      com_stat[(uint)SQLCOM_GET_DIAGNOSTICS]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"grant\", (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_GRANT]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"grant_roles\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_GRANT_ROLE]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"ha_close\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_HA_CLOSE]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"ha_open\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_HA_OPEN]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"ha_read\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_HA_READ]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"help\", (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_HELP]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"import\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_IMPORT]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"insert\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_INSERT]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"insert_select\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_INSERT_SELECT]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"install_component\",\n     (char *)offsetof(System_status_var,\n                      com_stat[(uint)SQLCOM_INSTALL_COMPONENT]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"install_plugin\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_INSTALL_PLUGIN]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"kill\", (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_KILL]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"load\", (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_LOAD]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"lock_instance\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_LOCK_INSTANCE]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"lock_tables\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_LOCK_TABLES]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"lock_tables_for_backup\",\n     (char *)offsetof(System_status_var,\n                      com_stat[(uint)SQLCOM_LOCK_TABLES_FOR_BACKUP]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"optimize\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_OPTIMIZE]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"preload_keys\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_PRELOAD_KEYS]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"prepare_sql\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_PREPARE]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"purge\", (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_PURGE]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"purge_before_date\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_PURGE_BEFORE]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"release_savepoint\",\n     (char *)offsetof(System_status_var,\n                      com_stat[(uint)SQLCOM_RELEASE_SAVEPOINT]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"rename_table\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_RENAME_TABLE]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"rename_user\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_RENAME_USER]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"repair\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_REPAIR]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"replace\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_REPLACE]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"replace_select\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_REPLACE_SELECT]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"reset\", (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_RESET]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"resignal\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_RESIGNAL]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"restart\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_RESTART_SERVER]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"revoke\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_REVOKE]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"revoke_all\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_REVOKE_ALL]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"revoke_roles\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_REVOKE_ROLE]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"rollback\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_ROLLBACK]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"rollback_to_savepoint\",\n     (char *)offsetof(System_status_var,\n                      com_stat[(uint)SQLCOM_ROLLBACK_TO_SAVEPOINT]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"savepoint\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_SAVEPOINT]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"select\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_SELECT]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"set_option\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_SET_OPTION]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"set_password\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_SET_PASSWORD]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"set_resource_group\",\n     (char *)offsetof(System_status_var,\n                      com_stat[(uint)SQLCOM_SET_RESOURCE_GROUP]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"set_role\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_SET_ROLE]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"signal\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_SIGNAL]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"show_binlog_events\",\n     (char *)offsetof(System_status_var,\n                      com_stat[(uint)SQLCOM_SHOW_BINLOG_EVENTS]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"show_binlogs\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_SHOW_BINLOGS]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"show_charsets\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_SHOW_CHARSETS]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"show_client_statistics\",\n     (char *)offsetof(System_status_var,\n                      com_stat[(uint)SQLCOM_SHOW_CLIENT_STATS]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"show_collations\",\n     (char *)offsetof(System_status_var,\n                      com_stat[(uint)SQLCOM_SHOW_COLLATIONS]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"show_create_db\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_SHOW_CREATE_DB]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"show_create_event\",\n     (char *)offsetof(System_status_var,\n                      com_stat[(uint)SQLCOM_SHOW_CREATE_EVENT]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"show_create_func\",\n     (char *)offsetof(System_status_var,\n                      com_stat[(uint)SQLCOM_SHOW_CREATE_FUNC]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"show_create_proc\",\n     (char *)offsetof(System_status_var,\n                      com_stat[(uint)SQLCOM_SHOW_CREATE_PROC]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"show_create_table\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_SHOW_CREATE]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"show_create_trigger\",\n     (char *)offsetof(System_status_var,\n                      com_stat[(uint)SQLCOM_SHOW_CREATE_TRIGGER]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"show_databases\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_SHOW_DATABASES]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"show_engine_logs\",\n     (char *)offsetof(System_status_var,\n                      com_stat[(uint)SQLCOM_SHOW_ENGINE_LOGS]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"show_engine_mutex\",\n     (char *)offsetof(System_status_var,\n                      com_stat[(uint)SQLCOM_SHOW_ENGINE_MUTEX]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"show_engine_status\",\n     (char *)offsetof(System_status_var,\n                      com_stat[(uint)SQLCOM_SHOW_ENGINE_STATUS]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"show_events\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_SHOW_EVENTS]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"show_errors\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_SHOW_ERRORS]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"show_fields\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_SHOW_FIELDS]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"show_function_code\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_SHOW_FUNC_CODE]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"show_function_status\",\n     (char *)offsetof(System_status_var,\n                      com_stat[(uint)SQLCOM_SHOW_STATUS_FUNC]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"show_grants\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_SHOW_GRANTS]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"show_index_statistics\",\n     (char *)offsetof(System_status_var,\n                      com_stat[(uint)SQLCOM_SHOW_INDEX_STATS]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"show_keys\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_SHOW_KEYS]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"show_master_status\",\n     (char *)offsetof(System_status_var,\n                      com_stat[(uint)SQLCOM_SHOW_MASTER_STAT]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"show_open_tables\",\n     (char *)offsetof(System_status_var,\n                      com_stat[(uint)SQLCOM_SHOW_OPEN_TABLES]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"show_plugins\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_SHOW_PLUGINS]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"show_privileges\",\n     (char *)offsetof(System_status_var,\n                      com_stat[(uint)SQLCOM_SHOW_PRIVILEGES]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"show_procedure_code\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_SHOW_PROC_CODE]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"show_procedure_status\",\n     (char *)offsetof(System_status_var,\n                      com_stat[(uint)SQLCOM_SHOW_STATUS_PROC]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"show_processlist\",\n     (char *)offsetof(System_status_var,\n                      com_stat[(uint)SQLCOM_SHOW_PROCESSLIST]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"show_profile\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_SHOW_PROFILE]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"show_profiles\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_SHOW_PROFILES]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"show_relaylog_events\",\n     (char *)offsetof(System_status_var,\n                      com_stat[(uint)SQLCOM_SHOW_RELAYLOG_EVENTS]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"show_slave_hosts\",\n     (char *)offsetof(System_status_var,\n                      com_stat[(uint)SQLCOM_SHOW_SLAVE_HOSTS]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"show_slave_status\",\n     (char *)offsetof(System_status_var,\n                      com_stat[(uint)SQLCOM_SHOW_SLAVE_STAT]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"show_status\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_SHOW_STATUS]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"show_storage_engines\",\n     (char *)offsetof(System_status_var,\n                      com_stat[(uint)SQLCOM_SHOW_STORAGE_ENGINES]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"show_table_statistics\",\n     (char *)offsetof(System_status_var,\n                      com_stat[(uint)SQLCOM_SHOW_TABLE_STATS]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"show_table_status\",\n     (char *)offsetof(System_status_var,\n                      com_stat[(uint)SQLCOM_SHOW_TABLE_STATUS]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"show_tables\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_SHOW_TABLES]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"show_thread_statistics\",\n     (char *)offsetof(System_status_var,\n                      com_stat[(uint)SQLCOM_SHOW_THREAD_STATS]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"show_triggers\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_SHOW_TRIGGERS]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"show_user_statistics\",\n     (char *)offsetof(System_status_var,\n                      com_stat[(uint)SQLCOM_SHOW_USER_STATS]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"show_variables\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_SHOW_VARIABLES]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"show_warnings\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_SHOW_WARNS]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"show_create_user\",\n     (char *)offsetof(System_status_var,\n                      com_stat[(uint)SQLCOM_SHOW_CREATE_USER]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"shutdown\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_SHUTDOWN]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"slave_start\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_SLAVE_START]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"slave_stop\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_SLAVE_STOP]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"group_replication_start\",\n     (char *)offsetof(System_status_var,\n                      com_stat[(uint)SQLCOM_START_GROUP_REPLICATION]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"group_replication_stop\",\n     (char *)offsetof(System_status_var,\n                      com_stat[(uint)SQLCOM_STOP_GROUP_REPLICATION]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"stmt_execute\", (char *)offsetof(System_status_var, com_stmt_execute),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"stmt_close\", (char *)offsetof(System_status_var, com_stmt_close),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"stmt_fetch\", (char *)offsetof(System_status_var, com_stmt_fetch),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"stmt_prepare\", (char *)offsetof(System_status_var, com_stmt_prepare),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"stmt_reset\", (char *)offsetof(System_status_var, com_stmt_reset),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"stmt_send_long_data\",\n     (char *)offsetof(System_status_var, com_stmt_send_long_data),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"truncate\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_TRUNCATE]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"uninstall_component\",\n     (char *)offsetof(System_status_var,\n                      com_stat[(uint)SQLCOM_UNINSTALL_COMPONENT]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"uninstall_plugin\",\n     (char *)offsetof(System_status_var,\n                      com_stat[(uint)SQLCOM_UNINSTALL_PLUGIN]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"unlock_instance\",\n     (char *)offsetof(System_status_var,\n                      com_stat[(uint)SQLCOM_UNLOCK_INSTANCE]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"unlock_tables\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_UNLOCK_TABLES]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"update\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_UPDATE]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"update_multi\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_UPDATE_MULTI]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"xa_commit\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_XA_COMMIT]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"xa_end\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_XA_END]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"xa_prepare\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_XA_PREPARE]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"xa_recover\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_XA_RECOVER]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"xa_rollback\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_XA_ROLLBACK]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {\"xa_start\",\n     (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_XA_START]),\n     SHOW_LONG_STATUS, SHOW_SCOPE_ALL},\n    {NullS, NullS, SHOW_LONG, SHOW_SCOPE_ALL}};\n\nLEX_CSTRING sql_statement_names[(uint)SQLCOM_END + 1];\n\nstatic void init_sql_statement_names() {\n  char *first_com = (char *)offsetof(System_status_var, com_stat[0]);\n  char *last_com =\n      (char *)offsetof(System_status_var, com_stat[(uint)SQLCOM_END]);\n  int record_size = (char *)offsetof(System_status_var, com_stat[1]) -\n                    (char *)offsetof(System_status_var, com_stat[0]);\n  char *ptr;\n  uint i;\n  uint com_index;\n\n  for (i = 0; i < ((uint)SQLCOM_END + 1); i++)\n    sql_statement_names[i] = {STRING_WITH_LEN(\"\")};\n\n  SHOW_VAR *var = &com_status_vars[0];\n  while (var->name != nullptr) {\n    ptr = var->value;\n    if ((first_com <= ptr) && (ptr <= last_com)) {\n      com_index = ((int)(ptr - first_com)) / record_size;\n      DBUG_ASSERT(com_index < (uint)SQLCOM_END);\n      sql_statement_names[com_index].str = var->name;\n      /* TODO: Change SHOW_VAR::name to a LEX_STRING, to avoid strlen() */\n      sql_statement_names[com_index].length = strlen(var->name);\n    }\n    var++;\n  }\n\n  DBUG_ASSERT(strcmp(sql_statement_names[(uint)SQLCOM_SELECT].str, \"select\") ==\n              0);\n  DBUG_ASSERT(strcmp(sql_statement_names[(uint)SQLCOM_SIGNAL].str, \"signal\") ==\n              0);\n\n  sql_statement_names[(uint)SQLCOM_END].str = \"error\";\n}\n\n#ifdef HAVE_PSI_STATEMENT_INTERFACE\nPSI_statement_info sql_statement_info[(uint)SQLCOM_END + 1];\nPSI_statement_info com_statement_info[(uint)COM_END + 1];\n\n/**\n  Initialize the command names array.\n  Since we do not want to maintain a separate array,\n  this is populated from data mined in com_status_vars,\n  which already has one name for each command.\n*/\nstatic void init_sql_statement_info() {\n  uint i;\n\n  for (i = 0; i < ((uint)SQLCOM_END + 1); i++) {\n    sql_statement_info[i].m_name = sql_statement_names[i].str;\n    sql_statement_info[i].m_flags = 0;\n    sql_statement_info[i].m_documentation = PSI_DOCUMENT_ME;\n  }\n\n  /* \"statement/sql/error\" represents broken queries (syntax error). */\n  sql_statement_info[(uint)SQLCOM_END].m_name = \"error\";\n  sql_statement_info[(uint)SQLCOM_END].m_flags = 0;\n  sql_statement_info[(uint)SQLCOM_END].m_documentation =\n      \"Invalid SQL queries (syntax error).\";\n\n  /* \"statement/sql/clone\" will mutate to clone plugin statement */\n  sql_statement_info[(uint)SQLCOM_CLONE].m_flags = PSI_FLAG_MUTABLE;\n}\n\nstatic void init_com_statement_info() {\n  uint index;\n\n  for (index = 0; index < (uint)COM_END + 1; index++) {\n    com_statement_info[index].m_name = command_name[index].str;\n    com_statement_info[index].m_flags = 0;\n    com_statement_info[index].m_documentation = PSI_DOCUMENT_ME;\n  }\n\n  /* \"statement/abstract/query\" can mutate into \"statement/sql/...\" */\n  com_statement_info[(uint)COM_QUERY].m_flags = PSI_FLAG_MUTABLE;\n  com_statement_info[(uint)COM_QUERY].m_documentation =\n      \"SQL query just received from the network. \"\n      \"At this point, the real statement type is unknown, \"\n      \"the type will be refined after SQL parsing.\";\n\n  /* \"statement/com/clone\" will mutate to clone plugin statement */\n  com_statement_info[(uint)COM_CLONE].m_flags = PSI_FLAG_MUTABLE;\n}\n#endif\n\n/**\n  Create a replication file name or base for file names.\n\n  @param     key Instrumentation key used to track allocations\n  @param[in] opt Value of option, or NULL\n  @param[in] def Default value if option value is not set.\n  @param[in] ext Extension to use for the path\n\n  @returns Pointer to string containing the full file path, or NULL if\n  it was not possible to create the path.\n */\nstatic inline const char *rpl_make_log_name(PSI_memory_key key, const char *opt,\n                                            const char *def, const char *ext) {\n  DBUG_TRACE;\n  DBUG_PRINT(\"enter\", (\"opt: %s, def: %s, ext: %s\", (opt && opt[0]) ? opt : \"\",\n                       def, ext));\n  char buff[FN_REFLEN];\n  /*\n    opt[0] needs to be checked to make sure opt name is not an empty\n    string, incase it is an empty string default name will be considered\n  */\n  const char *base = (opt && opt[0]) ? opt : def;\n  unsigned int options = MY_REPLACE_EXT | MY_UNPACK_FILENAME | MY_SAFE_PATH;\n\n  /* mysql_real_data_home_ptr may be null if no value of datadir has been\n     specified through command-line or througha cnf file. If that is the\n     case we make mysql_real_data_home_ptr point to mysql_real_data_home\n     which, in that case holds the default path for data-dir.\n  */\n\n  DBUG_EXECUTE_IF(\"emulate_empty_datadir_param\",\n                  { mysql_real_data_home_ptr = nullptr; };);\n\n  if (mysql_real_data_home_ptr == nullptr)\n    mysql_real_data_home_ptr = mysql_real_data_home;\n\n  if (fn_format(buff, base, mysql_real_data_home_ptr, ext, options))\n    return my_strdup(key, buff, MYF(0));\n  else\n    return nullptr;\n}\n\nint init_common_variables() {\n  umask(((~my_umask) & 0666));\n  my_decimal_set_zero(&decimal_zero);  // set decimal_zero constant;\n  tzset();                             // Set tzname\n\n  max_system_variables.pseudo_thread_id = (my_thread_id)~0;\n  server_start_time = flush_status_time = my_time(0);\n\n  binlog_filter = new Rpl_filter;\n  if (!binlog_filter) {\n    LogErr(ERROR_LEVEL, ER_RPL_BINLOG_FILTERS_OOM, strerror(errno));\n    return 1;\n  }\n\n  if (init_thread_environment() || mysql_init_variables()) return 1;\n\n  {\n    struct tm tm_tmp;\n    localtime_r(&server_start_time, &tm_tmp);\n#ifdef _WIN32\n    strmake(system_time_zone, _tzname[tm_tmp.tm_isdst != 0 ? 1 : 0],\n            sizeof(system_time_zone) - 1);\n#else\n    strmake(system_time_zone, tzname[tm_tmp.tm_isdst != 0 ? 1 : 0],\n            sizeof(system_time_zone) - 1);\n#endif\n  }\n  /*\n    We set SYSTEM time zone as reasonable default and\n    also for failure of my_tz_init() and bootstrap mode.\n    If user explicitly set time zone with --default-time-zone\n    option we will change this value in my_tz_init().\n  */\n  global_system_variables.time_zone = my_tz_SYSTEM;\n\n#ifdef HAVE_PSI_INTERFACE\n  /*\n    Complete the mysql_bin_log initialization.\n    Instrumentation keys are known only after the performance schema\n    initialization, and can not be set in the MYSQL_BIN_LOG constructor (called\n    before main()).\n  */\n  mysql_bin_log.set_psi_keys(\n      key_BINLOG_LOCK_index, key_BINLOG_LOCK_commit,\n      key_BINLOG_LOCK_commit_queue, key_BINLOG_LOCK_done,\n      key_BINLOG_LOCK_flush_queue, key_BINLOG_LOCK_log,\n      key_BINLOG_LOCK_binlog_end_pos, key_BINLOG_LOCK_sync,\n      key_BINLOG_LOCK_sync_queue, key_BINLOG_LOCK_xids, key_BINLOG_COND_done,\n      key_BINLOG_update_cond, key_BINLOG_prep_xids_cond, key_file_binlog,\n      key_file_binlog_index, key_file_binlog_cache,\n      key_file_binlog_index_cache);\n#endif\n\n  /*\n    Init mutexes for the global MYSQL_BIN_LOG objects.\n    As safe_mutex depends on what MY_INIT() does, we can't init the mutexes of\n    global MYSQL_BIN_LOGs in their constructors, because then they would be\n    inited before MY_INIT(). So we do it here.\n  */\n  mysql_bin_log.init_pthread_objects();\n\n  /* TODO: remove this when my_time_t is 64 bit compatible */\n  if (!is_time_t_valid_for_timestamp(server_start_time)) {\n    LogErr(ERROR_LEVEL, ER_UNSUPPORTED_DATE);\n    return 1;\n  }\n\n  if (gethostname(glob_hostname, sizeof(glob_hostname)) < 0) {\n    strmake(glob_hostname, STRING_WITH_LEN(\"localhost\"));\n    LogErr(WARNING_LEVEL, ER_CALL_ME_LOCALHOST, glob_hostname);\n    strmake(default_logfile_name, STRING_WITH_LEN(\"mysql\"));\n  } else\n    strmake(default_logfile_name, glob_hostname,\n            sizeof(default_logfile_name) - 5);\n\n  strmake(default_binlogfile_name, STRING_WITH_LEN(\"binlog\"));\n  if (opt_initialize || opt_initialize_insecure) {\n    /*\n      System tables initialization are not binary logged (regardless\n      --log-bin option).\n\n      Disable binary log while executing any user script sourced while\n      initializing system except if explicitly requested.\n    */\n    opt_bin_log = false;\n  }\n\n  strmake(pidfile_name, default_logfile_name, sizeof(pidfile_name) - 5);\n  my_stpcpy(fn_ext(pidfile_name), \".pid\");  // Add proper extension\n\n  /*\n    The default-storage-engine entry in my_long_options should have a\n    non-null default value. It was earlier intialized as\n    (longlong)\"MyISAM\" in my_long_options but this triggered a\n    compiler error in the Sun Studio 12 compiler. As a work-around we\n    set the def_value member to 0 in my_long_options and initialize it\n    to the correct value here.\n\n    From MySQL 5.5 onwards, the default storage engine is InnoDB.\n  */\n  default_storage_engine = \"InnoDB\";\n  default_tmp_storage_engine = default_storage_engine;\n\n  /*\n    Add server status variables to the dynamic list of\n    status variables that is shown by SHOW STATUS.\n    Later, in plugin_register_builtin_and_init_core_se(),\n    plugin_register_dynamic_and_init_all() and\n    mysql_install_plugin(), new entries could be added\n    to that list.\n  */\n  if (add_status_vars(status_vars)) return 1;  // an error was already reported\n\n#ifndef DBUG_OFF\n  /*\n    We have few debug-only commands in com_status_vars, only visible in debug\n    builds. for simplicity we enable the assert only in debug builds\n\n    There are 8 Com_ variables which don't have corresponding SQLCOM_ values:\n    (TODO strictly speaking they shouldn't be here, should not have Com_ prefix\n    that is. Perhaps Stmt_ ? Comstmt_ ? Prepstmt_ ?)\n\n      Com_admin_commands       => com_other\n      Com_stmt_close           => com_stmt_close\n      Com_stmt_execute         => com_stmt_execute\n      Com_stmt_fetch           => com_stmt_fetch\n      Com_stmt_prepare         => com_stmt_prepare\n      Com_stmt_reprepare       => com_stmt_reprepare\n      Com_stmt_reset           => com_stmt_reset\n      Com_stmt_send_long_data  => com_stmt_send_long_data\n\n    With this correction the number of Com_ variables (number of elements in\n    the array, excluding the last element - terminator) must match the number\n    of SQLCOM_ constants.\n  */\n  static_assert(sizeof(com_status_vars) / sizeof(com_status_vars[0]) - 1 ==\n                    SQLCOM_END + 7,\n                \"\");\n#endif\n\n  if (get_options(&remaining_argc, &remaining_argv)) return 1;\n\n  /*\n    The opt_bin_log can be false (binary log is disabled) only if\n    --skip-log-bin/--disable-log-bin is configured or while the\n    system is initializing.\n  */\n  if (!opt_bin_log) {\n    /*\n      The log-slave-updates should be disabled if binary log is disabled\n      and --log-slave-updates option is not set explicitly on command\n      line or configuration file.\n    */\n    if (!log_slave_updates_supplied) opt_log_slave_updates = false;\n    /*\n      The slave-preserve-commit-order should be disabled if binary log is\n      disabled and --slave-preserve-commit-order option is not set\n      explicitly on command line or configuration file.\n    */\n    if (!slave_preserve_commit_order_supplied)\n      opt_slave_preserve_commit_order = false;\n  }\n\n  if (opt_protocol_compression_algorithms) {\n    if ((opt_protocol_compression_algorithms[0] == 0) ||\n        (validate_compression_attributes(\n            std::string(opt_protocol_compression_algorithms), std::string(),\n            true))) {\n      /*\n       --protocol-compression-algorithms is set to invalid value, resetting\n       its value to default \"zlib,zstd,uncompressed\"\n      */\n      opt_protocol_compression_algorithms =\n          const_cast<char *>(PROTOCOL_COMPRESSION_DEFAULT_VALUE);\n      LogErr(WARNING_LEVEL, ER_PROTOCOL_COMPRESSION_RESET_LOG);\n    }\n  }\n  update_parser_max_mem_size();\n\n  if (set_default_auth_plugin(default_auth_plugin,\n                              strlen(default_auth_plugin))) {\n    LogErr(ERROR_LEVEL, ER_AUTH_CANT_SET_DEFAULT_PLUGIN);\n    return 1;\n  }\n  set_server_version();\n\n  if (!is_help_or_validate_option()) {\n    LogErr(INFORMATION_LEVEL, ER_BASEDIR_SET_TO, mysql_home);\n  }\n\n  if (!opt_validate_config && (opt_initialize || opt_initialize_insecure)) {\n    LogErr(SYSTEM_LEVEL, ER_STARTING_INIT, my_progname, server_version,\n           (ulong)getpid());\n  } else if (!is_help_or_validate_option()) {\n    LogErr(SYSTEM_LEVEL, ER_STARTING_AS, my_progname, server_version,\n           (ulong)getpid());\n  }\n  if (opt_help && !opt_verbose) unireg_abort(MYSQLD_SUCCESS_EXIT);\n\n  DBUG_PRINT(\"info\", (\"%s  Ver %s for %s on %s\\n\", my_progname, server_version,\n                      SYSTEM_TYPE, MACHINE_TYPE));\n\n#ifdef HAVE_LINUX_LARGE_PAGES\n  /* Initialize large page size */\n  if (opt_large_pages && (opt_large_page_size = my_get_large_page_size())) {\n    DBUG_PRINT(\"info\",\n               (\"Large page set, large_page_size = %d\", opt_large_page_size));\n  } else {\n    opt_large_pages = false;\n    /*\n       Either not configured to use large pages or Linux haven't\n       been compiled with large page support\n    */\n  }\n#endif /* HAVE_LINUX_LARGE_PAGES */\n#ifdef HAVE_SOLARIS_LARGE_PAGES\n#define LARGE_PAGESIZE (4 * 1024 * 1024)         /* 4MB */\n#define SUPER_LARGE_PAGESIZE (256 * 1024 * 1024) /* 256MB */\n  if (opt_large_pages) {\n    /*\n      tell the kernel that we want to use 4/256MB page for heap storage\n      and also for the stack. We use 4 MByte as default and if the\n      super-large-page is set we increase it to 256 MByte. 256 MByte\n      is for server installations with GBytes of RAM memory where\n      the MySQL Server will have page caches and other memory regions\n      measured in a number of GBytes.\n      We use as big pages as possible which isn't bigger than the above\n      desired page sizes.\n    */\n    int nelem;\n    size_t max_desired_page_size;\n    if (opt_super_large_pages)\n      max_desired_page_size = SUPER_LARGE_PAGESIZE;\n    else\n      max_desired_page_size = LARGE_PAGESIZE;\n    nelem = getpagesizes(NULL, 0);\n    if (nelem > 0) {\n      size_t *pagesize = (size_t *)malloc(sizeof(size_t) * nelem);\n      if (pagesize != NULL && getpagesizes(pagesize, nelem) > 0) {\n        size_t max_page_size = 0;\n        for (int i = 0; i < nelem; i++) {\n          if (pagesize[i] > max_page_size &&\n              pagesize[i] <= max_desired_page_size)\n            max_page_size = pagesize[i];\n        }\n        free(pagesize);\n        if (max_page_size > 0) {\n          struct memcntl_mha mpss;\n\n          mpss.mha_cmd = MHA_MAPSIZE_BSSBRK;\n          mpss.mha_pagesize = max_page_size;\n          mpss.mha_flags = 0;\n          memcntl(NULL, 0, MC_HAT_ADVISE, (caddr_t)&mpss, 0, 0);\n          mpss.mha_cmd = MHA_MAPSIZE_STACK;\n          memcntl(NULL, 0, MC_HAT_ADVISE, (caddr_t)&mpss, 0, 0);\n        }\n      }\n    }\n  }\n#endif /* HAVE_SOLARIS_LARGE_PAGES */\n\n  longlong default_value;\n  sys_var *var;\n  /* Calculate and update default value for thread_cache_size. */\n  if ((default_value = 8 + max_connections / 100) > 100) default_value = 100;\n  var = intern_find_sys_var(STRING_WITH_LEN(\"thread_cache_size\"));\n  var->update_default(default_value);\n\n  /* Calculate and update default value for host_cache_size. */\n  if ((default_value = 128 + max_connections) > 628 &&\n      (default_value = 628 + ((max_connections - 500) / 20)) > 2000)\n    default_value = 2000;\n  var = intern_find_sys_var(STRING_WITH_LEN(\"host_cache_size\"));\n  var->update_default(default_value);\n\n  /* Fix thread_cache_size. */\n  if (!thread_cache_size_specified &&\n      (Per_thread_connection_handler::max_blocked_pthreads =\n           8 + max_connections / 100) > 100)\n    Per_thread_connection_handler::max_blocked_pthreads = 100;\n\n  /* Fix host_cache_size. */\n  if (!host_cache_size_specified &&\n      (host_cache_size = 128 + max_connections) > 628 &&\n      (host_cache_size = 628 + ((max_connections - 500) / 20)) > 2000)\n    host_cache_size = 2000;\n\n  /* Fix back_log */\n  if (back_log == 0 && (back_log = max_connections) > 65535) back_log = 65535;\n\n  unireg_init(opt_specialflag); /* Set up extern variables */\n  while (!(my_default_lc_messages =\n               my_locale_by_name(nullptr, lc_messages, strlen(lc_messages)))) {\n    LogErr(ERROR_LEVEL, ER_FAILED_TO_FIND_LOCALE_NAME, lc_messages);\n    if (!my_strcasecmp(&my_charset_latin1, lc_messages,\n                       mysqld_default_locale_name))\n      return 1;\n    lc_messages = mysqld_default_locale_name;\n  }\n  global_system_variables.lc_messages = my_default_lc_messages;\n  if (init_errmessage()) /* Read error messages from file */\n    return 1;\n  init_client_errs();\n\n  mysql_client_plugin_init();\n  if (item_create_init()) return 1;\n  item_init();\n  range_optimizer_init();\n  my_string_stack_guard = check_enough_stack_size;\n  /*\n    Process a comma-separated character set list and choose\n    the first available character set. This is mostly for\n    test purposes, to be able to start \"mysqld\" even if\n    the requested character set is not available (see bug#18743).\n  */\n  for (;;) {\n    char *next_character_set_name =\n        strchr(const_cast<char *>(default_character_set_name), ',');\n    if (next_character_set_name) *next_character_set_name++ = '\\0';\n    if (!(default_charset_info = get_charset_by_csname(\n              default_character_set_name, MY_CS_PRIMARY, MYF(MY_WME)))) {\n      if (next_character_set_name) {\n        default_character_set_name = next_character_set_name;\n        default_collation_name = nullptr;  // Ignore collation\n      } else\n        return 1;  // Eof of the list\n    } else {\n      warn_on_deprecated_charset(nullptr, default_charset_info,\n                                 default_character_set_name,\n                                 \"--character-set-server\");\n      break;\n    }\n  }\n\n  if (default_collation_name) {\n    CHARSET_INFO *default_collation;\n    default_collation = get_charset_by_name(default_collation_name, MYF(0));\n    if (!default_collation) {\n      LogErr(ERROR_LEVEL, ER_FAILED_TO_FIND_COLLATION_NAME,\n             default_collation_name);\n      return 1;\n    }\n    if (!my_charset_same(default_charset_info, default_collation)) {\n      LogErr(ERROR_LEVEL, ER_INVALID_COLLATION_FOR_CHARSET,\n             default_collation_name, default_charset_info->csname);\n      return 1;\n    }\n    warn_on_deprecated_collation(nullptr, default_collation,\n                                 \"--collation-server\");\n    default_charset_info = default_collation;\n  }\n  /* Set collactions that depends on the default collation */\n  global_system_variables.collation_server = default_charset_info;\n  global_system_variables.collation_database = default_charset_info;\n  global_system_variables.default_collation_for_utf8mb4 =\n      &my_charset_utf8mb4_0900_ai_ci;\n\n  if (is_supported_parser_charset(default_charset_info)) {\n    global_system_variables.collation_connection = default_charset_info;\n    global_system_variables.character_set_results = default_charset_info;\n    global_system_variables.character_set_client = default_charset_info;\n  } else {\n    LogErr(INFORMATION_LEVEL, ER_FIXING_CLIENT_CHARSET,\n           default_charset_info->csname, my_charset_latin1.csname);\n    global_system_variables.collation_connection = &my_charset_latin1;\n    global_system_variables.character_set_results = &my_charset_latin1;\n    global_system_variables.character_set_client = &my_charset_latin1;\n  }\n\n  if (!(character_set_filesystem = get_charset_by_csname(\n            character_set_filesystem_name, MY_CS_PRIMARY, MYF(MY_WME))))\n    return 1;\n  else\n    warn_on_deprecated_charset(nullptr, character_set_filesystem,\n                               character_set_filesystem_name,\n                               \"--character-set-filesystem\");\n  global_system_variables.character_set_filesystem = character_set_filesystem;\n\n  if (lex_init()) {\n    LogErr(ERROR_LEVEL, ER_OOM);\n    return 1;\n  }\n\n  while (!(my_default_lc_time_names = my_locale_by_name(\n               nullptr, lc_time_names_name, strlen(lc_time_names_name)))) {\n    LogErr(ERROR_LEVEL, ER_FAILED_TO_FIND_LOCALE_NAME, lc_time_names_name);\n    if (!my_strcasecmp(&my_charset_latin1, lc_time_names_name,\n                       mysqld_default_locale_name))\n      return 1;\n    lc_time_names_name = mysqld_default_locale_name;\n  }\n  global_system_variables.lc_time_names = my_default_lc_time_names;\n\n  /* check log options and issue warnings if needed */\n  if (opt_general_log && opt_general_logname &&\n      !(log_output_options & LOG_FILE) && !(log_output_options & LOG_NONE))\n    LogErr(WARNING_LEVEL, ER_LOG_FILES_GIVEN_LOG_OUTPUT_IS_TABLE,\n           \"--general-log-file option\");\n\n  if (opt_slow_log && opt_slow_logname && !(log_output_options & LOG_FILE) &&\n      !(log_output_options & LOG_NONE))\n    LogErr(WARNING_LEVEL, ER_LOG_FILES_GIVEN_LOG_OUTPUT_IS_TABLE,\n           \"--slow-query-log-file option\");\n\n  if (opt_general_logname &&\n      !is_valid_log_name(opt_general_logname, strlen(opt_general_logname))) {\n    LogErr(ERROR_LEVEL, ER_LOG_FILE_INVALID, \"--general_log_file\",\n           opt_general_logname);\n    return 1;\n  }\n\n  if (opt_slow_logname &&\n      !is_valid_log_name(opt_slow_logname, strlen(opt_slow_logname))) {\n    LogErr(ERROR_LEVEL, ER_LOG_FILE_INVALID, \"--slow_query_log_file\",\n           opt_slow_logname);\n    return 1;\n  }\n\n  if (global_system_variables.transaction_write_set_extraction ==\n          HASH_ALGORITHM_OFF &&\n      mysql_bin_log.m_dependency_tracker.m_opt_tracking_mode !=\n          DEPENDENCY_TRACKING_COMMIT_ORDER) {\n    LogErr(ERROR_LEVEL,\n           ER_TX_EXTRACTION_ALGORITHM_FOR_BINLOG_TX_DEPEDENCY_TRACKING,\n           \"XXHASH64 or MURMUR32\", \"WRITESET or WRITESET_SESSION\");\n    return 1;\n  } else\n    mysql_bin_log.m_dependency_tracker.tracking_mode_changed();\n\n#define FIX_LOG_VAR(VAR, ALT) \\\n  if (!VAR || !*VAR) VAR = ALT;\n\n  FIX_LOG_VAR(opt_general_logname,\n              make_query_log_name(logname_path, QUERY_LOG_GENERAL));\n  FIX_LOG_VAR(opt_slow_logname,\n              make_query_log_name(slow_logname_path, QUERY_LOG_SLOW));\n\n#if defined(ENABLED_DEBUG_SYNC)\n  /* Initialize the debug sync facility. See debug_sync.cc. */\n  if (debug_sync_init()) return 1; /* purecov: tested */\n#endif                             /* defined(ENABLED_DEBUG_SYNC) */\n\n  if (opt_validate_config) return 0;\n\n  /* create the data directory if requested */\n  if (unlikely(opt_initialize) &&\n      initialize_create_data_directory(mysql_real_data_home))\n    return 1;\n\n  /*\n    Ensure that lower_case_table_names is set on system where we have case\n    insensitive names.  If this is not done the users MyISAM tables will\n    get corrupted if accesses with names of different case.\n  */\n  DBUG_PRINT(\"info\", (\"lower_case_table_names: %d\", lower_case_table_names));\n  lower_case_file_system = test_if_case_insensitive(mysql_real_data_home);\n  if (!lower_case_table_names && lower_case_file_system == 1) {\n    if (lower_case_table_names_used) {\n      LogErr(ERROR_LEVEL, ER_LOWER_CASE_TABLE_NAMES_CS_DD_ON_CI_FS_UNSUPPORTED);\n      return 1;\n    } else {\n      LogErr(WARNING_LEVEL, ER_LOWER_CASE_TABLE_NAMES_USING_2,\n             mysql_real_data_home);\n      lower_case_table_names = 2;\n    }\n  } else if (lower_case_table_names == 2 &&\n             !(lower_case_file_system =\n                   (test_if_case_insensitive(mysql_real_data_home) == 1))) {\n    LogErr(WARNING_LEVEL, ER_LOWER_CASE_TABLE_NAMES_USING_0,\n           mysql_real_data_home);\n    lower_case_table_names = 0;\n  } else {\n    lower_case_file_system =\n        (test_if_case_insensitive(mysql_real_data_home) == 1);\n  }\n\n  /* Reset table_alias_charset, now that lower_case_table_names is set. */\n  table_alias_charset =\n      (lower_case_table_names ? &my_charset_utf8_tolower_ci : &my_charset_bin);\n\n  /*\n    Build do_table and ignore_table rules to hashes\n    after the resetting of table_alias_charset.\n  */\n  if (rpl_global_filter.build_do_table_hash() ||\n      rpl_global_filter.build_ignore_table_hash()) {\n    LogErr(ERROR_LEVEL, ER_CANT_HASH_DO_AND_IGNORE_RULES);\n    return 1;\n  }\n\n  /*\n    Reset the P_S view for global replication filter at\n    the end of server startup.\n  */\n#ifdef WITH_PERFSCHEMA_STORAGE_ENGINE\n  rpl_global_filter.wrlock();\n  rpl_global_filter.reset_pfs_view();\n  rpl_global_filter.unlock();\n#endif /* WITH_PERFSCHEMA_STORAGE_ENGINE */\n\n  if (rpl_channel_filters.build_do_and_ignore_table_hashes()) return 1;\n\n  return 0;\n}\n\nstatic int init_thread_environment() {\n  mysql_mutex_init(key_LOCK_status, &LOCK_status, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_manager, &LOCK_manager, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_crypt, &LOCK_crypt, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_user_conn, &LOCK_user_conn, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_global_system_variables,\n                   &LOCK_global_system_variables, MY_MUTEX_INIT_FAST);\n  mysql_rwlock_init(key_rwlock_LOCK_system_variables_hash,\n                    &LOCK_system_variables_hash);\n  mysql_mutex_init(key_LOCK_prepared_stmt_count, &LOCK_prepared_stmt_count,\n                   MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_sql_slave_skip_counter,\n                   &LOCK_sql_slave_skip_counter, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_slave_net_timeout, &LOCK_slave_net_timeout,\n                   MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_slave_trans_dep_tracker,\n                   &LOCK_slave_trans_dep_tracker, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_error_messages, &LOCK_error_messages,\n                   MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_uuid_generator, &LOCK_uuid_generator,\n                   MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_sql_rand, &LOCK_sql_rand, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_log_throttle_qni, &LOCK_log_throttle_qni,\n                   MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_default_password_lifetime,\n                   &LOCK_default_password_lifetime, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_mandatory_roles, &LOCK_mandatory_roles,\n                   MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_password_history, &LOCK_password_history,\n                   MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_password_reuse_interval,\n                   &LOCK_password_reuse_interval, MY_MUTEX_INIT_FAST);\n  mysql_rwlock_init(key_rwlock_LOCK_sys_init_connect, &LOCK_sys_init_connect);\n  mysql_rwlock_init(key_rwlock_LOCK_sys_init_slave, &LOCK_sys_init_slave);\n  mysql_cond_init(key_COND_manager, &COND_manager);\n  mysql_mutex_init(key_LOCK_server_started, &LOCK_server_started,\n                   MY_MUTEX_INIT_FAST);\n  mysql_cond_init(key_COND_server_started, &COND_server_started);\n  mysql_mutex_init(key_LOCK_reset_gtid_table, &LOCK_reset_gtid_table,\n                   MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_compress_gtid_table, &LOCK_compress_gtid_table,\n                   MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_collect_instance_log, &LOCK_collect_instance_log,\n                   MY_MUTEX_INIT_FAST);\n  mysql_cond_init(key_COND_compress_gtid_table, &COND_compress_gtid_table);\n\n  mysql_mutex_init(key_LOCK_global_user_client_stats,\n                   &LOCK_global_user_client_stats, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_global_table_stats, &LOCK_global_table_stats,\n                   MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_global_index_stats, &LOCK_global_index_stats,\n                   MY_MUTEX_INIT_FAST);\n\n  Events::init_mutexes();\n#if defined(_WIN32)\n  mysql_mutex_init(key_LOCK_handler_count, &LOCK_handler_count,\n                   MY_MUTEX_INIT_FAST);\n  mysql_cond_init(key_COND_handler_count, &COND_handler_count);\n  mysql_rwlock_init(key_rwlock_LOCK_named_pipe_full_access_group,\n                    &LOCK_named_pipe_full_access_group);\n#else\n  mysql_mutex_init(key_LOCK_socket_listener_active,\n                   &LOCK_socket_listener_active, MY_MUTEX_INIT_FAST);\n  mysql_cond_init(key_COND_socket_listener_active,\n                  &COND_socket_listener_active);\n  mysql_mutex_init(key_LOCK_start_signal_handler, &LOCK_start_signal_handler,\n                   MY_MUTEX_INIT_FAST);\n  mysql_cond_init(key_COND_start_signal_handler, &COND_start_signal_handler);\n#endif  // _WIN32\n  /* Parameter for threads created for connections */\n  (void)my_thread_attr_init(&connection_attrib);\n  my_thread_attr_setdetachstate(&connection_attrib, MY_THREAD_CREATE_DETACHED);\n#ifndef _WIN32\n  pthread_attr_setscope(&connection_attrib, PTHREAD_SCOPE_SYSTEM);\n#endif\n\n  mysql_mutex_init(key_LOCK_keyring_operations, &LOCK_keyring_operations,\n                   MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_tls_ctx_options, &LOCK_tls_ctx_options,\n                   MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_rotate_binlog_master_key,\n                   &LOCK_rotate_binlog_master_key, MY_MUTEX_INIT_FAST);\n  return 0;\n}\n\n#if !defined(__sun)\n/* TODO: remove the !defined(__sun) when bug 23285559 is out of the picture */\n\nstatic PSI_memory_key key_memory_openssl = PSI_NOT_INSTRUMENTED;\n\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\n#define FILE_LINE_ARGS\n#else\n#define FILE_LINE_ARGS , const char *, int\n#endif\n\nstatic void *my_openssl_malloc(size_t size FILE_LINE_ARGS) {\n  return my_malloc(key_memory_openssl, size, MYF(MY_WME));\n}\nstatic void *my_openssl_realloc(void *ptr, size_t size FILE_LINE_ARGS) {\n  return my_realloc(key_memory_openssl, ptr, size, MYF(MY_WME));\n}\nstatic void my_openssl_free(void *ptr FILE_LINE_ARGS) { return my_free(ptr); }\n#endif /* !defined(__sun) */\n\nstatic void init_ssl() {\n#if !defined(__sun)\n#if defined(HAVE_PSI_MEMORY_INTERFACE)\n  static PSI_memory_info all_openssl_memory[] = {\n      {&key_memory_openssl, \"openssl_malloc\", 0, 0,\n       \"All memory used by openSSL\"}};\n  mysql_memory_register(\"mysqld_openssl\", all_openssl_memory,\n                        (int)array_elements(all_openssl_memory));\n#endif /* defined(HAVE_PSI_MEMORY_INTERFACE) */\n  int ret = CRYPTO_set_mem_functions(my_openssl_malloc, my_openssl_realloc,\n                                     my_openssl_free);\n  if (ret == 0)\n    LogErr(WARNING_LEVEL, ER_SSL_MEMORY_INSTRUMENTATION_INIT_FAILED,\n           \"CRYPTO_set_mem_functions\");\n#endif /* !defined(__sun) */\n  ssl_start();\n}\n\nstatic int init_ssl_communication() {\n  char ssl_err_string[OPENSSL_ERROR_LENGTH] = {'\\0'};\n  int ret_fips_mode = set_fips_mode(opt_ssl_fips_mode, ssl_err_string);\n  if (ret_fips_mode != 1) {\n    LogErr(ERROR_LEVEL, ER_SSL_FIPS_MODE_ERROR, ssl_err_string);\n    return 1;\n  }\n  if (SslAcceptorContext::singleton_init(opt_use_ssl)) return 1;\n\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\n  ERR_remove_thread_state(0);\n#endif /* OPENSSL_VERSION_NUMBER < 0x10100000L */\n\n  if (init_rsa_keys()) return 1;\n  return 0;\n}\n\nstatic void end_ssl() {\n  SslAcceptorContext::singleton_deinit();\n  deinit_rsa_keys();\n}\n\n/**\n  Generate a UUID and save it into server_uuid variable.\n\n  @return Retur 0 or 1 if an error occurred.\n */\nstatic int generate_server_uuid() {\n  THD *thd;\n  Item_func_uuid *func_uuid;\n  String uuid;\n\n  /*\n    To be able to run this from boot, we allocate a temporary THD\n   */\n  if (!(thd = new THD)) {\n    LogErr(ERROR_LEVEL, ER_NO_THD_NO_UUID);\n    return 1;\n  }\n  thd->thread_stack = (char *)&thd;\n  thd->store_globals();\n\n  /*\n    Initialize the variables which are used during \"uuid generator\n    initialization\" with values that should normally differ between\n    mysqlds on the same host. This avoids that another mysqld started\n    at the same time on the same host get the same \"server_uuid\".\n  */\n\n  const time_t save_server_start_time = server_start_time;\n  server_start_time += ((ulonglong)current_pid << 48) + current_pid;\n  thd->status_var.bytes_sent = (ulonglong)thd;\n\n  lex_start(thd);\n  func_uuid = new (thd->mem_root) Item_func_uuid();\n  func_uuid->fixed = true;\n  func_uuid->val_str(&uuid);\n\n  // Restore global variables used for salting\n  server_start_time = save_server_start_time;\n\n  delete thd;\n\n  strncpy(server_uuid, uuid.c_ptr(), sizeof(server_uuid));\n  DBUG_EXECUTE_IF(\"server_uuid_deterministic\",\n                  memcpy(server_uuid, \"00000000-1111-0000-1111-000000000000\",\n                         UUID_LENGTH););\n  server_uuid[UUID_LENGTH] = '\\0';\n  return 0;\n}\n\n/**\n  Save all options which was auto-generated by server-self into the given file.\n\n  @param fname The name of the file in which the auto-generated options will b\n  e saved.\n\n  @return Return 0 or 1 if an error occurred.\n */\nstatic int flush_auto_options(const char *fname) {\n  File fd;\n  IO_CACHE io_cache;\n  int result = 0;\n\n  if ((fd = my_open(fname, O_CREAT | O_RDWR, MYF(MY_WME))) < 0) {\n    LogErr(ERROR_LEVEL, ER_AUTO_OPTIONS_FAILED, \"file\", fname, my_errno());\n    return 1;\n  }\n\n  if (init_io_cache(&io_cache, fd, IO_SIZE * 2, WRITE_CACHE, 0L, false,\n                    MYF(MY_WME))) {\n    LogErr(ERROR_LEVEL, ER_AUTO_OPTIONS_FAILED, \"a cache on \", fname,\n           my_errno());\n    my_close(fd, MYF(MY_WME));\n    return 1;\n  }\n\n  my_b_seek(&io_cache, 0L);\n  my_b_printf(&io_cache, \"%s\\n\", \"[auto]\");\n  my_b_printf(&io_cache, \"server-uuid=%s\\n\", server_uuid);\n\n  if (flush_io_cache(&io_cache) || my_sync(fd, MYF(MY_WME))) result = 1;\n\n  my_close(fd, MYF(MY_WME));\n  end_io_cache(&io_cache);\n  return result;\n}\n\n/**\n  File 'auto.cnf' resides in the data directory to hold values of options that\n  server evaluates itself and that needs to be durable to sustain the server\n  restart. There is only a section ['auto'] in the file. All these options are\n  in the section. Only one option exists now, it is server_uuid.\n  Note, the user may not supply any literal value to these auto-options, and\n  only allowed to trigger (re)evaluation.\n  For instance, 'server_uuid' value will be evaluated and stored if there is\n  no corresponding line in the file.\n  Because of the specifics of the auto-options, they need a seperate storage.\n  Meanwhile, it is the 'auto.cnf' that has the same structure as 'my.cnf'.\n\n  @todo consider to implement sql-query-able persistent storage by WL#5279.\n  @return Return 0 or 1 if an error occurred.\n */\nstatic int init_server_auto_options() {\n  bool flush = false;\n  char fname[FN_REFLEN];\n  char name[] = \"auto\";\n  char *name_ptr = name;\n  const char *groups[] = {\"auto\", nullptr};\n  char *uuid = nullptr;\n  my_option auto_options[] = {\n      {\"server-uuid\", 0, \"\", &uuid, &uuid, nullptr, GET_STR, REQUIRED_ARG, 0, 0,\n       0, nullptr, 0, nullptr},\n      {nullptr, 0, nullptr, nullptr, nullptr, nullptr, GET_NO_ARG, NO_ARG, 0, 0,\n       0, nullptr, 0, nullptr}};\n\n  DBUG_TRACE;\n\n  if (nullptr == fn_format(fname, \"auto.cnf\", mysql_data_home, \"\",\n                           MY_UNPACK_FILENAME | MY_SAFE_PATH))\n    return 1;\n\n  /* load_defaults require argv[0] is not null */\n  char **argv = &name_ptr;\n  int argc = 1;\n  if (!check_file_permissions(fname, false)) {\n    /*\n      Found a world writable file hence removing it as it is dangerous to write\n      a new UUID into the same file.\n     */\n    my_delete(fname, MYF(MY_WME));\n    LogErr(WARNING_LEVEL, ER_WRITABLE_CONFIG_REMOVED, fname);\n  }\n\n  /* load all options in 'auto.cnf'. */\n  MEM_ROOT alloc{PSI_NOT_INSTRUMENTED, 512};\n  if (my_load_defaults(fname, groups, &argc, &argv, &alloc, nullptr)) return 1;\n\n  if (handle_options(&argc, &argv, auto_options, mysqld_get_one_option))\n    return 1;\n\n  DBUG_PRINT(\"info\", (\"uuid=%p=%s server_uuid=%s\", uuid, uuid, server_uuid));\n  if (uuid) {\n    if (!binary_log::Uuid::is_valid(uuid, binary_log::Uuid::TEXT_LENGTH)) {\n      LogErr(ERROR_LEVEL, ER_UUID_INVALID);\n      goto err;\n    }\n    /*\n      Uuid::is_valid() cannot do strict check on the length as it will be\n      called by GTID::is_valid() as well (GTID = UUID:seq_no). We should\n      explicitly add the *length check* here in this function.\n\n      If UUID length is less than '36' (UUID_LENGTH), that error case would have\n      got caught in above is_valid check. The below check is to make sure that\n      length is not greater than UUID_LENGTH i.e., there are no extra characters\n      (Garbage) at the end of the valid UUID.\n    */\n    if (strlen(uuid) > UUID_LENGTH) {\n      LogErr(ERROR_LEVEL, ER_UUID_SCRUB, UUID_LENGTH);\n      goto err;\n    }\n    strcpy(server_uuid, uuid);\n  } else {\n    DBUG_PRINT(\"info\", (\"generating server_uuid\"));\n    flush = true;\n    /* server_uuid will be set in the function */\n    if (generate_server_uuid()) goto err;\n    DBUG_PRINT(\"info\", (\"generated server_uuid=%s\", server_uuid));\n    if (opt_initialize || opt_initialize_insecure) {\n      LogErr(INFORMATION_LEVEL, ER_CREATING_NEW_UUID_FIRST_START, server_uuid);\n\n    } else {\n      LogErr(WARNING_LEVEL, ER_CREATING_NEW_UUID, server_uuid);\n    }\n  }\n\n  if (flush) return flush_auto_options(fname);\n  return 0;\nerr:\n  return 1;\n}\n\nstatic bool initialize_storage_engine(const char *se_name, const char *se_kind,\n                                      plugin_ref *dest_plugin) {\n  LEX_CSTRING name = {se_name, strlen(se_name)};\n  plugin_ref plugin;\n  handlerton *hton;\n  if ((plugin = ha_resolve_by_name(nullptr, &name, false)))\n    hton = plugin_data<handlerton *>(plugin);\n  else {\n    LogErr(ERROR_LEVEL, ER_UNKNOWN_UNSUPPORTED_STORAGE_ENGINE, se_name);\n    return true;\n  }\n  if (!ha_storage_engine_is_enabled(hton)) {\n    if (!opt_initialize) {\n      LogErr(ERROR_LEVEL, ER_DEFAULT_SE_UNAVAILABLE, se_kind, se_name);\n      return true;\n    }\n    DBUG_ASSERT(*dest_plugin);\n  } else {\n    /*\n      Need to unlock as global_system_variables.table_plugin\n      was acquired during plugin_register_builtin_and_init_core_se()\n    */\n    plugin_ref old_dest_plugin = *dest_plugin;\n    *dest_plugin = plugin;\n    plugin_unlock(nullptr, old_dest_plugin);\n  }\n  return false;\n}\n\nstatic void setup_error_log() {\n/* Setup logs */\n\n/*\n  Enable old-fashioned error log, except when the user has requested\n  help information. Since the implementation of plugin server\n  variables the help output is now written much later.\n\n  log_error_dest can be:\n  disabled_my_option     --log-error was not used or --log-error=\n  \"\"                     --log-error without arguments (no '=')\n  filename               --log-error=filename\n*/\n#ifdef _WIN32\n  /*\n    Enable the error log file only if console option is not specified\n    and --help is not used.\n  */\n  bool log_errors_to_file = !is_help_or_validate_option() && !opt_console;\n#else\n  /*\n    Enable the error log file only if --log-error=filename or --log-error\n    was used. Logging to file is disabled by default unlike on Windows.\n  */\n  bool log_errors_to_file =\n      !is_help_or_validate_option() && (log_error_dest != disabled_my_option);\n#endif\n\n  enum log_error_stage les = LOG_ERROR_STAGE_BUFFERING_UNIPLEX;\n\n  if (log_errors_to_file) {\n    // Construct filename if no filename was given by the user.\n    if (!log_error_dest[0] || log_error_dest == disabled_my_option) {\n#ifdef _WIN32\n      const char *filename = pidfile_name;\n#else\n      const char *filename = default_logfile_name;\n#endif\n      fn_format(errorlog_filename_buff, filename, mysql_real_data_home, \".err\",\n                MY_REPLACE_EXT | /* replace '.<domain>' by '.err', bug#4997 */\n                    MY_REPLACE_DIR);\n    } else\n      fn_format(errorlog_filename_buff, log_error_dest, mysql_data_home, \".err\",\n                MY_UNPACK_FILENAME);\n    /*\n      log_error_dest may have been set to disabled_my_option or \"\" if no\n      argument was passed, but we need to show the real name in SHOW VARIABLES.\n    */\n    log_error_dest = errorlog_filename_buff;\n\n#ifndef _WIN32\n    // Create backup stream to stdout if deamonizing and connected to tty\n    if (opt_daemonize && isatty(STDOUT_FILENO)) {\n      nstdout = fdopen(dup(STDOUT_FILENO), \"a\");\n      if (nstdout == nullptr) {\n        LogErr(ERROR_LEVEL, ER_DUP_FD_OPEN_FAILED, \"stdout\", strerror(errno));\n        unireg_abort(MYSQLD_ABORT_EXIT);\n      }\n      // Display location of error log file on stdout if connected to tty\n      fprintf(nstdout, \"mysqld will log errors to %s\\n\",\n              errorlog_filename_buff);\n    }\n#endif /* ndef _WIN32 */\n\n    if (open_error_log(errorlog_filename_buff, false))\n      unireg_abort(MYSQLD_ABORT_EXIT);\n\n#ifdef _WIN32\n      // FreeConsole();        // Remove window\n#endif /* _WIN32 */\n  } else {\n    // We are logging to stderr and SHOW VARIABLES should reflect that.\n    log_error_dest = \"stderr\";\n\n    /*\n      We have no known file-name, and a non-standard logging pipeline,\n      so output of multiple log-writers may be multi-plexed to stderr.\n      This can result in false positives, but since we're only using\n      this to turn off some optimizations, this seems acceptable for now.\n      With regard to the pipeline, what matters is that a non-standard\n      set-up was requested, not that it is actually active at this point\n      (which it wouldn't be, we do not try to apply a user-supplied\n      configuration until external components are available).\n    */\n    if ((opt_log_error_services == nullptr) ||\n        (0 != strcmp(LOG_ERROR_SERVICES_DEFAULT, opt_log_error_services)))\n      les = LOG_ERROR_STAGE_BUFFERING_MULTIPLEX;\n  }\n\n  log_error_stage_set(les);\n}\n\nstatic int init_server_components() {\n  DBUG_TRACE;\n  /*\n    We need to call each of these following functions to ensure that\n    all things are initialized so that unireg_abort() doesn't fail\n  */\n  mdl_init();\n  partitioning_init();\n  if (table_def_init() | hostname_cache_init(host_cache_size))\n    unireg_abort(MYSQLD_ABORT_EXIT);\n\n  /*\n    Timers not needed if only starting with --help.\n  */\n  if (!is_help_or_validate_option()) {\n    if (my_timer_initialize())\n      LogErr(ERROR_LEVEL, ER_CANT_INIT_TIMER, errno);\n    else\n      have_statement_timeout = SHOW_OPTION_YES;\n  }\n\n  randominit(&sql_rand, (ulong)server_start_time, (ulong)server_start_time / 2);\n  setup_fpu();\n  init_slave_list();\n\n  init_global_table_stats();\n  init_global_index_stats();\n\n  setup_error_log();  // opens the log if needed\n\n  enter_cond_hook = thd_enter_cond;\n  exit_cond_hook = thd_exit_cond;\n  enter_stage_hook = thd_enter_stage;\n  set_waiting_for_disk_space_hook = thd_set_waiting_for_disk_space;\n  is_killed_hook = thd_killed;\n\n  if (transaction_cache_init()) {\n    LogErr(ERROR_LEVEL, ER_OOM);\n    unireg_abort(MYSQLD_ABORT_EXIT);\n  }\n\n  if (MDL_context_backup_manager::init()) {\n    LogErr(ERROR_LEVEL, ER_OOM);\n    unireg_abort(MYSQLD_ABORT_EXIT);\n  }\n\n  /*\n    initialize delegates for extension observers, errors have already\n    been reported in the function\n  */\n  if (delegates_init()) unireg_abort(MYSQLD_ABORT_EXIT);\n\n  /* need to configure logging before initializing storage engines */\n  if (opt_log_slave_updates && !opt_bin_log) {\n    LogErr(WARNING_LEVEL, ER_NEED_LOG_BIN, \"--log-slave-updates\");\n  }\n  if (binlog_format_used && !opt_bin_log)\n    LogErr(WARNING_LEVEL, ER_NEED_LOG_BIN, \"--binlog-format\");\n\n  /* Check that we have not let the format to unspecified at this point */\n  DBUG_ASSERT((uint)global_system_variables.binlog_format <=\n              array_elements(binlog_format_names) - 1);\n\n  opt_server_id_mask = ~ulong(0);\n  opt_server_id_mask =\n      (opt_server_id_bits == 32) ? ~ulong(0) : (1 << opt_server_id_bits) - 1;\n  if (server_id != (server_id & opt_server_id_mask)) {\n    LogErr(ERROR_LEVEL, ER_SERVERID_TOO_LARGE);\n    unireg_abort(MYSQLD_ABORT_EXIT);\n  }\n\n  if (opt_bin_log) {\n    /* Reports an error and aborts, if the --log-bin's path\n       is a directory.*/\n    if (opt_bin_logname &&\n        opt_bin_logname[strlen(opt_bin_logname) - 1] == FN_LIBCHAR) {\n      LogErr(ERROR_LEVEL, ER_NEED_FILE_INSTEAD_OF_DIR, \"--log-bin\",\n             opt_bin_logname);\n      unireg_abort(MYSQLD_ABORT_EXIT);\n    }\n\n    /* Reports an error and aborts, if the --log-bin-index's path\n       is a directory.*/\n    if (opt_binlog_index_name &&\n        opt_binlog_index_name[strlen(opt_binlog_index_name) - 1] ==\n            FN_LIBCHAR) {\n      LogErr(ERROR_LEVEL, ER_NEED_FILE_INSTEAD_OF_DIR, \"--log-bin-index\",\n             opt_binlog_index_name);\n      unireg_abort(MYSQLD_ABORT_EXIT);\n    }\n\n    char buf[FN_REFLEN];\n    const char *ln;\n    if (log_bin_supplied) {\n      /*\n        Binary log basename defaults to \"`hostname`-bin\" name prefix\n        if --log-bin is used without argument.\n      */\n      ln = mysql_bin_log.generate_name(opt_bin_logname, \"-bin\", buf);\n    } else {\n      /*\n        Binary log basename defaults to \"binlog\" name prefix\n        if --log-bin is not used.\n      */\n      ln = mysql_bin_log.generate_name(opt_bin_logname, \"\", buf);\n    }\n\n    if (!opt_bin_logname && !opt_binlog_index_name && log_bin_supplied) {\n      /*\n        User didn't give us info to name the binlog index file.\n        Picking `hostname`-bin.index like did in 4.x, causes replication to\n        fail if the hostname is changed later. So, we would like to instead\n        require a name. But as we don't want to break many existing setups, we\n        only give warning, not error.\n      */\n      LogErr(INFORMATION_LEVEL, ER_LOG_BIN_BETTER_WITH_NAME, ln);\n    }\n    if (ln == buf) {\n      my_free(opt_bin_logname);\n      opt_bin_logname = my_strdup(key_memory_opt_bin_logname, buf, MYF(0));\n    }\n\n    /*\n      Skip opening the index file if we start with --help. This is necessary\n      to avoid creating the file in an otherwise empty datadir, which will\n      cause a succeeding 'mysqld --initialize' to fail.\n    */\n    if (!is_help_or_validate_option() &&\n        mysql_bin_log.open_index_file(opt_binlog_index_name, ln, true)) {\n      unireg_abort(MYSQLD_ABORT_EXIT);\n    }\n  }\n\n  if (opt_bin_log) {\n    /*\n      opt_bin_logname[0] needs to be checked to make sure opt binlog name is\n      not an empty string, incase it is an empty string default file\n      extension will be passed\n     */\n    if (log_bin_supplied) {\n      log_bin_basename = rpl_make_log_name(\n          key_memory_MYSQL_BIN_LOG_basename, opt_bin_logname,\n          default_logfile_name,\n          (opt_bin_logname && opt_bin_logname[0]) ? \"\" : \"-bin\");\n    } else {\n      log_bin_basename =\n          rpl_make_log_name(key_memory_MYSQL_BIN_LOG_basename, opt_bin_logname,\n                            default_binlogfile_name, \"\");\n    }\n\n    log_bin_index =\n        rpl_make_log_name(key_memory_MYSQL_BIN_LOG_index, opt_binlog_index_name,\n                          log_bin_basename, \".index\");\n\n    if ((!opt_binlog_index_name || !opt_binlog_index_name[0]) &&\n        log_bin_index) {\n      strmake(default_binlog_index_name,\n              log_bin_index + dirname_length(log_bin_index),\n              FN_REFLEN + index_ext_length - 1);\n      opt_binlog_index_name = default_binlog_index_name;\n    }\n\n    if (log_bin_basename == nullptr || log_bin_index == nullptr) {\n      LogErr(ERROR_LEVEL, ER_RPL_CANT_MAKE_PATHS, (int)FN_REFLEN, (int)FN_LEN);\n      unireg_abort(MYSQLD_ABORT_EXIT);\n    }\n  }\n\n  DBUG_PRINT(\"debug\",\n             (\"opt_bin_logname: %s, opt_relay_logname: %s, pidfile_name: %s\",\n              opt_bin_logname, opt_relay_logname, pidfile_name));\n\n  /*\n    opt_relay_logname[0] needs to be checked to make sure opt relaylog name is\n    not an empty string, incase it is an empty string default file\n    extension will be passed\n   */\n  relay_log_basename = rpl_make_log_name(\n      key_memory_MYSQL_RELAY_LOG_basename, opt_relay_logname,\n      default_logfile_name,\n      (opt_relay_logname && opt_relay_logname[0]) ? \"\" : relay_ext);\n\n  if (!opt_relay_logname || !opt_relay_logname[0]) {\n    if (relay_log_basename) {\n      strmake(default_relaylogfile_name,\n              relay_log_basename + dirname_length(relay_log_basename),\n              FN_REFLEN + relay_ext_length - 1);\n      opt_relay_logname = default_relaylogfile_name;\n    }\n  } else\n    opt_relay_logname_supplied = true;\n\n  if (relay_log_basename != nullptr)\n    relay_log_index = rpl_make_log_name(key_memory_MYSQL_RELAY_LOG_index,\n                                        opt_relaylog_index_name,\n                                        relay_log_basename, \".index\");\n\n  if (!opt_relaylog_index_name || !opt_relaylog_index_name[0]) {\n    if (relay_log_index) {\n      strmake(default_relaylog_index_name,\n              relay_log_index + dirname_length(relay_log_index),\n              FN_REFLEN + relay_ext_length + index_ext_length - 1);\n      opt_relaylog_index_name = default_relaylog_index_name;\n    }\n  } else\n    opt_relaylog_index_name_supplied = true;\n\n  if (relay_log_basename == nullptr || relay_log_index == nullptr) {\n    LogErr(ERROR_LEVEL, ER_RPL_CANT_MAKE_PATHS, (int)FN_REFLEN, (int)FN_LEN);\n    unireg_abort(MYSQLD_ABORT_EXIT);\n  }\n\n  if (log_bin_basename != nullptr &&\n      !strcmp(log_bin_basename, relay_log_basename)) {\n    const int bin_ext_length = 4;\n    char default_binlogfile_name_from_hostname[FN_REFLEN + bin_ext_length];\n    /* Generate default bin log file name. */\n    strmake(default_binlogfile_name_from_hostname, default_logfile_name,\n            FN_REFLEN - 1);\n    strcat(default_binlogfile_name_from_hostname, \"-bin\");\n\n    if (!default_relaylogfile_name[0]) {\n      /* Generate default relay log file name. */\n      strmake(default_relaylogfile_name, default_logfile_name, FN_REFLEN - 1);\n      strcat(default_relaylogfile_name, relay_ext);\n    }\n    /*\n      Reports an error and aborts, if the same base name is specified\n      for both binary and relay logs.\n    */\n    LogErr(ERROR_LEVEL, ER_RPL_CANT_HAVE_SAME_BASENAME, log_bin_basename,\n           \"--log-bin\", default_binlogfile_name,\n           default_binlogfile_name_from_hostname, \"--relay-log\",\n           default_relaylogfile_name);\n    unireg_abort(MYSQLD_ABORT_EXIT);\n  }\n\n  if (global_system_variables.binlog_row_value_options != 0) {\n    const char *msg = nullptr;\n    longlong err = ER_BINLOG_ROW_VALUE_OPTION_IGNORED;\n    if (!opt_bin_log)\n      msg = \"the binary log is disabled\";\n    else if (global_system_variables.binlog_format == BINLOG_FORMAT_STMT)\n      msg = \"binlog_format=STATEMENT\";\n    else if (log_bin_use_v1_row_events) {\n      msg = \"binlog_row_value_options=PARTIAL_JSON\";\n      err = ER_BINLOG_USE_V1_ROW_EVENTS_IGNORED;\n    } else if (global_system_variables.binlog_row_image ==\n               BINLOG_ROW_IMAGE_FULL) {\n      msg = \"binlog_row_image=FULL\";\n      err = ER_BINLOG_ROW_VALUE_OPTION_USED_ONLY_FOR_AFTER_IMAGES;\n    }\n    if (msg) {\n      switch (err) {\n        case ER_BINLOG_ROW_VALUE_OPTION_IGNORED:\n        case ER_BINLOG_ROW_VALUE_OPTION_USED_ONLY_FOR_AFTER_IMAGES:\n          LogErr(WARNING_LEVEL, err, msg, \"PARTIAL_JSON\");\n          break;\n        case ER_BINLOG_USE_V1_ROW_EVENTS_IGNORED:\n          LogErr(WARNING_LEVEL, err, msg);\n          break;\n        default:\n          DBUG_ASSERT(0); /* purecov: deadcode */\n      }\n    }\n  }\n\n  /* call ha_init_key_cache() on all key caches to init them */\n  process_key_caches(&ha_init_key_cache);\n\n  /* Allow storage engine to give real error messages */\n  if (ha_init_errors()) return 1;\n\n  if (gtid_server_init()) {\n    LogErr(ERROR_LEVEL, ER_CANT_INITIALIZE_GTID);\n    unireg_abort(MYSQLD_ABORT_EXIT);\n  }\n\n  if (opt_log_slave_updates && replicate_same_server_id) {\n    enum_gtid_mode gtid_mode = get_gtid_mode(GTID_MODE_LOCK_NONE);\n    if (opt_bin_log && gtid_mode != GTID_MODE_ON) {\n      LogErr(ERROR_LEVEL, ER_RPL_INFINITY_DENIED);\n      unireg_abort(MYSQLD_ABORT_EXIT);\n    } else\n      LogErr(WARNING_LEVEL, ER_RPL_INFINITY_IGNORED);\n  }\n\n  {\n    /*\n      We have to call a function in log_resource.cc, or its references\n      won't be visible to plugins.\n    */\n#ifndef DBUG_OFF\n    int dummy =\n#endif\n        Log_resource::dummy_function_to_ensure_we_are_linked_into_the_server();\n    DBUG_ASSERT(dummy == 1);\n  }\n\n  /*\n    We need to initialize the UDF globals early before reading the proc table\n    and before the server component initialization to allow other components\n    to register their UDFs at init time and de-register them at deinit time.\n  */\n  udf_init_globals();\n\n  /*\n    Set tc_log to point to TC_LOG_DUMMY early in order to allow plugin_init()\n    to commit attachable transaction after reading from mysql.plugin table.\n    If necessary tc_log will be adjusted to point to correct TC_LOG instance\n    later.\n  */\n  tc_log = &tc_log_dummy;\n\n  /* This limits ability to configure SSL library through config options */\n  init_ssl();\n\n  /*Load early plugins */\n  if (plugin_register_early_plugins(&remaining_argc, remaining_argv,\n                                    (is_help_or_validate_option())\n                                        ? PLUGIN_INIT_SKIP_INITIALIZATION\n                                        : 0)) {\n    LogErr(ERROR_LEVEL, ER_CANT_INITIALIZE_EARLY_PLUGINS);\n    unireg_abort(1);\n  }\n\n  /* Load builtin plugins, initialize MyISAM, CSV and InnoDB */\n  if (plugin_register_builtin_and_init_core_se(&remaining_argc,\n                                               remaining_argv)) {\n    if (!opt_validate_config)\n      LogErr(ERROR_LEVEL, ER_CANT_INITIALIZE_BUILTIN_PLUGINS);\n    unireg_abort(1);\n  }\n\n  /*\n    Needs to be done before dd::init() which runs DDL commands (for real)\n    during instance initialization.\n  */\n  init_sql_command_flags();\n\n  /*\n    plugin_register_dynamic_and_init_all() needs DD initialized.\n    Initialize DD to create data directory using current server.\n  */\n  if (opt_initialize) {\n    if (!is_help_or_validate_option()) {\n      if (dd::init(dd::enum_dd_init_type::DD_INITIALIZE)) {\n        LogErr(ERROR_LEVEL, ER_DD_INIT_FAILED);\n        unireg_abort(1);\n      }\n\n      if (dd::init(dd::enum_dd_init_type::DD_INITIALIZE_SYSTEM_VIEWS)) {\n        LogErr(ERROR_LEVEL, ER_SYSTEM_VIEW_INIT_FAILED);\n        unireg_abort(1);\n      }\n    }\n  } else {\n    /*\n      Initialize DD in case of upgrade and normal normal server restart.\n      It is detected if we are starting on old data directory or current\n      data directory. If it is old data directory, DD tables are created.\n      If server is starting on data directory with DD tables, DD is initialized.\n    */\n    if (!is_help_or_validate_option() &&\n        dd::init(dd::enum_dd_init_type::DD_RESTART_OR_UPGRADE)) {\n      LogErr(ERROR_LEVEL, ER_DD_INIT_FAILED);\n\n      /* If clone recovery fails, we rollback the files to previous\n      dataset and attempt to restart server. */\n      int exit_code =\n          clone_recovery_error ? MYSQLD_RESTART_EXIT : MYSQLD_ABORT_EXIT;\n      unireg_abort(exit_code);\n    }\n  }\n\n  /*\n   During plugin initialization, a plugin may expect (depending on what the\n   plugin actually does) to find a functional server, including:\n   - mysql system tables\n   - information schema tables\n   - performance schema tables\n   - data dictionary\n   - components / services, including the registry service\n   During the server installation, all these parts are not available yet, as\n   they are created during the installation process with mysqld --initialize.\n\n   As a result, plugins are not loaded during mysqld --initialize, so that\n   the server install can proceed and complete before any plugin is loaded\n   through any config file or pre-programmed command line.\n  */\n  int flags = 0;\n\n  if (opt_noacl) flags |= PLUGIN_INIT_SKIP_PLUGIN_TABLE;\n  if (is_help_or_validate_option())\n    flags |= PLUGIN_INIT_SKIP_INITIALIZATION | PLUGIN_INIT_SKIP_PLUGIN_TABLE;\n  if (opt_initialize) flags |= PLUGIN_INIT_SKIP_DYNAMIC_LOADING;\n\n  /*\n    In the case of upgrade, we need to delay initialization of plugins that\n    depend on e.g. mysql tables that will be changed during upgrade.\n  */\n  if (!is_help_or_validate_option() && !opt_initialize &&\n      !dd::upgrade::no_server_upgrade_required() &&\n      opt_upgrade_mode != UPGRADE_MINIMAL)\n    flags |= PLUGIN_INIT_DELAY_UNTIL_AFTER_UPGRADE;\n\n  if (plugin_register_dynamic_and_init_all(&remaining_argc, remaining_argv,\n                                           flags)) {\n    // Delete all DD tables in case of error in initializing plugins.\n    if (dd::upgrade_57::in_progress())\n      (void)dd::init(dd::enum_dd_init_type::DD_DELETE);\n\n    if (!opt_validate_config)\n      LogErr(ERROR_LEVEL, ER_CANT_INITIALIZE_DYNAMIC_PLUGINS);\n    unireg_abort(MYSQLD_ABORT_EXIT);\n  }\n  dynamic_plugins_are_initialized =\n      true; /* Don't separate from init function */\n\n  LEX_CSTRING plugin_name = {STRING_WITH_LEN(\"thread_pool\")};\n  if (Connection_handler_manager::thread_handling !=\n          Connection_handler_manager::SCHEDULER_ONE_THREAD_PER_CONNECTION ||\n      plugin_is_ready(plugin_name, MYSQL_DAEMON_PLUGIN)) {\n    auto res_grp_mgr = resourcegroups::Resource_group_mgr::instance();\n    res_grp_mgr->disable_resource_group();\n    res_grp_mgr->set_unsupport_reason(\"Thread pool plugin enabled\");\n  }\n\n#ifdef WITH_PERFSCHEMA_STORAGE_ENGINE\n  /*\n    A value of the variable dd_upgrade_flag is reset after\n    dd::init(dd::enum_dd_init_type::DD_POPULATE_UPGRADE) returned.\n    So make its copy to call init_pfs_tables() with right argument value later.\n  */\n  bool dd_upgrade_was_initiated = dd::upgrade_57::in_progress();\n#endif\n\n  if (!is_help_or_validate_option() && dd::upgrade_57::in_progress()) {\n    // Populate DD tables with meta data from 5.7\n    if (dd::init(dd::enum_dd_init_type::DD_POPULATE_UPGRADE)) {\n      LogErr(ERROR_LEVEL, ER_DD_POPULATING_TABLES_FAILED);\n      unireg_abort(1);\n    }\n    // Run after_dd_upgrade hook\n    if (RUN_HOOK(server_state, after_dd_upgrade_from_57, (nullptr)))\n      unireg_abort(MYSQLD_ABORT_EXIT);\n  }\n\n  /*\n    Store server and plugin IS tables metadata into new DD.\n    This is done after all the plugins are registered.\n  */\n  if (!is_help_or_validate_option() && !opt_initialize &&\n      !dd::upgrade_57::in_progress() &&\n      dd::init(dd::enum_dd_init_type::DD_UPDATE_I_S_METADATA)) {\n    LogErr(ERROR_LEVEL, ER_DD_UPDATING_PLUGIN_MD_FAILED);\n    unireg_abort(MYSQLD_ABORT_EXIT);\n  }\n\n#ifdef WITH_PERFSCHEMA_STORAGE_ENGINE\n  if (!is_help_or_validate_option()) {\n    /*\n      Initialize the cost model, but delete it after the pfs is initialized.\n      Cost model is needed while dropping and creating pfs tables to\n      update metadata of referencing views (if there are any).\n    */\n    init_optimizer_cost_module(true);\n\n    bool st;\n    if (opt_initialize || dd_upgrade_was_initiated)\n      st = dd::performance_schema::init_pfs_tables(\n          dd::enum_dd_init_type::DD_INITIALIZE);\n    else\n      st = dd::performance_schema::init_pfs_tables(\n          dd::enum_dd_init_type::DD_RESTART_OR_UPGRADE);\n\n    /* Now that the pfs is initialized, delete the cost model. */\n    delete_optimizer_cost_module();\n\n    if (st) {\n      LogErr(ERROR_LEVEL, ER_PERFSCHEMA_TABLES_INIT_FAILED);\n      unireg_abort(1);\n    }\n  }\n#endif\n\n  bool recreate_non_dd_based_system_view = dd::upgrade::I_S_upgrade_required();\n  if (!is_help_or_validate_option() && !opt_initialize &&\n      !dd::upgrade::no_server_upgrade_required()) {\n    if (opt_upgrade_mode == UPGRADE_MINIMAL)\n      LogErr(WARNING_LEVEL, ER_SERVER_UPGRADE_SKIP);\n    else {\n      init_optimizer_cost_module(true);\n      if (bootstrap::run_bootstrap_thread(nullptr, nullptr,\n                                          &dd::upgrade::upgrade_system_schemas,\n                                          SYSTEM_THREAD_SERVER_UPGRADE)) {\n        LogErr(ERROR_LEVEL, ER_SERVER_UPGRADE_FAILED);\n        unireg_abort(MYSQLD_ABORT_EXIT);\n      }\n      delete_optimizer_cost_module();\n      recreate_non_dd_based_system_view = true;\n\n      /*\n        When upgrade is finished, we need to initialize the plugins that\n        had their initialization delayed due to dependencies on the\n        environment.\n\n        TODO: Provide a better long term solution by re-ordering startup\n              sequence and rewriting the way we create and upgrade server\n              resources needed by plugins.\n      */\n      if (dd::upgrade::plugin_initialize_delayed_after_upgrade()) {\n        unireg_abort(MYSQLD_ABORT_EXIT);\n      }\n    }\n  }\n\n  /*\n    Re-create non DD based system views after a) if we upgraded system\n    schemas b) I_S system view version is changed and server system views\n    were recreated. c) If the database was upgraded. We do not update this\n    in upgrade-minimal mode.\n   */\n  if (!is_help_or_validate_option() && !opt_initialize &&\n      opt_upgrade_mode != UPGRADE_MINIMAL &&\n      recreate_non_dd_based_system_view) {\n    if (dd::init(\n            dd::enum_dd_init_type::DD_INITIALIZE_NON_DD_BASED_SYSTEM_VIEWS)) {\n      LogErr(ERROR_LEVEL, ER_SYSTEM_VIEW_INIT_FAILED);\n      unireg_abort(MYSQLD_ABORT_EXIT);\n    }\n  }\n\n  auto res_grp_mgr = resourcegroups::Resource_group_mgr::instance();\n  // Initialize the Resource group subsystem.\n  if (!is_help_or_validate_option() && !opt_initialize) {\n    if (res_grp_mgr->post_init()) {\n      LogErr(ERROR_LEVEL, ER_RESOURCE_GROUP_POST_INIT_FAILED);\n      unireg_abort(MYSQLD_ABORT_EXIT);\n    }\n  }\n\n  Session_tracker session_track_system_variables_check;\n  LEX_STRING var_list;\n  char *tmp_str;\n  size_t len = strlen(global_system_variables.track_sysvars_ptr);\n  tmp_str = (char *)my_malloc(PSI_NOT_INSTRUMENTED, len * sizeof(char) + 2,\n                              MYF(MY_WME));\n  strcpy(tmp_str, global_system_variables.track_sysvars_ptr);\n  var_list.length = len;\n  var_list.str = tmp_str;\n  if (session_track_system_variables_check.server_boot_verify(\n          system_charset_info, var_list)) {\n    LogErr(ERROR_LEVEL, ER_TRACK_VARIABLES_BOGUS);\n    if (tmp_str) my_free(tmp_str);\n    unireg_abort(MYSQLD_ABORT_EXIT);\n  }\n  if (tmp_str) my_free(tmp_str);\n\n  // Validate the configuration if --validate-config was specified.\n  if (opt_validate_config && (remaining_argc > 1)) {\n    bool saved_getopt_skip_unknown = my_getopt_skip_unknown;\n    struct my_option no_opts[] = {{nullptr, 0, nullptr, nullptr, nullptr,\n                                   nullptr, GET_NO_ARG, NO_ARG, 0, 0, 0,\n                                   nullptr, 0, nullptr}};\n\n    my_getopt_skip_unknown = false;\n\n    if (handle_options(&remaining_argc, &remaining_argv, no_opts,\n                       mysqld_get_one_option))\n      unireg_abort(MYSQLD_ABORT_EXIT);\n    my_getopt_skip_unknown = saved_getopt_skip_unknown;\n  }\n\n  if (is_help_or_validate_option()) unireg_abort(MYSQLD_SUCCESS_EXIT);\n\n  /* if the errmsg.sys is not loaded, terminate to maintain behaviour */\n  if (!my_default_lc_messages->errmsgs->is_loaded()) {\n    LogErr(ERROR_LEVEL, ER_CANT_READ_ERRMSGS);\n    unireg_abort(MYSQLD_ABORT_EXIT);\n  }\n\n  /* We have to initialize the storage engines before CSV logging */\n  if (ha_init()) {\n    LogErr(ERROR_LEVEL, ER_CANT_INIT_DBS);\n    unireg_abort(MYSQLD_ABORT_EXIT);\n  }\n\n  /* Initialize ndbinfo tables in DD */\n  if (dd::ndbinfo::init_schema_and_tables(opt_upgrade_mode)) {\n    LogErr(ERROR_LEVEL, ER_NDBINFO_UPGRADING_SCHEMA_FAIL);\n    unireg_abort(1);\n  }\n\n  if (opt_initialize) log_output_options = LOG_FILE;\n\n  /*\n    Issue a warning if there were specified additional options to the\n    log-output along with NONE. Probably this wasn't what user wanted.\n  */\n  if ((log_output_options & LOG_NONE) && (log_output_options & ~LOG_NONE))\n    LogErr(WARNING_LEVEL, ER_LOG_OUTPUT_CONTRADICTORY);\n\n  if (log_output_options & LOG_TABLE) {\n    /* Fall back to log files if the csv engine is not loaded. */\n    LEX_CSTRING csv_name = {STRING_WITH_LEN(\"csv\")};\n    if (!plugin_is_ready(csv_name, MYSQL_STORAGE_ENGINE_PLUGIN)) {\n      LogErr(ERROR_LEVEL, ER_NO_CSV_NO_LOG_TABLES);\n      log_output_options = (log_output_options & ~LOG_TABLE) | LOG_FILE;\n    }\n  }\n\n  query_logger.set_handlers(log_output_options);\n\n  // Open slow log file if enabled.\n  query_logger.set_log_file(QUERY_LOG_SLOW);\n  if (opt_slow_log && query_logger.reopen_log_file(QUERY_LOG_SLOW))\n    opt_slow_log = false;\n\n  // Open general log file if enabled.\n  query_logger.set_log_file(QUERY_LOG_GENERAL);\n  if (opt_general_log && query_logger.reopen_log_file(QUERY_LOG_GENERAL))\n    opt_general_log = false;\n\n  /*\n    Set the default storage engines\n  */\n  if (initialize_storage_engine(default_storage_engine, \"\",\n                                &global_system_variables.table_plugin))\n    unireg_abort(MYSQLD_ABORT_EXIT);\n  if (initialize_storage_engine(default_tmp_storage_engine, \" temp\",\n                                &global_system_variables.temp_table_plugin))\n    unireg_abort(MYSQLD_ABORT_EXIT);\n\n  if (!opt_initialize && !opt_noacl) {\n    std::string disabled_se_str(opt_disabled_storage_engines);\n    ha_set_normalized_disabled_se_str(disabled_se_str);\n\n    // Log warning if default_storage_engine is a disabled storage engine.\n    handlerton *default_se_handle =\n        plugin_data<handlerton *>(global_system_variables.table_plugin);\n    if (ha_is_storage_engine_disabled(default_se_handle))\n      LogErr(WARNING_LEVEL, ER_DISABLED_STORAGE_ENGINE_AS_DEFAULT,\n             \"default_storage_engine\", default_storage_engine);\n\n    // Log warning if default_tmp_storage_engine is a disabled storage engine.\n    handlerton *default_tmp_se_handle =\n        plugin_data<handlerton *>(global_system_variables.temp_table_plugin);\n    if (ha_is_storage_engine_disabled(default_tmp_se_handle))\n      LogErr(WARNING_LEVEL, ER_DISABLED_STORAGE_ENGINE_AS_DEFAULT,\n             \"default_tmp_storage_engine\", default_tmp_storage_engine);\n  }\n\n  /*\n    Validate any enforced storage engine\n  */\n  if (enforce_storage_engine && !opt_initialize && !opt_noacl) {\n    const LEX_CSTRING name{enforce_storage_engine,\n                           strlen(enforce_storage_engine)};\n    plugin_ref plugin;\n    if ((plugin = ha_resolve_by_name(nullptr, &name, false))) {\n      handlerton *hton = plugin_data<handlerton *>(plugin);\n      const LEX_CSTRING defname{default_storage_engine,\n                                strlen(default_storage_engine)};\n      plugin_ref defplugin;\n      handlerton *defhton;\n      if ((defplugin = ha_resolve_by_name(nullptr, &defname, false))) {\n        defhton = plugin_data<handlerton *>(defplugin);\n        if (defhton != hton) {\n          sql_print_warning(\n              \"Default storage engine (%s)\"\n              \" is not the same as enforced storage engine (%s)\",\n              default_storage_engine, enforce_storage_engine);\n        }\n      }\n      if (ha_is_storage_engine_disabled(hton)) {\n        sql_print_error(\n            \"enforced storage engine %s is among disabled storage \"\n            \"engines\",\n            enforce_storage_engine);\n        unireg_abort(MYSQLD_ABORT_EXIT);\n      }\n      plugin_unlock(nullptr, defplugin);\n      plugin_unlock(nullptr, plugin);\n    } else {\n      sql_print_error(\"Unknown/unsupported storage engine: %s\",\n                      enforce_storage_engine);\n      unireg_abort(MYSQLD_ABORT_EXIT);\n    }\n  }\n\n  if (total_ha_2pc > 1 || (1 == total_ha_2pc && opt_bin_log)) {\n    if (opt_bin_log)\n      tc_log = &mysql_bin_log;\n    else\n      tc_log = &tc_log_mmap;\n  }\n\n  if (Recovered_xa_transactions::init()) {\n    LogErr(ERROR_LEVEL, ER_OOM);\n    unireg_abort(MYSQLD_ABORT_EXIT);\n  }\n\n  if (tc_log->open(opt_bin_log ? opt_bin_logname : opt_tc_log_file)) {\n    LogErr(ERROR_LEVEL, ER_CANT_INIT_TC_LOG);\n    unireg_abort(MYSQLD_ABORT_EXIT);\n  }\n  (void)RUN_HOOK(server_state, before_recovery, (nullptr));\n  if (ha_recover(nullptr)) {\n    unireg_abort(MYSQLD_ABORT_EXIT);\n  }\n\n  if (dd::reset_tables_and_tablespaces()) {\n    unireg_abort(MYSQLD_ABORT_EXIT);\n  }\n  ha_post_recover();\n\n  /*\n    Add prepared XA transactions into the cache of XA transactions and acquire\n    mdl lock for every table involved in any of these prepared XA transactions.\n    This step moved away from the function ha_recover() in order to avoid\n    possible suspending on acquiring EXLUSIVE mdl lock on tables inside the\n    function dd::reset_tables_and_tablespaces() when table cache being reset.\n  */\n  if (Recovered_xa_transactions::instance()\n          .recover_prepared_xa_transactions()) {\n    unireg_abort(MYSQLD_ABORT_EXIT);\n  }\n\n  /// @todo: this looks suspicious, revisit this /sven\n  enum_gtid_mode gtid_mode = get_gtid_mode(GTID_MODE_LOCK_NONE);\n\n  if (gtid_mode == GTID_MODE_ON &&\n      _gtid_consistency_mode != GTID_CONSISTENCY_MODE_ON) {\n    LogErr(ERROR_LEVEL, ER_RPL_GTID_MODE_REQUIRES_ENFORCE_GTID_CONSISTENCY_ON);\n    unireg_abort(MYSQLD_ABORT_EXIT);\n  }\n\n  /*\n    Each server should have one UUID. We will create it automatically, if it\n    does not exist. It should be initialized before opening binlog file. Because\n    server's uuid will be stored into the new binlog file.\n  */\n  if (init_server_auto_options()) {\n    LogErr(ERROR_LEVEL, ER_CANT_CREATE_UUID);\n    unireg_abort(MYSQLD_ABORT_EXIT);\n  }\n\n  if (rpl_encryption.initialize()) {\n    LogErr(ERROR_LEVEL, ER_SERVER_RPL_ENCRYPTION_UNABLE_TO_INITIALIZE);\n    unireg_abort(MYSQLD_ABORT_EXIT);\n  }\n\n  if (rpl_encryption.is_enabled() && !opt_bin_log) {\n    sql_print_information(\n        \"binlog and relay log encryption enabled without binary logging being \"\n        \"enabled. \"\n        \"If relay logs are in use, they will be encrypted.\");\n  }\n\n  if (opt_bin_log) {\n    /*\n      Configures what object is used by the current log to store processed\n      gtid(s). This is necessary in the MYSQL_BIN_LOG::MYSQL_BIN_LOG to\n      corretly compute the set of previous gtids.\n    */\n    DBUG_ASSERT(!mysql_bin_log.is_relay_log);\n    mysql_mutex_t *log_lock = mysql_bin_log.get_log_lock();\n    mysql_mutex_lock(log_lock);\n\n    if (mysql_bin_log.open_binlog(opt_bin_logname, nullptr, max_binlog_size,\n                                  false, true /*need_lock_index=true*/,\n                                  true /*need_sid_lock=true*/, nullptr)) {\n      mysql_mutex_unlock(log_lock);\n      unireg_abort(MYSQLD_ABORT_EXIT);\n    }\n    mysql_mutex_unlock(log_lock);\n  }\n\n  /*\n    When we pass non-zero values for both expire_logs_days and\n    binlog_expire_logs_seconds at the server start-up, the value of\n    expire_logs_days will be ignored and only binlog_expire_logs_seconds\n    will be used.\n  */\n  if (binlog_expire_logs_seconds_supplied && expire_logs_days_supplied) {\n    if (binlog_expire_logs_seconds != 0 && expire_logs_days != 0) {\n      LogErr(WARNING_LEVEL, ER_EXPIRE_LOGS_DAYS_IGNORED);\n      expire_logs_days = 0;\n    }\n  } else if (expire_logs_days_supplied)\n    binlog_expire_logs_seconds = 0;\n  DBUG_ASSERT(expire_logs_days == 0 || binlog_expire_logs_seconds == 0);\n\n  if (opt_bin_log) {\n    if (expire_logs_days > 0 || binlog_expire_logs_seconds > 0) {\n      time_t purge_time = my_time(0) - binlog_expire_logs_seconds -\n                          expire_logs_days * 24 * 60 * 60;\n      DBUG_EXECUTE_IF(\"expire_logs_always_at_start\",\n                      { purge_time = my_time(0); });\n      mysql_bin_log.purge_logs_before_date(purge_time, true);\n    }\n    if (binlog_space_limit) mysql_bin_log.purge_logs_by_size(true);\n  } else {\n    if (binlog_expire_logs_seconds_supplied)\n      LogErr(WARNING_LEVEL, ER_NEED_LOG_BIN, \"--binlog-expire-logs-seconds\");\n    if (expire_logs_days_supplied)\n      LogErr(WARNING_LEVEL, ER_NEED_LOG_BIN, \"--expire_logs_days\");\n    if (binlog_space_limit)\n      LogErr(WARNING_LEVEL, ER_NEED_LOG_BIN, \"--binlog-space-limit\");\n  }\n\n  if (opt_myisam_log) (void)mi_log(1);\n\n#if defined(HAVE_MLOCKALL) && defined(MCL_CURRENT)\n  if (locked_in_memory && !getuid()) {\n    if (setreuid((uid_t)-1, 0) == -1) {  // this should never happen\n      LogErr(ERROR_LEVEL, ER_FAIL_SETREUID, strerror(errno));\n      unireg_abort(MYSQLD_ABORT_EXIT);\n    }\n    if (mlockall(MCL_CURRENT)) {\n      LogErr(WARNING_LEVEL, ER_FAILED_TO_LOCK_MEM,\n             errno); /* purecov: inspected */\n      locked_in_memory = false;\n    }\n#ifndef _WIN32\n    if (!user_info.IsVoid()) set_user(mysqld_user, user_info);\n#endif\n  } else\n#endif\n    locked_in_memory = false;\n\n  /* Initialize the optimizer cost module */\n  init_optimizer_cost_module(true);\n  ft_init_stopwords();\n\n  init_max_user_conn();\n\n  init_global_user_stats();\n  init_global_client_stats();\n  init_global_thread_stats();\n  return 0;\n}\n\n#ifdef _WIN32\n\nextern \"C\" void *handle_shutdown_and_restart(void *arg) {\n  MSG msg;\n  HANDLE event_handles[2];\n  event_handles[0] = hEventShutdown;\n  event_handles[1] = hEventRestart;\n\n  my_thread_init();\n  /* This call should create the message queue for this thread. */\n  PeekMessage(&msg, NULL, 1, 65534, PM_NOREMOVE);\n  DWORD ret_code = WaitForMultipleObjects(\n      2, static_cast<HANDLE *>(event_handles), FALSE, INFINITE);\n\n  if (ret_code == WAIT_OBJECT_0 || ret_code == WAIT_OBJECT_0 + 1) {\n    if (ret_code == WAIT_OBJECT_0)\n      LogErr(SYSTEM_LEVEL, ER_NORMAL_SERVER_SHUTDOWN, my_progname);\n    else\n      signal_hand_thr_exit_code = MYSQLD_RESTART_EXIT;\n\n    set_connection_events_loop_aborted(true);\n    close_connections();\n    my_thread_end();\n    my_thread_exit(0);\n  }\n  return 0;\n}\n\nstatic void create_shutdown_and_restart_thread() {\n  DBUG_TRACE;\n\n  const char *errmsg;\n  my_thread_attr_t thr_attr;\n  SECURITY_ATTRIBUTES *shutdown_sec_attr;\n\n  my_security_attr_create(&shutdown_sec_attr, &errmsg, GENERIC_ALL,\n                          SYNCHRONIZE | EVENT_MODIFY_STATE);\n\n  if (!opt_no_monitor) {\n    snprintf(shutdown_event_name, sizeof(shutdown_event_name),\n             \"mysqld%s_shutdown\", get_monitor_pid());\n  }\n\n  hEventShutdown =\n      CreateEvent(shutdown_sec_attr, FALSE, FALSE, shutdown_event_name);\n  hEventRestart = CreateEvent(0, FALSE, FALSE, restart_event_name);\n\n  my_thread_attr_init(&thr_attr);\n\n  if (my_thread_create(&shutdown_restart_thr_handle, &thr_attr,\n                       handle_shutdown_and_restart, 0))\n    LogErr(WARNING_LEVEL, ER_CANT_CREATE_SHUTDOWN_THREAD, errno);\n\n  my_security_attr_free(shutdown_sec_attr);\n  my_thread_attr_destroy(&thr_attr);\n}\n#endif /* _WIN32 */\n\n#ifndef DBUG_OFF\n/*\n  Debugging helper function to keep the locale database\n  (see sql_locale.cc) and max_month_name_length and\n  max_day_name_length variable values in consistent state.\n*/\nstatic void test_lc_time_sz() {\n  DBUG_TRACE;\n  for (MY_LOCALE **loc = my_locales; *loc; loc++) {\n    size_t max_month_len = 0;\n    size_t max_day_len = 0;\n    for (const char **month = (*loc)->month_names->type_names; *month;\n         month++) {\n      max_month_len = std::max(\n          max_month_len, my_numchars_mb(&my_charset_utf8_general_ci, *month,\n                                        *month + strlen(*month)));\n    }\n    for (const char **day = (*loc)->day_names->type_names; *day; day++) {\n      max_day_len =\n          std::max(max_day_len, my_numchars_mb(&my_charset_utf8_general_ci,\n                                               *day, *day + strlen(*day)));\n    }\n    if ((*loc)->max_month_name_length != max_month_len ||\n        (*loc)->max_day_name_length != max_day_len) {\n      DBUG_PRINT(\"Wrong max day name(or month name) length for locale:\",\n                 (\"%s\", (*loc)->name));\n      DBUG_ASSERT(0);\n    }\n  }\n}\n#endif  // DBUG_OFF\n\n/*\n  @brief : Set opt_super_readonly to user supplied value before\n           enabling communication channels to accept user connections\n*/\n\nstatic void set_super_read_only_post_init() {\n  opt_super_readonly = super_read_only;\n}\n\nstatic void calculate_mysql_home_from_my_progname() {\n  const std::string runtime_output_directory_addon{\n      \"/runtime_output_directory/\"};\n#if defined(_WIN32) || defined(APPLE_XCODE)\n  /* Allow Win32 users to move MySQL anywhere */\n  char prg_dev[LIBLEN];\n  my_path(prg_dev, my_progname, nullptr);\n\n  // On windows or Xcode the basedir will always be one level up from where\n  // the executable is located. E.g. <basedir>/bin/mysqld.exe in a\n  // package, or <basedir>/runtime_output_directory/<buildconfig>/mysqld.exe\n  // for a sandbox build.\n  strcat(prg_dev, \"/../\");  // Remove containing directory to get base dir\n  cleanup_dirname(mysql_home, prg_dev);\n\n  // New layout: <cmake_binary_dir>/runtime_output_directory/<buildconfig>/\n  char cmake_binary_dir[FN_REFLEN];\n  size_t dlen = 0;\n  dirname_part(cmake_binary_dir, mysql_home, &dlen);\n  if (dlen > runtime_output_directory_addon.length() &&\n      (!strcmp(\n           cmake_binary_dir + (dlen - runtime_output_directory_addon.length()),\n           runtime_output_directory_addon.c_str()) ||\n       !strcmp(\n           cmake_binary_dir + (dlen - runtime_output_directory_addon.length()),\n           \"\\\\runtime_output_directory\\\\\"))) {\n    mysql_home[strlen(mysql_home) - 1] = '\\0';  // remove trailing\n    dirname_part(cmake_binary_dir, mysql_home, &dlen);\n    strmake(mysql_home, cmake_binary_dir, sizeof(mysql_home) - 1);\n  }\n  // The sql_print_information below outputs nothing ??\n  // fprintf(stderr, \"mysql_home %s\\n\", mysql_home);\n  // fflush(stderr);\n#else\n  const char *tmpenv = getenv(\"MY_BASEDIR_VERSION\");\n  if (tmpenv != nullptr) {\n    strmake(mysql_home, tmpenv, sizeof(mysql_home) - 1);\n  } else {\n    char progdir[FN_REFLEN];\n    size_t dlen = 0;\n    dirname_part(progdir, my_progname, &dlen);\n    if (dlen > runtime_output_directory_addon.length() &&\n        !strcmp(progdir + (dlen - runtime_output_directory_addon.length()),\n                runtime_output_directory_addon.c_str())) {\n      char cmake_binary_dir[FN_REFLEN];\n      progdir[strlen(progdir) - 1] = '\\0';  // remove trailing \"/\"\n      dirname_part(cmake_binary_dir, progdir, &dlen);\n      strmake(mysql_home, cmake_binary_dir, sizeof(mysql_home) - 1);\n    } else {\n      strcat(progdir, \"/../\");\n      cleanup_dirname(mysql_home, progdir);\n    }\n  }\n#endif\n  mysql_home_ptr = mysql_home;\n}\n\n#ifdef _WIN32\nint win_main(int argc, char **argv)\n#else\nint mysqld_main(int argc, char **argv)\n#endif\n{\n  // Substitute the full path to the executable in argv[0]\n  substitute_progpath(argv);\n  sysd::notify_connect();\n  sysd::notify(\"STATUS=Server startup in progress\\n\");\n\n  /*\n    Perform basic thread library and malloc initialization,\n    to be able to read defaults files and parse options.\n  */\n  my_progname = argv[0];\n  calculate_mysql_home_from_my_progname();\n\n#ifndef _WIN32\n#ifdef WITH_PERFSCHEMA_STORAGE_ENGINE\n  pre_initialize_performance_schema();\n#endif /*WITH_PERFSCHEMA_STORAGE_ENGINE */\n  // For windows, my_init() is called from the win specific mysqld_main\n  if (my_init())  // init my_sys library & pthreads\n  {\n    LogErr(ERROR_LEVEL, ER_MYINIT_FAILED);\n    flush_error_log_messages();\n    return 1;\n  }\n#endif /* _WIN32 */\n\n  orig_argc = argc;\n  orig_argv = argv;\n  my_getopt_use_args_separator = true;\n  my_defaults_read_login_file = false;\n  if (load_defaults(MYSQL_CONFIG_NAME, load_default_groups, &argc, &argv,\n                    &argv_alloc)) {\n    flush_error_log_messages();\n    return 1;\n  }\n\n  /* Set data dir directory paths */\n  strmake(mysql_real_data_home, get_relative_path(MYSQL_DATADIR),\n          sizeof(mysql_real_data_home) - 1);\n\n  /*\n   Initialize variables cache for persisted variables, load persisted\n   config file and append read only persisted variables to command line\n   options if present.\n  */\n  if (persisted_variables_cache.init(&argc, &argv) ||\n      persisted_variables_cache.load_persist_file() ||\n      persisted_variables_cache.append_read_only_variables(&argc, &argv)) {\n    flush_error_log_messages();\n    return 1;\n  }\n  my_getopt_use_args_separator = false;\n  remaining_argc = argc;\n  remaining_argv = argv;\n\n  init_variable_default_paths();\n\n  /* Must be initialized early for comparison of options name */\n  system_charset_info = &my_charset_utf8_general_ci;\n\n  /* Write mysys error messages to the error log. */\n  local_message_hook = error_log_print;\n\n  int heo_error;\n\n#ifdef WITH_PERFSCHEMA_STORAGE_ENGINE\n  /*\n    Initialize the array of performance schema instrument configurations.\n  */\n  init_pfs_instrument_array();\n#endif /* WITH_PERFSCHEMA_STORAGE_ENGINE */\n\n  /* init_error_log() is required by error_log_printf() in\n     option_error_reporter() */\n  //  Init error log subsystem. This does not actually open the log yet.\n  if (init_error_log()) unireg_abort(MYSQLD_ABORT_EXIT);\n  heo_error = handle_early_options();\n\n  init_sql_statement_names();\n  sys_var_init();\n  ulong requested_open_files = 0;\n  if (!opt_validate_config) adjust_related_options(&requested_open_files);\n  // moved signal initialization here so that PFS thread inherited signal mask\n  my_init_signals();\n\n#ifdef WITH_PERFSCHEMA_STORAGE_ENGINE\n  if (heo_error == 0) {\n    if (!is_help_or_validate_option() && !opt_initialize) {\n      int pfs_rc;\n      /* Add sizing hints from the server sizing parameters. */\n      pfs_param.m_hints.m_table_definition_cache = table_def_size;\n      pfs_param.m_hints.m_table_open_cache = table_cache_size;\n      pfs_param.m_hints.m_max_connections = max_connections;\n      pfs_param.m_hints.m_open_files_limit = requested_open_files;\n      pfs_param.m_hints.m_max_prepared_stmt_count = max_prepared_stmt_count;\n\n      pfs_rc = initialize_performance_schema(\n          &pfs_param, &psi_thread_hook, &psi_mutex_hook, &psi_rwlock_hook,\n          &psi_cond_hook, &psi_file_hook, &psi_socket_hook, &psi_table_hook,\n          &psi_mdl_hook, &psi_idle_hook, &psi_stage_hook, &psi_statement_hook,\n          &psi_transaction_hook, &psi_memory_hook, &psi_error_hook,\n          &psi_data_lock_hook, &psi_system_hook);\n      if ((pfs_rc != 0) && pfs_param.m_enabled) {\n        pfs_param.m_enabled = false;\n        LogErr(WARNING_LEVEL, ER_PERFSCHEMA_INIT_FAILED);\n      }\n    }\n  }\n#endif /* WITH_PERFSCHEMA_STORAGE_ENGINE */\n\n#ifdef WITH_LOCK_ORDER\n  if (heo_error == 0) {\n    if (lo_param.m_enabled && !opt_help && !opt_initialize) {\n      int lo_rc;\n      lo_rc = LO_init(&lo_param, &psi_thread_hook, &psi_mutex_hook,\n                      &psi_rwlock_hook, &psi_cond_hook, &psi_file_hook,\n                      &psi_socket_hook, &psi_table_hook, &psi_mdl_hook,\n                      &psi_idle_hook, &psi_stage_hook, &psi_statement_hook,\n                      &psi_transaction_hook, &psi_memory_hook);\n      if (lo_rc != 0) {\n        LogErr(WARNING_LEVEL, ER_LOCK_ORDER_INIT_FAILED);\n      }\n    }\n  }\n#endif /* WITH_LOCK_ORDER */\n\n  /*\n    Other provider of the instrumentation interface should\n    initialize PSI_hook here:\n    - HAVE_PSI_INTERFACE is for the instrumentation interface\n    - WITH_PERFSCHEMA_STORAGE_ENGINE is for one implementation\n      of the interface,\n    but there could be alternate implementations, which is why\n    these two defines are kept separate.\n  */\n\n#ifdef HAVE_PSI_INTERFACE\n  /*\n    Obtain the current performance schema instrumentation interface,\n    if available.\n  */\n\n  void *service;\n\n  if (psi_thread_hook != nullptr) {\n    service = psi_thread_hook->get_interface(PSI_CURRENT_THREAD_VERSION);\n    if (service != nullptr) {\n      set_psi_thread_service(service);\n    }\n  }\n\n  if (psi_mutex_hook != nullptr) {\n    service = psi_mutex_hook->get_interface(PSI_CURRENT_MUTEX_VERSION);\n    if (service != nullptr) {\n      set_psi_mutex_service(service);\n    }\n  }\n\n  if (psi_rwlock_hook != nullptr) {\n    service = psi_rwlock_hook->get_interface(PSI_CURRENT_RWLOCK_VERSION);\n    if (service != nullptr) {\n      set_psi_rwlock_service(service);\n    }\n  }\n\n  if (psi_cond_hook != nullptr) {\n    service = psi_cond_hook->get_interface(PSI_CURRENT_COND_VERSION);\n    if (service != nullptr) {\n      set_psi_cond_service(service);\n    }\n  }\n\n  if (psi_file_hook != nullptr) {\n    service = psi_file_hook->get_interface(PSI_CURRENT_FILE_VERSION);\n    if (service != nullptr) {\n      set_psi_file_service(service);\n    }\n  }\n\n  if (psi_socket_hook != nullptr) {\n    service = psi_socket_hook->get_interface(PSI_CURRENT_SOCKET_VERSION);\n    if (service != nullptr) {\n      set_psi_socket_service(service);\n    }\n  }\n\n  if (psi_table_hook != nullptr) {\n    service = psi_table_hook->get_interface(PSI_CURRENT_TABLE_VERSION);\n    if (service != nullptr) {\n      set_psi_table_service(service);\n    }\n  }\n\n  if (psi_mdl_hook != nullptr) {\n    service = psi_mdl_hook->get_interface(PSI_CURRENT_MDL_VERSION);\n    if (service != nullptr) {\n      set_psi_mdl_service(service);\n    }\n  }\n\n  if (psi_idle_hook != nullptr) {\n    service = psi_idle_hook->get_interface(PSI_CURRENT_IDLE_VERSION);\n    if (service != nullptr) {\n      set_psi_idle_service(service);\n    }\n  }\n\n  if (psi_stage_hook != nullptr) {\n    service = psi_stage_hook->get_interface(PSI_CURRENT_STAGE_VERSION);\n    if (service != nullptr) {\n      set_psi_stage_service(service);\n    }\n  }\n\n  if (psi_statement_hook != nullptr) {\n    service = psi_statement_hook->get_interface(PSI_CURRENT_STATEMENT_VERSION);\n    if (service != nullptr) {\n      set_psi_statement_service(service);\n    }\n  }\n\n  if (psi_transaction_hook != nullptr) {\n    service =\n        psi_transaction_hook->get_interface(PSI_CURRENT_TRANSACTION_VERSION);\n    if (service != nullptr) {\n      set_psi_transaction_service(service);\n    }\n  }\n\n  if (psi_memory_hook != nullptr) {\n    service = psi_memory_hook->get_interface(PSI_CURRENT_MEMORY_VERSION);\n    if (service != nullptr) {\n      set_psi_memory_service(service);\n    }\n  }\n\n  if (psi_error_hook != nullptr) {\n    service = psi_error_hook->get_interface(PSI_CURRENT_ERROR_VERSION);\n    if (service != nullptr) {\n      set_psi_error_service(service);\n    }\n  }\n\n  if (psi_data_lock_hook != nullptr) {\n    service = psi_data_lock_hook->get_interface(PSI_CURRENT_DATA_LOCK_VERSION);\n    if (service != nullptr) {\n      set_psi_data_lock_service(service);\n    }\n  }\n\n  if (psi_system_hook != nullptr) {\n    service = psi_system_hook->get_interface(PSI_CURRENT_SYSTEM_VERSION);\n    if (service != nullptr) {\n      set_psi_system_service(service);\n    }\n  }\n\n  /*\n    Now that we have parsed the command line arguments, and have initialized\n    the performance schema itself, the next step is to register all the\n    server instruments.\n  */\n  init_server_psi_keys();\n\n  /*\n    Now that some instrumentation is in place,\n    recreate objects which were initialised early,\n    so that they are instrumented as well.\n  */\n  my_thread_global_reinit();\n#endif /* HAVE_PSI_INTERFACE */\n\n  /*\n    Initialize Components core subsystem early on, once we have PSI, which it\n    uses. This part doesn't use any more MySQL-specific functionalities but\n    error logging and PFS.\n  */\n  if (component_infrastructure_init()) unireg_abort(MYSQLD_ABORT_EXIT);\n\n    /*\n      Initialize Performance Schema component services.\n    */\n#ifdef HAVE_PSI_THREAD_INTERFACE\n  if (!is_help_or_validate_option() && !opt_initialize) {\n    register_pfs_notification_service();\n    register_pfs_resource_group_service();\n  }\n#endif\n\n  // Initialize the resource group subsystem.\n  auto res_grp_mgr = resourcegroups::Resource_group_mgr::instance();\n  if (!is_help_or_validate_option() && !opt_initialize) {\n    if (res_grp_mgr->init()) {\n      LogErr(ERROR_LEVEL, ER_RESOURCE_GROUP_SUBSYSTEM_INIT_FAILED);\n      unireg_abort(MYSQLD_ABORT_EXIT);\n    }\n  }\n\n#ifdef HAVE_PSI_THREAD_INTERFACE\n  /* Instrument the main thread */\n  PSI_thread *psi = PSI_THREAD_CALL(new_thread)(key_thread_main, nullptr, 0);\n  PSI_THREAD_CALL(set_thread_os_id)(psi);\n  PSI_THREAD_CALL(set_thread)(psi);\n#endif /* HAVE_PSI_THREAD_INTERFACE */\n\n  /* Initialize audit interface globals. Audit plugins are inited later. */\n  mysql_audit_initialize();\n\n  Srv_session::module_init();\n\n  /*\n    Perform basic query log initialization. Should be called after\n    MY_INIT, as it initializes mutexes.\n  */\n  query_logger.init();\n\n  if (heo_error) {\n    /*\n      Parsing command line option failed,\n      Since we don't have a workable remaining_argc/remaining_argv\n      to continue the server initialization, this is as far as this\n      code can go.\n      This is the best effort to log meaningful messages:\n      - messages will be printed to stderr, which is not redirected yet,\n      - messages will be printed in the NT event log, for windows.\n    */\n    flush_error_log_messages();\n    /*\n      Not enough initializations for unireg_abort()\n      Using exit() for windows.\n    */\n    exit(MYSQLD_ABORT_EXIT);\n  }\n\n  if (init_common_variables()) {\n    setup_error_log();\n    unireg_abort(MYSQLD_ABORT_EXIT);  // Will do exit\n  }\n\n  size_t guardize = 0;\n#ifndef _WIN32\n  int retval = pthread_attr_getguardsize(&connection_attrib, &guardize);\n  DBUG_ASSERT(retval == 0);\n  if (retval != 0) guardize = my_thread_stack_size;\n#endif\n\n#if defined(__ia64__) || defined(__ia64)\n  /*\n    Peculiar things with ia64 platforms - it seems we only have half the\n    stack size in reality, so we have to double it here\n  */\n  guardize = my_thread_stack_size;\n#endif\n\n  if (0 != my_thread_attr_setstacksize(&connection_attrib,\n                                       my_thread_stack_size + guardize)) {\n    DBUG_ASSERT(false);\n  }\n\n  {\n    /* Retrieve used stack size;  Needed for checking stack overflows */\n    size_t stack_size = 0;\n    my_thread_attr_getstacksize(&connection_attrib, &stack_size);\n\n    /* We must check if stack_size = 0 as Solaris 2.9 can return 0 here */\n    if (stack_size && stack_size < (my_thread_stack_size + guardize)) {\n      LogErr(WARNING_LEVEL, ER_STACKSIZE_UNEXPECTED,\n             my_thread_stack_size + guardize, (long)stack_size);\n#if defined(__ia64__) || defined(__ia64)\n      my_thread_stack_size = stack_size / 2;\n#else\n      my_thread_stack_size = static_cast<ulong>(stack_size - guardize);\n#endif\n    }\n  }\n\n#ifndef DBUG_OFF\n  test_lc_time_sz();\n  srand(static_cast<uint>(time(nullptr)));\n#endif\n\n#if !defined(_WIN32)\n\n  if (opt_initialize && opt_daemonize) {\n    fprintf(stderr, \"Initialize and daemon options are incompatible.\\n\");\n    unireg_abort(MYSQLD_ABORT_EXIT);\n  }\n\n  if (opt_daemonize && log_error_dest == disabled_my_option &&\n      (isatty(STDOUT_FILENO) || isatty(STDERR_FILENO))) {\n    // Just use the default in this case.\n    log_error_dest = \"\";\n  }\n\n  if (opt_daemonize && !opt_validate_config) {\n    if (chdir(\"/\") < 0) {\n      LogErr(ERROR_LEVEL, ER_CANNOT_CHANGE_TO_ROOT_DIR, strerror(errno));\n      unireg_abort(MYSQLD_ABORT_EXIT);\n    }\n\n    if ((pipe_write_fd = mysqld::runtime::mysqld_daemonize()) < -1) {\n      LogErr(ERROR_LEVEL, ER_FAILED_START_MYSQLD_DAEMON);\n      unireg_abort(MYSQLD_ABORT_EXIT);\n    }\n\n    if (pipe_write_fd < 0) {\n      // This is the launching process and the daemon appears to have\n      // started ok (Need to call unireg_abort with success here to\n      // clean up resources in the lauching process.\n      unireg_abort(MYSQLD_SUCCESS_EXIT);\n    }\n\n    // Need to update the value of current_pid so that it reflects the\n    // pid of the daemon (the previous value was set by unireg_init()\n    // while still in the launcher process.\n    current_pid = static_cast<ulong>(getpid());\n  }\n#endif\n\n#ifndef _WIN32\n  user_info = check_user(mysqld_user);\n  if (!user_info.IsVoid()) {\n#if HAVE_CHOWN\n    if (unlikely(opt_initialize)) {\n      /* need to change the owner of the freshly created data directory */\n      MY_STAT stat;\n      char errbuf[MYSYS_STRERROR_SIZE];\n      bool must_chown = true;\n\n      /* fetch the directory's owner */\n      if (!my_stat(mysql_real_data_home, &stat, MYF(0))) {\n        LogErr(INFORMATION_LEVEL, ER_CANT_STAT_DATADIR, my_errno(),\n               my_strerror(errbuf, sizeof(errbuf), my_errno()));\n      }\n      /* Don't change it if it's already the same as SElinux stops this */\n      else if (stat.st_uid == user_info.pw_uid &&\n               stat.st_gid == user_info.pw_gid)\n        must_chown = false;\n\n      if (must_chown &&\n          chown(mysql_real_data_home, user_info.pw_uid, user_info.pw_gid)) {\n        LogErr(ERROR_LEVEL, ER_CANT_CHOWN_DATADIR, mysqld_user);\n        unireg_abort(1);\n      }\n    }\n#endif\n\n#if defined(HAVE_MLOCKALL) && defined(MCL_CURRENT)\n    if (locked_in_memory)  // getuid() == 0 here\n      set_effective_user(user_info);\n    else\n#endif\n      set_user(mysqld_user, user_info);\n  }\n#endif  // !_WIN32\n\n  /*\n   initiate key migration if any one of the migration specific\n   options are provided.\n  */\n  if (opt_keyring_migration_source || opt_keyring_migration_destination ||\n      migrate_connect_options) {\n    Migrate_keyring mk;\n    my_getopt_skip_unknown = TRUE;\n    if (mk.init(remaining_argc, remaining_argv, opt_keyring_migration_source,\n                opt_keyring_migration_destination, opt_keyring_migration_user,\n                opt_keyring_migration_host, opt_keyring_migration_password,\n                opt_keyring_migration_socket, opt_keyring_migration_port)) {\n      LogErr(ERROR_LEVEL, ER_KEYRING_MIGRATION_FAILED);\n      log_error_dest = \"stderr\";\n      flush_error_log_messages();\n      unireg_abort(MYSQLD_ABORT_EXIT);\n    }\n\n    if (mk.execute()) {\n      LogErr(ERROR_LEVEL, ER_KEYRING_MIGRATION_FAILED);\n      log_error_dest = \"stderr\";\n      flush_error_log_messages();\n      unireg_abort(MYSQLD_ABORT_EXIT);\n    }\n\n    my_getopt_skip_unknown = false;\n    LogErr(INFORMATION_LEVEL, ER_KEYRING_MIGRATION_SUCCESSFUL);\n    log_error_dest = \"stderr\";\n    flush_error_log_messages();\n    unireg_abort(MYSQLD_SUCCESS_EXIT);\n  }\n\n  /*\n   We have enough space for fiddling with the argv, continue\n  */\n  if (!(is_help_or_validate_option()) &&\n      my_setwd(mysql_real_data_home, MYF(0))) {\n    char errbuf[MYSYS_STRERROR_SIZE];\n\n    LogErr(ERROR_LEVEL, ER_CANT_SET_DATA_DIR, mysql_real_data_home, errno,\n           my_strerror(errbuf, sizeof(errbuf), errno));\n    unireg_abort(MYSQLD_ABORT_EXIT); /* purecov: inspected */\n  }\n\n  /*\n   The subsequent calls may take a long time : e.g. innodb log read.\n   Thus set the long running service control manager timeout\n  */\n#if defined(_WIN32)\n  if (windows_service) {\n    if (setup_service_status_cmd_processed_handle())\n      unireg_abort(MYSQLD_ABORT_EXIT);\n\n    char buf[32];\n    snprintf(buf, sizeof(buf), \"T %lu\", slow_start_timeout);\n    Service_status_msg msg(buf);\n    send_service_status(msg);\n  }\n#endif\n\n  /* Determine default TCP port and unix socket name */\n  set_ports();\n\n  if (init_server_components()) unireg_abort(MYSQLD_ABORT_EXIT);\n\n  if (!server_id_supplied)\n    LogErr(INFORMATION_LEVEL, ER_WARN_NO_SERVERID_SPECIFIED);\n\n  /* Server generates uuid after innodb is initialized. But during\n  initialization, if tablespaces like system, redo, temporary are encrypted,\n  they are initialized with \"empty\" UUID. Now UUID is available, fix the\n  empty UUID of such tablespaces now */\n  if (innodb_hton != nullptr) {\n    if (innodb_hton->fix_tablespaces_empty_uuid != nullptr &&\n        innodb_hton->fix_tablespaces_empty_uuid()) {\n      sql_print_error(\n          \"Fixing empty UUID with InnoDB Engine failed. Please\"\n          \" check if keyring plugin is loaded and execute\"\n          \" \\\"ALTER INSTANCE ROTATE INNODB MASTER KEY\\\"\");\n    }\n    // Only now, that we have server_uuid initialized we can\n    // instruct encryption threads to do some work\n    if (innodb_hton->fix_default_table_encryption != nullptr) {\n      innodb_hton->fix_default_table_encryption(\n          global_system_variables.default_table_encryption);\n    }\n  }\n\n  /*\n    Add server_uuid to the sid_map.  This must be done after\n    server_uuid has been initialized in init_server_auto_options and\n    after the binary log (and sid_map file) has been initialized in\n    init_server_components().\n\n    No error message is needed: init_sid_map() prints a message.\n\n    Strictly speaking, this is not currently needed when\n    opt_bin_log==0, since the variables that gtid_state->init\n    initializes are not currently used in that case.  But we call it\n    regardless to avoid possible future bugs if gtid_state ever\n    needs to do anything else.\n  */\n  global_sid_lock->wrlock();\n  int gtid_ret = gtid_state->init();\n  global_sid_lock->unlock();\n\n  if (gtid_ret) unireg_abort(MYSQLD_ABORT_EXIT);\n\n  if (!opt_initialize && !opt_initialize_insecure) {\n    // Initialize executed_gtids from mysql.gtid_executed table.\n    if (gtid_state->read_gtid_executed_from_table() == -1) unireg_abort(1);\n  }\n\n  if (opt_bin_log) {\n    /*\n      Initialize GLOBAL.GTID_EXECUTED and GLOBAL.GTID_PURGED from\n      gtid_executed table and binlog files during server startup.\n    */\n    Gtid_set *executed_gtids =\n        const_cast<Gtid_set *>(gtid_state->get_executed_gtids());\n    Gtid_set *lost_gtids = const_cast<Gtid_set *>(gtid_state->get_lost_gtids());\n    Gtid_set *gtids_only_in_table =\n        const_cast<Gtid_set *>(gtid_state->get_gtids_only_in_table());\n    Gtid_set *previous_gtids_logged =\n        const_cast<Gtid_set *>(gtid_state->get_previous_gtids_logged());\n\n    Gtid_set purged_gtids_from_binlog(global_sid_map, global_sid_lock);\n    Gtid_set gtids_in_binlog(global_sid_map, global_sid_lock);\n    Gtid_set gtids_in_binlog_not_in_table(global_sid_map, global_sid_lock);\n\n    if (mysql_bin_log.init_gtid_sets(\n            &gtids_in_binlog, &purged_gtids_from_binlog,\n            opt_master_verify_checksum, true /*true=need lock*/,\n            nullptr /*trx_parser*/, nullptr /*partial_trx*/,\n            true /*is_server_starting*/))\n      unireg_abort(MYSQLD_ABORT_EXIT);\n\n    global_sid_lock->wrlock();\n\n    purged_gtids_from_binlog.dbug_print(\"purged_gtids_from_binlog\");\n    gtids_in_binlog.dbug_print(\"gtids_in_binlog\");\n\n    if (!gtids_in_binlog.is_empty() &&\n        !gtids_in_binlog.is_subset(executed_gtids)) {\n      gtids_in_binlog_not_in_table.add_gtid_set(&gtids_in_binlog);\n      if (!executed_gtids->is_empty())\n        gtids_in_binlog_not_in_table.remove_gtid_set(executed_gtids);\n      /*\n        Save unsaved GTIDs into gtid_executed table, in the following\n        four cases:\n          1. the upgrade case.\n          2. the case that a slave is provisioned from a backup of\n             the master and the slave is cleaned by RESET MASTER\n             and RESET SLAVE before this.\n          3. the case that no binlog rotation happened from the\n             last RESET MASTER on the server before it crashes.\n          4. The set of GTIDs of the last binlog is not saved into the\n             gtid_executed table if server crashes, so we save it into\n             gtid_executed table and executed_gtids during recovery\n             from the crash.\n      */\n      if (gtid_state->save(&gtids_in_binlog_not_in_table) == -1) {\n        global_sid_lock->unlock();\n        unireg_abort(MYSQLD_ABORT_EXIT);\n      }\n      executed_gtids->add_gtid_set(&gtids_in_binlog_not_in_table);\n    }\n\n    /* gtids_only_in_table= executed_gtids - gtids_in_binlog */\n    if (gtids_only_in_table->add_gtid_set(executed_gtids) != RETURN_STATUS_OK) {\n      global_sid_lock->unlock();\n      unireg_abort(MYSQLD_ABORT_EXIT);\n    }\n    gtids_only_in_table->remove_gtid_set(&gtids_in_binlog);\n    /*\n      lost_gtids = executed_gtids -\n                   (gtids_in_binlog - purged_gtids_from_binlog)\n                 = gtids_only_in_table + purged_gtids_from_binlog;\n    */\n    DBUG_ASSERT(lost_gtids->is_empty());\n    if (lost_gtids->add_gtid_set(gtids_only_in_table) != RETURN_STATUS_OK ||\n        lost_gtids->add_gtid_set(&purged_gtids_from_binlog) !=\n            RETURN_STATUS_OK) {\n      global_sid_lock->unlock();\n      unireg_abort(MYSQLD_ABORT_EXIT);\n    }\n\n    /* Prepare previous_gtids_logged for next binlog */\n    if (previous_gtids_logged->add_gtid_set(&gtids_in_binlog) !=\n        RETURN_STATUS_OK) {\n      global_sid_lock->unlock();\n      unireg_abort(MYSQLD_ABORT_EXIT);\n    }\n\n    /*\n      Write the previous set of gtids at this point because during\n      the creation of the binary log this is not done as we cannot\n      move the init_gtid_sets() to a place before openning the binary\n      log. This requires some investigation.\n\n      /Alfranio\n    */\n    Previous_gtids_log_event prev_gtids_ev(&gtids_in_binlog);\n\n    global_sid_lock->unlock();\n\n    (prev_gtids_ev.common_footer)->checksum_alg =\n        static_cast<enum_binlog_checksum_alg>(binlog_checksum_options);\n\n    if (mysql_bin_log.write_event_to_binlog_and_sync(&prev_gtids_ev))\n      unireg_abort(MYSQLD_ABORT_EXIT);\n\n    (void)RUN_HOOK(server_state, after_engine_recovery, (nullptr));\n  }\n\n  if (init_ssl_communication()) unireg_abort(MYSQLD_ABORT_EXIT);\n  if (network_init()) unireg_abort(MYSQLD_ABORT_EXIT);\n\n#ifdef _WIN32\n  if (opt_require_secure_transport && !opt_enable_shared_memory &&\n      !SslAcceptorContext::have_ssl() && !opt_initialize) {\n    LogErr(ERROR_LEVEL, ER_TRANSPORTS_WHAT_TRANSPORTS);\n    unireg_abort(MYSQLD_ABORT_EXIT);\n  }\n#endif\n\n  /*\n   Initialize my_str_malloc(), my_str_realloc() and my_str_free()\n  */\n  my_str_malloc = &my_str_malloc_mysqld;\n  my_str_free = &my_str_free_mysqld;\n  my_str_realloc = &my_str_realloc_mysqld;\n\n  error_handler_hook = my_message_sql;\n\n  bool abort = false;\n\n  /* Save pid of this process in a file */\n  if (!opt_initialize) {\n    if (create_pid_file()) abort = true;\n  }\n\n  /* Read the optimizer cost model configuration tables */\n  if (!opt_initialize) reload_optimizer_cost_constants();\n\n  if (\n      /*\n        Read components table to restore previously installed components. This\n        requires read access to mysql.component table.\n      */\n      (!opt_initialize && mysql_component_infrastructure_init()) ||\n      mysql_rm_tmp_tables()) {\n    abort = true;\n  }\n\n  /* we do want to exit if there are any other unknown options */\n  if (remaining_argc > 1) {\n    int ho_error;\n    struct my_option no_opts[] = {{nullptr, 0, nullptr, nullptr, nullptr,\n                                   nullptr, GET_NO_ARG, NO_ARG, 0, 0, 0,\n                                   nullptr, 0, nullptr}};\n    /*\n      We need to eat any 'loose' arguments first before we conclude\n      that there are unprocessed options.\n    */\n    my_getopt_skip_unknown = false;\n\n    if ((ho_error = handle_options(&remaining_argc, &remaining_argv, no_opts,\n                                   mysqld_get_one_option)))\n      abort = true;\n    else {\n      /* Add back the program name handle_options removes */\n      remaining_argc++;\n      remaining_argv--;\n      my_getopt_skip_unknown = true;\n\n      if (remaining_argc > 1) {\n        LogErr(ERROR_LEVEL, ER_EXCESS_ARGUMENTS, remaining_argv[1]);\n        LogErr(INFORMATION_LEVEL, ER_VERBOSE_HINT);\n        abort = true;\n      }\n    }\n  }\n\n  if (abort || acl_init(opt_noacl)) {\n    if (!abort) LogErr(ERROR_LEVEL, ER_PRIVILEGE_SYSTEM_INIT_FAILED);\n    abort = true;\n    opt_noacl = true;\n  }\n\n  /*\n   if running with --initialize, explicitly allocate the memory\n   to be used by ACL objects.\n  */\n  if (opt_initialize) init_acl_memory();\n\n  /*\n    Turn ON the system variable '@@partial_revokes' during server\n    start in case there exist at least one restrictions instance.\n  */\n  if (mysqld_partial_revokes() == false && is_partial_revoke_exists(nullptr)) {\n    set_mysqld_partial_revokes(true);\n    LogErr(WARNING_LEVEL, ER_TURNING_ON_PARTIAL_REVOKES);\n  }\n\n  if (abort || my_tz_init((THD *)nullptr, default_tz_name, opt_initialize) ||\n      grant_init(opt_noacl)) {\n    set_connection_events_loop_aborted(true);\n\n    delete_pid_file(MYF(MY_WME));\n\n    unireg_abort(MYSQLD_ABORT_EXIT);\n  }\n\n  /*\n    Bootstrap the dynamic privilege service implementation\n  */\n  if (dynamic_privilege_init()) {\n    LogErr(WARNING_LEVEL, ER_PERSISTENT_PRIVILEGES_BOOTSTRAP);\n  }\n\n  if (!opt_initialize) servers_init(false);\n\n  if (!opt_noacl) {\n    udf_read_functions_table();\n  }\n\n  init_status_vars();\n  /* If running with --initialize, do not start replication. */\n  if (opt_initialize) opt_skip_slave_start = true;\n\n  check_binlog_cache_size(nullptr);\n  check_binlog_stmt_cache_size(nullptr);\n\n  binlog_unsafe_map_init();\n\n  /* If running with --initialize, do not start replication. */\n  if (!opt_initialize) {\n    // Make @@slave_skip_errors show the nice human-readable value.\n    set_slave_skip_errors(&opt_slave_skip_errors);\n    /*\n      Group replication filters should be discarded before init_slave(),\n      otherwise the pre-configured filters will be referenced by group\n      replication channels.\n    */\n    rpl_channel_filters.discard_group_replication_filters();\n\n    /*\n      init_slave() must be called after the thread keys are created.\n    */\n    if (server_id != 0)\n      init_slave(); /* Ignoring errors while configuring replication. */\n\n    /*\n      If the user specifies a per-channel replication filter through a\n      command-line option (or in a configuration file) for a slave\n      replication channel which does not exist as of now (i.e not\n      present in slave info tables yet), then the per-channel\n      replication filter is discarded with a warning.\n      If the user specifies a per-channel replication filter through\n      a command-line option (or in a configuration file) for group\n      replication channels 'group_replication_recovery' and\n      'group_replication_applier' which is disallowed, then the\n      per-channel replication filter is discarded with a warning.\n    */\n    rpl_channel_filters.discard_all_unattached_filters();\n  }\n\n#ifdef WITH_LOCK_ORDER\n  if (!opt_initialize) {\n    LO_activate();\n  }\n#endif /* WITH_LOCK_ORDER */\n\n#ifdef WITH_PERFSCHEMA_STORAGE_ENGINE\n  initialize_performance_schema_acl(opt_initialize);\n#endif /* WITH_PERFSCHEMA_STORAGE_ENGINE */\n\n  initialize_information_schema_acl();\n\n  (void)RUN_HOOK(server_state, after_recovery, (nullptr));\n\n  if (Events::init(opt_noacl || opt_initialize))\n    unireg_abort(MYSQLD_ABORT_EXIT);\n\n#ifndef _WIN32\n  //  Start signal handler thread.\n  start_signal_handler();\n#endif\n\n  /* set all persistent options */\n  if (persisted_variables_cache.set_persist_options()) {\n    LogErr(ERROR_LEVEL, ER_CANT_SET_UP_PERSISTED_VALUES);\n    flush_error_log_messages();\n    return 1;\n  }\n\n  /*\n    Activate loadable error logging components, if any.\n    First, check configuration value -- is it well-formed, and do\n    the requested services exist?\n  */\n  if (log_builtins_error_stack(opt_log_error_services, true, nullptr) == 0) {\n    // Syntax is OK and services exist; let's try to initialize them:\n    size_t pos;\n\n    if (log_builtins_error_stack(opt_log_error_services, false, &pos) < 0) {\n      char *problem = opt_log_error_services; /* purecov: begin inspected */\n      const char *var_name = \"log_error_services\";\n\n      /*\n        We failed to set the requested configuration. This can happen\n        e.g. when a given log-writer does not have sufficient permissions\n        to open its log files. pos should mark the position in the\n        configuration string where we ran into trouble. Make a char-pointer\n        from it so we can inform the user what log-service we could not\n        initialize.\n      */\n      if (pos < strlen(opt_log_error_services))\n        problem = &((char *)opt_log_error_services)[pos];\n\n      flush_error_log_messages();\n\n      /*\n        We could not set the requested pipeline.\n        Try to fall back to default error logging stack\n        (by looking up the system variable for this configuration\n        item and extracting the default value from it).\n        If that's impossible, print diagnostics, then exit.\n      */\n      sys_var *var = intern_find_sys_var(var_name, strlen(var_name));\n\n      if (var != nullptr) {\n        // We found the system variable, now extract the default value:\n        opt_log_error_services = (char *)var->get_default();\n        if (log_builtins_error_stack(opt_log_error_services, false, nullptr) >=\n            0) {\n          /*\n            We managed to set the default pipeline. Now log what was wrong\n            about the user-supplied value, then shut down.\n          */\n          LogErr(ERROR_LEVEL, ER_CANT_START_ERROR_LOG_SERVICE, var_name,\n                 problem);\n          unireg_abort(MYSQLD_ABORT_EXIT);\n        }\n        /*\n          If we arrive here, the user-supplied value was valid, but could\n          not be set. The default value was found, but also could not be\n          set. Something is very wrong. Fall-through to below where we\n          low-level write diagnostics, then abort.\n        */\n      }\n\n      /*\n        We failed to set the default error logging stack (or failed to look\n        up the default setting). At this point, we don't know whether ANY of\n        the requested sinks work, so our best bet is to write directly to the\n        error stream. Then, we abort.\n      */\n      {\n        char buff[512];\n        size_t len;\n\n        len = snprintf(buff, sizeof(buff),\n                       ER_DEFAULT(ER_CANT_START_ERROR_LOG_SERVICE), var_name,\n                       problem);\n        len = std::min(len, sizeof(buff) - 1);\n\n        // Trust nothing. Write directly. Quit.\n        log_write_errstream(buff, len);\n\n        unireg_abort(MYSQLD_ABORT_EXIT);\n      } /* purecov: end */\n    }   // value was OK, but could not be set\n    // If we arrive here, the value was OK, and was set successfully.\n  } else {\n    /*\n      We were given an illegal value at start-up, so the default was\n      used instead. Let's now point our variable back at the default\n      (i.e. the value actually used) so SELECT @@GLOBAL.log_error_services\n      will render correct results.\n    */\n    sys_var *var = intern_find_sys_var(STRING_WITH_LEN(\"log_error_services\"));\n    char *default_services = nullptr;\n\n    if ((var != nullptr) &&\n        ((default_services = (char *)var->get_default()) != nullptr))\n      log_builtins_error_stack(default_services, false, nullptr);\n\n    // Report that we're falling back to the default value.\n    LogErr(WARNING_LEVEL, ER_CANNOT_SET_LOG_ERROR_SERVICES,\n           opt_log_error_services);\n\n    if (default_services != nullptr) opt_log_error_services = default_services;\n  }\n\n  /*\n    Now that the error-logging stack is fully set up, loadable components\n    and all, flush buffered log-events to the log-services the user actually\n    wants!\n  */\n  log_error_stage_set(LOG_ERROR_STAGE_EXTERNAL_SERVICES_AVAILABLE);\n  flush_error_log_messages();\n\n  /*\n    Invoke the bootstrap thread, if required.\n  */\n  process_bootstrap();\n\n  /*\n    Event must be invoked after error_handler_hook is assigned to\n    my_message_sql, otherwise my_message will not cause the event to abort.\n  */\n  void *argv_p = argv;\n  if (mysql_audit_notify(AUDIT_EVENT(MYSQL_AUDIT_SERVER_STARTUP_STARTUP),\n                         static_cast<const char **>(argv_p), argc))\n    unireg_abort(MYSQLD_ABORT_EXIT);\n\n#ifdef _WIN32\n  create_shutdown_and_restart_thread();\n#endif\n  if (mysqld_process_must_end_at_startup) {\n#if !defined(_WIN32)\n    if (opt_daemonize) mysqld::runtime::signal_parent(pipe_write_fd, 1);\n#endif\n    unireg_abort(MYSQLD_SUCCESS_EXIT);\n  }\n\n  start_handle_manager();\n\n  create_compress_gtid_table_thread();\n\n  LogEvent()\n      .type(LOG_TYPE_ERROR)\n      .subsys(LOG_SUBSYSTEM_TAG)\n      .prio(SYSTEM_LEVEL)\n      .lookup(ER_SERVER_STARTUP_MSG, my_progname, server_version,\n#ifdef HAVE_SYS_UN_H\n              (opt_initialize ? \"\" : mysqld_unix_port),\n#else\n              \"\",\n#endif\n              mysqld_port, MYSQL_COMPILATION_COMMENT_SERVER);\n\n  if (!opt_disable_networking && my_admin_bind_addr_str)\n    LogEvent()\n        .type(LOG_TYPE_ERROR)\n        .subsys(LOG_SUBSYSTEM_TAG)\n        .prio(SYSTEM_LEVEL)\n        .lookup(ER_SERVER_STARTUP_ADMIN_INTERFACE, my_admin_bind_addr_str,\n                mysqld_admin_port, MYSQL_COMPILATION_COMMENT);\n\n#if defined(_WIN32)\n  if (windows_service) {\n    Service_status_msg s(\"R\");\n    send_service_status(s);\n  }\n#endif\n\n  server_components_initialized();\n\n  /*\n    Set opt_super_readonly here because if opt_super_readonly is set\n    in get_option, it will create problem while setting up event scheduler.\n  */\n  set_super_read_only_post_init();\n\n  DBUG_PRINT(\"info\", (\"Block, listening for incoming connections\"));\n\n  (void)MYSQL_SET_STAGE(0, __FILE__, __LINE__);\n\n  server_operational_state = SERVER_OPERATING;\n  sysd::notify(\"READY=1\\nSTATUS=Server is operational\\nMAIN_PID=\", getpid(),\n               \"\\n\");\n\n  (void)RUN_HOOK(server_state, before_handle_connection, (nullptr));\n\n#if defined(_WIN32)\n  setup_conn_event_handler_threads();\n#else\n  mysql_mutex_lock(&LOCK_socket_listener_active);\n  // Make it possible for the signal handler to kill the listener.\n  socket_listener_active = true;\n  mysql_mutex_unlock(&LOCK_socket_listener_active);\n\n  if (opt_daemonize) {\n    if (nstdout != nullptr) {\n      // Show the pid on stdout if deamonizing and connected to tty\n      fprintf(nstdout, \"mysqld is running as pid %lu\\n\", current_pid);\n      fclose(nstdout);\n      nstdout = nullptr;\n    }\n\n    mysqld::runtime::signal_parent(pipe_write_fd, 1);\n  }\n\n  mysqld_socket_acceptor->connection_event_loop();\n#endif /* _WIN32 */\n  server_operational_state = SERVER_SHUTTING_DOWN;\n  sysd::notify(\"STOPPING=1\\nSTATUS=Server shutdown in progress\\n\");\n\n  DBUG_PRINT(\"info\", (\"No longer listening for incoming connections\"));\n\n  mysql_audit_notify(MYSQL_AUDIT_SERVER_SHUTDOWN_SHUTDOWN,\n                     MYSQL_AUDIT_SERVER_SHUTDOWN_REASON_SHUTDOWN,\n                     MYSQLD_SUCCESS_EXIT);\n\n  terminate_compress_gtid_table_thread();\n  /*\n    Save set of GTIDs of the last binlog into gtid_executed table\n    on server shutdown.\n  */\n  if (opt_bin_log)\n    if (gtid_state->save_gtids_of_last_binlog_into_table())\n      LogErr(WARNING_LEVEL, ER_CANT_SAVE_GTIDS);\n\n#ifndef _WIN32\n  mysql_mutex_lock(&LOCK_socket_listener_active);\n  // Notify the signal handler that we have stopped listening for connections.\n  socket_listener_active = false;\n  mysql_cond_broadcast(&COND_socket_listener_active);\n  mysql_mutex_unlock(&LOCK_socket_listener_active);\n#endif  // !_WIN32\n\n#ifdef HAVE_PSI_THREAD_INTERFACE\n  /*\n    Disable the main thread instrumentation,\n    to avoid recording events during the shutdown.\n  */\n  PSI_THREAD_CALL(delete_current_thread)();\n#endif /* HAVE_PSI_THREAD_INTERFACE */\n\n  DBUG_PRINT(\"info\", (\"Waiting for shutdown proceed\"));\n  int ret = 0;\n#ifdef _WIN32\n  if (shutdown_restart_thr_handle.handle)\n    ret = my_thread_join(&shutdown_restart_thr_handle, NULL);\n  shutdown_restart_thr_handle.handle = NULL;\n  if (0 != ret)\n    LogErr(WARNING_LEVEL, ER_CANT_JOIN_SHUTDOWN_THREAD, \"shutdown \", ret);\n#else\n  if (signal_thread_id.thread != 0)\n    ret = my_thread_join(&signal_thread_id, nullptr);\n  signal_thread_id.thread = 0;\n  if (0 != ret)\n    LogErr(WARNING_LEVEL, ER_CANT_JOIN_SHUTDOWN_THREAD, \"signal_\", ret);\n#endif  // _WIN32\n\n  clean_up(true);\n  sysd::notify(\"STATUS=Server shutdown complete\");\n  mysqld_exit(signal_hand_thr_exit_code);\n}\n\n/****************************************************************************\n  Main and thread entry function for Win32\n  (all this is needed only to run mysqld as a service on WinNT)\n****************************************************************************/\n\n#if defined(_WIN32)\n\nbool is_windows_service() { return windows_service; }\n\nNTService *get_win_service_ptr() { return &Service; }\n\nint mysql_service(void *p) {\n  int my_argc;\n  char **my_argv;\n\n  if (use_opt_args) {\n    my_argc = opt_argc;\n    my_argv = opt_argv;\n  } else if (is_mysqld_monitor()) {\n    my_argc = Service.my_argc;\n    my_argv = Service.my_argv;\n  } else {\n    my_argc = my_global_argc;\n    my_argv = my_global_argv;\n  }\n\n  if (!mysqld_early_option) {\n    int res = start_monitor();\n    if (res != -1) {\n      deinitialize_mysqld_monitor();\n      return res;\n    }\n  }\n\n  if (my_thread_init()) {\n    flush_error_log_messages();\n    return 1;\n  }\n\n  win_main(my_argc, my_argv);\n\n  my_thread_end();\n  return 0;\n}\n\n/* Quote string if it contains space, else copy */\n\nstatic char *add_quoted_string(char *to, const char *from, char *to_end) {\n  uint length = (uint)(to_end - to);\n\n  if (!strchr(from, ' ')) return strmake(to, from, length - 1);\n  return strxnmov(to, length - 1, \"\\\"\", from, \"\\\"\", NullS);\n}\n\n/**\n  Handle basic handling of services, like installation and removal.\n\n  @param argv             Pointer to argument list\n  @param servicename    Internal name of service\n  @param displayname    Display name of service (in taskbar ?)\n  @param file_path    Path to this program\n  @param startup_option Startup option to mysqld\n\n  @retval\n    0   option handled\n  @retval\n    1   Could not handle option\n*/\n\nstatic bool default_service_handling(char **argv, const char *servicename,\n                                     const char *displayname,\n                                     const char *file_path,\n                                     const char *extra_opt,\n                                     const char *account_name) {\n  char path_and_service[FN_REFLEN + FN_REFLEN + 32], *pos, *end;\n  const char *opt_delim;\n  end = path_and_service + sizeof(path_and_service) - 3;\n\n  /* We have to quote filename if it contains spaces */\n  pos = add_quoted_string(path_and_service, file_path, end);\n  if (extra_opt && *extra_opt) {\n    /*\n     Add option after file_path. There will be zero or one extra option.  It's\n     assumed to be --defaults-file=file but isn't checked.  The variable (not\n     the option name) should be quoted if it contains a string.\n    */\n    *pos++ = ' ';\n    if (opt_delim = strchr(extra_opt, '=')) {\n      size_t length = ++opt_delim - extra_opt;\n      pos = my_stpnmov(pos, extra_opt, length);\n    } else\n      opt_delim = extra_opt;\n\n    pos = add_quoted_string(pos, opt_delim, end);\n  }\n  /* We must have servicename last */\n  *pos++ = ' ';\n  (void)add_quoted_string(pos, servicename, end);\n\n  if (Service.got_service_option(argv, \"install\")) {\n    Service.Install(1, servicename, displayname, path_and_service,\n                    account_name);\n    return 0;\n  }\n  if (Service.got_service_option(argv, \"install-manual\")) {\n    Service.Install(0, servicename, displayname, path_and_service,\n                    account_name);\n    return 0;\n  }\n  if (Service.got_service_option(argv, \"remove\")) {\n    Service.Remove(servicename);\n    return 0;\n  }\n  return 1;\n}\n\nint mysqld_main(int argc, char **argv) {\n  bool mysqld_monitor = false;\n  mysqld_early_option = is_early_option(argc, argv);\n\n  if (!mysqld_early_option) {\n    initialize_mysqld_monitor();\n    mysqld_monitor = is_mysqld_monitor();\n  }\n\n  if (mysqld_early_option || !mysqld_monitor) {\n    /*\n      When several instances are running on the same machine, we\n      need to have an  unique  named  hEventShudown  through the\n      application PID e.g.: MySQLShutdown1890; MySQLShutdown2342\n    */\n\n    longlong10_to_str(GetCurrentProcessId(),\n                      my_stpcpy(shutdown_event_name, \"MYSQLShutdown\"), 10);\n    longlong10_to_str(GetCurrentProcessId(),\n                      my_stpcpy(restart_event_name, \"MYSQLRestart\"), 10);\n  }\n\n  /* Must be initialized early for comparison of service name */\n  system_charset_info = &my_charset_utf8_general_ci;\n\n  if (mysqld_early_option || !mysqld_monitor) {\n#ifdef WITH_PERFSCHEMA_STORAGE_ENGINE\n    pre_initialize_performance_schema();\n#endif /*WITH_PERFSCHEMA_STORAGE_ENGINE */\n\n    if (my_init()) {\n      LogErr(ERROR_LEVEL, ER_MYINIT_FAILED);\n      flush_error_log_messages();\n      return 1;\n    }\n  }\n\n  if (Service.GetOS() && mysqld_monitor) /* true NT family */\n  {\n    char file_path[FN_REFLEN];\n    my_path(file_path, argv[0], \"\"); /* Find name in path */\n    fn_format(file_path, argv[0], file_path, \"\",\n              MY_REPLACE_DIR | MY_UNPACK_FILENAME | MY_RESOLVE_SYMLINKS);\n\n    if (argc == 2) {\n      if (!default_service_handling(argv, MYSQL_SERVICENAME, MYSQL_SERVICENAME,\n                                    file_path, \"\", NULL))\n        return 0;\n      if (Service.IsService(argv[1])) /* Start an optional service */\n      {\n        /*\n          Only add the service name to the groups read from the config file\n          if it's not \"MySQL\". (The default service name should be 'mysqld'\n          but we started a bad tradition by calling it MySQL from the start\n          and we are now stuck with it.\n        */\n        if (my_strcasecmp(system_charset_info, argv[1], \"mysql\"))\n          load_default_groups[load_default_groups_sz - 2] = argv[1];\n        windows_service = true;\n\n        Service.Init(argv[1], mysql_service);\n        return 0;\n      }\n    } else if (argc == 3) /* install or remove any optional service */\n    {\n      if (!default_service_handling(argv, argv[2], argv[2], file_path, \"\",\n                                    NULL))\n        return 0;\n      if (Service.IsService(argv[2])) {\n        /*\n          mysqld was started as\n          mysqld --defaults-file=my_path\\my.ini service-name\n        */\n        use_opt_args = 1;\n        opt_argc = 2;  // Skip service-name\n        opt_argv = argv;\n        windows_service = true;\n        if (my_strcasecmp(system_charset_info, argv[2], \"mysql\"))\n          load_default_groups[load_default_groups_sz - 2] = argv[2];\n        Service.Init(argv[2], mysql_service);\n        return 0;\n      }\n    } else if (argc == 4 || argc == 5) {\n      /*\n        This may seem strange, because we handle --local-service while\n        preserving 4.1's behavior of allowing any one other argument that is\n        passed to the service on startup. (The assumption is that this is\n        --defaults-file=file, but that was not enforced in 4.1, so we don't\n        enforce it here.)\n      */\n      const char *extra_opt = NullS;\n      const char *account_name = NullS;\n      int index;\n      for (index = 3; index < argc; index++) {\n        if (!strcmp(argv[index], \"--local-service\"))\n          account_name = \"NT AUTHORITY\\\\LocalService\";\n        else\n          extra_opt = argv[index];\n      }\n\n      if (argc == 4 || account_name)\n        if (!default_service_handling(argv, argv[2], argv[2], file_path,\n                                      extra_opt, account_name))\n          return 0;\n    } else if (argc == 1 && Service.IsService(MYSQL_SERVICENAME)) {\n      /* start the default service */\n      windows_service = true;\n      Service.Init(MYSQL_SERVICENAME, mysql_service);\n      return 0;\n    }\n  }\n\n  // Set windows_service value in mysqld\n  if (!mysqld_monitor) {\n    windows_service = is_monitor_win_service();\n\n    if (windows_service) {\n      if (argc == 2 && Service.IsService(argv[1])) {\n        if (my_strcasecmp(system_charset_info, argv[1], \"mysql\"))\n          load_default_groups[load_default_groups_sz - 2] = argv[1];\n        argc--;\n\n      } else if (argc == 3 && Service.IsService(argv[2])) {\n        /*\n        mysqld was started as\n        mysqld --defaults-file=my_path\\my.ini service-name\n        */\n        if (my_strcasecmp(system_charset_info, argv[2], \"mysql\"))\n          load_default_groups[load_default_groups_sz - 2] = argv[2];\n        argc--;\n      }\n    }\n\n    my_global_argc = argc;\n    my_global_argv = argv;\n  } else {\n    Service.my_argc = argc;\n    Service.my_argv = argv;\n  }\n\n  return mysql_service(NULL);\n}\n#endif  // _WIN32\n\n/**\n  Execute the bootstrap thread, if required.\n\n  When mysqld is started with --initialize only,\n  the bootstrap thread executes\n  - compiled in statements.\n  - create the non-DD based INFORMATION_SCHEMA.\n  and the server exits.\n\n  When mysqld is started with --init-file only,\n  the bootstrap thread executes SQL statements provided\n  in the input text file,\n  and the server continues and serves requests.\n\n  When mysqld is started with both --initialize and --init-file,\n  the bootstrap thread:\n  - executes compiled in statements,\n  - executes SQL statements in the --init-file.\n  - creates the non-DD based INFORMATION_SCHEMA.\n  The server then exits.\n\n  Compiled in statements are executed in a privileged mode,\n  with SYSTEM_THREAD_SERVER_INITIALIZE.\n\n  @see handle_bootstrap_impl\n*/\nstatic void process_bootstrap() {\n  MYSQL_FILE *init_file = nullptr;\n  const char *init_file_name = nullptr;\n  enum_thread_type system_thread;\n  bool need_bootstrap = false;\n\n  if (opt_initialize) {\n    // Make sure we can process SIGHUP during bootstrap.\n    server_components_initialized();\n    need_bootstrap = true;\n    system_thread = SYSTEM_THREAD_SERVER_INITIALIZE;\n  } else {\n    system_thread = SYSTEM_THREAD_INIT_FILE;\n  }\n\n  if (opt_init_file != nullptr) {\n    if (*opt_init_file != '\\0') {\n      init_file_name = opt_init_file;\n      LogErr(INFORMATION_LEVEL, ER_BEG_INITFILE, init_file_name);\n\n      init_file = mysql_file_fopen(key_file_init, init_file_name, O_RDONLY,\n                                   MYF(MY_WME));\n      need_bootstrap = true;\n    }\n\n    if (init_file == nullptr) {\n      LogErr(ERROR_LEVEL, ER_INIT_CANT_OPEN_BOOTSTRAP_FILE, init_file_name);\n      unireg_abort(MYSQLD_ABORT_EXIT);\n    }\n  }\n\n  if (need_bootstrap) {\n    bool error = bootstrap::run_bootstrap_thread(init_file_name, init_file,\n                                                 nullptr, system_thread);\n\n    if (init_file != nullptr) {\n      mysql_file_fclose(init_file, MYF(MY_WME));\n      LogErr(INFORMATION_LEVEL, ER_END_INITFILE, init_file_name);\n    }\n\n    if (error) {\n      /* Abort during system initialization, but not init-file execution */\n      if (system_thread == SYSTEM_THREAD_SERVER_INITIALIZE) {\n        unireg_abort(MYSQLD_ABORT_EXIT);\n      }\n    }\n\n    if (opt_initialize) {\n      // Create non DD based system views during --initialize.\n      error = dd::init(\n          dd::enum_dd_init_type::DD_INITIALIZE_NON_DD_BASED_SYSTEM_VIEWS);\n      if (error != 0) {\n        LogErr(ERROR_LEVEL, ER_SYSTEM_VIEW_INIT_FAILED);\n        unireg_abort(MYSQLD_ABORT_EXIT);\n      }\n\n      unireg_abort(MYSQLD_SUCCESS_EXIT);\n    }\n  }\n\n  return;\n}\n\n/****************************************************************************\n  Handle start options\n******************************************************************************/\n\n/**\n  Process command line options but use only \"help\", \"initialize\",\n  \"initialize-insecure\". If one of these options exists then change default\n  value of log_error_verbosity.\n*/\nstatic void adjust_log_error_verbosity(vector<my_option> *all_early_options) {\n  if (remaining_argc <= 1) return;\n\n  /* create a copy of remaining_argv */\n  int copy_argc = remaining_argc;\n  vector<char *> copy_argv;\n  copy_argv.reserve(copy_argc + 1);\n  for (int i = 0; i < copy_argc; i++) copy_argv.push_back(remaining_argv[i]);\n  copy_argv.push_back(nullptr);\n\n  /* select only \"help\", \"initialize\", \"initialize-insecure\" options */\n  vector<my_option> init_options;\n  static const vector<const char *> opt_names{\"help\", \"initialize\",\n                                              \"initialize-insecure\"};\n  for (my_option *opt = my_long_early_options; opt->name != nullptr; opt++)\n    if (std::find(opt_names.cbegin(), opt_names.cend(), opt->name) !=\n        opt_names.cend())\n      init_options.push_back(*opt);\n  add_terminator(&init_options);\n\n  char **copy_argv_ptr = &copy_argv[0];\n  int ho_error = handle_options(&copy_argc, &copy_argv_ptr, &init_options[0],\n                                mysqld_get_one_option);\n\n  if ((ho_error == 0) &&\n      (opt_help || opt_initialize || opt_initialize_insecure)) {\n    /*\n      Show errors during --help, but mute everything else so the info the\n      user actually wants isn't lost in the spam.  (For --help --verbose,\n      we need to set up far enough to be able to print variables provided\n      by plugins, so a good number of warnings/notes might get printed.)\n      Likewise for --initialize.\n    */\n    for (my_option *opt = &(*all_early_options)[0]; opt->name; opt++)\n      if (!strcmp(\"log_error_verbosity\", opt->name)) {\n        opt->def_value = (opt_initialize || opt_initialize_insecure) ? 2 : 1;\n      }\n  }\n}\n\n/**\n  Process command line options flagged as 'early'.\n  Some components needs to be initialized as early as possible,\n  because the rest of the server initialization depends on them.\n  Options that needs to be parsed early includes:\n  - the performance schema, when compiled in,\n  - options related to the help,\n  - options related to the bootstrap\n  The performance schema needs to be initialized as early as possible,\n  before to-be-instrumented objects of the server are initialized.\n*/\nstatic int handle_early_options() {\n  int ho_error;\n  vector<my_option> all_early_options;\n  all_early_options.reserve(100);\n\n  my_getopt_register_get_addr(nullptr);\n  /* Skip unknown options so that they may be processed later */\n  my_getopt_skip_unknown = true;\n\n  /* Add the system variables parsed early */\n  sys_var_add_options(&all_early_options, sys_var::PARSE_EARLY);\n\n  /* Add the command line options parsed early */\n  for (my_option *opt = my_long_early_options; opt->name != nullptr; opt++)\n    all_early_options.push_back(*opt);\n\n  add_terminator(&all_early_options);\n\n  my_getopt_error_reporter = option_error_reporter;\n  my_charset_error_reporter = charset_error_reporter;\n\n  adjust_log_error_verbosity(&all_early_options);\n\n  ho_error = handle_options(&remaining_argc, &remaining_argv,\n                            &all_early_options[0], mysqld_get_one_option);\n\n  if (ho_error == 0) {\n    /* update verbosity in filter engine, if needed */\n    log_builtins_filter_update_verbosity(log_error_verbosity);\n\n    /* Add back the program name handle_options removes */\n    remaining_argc++;\n    remaining_argv--;\n\n    if (opt_initialize_insecure) opt_initialize = true;\n\n    if (opt_debugging) {\n      /* Allow break with SIGINT, no core or stack trace */\n      test_flags |= TEST_SIGINT | TEST_NO_STACKTRACE;\n      test_flags &= ~TEST_CORE_ON_SIGNAL;\n    }\n  }\n\n  // Swap with an empty vector, i.e. delete elements and free allocated space.\n  vector<my_option>().swap(all_early_options);\n\n  return ho_error;\n}\n\n/**\n  Adjust @c open_files_limit.\n  Computation is  based on:\n  - @c max_connections,\n  - @c table_cache_size,\n  - the platform max open file limit.\n*/\nstatic void adjust_open_files_limit(ulong *requested_open_files) {\n  ulong limit_1;\n  ulong limit_2;\n  ulong limit_3;\n  ulong request_open_files;\n  ulong effective_open_files;\n\n  /* MyISAM requires two file handles per table. */\n  limit_1 = 10 + max_connections + table_cache_size * 2;\n\n  /*\n    We are trying to allocate no less than max_connections*5 file\n    handles (i.e. we are trying to set the limit so that they will\n    be available).\n  */\n  limit_2 = max_connections * 5;\n\n  /* Try to allocate no less than 5000 by default. */\n  limit_3 = open_files_limit ? open_files_limit : 5000;\n\n  request_open_files = max<ulong>(max<ulong>(limit_1, limit_2), limit_3);\n\n  /* Notice: my_set_max_open_files() may return more than requested. */\n  effective_open_files = my_set_max_open_files(request_open_files);\n\n  if (effective_open_files < request_open_files) {\n    if (open_files_limit == 0) {\n      LogErr(WARNING_LEVEL, ER_CHANGED_MAX_OPEN_FILES, effective_open_files,\n             request_open_files);\n    } else {\n      LogErr(WARNING_LEVEL, ER_CANT_INCREASE_MAX_OPEN_FILES,\n             effective_open_files, request_open_files);\n    }\n  }\n\n  open_files_limit = effective_open_files;\n  if (requested_open_files)\n    *requested_open_files =\n        min<ulong>(effective_open_files, request_open_files);\n}\n\nstatic void adjust_max_connections(ulong requested_open_files) {\n  ulong limit;\n\n  limit = requested_open_files - 10 - TABLE_OPEN_CACHE_MIN * 2;\n\n  if (limit < max_connections) {\n    LogErr(WARNING_LEVEL, ER_CHANGED_MAX_CONNECTIONS, limit, max_connections);\n\n    // This can be done unprotected since it is only called on startup.\n    max_connections = limit;\n  }\n}\n\nstatic void adjust_table_cache_size(ulong requested_open_files) {\n  ulong limit;\n\n  limit = max<ulong>((requested_open_files - 10 - max_connections) / 2,\n                     TABLE_OPEN_CACHE_MIN);\n\n  if (limit < table_cache_size) {\n    LogErr(WARNING_LEVEL, ER_CHANGED_TABLE_OPEN_CACHE, limit, table_cache_size);\n\n    table_cache_size = limit;\n  }\n\n  table_cache_size_per_instance = table_cache_size / table_cache_instances;\n}\n\nstatic void adjust_table_def_size() {\n  ulong default_value;\n  sys_var *var;\n\n  default_value = min<ulong>(400 + table_cache_size / 2, 2000);\n  var = intern_find_sys_var(STRING_WITH_LEN(\"table_definition_cache\"));\n  DBUG_ASSERT(var != nullptr);\n  var->update_default(default_value);\n\n  if (!table_definition_cache_specified) table_def_size = default_value;\n}\n\nstatic void adjust_related_options(ulong *requested_open_files) {\n  /*\n    In bootstrap, disable grant tables (about to be created)\n  */\n  if (opt_initialize) opt_noacl = true;\n\n  /* The order is critical here, because of dependencies. */\n  adjust_open_files_limit(requested_open_files);\n  adjust_max_connections(*requested_open_files);\n  adjust_table_cache_size(*requested_open_files);\n  adjust_table_def_size();\n}\n\nvector<my_option> all_options;\n\nstruct my_option my_long_early_options[] = {\n#if !defined(_WIN32)\n    {\"daemonize\", 'D', \"Run mysqld as sysv daemon\", &opt_daemonize,\n     &opt_daemonize, nullptr, GET_BOOL, NO_ARG, 0, 0, 0, nullptr, 0, nullptr},\n#endif\n    {\"skip-grant-tables\", 0,\n     \"Start without grant tables. This gives all users FULL ACCESS to all \"\n     \"tables.\",\n     &opt_noacl, &opt_noacl, nullptr, GET_BOOL, NO_ARG, 0, 0, 0, nullptr, 0,\n     nullptr},\n    {\"help\", '?', \"Display this help and exit.\", &opt_help, &opt_help, nullptr,\n     GET_BOOL, NO_ARG, 0, 0, 0, nullptr, 0, nullptr},\n    {\"verbose\", 'v', \"Used with --help option for detailed help.\", &opt_verbose,\n     &opt_verbose, nullptr, GET_BOOL, NO_ARG, 0, 0, 0, nullptr, 0, nullptr},\n    {\"version\", 'V', \"Output version information and exit.\", nullptr, nullptr,\n     nullptr, GET_NO_ARG, NO_ARG, 0, 0, 0, nullptr, 0, nullptr},\n    {\"initialize\", 'I',\n     \"Create the default database and exit.\"\n     \" Create a super user with a random expired password and store it into \"\n     \"the log.\",\n     &opt_initialize, &opt_initialize, nullptr, GET_BOOL, NO_ARG, 0, 0, 0,\n     nullptr, 0, nullptr},\n    {\"initialize-insecure\", 0,\n     \"Create the default database and exit.\"\n     \" Create a super user with empty password.\",\n     &opt_initialize_insecure, &opt_initialize_insecure, nullptr, GET_BOOL,\n     NO_ARG, 0, 0, 0, nullptr, 0, nullptr},\n    {\"keyring-migration-source\", OPT_KEYRING_MIGRATION_SOURCE,\n     \"Keyring plugin from where the keys needs to \"\n     \"be migrated to. This option must be specified along with \"\n     \"--keyring-migration-destination.\",\n     &opt_keyring_migration_source, &opt_keyring_migration_source, nullptr,\n     GET_STR, REQUIRED_ARG, 0, 0, 0, nullptr, 0, nullptr},\n    {\"keyring-migration-destination\", OPT_KEYRING_MIGRATION_DESTINATION,\n     \"Keyring plugin to which the keys are \"\n     \"migrated to. This option must be specified along with \"\n     \"--keyring-migration-source.\",\n     &opt_keyring_migration_destination, &opt_keyring_migration_destination,\n     nullptr, GET_STR, REQUIRED_ARG, 0, 0, 0, nullptr, 0, nullptr},\n    {\"keyring-migration-user\", OPT_KEYRING_MIGRATION_USER,\n     \"User to login to server.\", &opt_keyring_migration_user,\n     &opt_keyring_migration_user, nullptr, GET_STR, REQUIRED_ARG, 0, 0, 0,\n     nullptr, 0, nullptr},\n    {\"keyring-migration-host\", OPT_KEYRING_MIGRATION_HOST, \"Connect to host.\",\n     &opt_keyring_migration_host, &opt_keyring_migration_host, nullptr, GET_STR,\n     REQUIRED_ARG, 0, 0, 0, nullptr, 0, nullptr},\n    {\"keyring-migration-password\", 'p',\n     \"Password to use when connecting to server during keyring migration. \"\n     \"If password value is not specified then it will be asked from the tty.\",\n     nullptr, nullptr, nullptr, GET_PASSWORD, OPT_ARG, 0, 0, 0, nullptr, 0,\n     nullptr},\n    {\"keyring-migration-socket\", OPT_KEYRING_MIGRATION_SOCKET,\n     \"The socket file to use for connection.\", &opt_keyring_migration_socket,\n     &opt_keyring_migration_socket, nullptr, GET_STR, REQUIRED_ARG, 0, 0, 0,\n     nullptr, 0, nullptr},\n    {\"keyring-migration-port\", OPT_KEYRING_MIGRATION_PORT,\n     \"Port number to use for connection.\", &opt_keyring_migration_port,\n     &opt_keyring_migration_port, nullptr, GET_ULONG, REQUIRED_ARG, 0, 0, 0,\n     nullptr, 0, nullptr},\n    {\"no-dd-upgrade\", 0,\n     \"Abort restart if automatic upgrade or downgrade of the data dictionary \"\n     \"is needed. Deprecated option. Use --upgrade=NONE instead.\",\n     &opt_no_dd_upgrade, &opt_no_dd_upgrade, nullptr, GET_BOOL, NO_ARG, 0, 0, 0,\n     nullptr, 0, nullptr},\n    {\"validate-config\", 0,\n     \"Validate the server configuration specified by the user.\",\n     &opt_validate_config, &opt_validate_config, nullptr, GET_BOOL, NO_ARG, 0,\n     0, 0, nullptr, 0, nullptr},\n    {\"core-file\", OPT_WANT_CORE, \"Write core on errors.\", 0, 0, nullptr,\n     GET_NO_ARG, NO_ARG, 0, 0, 0, nullptr, 0, nullptr},\n    {\"skip-stack-trace\", OPT_SKIP_STACK_TRACE,\n     \"Don't print a stack trace on failure.\", 0, 0, nullptr, GET_NO_ARG, NO_ARG,\n     0, 0, 0, nullptr, 0, nullptr},\n    /* We must always support the next option to make scripts like mysqltest\n       easier to do */\n    {\"gdb\", 0, \"Set up signals usable for debugging.\", &opt_debugging,\n     &opt_debugging, nullptr, GET_BOOL, NO_ARG, 0, 0, 0, nullptr, 0, nullptr},\n    {nullptr, 0, nullptr, nullptr, nullptr, nullptr, GET_NO_ARG, NO_ARG, 0, 0,\n     0, nullptr, 0, nullptr}};\n\n/**\n  System variables are automatically command-line options (few\n  exceptions are documented in sys_var.h), so don't need\n  to be listed here.\n*/\n\nstruct my_option my_long_options[] = {\n    {\"abort-slave-event-count\", 0,\n     \"Option used by mysql-test for debugging and testing of replication.\",\n     &abort_slave_event_count, &abort_slave_event_count, nullptr, GET_INT,\n     REQUIRED_ARG, 0, 0, 0, nullptr, 0, nullptr},\n    {\"allow-suspicious-udfs\", 0,\n     \"Allows use of UDFs consisting of only one symbol xxx() \"\n     \"without corresponding xxx_init() or xxx_deinit(). That also means \"\n     \"that one can load any function from any library, for example exit() \"\n     \"from libc.so\",\n     &opt_allow_suspicious_udfs, &opt_allow_suspicious_udfs, nullptr, GET_BOOL,\n     NO_ARG, 0, 0, 0, nullptr, 0, nullptr},\n    {\"ansi\", 'a',\n     \"Use ANSI SQL syntax instead of MySQL syntax. This mode \"\n     \"will also set transaction isolation level 'serializable'.\",\n     nullptr, nullptr, nullptr, GET_NO_ARG, NO_ARG, 0, 0, 0, nullptr, 0,\n     nullptr},\n    /*\n      Because Sys_var_bit does not support command-line options, we need to\n      explicitly add one for --autocommit\n    */\n    {\"autocommit\", 0, \"Set default value for autocommit (0 or 1)\",\n     &opt_autocommit, &opt_autocommit, nullptr, GET_BOOL, OPT_ARG, 1, 0, 0,\n     &source_autocommit, /* arg_source, to be copied to Sys_var */\n     0, nullptr},\n    {\"binlog-do-db\", OPT_BINLOG_DO_DB,\n     \"Tells the master it should log updates for the specified database, \"\n     \"and exclude all others not explicitly mentioned.\",\n     nullptr, nullptr, nullptr, GET_STR, REQUIRED_ARG, 0, 0, 0, nullptr, 0,\n     nullptr},\n    {\"binlog-ignore-db\", OPT_BINLOG_IGNORE_DB,\n     \"Tells the master that updates to the given database should not be logged \"\n     \"to the binary log.\",\n     nullptr, nullptr, nullptr, GET_STR, REQUIRED_ARG, 0, 0, 0, nullptr, 0,\n     nullptr},\n    {\"character-set-client-handshake\", 0,\n     \"Don't ignore client side character set value sent during handshake.\",\n     &opt_character_set_client_handshake, &opt_character_set_client_handshake,\n     nullptr, GET_BOOL, NO_ARG, 1, 0, 0, nullptr, 0, nullptr},\n    {\"character-set-filesystem\", 0, \"Set the filesystem character set.\",\n     &character_set_filesystem_name, &character_set_filesystem_name, nullptr,\n     GET_STR, REQUIRED_ARG, 0, 0, 0, nullptr, 0, nullptr},\n    {\"character-set-server\", 'C', \"Set the default character set.\",\n     &default_character_set_name, &default_character_set_name, nullptr, GET_STR,\n     REQUIRED_ARG, 0, 0, 0, nullptr, 0, nullptr},\n    {\"chroot\", 'r', \"Chroot mysqld daemon during startup.\", &mysqld_chroot,\n     &mysqld_chroot, nullptr, GET_STR, REQUIRED_ARG, 0, 0, 0, nullptr, 0,\n     nullptr},\n    {\"collation-server\", 0, \"Set the default collation.\",\n     &default_collation_name, &default_collation_name, nullptr, GET_STR,\n     REQUIRED_ARG, 0, 0, 0, nullptr, 0, nullptr},\n    {\"console\", OPT_CONSOLE,\n     \"Write error output on screen; don't remove the console window on \"\n     \"windows.\",\n     &opt_console, &opt_console, nullptr, GET_BOOL, NO_ARG, 0, 0, 0, nullptr, 0,\n     nullptr},\n    /* default-storage-engine should have \"MyISAM\" as def_value. Instead\n       of initializing it here it is done in init_common_variables() due\n       to a compiler bug in Sun Studio compiler. */\n    {\"default-storage-engine\", 0, \"The default storage engine for new tables\",\n     &default_storage_engine, nullptr, nullptr, GET_STR, REQUIRED_ARG, 0, 0, 0,\n     nullptr, 0, nullptr},\n    {\"default-tmp-storage-engine\", 0,\n     \"The default storage engine for new explicit temporary tables\",\n     &default_tmp_storage_engine, nullptr, nullptr, GET_STR, REQUIRED_ARG, 0, 0,\n     0, nullptr, 0, nullptr},\n    {\"default-time-zone\", 0, \"Set the default time zone.\", &default_tz_name,\n     &default_tz_name, nullptr, GET_STR, REQUIRED_ARG, 0, 0, 0, nullptr, 0,\n     nullptr},\n    {\"disconnect-slave-event-count\", 0,\n     \"Option used by mysql-test for debugging and testing of replication.\",\n     &disconnect_slave_event_count, &disconnect_slave_event_count, nullptr,\n     GET_INT, REQUIRED_ARG, 0, 0, 0, nullptr, 0, nullptr},\n    {\"exit-info\", 'T', \"Used for debugging. Use at your own risk.\", nullptr,\n     nullptr, nullptr, GET_LONG, OPT_ARG, 0, 0, 0, nullptr, 0, nullptr},\n\n    {\"external-locking\", 0,\n     \"Use system (external) locking (disabled by \"\n     \"default).  With this option enabled you can run myisamchk to test \"\n     \"(not repair) tables while the MySQL server is running. Disable with \"\n     \"--skip-external-locking.\",\n     &opt_external_locking, &opt_external_locking, nullptr, GET_BOOL, NO_ARG, 0,\n     0, 0, nullptr, 0, nullptr},\n#if defined(HAVE_LINUX_LARGE_PAGES) || defined(HAVE_SOLARIS_LARGE_PAGES)\n    {\"super-large-pages\", 0, \"Enable support for super large pages.\",\n     &opt_super_large_pages, &opt_super_large_pages, nullptr, GET_BOOL, OPT_ARG,\n     0, 0, 1, nullptr, 1, nullptr},\n#endif\n    {\"language\", 'L',\n     \"Client error messages in given language. May be given as a full path. \"\n     \"Deprecated. Use --lc-messages-dir instead.\",\n     &lc_messages_dir_ptr, &lc_messages_dir_ptr, nullptr, GET_STR, REQUIRED_ARG,\n     0, 0, 0, nullptr, 0, nullptr},\n    {\"lc-messages\", 0, \"Set the language used for the error messages.\",\n     &lc_messages, &lc_messages, nullptr, GET_STR, REQUIRED_ARG, 0, 0, 0,\n     nullptr, 0, nullptr},\n    {\"lc-time-names\", 0,\n     \"Set the language used for the month names and the days of the week.\",\n     &lc_time_names_name, &lc_time_names_name, nullptr, GET_STR, REQUIRED_ARG,\n     0, 0, 0, nullptr, 0, nullptr},\n    {\"log-bin\", OPT_BIN_LOG,\n     \"Configures the name prefix to use for binary log files. If the --log-bin \"\n     \"option is not supplied, the name prefix defaults to \\\"binlog\\\". If the \"\n     \"--log-bin option is supplied without argument, the name prefix defaults \"\n     \"to \\\"HOSTNAME-bin\\\", where HOSTNAME is the machine's hostname. To set a \"\n     \"different name prefix for binary log files, use --log-bin=name. To \"\n     \"disable \"\n     \"binary logging, use the --skip-log-bin or --disable-log-bin option.\",\n     &opt_bin_logname, &opt_bin_logname, nullptr, GET_STR_ALLOC, OPT_ARG, 0, 0,\n     0, nullptr, 0, nullptr},\n    {\"log-bin-index\", 0, \"File that holds the names for binary log files.\",\n     &opt_binlog_index_name, &opt_binlog_index_name, nullptr, GET_STR,\n     REQUIRED_ARG, 0, 0, 0, nullptr, 0, nullptr},\n    {\"relay-log-index\", 0, \"File that holds the names for relay log files.\",\n     &opt_relaylog_index_name, &opt_relaylog_index_name, nullptr, GET_STR,\n     REQUIRED_ARG, 0, 0, 0, nullptr, 0, nullptr},\n    {\"log-isam\", OPT_ISAM_LOG, \"Log all MyISAM changes to file.\",\n     &myisam_log_filename, &myisam_log_filename, nullptr, GET_STR, OPT_ARG, 0,\n     0, 0, nullptr, 0, nullptr},\n    {\"log-short-format\", 0,\n     \"Don't log extra information to update and slow-query logs.\",\n     &opt_short_log_format, &opt_short_log_format, nullptr, GET_BOOL, NO_ARG, 0,\n     0, 0, nullptr, 0, nullptr},\n    {\"log-tc\", 0,\n     \"Path to transaction coordinator log (used for transactions that affect \"\n     \"more than one storage engine, when binary log is disabled).\",\n     &opt_tc_log_file, &opt_tc_log_file, nullptr, GET_STR, REQUIRED_ARG, 0, 0,\n     0, nullptr, 0, nullptr},\n    {\"log-tc-size\", 0, \"Size of transaction coordinator log.\", &opt_tc_log_size,\n     &opt_tc_log_size, nullptr, GET_ULONG, REQUIRED_ARG,\n     TC_LOG_MIN_PAGES *my_getpagesize(), TC_LOG_MIN_PAGES *my_getpagesize(),\n     ULONG_MAX, nullptr, my_getpagesize(), nullptr},\n    {\"master-info-file\", OPT_MASTER_INFO_FILE,\n     \"The location and name of the file that remembers the master and where \"\n     \"the I/O replication thread is in the master's binlogs. \"\n     \"Deprecated option that shall be removed eventually without a \"\n     \"replacement.\",\n     &master_info_file, &master_info_file, nullptr, GET_STR, REQUIRED_ARG, 0, 0,\n     0, nullptr, 0, nullptr},\n    {\"master-retry-count\", OPT_MASTER_RETRY_COUNT,\n     \"The number of tries the slave will make to connect to the master before \"\n     \"giving up. \"\n     \"Deprecated option, use 'CHANGE MASTER TO master_retry_count = <num>' \"\n     \"instead.\",\n     &master_retry_count, &master_retry_count, nullptr, GET_ULONG, REQUIRED_ARG,\n     3600 * 24, 0, 0, nullptr, 0, nullptr},\n    {\"max-binlog-dump-events\", 0,\n     \"Option used by mysql-test for debugging and testing of replication.\",\n     &max_binlog_dump_events, &max_binlog_dump_events, nullptr, GET_INT,\n     REQUIRED_ARG, 0, 0, 0, nullptr, 0, nullptr},\n    {\"memlock\", 0, \"Lock mysqld in memory.\", &locked_in_memory,\n     &locked_in_memory, nullptr, GET_BOOL, NO_ARG, 0, 0, 0, nullptr, 0,\n     nullptr},\n    {\"old-style-user-limits\", 0,\n     \"Enable old-style user limits (before 5.0.3, user resources were counted \"\n     \"per each user+host vs. per account).\",\n     &opt_old_style_user_limits, &opt_old_style_user_limits, nullptr, GET_BOOL,\n     NO_ARG, 0, 0, 0, nullptr, 0, nullptr},\n    {\"port-open-timeout\", 0,\n     \"Maximum time in seconds to wait for the port to become free. \"\n     \"(Default: No wait).\",\n     &mysqld_port_timeout, &mysqld_port_timeout, nullptr, GET_UINT,\n     REQUIRED_ARG, 0, 0, 0, nullptr, 0, nullptr},\n    {\"replicate-do-db\", OPT_REPLICATE_DO_DB,\n     \"Tells the slave thread to restrict replication to the specified \"\n     \"database. \"\n     \"To specify more than one database, use the directive multiple times, \"\n     \"once for each database. Note that this will only work if you do not use \"\n     \"cross-database queries such as UPDATE some_db.some_table SET foo='bar' \"\n     \"while having selected a different or no database. If you need cross \"\n     \"database updates to work, make sure you have 3.23.28 or later, and use \"\n     \"replicate-wild-do-table=db_name.%.\",\n     nullptr, nullptr, nullptr, GET_STR, REQUIRED_ARG, 0, 0, 0, nullptr, 0,\n     nullptr},\n    {\"replicate-do-table\", OPT_REPLICATE_DO_TABLE,\n     \"Tells the slave thread to restrict replication to the specified table. \"\n     \"To specify more than one table, use the directive multiple times, once \"\n     \"for each table. This will work for cross-database updates, in contrast \"\n     \"to replicate-do-db.\",\n     nullptr, nullptr, nullptr, GET_STR, REQUIRED_ARG, 0, 0, 0, nullptr, 0,\n     nullptr},\n    {\"replicate-ignore-db\", OPT_REPLICATE_IGNORE_DB,\n     \"Tells the slave thread to not replicate to the specified database. To \"\n     \"specify more than one database to ignore, use the directive multiple \"\n     \"times, once for each database. This option will not work if you use \"\n     \"cross database updates. If you need cross database updates to work, \"\n     \"make sure you have 3.23.28 or later, and use replicate-wild-ignore-\"\n     \"table=db_name.%. \",\n     nullptr, nullptr, nullptr, GET_STR, REQUIRED_ARG, 0, 0, 0, nullptr, 0,\n     nullptr},\n    {\"replicate-ignore-table\", OPT_REPLICATE_IGNORE_TABLE,\n     \"Tells the slave thread to not replicate to the specified table. To \"\n     \"specify \"\n     \"more than one table to ignore, use the directive multiple times, once \"\n     \"for \"\n     \"each table. This will work for cross-database updates, in contrast to \"\n     \"replicate-ignore-db.\",\n     nullptr, nullptr, nullptr, GET_STR, REQUIRED_ARG, 0, 0, 0, nullptr, 0,\n     nullptr},\n    {\"replicate-rewrite-db\", OPT_REPLICATE_REWRITE_DB,\n     \"Updates to a database with a different name than the original. Example: \"\n     \"replicate-rewrite-db=master_db_name->slave_db_name.\",\n     nullptr, nullptr, nullptr, GET_STR, REQUIRED_ARG, 0, 0, 0, nullptr, 0,\n     nullptr},\n    {\"replicate-same-server-id\", 0,\n     \"In replication, if set to 1, do not skip events having our server id. \"\n     \"Default value is 0 (to break infinite loops in circular replication). \"\n     \"Can't be set to 1 if --log-slave-updates is used.\",\n     &replicate_same_server_id, &replicate_same_server_id, nullptr, GET_BOOL,\n     NO_ARG, 0, 0, 0, nullptr, 0, nullptr},\n    {\"replicate-wild-do-table\", OPT_REPLICATE_WILD_DO_TABLE,\n     \"Tells the slave thread to restrict replication to the tables that match \"\n     \"the specified wildcard pattern. To specify more than one table, use the \"\n     \"directive multiple times, once for each table. This will work for cross-\"\n     \"database updates. Example: replicate-wild-do-table=foo%.bar% will \"\n     \"replicate only updates to tables in all databases that start with foo \"\n     \"and whose table names start with bar.\",\n     nullptr, nullptr, nullptr, GET_STR, REQUIRED_ARG, 0, 0, 0, nullptr, 0,\n     nullptr},\n    {\"replicate-wild-ignore-table\", OPT_REPLICATE_WILD_IGNORE_TABLE,\n     \"Tells the slave thread to not replicate to the tables that match the \"\n     \"given wildcard pattern. To specify more than one table to ignore, use \"\n     \"the directive multiple times, once for each table. This will work for \"\n     \"cross-database updates. Example: replicate-wild-ignore-table=foo%.bar% \"\n     \"will not do updates to tables in databases that start with foo and whose \"\n     \"table names start with bar.\",\n     nullptr, nullptr, nullptr, GET_STR, REQUIRED_ARG, 0, 0, 0, nullptr, 0,\n     nullptr},\n    {\"safe-user-create\", 0,\n     \"Don't allow new user creation by the user who has no write privileges to \"\n     \"the mysql.user table.\",\n     &opt_safe_user_create, &opt_safe_user_create, nullptr, GET_BOOL, NO_ARG, 0,\n     0, 0, nullptr, 0, nullptr},\n    {\"show-slave-auth-info\", 0,\n     \"Show user and password in SHOW SLAVE HOSTS on this master.\",\n     &opt_show_slave_auth_info, &opt_show_slave_auth_info, nullptr, GET_BOOL,\n     NO_ARG, 0, 0, 0, nullptr, 0, nullptr},\n    {\"skip-host-cache\", OPT_SKIP_HOST_CACHE, \"Don't cache host names.\", nullptr,\n     nullptr, nullptr, GET_NO_ARG, NO_ARG, 0, 0, 0, nullptr, 0, nullptr},\n    {\"skip-new\", OPT_SKIP_NEW, \"Don't use new, possibly wrong routines.\",\n     nullptr, nullptr, nullptr, GET_NO_ARG, NO_ARG, 0, 0, 0, nullptr, 0,\n     nullptr},\n    {\"skip-slave-start\", 0, \"If set, slave is not autostarted.\",\n     &opt_skip_slave_start, &opt_skip_slave_start, nullptr, GET_BOOL, NO_ARG, 0,\n     0, 0, nullptr, 0, nullptr},\n#if defined(_WIN32)\n    {\"slow-start-timeout\", 0,\n     \"Maximum number of milliseconds that the service control manager should \"\n     \"wait \"\n     \"before trying to kill the windows service during startup\"\n     \"(Default: 15000).\",\n     &slow_start_timeout, &slow_start_timeout, 0, GET_ULONG, REQUIRED_ARG,\n     15000, 0, 0, 0, 0, 0},\n#endif\n    {\"sporadic-binlog-dump-fail\", 0,\n     \"Option used by mysql-test for debugging and testing of replication.\",\n     &opt_sporadic_binlog_dump_fail, &opt_sporadic_binlog_dump_fail, nullptr,\n     GET_BOOL, NO_ARG, 0, 0, 0, nullptr, 0, nullptr},\n    {\"ssl\", 0,\n     \"Enable SSL for connection (automatically enabled with other flags).\",\n     &opt_use_ssl, &opt_use_ssl, nullptr, GET_BOOL, OPT_ARG, 1, 0, 0, nullptr,\n     0, nullptr},\n#ifdef _WIN32\n    {\"standalone\", 0, \"Dummy option to start as a standalone program (NT).\", 0,\n     0, 0, GET_NO_ARG, NO_ARG, 0, 0, 0, 0, 0, 0},\n    {\"no-monitor\", 0, \"Disable monitor process.\", &opt_no_monitor,\n     &opt_no_monitor, 0, GET_BOOL, NO_ARG, 0, 0, 0, 0, 0, 0},\n#endif\n    {\"symbolic-links\", 's',\n     \"Enable symbolic link support (deprecated and will be  removed in a future\"\n     \" release).\",\n     &my_enable_symlinks, &my_enable_symlinks, nullptr, GET_BOOL, NO_ARG, 0, 0,\n     0, nullptr, 0, nullptr},\n    {\"sysdate-is-now\", 0,\n     \"Non-default option to alias SYSDATE() to NOW() to make it \"\n     \"safe-replicable. \"\n     \"Since 5.0, SYSDATE() returns a `dynamic' value different for different \"\n     \"invocations, even within the same statement.\",\n     &global_system_variables.sysdate_is_now, nullptr, nullptr, GET_BOOL,\n     NO_ARG, 0, 0, 1, nullptr, 1, nullptr},\n    {\"tc-heuristic-recover\", 0,\n     \"Decision to use in heuristic recover process. Possible values are OFF, \"\n     \"COMMIT or ROLLBACK.\",\n     &tc_heuristic_recover, &tc_heuristic_recover,\n     &tc_heuristic_recover_typelib, GET_ENUM, REQUIRED_ARG,\n     TC_HEURISTIC_NOT_USED, 0, 0, nullptr, 0, nullptr},\n#if defined(ENABLED_DEBUG_SYNC)\n    {\"debug-sync-timeout\", OPT_DEBUG_SYNC_TIMEOUT,\n     \"Enable the debug sync facility \"\n     \"and optionally specify a default wait timeout in seconds. \"\n     \"A zero value keeps the facility disabled.\",\n     &opt_debug_sync_timeout, nullptr, nullptr, GET_UINT, OPT_ARG, 0, 0,\n     UINT_MAX, nullptr, 0, nullptr},\n#endif /* defined(ENABLED_DEBUG_SYNC) */\n    {\"transaction-isolation\", 0, \"Default transaction isolation level.\",\n     &global_system_variables.transaction_isolation,\n     &global_system_variables.transaction_isolation, &tx_isolation_typelib,\n     GET_ENUM, REQUIRED_ARG, ISO_REPEATABLE_READ, 0, 0, nullptr, 0, nullptr},\n    {\"transaction-read-only\", 0,\n     \"Default transaction access mode. \"\n     \"True if transactions are read-only.\",\n     &global_system_variables.transaction_read_only,\n     &global_system_variables.transaction_read_only, nullptr, GET_BOOL, OPT_ARG,\n     0, 0, 0, nullptr, 0, nullptr},\n    {\"user\", 'u', \"Run mysqld daemon as user.\", nullptr, nullptr, nullptr,\n     GET_STR, REQUIRED_ARG, 0, 0, 0, nullptr, 0, nullptr},\n    {\"early-plugin-load\", OPT_EARLY_PLUGIN_LOAD,\n     \"Optional semicolon-separated list of plugins to load before storage \"\n     \"engine \"\n     \"initialization, where each plugin is identified as name=library, where \"\n     \"name is the plugin name and library is the plugin library in plugin_dir.\",\n     nullptr, nullptr, nullptr, GET_STR, REQUIRED_ARG, 0, 0, 0, nullptr, 0,\n     nullptr},\n    {\"plugin-load\", OPT_PLUGIN_LOAD,\n     \"Optional semicolon-separated list of plugins to load, where each plugin \"\n     \"is \"\n     \"identified as name=library, where name is the plugin name and library \"\n     \"is the plugin library in plugin_dir.\",\n     nullptr, nullptr, nullptr, GET_STR, REQUIRED_ARG, 0, 0, 0, nullptr, 0,\n     nullptr},\n    {\"plugin-load-add\", OPT_PLUGIN_LOAD_ADD,\n     \"Optional semicolon-separated list of plugins to load, where each plugin \"\n     \"is \"\n     \"identified as name=library, where name is the plugin name and library \"\n     \"is the plugin library in plugin_dir. This option adds to the list \"\n     \"specified by --plugin-load in an incremental way. \"\n     \"Multiple --plugin-load-add are supported.\",\n     nullptr, nullptr, nullptr, GET_STR, REQUIRED_ARG, 0, 0, 0, nullptr, 0,\n     nullptr},\n\n    {\"innodb\", OPT_SKIP_INNODB,\n     \"Deprecated option. Provided for backward compatibility only. \"\n     \"The option has no effect on the server behaviour. InnoDB is always \"\n     \"enabled. \"\n     \"The option will be removed in a future release.\",\n     nullptr, nullptr, nullptr, GET_BOOL, OPT_ARG, 0, 0, 0, nullptr, 0,\n     nullptr},\n\n    {\"upgrade\", 0,\n     \"Set server upgrade mode. NONE to abort server if automatic upgrade of \"\n     \"the server is needed; MINIMAL to start the server, but skip upgrade \"\n     \"steps that are not absolutely necessary; AUTO (default) to upgrade the \"\n     \"server if required; FORCE to force upgrade server.\",\n     &opt_upgrade_mode, &opt_upgrade_mode, &upgrade_mode_typelib, GET_ENUM,\n     REQUIRED_ARG, UPGRADE_AUTO, 0, 0, nullptr, 0, nullptr},\n\n    {\"utility_user\", 0,\n     \"Specifies a MySQL user that will be added to the \"\n     \"internal list of users and recognized as the utility user.\",\n     &utility_user, 0, 0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n    {\"utility_user_password\", 0,\n     \"Specifies the password required for the \"\n     \"utility user.\",\n     &utility_user_password, 0, 0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n    {\"utility_user_privileges\", 0,\n     \"Specifies the privileges that the utility \"\n     \"user will have in a comma delimited list. See the manual for a complete \"\n     \"list of privileges.\",\n     &utility_user_privileges, 0, &utility_user_privileges_typelib, GET_SET,\n     REQUIRED_ARG, 0, 0, 0, 0, 0, 0},\n    {\"utility_user_dynamic_privileges\", 0,\n     \"Specifies the dynamic privileges that the utility \"\n     \"user will have in a comma delimited list. See the manual for a complete \"\n     \"list of privileges.\",\n     &utility_user_dynamic_privileges, 0, 0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0,\n     0, 0},\n    {\"utility_user_schema_access\", 0,\n     \"Specifies the schemas that the utility \"\n     \"user has access to in a comma delimited list.\",\n     &utility_user_schema_access, 0, 0, GET_STR, REQUIRED_ARG, 0, 0, 0, 0, 0,\n     0},\n\n    {nullptr, 0, nullptr, nullptr, nullptr, nullptr, GET_NO_ARG, NO_ARG, 0, 0,\n     0, nullptr, 0, nullptr}};\n\nstatic int show_queries(THD *thd, SHOW_VAR *var, char *) {\n  var->type = SHOW_LONGLONG;\n  var->value = (char *)&thd->query_id;\n  return 0;\n}\n\nstatic int show_net_compression(THD *thd, SHOW_VAR *var, char *buff) {\n  var->type = SHOW_MY_BOOL;\n  var->value = buff;\n  *((bool *)buff) = thd->get_protocol()->get_compression();\n  return 0;\n}\n\nstatic int show_net_compression_algorithm(THD *thd, SHOW_VAR *var, char *buff) {\n  const char *s = thd->get_protocol()->get_compression_algorithm();\n  var->type = SHOW_CHAR;\n  var->value = buff;\n  sprintf(buff, \"%s\", (s ? s : \"\"));\n  return 0;\n}\n\nstatic int show_net_compression_level(THD *thd, SHOW_VAR *var, char *buff) {\n  var->type = SHOW_INT;\n  var->value = buff;\n  unsigned int *value = reinterpret_cast<unsigned int *>(buff);\n  *value = thd->get_protocol()->get_compression_level();\n  return 0;\n}\n\nstatic int show_starttime(THD *thd, SHOW_VAR *var, char *buff) {\n  var->type = SHOW_LONGLONG;\n  var->value = buff;\n  *((longlong *)buff) =\n      (longlong)(thd->query_start_in_secs() - server_start_time);\n  return 0;\n}\n\nstatic int show_max_used_connections_time(THD *thd, SHOW_VAR *var, char *buff) {\n  MYSQL_TIME max_used_connections_time;\n  var->type = SHOW_CHAR;\n  var->value = buff;\n  thd->variables.time_zone->gmt_sec_to_TIME(\n      &max_used_connections_time,\n      Connection_handler_manager::max_used_connections_time);\n  my_datetime_to_str(max_used_connections_time, buff, 0);\n  return 0;\n}\n\nstatic int show_num_thread_running(THD *, SHOW_VAR *var, char *buff) {\n  var->type = SHOW_LONGLONG;\n  var->value = buff;\n  long long *value = reinterpret_cast<long long *>(buff);\n  *value = static_cast<long long>(\n      Global_THD_manager::get_instance()->get_num_thread_running());\n  return 0;\n}\n\nstatic int show_num_thread_created(THD *, SHOW_VAR *var, char *buff) {\n  var->type = SHOW_LONG;\n  var->value = buff;\n  long *value = reinterpret_cast<long *>(buff);\n  *value = static_cast<long>(\n      Global_THD_manager::get_instance()->get_num_thread_created());\n  return 0;\n}\n\nstatic int show_thread_id_count(THD *, SHOW_VAR *var, char *buff) {\n  var->type = SHOW_LONG;\n  var->value = buff;\n  long *value = reinterpret_cast<long *>(buff);\n  *value = static_cast<long>(\n      Global_THD_manager::get_instance()->get_thread_id() - 1);\n  return 0;\n}\n\nstatic int show_aborted_connects(THD *, SHOW_VAR *var, char *buff) {\n  var->type = SHOW_LONG;\n  var->value = buff;\n  long *value = reinterpret_cast<long *>(buff);\n  *value = static_cast<long>(\n      Connection_handler_manager::get_instance()->aborted_connects());\n  return 0;\n}\n\nstatic int show_acl_cache_items_count(THD *, SHOW_VAR *var, char *buff) {\n  var->type = SHOW_LONG;\n  var->value = buff;\n  long *value = reinterpret_cast<long *>(buff);\n  *value = static_cast<long>(get_global_acl_cache_size());\n  return 0;\n}\n\nstatic int show_connection_errors_max_connection(THD *, SHOW_VAR *var,\n                                                 char *buff) {\n  var->type = SHOW_LONG;\n  var->value = buff;\n  long *value = reinterpret_cast<long *>(buff);\n  *value = static_cast<long>(Connection_handler_manager::get_instance()\n                                 ->connection_errors_max_connection());\n  return 0;\n}\n\nstatic int show_connection_errors_select(THD *, SHOW_VAR *var, char *buff) {\n  var->type = SHOW_LONG;\n  var->value = buff;\n  long *value = reinterpret_cast<long *>(buff);\n  *value = static_cast<long>(get_connection_errors_select());\n  return 0;\n}\n\nstatic int show_connection_errors_accept(THD *, SHOW_VAR *var, char *buff) {\n  var->type = SHOW_LONG;\n  var->value = buff;\n  long *value = reinterpret_cast<long *>(buff);\n  *value = static_cast<long>(get_connection_errors_accept());\n  return 0;\n}\n\nstatic int show_connection_errors_tcpwrap(THD *, SHOW_VAR *var, char *buff) {\n  var->type = SHOW_LONG;\n  var->value = buff;\n  long *value = reinterpret_cast<long *>(buff);\n  *value = static_cast<long>(get_connection_errors_tcpwrap());\n  return 0;\n}\n\n#ifdef ENABLED_PROFILING\nstatic int show_flushstatustime(THD *thd, SHOW_VAR *var, char *buff) {\n  var->type = SHOW_LONGLONG;\n  var->value = buff;\n  *((longlong *)buff) =\n      (longlong)(thd->query_start_in_secs() - flush_status_time);\n  return 0;\n}\n#endif\n\n/**\n  After Multisource replication, this function only shows the value\n  of default channel.\n\n  To know the status of other channels, performance schema replication\n  tables comes to the rescue.\n\n  @todo  Any warning needed if multiple channels exist to request\n         the users to start using replication performance schema\n         tables.\n*/\nstatic int show_slave_running(THD *, SHOW_VAR *var, char *buff) {\n  channel_map.rdlock();\n  Master_info *mi = channel_map.get_default_channel_mi();\n\n  if (mi) {\n    var->type = SHOW_MY_BOOL;\n    var->value = buff;\n    *((bool *)buff) =\n        (bool)(mi && mi->slave_running == MYSQL_SLAVE_RUN_CONNECT &&\n               mi->rli->slave_running);\n  } else\n    var->type = SHOW_UNDEF;\n\n  channel_map.unlock();\n  return 0;\n}\n\n/**\n  This status variable is also exclusively (look comments on\n  show_slave_running()) for default channel.\n*/\nstatic int show_slave_retried_trans(THD *, SHOW_VAR *var, char *buff) {\n  channel_map.rdlock();\n  Master_info *mi = channel_map.get_default_channel_mi();\n\n  if (mi) {\n    var->type = SHOW_LONG;\n    var->value = buff;\n    *((long *)buff) = (long)mi->rli->retried_trans;\n  } else\n    var->type = SHOW_UNDEF;\n\n  channel_map.unlock();\n  return 0;\n}\n\n/**\n  Only for default channel. Refer to comments on show_slave_running()\n*/\nstatic int show_slave_received_heartbeats(THD *, SHOW_VAR *var, char *buff) {\n  channel_map.rdlock();\n  Master_info *mi = channel_map.get_default_channel_mi();\n\n  if (mi) {\n    var->type = SHOW_LONGLONG;\n    var->value = buff;\n    *((longlong *)buff) = mi->received_heartbeats;\n  } else\n    var->type = SHOW_UNDEF;\n\n  channel_map.unlock();\n  return 0;\n}\n\n/**\n  Only for default channel. Refer to comments on show_slave_running()\n*/\nstatic int show_slave_last_heartbeat(THD *thd, SHOW_VAR *var, char *buff) {\n  MYSQL_TIME received_heartbeat_time;\n\n  channel_map.rdlock();\n  Master_info *mi = channel_map.get_default_channel_mi();\n\n  if (mi) {\n    var->type = SHOW_CHAR;\n    var->value = buff;\n    if (mi->last_heartbeat == 0)\n      buff[0] = '\\0';\n    else {\n      thd->variables.time_zone->gmt_sec_to_TIME(\n          &received_heartbeat_time,\n          static_cast<my_time_t>(mi->last_heartbeat / 1000000));\n      my_datetime_to_str(received_heartbeat_time, buff, 0);\n    }\n  } else\n    var->type = SHOW_UNDEF;\n\n  channel_map.unlock();\n  return 0;\n}\n\n/**\n  Only for default channel. For details, refer to show_slave_running()\n*/\nstatic int show_heartbeat_period(THD *, SHOW_VAR *var, char *buff) {\n  channel_map.rdlock();\n  Master_info *mi = channel_map.get_default_channel_mi();\n\n  if (mi) {\n    var->type = SHOW_CHAR;\n    var->value = buff;\n    sprintf(buff, \"%.3f\", mi->heartbeat_period);\n  } else\n    var->type = SHOW_UNDEF;\n\n  channel_map.unlock();\n  return 0;\n}\n\n#ifndef DBUG_OFF\nstatic int show_slave_rows_last_search_algorithm_used(THD *, SHOW_VAR *var,\n                                                      char *buff) {\n  uint res = slave_rows_last_search_algorithm_used;\n  const char *s =\n      ((res == Rows_log_event::ROW_LOOKUP_TABLE_SCAN)\n           ? \"TABLE_SCAN\"\n           : ((res == Rows_log_event::ROW_LOOKUP_HASH_SCAN) ? \"HASH_SCAN\"\n                                                            : \"INDEX_SCAN\"));\n\n  var->type = SHOW_CHAR;\n  var->value = buff;\n  sprintf(buff, \"%s\", s);\n\n  return 0;\n}\n\nstatic int show_ongoing_automatic_gtid_violating_transaction_count(\n    THD *, SHOW_VAR *var, char *buf) {\n  var->type = SHOW_CHAR;\n  var->value = buf;\n  sprintf(buf, \"%d\",\n          gtid_state->get_automatic_gtid_violating_transaction_count());\n  return 0;\n}\n\nstatic int show_ongoing_anonymous_gtid_violating_transaction_count(\n    THD *, SHOW_VAR *var, char *buf) {\n  var->type = SHOW_CHAR;\n  var->value = buf;\n  sprintf(buf, \"%d\",\n          gtid_state->get_anonymous_gtid_violating_transaction_count());\n  return 0;\n}\n\n#endif\n\nstatic int show_ongoing_anonymous_transaction_count(THD *, SHOW_VAR *var,\n                                                    char *buf) {\n  var->type = SHOW_CHAR;\n  var->value = buf;\n  sprintf(buf, \"%d\", gtid_state->get_anonymous_ownership_count());\n  return 0;\n}\n\nstatic int show_open_tables(THD *, SHOW_VAR *var, char *buff) {\n  var->type = SHOW_LONG;\n  var->value = buff;\n  *((long *)buff) = (long)table_cache_manager.cached_tables();\n  return 0;\n}\n\nstatic int show_prepared_stmt_count(THD *, SHOW_VAR *var, char *buff) {\n  var->type = SHOW_LONG;\n  var->value = buff;\n  mysql_mutex_lock(&LOCK_prepared_stmt_count);\n  *((long *)buff) = (long)prepared_stmt_count;\n  mysql_mutex_unlock(&LOCK_prepared_stmt_count);\n  return 0;\n}\n\nstatic int show_table_definitions(THD *, SHOW_VAR *var, char *buff) {\n  var->type = SHOW_LONG;\n  var->value = buff;\n  *((long *)buff) = (long)cached_table_definitions();\n  return 0;\n}\n\n/*\n   Functions relying on SSL\n   Note: In the show_ssl_* functions, we need to check if we have a\n         valid vio-object since this isn't always true, specifically\n         when session_status or global_status is requested from\n         inside an Event.\n */\nstatic int show_ssl_get_version(THD *thd, SHOW_VAR *var, char *) {\n  SSL_handle ssl = thd->get_ssl();\n  var->type = SHOW_CHAR;\n  if (ssl)\n    var->value = const_cast<char *>(SSL_get_version(ssl));\n  else\n    var->value = const_cast<char *>(\"\");\n  return 0;\n}\n\nstatic int show_ssl_session_reused(THD *thd, SHOW_VAR *var, char *buff) {\n  SSL_handle ssl = thd->get_ssl();\n  var->type = SHOW_LONG;\n  var->value = buff;\n  if (ssl)\n    *((long *)buff) = (long)SSL_session_reused(ssl);\n  else\n    *((long *)buff) = 0;\n  return 0;\n}\n\nstatic int show_ssl_get_default_timeout(THD *thd, SHOW_VAR *var, char *buff) {\n  SSL_handle ssl = thd->get_ssl();\n  var->type = SHOW_LONG;\n  var->value = buff;\n  if (ssl)\n    *((long *)buff) = (long)SSL_get_default_timeout(ssl);\n  else\n    *((long *)buff) = 0;\n  return 0;\n}\n\nstatic int show_ssl_get_verify_mode(THD *thd, SHOW_VAR *var, char *buff) {\n  SSL_handle ssl = thd->get_ssl();\n  var->type = SHOW_LONG;\n  var->value = buff;\n  if (ssl)\n    *((long *)buff) = (long)SSL_get_verify_mode(ssl);\n  else\n    *((long *)buff) = 0;\n  return 0;\n}\n\nstatic int show_ssl_get_verify_depth(THD *thd, SHOW_VAR *var, char *buff) {\n  SSL_handle ssl = thd->get_ssl();\n  var->type = SHOW_LONG;\n  var->value = buff;\n  if (ssl)\n    *((long *)buff) = (long)SSL_get_verify_depth(ssl);\n  else\n    *((long *)buff) = 0;\n  return 0;\n}\n\nstatic int show_ssl_get_cipher(THD *thd, SHOW_VAR *var, char *) {\n  SSL_handle ssl = thd->get_ssl();\n  var->type = SHOW_CHAR;\n  if (ssl)\n    var->value = const_cast<char *>(SSL_get_cipher(ssl));\n  else\n    var->value = const_cast<char *>(\"\");\n  return 0;\n}\n\nstatic int show_ssl_get_cipher_list(THD *thd, SHOW_VAR *var, char *buff) {\n  SSL_handle ssl = thd->get_ssl();\n  var->type = SHOW_CHAR;\n  var->value = buff;\n  if (ssl) {\n    int i;\n    const char *p;\n    char *end = buff + SHOW_VAR_FUNC_BUFF_SIZE;\n    for (i = 0; (p = SSL_get_cipher_list(ssl, i)) && buff < end; i++) {\n      buff = my_stpnmov(buff, p, end - buff - 1);\n      *buff++ = ':';\n    }\n    if (i) buff--;\n  }\n  *buff = 0;\n  return 0;\n}\n\n#ifdef HAVE_POOL_OF_THREADS\nstatic int show_threadpool_idle_threads(THD *thd MY_ATTRIBUTE((unused)),\n                                        SHOW_VAR *var, char *buff) {\n  var->type = SHOW_INT;\n  var->value = buff;\n  *(int *)buff = tp_get_idle_thread_count();\n  return 0;\n}\n#endif\n\nstatic int show_slave_open_temp_tables(THD *, SHOW_VAR *var, char *buf) {\n  var->type = SHOW_INT;\n  var->value = buf;\n  *((int *)buf) = atomic_slave_open_temp_tables;\n  return 0;\n}\n\n/*\n  Variables shown by SHOW STATUS in alphabetical order\n*/\n\nSHOW_VAR status_vars[] = {\n    {\"Aborted_clients\", (char *)&aborted_threads, SHOW_LONG, SHOW_SCOPE_GLOBAL},\n    {\"Aborted_connects\", (char *)&show_aborted_connects, SHOW_FUNC,\n     SHOW_SCOPE_GLOBAL},\n    {\"Acl_cache_items_count\", (char *)&show_acl_cache_items_count, SHOW_FUNC,\n     SHOW_SCOPE_GLOBAL},\n#ifndef DBUG_OFF\n    {\"Ongoing_anonymous_gtid_violating_transaction_count\",\n     (char *)&show_ongoing_anonymous_gtid_violating_transaction_count,\n     SHOW_FUNC, SHOW_SCOPE_GLOBAL},\n#endif  //! DBUG_OFF\n    {\"Ongoing_anonymous_transaction_count\",\n     (char *)&show_ongoing_anonymous_transaction_count, SHOW_FUNC,\n     SHOW_SCOPE_GLOBAL},\n#ifndef DBUG_OFF\n    {\"Ongoing_automatic_gtid_violating_transaction_count\",\n     (char *)&show_ongoing_automatic_gtid_violating_transaction_count,\n     SHOW_FUNC, SHOW_SCOPE_GLOBAL},\n#endif  //! DBUG_OFF\n    {\"Binlog_cache_disk_use\", (char *)&binlog_cache_disk_use, SHOW_LONG,\n     SHOW_SCOPE_GLOBAL},\n    {\"Binlog_cache_use\", (char *)&binlog_cache_use, SHOW_LONG,\n     SHOW_SCOPE_GLOBAL},\n    {\"Binlog_stmt_cache_disk_use\", (char *)&binlog_stmt_cache_disk_use,\n     SHOW_LONG, SHOW_SCOPE_GLOBAL},\n    {\"Binlog_stmt_cache_use\", (char *)&binlog_stmt_cache_use, SHOW_LONG,\n     SHOW_SCOPE_GLOBAL},\n    {\"Bytes_received\", (char *)offsetof(System_status_var, bytes_received),\n     SHOW_LONGLONG_STATUS, SHOW_SCOPE_ALL},\n    {\"Bytes_sent\", (char *)offsetof(System_status_var, bytes_sent),\n     SHOW_LONGLONG_STATUS, SHOW_SCOPE_ALL},\n    {\"Com\", (char *)com_status_vars, SHOW_ARRAY, SHOW_SCOPE_ALL},\n    {\"Com_stmt_reprepare\",\n     (char *)offsetof(System_status_var, com_stmt_reprepare), SHOW_LONG_STATUS,\n     SHOW_SCOPE_ALL},\n    {\"Compression\", (char *)&show_net_compression, SHOW_FUNC,\n     SHOW_SCOPE_SESSION},\n    {\"Compression_algorithm\", (char *)&show_net_compression_algorithm,\n     SHOW_FUNC, SHOW_SCOPE_SESSION},\n    {\"Compression_level\", (char *)&show_net_compression_level, SHOW_FUNC,\n     SHOW_SCOPE_SESSION},\n    {\"Connections\", (char *)&show_thread_id_count, SHOW_FUNC,\n     SHOW_SCOPE_GLOBAL},\n    {\"Connection_errors_accept\", (char *)&show_connection_errors_accept,\n     SHOW_FUNC, SHOW_SCOPE_GLOBAL},\n    {\"Connection_errors_internal\", (char *)&connection_errors_internal,\n     SHOW_LONG, SHOW_SCOPE_GLOBAL},\n    {\"Connection_errors_max_connections\",\n     (char *)&show_connection_errors_max_connection, SHOW_FUNC,\n     SHOW_SCOPE_GLOBAL},\n    {\"Connection_errors_peer_address\", (char *)&connection_errors_peer_addr,\n     SHOW_LONG, SHOW_SCOPE_GLOBAL},\n    {\"Connection_errors_select\", (char *)&show_connection_errors_select,\n     SHOW_FUNC, SHOW_SCOPE_GLOBAL},\n    {\"Connection_errors_tcpwrap\", (char *)&show_connection_errors_tcpwrap,\n     SHOW_FUNC, SHOW_SCOPE_GLOBAL},\n    {\"Created_tmp_disk_tables\",\n     (char *)offsetof(System_status_var, created_tmp_disk_tables),\n     SHOW_LONGLONG_STATUS, SHOW_SCOPE_ALL},\n    {\"Created_tmp_files\", (char *)&my_tmp_file_created, SHOW_LONG,\n     SHOW_SCOPE_GLOBAL},\n    {\"Created_tmp_tables\",\n     (char *)offsetof(System_status_var, created_tmp_tables),\n     SHOW_LONGLONG_STATUS, SHOW_SCOPE_ALL},\n    {\"Delayed_errors\", (char *)&delayed_insert_errors, SHOW_LONG,\n     SHOW_SCOPE_GLOBAL},\n    {\"Delayed_insert_threads\", (char *)&delayed_insert_threads,\n     SHOW_LONG_NOFLUSH, SHOW_SCOPE_GLOBAL},\n    {\"Delayed_writes\", (char *)&delayed_insert_writes, SHOW_LONG,\n     SHOW_SCOPE_GLOBAL},\n    {\"Flush_commands\", (char *)&refresh_version, SHOW_LONG_NOFLUSH,\n     SHOW_SCOPE_GLOBAL},\n    {\"Handler_commit\", (char *)offsetof(System_status_var, ha_commit_count),\n     SHOW_LONGLONG_STATUS, SHOW_SCOPE_ALL},\n    {\"Handler_delete\", (char *)offsetof(System_status_var, ha_delete_count),\n     SHOW_LONGLONG_STATUS, SHOW_SCOPE_ALL},\n    {\"Handler_discover\", (char *)offsetof(System_status_var, ha_discover_count),\n     SHOW_LONGLONG_STATUS, SHOW_SCOPE_ALL},\n    {\"Handler_external_lock\",\n     (char *)offsetof(System_status_var, ha_external_lock_count),\n     SHOW_LONGLONG_STATUS, SHOW_SCOPE_ALL},\n    {\"Handler_mrr_init\",\n     (char *)offsetof(System_status_var, ha_multi_range_read_init_count),\n     SHOW_LONGLONG_STATUS, SHOW_SCOPE_ALL},\n    {\"Handler_prepare\", (char *)offsetof(System_status_var, ha_prepare_count),\n     SHOW_LONGLONG_STATUS, SHOW_SCOPE_ALL},\n    {\"Handler_read_first\",\n     (char *)offsetof(System_status_var, ha_read_first_count),\n     SHOW_LONGLONG_STATUS, SHOW_SCOPE_ALL},\n    {\"Handler_read_key\", (char *)offsetof(System_status_var, ha_read_key_count),\n     SHOW_LONGLONG_STATUS, SHOW_SCOPE_ALL},\n    {\"Handler_read_last\",\n     (char *)offsetof(System_status_var, ha_read_last_count),\n     SHOW_LONGLONG_STATUS, SHOW_SCOPE_ALL},\n    {\"Handler_read_next\",\n     (char *)offsetof(System_status_var, ha_read_next_count),\n     SHOW_LONGLONG_STATUS, SHOW_SCOPE_ALL},\n    {\"Handler_read_prev\",\n     (char *)offsetof(System_status_var, ha_read_prev_count),\n     SHOW_LONGLONG_STATUS, SHOW_SCOPE_ALL},\n    {\"Handler_read_rnd\", (char *)offsetof(System_status_var, ha_read_rnd_count),\n     SHOW_LONGLONG_STATUS, SHOW_SCOPE_ALL},\n    {\"Handler_read_rnd_next\",\n     (char *)offsetof(System_status_var, ha_read_rnd_next_count),\n     SHOW_LONGLONG_STATUS, SHOW_SCOPE_ALL},\n    {\"Handler_rollback\", (char *)offsetof(System_status_var, ha_rollback_count),\n     SHOW_LONGLONG_STATUS, SHOW_SCOPE_ALL},\n    {\"Handler_savepoint\",\n     (char *)offsetof(System_status_var, ha_savepoint_count),\n     SHOW_LONGLONG_STATUS, SHOW_SCOPE_ALL},\n    {\"Handler_savepoint_rollback\",\n     (char *)offsetof(System_status_var, ha_savepoint_rollback_count),\n     SHOW_LONGLONG_STATUS, SHOW_SCOPE_ALL},\n    {\"Handler_update\", (char *)offsetof(System_status_var, ha_update_count),\n     SHOW_LONGLONG_STATUS, SHOW_SCOPE_ALL},\n    {\"Handler_write\", (char *)offsetof(System_status_var, ha_write_count),\n     SHOW_LONGLONG_STATUS, SHOW_SCOPE_ALL},\n    {\"Key_blocks_not_flushed\",\n     (char *)offsetof(KEY_CACHE, global_blocks_changed), SHOW_KEY_CACHE_LONG,\n     SHOW_SCOPE_GLOBAL},\n    {\"Key_blocks_unused\", (char *)offsetof(KEY_CACHE, blocks_unused),\n     SHOW_KEY_CACHE_LONG, SHOW_SCOPE_GLOBAL},\n    {\"Key_blocks_used\", (char *)offsetof(KEY_CACHE, blocks_used),\n     SHOW_KEY_CACHE_LONG, SHOW_SCOPE_GLOBAL},\n    {\"Key_read_requests\", (char *)offsetof(KEY_CACHE, global_cache_r_requests),\n     SHOW_KEY_CACHE_LONGLONG, SHOW_SCOPE_GLOBAL},\n    {\"Key_reads\", (char *)offsetof(KEY_CACHE, global_cache_read),\n     SHOW_KEY_CACHE_LONGLONG, SHOW_SCOPE_GLOBAL},\n    {\"Key_write_requests\", (char *)offsetof(KEY_CACHE, global_cache_w_requests),\n     SHOW_KEY_CACHE_LONGLONG, SHOW_SCOPE_GLOBAL},\n    {\"Key_writes\", (char *)offsetof(KEY_CACHE, global_cache_write),\n     SHOW_KEY_CACHE_LONGLONG, SHOW_SCOPE_GLOBAL},\n    {\"Last_query_cost\", (char *)offsetof(System_status_var, last_query_cost),\n     SHOW_DOUBLE_STATUS, SHOW_SCOPE_SESSION},\n    {\"Last_query_partial_plans\",\n     (char *)offsetof(System_status_var, last_query_partial_plans),\n     SHOW_LONGLONG_STATUS, SHOW_SCOPE_SESSION},\n    {\"Locked_connects\", (char *)&locked_account_connection_count, SHOW_LONG,\n     SHOW_SCOPE_GLOBAL},\n    {\"Max_execution_time_exceeded\",\n     (char *)offsetof(System_status_var, max_execution_time_exceeded),\n     SHOW_LONGLONG_STATUS, SHOW_SCOPE_ALL},\n    {\"Max_execution_time_set\",\n     (char *)offsetof(System_status_var, max_execution_time_set),\n     SHOW_LONGLONG_STATUS, SHOW_SCOPE_ALL},\n    {\"Max_execution_time_set_failed\",\n     (char *)offsetof(System_status_var, max_execution_time_set_failed),\n     SHOW_LONGLONG_STATUS, SHOW_SCOPE_ALL},\n    {\"Max_used_connections\",\n     (char *)&Connection_handler_manager::max_used_connections, SHOW_LONG,\n     SHOW_SCOPE_GLOBAL},\n    {\"Max_used_connections_time\", (char *)&show_max_used_connections_time,\n     SHOW_FUNC, SHOW_SCOPE_GLOBAL},\n    {\"Not_flushed_delayed_rows\", (char *)&delayed_rows_in_use,\n     SHOW_LONG_NOFLUSH, SHOW_SCOPE_GLOBAL},\n    {\"Open_files\", (char *)&my_file_opened, SHOW_LONG_NOFLUSH,\n     SHOW_SCOPE_GLOBAL},\n    {\"Open_streams\", (char *)&my_stream_opened, SHOW_LONG_NOFLUSH,\n     SHOW_SCOPE_GLOBAL},\n    {\"Open_table_definitions\", (char *)&show_table_definitions, SHOW_FUNC,\n     SHOW_SCOPE_GLOBAL},\n    {\"Open_tables\", (char *)&show_open_tables, SHOW_FUNC, SHOW_SCOPE_ALL},\n    {\"Opened_files\",\n     const_cast<char *>(reinterpret_cast<const char *>(&my_file_total_opened)),\n     SHOW_LONG_NOFLUSH, SHOW_SCOPE_GLOBAL},\n    {\"Opened_tables\", (char *)offsetof(System_status_var, opened_tables),\n     SHOW_LONGLONG_STATUS, SHOW_SCOPE_ALL},\n    {\"Opened_table_definitions\",\n     (char *)offsetof(System_status_var, opened_shares), SHOW_LONGLONG_STATUS,\n     SHOW_SCOPE_ALL},\n    {\"Prepared_stmt_count\", (char *)&show_prepared_stmt_count, SHOW_FUNC,\n     SHOW_SCOPE_GLOBAL},\n    {\"Queries\", (char *)&show_queries, SHOW_FUNC, SHOW_SCOPE_ALL},\n    {\"Questions\", (char *)offsetof(System_status_var, questions),\n     SHOW_LONGLONG_STATUS, SHOW_SCOPE_ALL},\n    {\"Secondary_engine_execution_count\",\n     (char *)offsetof(System_status_var, secondary_engine_execution_count),\n     SHOW_LONGLONG_STATUS, SHOW_SCOPE_ALL},\n    {\"Select_full_join\",\n     (char *)offsetof(System_status_var, select_full_join_count),\n     SHOW_LONGLONG_STATUS, SHOW_SCOPE_ALL},\n    {\"Select_full_range_join\",\n     (char *)offsetof(System_status_var, select_full_range_join_count),\n     SHOW_LONGLONG_STATUS, SHOW_SCOPE_ALL},\n    {\"Select_range\", (char *)offsetof(System_status_var, select_range_count),\n     SHOW_LONGLONG_STATUS, SHOW_SCOPE_ALL},\n    {\"Select_range_check\",\n     (char *)offsetof(System_status_var, select_range_check_count),\n     SHOW_LONGLONG_STATUS, SHOW_SCOPE_ALL},\n    {\"Select_scan\", (char *)offsetof(System_status_var, select_scan_count),\n     SHOW_LONGLONG_STATUS, SHOW_SCOPE_ALL},\n    {\"Slave_open_temp_tables\", (char *)&show_slave_open_temp_tables, SHOW_FUNC,\n     SHOW_SCOPE_GLOBAL},\n    {\"Slave_retried_transactions\", (char *)&show_slave_retried_trans, SHOW_FUNC,\n     SHOW_SCOPE_GLOBAL},\n    {\"Slave_heartbeat_period\", (char *)&show_heartbeat_period, SHOW_FUNC,\n     SHOW_SCOPE_GLOBAL},\n    {\"Slave_received_heartbeats\", (char *)&show_slave_received_heartbeats,\n     SHOW_FUNC, SHOW_SCOPE_GLOBAL},\n    {\"Slave_last_heartbeat\", (char *)&show_slave_last_heartbeat, SHOW_FUNC,\n     SHOW_SCOPE_GLOBAL},\n#ifndef DBUG_OFF\n    {\"Slave_rows_last_search_algorithm_used\",\n     (char *)&show_slave_rows_last_search_algorithm_used, SHOW_FUNC,\n     SHOW_SCOPE_GLOBAL},\n#endif\n    {\"Slave_running\", (char *)&show_slave_running, SHOW_FUNC,\n     SHOW_SCOPE_GLOBAL},\n    {\"Slow_launch_threads\",\n     (char *)&Per_thread_connection_handler::slow_launch_threads, SHOW_LONG,\n     SHOW_SCOPE_ALL},\n    {\"Slow_queries\", (char *)offsetof(System_status_var, long_query_count),\n     SHOW_LONGLONG_STATUS, SHOW_SCOPE_ALL},\n    {\"Sort_merge_passes\",\n     (char *)offsetof(System_status_var, filesort_merge_passes),\n     SHOW_LONGLONG_STATUS, SHOW_SCOPE_ALL},\n    {\"Sort_range\", (char *)offsetof(System_status_var, filesort_range_count),\n     SHOW_LONGLONG_STATUS, SHOW_SCOPE_ALL},\n    {\"Sort_rows\", (char *)offsetof(System_status_var, filesort_rows),\n     SHOW_LONGLONG_STATUS, SHOW_SCOPE_ALL},\n    {\"Sort_scan\", (char *)offsetof(System_status_var, filesort_scan_count),\n     SHOW_LONGLONG_STATUS, SHOW_SCOPE_ALL},\n    {\"Ssl_accept_renegotiates\",\n     (char *)&SslAcceptorContext::show_ssl_ctx_sess_accept_renegotiate,\n     SHOW_FUNC, SHOW_SCOPE_GLOBAL},\n    {\"Ssl_accepts\", (char *)&SslAcceptorContext::show_ssl_ctx_sess_accept,\n     SHOW_FUNC, SHOW_SCOPE_GLOBAL},\n    {\"Ssl_callback_cache_hits\",\n     (char *)&SslAcceptorContext::show_ssl_ctx_sess_cb_hits, SHOW_FUNC,\n     SHOW_SCOPE_GLOBAL},\n    {\"Ssl_cipher\", (char *)&show_ssl_get_cipher, SHOW_FUNC, SHOW_SCOPE_ALL},\n    {\"Ssl_cipher_list\", (char *)&show_ssl_get_cipher_list, SHOW_FUNC,\n     SHOW_SCOPE_ALL},\n    {\"Ssl_client_connects\",\n     (char *)&SslAcceptorContext::show_ssl_ctx_sess_connect, SHOW_FUNC,\n     SHOW_SCOPE_GLOBAL},\n    {\"Ssl_connect_renegotiates\",\n     (char *)&SslAcceptorContext::show_ssl_ctx_sess_connect_renegotiate,\n     SHOW_FUNC, SHOW_SCOPE_GLOBAL},\n    {\"Ssl_ctx_verify_depth\",\n     (char *)&SslAcceptorContext::show_ssl_ctx_get_verify_depth, SHOW_FUNC,\n     SHOW_SCOPE_GLOBAL},\n    {\"Ssl_ctx_verify_mode\",\n     (char *)&SslAcceptorContext::show_ssl_ctx_get_verify_mode, SHOW_FUNC,\n     SHOW_SCOPE_GLOBAL},\n    {\"Ssl_default_timeout\", (char *)&show_ssl_get_default_timeout, SHOW_FUNC,\n     SHOW_SCOPE_ALL},\n    {\"Ssl_finished_accepts\",\n     (char *)&SslAcceptorContext::show_ssl_ctx_sess_accept_good, SHOW_FUNC,\n     SHOW_SCOPE_GLOBAL},\n    {\"Ssl_finished_connects\",\n     (char *)&SslAcceptorContext::show_ssl_ctx_sess_connect_good, SHOW_FUNC,\n     SHOW_SCOPE_GLOBAL},\n    {\"Ssl_session_cache_hits\",\n     (char *)&SslAcceptorContext::show_ssl_ctx_sess_hits, SHOW_FUNC,\n     SHOW_SCOPE_GLOBAL},\n    {\"Ssl_session_cache_misses\",\n     (char *)&SslAcceptorContext::show_ssl_ctx_sess_misses, SHOW_FUNC,\n     SHOW_SCOPE_GLOBAL},\n    {\"Ssl_session_cache_mode\",\n     (char *)&SslAcceptorContext::show_ssl_ctx_get_session_cache_mode,\n     SHOW_FUNC, SHOW_SCOPE_GLOBAL},\n    {\"Ssl_session_cache_overflows\",\n     (char *)&SslAcceptorContext::show_ssl_ctx_sess_cache_full, SHOW_FUNC,\n     SHOW_SCOPE_GLOBAL},\n    {\"Ssl_session_cache_size\",\n     (char *)&SslAcceptorContext::show_ssl_ctx_sess_get_cache_size, SHOW_FUNC,\n     SHOW_SCOPE_GLOBAL},\n    {\"Ssl_session_cache_timeouts\",\n     (char *)&SslAcceptorContext::show_ssl_ctx_sess_timeouts, SHOW_FUNC,\n     SHOW_SCOPE_GLOBAL},\n    {\"Ssl_sessions_reused\", (char *)&show_ssl_session_reused, SHOW_FUNC,\n     SHOW_SCOPE_ALL},\n    {\"Ssl_used_session_cache_entries\",\n     (char *)&SslAcceptorContext::show_ssl_ctx_sess_number, SHOW_FUNC,\n     SHOW_SCOPE_GLOBAL},\n    {\"Ssl_verify_depth\", (char *)&show_ssl_get_verify_depth, SHOW_FUNC,\n     SHOW_SCOPE_ALL},\n    {\"Ssl_verify_mode\", (char *)&show_ssl_get_verify_mode, SHOW_FUNC,\n     SHOW_SCOPE_ALL},\n    {\"Ssl_version\", (char *)&show_ssl_get_version, SHOW_FUNC, SHOW_SCOPE_ALL},\n    {\"Ssl_server_not_before\",\n     (char *)&SslAcceptorContext::show_ssl_get_server_not_before, SHOW_FUNC,\n     SHOW_SCOPE_ALL},\n    {\"Ssl_server_not_after\",\n     (char *)&SslAcceptorContext::show_ssl_get_server_not_after, SHOW_FUNC,\n     SHOW_SCOPE_ALL},\n    {\"Current_tls_ca\", (char *)&SslAcceptorContext::show_ssl_get_ssl_ca,\n     SHOW_FUNC, SHOW_SCOPE_GLOBAL},\n    {\"Current_tls_capath\", (char *)&SslAcceptorContext::show_ssl_get_ssl_capath,\n     SHOW_FUNC, SHOW_SCOPE_GLOBAL},\n    {\"Current_tls_cert\", (char *)&SslAcceptorContext::show_ssl_get_ssl_cert,\n     SHOW_FUNC, SHOW_SCOPE_GLOBAL},\n    {\"Current_tls_key\", (char *)&SslAcceptorContext::show_ssl_get_ssl_key,\n     SHOW_FUNC, SHOW_SCOPE_GLOBAL},\n    {\"Current_tls_version\",\n     (char *)&SslAcceptorContext::show_ssl_get_tls_version, SHOW_FUNC,\n     SHOW_SCOPE_GLOBAL},\n    {\"Current_tls_cipher\", (char *)&SslAcceptorContext::show_ssl_get_ssl_cipher,\n     SHOW_FUNC, SHOW_SCOPE_GLOBAL},\n    {\"Current_tls_ciphersuites\",\n     (char *)&SslAcceptorContext::show_ssl_get_tls_ciphersuites, SHOW_FUNC,\n     SHOW_SCOPE_GLOBAL},\n    {\"Current_tls_crl\", (char *)&SslAcceptorContext::show_ssl_get_ssl_crl,\n     SHOW_FUNC, SHOW_SCOPE_GLOBAL},\n    {\"Current_tls_crlpath\",\n     (char *)&SslAcceptorContext::show_ssl_get_ssl_crlpath, SHOW_FUNC,\n     SHOW_SCOPE_GLOBAL},\n    {\"Rsa_public_key\", (char *)&show_rsa_public_key, SHOW_FUNC,\n     SHOW_SCOPE_GLOBAL},\n    {\"Table_locks_immediate\", (char *)&locks_immediate, SHOW_LONG,\n     SHOW_SCOPE_GLOBAL},\n    {\"Table_locks_waited\", (char *)&locks_waited, SHOW_LONG, SHOW_SCOPE_GLOBAL},\n    {\"Table_open_cache_hits\",\n     (char *)offsetof(System_status_var, table_open_cache_hits),\n     SHOW_LONGLONG_STATUS, SHOW_SCOPE_ALL},\n    {\"Table_open_cache_misses\",\n     (char *)offsetof(System_status_var, table_open_cache_misses),\n     SHOW_LONGLONG_STATUS, SHOW_SCOPE_ALL},\n    {\"Table_open_cache_overflows\",\n     (char *)offsetof(System_status_var, table_open_cache_overflows),\n     SHOW_LONGLONG_STATUS, SHOW_SCOPE_ALL},\n    {\"Tc_log_max_pages_used\", (char *)&tc_log_max_pages_used, SHOW_LONG,\n     SHOW_SCOPE_GLOBAL},\n    {\"Tc_log_page_size\", (char *)&tc_log_page_size, SHOW_LONG_NOFLUSH,\n     SHOW_SCOPE_GLOBAL},\n    {\"Tc_log_page_waits\", (char *)&tc_log_page_waits, SHOW_LONG,\n     SHOW_SCOPE_GLOBAL},\n#ifdef HAVE_POOL_OF_THREADS\n    {\"Threadpool_idle_threads\", (char *)&show_threadpool_idle_threads,\n     SHOW_FUNC, SHOW_SCOPE_GLOBAL},\n    {\"Threadpool_threads\", (char *)&tp_stats.num_worker_threads, SHOW_INT,\n     SHOW_SCOPE_GLOBAL},\n#endif\n    {\"Threads_cached\",\n     (char *)&Per_thread_connection_handler::blocked_pthread_count,\n     SHOW_LONG_NOFLUSH, SHOW_SCOPE_GLOBAL},\n    {\"Threads_connected\", (char *)&Connection_handler_manager::connection_count,\n     SHOW_INT, SHOW_SCOPE_GLOBAL},\n    {\"Threads_created\", (char *)&show_num_thread_created, SHOW_FUNC,\n     SHOW_SCOPE_GLOBAL},\n    {\"Threads_running\", (char *)&show_num_thread_running, SHOW_FUNC,\n     SHOW_SCOPE_GLOBAL},\n    {\"Uptime\", (char *)&show_starttime, SHOW_FUNC, SHOW_SCOPE_GLOBAL},\n#ifdef ENABLED_PROFILING\n    {\"Uptime_since_flush_status\", (char *)&show_flushstatustime, SHOW_FUNC,\n     SHOW_SCOPE_GLOBAL},\n#endif\n    {NullS, NullS, SHOW_LONG, SHOW_SCOPE_ALL}};\n\nvoid add_terminator(vector<my_option> *options) {\n  my_option empty_element = {nullptr, 0,          nullptr, nullptr, nullptr,\n                             nullptr, GET_NO_ARG, NO_ARG,  0,       0,\n                             0,       nullptr,    0,       nullptr};\n  options->push_back(empty_element);\n}\n\nstatic void print_server_version(void) {\n  set_server_version();\n\n  print_explicit_version(server_version);\n}\n\n/** Compares two options' names, treats - and _ the same */\nstatic bool operator<(const my_option &a, const my_option &b) {\n  const char *sa = a.name;\n  const char *sb = b.name;\n  for (; *sa || *sb; sa++, sb++) {\n    if (*sa < *sb) {\n      if (*sa == '-' && *sb == '_')\n        continue;\n      else\n        return true;\n    }\n    if (*sa > *sb) {\n      if (*sa == '_' && *sb == '-')\n        continue;\n      else\n        return false;\n    }\n  }\n  DBUG_ASSERT(a.name == b.name);\n  return false;\n}\n\nstatic void print_help() {\n  MEM_ROOT mem_root;\n  init_alloc_root(key_memory_help, &mem_root, 4096, 4096);\n\n  all_options.pop_back();\n  sys_var_add_options(&all_options, sys_var::PARSE_EARLY);\n  for (my_option *opt = my_long_early_options; opt->name != nullptr; opt++) {\n    all_options.push_back(*opt);\n  }\n  add_plugin_options(&all_options, &mem_root);\n  std::sort(all_options.begin(), all_options.end(), std::less<my_option>());\n  add_terminator(&all_options);\n\n  my_print_help(&all_options[0]);\n  my_print_variables(&all_options[0]);\n\n  free_root(&mem_root, MYF(0));\n  vector<my_option>().swap(all_options);  // Deletes the vector contents.\n}\n\nstatic void usage(void) {\n  DBUG_TRACE;\n  if (!(default_charset_info = get_charset_by_csname(\n            default_character_set_name, MY_CS_PRIMARY, MYF(MY_WME))))\n    exit(MYSQLD_ABORT_EXIT);\n  if (!default_collation_name)\n    default_collation_name = default_charset_info->name;\n  if (is_help_or_validate_option() || opt_verbose) {\n    my_progname = my_progname + dirname_length(my_progname);\n  }\n  print_server_version();\n  puts(ORACLE_WELCOME_COPYRIGHT_NOTICE(\"2000\"));\n  puts(\"Starts the MySQL database server.\\n\");\n  printf(\"Usage: %s [OPTIONS]\\n\", my_progname);\n  if (!opt_verbose)\n    puts(\n        \"\\nFor more help options (several pages), use mysqld --verbose \"\n        \"--help.\");\n  else {\n#ifdef _WIN32\n    puts(\n        \"NT and Win32 specific options:\\n\\\n  --install                     Install the default service (NT).\\n\\\n  --install-manual              Install the default service started manually (NT).\\n\\\n  --install service_name        Install an optional service (NT).\\n\\\n  --install-manual service_name Install an optional service started manually (NT).\\n\\\n  --remove                      Remove the default service from the service list (NT).\\n\\\n  --remove service_name         Remove the service_name from the service list (NT).\\n\\\n  --enable-named-pipe           Only to be used for the default server (NT).\\n\\\n  --standalone                  Dummy option to start as a standalone server (NT).\\\n\");\n    puts(\"\");\n#endif\n    print_defaults(MYSQL_CONFIG_NAME, load_default_groups);\n    puts(\"\");\n    set_ports();\n\n    /* Print out all the options including plugin supplied options */\n    print_help();\n\n    if (!dynamic_plugins_are_initialized) {\n      puts(\n          \"\\n\\\nPlugins have parameters that are not reflected in this list\\n\\\nbecause execution stopped before plugins were initialized.\");\n    }\n\n    puts(\n        \"\\n\\\nTo see what values a running MySQL server is using, type\\n\\\n'mysqladmin variables' instead of 'mysqld --verbose --help'.\");\n  }\n}\n\n/**\n  Initialize MySQL global variables to default values.\n\n  @note\n    The reason to set a lot of global variables to zero is that\n    on some exotic platforms global variables are\n    not set to 0 when a program starts.\n\n    We don't need to set variables refered to in my_long_options\n    as these are initialized by my_getopt.\n*/\n\nstatic int mysql_init_variables() {\n  /* Things reset to zero */\n  opt_skip_slave_start = false;\n  pidfile_name[0] = 0;\n  myisam_test_invalid_symlink = test_if_data_home_dir;\n  opt_general_log = opt_slow_log = false;\n  opt_disable_networking = opt_skip_show_db = false;\n  opt_skip_name_resolve = false;\n  opt_general_logname = opt_binlog_index_name = opt_slow_logname = nullptr;\n  opt_tc_log_file = \"tc.log\";  // no hostname in tc_log file name !\n  opt_myisam_log = false;\n  mqh_used = false;\n  cleanup_done = 0;\n  server_id_supplied = false;\n  select_errors = ha_open_options = 0;\n  atomic_slave_open_temp_tables = 0;\n  opt_endinfo = using_udf_functions = false;\n  opt_using_transactions = false;\n  set_connection_events_loop_aborted(false);\n  set_mysqld_offline_mode(false);\n  set_mysqld_partial_revokes(opt_partial_revokes);\n  server_operational_state = SERVER_BOOTING;\n  aborted_threads = 0;\n  delayed_insert_threads = delayed_insert_writes = delayed_rows_in_use = 0;\n  delayed_insert_errors = 0;\n  specialflag = 0;\n  binlog_cache_use = binlog_cache_disk_use = 0;\n  mysqld_user = mysqld_chroot = opt_init_file = opt_bin_logname = nullptr;\n  prepared_stmt_count = 0;\n  mysqld_unix_port = opt_mysql_tmpdir = my_bind_addr_str = NullS;\n  new (&mysql_tmpdir_list) MY_TMPDIR;\n  memset(&global_status_var, 0, sizeof(global_status_var));\n  opt_large_pages = false;\n  opt_super_large_pages = false;\n#if defined(ENABLED_DEBUG_SYNC)\n  opt_debug_sync_timeout = 0;\n#endif /* defined(ENABLED_DEBUG_SYNC) */\n  server_uuid[0] = 0;\n\n  /* Character sets */\n  system_charset_info = &my_charset_utf8_general_ci;\n  files_charset_info = &my_charset_utf8_general_ci;\n  national_charset_info = &my_charset_utf8_general_ci;\n  table_alias_charset = &my_charset_bin;\n  character_set_filesystem = &my_charset_bin;\n\n  opt_specialflag = 0;\n  pidfile_name_ptr = pidfile_name;\n  lc_messages_dir_ptr = lc_messages_dir;\n  protocol_version = PROTOCOL_VERSION;\n  what_to_log = ~(1L << (uint)COM_TIME);\n  refresh_version = 1L; /* Increments on each reload */\n  my_stpcpy(server_version, MYSQL_SERVER_VERSION);\n  key_caches.empty();\n  if (!(dflt_key_cache = get_or_create_key_cache(\n            default_key_cache_base.str, default_key_cache_base.length))) {\n    LogErr(ERROR_LEVEL, ER_KEYCACHE_OOM);\n    return 1;\n  }\n  /* set key_cache_hash.default_value = dflt_key_cache */\n  multi_keycache_init();\n\n  /* Replication parameters */\n  master_info_file = \"master.info\";\n  relay_log_info_file = \"relay-log.info\";\n  report_user = report_password = report_host = nullptr; /* TO BE DELETED */\n  opt_relay_logname = opt_relaylog_index_name = nullptr;\n  opt_relaylog_index_name_supplied = false;\n  opt_relay_logname_supplied = false;\n  log_bin_basename = nullptr;\n  log_bin_index = nullptr;\n\n  /* Handler variables */\n  total_ha_2pc = 0;\n  /* Variables in libraries */\n  charsets_dir = nullptr;\n  default_character_set_name = MYSQL_DEFAULT_CHARSET_NAME;\n  default_collation_name = compiled_default_collation_name;\n  character_set_filesystem_name = \"binary\";\n  lc_messages = mysqld_default_locale_name;\n  lc_time_names_name = mysqld_default_locale_name;\n\n  /* Variables that depends on compile options */\n#ifndef DBUG_OFF\n  default_dbug_option =\n      IF_WIN(\"d:t:i:O,\\\\mysqld.trace\", \"d:t:i:o,/tmp/mysqld.trace\");\n#endif\n#ifdef ENABLED_PROFILING\n  have_profiling = SHOW_OPTION_YES;\n#else\n  have_profiling = SHOW_OPTION_NO;\n#endif\n\n  have_symlink = SHOW_OPTION_YES;\n\n  have_dlopen = SHOW_OPTION_YES;\n\n  have_query_cache = SHOW_OPTION_NO;\n\n  have_geometry = SHOW_OPTION_YES;\n\n  have_rtree_keys = SHOW_OPTION_YES;\n\n  /* Always true */\n  have_compress = SHOW_OPTION_YES;\n#if defined(_WIN32)\n  shared_memory_base_name = default_shared_memory_base_name;\n#endif\n\n  have_backup_locks = SHOW_OPTION_YES;\n  have_backup_safe_binlog_info = SHOW_OPTION_YES;\n  have_snapshot_cloning = SHOW_OPTION_YES;\n\n  return 0;\n}\n\n/**\n  Check if it is a global replication filter setting.\n\n  @param argument The setting of startup option --replicate-*.\n\n  @retval\n    0    OK\n  @retval\n    1    Error\n*/\nstatic bool is_rpl_global_filter_setting(char *argument) {\n  DBUG_TRACE;\n\n  bool res = false;\n  char *p = strchr(argument, ':');\n  if (p == nullptr) res = true;\n\n  return res;\n}\n\n/**\n  Extract channel name and filter value from argument.\n\n  @param [out] channel_name The name of the channel.\n  @param [out] filter_val The value of filter.\n  @param argument The setting of startup option --replicate-*.\n*/\nvoid parse_filter_arg(char **channel_name, char **filter_val, char *argument) {\n  DBUG_TRACE;\n\n  char *p = strchr(argument, ':');\n\n  DBUG_ASSERT(p != nullptr);\n\n  /*\n    If argument='channel_1:db1', then channel_name='channel_1'\n    and filter_val='db1'; If argument=':db1', then channel_name=''\n    and filter_val='db1'.\n  */\n  *channel_name = argument;\n  *filter_val = p + 1;\n  *p = 0;\n}\n\n/**\n  Extract channel name and filter value from argument.\n\n  @param [out] key The db is rewritten from.\n  @param [out] val The db is rewritten to.\n  @param argument The value of filter.\n\n  @retval\n    0    OK\n  @retval\n    1    Error\n*/\nstatic int parse_replicate_rewrite_db(char **key, char **val, char *argument) {\n  DBUG_TRACE;\n  char *p;\n  *key = argument;\n\n  if (!(p = strstr(argument, \"->\"))) {\n    LogErr(ERROR_LEVEL, ER_RPL_REWRITEDB_MISSING_ARROW);\n    return 1;\n  }\n  *val = p + 2;\n\n  while (p > argument && my_isspace(mysqld_charset, p[-1])) p--;\n  *p = 0;\n\n  if (!**key) {\n    LogErr(ERROR_LEVEL, ER_RPL_REWRITEDB_EMPTY_FROM);\n    return 1;\n  }\n  while (**val && my_isspace(mysqld_charset, **val)) (*val)++;\n  if (!**val) {\n    LogErr(ERROR_LEVEL, ER_RPL_REWRITEDB_EMPTY_TO);\n    return 1;\n  }\n\n  return 0;\n}\n\nbool mysqld_get_one_option(int optid,\n                           const struct my_option *opt MY_ATTRIBUTE((unused)),\n                           char *argument) {\n  Rpl_filter *rpl_filter = nullptr;\n  char *filter_val;\n  char *channel_name;\n\n  switch (optid) {\n    case '#':\n#ifndef DBUG_OFF\n      DBUG_SET_INITIAL(argument ? argument : default_dbug_option);\n#endif\n      opt_endinfo = true; /* unireg: memory allocation */\n      break;\n    case 'a':\n      global_system_variables.sql_mode = MODE_ANSI;\n      global_system_variables.transaction_isolation = ISO_SERIALIZABLE;\n      break;\n    case 'b':\n      strmake(mysql_home, argument, sizeof(mysql_home) - 1);\n      mysql_home_ptr = mysql_home;\n      break;\n    case 'C':\n      if (default_collation_name == compiled_default_collation_name)\n        default_collation_name = nullptr;\n      break;\n    case 'h':\n      strmake(mysql_real_data_home, argument, sizeof(mysql_real_data_home) - 1);\n      /* Correct pointer set by my_getopt */\n      mysql_real_data_home_ptr = mysql_real_data_home;\n      break;\n    case 'u':\n      if (!mysqld_user || !strcmp(mysqld_user, argument))\n        mysqld_user = argument;\n      else\n        LogErr(WARNING_LEVEL, ER_THE_USER_ABIDES, argument, mysqld_user);\n      break;\n    case 's':\n      if (argument && argument[0] == '0') {\n        LogErr(WARNING_LEVEL, ER_DEPRECATE_MSG_NO_REPLACEMENT,\n               \"Disabling symbolic links using --skip-symbolic-links\"\n               \" (or equivalent) is the default. Consider not using\"\n               \" this option as it\");\n      } else {\n        LogErr(WARNING_LEVEL, ER_DEPRECATE_MSG_NO_REPLACEMENT,\n               \"Enabling symbolic using --symbolic-links/-s (or equivalent)\");\n      }\n      break;\n    case 'L':\n      push_deprecated_warn(nullptr, \"--language/-l\", \"'--lc-messages-dir'\");\n    // fallthrough\n    case OPT_LC_MESSAGES_DIRECTORY:\n      strmake(lc_messages_dir, argument, sizeof(lc_messages_dir) - 1);\n      lc_messages_dir_ptr = lc_messages_dir;\n      break;\n    case OPT_BINLOG_FORMAT:\n      binlog_format_used = true;\n      break;\n    case OPT_BINLOG_MAX_FLUSH_QUEUE_TIME:\n      push_deprecated_warn_no_replacement(nullptr,\n                                          \"--binlog_max_flush_queue_time\");\n      break;\n    case OPT_EXPIRE_LOGS_DAYS:\n      push_deprecated_warn(nullptr, \"expire-logs-days\",\n                           \"binlog_expire_logs_seconds\");\n      expire_logs_days_supplied = true;\n      break;\n    case OPT_BINLOG_EXPIRE_LOGS_SECONDS:\n      binlog_expire_logs_seconds_supplied = true;\n      break;\n    case OPT_SSL_KEY:\n    case OPT_SSL_CERT:\n    case OPT_SSL_CA:\n    case OPT_SSL_CAPATH:\n    case OPT_SSL_CIPHER:\n    case OPT_TLS_CIPHERSUITES:\n    case OPT_SSL_CRL:\n    case OPT_SSL_CRLPATH:\n    case OPT_TLS_VERSION:\n      /*\n        Enable use of SSL if we are using any ssl option.\n        One can disable SSL later by using --skip-ssl or --ssl=0.\n      */\n      opt_use_ssl = true;\n      break;\n    case 'V':\n      print_server_version();\n      exit(MYSQLD_SUCCESS_EXIT);\n    case 'T':\n      test_flags = argument ? (uint)atoi(argument) : 0;\n      opt_endinfo = true;\n      break;\n    case (int)OPT_ISAM_LOG:\n      opt_myisam_log = true;\n      break;\n    case (int)OPT_BIN_LOG:\n      opt_bin_log = (argument != disabled_my_option);\n      if (!opt_bin_log) {\n        // Clear the binlog basename used by any previous --log-bin\n        if (opt_bin_logname) {\n          my_free(opt_bin_logname);\n          opt_bin_logname = nullptr;\n        }\n      }\n      log_bin_supplied = true;\n      break;\n    case (int)OPT_REPLICATE_IGNORE_DB: {\n      if (is_rpl_global_filter_setting(argument)) {\n        rpl_global_filter.add_ignore_db(argument);\n        rpl_global_filter.ignore_db_statistics.set_all(\n            CONFIGURED_BY_STARTUP_OPTIONS);\n      } else {\n        parse_filter_arg(&channel_name, &filter_val, argument);\n        rpl_filter = rpl_channel_filters.get_channel_filter(channel_name);\n        rpl_filter->add_ignore_db(filter_val);\n        rpl_filter->ignore_db_statistics.set_all(\n            CONFIGURED_BY_STARTUP_OPTIONS_FOR_CHANNEL);\n      }\n      break;\n    }\n    case (int)OPT_REPLICATE_DO_DB: {\n      if (is_rpl_global_filter_setting(argument)) {\n        rpl_global_filter.add_do_db(argument);\n        rpl_global_filter.do_db_statistics.set_all(\n            CONFIGURED_BY_STARTUP_OPTIONS);\n      } else {\n        parse_filter_arg(&channel_name, &filter_val, argument);\n        rpl_filter = rpl_channel_filters.get_channel_filter(channel_name);\n        rpl_filter->add_do_db(filter_val);\n        rpl_filter->do_db_statistics.set_all(\n            CONFIGURED_BY_STARTUP_OPTIONS_FOR_CHANNEL);\n      }\n      break;\n    }\n    case (int)OPT_REPLICATE_REWRITE_DB: {\n      char *key, *val;\n      if (is_rpl_global_filter_setting(argument)) {\n        if (parse_replicate_rewrite_db(&key, &val, argument)) return true;\n        rpl_global_filter.add_db_rewrite(key, val);\n        rpl_global_filter.rewrite_db_statistics.set_all(\n            CONFIGURED_BY_STARTUP_OPTIONS);\n      } else {\n        parse_filter_arg(&channel_name, &filter_val, argument);\n        rpl_filter = rpl_channel_filters.get_channel_filter(channel_name);\n        if (parse_replicate_rewrite_db(&key, &val, filter_val)) return true;\n        rpl_filter->add_db_rewrite(key, val);\n        rpl_filter->rewrite_db_statistics.set_all(\n            CONFIGURED_BY_STARTUP_OPTIONS_FOR_CHANNEL);\n      }\n      break;\n    }\n\n    case (int)OPT_BINLOG_IGNORE_DB: {\n      binlog_filter->add_ignore_db(argument);\n      break;\n    }\n    case (int)OPT_BINLOG_DO_DB: {\n      binlog_filter->add_do_db(argument);\n      break;\n    }\n    case (int)OPT_REPLICATE_DO_TABLE: {\n      if (is_rpl_global_filter_setting(argument)) {\n        if (rpl_global_filter.add_do_table_array(argument)) {\n          LogErr(ERROR_LEVEL, ER_RPL_CANT_ADD_DO_TABLE, argument);\n          return true;\n        }\n        rpl_global_filter.do_table_statistics.set_all(\n            CONFIGURED_BY_STARTUP_OPTIONS);\n      } else {\n        parse_filter_arg(&channel_name, &filter_val, argument);\n        rpl_filter = rpl_channel_filters.get_channel_filter(channel_name);\n        if (rpl_filter->add_do_table_array(filter_val)) {\n          LogErr(ERROR_LEVEL, ER_RPL_CANT_ADD_DO_TABLE, argument);\n          return true;\n        }\n        rpl_filter->do_table_statistics.set_all(\n            CONFIGURED_BY_STARTUP_OPTIONS_FOR_CHANNEL);\n      }\n      break;\n    }\n    case (int)OPT_REPLICATE_WILD_DO_TABLE: {\n      if (is_rpl_global_filter_setting(argument)) {\n        if (rpl_global_filter.add_wild_do_table(argument)) {\n          LogErr(ERROR_LEVEL, ER_RPL_FILTER_ADD_WILD_DO_TABLE_FAILED, argument);\n          return true;\n        }\n        rpl_global_filter.wild_do_table_statistics.set_all(\n            CONFIGURED_BY_STARTUP_OPTIONS);\n      } else {\n        parse_filter_arg(&channel_name, &filter_val, argument);\n        rpl_filter = rpl_channel_filters.get_channel_filter(channel_name);\n        if (rpl_filter->add_wild_do_table(filter_val)) {\n          LogErr(ERROR_LEVEL, ER_RPL_FILTER_ADD_WILD_DO_TABLE_FAILED, argument);\n          return true;\n        }\n        rpl_filter->wild_do_table_statistics.set_all(\n            CONFIGURED_BY_STARTUP_OPTIONS_FOR_CHANNEL);\n      }\n      break;\n    }\n    case (int)OPT_REPLICATE_WILD_IGNORE_TABLE: {\n      if (is_rpl_global_filter_setting(argument)) {\n        if (rpl_global_filter.add_wild_ignore_table(argument)) {\n          LogErr(ERROR_LEVEL, ER_RPL_FILTER_ADD_WILD_IGNORE_TABLE_FAILED,\n                 argument);\n          return true;\n        }\n        rpl_global_filter.wild_ignore_table_statistics.set_all(\n            CONFIGURED_BY_STARTUP_OPTIONS);\n      } else {\n        parse_filter_arg(&channel_name, &filter_val, argument);\n        rpl_filter = rpl_channel_filters.get_channel_filter(channel_name);\n        if (rpl_filter->add_wild_ignore_table(filter_val)) {\n          LogErr(ERROR_LEVEL, ER_RPL_FILTER_ADD_WILD_IGNORE_TABLE_FAILED,\n                 argument);\n          return true;\n        }\n        rpl_filter->wild_ignore_table_statistics.set_all(\n            CONFIGURED_BY_STARTUP_OPTIONS_FOR_CHANNEL);\n      }\n      break;\n    }\n    case (int)OPT_REPLICATE_IGNORE_TABLE: {\n      if (is_rpl_global_filter_setting(argument)) {\n        if (rpl_global_filter.add_ignore_table_array(argument)) {\n          LogErr(ERROR_LEVEL, ER_RPL_CANT_ADD_IGNORE_TABLE, argument);\n          return true;\n        }\n        rpl_global_filter.ignore_table_statistics.set_all(\n            CONFIGURED_BY_STARTUP_OPTIONS);\n      } else {\n        parse_filter_arg(&channel_name, &filter_val, argument);\n        rpl_filter = rpl_channel_filters.get_channel_filter(channel_name);\n        if (rpl_filter->add_ignore_table_array(filter_val)) {\n          LogErr(ERROR_LEVEL, ER_RPL_CANT_ADD_IGNORE_TABLE, argument);\n          return true;\n        }\n        rpl_filter->ignore_table_statistics.set_all(\n            CONFIGURED_BY_STARTUP_OPTIONS_FOR_CHANNEL);\n      }\n      break;\n    }\n    case (int)OPT_MASTER_RETRY_COUNT:\n      push_deprecated_warn(nullptr, \"--master-retry-count\",\n                           \"'CHANGE MASTER TO master_retry_count = <num>'\");\n      break;\n    case (int)OPT_SKIP_NEW:\n      opt_specialflag |= SPECIAL_NO_NEW_FUNC;\n      delay_key_write_options = DELAY_KEY_WRITE_NONE;\n      myisam_concurrent_insert = 0;\n      myisam_recover_options = HA_RECOVER_OFF;\n      sp_automatic_privileges = false;\n      my_enable_symlinks = false;\n      ha_open_options &= ~(HA_OPEN_ABORT_IF_CRASHED | HA_OPEN_DELAY_KEY_WRITE);\n      break;\n    case (int)OPT_SKIP_HOST_CACHE:\n      opt_specialflag |= SPECIAL_NO_HOST_CACHE;\n      break;\n    case (int)OPT_SKIP_RESOLVE:\n      if (argument && (argument == disabled_my_option ||\n                       !my_strcasecmp(system_charset_info, argument, \"OFF\")))\n        opt_skip_name_resolve = false;\n      else {\n        opt_skip_name_resolve = true;\n        opt_specialflag |= SPECIAL_NO_RESOLVE;\n      }\n      break;\n    case (int)OPT_WANT_CORE:\n      test_flags |= TEST_CORE_ON_SIGNAL;\n      break;\n    case (int)OPT_SKIP_STACK_TRACE:\n      test_flags |= TEST_NO_STACKTRACE;\n      break;\n    case OPT_SERVER_ID:\n      /*\n       Consider that one received a Server Id when 2 conditions are present:\n       1) The argument is on the list\n       2) There is a value present\n      */\n      server_id_supplied = (*argument != 0);\n      break;\n    case OPT_LOWER_CASE_TABLE_NAMES:\n      lower_case_table_names_used = true;\n      break;\n#if defined(ENABLED_DEBUG_SYNC)\n    case OPT_DEBUG_SYNC_TIMEOUT:\n      /*\n        Debug Sync Facility. See debug_sync.cc.\n        Default timeout for WAIT_FOR action.\n        Default value is zero (facility disabled).\n        If option is given without an argument, supply a non-zero value.\n      */\n      if (!argument) {\n        /* purecov: begin tested */\n        opt_debug_sync_timeout = DEBUG_SYNC_DEFAULT_WAIT_TIMEOUT;\n        /* purecov: end */\n      }\n      break;\n#endif /* defined(ENABLED_DEBUG_SYNC) */\n    case OPT_LOG_ERROR:\n      /*\n        \"No --log-error\" == \"write errors to stderr\",\n        \"--log-error without argument\" == \"write errors to a file\".\n      */\n      if (argument == nullptr) /* no argument */\n        log_error_dest = \"\";\n      break;\n\n    case OPT_EARLY_PLUGIN_LOAD:\n      free_list(opt_early_plugin_load_list_ptr);\n      opt_early_plugin_load_list_ptr->push_back(new i_string(argument));\n      break;\n    case OPT_PLUGIN_LOAD:\n      free_list(opt_plugin_load_list_ptr);\n      /* fall through */\n    case OPT_PLUGIN_LOAD_ADD:\n      opt_plugin_load_list_ptr->push_back(new i_string(argument));\n      break;\n    case OPT_PFS_INSTRUMENT: {\n#ifdef WITH_PERFSCHEMA_STORAGE_ENGINE\n      /*\n        Parse instrument name and value from argument string. Handle leading\n        and trailing spaces. Also handle single quotes.\n\n        Acceptable:\n          performance_schema_instrument = ' foo/%/bar/  =  ON  '\n          performance_schema_instrument = '%=OFF'\n        Not acceptable:\n          performance_schema_instrument = '' foo/%/bar = ON ''\n          performance_schema_instrument = '%='OFF''\n      */\n      char *name = argument, *p = nullptr, *val = nullptr;\n      bool quote = false; /* true if quote detected */\n      bool error = true;  /* false if no errors detected */\n      const int PFS_BUFFER_SIZE = 128;\n      char orig_argument[PFS_BUFFER_SIZE + 1];\n      orig_argument[0] = 0;\n\n      if (!argument) goto pfs_error;\n\n      /* Save original argument string for error reporting */\n      strncpy(orig_argument, argument, PFS_BUFFER_SIZE);\n\n      /* Split instrument name and value at the equal sign */\n      if (!(p = strchr(argument, '='))) goto pfs_error;\n\n      /* Get option value */\n      val = p + 1;\n      if (!*val) goto pfs_error;\n\n      /* Trim leading spaces and quote from the instrument name */\n      while (*name && (my_isspace(mysqld_charset, *name) || (*name == '\\''))) {\n        /* One quote allowed */\n        if (*name == '\\'') {\n          if (!quote)\n            quote = true;\n          else\n            goto pfs_error;\n        }\n        name++;\n      }\n\n      /* Trim trailing spaces from instrument name */\n      while ((p > name) && my_isspace(mysqld_charset, p[-1])) p--;\n      *p = 0;\n\n      /* Remove trailing slash from instrument name */\n      if (p > name && (p[-1] == '/')) p[-1] = 0;\n\n      if (!*name) goto pfs_error;\n\n      /* Trim leading spaces from option value */\n      while (*val && my_isspace(mysqld_charset, *val)) val++;\n\n      /* Trim trailing spaces and matching quote from value */\n      p = val + strlen(val);\n      while (p > val && (my_isspace(mysqld_charset, p[-1]) || p[-1] == '\\'')) {\n        /* One matching quote allowed */\n        if (p[-1] == '\\'') {\n          if (quote)\n            quote = false;\n          else\n            goto pfs_error;\n        }\n        p--;\n      }\n\n      *p = 0;\n\n      if (!*val) goto pfs_error;\n\n      /* Add instrument name and value to array of configuration options */\n      if (add_pfs_instr_to_array(name, val)) goto pfs_error;\n\n      error = false;\n\n    pfs_error:\n      if (error) {\n        LogErr(WARNING_LEVEL, ER_INVALID_INSTRUMENT, orig_argument);\n        return false;\n      }\n#endif /* WITH_PERFSCHEMA_STORAGE_ENGINE */\n      break;\n    }\n    case OPT_THREAD_CACHE_SIZE:\n      thread_cache_size_specified = true;\n      break;\n    case OPT_HOST_CACHE_SIZE:\n      host_cache_size_specified = true;\n      break;\n    case OPT_TABLE_DEFINITION_CACHE:\n      table_definition_cache_specified = true;\n      break;\n    case OPT_SKIP_INNODB:\n      LogErr(WARNING_LEVEL, ER_INNODB_MANDATORY);\n      break;\n    case OPT_AVOID_TEMPORAL_UPGRADE:\n      push_deprecated_warn_no_replacement(nullptr, \"avoid_temporal_upgrade\");\n      break;\n    case OPT_SHOW_OLD_TEMPORALS:\n      push_deprecated_warn_no_replacement(nullptr, \"show_old_temporals\");\n      break;\n    case 'p':\n      if (argument) {\n        char *start = argument;\n        my_free(opt_keyring_migration_password);\n        opt_keyring_migration_password =\n            my_strdup(PSI_NOT_INSTRUMENTED, argument, MYF(MY_FAE));\n        while (*argument) *argument++ = 'x';\n        if (*start) start[1] = 0;\n      } else\n        opt_keyring_migration_password = get_tty_password(NullS);\n      migrate_connect_options = true;\n      break;\n    case OPT_KEYRING_MIGRATION_USER:\n    case OPT_KEYRING_MIGRATION_HOST:\n    case OPT_KEYRING_MIGRATION_SOCKET:\n    case OPT_KEYRING_MIGRATION_PORT:\n      migrate_connect_options = true;\n      break;\n    case OPT_LOG_SLAVE_UPDATES:\n      log_slave_updates_supplied = true;\n      break;\n    case OPT_SLAVE_PRESERVE_COMMIT_ORDER:\n      slave_preserve_commit_order_supplied = true;\n      break;\n    case OPT_ENFORCE_GTID_CONSISTENCY: {\n      const char *wrong_value =\n          fixup_enforce_gtid_consistency_command_line(argument);\n      if (wrong_value != nullptr)\n        LogErr(WARNING_LEVEL, ER_INVALID_VALUE_FOR_ENFORCE_GTID_CONSISTENCY,\n               wrong_value);\n    } break;\n    case OPT_NAMED_PIPE_FULL_ACCESS_GROUP:\n#ifdef _WIN32\n      if (!is_valid_named_pipe_full_access_group(argument)) {\n        LogErr(ERROR_LEVEL, ER_INVALID_NAMED_PIPE_FULL_ACCESS_GROUP);\n        return 1;\n      }\n#endif  // _WIN32\n      break;\n    case OPT_RELAY_LOG_INFO_FILE:\n      push_deprecated_warn_no_replacement(nullptr, \"--relay-log-info-file\");\n      break;\n    case OPT_MASTER_INFO_FILE:\n      push_deprecated_warn_no_replacement(nullptr, \"--master-info-file\");\n      break;\n    case OPT_LOG_BIN_USE_V1_ROW_EVENTS:\n      push_deprecated_warn_no_replacement(nullptr,\n                                          \"--log-bin-use-v1-row-events\");\n      break;\n    case OPT_SLAVE_ROWS_SEARCH_ALGORITHMS:\n      push_deprecated_warn_no_replacement(nullptr,\n                                          \"--slave-rows-search-algorithms\");\n      break;\n  }\n  return false;\n}\n\n/** Handle arguments for multiple key caches. */\n\nstatic void *mysql_getopt_value(const char *keyname, size_t key_length,\n                                const struct my_option *option, int *error) {\n  if (error) *error = 0;\n  switch (option->id) {\n    case OPT_KEY_BUFFER_SIZE:\n    case OPT_KEY_CACHE_BLOCK_SIZE:\n    case OPT_KEY_CACHE_DIVISION_LIMIT:\n    case OPT_KEY_CACHE_AGE_THRESHOLD: {\n      KEY_CACHE *key_cache;\n      if (!(key_cache = get_or_create_key_cache(keyname, key_length))) {\n        if (error) *error = EXIT_OUT_OF_MEMORY;\n        return nullptr;\n      }\n      switch (option->id) {\n        case OPT_KEY_BUFFER_SIZE:\n          return &key_cache->param_buff_size;\n        case OPT_KEY_CACHE_BLOCK_SIZE:\n          return &key_cache->param_block_size;\n        case OPT_KEY_CACHE_DIVISION_LIMIT:\n          return &key_cache->param_division_limit;\n        case OPT_KEY_CACHE_AGE_THRESHOLD:\n          return &key_cache->param_age_threshold;\n      }\n    }\n  }\n  return option->value;\n}\n\n/**\n  Get server options from the command line,\n  and perform related server initializations.\n  @param [in, out] argc_ptr       command line options (count)\n  @param [in, out] argv_ptr       command line options (values)\n  @return 0 on success\n\n  @todo\n  - FIXME add EXIT_TOO_MANY_ARGUMENTS to \"mysys_err.h\" and return that code?\n*/\nstatic int get_options(int *argc_ptr, char ***argv_ptr) {\n  int ho_error;\n\n  my_getopt_register_get_addr(mysql_getopt_value);\n\n  /* prepare all_options array */\n  all_options.reserve(array_elements(my_long_options));\n  for (my_option *opt = my_long_options;\n       opt < my_long_options + array_elements(my_long_options) - 1; opt++) {\n    all_options.push_back(*opt);\n  }\n  sys_var_add_options(&all_options, sys_var::PARSE_NORMAL);\n  add_terminator(&all_options);\n\n  /* Skip unknown options so that they may be processed later by plugins */\n  my_getopt_skip_unknown = true;\n\n  if ((ho_error = handle_options(argc_ptr, argv_ptr, &all_options[0],\n                                 mysqld_get_one_option)))\n    return ho_error;\n\n  // update suppression list in filter engine\n  {\n    int rr;\n    // try to set the list\n    if (((rr = log_builtins_filter_parse_suppression_list(\n              opt_log_error_suppression_list, false)) != 0) ||\n        ((rr = log_builtins_filter_parse_suppression_list(\n              opt_log_error_suppression_list, true)) != 0)) {\n      rr = -(rr + 1);\n      LogErr(ERROR_LEVEL, ER_CANT_SET_ERROR_SUPPRESSION_LIST_FROM_COMMAND_LINE,\n             \"log_error_suppression_list\", &opt_log_error_suppression_list[rr]);\n\n      /*\n        We were given an illegal value at start-up, so the default will be\n        used instead. We have reported the problem (and the dodgy value);\n        let's now point our variable back at the default (i.e. the value\n        actually used) so SELECT @@GLOBAL.log_error_suppression_list will\n        render correct results.\n      */\n      sys_var *var =\n          intern_find_sys_var(STRING_WITH_LEN(\"log_error_suppression_list\"));\n      if (var != nullptr) {\n        opt_log_error_suppression_list = (char *)var->get_default();\n        /*\n          During unit-testing, the log subsystem is not initialized,\n          so while the default should always check out as a valid\n          argument, actually setting it will still fail in this\n          particular case as we cannot acquire the rule-set or its\n          lock.\n        */\n        if (log_builtins_filter_parse_suppression_list(\n                opt_log_error_suppression_list, false) == 0) {\n          log_builtins_filter_parse_suppression_list(\n              opt_log_error_suppression_list, true);\n        } else {\n          DBUG_ASSERT(false); /* purecov: inspected */\n        }\n      }\n    }\n  }\n\n  if (!is_help_or_validate_option())\n    vector<my_option>().swap(all_options);  // Deletes the vector contents.\n\n  /* Add back the program name handle_options removes */\n  (*argc_ptr)++;\n  (*argv_ptr)--;\n\n  /*\n    Options have been parsed. Now some of them need additional special\n    handling, like custom value checking, checking of incompatibilites\n    between options, setting of multiple variables, etc.\n    Do them here.\n  */\n\n  if (!opt_help && opt_verbose) LogErr(ERROR_LEVEL, ER_VERBOSE_REQUIRES_HELP);\n\n  if ((opt_log_slow_admin_statements || opt_log_queries_not_using_indexes ||\n       opt_log_slow_slave_statements) &&\n      !opt_slow_log)\n    LogErr(WARNING_LEVEL, ER_POINTLESS_WITHOUT_SLOWLOG);\n\n  if (global_system_variables.net_buffer_length >\n      global_system_variables.max_allowed_packet) {\n    LogErr(WARNING_LEVEL, ER_WASTEFUL_NET_BUFFER_SIZE,\n           global_system_variables.net_buffer_length,\n           global_system_variables.max_allowed_packet);\n  }\n\n  /*\n    TIMESTAMP columns get implicit DEFAULT values when\n    --explicit_defaults_for_timestamp is not set.\n    This behavior is deprecated now.\n  */\n  if (!is_help_or_validate_option() &&\n      !global_system_variables.explicit_defaults_for_timestamp)\n    LogErr(WARNING_LEVEL, ER_DEPRECATED_TIMESTAMP_IMPLICIT_DEFAULTS);\n\n  if (!is_help_or_validate_option() &&\n      opt_mi_repository_id == INFO_REPOSITORY_FILE)\n    push_deprecated_warn(nullptr, \"--master-info-repository=FILE\",\n                         \"'--master-info-repository=TABLE'\");\n\n  if (!is_help_or_validate_option() &&\n      opt_rli_repository_id == INFO_REPOSITORY_FILE)\n    push_deprecated_warn(nullptr, \"--relay-log-info-repository=FILE\",\n                         \"'--relay-log-info-repository=TABLE'\");\n\n  opt_init_connect.length = strlen(opt_init_connect.str);\n  opt_init_slave.length = strlen(opt_init_slave.str);\n  opt_mandatory_roles.length = strlen(opt_mandatory_roles.str);\n\n  if (global_system_variables.low_priority_updates)\n    thr_upgraded_concurrent_insert_lock = TL_WRITE_LOW_PRIORITY;\n\n  if (ft_boolean_check_syntax_string(\n          pointer_cast<const uchar *>(ft_boolean_syntax))) {\n    LogErr(ERROR_LEVEL, ER_FT_BOOL_SYNTAX_INVALID, ft_boolean_syntax);\n    return 1;\n  }\n\n  if (opt_noacl && !is_help_or_validate_option()) opt_disable_networking = true;\n\n  if (opt_disable_networking) mysqld_port = 0;\n\n  if (opt_skip_show_db) opt_specialflag |= SPECIAL_SKIP_SHOW_DB;\n\n  if (myisam_flush) flush_time = 0;\n\n  if (opt_slave_skip_errors) add_slave_skip_errors(opt_slave_skip_errors);\n\n  if (global_system_variables.max_join_size == HA_POS_ERROR)\n    global_system_variables.option_bits |= OPTION_BIG_SELECTS;\n  else\n    global_system_variables.option_bits &= ~OPTION_BIG_SELECTS;\n\n  // Synchronize @@global.autocommit value on --autocommit\n  const ulonglong turn_bit_on =\n      opt_autocommit ? OPTION_AUTOCOMMIT : OPTION_NOT_AUTOCOMMIT;\n  global_system_variables.option_bits =\n      (global_system_variables.option_bits &\n       ~(OPTION_NOT_AUTOCOMMIT | OPTION_AUTOCOMMIT)) |\n      turn_bit_on;\n\n  // Synchronize @@global.autocommit metadata on --autocommit\n  my_option *opt = &my_long_options[3];\n  DBUG_ASSERT(strcmp(opt->name, \"autocommit\") == 0);\n  DBUG_ASSERT(opt->arg_source != nullptr);\n  Sys_autocommit_ptr->set_source_name(opt->arg_source->m_path_name);\n  Sys_autocommit_ptr->set_source(opt->arg_source->m_source);\n\n  global_system_variables.sql_mode =\n      expand_sql_mode(global_system_variables.sql_mode, nullptr);\n\n  if (!my_enable_symlinks) have_symlink = SHOW_OPTION_DISABLED;\n\n  /* Set global MyISAM variables from delay_key_write_options */\n  fix_delay_key_write(nullptr, nullptr, OPT_GLOBAL);\n\n#ifndef _WIN32\n  if (mysqld_chroot) set_root(mysqld_chroot);\n#endif\n  if (fix_paths()) return 1;\n\n  /*\n    Set some global variables from the global_system_variables\n    In most cases the global variables will not be used\n  */\n  my_disable_locking = myisam_single_user = (opt_external_locking == 0);\n  my_default_record_cache_size = global_system_variables.read_buff_size;\n\n  global_system_variables.long_query_time =\n      (ulonglong)(global_system_variables.long_query_time_double * 1e6);\n\n  init_log_slow_verbosity();\n  init_slow_query_log_use_global_control();\n  init_log_slow_sp_statements();\n\n  if (opt_short_log_format) opt_specialflag |= SPECIAL_SHORT_LOG_FORMAT;\n\n  if (Connection_handler_manager::init()) {\n    LogErr(ERROR_LEVEL, ER_CONNECTION_HANDLING_OOM);\n    return 1;\n  }\n  if (Global_THD_manager::create_instance()) {\n    LogErr(ERROR_LEVEL, ER_THREAD_HANDLING_OOM);\n    return 1;\n  }\n\n  /* If --super-read-only was specified, set read_only to 1 */\n  read_only = super_read_only ? super_read_only : read_only;\n  opt_readonly = read_only;\n\n  return 0;\n}\n\n/*\n  Create version name for running mysqld version\n  We automaticly add suffixes -debug, -valgrind, -asan, -ubsan\n  to the version name to make the version more descriptive.\n  (MYSQL_SERVER_SUFFIX is set by the compilation environment)\n*/\n\n/*\n  The following code is quite ugly as there is no portable way to easily set a\n  string to the value of a macro\n*/\n#ifdef MYSQL_SERVER_SUFFIX\n#define MYSQL_SERVER_SUFFIX_STR STRINGIFY_ARG(MYSQL_SERVER_SUFFIX)\n#else\n#define MYSQL_SERVER_SUFFIX_STR MYSQL_SERVER_SUFFIX_DEF\n#endif\n\nstatic void set_server_version(void) {\n  char *end MY_ATTRIBUTE((unused)) = strxmov(\n      server_version, MYSQL_SERVER_VERSION, MYSQL_SERVER_SUFFIX_STR, NullS);\n#ifndef DBUG_OFF\n  if (!strstr(MYSQL_SERVER_SUFFIX_STR, \"-debug\"))\n    end = my_stpcpy(end, \"-debug\");\n#endif\n#ifdef HAVE_VALGRIND\n  if (SERVER_VERSION_LENGTH - (end - server_version) >\n      static_cast<int>(sizeof(\"-valgrind\")))\n    end = my_stpcpy(end, \"-valgrind\");\n#endif\n#ifdef HAVE_ASAN\n  if (SERVER_VERSION_LENGTH - (end - server_version) >\n      static_cast<int>(sizeof(\"-asan\")))\n    end = my_stpcpy(end, \"-asan\");\n#endif\n#ifdef HAVE_LSAN\n  if (SERVER_VERSION_LENGTH - (end - server_version) >\n      static_cast<int>(sizeof(\"-lsan\")))\n    end = my_stpcpy(end, \"-lsan\");\n#endif\n#ifdef HAVE_UBSAN\n  if (SERVER_VERSION_LENGTH - (end - server_version) >\n      static_cast<int>(sizeof(\"-ubsan\")))\n    end = my_stpcpy(end, \"-ubsan\");\n#endif\n#ifdef HAVE_TSAN\n  if (SERVER_VERSION_LENGTH - (end - server_version) >\n      static_cast<int>(sizeof(\"-tsan\")))\n    end = my_stpcpy(end, \"-tsan\");\n#endif\n\n  DBUG_ASSERT(end < server_version + SERVER_VERSION_LENGTH);\n  my_stpcpy(server_version_suffix,\n            server_version + strlen(MYSQL_SERVER_VERSION));\n}\n\nstatic const char *get_relative_path(const char *path) {\n  if (test_if_hard_path(path) && is_prefix(path, DEFAULT_MYSQL_HOME) &&\n      strcmp(DEFAULT_MYSQL_HOME, FN_ROOTDIR)) {\n    path += strlen(DEFAULT_MYSQL_HOME);\n    while (is_directory_separator(*path)) path++;\n  }\n  return path;\n}\n\n/**\n  Test a file path to determine if the path is compatible with the secure file\n  path restriction.\n\n  @param path null terminated character string\n\n  @retval true The path is secure\n  @retval false The path isn't secure\n*/\n\nbool is_secure_file_path(const char *path) {\n  char buff1[FN_REFLEN], buff2[FN_REFLEN];\n  size_t opt_secure_file_priv_len;\n  /*\n    All paths are secure if opt_secure_file_priv is 0\n  */\n  if (!opt_secure_file_priv[0]) return true;\n\n  opt_secure_file_priv_len = strlen(opt_secure_file_priv);\n\n  if (strlen(path) >= FN_REFLEN) return false;\n\n  if (!my_strcasecmp(system_charset_info, opt_secure_file_priv, \"NULL\"))\n    return false;\n\n  if (my_realpath(buff1, path, 0)) {\n    /*\n      The supplied file path might have been a file and not a directory.\n    */\n    int length = (int)dirname_length(path);\n    if (length >= FN_REFLEN) return false;\n    memcpy(buff2, path, length);\n    buff2[length] = '\\0';\n    if (length == 0 || my_realpath(buff1, buff2, 0)) return false;\n  }\n  convert_dirname(buff2, buff1, NullS);\n  if (!lower_case_file_system) {\n    if (strncmp(opt_secure_file_priv, buff2, opt_secure_file_priv_len))\n      return false;\n  } else {\n    if (files_charset_info->coll->strnncoll(\n            files_charset_info, (uchar *)buff2, strlen(buff2),\n            pointer_cast<const uchar *>(opt_secure_file_priv),\n            opt_secure_file_priv_len, true))\n      return false;\n  }\n  return true;\n}\n\n/**\n  check_secure_file_priv_path : Checks path specified through\n  --secure-file-priv and raises warning in following cases:\n  1. If path is empty string or NULL and mysqld is not running\n     with --initialize (bootstrap mode).\n  2. If path can access data directory\n  3. If path points to a directory which is accessible by\n     all OS users (non-Windows build only)\n\n  It throws error in following cases:\n\n  1. If path normalization fails\n  2. If it can not get stats of the directory\n\n  Assumptions :\n  1. Data directory path has been normalized\n  2. opt_secure_file_priv has been normalized unless it is set\n     to \"NULL\".\n\n  @returns Status of validation\n    @retval true : Validation is successful with/without warnings\n    @retval false : Validation failed. Error is raised.\n*/\n\nstatic bool check_secure_file_priv_path() {\n  char datadir_buffer[FN_REFLEN + 1] = {0};\n  char plugindir_buffer[FN_REFLEN + 1] = {0};\n  char whichdir[20] = {0};\n  size_t opt_plugindir_len = 0;\n  size_t opt_datadir_len = 0;\n  size_t opt_secure_file_priv_len = 0;\n  bool warn = false;\n  bool case_insensitive_fs;\n#ifndef _WIN32\n  MY_STAT dir_stat;\n#endif\n\n  if (!opt_secure_file_priv[0]) {\n    if (opt_initialize) {\n      /*\n        Do not impose --secure-file-priv restriction\n        in bootstrap mode\n      */\n      LogErr(INFORMATION_LEVEL, ER_SEC_FILE_PRIV_IGNORED);\n    } else {\n      LogErr(WARNING_LEVEL, ER_SEC_FILE_PRIV_EMPTY);\n    }\n    return true;\n  }\n\n  /*\n    Setting --secure-file-priv to NULL would disable\n    reading/writing from/to file\n  */\n  if (!my_strcasecmp(system_charset_info, opt_secure_file_priv, \"NULL\")) {\n    LogErr(INFORMATION_LEVEL, ER_SEC_FILE_PRIV_NULL);\n    return true;\n  }\n\n  /*\n    Check if --secure-file-priv can access data directory\n  */\n  opt_secure_file_priv_len = strlen(opt_secure_file_priv);\n\n  /*\n    Adds dir seperator at the end.\n    This is required in subsequent comparison\n  */\n  convert_dirname(datadir_buffer, mysql_unpacked_real_data_home, NullS);\n  opt_datadir_len = strlen(datadir_buffer);\n\n  case_insensitive_fs = (test_if_case_insensitive(datadir_buffer) == 1);\n\n  if (!case_insensitive_fs) {\n    if (!strncmp(datadir_buffer, opt_secure_file_priv,\n                 opt_datadir_len < opt_secure_file_priv_len\n                     ? opt_datadir_len\n                     : opt_secure_file_priv_len)) {\n      warn = true;\n      strcpy(whichdir, \"Data directory\");\n    }\n  } else {\n    if (!files_charset_info->coll->strnncoll(\n            files_charset_info, (uchar *)datadir_buffer, opt_datadir_len,\n            pointer_cast<const uchar *>(opt_secure_file_priv),\n            opt_secure_file_priv_len, true)) {\n      warn = true;\n      strcpy(whichdir, \"Data directory\");\n    }\n  }\n\n  /*\n    Don't bother comparing --secure-file-priv with --plugin-dir\n    if we already have a match against --datdir or\n    --plugin-dir is not pointing to a valid directory.\n  */\n  if (!warn && !my_realpath(plugindir_buffer, opt_plugin_dir, 0)) {\n    convert_dirname(plugindir_buffer, plugindir_buffer, NullS);\n    opt_plugindir_len = strlen(plugindir_buffer);\n\n    if (!case_insensitive_fs) {\n      if (!strncmp(plugindir_buffer, opt_secure_file_priv,\n                   opt_plugindir_len < opt_secure_file_priv_len\n                       ? opt_plugindir_len\n                       : opt_secure_file_priv_len)) {\n        warn = true;\n        strcpy(whichdir, \"Plugin directory\");\n      }\n    } else {\n      if (!files_charset_info->coll->strnncoll(\n              files_charset_info, (uchar *)plugindir_buffer, opt_plugindir_len,\n              pointer_cast<const uchar *>(opt_secure_file_priv),\n              opt_secure_file_priv_len, true)) {\n        warn = true;\n        strcpy(whichdir, \"Plugin directory\");\n      }\n    }\n  }\n\n  if (warn)\n    LogErr(WARNING_LEVEL, ER_SEC_FILE_PRIV_DIRECTORY_INSECURE, whichdir);\n\n#ifndef _WIN32\n  /*\n     Check for --secure-file-priv directory's permission\n  */\n  if (!(my_stat(opt_secure_file_priv, &dir_stat, MYF(0)))) {\n    LogErr(ERROR_LEVEL, ER_SEC_FILE_PRIV_CANT_STAT);\n    return false;\n  }\n\n  if (dir_stat.st_mode & S_IRWXO)\n    LogErr(WARNING_LEVEL, ER_SEC_FILE_PRIV_DIRECTORY_PERMISSIONS);\n#endif\n  return true;\n}\n\nstatic int fix_paths(void) {\n  char buff[FN_REFLEN];\n  bool secure_file_priv_nonempty = false;\n  convert_dirname(mysql_home, mysql_home, NullS);\n  /* Resolve symlinks to allow 'mysql_home' to be a relative symlink */\n  my_realpath(mysql_home, mysql_home, MYF(0));\n  /* Ensure that mysql_home ends in FN_LIBCHAR */\n  char *pos = strend(mysql_home);\n  if (pos == mysql_home || pos[-1] != FN_LIBCHAR) {\n    pos[0] = FN_LIBCHAR;\n    pos[1] = 0;\n  }\n  convert_dirname(lc_messages_dir, lc_messages_dir, NullS);\n  convert_dirname(mysql_real_data_home, mysql_real_data_home, NullS);\n  (void)my_load_path(mysql_home, mysql_home, \"\");  // Resolve current dir\n  (void)my_load_path(mysql_real_data_home, mysql_real_data_home, mysql_home);\n  (void)my_load_path(pidfile_name, pidfile_name_ptr, mysql_real_data_home);\n\n  convert_dirname(\n      opt_plugin_dir,\n      opt_plugin_dir_ptr ? opt_plugin_dir_ptr : get_relative_path(PLUGINDIR),\n      NullS);\n  (void)my_load_path(opt_plugin_dir, opt_plugin_dir, mysql_home);\n  opt_plugin_dir_ptr = opt_plugin_dir;\n\n  my_realpath(mysql_unpacked_real_data_home, mysql_real_data_home, MYF(0));\n  mysql_unpacked_real_data_home_len = strlen(mysql_unpacked_real_data_home);\n  if (mysql_unpacked_real_data_home[mysql_unpacked_real_data_home_len - 1] ==\n      FN_LIBCHAR)\n    --mysql_unpacked_real_data_home_len;\n\n  const char *sharedir = get_relative_path(SHAREDIR);\n  if (test_if_hard_path(sharedir))\n    strmake(buff, sharedir, sizeof(buff) - 1); /* purecov: tested */\n  else\n    strxnmov(buff, sizeof(buff) - 1, mysql_home, sharedir, NullS);\n  convert_dirname(buff, buff, NullS);\n  (void)my_load_path(lc_messages_dir, lc_messages_dir, buff);\n\n  /* If --character-sets-dir isn't given, use shared library dir */\n  if (charsets_dir)\n    strmake(mysql_charsets_dir, charsets_dir, sizeof(mysql_charsets_dir) - 1);\n  else\n    strxnmov(mysql_charsets_dir, sizeof(mysql_charsets_dir) - 1, buff,\n             CHARSET_DIR, NullS);\n  (void)my_load_path(mysql_charsets_dir, mysql_charsets_dir, buff);\n  convert_dirname(mysql_charsets_dir, mysql_charsets_dir, NullS);\n  charsets_dir = mysql_charsets_dir;\n\n  if (init_tmpdir(&mysql_tmpdir_list, opt_mysql_tmpdir)) return 1;\n  if (!opt_mysql_tmpdir) opt_mysql_tmpdir = mysql_tmpdir;\n  if (!slave_load_tmpdir) slave_load_tmpdir = mysql_tmpdir;\n\n  if (opt_help) return 0;\n  /*\n    Convert the secure-file-priv option to system format, allowing\n    a quick strcmp to check if read or write is in an allowed dir\n  */\n  if (opt_initialize) opt_secure_file_priv = \"\";\n  secure_file_priv_nonempty = opt_secure_file_priv[0] ? true : false;\n\n  if (secure_file_priv_nonempty && strlen(opt_secure_file_priv) > FN_REFLEN) {\n    LogErr(WARNING_LEVEL, ER_SEC_FILE_PRIV_ARGUMENT_TOO_LONG, FN_REFLEN - 1);\n    return 1;\n  }\n\n  memset(buff, 0, sizeof(buff));\n  if (secure_file_priv_nonempty &&\n      my_strcasecmp(system_charset_info, opt_secure_file_priv, \"NULL\")) {\n    int retval = my_realpath(buff, opt_secure_file_priv, MYF(MY_WME));\n    if (!retval) {\n      convert_dirname(secure_file_real_path, buff, NullS);\n#ifdef WIN32\n      MY_DIR *dir = my_dir(secure_file_real_path, MYF(MY_DONT_SORT + MY_WME));\n      if (!dir) {\n        retval = 1;\n      } else {\n        my_dirend(dir);\n      }\n#endif\n    }\n\n    if (retval) {\n      LogErr(ERROR_LEVEL, ER_SEC_FILE_PRIV_CANT_ACCESS_DIR,\n             opt_secure_file_priv);\n      return 1;\n    }\n    opt_secure_file_priv = secure_file_real_path;\n  }\n\n  if (!check_secure_file_priv_path()) return 1;\n\n  return 0;\n}\n\n/**\n  Check if file system used for databases is case insensitive.\n\n  @param dir_name     Directory to test\n\n  @retval\n    -1  Don't know (Test failed)\n  @retval\n    0   File system is case sensitive\n  @retval\n    1   File system is case insensitive\n*/\n\nstatic int test_if_case_insensitive(const char *dir_name) {\n  int result = 0;\n  File file;\n  char buff[FN_REFLEN], buff2[FN_REFLEN];\n  MY_STAT stat_info;\n  const char *const tmp_file_name = \"mysqld_tmp_file_case_insensitive_test\";\n  DBUG_TRACE;\n\n  fn_format(buff, tmp_file_name, dir_name, \".lower-test\",\n            MY_UNPACK_FILENAME | MY_REPLACE_EXT | MY_REPLACE_DIR);\n  fn_format(buff2, tmp_file_name, dir_name, \".LOWER-TEST\",\n            MY_UNPACK_FILENAME | MY_REPLACE_EXT | MY_REPLACE_DIR);\n  mysql_file_delete(key_file_casetest, buff2, MYF(0));\n  if ((file = mysql_file_create(key_file_casetest, buff, 0666, O_RDWR,\n                                MYF(0))) < 0) {\n    LogErr(WARNING_LEVEL, ER_CANT_CREATE_TEST_FILE, buff);\n    return -1;\n  }\n  mysql_file_close(file, MYF(0));\n  if (mysql_file_stat(key_file_casetest, buff2, &stat_info, MYF(0)))\n    result = 1;  // Can access file\n  mysql_file_delete(key_file_casetest, buff, MYF(MY_WME));\n  DBUG_PRINT(\"exit\", (\"result: %d\", result));\n  return result;\n}\n\n/**\n  Create file to store pid number.\n*/\nstatic bool create_pid_file() {\n  File file;\n  bool check_parent_path = true, is_path_accessible = true;\n  char pid_filepath[FN_REFLEN], *pos = nullptr;\n  /* Copy pid file name to get pid file path */\n  strcpy(pid_filepath, pidfile_name);\n\n  /* Iterate through the entire path to check if even one of the sub-dirs\n     is world-writable */\n  while (check_parent_path && (pos = strrchr(pid_filepath, FN_LIBCHAR)) &&\n         (pos != pid_filepath)) /* shouldn't check root */\n  {\n    *pos = '\\0'; /* Trim the inner-most dir */\n    switch (is_file_or_dir_world_writable(pid_filepath)) {\n      case -2:\n        is_path_accessible = false;\n        break;\n      case -1:\n        LogErr(ERROR_LEVEL, ER_CANT_CHECK_PID_PATH, strerror(errno));\n        exit(MYSQLD_ABORT_EXIT);\n      case 1:\n        LogErr(WARNING_LEVEL, ER_PID_FILE_PRIV_DIRECTORY_INSECURE,\n               pid_filepath);\n        check_parent_path = false;\n        break;\n      case 0:\n        continue; /* Keep checking the parent dir */\n    }\n  }\n  if (!is_path_accessible) {\n    LogErr(WARNING_LEVEL, ER_PID_FILEPATH_LOCATIONS_INACCESSIBLE);\n  }\n  if ((file = mysql_file_create(key_file_pid, pidfile_name, 0664,\n                                O_WRONLY | O_TRUNC, MYF(MY_WME))) >= 0) {\n    char buff[MAX_BIGINT_WIDTH + 1], *end;\n    end = longlong10_to_str(getpid(), buff, -10);\n    *end++ = '\\n';\n    if (!mysql_file_write(file, (uchar *)buff, (uint)(end - buff),\n                          MYF(MY_WME | MY_NABP))) {\n      mysql_file_close(file, MYF(0));\n      pid_file_created = true;\n      return false;\n    }\n    mysql_file_close(file, MYF(0));\n  }\n  LogErr(ERROR_LEVEL, ER_CANT_CREATE_PID_FILE, strerror(errno));\n  return true;\n}\n\n/**\n  Remove the process' pid file.\n\n  @param  flags  file operation flags\n*/\n\nstatic void delete_pid_file(myf flags) {\n  File file;\n  if (opt_initialize || !pid_file_created ||\n      !(file = mysql_file_open(key_file_pid, pidfile_name, O_RDONLY, flags)))\n    return;\n\n  if (file == -1) {\n    LogErr(INFORMATION_LEVEL, ER_CANT_REMOVE_PID_FILE, strerror(errno));\n    return;\n  }\n\n  uchar buff[MAX_BIGINT_WIDTH + 1];\n  /* Make sure that the pid file was created by the same process. */\n  size_t error = mysql_file_read(file, buff, sizeof(buff), flags);\n  mysql_file_close(file, flags);\n  buff[sizeof(buff) - 1] = '\\0';\n  if (error != MY_FILE_ERROR && atol((char *)buff) == (long)getpid()) {\n    mysql_file_delete(key_file_pid, pidfile_name, flags);\n    pid_file_created = false;\n  }\n  return;\n}\n\n/**\n  Delete mysql.ibd after aborting upgrade.\n*/\nstatic void delete_dictionary_tablespace() {\n  char path[FN_REFLEN + 1];\n  bool not_used;\n\n  build_table_filename(path, sizeof(path) - 1, \"\", \"mysql\", \".ibd\", 0,\n                       &not_used);\n  (void)mysql_file_delete(key_file_misc, path, MYF(MY_WME));\n\n  // Drop file which tracks progress of upgrade.\n  dd::upgrade_57::Upgrade_status().remove();\n}\n\n/**\n  Returns the current state of the server : booting, operational or shutting\n  down.\n\n  @return\n    SERVER_BOOTING        Server is not operational. It is starting.\n    SERVER_OPERATING      Server is fully initialized and operating.\n    SERVER_SHUTTING_DOWN  Server is shutting down.\n*/\nenum_server_operational_state get_server_state() {\n  return server_operational_state;\n}\n\n/**\n  Reset status for all threads.\n*/\nclass Reset_thd_status : public Do_THD_Impl {\n public:\n  Reset_thd_status() {}\n  virtual void operator()(THD *thd) {\n    /* Update the global status if not done so already. */\n    if (!thd->status_var_aggregated) {\n      add_to_status(&global_status_var, &thd->status_var);\n    }\n    reset_system_status_vars(&thd->status_var);\n  }\n};\n\n/**\n  Reset global and session status variables.\n*/\nvoid refresh_status() {\n  mysql_mutex_lock(&LOCK_status);\n\n  /* For all threads, add status to global status and then reset. */\n  Reset_thd_status reset_thd_status;\n  Global_THD_manager::get_instance()->do_for_all_thd_copy(&reset_thd_status);\n#ifdef WITH_PERFSCHEMA_STORAGE_ENGINE\n  /* Reset aggregated status counters. */\n  reset_pfs_status_stats();\n#endif\n\n  /* Reset some global variables. */\n  reset_status_vars();\n\n  /* Reset the counters of all key caches (default and named). */\n  process_key_caches(reset_key_cache_counters);\n  flush_status_time = time((time_t *)nullptr);\n  mysql_mutex_unlock(&LOCK_status);\n\n  /*\n    Set max_used_connections to the number of currently open\n    connections.  Do this out of LOCK_status to avoid deadlocks.\n    Status reset becomes not atomic, but status data is not exact anyway.\n  */\n  Connection_handler_manager::reset_max_used_connections();\n}\n\n/*****************************************************************************\n  Instantiate variables for missing storage engines\n  This section should go away soon\n*****************************************************************************/\n\n#ifdef HAVE_PSI_INTERFACE\nPSI_mutex_key key_LOCK_tc;\nPSI_mutex_key key_hash_filo_lock;\nPSI_mutex_key key_LOCK_error_log;\nPSI_mutex_key key_LOCK_thd_data;\nPSI_mutex_key key_LOCK_thd_sysvar;\nPSI_mutex_key key_LOCK_thd_protocol;\nPSI_mutex_key key_LOG_LOCK_log;\nPSI_mutex_key key_master_info_data_lock;\nPSI_mutex_key key_master_info_run_lock;\nPSI_mutex_key key_master_info_sleep_lock;\nPSI_mutex_key key_master_info_thd_lock;\nPSI_mutex_key key_master_info_rotate_lock;\nPSI_mutex_key key_mutex_slave_reporting_capability_err_lock;\nPSI_mutex_key key_relay_log_info_data_lock;\nPSI_mutex_key key_relay_log_info_sleep_lock;\nPSI_mutex_key key_relay_log_info_thd_lock;\nPSI_mutex_key key_relay_log_info_log_space_lock;\nPSI_mutex_key key_relay_log_info_run_lock;\nPSI_mutex_key key_mutex_slave_parallel_pend_jobs;\nPSI_mutex_key key_mutex_slave_parallel_worker_count;\nPSI_mutex_key key_mutex_slave_parallel_worker;\nPSI_mutex_key key_structure_guard_mutex;\nPSI_mutex_key key_TABLE_SHARE_LOCK_ha_data;\nPSI_mutex_key key_LOCK_query_plan;\nPSI_mutex_key key_LOCK_thd_query;\nPSI_mutex_key key_LOCK_cost_const;\nPSI_mutex_key key_LOCK_current_cond;\nPSI_mutex_key key_LOCK_temporary_tables;\nPSI_mutex_key key_LOCK_global_user_client_stats;\nPSI_mutex_key key_LOCK_global_table_stats;\nPSI_mutex_key key_LOCK_global_index_stats;\nPSI_mutex_key key_RELAYLOG_LOCK_commit;\nPSI_mutex_key key_RELAYLOG_LOCK_commit_queue;\nPSI_mutex_key key_RELAYLOG_LOCK_done;\nPSI_mutex_key key_RELAYLOG_LOCK_flush_queue;\nPSI_mutex_key key_RELAYLOG_LOCK_index;\nPSI_mutex_key key_RELAYLOG_LOCK_log;\nPSI_mutex_key key_RELAYLOG_LOCK_log_end_pos;\nPSI_mutex_key key_RELAYLOG_LOCK_sync;\nPSI_mutex_key key_RELAYLOG_LOCK_sync_queue;\nPSI_mutex_key key_RELAYLOG_LOCK_xids;\nPSI_mutex_key key_gtid_ensure_index_mutex;\nPSI_mutex_key key_object_cache_mutex;  // TODO need to initialize\nPSI_cond_key key_object_loading_cond;  // TODO need to initialize\nPSI_mutex_key key_mts_temp_table_LOCK;\nPSI_mutex_key key_mts_gaq_LOCK;\nPSI_mutex_key key_thd_timer_mutex;\nPSI_mutex_key key_commit_order_manager_mutex;\nPSI_mutex_key key_mutex_slave_worker_hash;\n\n/* clang-format off */\nstatic PSI_mutex_info all_server_mutexes[]=\n{\n  { &key_LOCK_tc, \"TC_LOG_MMAP::LOCK_tc\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_BINLOG_LOCK_commit, \"MYSQL_BIN_LOG::LOCK_commit\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_BINLOG_LOCK_commit_queue, \"MYSQL_BIN_LOG::LOCK_commit_queue\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_BINLOG_LOCK_done, \"MYSQL_BIN_LOG::LOCK_done\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_BINLOG_LOCK_flush_queue, \"MYSQL_BIN_LOG::LOCK_flush_queue\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_BINLOG_LOCK_index, \"MYSQL_BIN_LOG::LOCK_index\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_BINLOG_LOCK_log, \"MYSQL_BIN_LOG::LOCK_log\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_BINLOG_LOCK_binlog_end_pos, \"MYSQL_BIN_LOG::LOCK_binlog_end_pos\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_BINLOG_LOCK_sync, \"MYSQL_BIN_LOG::LOCK_sync\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_BINLOG_LOCK_sync_queue, \"MYSQL_BIN_LOG::LOCK_sync_queue\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_BINLOG_LOCK_xids, \"MYSQL_BIN_LOG::LOCK_xids\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_RELAYLOG_LOCK_commit, \"MYSQL_RELAY_LOG::LOCK_commit\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_RELAYLOG_LOCK_commit_queue, \"MYSQL_RELAY_LOG::LOCK_commit_queue\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_RELAYLOG_LOCK_done, \"MYSQL_RELAY_LOG::LOCK_done\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_RELAYLOG_LOCK_flush_queue, \"MYSQL_RELAY_LOG::LOCK_flush_queue\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_RELAYLOG_LOCK_index, \"MYSQL_RELAY_LOG::LOCK_index\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_RELAYLOG_LOCK_log, \"MYSQL_RELAY_LOG::LOCK_log\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_RELAYLOG_LOCK_log_end_pos, \"MYSQL_RELAY_LOG::LOCK_log_end_pos\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_RELAYLOG_LOCK_sync, \"MYSQL_RELAY_LOG::LOCK_sync\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_RELAYLOG_LOCK_sync_queue, \"MYSQL_RELAY_LOG::LOCK_sync_queue\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_RELAYLOG_LOCK_xids, \"MYSQL_RELAY_LOG::LOCK_xids\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_hash_filo_lock, \"hash_filo::lock\", 0, 0, PSI_DOCUMENT_ME},\n  { &Gtid_set::key_gtid_executed_free_intervals_mutex, \"Gtid_set::gtid_executed::free_intervals_mutex\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_LOCK_bloom_filter, \"Bloom_filter\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_LOCK_crypt, \"LOCK_crypt\", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},\n  { &key_LOCK_error_log, \"LOCK_error_log\", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},\n  { &key_LOCK_global_system_variables, \"LOCK_global_system_variables\", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},\n#if defined(_WIN32)\n  { &key_LOCK_handler_count, \"LOCK_handler_count\", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},\n  { &key_LOCK_global_user_client_stats,\n    \"LOCK_global_user_client_stats\", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},\n  { &key_LOCK_global_table_stats,\n    \"LOCK_global_table_stats\", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},\n  { &key_LOCK_global_index_stats,\n    \"LOCK_global_index_stats\", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},\n#endif\n  { &key_LOCK_manager, \"LOCK_manager\", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},\n  { &key_LOCK_prepared_stmt_count, \"LOCK_prepared_stmt_count\", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},\n  { &key_LOCK_sql_slave_skip_counter, \"LOCK_sql_slave_skip_counter\", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},\n  { &key_LOCK_slave_net_timeout, \"LOCK_slave_net_timeout\", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},\n  { &key_LOCK_slave_trans_dep_tracker, \"LOCK_slave_trans_dep_tracker\", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},\n  { &key_LOCK_server_started, \"LOCK_server_started\", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},\n#if !defined(_WIN32)\n  { &key_LOCK_socket_listener_active, \"LOCK_socket_listener_active\", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},\n  { &key_LOCK_start_signal_handler, \"LOCK_start_signal_handler\", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},\n#endif\n  { &key_LOCK_status, \"LOCK_status\", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},\n  { &key_LOCK_thd_data, \"THD::LOCK_thd_data\", 0, PSI_VOLATILITY_SESSION, PSI_DOCUMENT_ME},\n  { &key_LOCK_thd_query, \"THD::LOCK_thd_query\", 0, PSI_VOLATILITY_SESSION, PSI_DOCUMENT_ME},\n  { &key_LOCK_thd_sysvar, \"THD::LOCK_thd_sysvar\", 0, PSI_VOLATILITY_SESSION, PSI_DOCUMENT_ME},\n  { &key_LOCK_thd_protocol, \"THD::LOCK_thd_protocol\", 0, PSI_VOLATILITY_SESSION, PSI_DOCUMENT_ME},\n  { &key_LOCK_user_conn, \"LOCK_user_conn\", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},\n  { &key_LOCK_uuid_generator, \"LOCK_uuid_generator\", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},\n  { &key_LOCK_sql_rand, \"LOCK_sql_rand\", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},\n  { &key_LOG_LOCK_log, \"LOG::LOCK_log\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_master_info_data_lock, \"Master_info::data_lock\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_master_info_run_lock, \"Master_info::run_lock\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_master_info_sleep_lock, \"Master_info::sleep_lock\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_master_info_thd_lock, \"Master_info::info_thd_lock\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_master_info_rotate_lock, \"Master_info::rotate_lock\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_mutex_slave_reporting_capability_err_lock, \"Slave_reporting_capability::err_lock\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_relay_log_info_data_lock, \"Relay_log_info::data_lock\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_relay_log_info_sleep_lock, \"Relay_log_info::sleep_lock\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_relay_log_info_thd_lock, \"Relay_log_info::info_thd_lock\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_relay_log_info_log_space_lock, \"Relay_log_info::log_space_lock\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_relay_log_info_run_lock, \"Relay_log_info::run_lock\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_mutex_slave_parallel_pend_jobs, \"Relay_log_info::pending_jobs_lock\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_mutex_slave_parallel_worker_count, \"Relay_log_info::exit_count_lock\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_mutex_slave_parallel_worker, \"Worker_info::jobs_lock\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_TABLE_SHARE_LOCK_ha_data, \"TABLE_SHARE::LOCK_ha_data\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_LOCK_error_messages, \"LOCK_error_messages\", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},\n  { &key_LOCK_log_throttle_qni, \"LOCK_log_throttle_qni\", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},\n  { &key_gtid_ensure_index_mutex, \"Gtid_state\", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},\n  { &key_LOCK_query_plan, \"THD::LOCK_query_plan\", 0, PSI_VOLATILITY_SESSION, PSI_DOCUMENT_ME},\n  { &key_LOCK_cost_const, \"Cost_constant_cache::LOCK_cost_const\", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},\n  { &key_LOCK_current_cond, \"THD::LOCK_current_cond\", 0, PSI_VOLATILITY_SESSION, PSI_DOCUMENT_ME},\n  { &key_mts_temp_table_LOCK, \"key_mts_temp_table_LOCK\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_LOCK_reset_gtid_table, \"LOCK_reset_gtid_table\", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},\n  { &key_LOCK_compress_gtid_table, \"LOCK_compress_gtid_table\", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},\n  { &key_LOCK_collect_instance_log, \"LOCK_collect_instance_log\", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},\n  { &key_mts_gaq_LOCK, \"key_mts_gaq_LOCK\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_thd_timer_mutex, \"thd_timer_mutex\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_commit_order_manager_mutex, \"Commit_order_manager::m_mutex\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_mutex_slave_worker_hash, \"Relay_log_info::slave_worker_hash_lock\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_LOCK_default_password_lifetime, \"LOCK_default_password_lifetime\", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},\n  { &key_LOCK_mandatory_roles, \"LOCK_mandatory_roles\", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},\n  { &key_LOCK_password_history, \"LOCK_password_history\", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},\n  { &key_LOCK_password_reuse_interval, \"LOCK_password_reuse_interval\", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},\n  { &key_LOCK_keyring_operations, \"LOCK_keyring_operations\", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},\n  { &key_LOCK_tls_ctx_options, \"LOCK_tls_ctx_options\", 0, 0, \"A lock to control all of the --ssl-* CTX related command line options\"},\n  { &key_LOCK_rotate_binlog_master_key, \"LOCK_rotate_binlog_master_key\", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME}\n};\n/* clang-format on */\n\nPSI_rwlock_key key_rwlock_LOCK_logger;\nPSI_rwlock_key key_rwlock_channel_map_lock;\nPSI_rwlock_key key_rwlock_channel_lock;\nPSI_rwlock_key key_rwlock_receiver_sid_lock;\nPSI_rwlock_key key_rwlock_rpl_filter_lock;\nPSI_rwlock_key key_rwlock_channel_to_filter_lock;\nPSI_rwlock_key key_rwlock_LOCK_consistent_snapshot;\nPSI_rwlock_key key_rwlock_Trans_delegate_lock;\nPSI_rwlock_key key_rwlock_Server_state_delegate_lock;\nPSI_rwlock_key key_rwlock_Binlog_storage_delegate_lock;\nPSI_rwlock_key key_rwlock_Binlog_transmit_delegate_lock;\nPSI_rwlock_key key_rwlock_Binlog_relay_IO_delegate_lock;\nPSI_rwlock_key key_rwlock_resource_group_mgr_map_lock;\n\n/* clang-format off */\nstatic PSI_rwlock_info all_server_rwlocks[]=\n{\n  { &key_rwlock_Binlog_transmit_delegate_lock, \"Binlog_transmit_delegate::lock\", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},\n  { &key_rwlock_Binlog_relay_IO_delegate_lock, \"Binlog_relay_IO_delegate::lock\", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},\n  { &key_rwlock_LOCK_logger, \"LOGGER::LOCK_logger\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_rwlock_LOCK_sys_init_connect, \"LOCK_sys_init_connect\", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},\n  { &key_rwlock_LOCK_sys_init_slave, \"LOCK_sys_init_slave\", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},\n  { &key_rwlock_LOCK_system_variables_hash, \"LOCK_system_variables_hash\", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},\n  { &key_rwlock_global_sid_lock, \"gtid_commit_rollback\", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},\n  { &key_rwlock_gtid_mode_lock, \"gtid_mode_lock\", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},\n  { &key_rwlock_channel_map_lock, \"channel_map_lock\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_rwlock_channel_lock, \"channel_lock\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_rwlock_Trans_delegate_lock, \"Trans_delegate::lock\", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},\n  { &key_rwlock_Server_state_delegate_lock, \"Server_state_delegate::lock\", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},\n  { &key_rwlock_Binlog_storage_delegate_lock, \"Binlog_storage_delegate::lock\", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},\n  { &key_rwlock_receiver_sid_lock, \"gtid_retrieved\", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},\n  { &key_rwlock_rpl_filter_lock, \"rpl_filter_lock\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_rwlock_channel_to_filter_lock, \"channel_to_filter_lock\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_rwlock_resource_group_mgr_map_lock, \"Resource_group_mgr::m_map_rwlock\", 0, 0, PSI_DOCUMENT_ME},\n#ifdef _WIN32\n  { &key_rwlock_LOCK_named_pipe_full_access_group, \"LOCK_named_pipe_full_access_group\", PSI_FLAG_SINGLETON, 0,\n    \"This lock protects named pipe security attributes, preventing their \"\n    \"simultaneous application and modification.\"},\n#endif // _WIN32\n  { &key_rwlock_LOCK_consistent_snapshot, \"LOCK_consistent_snapshot\", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME}\n};\n/* clang-format on */\n\nPSI_cond_key key_PAGE_cond;\nPSI_cond_key key_COND_active;\nPSI_cond_key key_COND_pool;\nPSI_cond_key key_COND_cache_status_changed;\nPSI_cond_key key_item_func_sleep_cond;\nPSI_cond_key key_master_info_data_cond;\nPSI_cond_key key_master_info_start_cond;\nPSI_cond_key key_master_info_stop_cond;\nPSI_cond_key key_master_info_sleep_cond;\nPSI_cond_key key_master_info_rotate_cond;\nPSI_cond_key key_relay_log_info_data_cond;\nPSI_cond_key key_relay_log_info_log_space_cond;\nPSI_cond_key key_relay_log_info_start_cond;\nPSI_cond_key key_relay_log_info_stop_cond;\nPSI_cond_key key_relay_log_info_sleep_cond;\nPSI_cond_key key_cond_slave_parallel_pend_jobs;\nPSI_cond_key key_cond_slave_parallel_worker;\nPSI_cond_key key_cond_mts_gaq;\nPSI_cond_key key_RELAYLOG_update_cond;\nPSI_cond_key key_RELAYLOG_COND_done;\nPSI_cond_key key_RELAYLOG_prep_xids_cond;\nPSI_cond_key key_gtid_ensure_index_cond;\nPSI_cond_key key_COND_thr_lock;\nPSI_cond_key key_commit_order_manager_cond;\nPSI_cond_key key_cond_slave_worker_hash;\n\n/* clang-format off */\nstatic PSI_cond_info all_server_conds[]=\n{\n  { &key_PAGE_cond, \"PAGE::cond\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_COND_active, \"TC_LOG_MMAP::COND_active\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_COND_pool, \"TC_LOG_MMAP::COND_pool\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_BINLOG_COND_done, \"MYSQL_BIN_LOG::COND_done\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_BINLOG_update_cond, \"MYSQL_BIN_LOG::update_cond\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_BINLOG_prep_xids_cond, \"MYSQL_BIN_LOG::prep_xids_cond\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_RELAYLOG_COND_done, \"MYSQL_RELAY_LOG::COND_done\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_RELAYLOG_update_cond, \"MYSQL_RELAY_LOG::update_cond\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_RELAYLOG_prep_xids_cond, \"MYSQL_RELAY_LOG::prep_xids_cond\", 0, 0, PSI_DOCUMENT_ME},\n#if defined(_WIN32)\n  { &key_COND_handler_count, \"COND_handler_count\", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},\n#endif\n  { &key_COND_manager, \"COND_manager\", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},\n  { &key_COND_server_started, \"COND_server_started\", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},\n#if !defined(_WIN32)\n  { &key_COND_socket_listener_active, \"COND_socket_listener_active\", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},\n  { &key_COND_start_signal_handler, \"COND_start_signal_handler\", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},\n#endif\n  { &key_COND_thr_lock, \"COND_thr_lock\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_item_func_sleep_cond, \"Item_func_sleep::cond\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_master_info_data_cond, \"Master_info::data_cond\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_master_info_start_cond, \"Master_info::start_cond\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_master_info_stop_cond, \"Master_info::stop_cond\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_master_info_sleep_cond, \"Master_info::sleep_cond\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_master_info_rotate_cond, \"Master_info::rotate_cond\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_relay_log_info_data_cond, \"Relay_log_info::data_cond\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_relay_log_info_log_space_cond, \"Relay_log_info::log_space_cond\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_relay_log_info_start_cond, \"Relay_log_info::start_cond\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_relay_log_info_stop_cond, \"Relay_log_info::stop_cond\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_relay_log_info_sleep_cond, \"Relay_log_info::sleep_cond\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_cond_slave_parallel_pend_jobs, \"Relay_log_info::pending_jobs_cond\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_cond_slave_parallel_worker, \"Worker_info::jobs_cond\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_cond_mts_gaq, \"Relay_log_info::mts_gaq_cond\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_gtid_ensure_index_cond, \"Gtid_state\", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},\n  { &key_COND_compress_gtid_table, \"COND_compress_gtid_table\", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},\n  { &key_commit_order_manager_cond, \"Commit_order_manager::m_workers.cond\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_cond_slave_worker_hash, \"Relay_log_info::slave_worker_hash_lock\", 0, 0, PSI_DOCUMENT_ME}\n};\n/* clang-format on */\n\nPSI_thread_key key_thread_bootstrap;\nPSI_thread_key key_thread_handle_manager;\nPSI_thread_key key_thread_one_connection;\nPSI_thread_key key_thread_compress_gtid_table;\nPSI_thread_key key_thread_parser_service;\nPSI_thread_key key_thread_handle_con_admin_sockets;\n\n/* clang-format off */\nstatic PSI_thread_info all_server_threads[]=\n{\n#if defined (_WIN32)\n  { &key_thread_handle_con_namedpipes, \"con_named_pipes\", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},\n  { &key_thread_handle_con_sharedmem, \"con_shared_mem\", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},\n  { &key_thread_handle_con_sockets, \"con_sockets\", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},\n  { &key_thread_handle_shutdown_restart, \"shutdown_restart\", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},\n#endif /* _WIN32 */\n  { &key_thread_bootstrap, \"bootstrap\", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},\n  { &key_thread_handle_manager, \"manager\", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},\n  { &key_thread_main, \"main\", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},\n  { &key_thread_one_connection, \"one_connection\", PSI_FLAG_USER, 0, PSI_DOCUMENT_ME},\n  { &key_thread_signal_hand, \"signal_handler\", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},\n  { &key_thread_compress_gtid_table, \"compress_gtid_table\", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},\n  { &key_thread_parser_service, \"parser_service\", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},\n  { &key_thread_handle_con_admin_sockets, \"admin_interface\", PSI_FLAG_USER, 0, PSI_DOCUMENT_ME},\n};\n/* clang-format on */\n\nPSI_file_key key_file_binlog;\nPSI_file_key key_file_binlog_index;\nPSI_file_key key_file_dbopt;\nPSI_file_key key_file_ERRMSG;\nPSI_file_key key_select_to_file;\nPSI_file_key key_file_fileparser;\nPSI_file_key key_file_frm;\nPSI_file_key key_file_load;\nPSI_file_key key_file_loadfile;\nPSI_file_key key_file_log_event_data;\nPSI_file_key key_file_log_event_info;\nPSI_file_key key_file_misc;\nPSI_file_key key_file_tclog;\nPSI_file_key key_file_trg;\nPSI_file_key key_file_trn;\nPSI_file_key key_file_init;\nPSI_file_key key_file_general_log;\nPSI_file_key key_file_slow_log;\nPSI_file_key key_file_relaylog;\nPSI_file_key key_file_relaylog_cache;\nPSI_file_key key_file_relaylog_index;\nPSI_file_key key_file_relaylog_index_cache;\nPSI_file_key key_file_sdi;\nPSI_file_key key_file_hash_join;\n\n/* clang-format off */\nstatic PSI_file_info all_server_files[]=\n{\n  { &key_file_binlog, \"binlog\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_file_binlog_cache, \"binlog_cache\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_file_binlog_index, \"binlog_index\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_file_binlog_index_cache, \"binlog_index_cache\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_file_relaylog, \"relaylog\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_file_relaylog_cache, \"relaylog_cache\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_file_relaylog_index, \"relaylog_index\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_file_relaylog_index_cache, \"relaylog_index_cache\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_file_io_cache, \"io_cache\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_file_casetest, \"casetest\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_file_dbopt, \"dbopt\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_file_ERRMSG, \"ERRMSG\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_select_to_file, \"select_to_file\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_file_fileparser, \"file_parser\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_file_frm, \"FRM\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_file_load, \"load\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_file_loadfile, \"LOAD_FILE\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_file_log_event_data, \"log_event_data\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_file_log_event_info, \"log_event_info\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_file_misc, \"misc\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_file_pid, \"pid\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_file_general_log, \"query_log\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_file_slow_log, \"slow_log\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_file_tclog, \"tclog\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_file_trg, \"trigger_name\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_file_trn, \"trigger\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_file_init, \"init\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_file_sdi, \"SDI\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_file_hash_join, \"hash_join\", 0, 0, PSI_DOCUMENT_ME}\n};\n/* clang-format on */\n#endif /* HAVE_PSI_INTERFACE */\n\n/* clang-format off */\nPSI_stage_info stage_after_create= { 0, \"After create\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_alter_inplace_prepare= { 0, \"preparing for alter table\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_alter_inplace= { 0, \"altering table\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_alter_inplace_commit= { 0, \"committing alter table to storage engine\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_changing_master= { 0, \"Changing master\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_checking_master_version= { 0, \"Checking master version\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_checking_permissions= { 0, \"checking permissions\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_cleaning_up= { 0, \"cleaning up\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_closing_tables= { 0, \"closing tables\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_compressing_gtid_table= { 0, \"Compressing gtid_executed table\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_connecting_to_master= { 0, \"Connecting to master\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_converting_heap_to_ondisk= { 0, \"converting HEAP to ondisk\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_copy_to_tmp_table= { 0, \"copy to tmp table\", PSI_FLAG_STAGE_PROGRESS, PSI_DOCUMENT_ME};\nPSI_stage_info stage_creating_table= { 0, \"creating table\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_creating_tmp_table= { 0, \"Creating tmp table\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_deleting_from_main_table= { 0, \"deleting from main table\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_deleting_from_reference_tables= { 0, \"deleting from reference tables\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_discard_or_import_tablespace= { 0, \"discard_or_import_tablespace\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_end= { 0, \"end\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_executing= { 0, \"executing\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_execution_of_init_command= { 0, \"Execution of init_command\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_explaining= { 0, \"explaining\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_finished_reading_one_binlog_switching_to_next_binlog= { 0, \"Finished reading one binlog; switching to next binlog\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_flushing_relay_log_and_master_info_repository= { 0, \"Flushing relay log and master info repository.\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_flushing_relay_log_info_file= { 0, \"Flushing relay-log info file.\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_freeing_items= { 0, \"freeing items\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_fulltext_initialization= { 0, \"FULLTEXT initialization\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_init= { 0, \"init\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_killing_slave= { 0, \"Killing slave\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_logging_slow_query= { 0, \"logging slow query\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_making_temp_file_append_before_load_data= { 0, \"Making temporary file (append) before replaying LOAD DATA INFILE\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_manage_keys= { 0, \"manage keys\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_master_has_sent_all_binlog_to_slave= { 0, \"Master has sent all binlog to slave; waiting for more updates\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_opening_tables= { 0, \"Opening tables\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_optimizing= { 0, \"optimizing\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_preparing= { 0, \"preparing\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_purging_old_relay_logs= { 0, \"Purging old relay logs\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_query_end= { 0, \"query end\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_queueing_master_event_to_the_relay_log= { 0, \"Queueing master event to the relay log\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_reading_event_from_the_relay_log= { 0, \"Reading event from the relay log\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_registering_slave_on_master= { 0, \"Registering slave on master\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_removing_tmp_table= { 0, \"removing tmp table\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_rename= { 0, \"rename\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_rename_result_table= { 0, \"rename result table\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_requesting_binlog_dump= { 0, \"Requesting binlog dump\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_searching_rows_for_update= { 0, \"Searching rows for update\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_sending_binlog_event_to_slave= { 0, \"Sending binlog event to slave\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_setup= { 0, \"setup\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_slave_has_read_all_relay_log= { 0, \"Slave has read all relay log; waiting for more updates\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_slave_waiting_event_from_coordinator= { 0, \"Waiting for an event from Coordinator\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_slave_waiting_for_workers_to_process_queue= { 0, \"Waiting for slave workers to process their queues\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_slave_waiting_worker_queue= { 0, \"Waiting for Slave Worker queue\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_slave_waiting_worker_to_free_events= { 0, \"Waiting for Slave Workers to free pending events\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_slave_waiting_worker_to_release_partition= { 0, \"Waiting for Slave Worker to release partition\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_slave_waiting_workers_to_exit= { 0, \"Waiting for workers to exit\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_rpl_apply_row_evt_write= { 0, \"Applying batch of row changes (write)\", PSI_FLAG_STAGE_PROGRESS, PSI_DOCUMENT_ME};\nPSI_stage_info stage_rpl_apply_row_evt_update= { 0, \"Applying batch of row changes (update)\", PSI_FLAG_STAGE_PROGRESS, PSI_DOCUMENT_ME};\nPSI_stage_info stage_rpl_apply_row_evt_delete= { 0, \"Applying batch of row changes (delete)\", PSI_FLAG_STAGE_PROGRESS, PSI_DOCUMENT_ME};\nPSI_stage_info stage_statistics= { 0, \"statistics\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_sql_thd_waiting_until_delay= { 0, \"Waiting until MASTER_DELAY seconds after master executed event\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_system_lock= { 0, \"System lock\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_update= { 0, \"update\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_updating= { 0, \"updating\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_updating_main_table= { 0, \"updating main table\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_updating_reference_tables= { 0, \"updating reference tables\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_user_sleep= { 0, \"User sleep\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_verifying_table= { 0, \"verifying table\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_waiting_for_gtid_to_be_committed= { 0, \"Waiting for GTID to be committed\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_waiting_for_handler_commit= { 0, \"waiting for handler commit\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_waiting_for_master_to_send_event= { 0, \"Waiting for master to send event\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_waiting_for_master_update= { 0, \"Waiting for master update\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_waiting_for_relay_log_space= { 0, \"Waiting for the slave SQL thread to free enough relay log space\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_waiting_for_slave_mutex_on_exit= { 0, \"Waiting for slave mutex on exit\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_waiting_for_slave_thread_to_start= { 0, \"Waiting for slave thread to start\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_waiting_for_table_flush= { 0, \"Waiting for table flush\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_waiting_for_the_next_event_in_relay_log= { 0, \"Waiting for the next event in relay log\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_waiting_for_the_slave_thread_to_advance_position= { 0, \"Waiting for the slave SQL thread to advance position\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_waiting_to_finalize_termination= { 0, \"Waiting to finalize termination\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_worker_waiting_for_its_turn_to_commit= { 0, \"Waiting for preceding transaction to commit\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_worker_waiting_for_commit_parent= { 0, \"Waiting for dependent transaction to commit\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_suspending= { 0, \"Suspending\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_starting= { 0, \"starting\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_waiting_for_no_channel_reference= { 0, \"Waiting for no channel reference.\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_hook_begin_trans= { 0, \"Executing hook on transaction begin.\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_binlog_transaction_compress= { 0, \"Compressing transaction changes.\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_binlog_transaction_decompress= { 0, \"Decompressing transaction changes.\", 0, PSI_DOCUMENT_ME};\nPSI_stage_info stage_restoring_secondary_keys= { 0, \"restoring secondary keys\", 0, PSI_DOCUMENT_ME};\n/* clang-format on */\n\nextern PSI_stage_info stage_waiting_for_disk_space;\n\n#ifdef HAVE_PSI_INTERFACE\n\nPSI_stage_info *all_server_stages[] = {\n    &stage_after_create,\n    &stage_alter_inplace_prepare,\n    &stage_alter_inplace,\n    &stage_alter_inplace_commit,\n    &stage_changing_master,\n    &stage_checking_master_version,\n    &stage_checking_permissions,\n    &stage_cleaning_up,\n    &stage_closing_tables,\n    &stage_compressing_gtid_table,\n    &stage_connecting_to_master,\n    &stage_converting_heap_to_ondisk,\n    &stage_copy_to_tmp_table,\n    &stage_creating_table,\n    &stage_creating_tmp_table,\n    &stage_deleting_from_main_table,\n    &stage_deleting_from_reference_tables,\n    &stage_discard_or_import_tablespace,\n    &stage_end,\n    &stage_executing,\n    &stage_execution_of_init_command,\n    &stage_explaining,\n    &stage_finished_reading_one_binlog_switching_to_next_binlog,\n    &stage_flushing_relay_log_and_master_info_repository,\n    &stage_flushing_relay_log_info_file,\n    &stage_freeing_items,\n    &stage_fulltext_initialization,\n    &stage_init,\n    &stage_killing_slave,\n    &stage_logging_slow_query,\n    &stage_making_temp_file_append_before_load_data,\n    &stage_manage_keys,\n    &stage_master_has_sent_all_binlog_to_slave,\n    &stage_opening_tables,\n    &stage_optimizing,\n    &stage_preparing,\n    &stage_purging_old_relay_logs,\n    &stage_query_end,\n    &stage_queueing_master_event_to_the_relay_log,\n    &stage_reading_event_from_the_relay_log,\n    &stage_registering_slave_on_master,\n    &stage_removing_tmp_table,\n    &stage_rename,\n    &stage_rename_result_table,\n    &stage_requesting_binlog_dump,\n    &stage_searching_rows_for_update,\n    &stage_sending_binlog_event_to_slave,\n    &stage_setup,\n    &stage_slave_has_read_all_relay_log,\n    &stage_slave_waiting_event_from_coordinator,\n    &stage_slave_waiting_for_workers_to_process_queue,\n    &stage_slave_waiting_worker_queue,\n    &stage_slave_waiting_worker_to_free_events,\n    &stage_slave_waiting_worker_to_release_partition,\n    &stage_slave_waiting_workers_to_exit,\n    &stage_rpl_apply_row_evt_write,\n    &stage_rpl_apply_row_evt_update,\n    &stage_rpl_apply_row_evt_delete,\n    &stage_sql_thd_waiting_until_delay,\n    &stage_statistics,\n    &stage_system_lock,\n    &stage_update,\n    &stage_updating,\n    &stage_updating_main_table,\n    &stage_updating_reference_tables,\n    &stage_user_sleep,\n    &stage_verifying_table,\n    &stage_waiting_for_gtid_to_be_committed,\n    &stage_waiting_for_handler_commit,\n    &stage_waiting_for_master_to_send_event,\n    &stage_waiting_for_master_update,\n    &stage_waiting_for_relay_log_space,\n    &stage_waiting_for_slave_mutex_on_exit,\n    &stage_waiting_for_slave_thread_to_start,\n    &stage_waiting_for_table_flush,\n    &stage_waiting_for_the_next_event_in_relay_log,\n    &stage_waiting_for_the_slave_thread_to_advance_position,\n    &stage_waiting_to_finalize_termination,\n    &stage_worker_waiting_for_its_turn_to_commit,\n    &stage_worker_waiting_for_commit_parent,\n    &stage_suspending,\n    &stage_starting,\n    &stage_waiting_for_no_channel_reference,\n    &stage_hook_begin_trans,\n    &stage_waiting_for_disk_space,\n    &stage_binlog_transaction_compress,\n    &stage_binlog_transaction_decompress,\n    &stage_restoring_secondary_keys};\n\nPSI_socket_key key_socket_tcpip;\nPSI_socket_key key_socket_unix;\nPSI_socket_key key_socket_client_connection;\n\n/* clang-format off */\nstatic PSI_socket_info all_server_sockets[]=\n{\n  { &key_socket_tcpip, \"server_tcpip_socket\", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},\n  { &key_socket_unix, \"server_unix_socket\", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},\n  { &key_socket_client_connection, \"client_connection\", PSI_FLAG_USER, 0, PSI_DOCUMENT_ME}\n};\n/* clang-format on */\n\n/* TODO: find a good header */\nvoid init_client_psi_keys(void);\n\n/**\n  Initialise all the performance schema instrumentation points\n  used by the server.\n*/\nstatic void init_server_psi_keys(void) {\n  const char *category = \"sql\";\n  int count;\n\n  count = static_cast<int>(array_elements(all_server_mutexes));\n  mysql_mutex_register(category, all_server_mutexes, count);\n\n  count = static_cast<int>(array_elements(all_server_rwlocks));\n  mysql_rwlock_register(category, all_server_rwlocks, count);\n\n  count = static_cast<int>(array_elements(all_server_conds));\n  mysql_cond_register(category, all_server_conds, count);\n\n  count = static_cast<int>(array_elements(all_server_threads));\n  mysql_thread_register(category, all_server_threads, count);\n\n  count = static_cast<int>(array_elements(all_server_files));\n  mysql_file_register(category, all_server_files, count);\n\n  count = static_cast<int>(array_elements(all_server_stages));\n  mysql_stage_register(category, all_server_stages, count);\n\n  count = static_cast<int>(array_elements(all_server_sockets));\n  mysql_socket_register(category, all_server_sockets, count);\n\n  register_server_memory_keys();\n\n#ifdef HAVE_PSI_STATEMENT_INTERFACE\n  init_sql_statement_info();\n\n  /* Register [0 .. SQLCOM_CLONE - 1] as \"statement/sql/...\" */\n  count = (int)SQLCOM_CLONE;\n  mysql_statement_register(category, sql_statement_info, count);\n\n  /* Exclude SQLCOM_CLONE as it mutates and is registered as abstract. */\n  count = (int)SQLCOM_END - (int)SQLCOM_CLONE;\n  mysql_statement_register(category, &sql_statement_info[(int)SQLCOM_CLONE + 1],\n                           count);\n  category = \"abstract\";\n  mysql_statement_register(category, &sql_statement_info[(int)SQLCOM_CLONE], 1);\n\n  init_sp_psi_keys();\n\n  init_scheduler_psi_keys();\n\n  category = \"com\";\n  init_com_statement_info();\n\n  /*\n    Register [0 .. COM_QUERY - 1] as \"statement/com/...\"\n  */\n  count = (int)COM_QUERY;\n  mysql_statement_register(category, com_statement_info, count);\n\n  /* Exclude COM_CLONE as it would mutate */\n  count = (int)COM_CLONE - (int)COM_QUERY - 1;\n  mysql_statement_register(category, &com_statement_info[(int)COM_QUERY + 1],\n                           count);\n  /*\n    Register [COM_CLONE + 1 .. COM_END] as \"statement/com/...\"\n  */\n  count = (int)COM_END - (int)COM_CLONE;\n  mysql_statement_register(category, &com_statement_info[(int)COM_CLONE + 1],\n                           count);\n  category = \"abstract\";\n  /*\n    Register [COM_QUERY] as \"statement/abstract/com_query\"\n  */\n  mysql_statement_register(category, &com_statement_info[(int)COM_QUERY], 1);\n  mysql_statement_register(category, &com_statement_info[(int)COM_CLONE], 1);\n\n  /*\n    When a new packet is received,\n    it is instrumented as \"statement/abstract/new_packet\".\n    Based on the packet type found, it later mutates to the\n    proper narrow type, for example\n    \"statement/abstract/query\" or \"statement/com/ping\".\n    In cases of \"statement/abstract/query\", SQL queries are given to\n    the parser, which mutates the statement type to an even more\n    narrow classification, for example \"statement/sql/select\".\n  */\n  stmt_info_new_packet.m_key = 0;\n  stmt_info_new_packet.m_name = \"new_packet\";\n  stmt_info_new_packet.m_flags = PSI_FLAG_MUTABLE;\n  stmt_info_new_packet.m_documentation =\n      \"New packet just received from the network. \"\n      \"At this point, the real command type is unknown, \"\n      \"the type will be refined after reading the packet header.\";\n  mysql_statement_register(category, &stmt_info_new_packet, 1);\n\n  /*\n    Statements processed from the relay log are initially instrumented as\n    \"statement/abstract/relay_log\". The parser will mutate the statement type to\n    a more specific classification, for example \"statement/sql/insert\".\n  */\n  stmt_info_rpl.m_key = 0;\n  stmt_info_rpl.m_name = \"relay_log\";\n  stmt_info_rpl.m_flags = PSI_FLAG_MUTABLE;\n  stmt_info_rpl.m_documentation =\n      \"New event just read from the relay log. \"\n      \"At this point, the real statement type is unknown, \"\n      \"the type will be refined after parsing the event.\";\n  mysql_statement_register(category, &stmt_info_rpl, 1);\n#endif\n\n  /* Common client and server code. */\n  init_client_psi_keys();\n  /* Vio */\n  init_vio_psi_keys();\n}\n#endif /* HAVE_PSI_INTERFACE */\n\nbool do_create_native_table_for_pfs(THD *thd, const Plugin_table *t) {\n  const char *schema_name = t->get_schema_name();\n  const char *table_name = t->get_name();\n  MDL_request table_request;\n  MDL_REQUEST_INIT(&table_request, MDL_key::TABLE, schema_name, table_name,\n                   MDL_EXCLUSIVE, MDL_TRANSACTION);\n\n  if (thd->mdl_context.acquire_lock(&table_request,\n                                    thd->variables.lock_wait_timeout)) {\n    /* Error, failed to get MDL lock. */\n    return true;\n  }\n\n  tdc_remove_table(thd, TDC_RT_REMOVE_ALL, schema_name, table_name, false);\n\n  if (dd::create_native_table(thd, t)) {\n    /* Error, failed to create DD table. */\n    return true;\n  }\n\n  return false;\n}\n\nbool create_native_table_for_pfs(const Plugin_table *t) {\n  /* If InnoDB is not initialized yet, return error */\n  if (!is_builtin_and_core_se_initialized()) return true;\n\n  THD *thd = current_thd;\n  DBUG_ASSERT(thd);\n  return do_create_native_table_for_pfs(thd, t);\n}\n\nstatic bool do_drop_native_table_for_pfs(THD *thd, const char *schema_name,\n                                         const char *table_name) {\n  MDL_request table_request;\n  MDL_REQUEST_INIT(&table_request, MDL_key::TABLE, schema_name, table_name,\n                   MDL_EXCLUSIVE, MDL_TRANSACTION);\n\n  if (thd->mdl_context.acquire_lock(&table_request,\n                                    thd->variables.lock_wait_timeout)) {\n    /* Error, failed to get MDL lock. */\n    return true;\n  }\n\n  tdc_remove_table(thd, TDC_RT_REMOVE_ALL, schema_name, table_name, false);\n\n  if (dd::drop_native_table(thd, schema_name, table_name)) {\n    /* Error, failed to destroy DD table. */\n    return true;\n  }\n\n  return false;\n}\n\nbool drop_native_table_for_pfs(const char *schema_name,\n                               const char *table_name) {\n  /* If server is shutting down, by the time control reaches here, DD would have\n   * already been shut down. Therefore return success and tables won't be\n   * deleted and would be available at next server start.\n   */\n  if (get_server_state() == SERVER_SHUTTING_DOWN) {\n    return false;\n  }\n\n  /* During bootstrap error cleanup, we don't have THD. */\n  THD *thd = current_thd;\n  if (thd == nullptr) {\n    DBUG_ASSERT(get_server_state() == SERVER_BOOTING);\n    return false;\n  }\n  return do_drop_native_table_for_pfs(thd, schema_name, table_name);\n}\n\n#ifdef _WIN32\n// update_named_pipe_full_access_group returns false on success, true on failure\nbool update_named_pipe_full_access_group(const char *new_group_name) {\n  if (named_pipe_acceptor) {\n    return named_pipe_listener->update_named_pipe_full_access_group(\n        new_group_name);\n  }\n  return true;\n}\n\n#endif  // _WIN32\n\n/**\n  Get status partial_revokes on server\n\n  @return a bool indicating partial_revokes status of the server.\n    @retval true  Parital revokes is ON\n    @retval flase Partial revokes is OFF\n*/\nbool mysqld_partial_revokes() {\n  return partial_revokes.load(std::memory_order_relaxed);\n}\n\n/**\n  Set partial_revokes with a given value\n\n  @param value true or false indicating the status of partial revokes\n               turned ON/OFF on server.\n*/\nvoid set_mysqld_partial_revokes(bool value) {\n  partial_revokes.store(value, std::memory_order_relaxed);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/sql/sys_vars.cc": "/* Copyright (c) 2009, 2020, Oracle and/or its affiliates. All rights reserved.\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License, version 2.0,\n   as published by the Free Software Foundation.\n\n   This program is also distributed with certain software (including\n   but not limited to OpenSSL) that is licensed under separate terms,\n   as designated in a particular file or component or in included license\n   documentation.  The authors of MySQL hereby grant you an additional\n   permission to link the program and your derivative works with the\n   separately licensed software that they have included with MySQL.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License, version 2.0, for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA */\n\n/**\n  @file\n  Definitions of all server's session or global variables.\n\n  How to add new variables:\n\n  1. copy one of the existing variables, and edit the declaration.\n  2. if you need special behavior on assignment or additional checks\n     use ON_CHECK and ON_UPDATE callbacks.\n  3. *Don't* add new Sys_var classes or uncle Occam will come\n     with his razor to haunt you at nights\n\n  Note - all storage engine variables (for example myisam_whatever)\n  should go into the corresponding storage engine sources\n  (for example in storage/myisam/ha_myisam.cc) !\n*/\n\n#include \"sql/sys_vars.h\"\n\n#include \"my_config.h\"\n\n#include <assert.h>\n#include <limits.h>\n#include <math.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <sys/stat.h>\n#include <zlib.h>\n#include <atomic>\n#include <limits>\n\n#include \"include/compression.h\"\n\n#include \"my_loglevel.h\"\n#include \"mysql/components/services/log_builtins.h\"\n#include \"mysql/components/services/log_shared.h\"\n#include \"mysql_com.h\"\n#include \"sql/protocol.h\"\n#include \"sql/rpl_trx_tracking.h\"\n#ifdef HAVE_SYS_TIME_H\n#include <sys/time.h>\n#endif\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n#include <algorithm>\n#include <map>\n#include <utility>\n\n#include \"ft_global.h\"\n#include \"libbinlogevents/include/binlog_event.h\"\n#include \"m_string.h\"\n#include \"my_aes.h\"  // my_aes_opmode_names\n#include \"my_command.h\"\n#include \"my_compiler.h\"\n#include \"my_dbug.h\"\n#include \"my_dir.h\"\n#include \"my_double2ulonglong.h\"\n#include \"my_io.h\"\n#include \"my_macros.h\"\n#include \"my_sqlcommand.h\"\n#include \"my_thread.h\"\n#include \"my_thread_local.h\"\n#include \"my_time.h\"\n#include \"myisam.h\"  // myisam_flush\n#include \"mysql/components/services/log_builtins.h\"\n#include \"mysql/plugin_group_replication.h\"\n#include \"mysql/psi/mysql_mutex.h\"\n#include \"mysql_version.h\"\n#include \"sql/auth/auth_acls.h\"\n#include \"sql/auth/auth_common.h\"  // validate_user_plugins\n#include \"sql/binlog.h\"            // mysql_bin_log\n#include \"sql/clone_handler.h\"\n#include \"sql/conn_handler/connection_handler_impl.h\"  // Per_thread_connection_handler\n#include \"sql/conn_handler/connection_handler_manager.h\"  // Connection_handler_manager\n#include \"sql/conn_handler/socket_connection.h\"  // MY_BIND_ALL_ADDRESSES\n#include \"sql/derror.h\"                          // read_texts\n#include \"sql/discrete_interval.h\"\n#include \"sql/events.h\"          // Events\n#include \"sql/hostname_cache.h\"  // host_cache_resize\n#include \"sql/log.h\"\n#include \"sql/log_event.h\"  // MAX_MAX_ALLOWED_PACKET\n#include \"sql/mdl.h\"\n#include \"sql/my_decimal.h\"\n#include \"sql/opt_trace_context.h\"\n#include \"sql/options_mysqld.h\"\n#include \"sql/protocol_classic.h\"\n#include \"sql/psi_memory_key.h\"\n#include \"sql/query_options.h\"\n#include \"sql/rpl_group_replication.h\"  // is_group_replication_running\n#include \"sql/rpl_info_factory.h\"       // Rpl_info_factory\n#include \"sql/rpl_info_handler.h\"       // INFO_REPOSITORY_TABLE\n#include \"sql/rpl_log_encryption.h\"\n#include \"sql/rpl_mi.h\"                 // Master_info\n#include \"sql/rpl_msr.h\"                // channel_map\n#include \"sql/rpl_mts_submode.h\"        // MTS_PARALLEL_TYPE_DB_NAME\n#include \"sql/rpl_rli.h\"                // Relay_log_info\n#include \"sql/rpl_slave.h\"              // SLAVE_THD_TYPE\n#include \"sql/rpl_write_set_handler.h\"  // transaction_write_set_hashing_algorithms\n#include \"sql/server_component/log_builtins_filter_imp.h\"  // until we have pluggable variables\n#include \"sql/server_component/log_builtins_imp.h\"\n#include \"sql/session_tracker.h\"\n#include \"sql/sp_head.h\"          // SP_PSI_STATEMENT_INFO_COUNT\n#include \"sql/sql_backup_lock.h\"  // is_instance_backup_locked\n#include \"sql/sql_lex.h\"\n#include \"sql/sql_locale.h\"     // my_locale_by_number\n#include \"sql/sql_parse.h\"      // killall_non_super_threads\n#include \"sql/sql_tmp_table.h\"  // internal_tmp_mem_storage_engine_names\n#include \"sql/ssl_acceptor_context.h\"\n#include \"sql/system_variables.h\"\n#include \"sql/table_cache.h\"  // Table_cache_manager\n#include \"sql/threadpool.h\"\n#include \"sql/transaction.h\"  // trans_commit_stmt\n#include \"sql/transaction_info.h\"\n#include \"sql/xa.h\"\n#include \"template_utils.h\"  // pointer_cast\n#include \"thr_lock.h\"\n#ifdef _WIN32\n#include \"sql/named_pipe.h\"\n#endif\n\n#ifdef WITH_LOCK_ORDER\n#include \"sql/debug_lock_order.h\"\n#endif /* WITH_LOCK_ORDER */\n\n#ifdef WITH_PERFSCHEMA_STORAGE_ENGINE\n#include \"storage/perfschema/pfs_server.h\"\n#endif /* WITH_PERFSCHEMA_STORAGE_ENGINE */\n\n#define MAX_CONNECTIONS 100000\n\nTYPELIB bool_typelib = {array_elements(bool_values) - 1, \"\", bool_values,\n                        nullptr};\n\nstatic bool update_buffer_size(THD *, KEY_CACHE *key_cache,\n                               ptrdiff_t offset MY_ATTRIBUTE((unused)),\n                               ulonglong new_value) {\n  bool error = false;\n  DBUG_ASSERT(offset == offsetof(KEY_CACHE, param_buff_size));\n\n  if (new_value == 0) {\n    if (key_cache == dflt_key_cache) {\n      my_error(ER_WARN_CANT_DROP_DEFAULT_KEYCACHE, MYF(0));\n      return true;\n    }\n\n    if (key_cache->key_cache_inited)  // If initied\n    {\n      /*\n        Move tables using this key cache to the default key cache\n        and clear the old key cache.\n      */\n      key_cache->in_init = true;\n      mysql_mutex_unlock(&LOCK_global_system_variables);\n      key_cache->param_buff_size = 0;\n      ha_resize_key_cache(key_cache);\n      ha_change_key_cache(key_cache, dflt_key_cache);\n      /*\n        We don't delete the key cache as some running threads my still be in\n        the key cache code with a pointer to the deleted (empty) key cache\n      */\n      mysql_mutex_lock(&LOCK_global_system_variables);\n      key_cache->in_init = false;\n    }\n    return error;\n  }\n\n  key_cache->param_buff_size = new_value;\n\n  /* If key cache didn't exist initialize it, else resize it */\n  key_cache->in_init = true;\n  mysql_mutex_unlock(&LOCK_global_system_variables);\n\n  if (!key_cache->key_cache_inited)\n    error = ha_init_key_cache(nullptr, key_cache);\n  else\n    error = ha_resize_key_cache(key_cache);\n\n  mysql_mutex_lock(&LOCK_global_system_variables);\n  key_cache->in_init = false;\n\n  return error;\n}\n\nstatic bool update_keycache_param(THD *, KEY_CACHE *key_cache, ptrdiff_t offset,\n                                  ulonglong new_value) {\n  bool error = false;\n  DBUG_ASSERT(offset != offsetof(KEY_CACHE, param_buff_size));\n\n  keycache_var(key_cache, offset) = new_value;\n\n  key_cache->in_init = true;\n  mysql_mutex_unlock(&LOCK_global_system_variables);\n  error = ha_resize_key_cache(key_cache);\n\n  mysql_mutex_lock(&LOCK_global_system_variables);\n  key_cache->in_init = false;\n\n  return error;\n}\n\n/**\n  Check if REPLICATION_APPLIER granted. Throw SQL error if not.\n\n  Use this when setting session variables that are to be protected within\n  replication applier context.\n\n  @note For compatibility we also accept SUPER.\n\n  @retval true failure\n  @retval false success\n\n  @param self the system variable to set value for\n  @param thd the session context\n  @param setv the SET operations metadata\n */\nstatic bool check_session_admin_or_replication_applier(\n    sys_var *self MY_ATTRIBUTE((unused)), THD *thd, set_var *setv) {\n  DBUG_ASSERT(self->scope() != sys_var::GLOBAL);\n  Security_context *sctx = thd->security_context();\n  if ((setv->type == OPT_SESSION || setv->type == OPT_DEFAULT) &&\n      !sctx->has_global_grant(STRING_WITH_LEN(\"REPLICATION_APPLIER\")).first &&\n      !sctx->has_global_grant(STRING_WITH_LEN(\"SESSION_VARIABLES_ADMIN\"))\n           .first &&\n      !sctx->has_global_grant(STRING_WITH_LEN(\"SYSTEM_VARIABLES_ADMIN\"))\n           .first &&\n      !sctx->check_access(SUPER_ACL)) {\n    my_error(ER_SPECIFIC_ACCESS_DENIED_ERROR, MYF(0),\n             \"SUPER, SYSTEM_VARIABLES_ADMIN, SESSION_VARIABLES_ADMIN or \"\n             \"REPLICATION_APPLIER\");\n    return true;\n  }\n  return false;\n}\n\n/**\n  Check if SESSION_VARIABLES_ADMIN granted. Throw SQL error if not.\n\n  Use this when setting session variables that are sensitive and should\n  be protected.\n\n  We also accept SYSTEM_VARIABLES_ADMIN since it doesn't make a lot of\n  sense to be allowed to set the global variable and not the session ones.\n\n  @note For compatibility we also accept SUPER.\n\n  @retval true failure\n  @retval false success\n\n  @param self the system variable to set value for\n  @param thd the session context\n  @param setv the SET operations metadata\n */\nstatic bool check_session_admin(sys_var *self MY_ATTRIBUTE((unused)), THD *thd,\n                                set_var *setv) {\n  DBUG_ASSERT(self->scope() !=\n              sys_var::GLOBAL);  // don't abuse check_session_admin()\n  Security_context *sctx = thd->security_context();\n  if ((setv->type == OPT_SESSION || setv->type == OPT_DEFAULT) &&\n      !sctx->has_global_grant(STRING_WITH_LEN(\"SESSION_VARIABLES_ADMIN\"))\n           .first &&\n      !sctx->has_global_grant(STRING_WITH_LEN(\"SYSTEM_VARIABLES_ADMIN\"))\n           .first &&\n      !sctx->check_access(SUPER_ACL)) {\n    my_error(ER_SPECIFIC_ACCESS_DENIED_ERROR, MYF(0),\n             \"SUPER, SYSTEM_VARIABLES_ADMIN or SESSION_VARIABLES_ADMIN\");\n    return true;\n  }\n  return false;\n}\n\n/*\n  The rule for this file: everything should be 'static'. When a sys_var\n  variable or a function from this file is - in very rare cases - needed\n  elsewhere it should be explicitly declared 'export' here to show that it's\n  not a mistakenly forgotten 'static' keyword.\n*/\n#define export /* not static */\n\n#ifdef WITH_LOCK_ORDER\n\n#define LO_TRAILING_PROPERTIES                                          \\\n  NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(NULL), ON_UPDATE(NULL), NULL, \\\n      sys_var::PARSE_EARLY\n\nstatic Sys_var_bool Sys_lo_enabled(\"lock_order\", \"Enable the lock order.\",\n                                   READ_ONLY GLOBAL_VAR(lo_param.m_enabled),\n                                   CMD_LINE(OPT_ARG), DEFAULT(false),\n                                   LO_TRAILING_PROPERTIES);\n\nstatic Sys_var_charptr Sys_lo_out_dir(\"lock_order_output_directory\",\n                                      \"Lock order output directory.\",\n                                      READ_ONLY GLOBAL_VAR(lo_param.m_out_dir),\n                                      CMD_LINE(OPT_ARG), IN_FS_CHARSET,\n                                      DEFAULT(nullptr), LO_TRAILING_PROPERTIES);\n\nstatic Sys_var_charptr Sys_lo_dep_1(\n    \"lock_order_dependencies\", \"Lock order dependencies file.\",\n    READ_ONLY GLOBAL_VAR(lo_param.m_dependencies_1), CMD_LINE(OPT_ARG),\n    IN_FS_CHARSET, DEFAULT(nullptr), LO_TRAILING_PROPERTIES);\n\nstatic Sys_var_charptr Sys_lo_dep_2(\n    \"lock_order_extra_dependencies\", \"Lock order extra dependencies file.\",\n    READ_ONLY GLOBAL_VAR(lo_param.m_dependencies_2), CMD_LINE(OPT_ARG),\n    IN_FS_CHARSET, DEFAULT(nullptr), LO_TRAILING_PROPERTIES);\n\nstatic Sys_var_bool Sys_lo_print_txt(\"lock_order_print_txt\",\n                                     \"Print the lock_order.txt file.\",\n                                     READ_ONLY GLOBAL_VAR(lo_param.m_print_txt),\n                                     CMD_LINE(OPT_ARG), DEFAULT(false),\n                                     LO_TRAILING_PROPERTIES);\n\nstatic Sys_var_bool Sys_lo_trace_loop(\n    \"lock_order_trace_loop\", \"Enable tracing for all loops.\",\n    READ_ONLY GLOBAL_VAR(lo_param.m_trace_loop), CMD_LINE(OPT_ARG),\n    DEFAULT(false), LO_TRAILING_PROPERTIES);\n\nstatic Sys_var_bool Sys_lo_debug_loop(\n    \"lock_order_debug_loop\", \"Enable debugging for all loops.\",\n    READ_ONLY GLOBAL_VAR(lo_param.m_debug_loop), CMD_LINE(OPT_ARG),\n    DEFAULT(false), LO_TRAILING_PROPERTIES);\n\nstatic Sys_var_bool Sys_lo_trace_missing_arc(\n    \"lock_order_trace_missing_arc\", \"Enable tracing for all missing arcs.\",\n    READ_ONLY GLOBAL_VAR(lo_param.m_trace_missing_arc), CMD_LINE(OPT_ARG),\n    DEFAULT(true), LO_TRAILING_PROPERTIES);\n\nstatic Sys_var_bool Sys_lo_debug_missing_arc(\n    \"lock_order_debug_missing_arc\", \"Enable debugging for all missing arcs.\",\n    READ_ONLY GLOBAL_VAR(lo_param.m_debug_missing_arc), CMD_LINE(OPT_ARG),\n    DEFAULT(false), LO_TRAILING_PROPERTIES);\n\nstatic Sys_var_bool Sys_lo_trace_missing_unlock(\n    \"lock_order_trace_missing_unlock\", \"Enable tracing for all missing unlocks\",\n    READ_ONLY GLOBAL_VAR(lo_param.m_trace_missing_unlock), CMD_LINE(OPT_ARG),\n    DEFAULT(true), LO_TRAILING_PROPERTIES);\n\nstatic Sys_var_bool Sys_lo_debug_missing_unlock(\n    \"lock_order_debug_missing_unlock\",\n    \"Enable debugging for all missing unlocks\",\n    READ_ONLY GLOBAL_VAR(lo_param.m_debug_missing_unlock), CMD_LINE(OPT_ARG),\n    DEFAULT(false), LO_TRAILING_PROPERTIES);\n\nstatic Sys_var_bool Sys_lo_trace_missing_key(\n    \"lock_order_trace_missing_key\",\n    \"Enable trace for missing performance schema keys\",\n    READ_ONLY GLOBAL_VAR(lo_param.m_trace_missing_key), CMD_LINE(OPT_ARG),\n    DEFAULT(false), LO_TRAILING_PROPERTIES);\n\nstatic Sys_var_bool Sys_lo_debug_missing_key(\n    \"lock_order_debug_missing_key\",\n    \"Enable debugging for missing performance schema keys\",\n    READ_ONLY GLOBAL_VAR(lo_param.m_debug_missing_key), CMD_LINE(OPT_ARG),\n    DEFAULT(false), LO_TRAILING_PROPERTIES);\n\n#endif /* WITH_LOCK_ORDER */\n\n#ifdef WITH_PERFSCHEMA_STORAGE_ENGINE\n\n#define PFS_TRAILING_PROPERTIES                                         \\\n  NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(NULL), ON_UPDATE(NULL), NULL, \\\n      sys_var::PARSE_EARLY\n\nstatic Sys_var_bool Sys_pfs_enabled(\"performance_schema\",\n                                    \"Enable the performance schema.\",\n                                    READ_ONLY GLOBAL_VAR(pfs_param.m_enabled),\n                                    CMD_LINE(OPT_ARG), DEFAULT(true),\n                                    PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_charptr Sys_pfs_instrument(\n    \"performance_schema_instrument\",\n    \"Default startup value for a performance schema instrument.\",\n    READ_ONLY NOT_VISIBLE GLOBAL_VAR(pfs_param.m_pfs_instrument),\n    CMD_LINE(OPT_ARG, OPT_PFS_INSTRUMENT), IN_FS_CHARSET, DEFAULT(\"\"),\n    PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_bool Sys_pfs_consumer_events_stages_current(\n    \"performance_schema_consumer_events_stages_current\",\n    \"Default startup value for the events_stages_current consumer.\",\n    READ_ONLY NOT_VISIBLE\n        GLOBAL_VAR(pfs_param.m_consumer_events_stages_current_enabled),\n    CMD_LINE(OPT_ARG), DEFAULT(false), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_bool Sys_pfs_consumer_events_stages_history(\n    \"performance_schema_consumer_events_stages_history\",\n    \"Default startup value for the events_stages_history consumer.\",\n    READ_ONLY NOT_VISIBLE\n        GLOBAL_VAR(pfs_param.m_consumer_events_stages_history_enabled),\n    CMD_LINE(OPT_ARG), DEFAULT(false), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_bool Sys_pfs_consumer_events_stages_history_long(\n    \"performance_schema_consumer_events_stages_history_long\",\n    \"Default startup value for the events_stages_history_long consumer.\",\n    READ_ONLY NOT_VISIBLE\n        GLOBAL_VAR(pfs_param.m_consumer_events_stages_history_long_enabled),\n    CMD_LINE(OPT_ARG), DEFAULT(false), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_bool Sys_pfs_consumer_events_statements_current(\n    \"performance_schema_consumer_events_statements_current\",\n    \"Default startup value for the events_statements_current consumer.\",\n    READ_ONLY NOT_VISIBLE\n        GLOBAL_VAR(pfs_param.m_consumer_events_statements_current_enabled),\n    CMD_LINE(OPT_ARG), DEFAULT(true), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_bool Sys_pfs_consumer_events_statements_history(\n    \"performance_schema_consumer_events_statements_history\",\n    \"Default startup value for the events_statements_history consumer.\",\n    READ_ONLY NOT_VISIBLE\n        GLOBAL_VAR(pfs_param.m_consumer_events_statements_history_enabled),\n    CMD_LINE(OPT_ARG), DEFAULT(true), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_bool Sys_pfs_consumer_events_statements_history_long(\n    \"performance_schema_consumer_events_statements_history_long\",\n    \"Default startup value for the events_statements_history_long consumer.\",\n    READ_ONLY NOT_VISIBLE\n        GLOBAL_VAR(pfs_param.m_consumer_events_statements_history_long_enabled),\n    CMD_LINE(OPT_ARG), DEFAULT(false), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_bool Sys_pfs_consumer_events_transactions_current(\n    \"performance_schema_consumer_events_transactions_current\",\n    \"Default startup value for the events_transactions_current consumer.\",\n    READ_ONLY NOT_VISIBLE\n        GLOBAL_VAR(pfs_param.m_consumer_events_transactions_current_enabled),\n    CMD_LINE(OPT_ARG), DEFAULT(true), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_bool Sys_pfs_consumer_events_transactions_history(\n    \"performance_schema_consumer_events_transactions_history\",\n    \"Default startup value for the events_transactions_history consumer.\",\n    READ_ONLY NOT_VISIBLE\n        GLOBAL_VAR(pfs_param.m_consumer_events_transactions_history_enabled),\n    CMD_LINE(OPT_ARG), DEFAULT(true), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_bool Sys_pfs_consumer_events_transactions_history_long(\n    \"performance_schema_consumer_events_transactions_history_long\",\n    \"Default startup value for the events_transactions_history_long consumer.\",\n    READ_ONLY NOT_VISIBLE GLOBAL_VAR(\n        pfs_param.m_consumer_events_transactions_history_long_enabled),\n    CMD_LINE(OPT_ARG), DEFAULT(false), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_bool Sys_pfs_consumer_events_waits_current(\n    \"performance_schema_consumer_events_waits_current\",\n    \"Default startup value for the events_waits_current consumer.\",\n    READ_ONLY NOT_VISIBLE\n        GLOBAL_VAR(pfs_param.m_consumer_events_waits_current_enabled),\n    CMD_LINE(OPT_ARG), DEFAULT(false), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_bool Sys_pfs_consumer_events_waits_history(\n    \"performance_schema_consumer_events_waits_history\",\n    \"Default startup value for the events_waits_history consumer.\",\n    READ_ONLY NOT_VISIBLE\n        GLOBAL_VAR(pfs_param.m_consumer_events_waits_history_enabled),\n    CMD_LINE(OPT_ARG), DEFAULT(false), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_bool Sys_pfs_consumer_events_waits_history_long(\n    \"performance_schema_consumer_events_waits_history_long\",\n    \"Default startup value for the events_waits_history_long consumer.\",\n    READ_ONLY NOT_VISIBLE\n        GLOBAL_VAR(pfs_param.m_consumer_events_waits_history_long_enabled),\n    CMD_LINE(OPT_ARG), DEFAULT(false), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_bool Sys_pfs_consumer_global_instrumentation(\n    \"performance_schema_consumer_global_instrumentation\",\n    \"Default startup value for the global_instrumentation consumer.\",\n    READ_ONLY NOT_VISIBLE\n        GLOBAL_VAR(pfs_param.m_consumer_global_instrumentation_enabled),\n    CMD_LINE(OPT_ARG), DEFAULT(true), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_bool Sys_pfs_consumer_thread_instrumentation(\n    \"performance_schema_consumer_thread_instrumentation\",\n    \"Default startup value for the thread_instrumentation consumer.\",\n    READ_ONLY NOT_VISIBLE\n        GLOBAL_VAR(pfs_param.m_consumer_thread_instrumentation_enabled),\n    CMD_LINE(OPT_ARG), DEFAULT(true), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_bool Sys_pfs_consumer_statement_digest(\n    \"performance_schema_consumer_statements_digest\",\n    \"Default startup value for the statements_digest consumer.\",\n    READ_ONLY NOT_VISIBLE\n        GLOBAL_VAR(pfs_param.m_consumer_statement_digest_enabled),\n    CMD_LINE(OPT_ARG), DEFAULT(true), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_long Sys_pfs_events_waits_history_long_size(\n    \"performance_schema_events_waits_history_long_size\",\n    \"Number of rows in EVENTS_WAITS_HISTORY_LONG.\"\n    \" Use 0 to disable, -1 for automated sizing.\",\n    READ_ONLY GLOBAL_VAR(pfs_param.m_events_waits_history_long_sizing),\n    CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 1024 * 1024),\n    DEFAULT(PFS_AUTOSIZE_VALUE), BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_long Sys_pfs_events_waits_history_size(\n    \"performance_schema_events_waits_history_size\",\n    \"Number of rows per thread in EVENTS_WAITS_HISTORY.\"\n    \" Use 0 to disable, -1 for automated sizing.\",\n    READ_ONLY GLOBAL_VAR(pfs_param.m_events_waits_history_sizing),\n    CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 1024), DEFAULT(PFS_AUTOSIZE_VALUE),\n    BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_ulong Sys_pfs_max_cond_classes(\n    \"performance_schema_max_cond_classes\",\n    \"Maximum number of condition instruments.\",\n    READ_ONLY GLOBAL_VAR(pfs_param.m_cond_class_sizing), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(0, 1024), DEFAULT(PFS_MAX_COND_CLASS), BLOCK_SIZE(1),\n    PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_long Sys_pfs_max_cond_instances(\n    \"performance_schema_max_cond_instances\",\n    \"Maximum number of instrumented condition objects.\"\n    \" Use 0 to disable, -1 for automated scaling.\",\n    READ_ONLY GLOBAL_VAR(pfs_param.m_cond_sizing), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(-1, 1024 * 1024), DEFAULT(PFS_AUTOSCALE_VALUE), BLOCK_SIZE(1),\n    PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_long Sys_pfs_max_program_instances(\n    \"performance_schema_max_program_instances\",\n    \"Maximum number of instrumented programs.\"\n    \" Use 0 to disable, -1 for automated scaling.\",\n    READ_ONLY GLOBAL_VAR(pfs_param.m_program_sizing), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(-1, 1024 * 1024), DEFAULT(PFS_AUTOSCALE_VALUE), BLOCK_SIZE(1),\n    PFS_TRAILING_PROPERTIES);\n\nstatic constexpr int num_prepared_stmt_limit = 4 * 1024 * 1024;\n\nstatic Sys_var_long Sys_pfs_max_prepared_stmt_instances(\n    \"performance_schema_max_prepared_statements_instances\",\n    \"Maximum number of instrumented prepared statements.\"\n    \" Use 0 to disable, -1 for automated scaling.\",\n    READ_ONLY GLOBAL_VAR(pfs_param.m_prepared_stmt_sizing),\n    CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, num_prepared_stmt_limit),\n    DEFAULT(PFS_AUTOSCALE_VALUE), BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_ulong Sys_pfs_max_file_classes(\n    \"performance_schema_max_file_classes\",\n    \"Maximum number of file instruments.\",\n    READ_ONLY GLOBAL_VAR(pfs_param.m_file_class_sizing), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(0, 1024), DEFAULT(PFS_MAX_FILE_CLASS), BLOCK_SIZE(1),\n    PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_ulong Sys_pfs_max_file_handles(\n    \"performance_schema_max_file_handles\",\n    \"Maximum number of opened instrumented files.\",\n    READ_ONLY GLOBAL_VAR(pfs_param.m_file_handle_sizing),\n    CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, 1024 * 1024),\n    DEFAULT(PFS_MAX_FILE_HANDLE), BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_long Sys_pfs_max_file_instances(\n    \"performance_schema_max_file_instances\",\n    \"Maximum number of instrumented files.\"\n    \" Use 0 to disable, -1 for automated scaling.\",\n    READ_ONLY GLOBAL_VAR(pfs_param.m_file_sizing), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(-1, 1024 * 1024), DEFAULT(PFS_AUTOSCALE_VALUE), BLOCK_SIZE(1),\n    PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_long Sys_pfs_max_sockets(\n    \"performance_schema_max_socket_instances\",\n    \"Maximum number of opened instrumented sockets.\"\n    \" Use 0 to disable, -1 for automated scaling.\",\n    READ_ONLY GLOBAL_VAR(pfs_param.m_socket_sizing), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(-1, 1024 * 1024), DEFAULT(PFS_AUTOSCALE_VALUE), BLOCK_SIZE(1),\n    PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_ulong Sys_pfs_max_socket_classes(\n    \"performance_schema_max_socket_classes\",\n    \"Maximum number of socket instruments.\",\n    READ_ONLY GLOBAL_VAR(pfs_param.m_socket_class_sizing),\n    CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, 1024), DEFAULT(PFS_MAX_SOCKET_CLASS),\n    BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_ulong Sys_pfs_max_mutex_classes(\n    \"performance_schema_max_mutex_classes\",\n    \"Maximum number of mutex instruments.\",\n    READ_ONLY GLOBAL_VAR(pfs_param.m_mutex_class_sizing),\n    CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, 1024), DEFAULT(PFS_MAX_MUTEX_CLASS),\n    BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_long Sys_pfs_max_mutex_instances(\n    \"performance_schema_max_mutex_instances\",\n    \"Maximum number of instrumented MUTEX objects.\"\n    \" Use 0 to disable, -1 for automated scaling.\",\n    READ_ONLY GLOBAL_VAR(pfs_param.m_mutex_sizing), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(-1, 100 * 1024 * 1024), DEFAULT(PFS_AUTOSCALE_VALUE),\n    BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_ulong Sys_pfs_max_rwlock_classes(\n    \"performance_schema_max_rwlock_classes\",\n    \"Maximum number of rwlock instruments.\",\n    READ_ONLY GLOBAL_VAR(pfs_param.m_rwlock_class_sizing),\n    CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, 1024), DEFAULT(PFS_MAX_RWLOCK_CLASS),\n    BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_long Sys_pfs_max_rwlock_instances(\n    \"performance_schema_max_rwlock_instances\",\n    \"Maximum number of instrumented RWLOCK objects.\"\n    \" Use 0 to disable, -1 for automated scaling.\",\n    READ_ONLY GLOBAL_VAR(pfs_param.m_rwlock_sizing), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(-1, 100 * 1024 * 1024), DEFAULT(PFS_AUTOSCALE_VALUE),\n    BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_long Sys_pfs_max_table_handles(\n    \"performance_schema_max_table_handles\",\n    \"Maximum number of opened instrumented tables.\"\n    \" Use 0 to disable, -1 for automated scaling.\",\n    READ_ONLY GLOBAL_VAR(pfs_param.m_table_sizing), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(-1, 1024 * 1024), DEFAULT(PFS_AUTOSCALE_VALUE), BLOCK_SIZE(1),\n    PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_long Sys_pfs_max_table_instances(\n    \"performance_schema_max_table_instances\",\n    \"Maximum number of instrumented tables.\"\n    \" Use 0 to disable, -1 for automated scaling.\",\n    READ_ONLY GLOBAL_VAR(pfs_param.m_table_share_sizing),\n    CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 1024 * 1024),\n    DEFAULT(PFS_AUTOSCALE_VALUE), BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_long Sys_pfs_max_table_lock_stat(\n    \"performance_schema_max_table_lock_stat\",\n    \"Maximum number of lock statistics for instrumented tables.\"\n    \" Use 0 to disable, -1 for automated scaling.\",\n    READ_ONLY GLOBAL_VAR(pfs_param.m_table_lock_stat_sizing),\n    CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 1024 * 1024),\n    DEFAULT(PFS_AUTOSCALE_VALUE), BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_long Sys_pfs_max_index_stat(\n    \"performance_schema_max_index_stat\",\n    \"Maximum number of index statistics for instrumented tables.\"\n    \" Use 0 to disable, -1 for automated scaling.\",\n    READ_ONLY GLOBAL_VAR(pfs_param.m_index_stat_sizing), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(-1, 1024 * 1024), DEFAULT(PFS_AUTOSCALE_VALUE), BLOCK_SIZE(1),\n    PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_ulong Sys_pfs_max_thread_classes(\n    \"performance_schema_max_thread_classes\",\n    \"Maximum number of thread instruments.\",\n    READ_ONLY GLOBAL_VAR(pfs_param.m_thread_class_sizing),\n    CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, 1024), DEFAULT(PFS_MAX_THREAD_CLASS),\n    BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_long Sys_pfs_max_thread_instances(\n    \"performance_schema_max_thread_instances\",\n    \"Maximum number of instrumented threads.\"\n    \" Use 0 to disable, -1 for automated scaling.\",\n    READ_ONLY GLOBAL_VAR(pfs_param.m_thread_sizing), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(-1, 1024 * 1024), DEFAULT(PFS_AUTOSCALE_VALUE), BLOCK_SIZE(1),\n    PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_long Sys_pfs_setup_actors_size(\n    \"performance_schema_setup_actors_size\",\n    \"Maximum number of rows in SETUP_ACTORS.\"\n    \" Use 0 to disable, -1 for automated scaling.\",\n    READ_ONLY GLOBAL_VAR(pfs_param.m_setup_actor_sizing),\n    CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 1024 * 1024),\n    DEFAULT(PFS_AUTOSCALE_VALUE), BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_long Sys_pfs_setup_objects_size(\n    \"performance_schema_setup_objects_size\",\n    \"Maximum number of rows in SETUP_OBJECTS.\"\n    \" Use 0 to disable, -1 for automated scaling.\",\n    READ_ONLY GLOBAL_VAR(pfs_param.m_setup_object_sizing),\n    CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 1024 * 1024),\n    DEFAULT(PFS_AUTOSCALE_VALUE), BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_long Sys_pfs_accounts_size(\n    \"performance_schema_accounts_size\",\n    \"Maximum number of instrumented user@host accounts.\"\n    \" Use 0 to disable, -1 for automated scaling.\",\n    READ_ONLY GLOBAL_VAR(pfs_param.m_account_sizing), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(-1, 1024 * 1024), DEFAULT(PFS_AUTOSCALE_VALUE), BLOCK_SIZE(1),\n    PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_long Sys_pfs_hosts_size(\n    \"performance_schema_hosts_size\",\n    \"Maximum number of instrumented hosts.\"\n    \" Use 0 to disable, -1 for automated scaling.\",\n    READ_ONLY GLOBAL_VAR(pfs_param.m_host_sizing), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(-1, 1024 * 1024), DEFAULT(PFS_AUTOSCALE_VALUE), BLOCK_SIZE(1),\n    PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_long Sys_pfs_users_size(\n    \"performance_schema_users_size\",\n    \"Maximum number of instrumented users.\"\n    \" Use 0 to disable, -1 for automated scaling.\",\n    READ_ONLY GLOBAL_VAR(pfs_param.m_user_sizing), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(-1, 1024 * 1024), DEFAULT(PFS_AUTOSCALE_VALUE), BLOCK_SIZE(1),\n    PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_ulong Sys_pfs_max_stage_classes(\n    \"performance_schema_max_stage_classes\",\n    \"Maximum number of stage instruments.\",\n    READ_ONLY GLOBAL_VAR(pfs_param.m_stage_class_sizing),\n    CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, 1024), DEFAULT(PFS_MAX_STAGE_CLASS),\n    BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_long Sys_pfs_events_stages_history_long_size(\n    \"performance_schema_events_stages_history_long_size\",\n    \"Number of rows in EVENTS_STAGES_HISTORY_LONG.\"\n    \" Use 0 to disable, -1 for automated sizing.\",\n    READ_ONLY GLOBAL_VAR(pfs_param.m_events_stages_history_long_sizing),\n    CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 1024 * 1024),\n    DEFAULT(PFS_AUTOSIZE_VALUE), BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_long Sys_pfs_events_stages_history_size(\n    \"performance_schema_events_stages_history_size\",\n    \"Number of rows per thread in EVENTS_STAGES_HISTORY.\"\n    \" Use 0 to disable, -1 for automated sizing.\",\n    READ_ONLY GLOBAL_VAR(pfs_param.m_events_stages_history_sizing),\n    CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 1024), DEFAULT(PFS_AUTOSIZE_VALUE),\n    BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\n/**\n  Variable performance_schema_max_statement_classes.\n  The default number of statement classes is the sum of:\n  - COM_END for all regular \"statement/com/...\",\n  - 1 for \"statement/com/new_packet\", for unknown enum_server_command\n  - 1 for \"statement/com/Error\", for invalid enum_server_command\n  - SQLCOM_END for all regular \"statement/sql/...\",\n  - 1 for \"statement/sql/error\", for invalid enum_sql_command.\n  - SP_PSI_STATEMENT_INFO_COUNT for \"statement/sp/...\".\n  - CLONE_PSI_STATEMENT_COUNT for \"statement/clone/...\".\n  - 1 for \"statement/rpl/relay_log\", for replicated statements.\n  - 1 for \"statement/scheduler/event\", for scheduled events.\n*/\nstatic Sys_var_ulong Sys_pfs_max_statement_classes(\n    \"performance_schema_max_statement_classes\",\n    \"Maximum number of statement instruments.\",\n    READ_ONLY GLOBAL_VAR(pfs_param.m_statement_class_sizing),\n    CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, 256),\n    DEFAULT((ulong)SQLCOM_END + (ulong)COM_END + 5 +\n            SP_PSI_STATEMENT_INFO_COUNT + CLONE_PSI_STATEMENT_COUNT),\n    BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_long Sys_pfs_events_statements_history_long_size(\n    \"performance_schema_events_statements_history_long_size\",\n    \"Number of rows in EVENTS_STATEMENTS_HISTORY_LONG.\"\n    \" Use 0 to disable, -1 for automated sizing.\",\n    READ_ONLY GLOBAL_VAR(pfs_param.m_events_statements_history_long_sizing),\n    CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 1024 * 1024),\n    DEFAULT(PFS_AUTOSIZE_VALUE), BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_long Sys_pfs_events_statements_history_size(\n    \"performance_schema_events_statements_history_size\",\n    \"Number of rows per thread in EVENTS_STATEMENTS_HISTORY.\"\n    \" Use 0 to disable, -1 for automated sizing.\",\n    READ_ONLY GLOBAL_VAR(pfs_param.m_events_statements_history_sizing),\n    CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 1024), DEFAULT(PFS_AUTOSIZE_VALUE),\n    BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_ulong Sys_pfs_statement_stack_size(\n    \"performance_schema_max_statement_stack\",\n    \"Number of rows per thread in EVENTS_STATEMENTS_CURRENT.\",\n    READ_ONLY GLOBAL_VAR(pfs_param.m_statement_stack_sizing),\n    CMD_LINE(REQUIRED_ARG), VALID_RANGE(1, 256),\n    DEFAULT(PFS_STATEMENTS_STACK_SIZE), BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_ulong Sys_pfs_max_memory_classes(\n    \"performance_schema_max_memory_classes\",\n    \"Maximum number of memory pool instruments.\",\n    READ_ONLY GLOBAL_VAR(pfs_param.m_memory_class_sizing),\n    CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, 1024), DEFAULT(PFS_MAX_MEMORY_CLASS),\n    BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_long Sys_pfs_digest_size(\n    \"performance_schema_digests_size\",\n    \"Size of the statement digest.\"\n    \" Use 0 to disable, -1 for automated sizing.\",\n    READ_ONLY GLOBAL_VAR(pfs_param.m_digest_sizing), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(-1, 1024 * 1024), DEFAULT(PFS_AUTOSIZE_VALUE), BLOCK_SIZE(1),\n    PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_long Sys_pfs_events_transactions_history_long_size(\n    \"performance_schema_events_transactions_history_long_size\",\n    \"Number of rows in EVENTS_TRANSACTIONS_HISTORY_LONG.\"\n    \" Use 0 to disable, -1 for automated sizing.\",\n    READ_ONLY GLOBAL_VAR(pfs_param.m_events_transactions_history_long_sizing),\n    CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 1024 * 1024),\n    DEFAULT(PFS_AUTOSIZE_VALUE), BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_long Sys_pfs_events_transactions_history_size(\n    \"performance_schema_events_transactions_history_size\",\n    \"Number of rows per thread in EVENTS_TRANSACTIONS_HISTORY.\"\n    \" Use 0 to disable, -1 for automated sizing.\",\n    READ_ONLY GLOBAL_VAR(pfs_param.m_events_transactions_history_sizing),\n    CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 1024), DEFAULT(PFS_AUTOSIZE_VALUE),\n    BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_long Sys_pfs_max_digest_length(\n    \"performance_schema_max_digest_length\",\n    \"Maximum length considered for digest text, when stored in \"\n    \"performance_schema tables.\",\n    READ_ONLY GLOBAL_VAR(pfs_param.m_max_digest_length), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(0, 1024 * 1024), DEFAULT(1024), BLOCK_SIZE(1),\n    PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_ulong Sys_pfs_max_digest_sample_age(\n    \"performance_schema_max_digest_sample_age\",\n    \"The time in seconds after which a previous query sample is considered old.\"\n    \" When the value is 0, queries are sampled once.\"\n    \" When the value is greater than zero, queries are re sampled if the\"\n    \" last sample is more than performance_schema_max_digest_sample_age \"\n    \"seconds old.\",\n    GLOBAL_VAR(pfs_param.m_max_digest_sample_age), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(0, 1024 * 1024), DEFAULT(60), BLOCK_SIZE(1),\n    PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_long Sys_pfs_connect_attrs_size(\n    \"performance_schema_session_connect_attrs_size\",\n    \"Size of session attribute string buffer per thread.\"\n    \" Use 0 to disable, -1 for automated sizing.\",\n    READ_ONLY GLOBAL_VAR(pfs_param.m_session_connect_attrs_sizing),\n    CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 1024 * 1024),\n    DEFAULT(PFS_AUTOSIZE_VALUE), BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_long Sys_pfs_max_metadata_locks(\n    \"performance_schema_max_metadata_locks\",\n    \"Maximum number of metadata locks.\"\n    \" Use 0 to disable, -1 for automated scaling.\",\n    READ_ONLY GLOBAL_VAR(pfs_param.m_metadata_lock_sizing),\n    CMD_LINE(REQUIRED_ARG), VALID_RANGE(-1, 100 * 1024 * 1024),\n    DEFAULT(PFS_AUTOSCALE_VALUE), BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_long Sys_pfs_max_sql_text_length(\n    \"performance_schema_max_sql_text_length\",\n    \"Maximum length of displayed sql text.\",\n    READ_ONLY GLOBAL_VAR(pfs_param.m_max_sql_text_length),\n    CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, 1024 * 1024), DEFAULT(1024),\n    BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\nstatic Sys_var_long Sys_pfs_error_size(\n    \"performance_schema_error_size\", \"Number of server errors instrumented.\",\n    READ_ONLY GLOBAL_VAR(pfs_param.m_error_sizing), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(0, 1024 * 1024), DEFAULT(PFS_MAX_GLOBAL_SERVER_ERRORS),\n    BLOCK_SIZE(1), PFS_TRAILING_PROPERTIES);\n\n#endif /* WITH_PERFSCHEMA_STORAGE_ENGINE */\n\nstatic Sys_var_ulong Sys_auto_increment_increment(\n    \"auto_increment_increment\",\n    \"Auto-increment columns are incremented by this\",\n    HINT_UPDATEABLE SESSION_VAR(auto_increment_increment), CMD_LINE(OPT_ARG),\n    VALID_RANGE(1, 65535), DEFAULT(1), BLOCK_SIZE(1), NO_MUTEX_GUARD,\n    IN_BINLOG);\n\nstatic Sys_var_ulong Sys_auto_increment_offset(\n    \"auto_increment_offset\",\n    \"Offset added to Auto-increment columns. Used when \"\n    \"auto-increment-increment != 1\",\n    HINT_UPDATEABLE SESSION_VAR(auto_increment_offset), CMD_LINE(OPT_ARG),\n    VALID_RANGE(1, 65535), DEFAULT(1), BLOCK_SIZE(1), NO_MUTEX_GUARD,\n    IN_BINLOG);\n\nstatic Sys_var_bool Sys_windowing_use_high_precision(\n    \"windowing_use_high_precision\",\n    \"For SQL window functions, determines whether to enable inversion \"\n    \"optimization for moving window frames also for floating values.\",\n    HINT_UPDATEABLE SESSION_VAR(windowing_use_high_precision),\n    CMD_LINE(OPT_ARG), DEFAULT(true));\n\nstatic Sys_var_uint Sys_cte_max_recursion_depth(\n    \"cte_max_recursion_depth\",\n    \"Abort a recursive common table expression \"\n    \"if it does more than this number of iterations.\",\n    HINT_UPDATEABLE SESSION_VAR(cte_max_recursion_depth),\n    CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, UINT_MAX32), DEFAULT(1000),\n    BLOCK_SIZE(1));\n\nstatic Sys_var_bool Sys_automatic_sp_privileges(\n    \"automatic_sp_privileges\",\n    \"Creating and dropping stored procedures alters ACLs\",\n    GLOBAL_VAR(sp_automatic_privileges), CMD_LINE(OPT_ARG), DEFAULT(true));\n\nstatic Sys_var_ulong Sys_back_log(\n    \"back_log\",\n    \"The number of outstanding connection requests \"\n    \"MySQL can have. This comes into play when the main MySQL thread \"\n    \"gets very many connection requests in a very short time\",\n    READ_ONLY GLOBAL_VAR(back_log), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(0, 65535), DEFAULT(0), BLOCK_SIZE(1));\n\nstatic Sys_var_charptr Sys_basedir(\n    \"basedir\",\n    \"Path to installation directory. All paths are \"\n    \"usually resolved relative to this\",\n    READ_ONLY NON_PERSIST GLOBAL_VAR(mysql_home_ptr),\n    CMD_LINE(REQUIRED_ARG, 'b'), IN_FS_CHARSET, DEFAULT(nullptr));\n\nstatic Sys_var_charptr Sys_default_authentication_plugin(\n    \"default_authentication_plugin\",\n    \"The default authentication plugin \"\n    \"used by the server to hash the password.\",\n    READ_ONLY NON_PERSIST GLOBAL_VAR(default_auth_plugin),\n    CMD_LINE(REQUIRED_ARG), IN_FS_CHARSET, DEFAULT(\"caching_sha2_password\"));\n\nstatic PolyLock_mutex Plock_default_password_lifetime(\n    &LOCK_default_password_lifetime);\nstatic Sys_var_uint Sys_default_password_lifetime(\n    \"default_password_lifetime\",\n    \"The number of days after which the \"\n    \"password will expire.\",\n    GLOBAL_VAR(default_password_lifetime), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(0, UINT_MAX16), DEFAULT(0), BLOCK_SIZE(1),\n    &Plock_default_password_lifetime);\n\nstatic Sys_var_charptr Sys_my_bind_addr(\n    \"bind_address\",\n    \"IP address(es) to bind to. Syntax: address[,address]...,\"\n    \" where address can be an IPv4 address, IPv6 address,\"\n    \" host name or one of the wildcard values *, ::, 0.0.0.0.\"\n    \" In case more than one address is specified in a\"\n    \" comma-separated list, wildcard values are not allowed.\"\n    \" Every address can have optional network namespace separated\"\n    \" by the delimiter / from the address value. E.g., the following value\"\n    \" 192.168.1.1/red,172.16.1.1/green,193.168.1.1 specifies three IP\"\n    \" addresses to listen for incoming TCP connections two of that have\"\n    \" to be placed in corresponding namespaces: the address 192.168.1.1\"\n    \" must be placed into the namespace red and the address 172.16.1.1\"\n    \" must be placed into the namespace green. Using of network namespace\"\n    \" requires its support from underlying Operating System. Attempt to specify\"\n    \" a network namespace for a platform that doesn't support it results in\"\n    \" error during socket creation.\",\n    READ_ONLY NON_PERSIST GLOBAL_VAR(my_bind_addr_str), CMD_LINE(REQUIRED_ARG),\n    IN_FS_CHARSET, DEFAULT(MY_BIND_ALL_ADDRESSES));\n\nstatic Sys_var_charptr Sys_admin_addr(\n    \"admin_address\",\n    \"IP address to bind to for service connection. Address can be an IPv4\"\n    \" address, IPv6 address, or host name. Wildcard values *, ::, 0.0.0.0\"\n    \" are not allowed. Address value can have following optional network\"\n    \" namespace separated by the delimiter / from the address value.\"\n    \" E.g., the following value 192.168.1.1/red specifies IP addresses to\"\n    \" listen for incoming TCP connections that have to be placed into\"\n    \" the namespace 'red'. Using of network namespace requires its support\"\n    \" from underlying Operating System. Attempt to specify a network namespace\"\n    \" for a platform that doesn't support it results in error during socket\"\n    \" creation.\",\n    READ_ONLY NON_PERSIST GLOBAL_VAR(my_admin_bind_addr_str),\n    CMD_LINE(REQUIRED_ARG), IN_FS_CHARSET, DEFAULT(nullptr));\n\nstatic Sys_var_uint Sys_admin_port(\n    \"admin_port\",\n    \"Port number to use for service connection,\"\n    \" built-in default (\" STRINGIFY_ARG(MYSQL_ADMIN_PORT) \")\",\n    READ_ONLY NON_PERSIST GLOBAL_VAR(mysqld_admin_port), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(0, 65535), DEFAULT(MYSQL_ADMIN_PORT), BLOCK_SIZE(1));\n\nstatic Sys_var_bool Sys_use_separate_thread_for_admin(\n    \"create_admin_listener_thread\",\n    \"Use a dedicated thread for listening incoming connections on admin\"\n    \" interface\",\n    READ_ONLY NON_PERSIST GLOBAL_VAR(listen_admin_interface_in_separate_thread),\n    CMD_LINE(OPT_ARG), DEFAULT(false));\n\nstatic Sys_var_bool Sys_password_require_current(\n    \"password_require_current\",\n    \"Current password is needed to be specified in order to change it\",\n    GLOBAL_VAR(password_require_current), CMD_LINE(OPT_ARG), DEFAULT(false));\n\nstatic Sys_var_charptr Sys_my_proxy_protocol_networks(\n    \"proxy_protocol_networks\",\n    \"Enable proxy protocol for these source \"\n    \"networks. The syntax is a comma separated list of IPv4 and IPv6 \"\n    \"networks. If the network doesn't contain mask, it is considered to be \"\n    \"a single host. \\\"*\\\" represents all networks and must the only \"\n    \"directive on the line.\",\n    READ_ONLY GLOBAL_VAR(my_proxy_protocol_networks), CMD_LINE(REQUIRED_ARG),\n    IN_FS_CHARSET, DEFAULT(\"\"));\n\n/**\n  Checks,\n  if there exists at least a partial revoke on a database at the time\n  of turning OFF the system variable \"@@partial_revokes\". If it does then\n  throw error.\n  if there exists at least a DB grant with wildcard entry at the time of\n  turning ON the system variable \"@@partial_revokes\". If it does then\n  throw error.\n\n  @retval true failure\n  @retval false success\n\n  @param self the system variable to set value for\n  @param thd the session context\n  @param setv the SET operations metadata\n*/\nstatic bool check_partial_revokes(sys_var *self, THD *thd, set_var *setv) {\n  if (is_partial_revoke_exists(thd) && setv->save_result.ulonglong_value == 0) {\n    my_error(ER_PARTIAL_REVOKES_EXIST, MYF(0), self->name.str);\n    return true;\n  }\n  return false;\n}\n\n/** Sets the changed value to the corresponding atomic system variable */\nstatic bool partial_revokes_update(sys_var *, THD *, enum_var_type) {\n  set_mysqld_partial_revokes(opt_partial_revokes);\n  return false;\n}\n\nstatic Sys_var_bool Sys_partial_revokes(\n    \"partial_revokes\",\n    \"Access of database objects can be restricted, \"\n    \"even if user has global privileges granted.\",\n    GLOBAL_VAR(opt_partial_revokes), CMD_LINE(OPT_ARG),\n    DEFAULT(DEFAULT_PARTIAL_REVOKES), NO_MUTEX_GUARD, IN_BINLOG,\n    ON_CHECK(check_partial_revokes), ON_UPDATE(partial_revokes_update), nullptr,\n    sys_var::PARSE_EARLY);\n\nstatic bool fix_binlog_cache_size(sys_var *, THD *thd, enum_var_type) {\n  check_binlog_cache_size(thd);\n  return false;\n}\n\nstatic bool fix_binlog_stmt_cache_size(sys_var *, THD *thd, enum_var_type) {\n  check_binlog_stmt_cache_size(thd);\n  return false;\n}\n\nstatic Sys_var_ulong Sys_binlog_cache_size(\n    \"binlog_cache_size\",\n    \"The size of the transactional cache for \"\n    \"updates to transactional engines for the binary log. \"\n    \"If you often use transactions containing many statements, \"\n    \"you can increase this to get more performance\",\n    GLOBAL_VAR(binlog_cache_size), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(IO_SIZE, ULONG_MAX), DEFAULT(32768), BLOCK_SIZE(IO_SIZE),\n    NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(nullptr),\n    ON_UPDATE(fix_binlog_cache_size));\n\nstatic Sys_var_ulong Sys_binlog_stmt_cache_size(\n    \"binlog_stmt_cache_size\",\n    \"The size of the statement cache for \"\n    \"updates to non-transactional engines for the binary log. \"\n    \"If you often use statements updating a great number of rows, \"\n    \"you can increase this to get more performance\",\n    GLOBAL_VAR(binlog_stmt_cache_size), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(IO_SIZE, ULONG_MAX), DEFAULT(32768), BLOCK_SIZE(IO_SIZE),\n    NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(nullptr),\n    ON_UPDATE(fix_binlog_stmt_cache_size));\n\nstatic Sys_var_int32 Sys_binlog_max_flush_queue_time(\n    \"binlog_max_flush_queue_time\",\n    \"The maximum time that the binary log group commit will keep reading\"\n    \" transactions before it flush the transactions to the binary log (and\"\n    \" optionally sync, depending on the value of sync_binlog).\",\n    GLOBAL_VAR(opt_binlog_max_flush_queue_time),\n    CMD_LINE(REQUIRED_ARG, OPT_BINLOG_MAX_FLUSH_QUEUE_TIME),\n    VALID_RANGE(0, 100000), DEFAULT(0), BLOCK_SIZE(1), NO_MUTEX_GUARD,\n    NOT_IN_BINLOG, ON_CHECK(nullptr), ON_UPDATE(nullptr), DEPRECATED_VAR(\"\"));\n\nstatic Sys_var_long Sys_binlog_group_commit_sync_delay(\n    \"binlog_group_commit_sync_delay\",\n    \"The number of microseconds the server waits for the \"\n    \"binary log group commit sync queue to fill before \"\n    \"continuing. Default: 0. Min: 0. Max: 1000000.\",\n    GLOBAL_VAR(opt_binlog_group_commit_sync_delay), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(0, 1000000 /* max 1 sec */), DEFAULT(0), BLOCK_SIZE(1),\n    NO_MUTEX_GUARD, NOT_IN_BINLOG);\n\nstatic Sys_var_ulong Sys_binlog_group_commit_sync_no_delay_count(\n    \"binlog_group_commit_sync_no_delay_count\",\n    \"If there are this many transactions in the commit sync \"\n    \"queue and the server is waiting for more transactions \"\n    \"to be enqueued (as set using --binlog-group-commit-sync-delay), \"\n    \"the commit procedure resumes.\",\n    GLOBAL_VAR(opt_binlog_group_commit_sync_no_delay_count),\n    CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, 100000 /* max connections */),\n    DEFAULT(0), BLOCK_SIZE(1), NO_MUTEX_GUARD, NOT_IN_BINLOG);\n\nstatic bool check_outside_trx(sys_var *, THD *thd, set_var *var) {\n  if (thd->in_active_multi_stmt_transaction()) {\n    my_error(ER_VARIABLE_NOT_SETTABLE_IN_TRANSACTION, MYF(0),\n             var->var->name.str);\n    return true;\n  }\n  if (!thd->owned_gtid_is_empty()) {\n    char buf[Gtid::MAX_TEXT_LENGTH + 1];\n    if (thd->owned_gtid.sidno > 0)\n      thd->owned_gtid.to_string(thd->owned_sid, buf);\n    else\n      strcpy(buf, \"ANONYMOUS\");\n    my_error(ER_CANT_SET_VARIABLE_WHEN_OWNING_GTID, MYF(0), var->var->name.str,\n             buf);\n    return true;\n  }\n  return false;\n}\n\nstatic bool check_session_admin_outside_trx_outside_sf(sys_var *self, THD *thd,\n                                                       set_var *var) {\n  if (thd->in_sub_stmt) {\n    my_error(ER_VARIABLE_NOT_SETTABLE_IN_SF_OR_TRIGGER, MYF(0),\n             var->var->name.str);\n    return true;\n  }\n  if (check_outside_trx(self, thd, var)) return true;\n  if (self->scope() != sys_var::GLOBAL)\n    return check_session_admin(self, thd, var);\n  return false;\n}\n\nstatic bool check_explicit_defaults_for_timestamp(sys_var *self, THD *thd,\n                                                  set_var *var) {\n  // Deprecation warning if switching OFF explicit_defaults_for_timestamp\n  if (thd->variables.explicit_defaults_for_timestamp) {\n    if (!var->save_result.ulonglong_value)\n      push_warning_printf(thd, Sql_condition::SL_WARNING,\n                          ER_WARN_DEPRECATED_SYNTAX,\n                          ER_THD(thd, ER_WARN_DEPRECATED_SYNTAX_NO_REPLACEMENT),\n                          self->name.str);\n  }\n  if (thd->in_sub_stmt) {\n    my_error(ER_VARIABLE_NOT_SETTABLE_IN_SF_OR_TRIGGER, MYF(0),\n             var->var->name.str);\n    return true;\n  }\n  if (thd->in_active_multi_stmt_transaction()) {\n    my_error(ER_VARIABLE_NOT_SETTABLE_IN_TRANSACTION, MYF(0),\n             var->var->name.str);\n    return true;\n  }\n  return false;\n}\n\n/**\n  Check-function to @@GTID_NEXT system variable.\n\n  @param self   a pointer to the sys_var, i.e. gtid_next\n  @param thd    a reference to THD object\n  @param var    a pointer to the set_var created by the parser.\n\n  @return @c false if the change is allowed, otherwise @c true.\n*/\n\nstatic bool check_gtid_next(sys_var *self, THD *thd, set_var *var) {\n  bool is_prepared_trx =\n      thd->get_transaction()->xid_state()->has_state(XID_STATE::XA_PREPARED);\n\n  if (thd->in_sub_stmt) {\n    my_error(ER_VARIABLE_NOT_SETTABLE_IN_SF_OR_TRIGGER, MYF(0),\n             var->var->name.str);\n    return true;\n  }\n  if (!is_prepared_trx && thd->in_active_multi_stmt_transaction()) {\n    my_error(ER_VARIABLE_NOT_SETTABLE_IN_TRANSACTION, MYF(0),\n             var->var->name.str);\n    return true;\n  }\n  return check_session_admin_or_replication_applier(self, thd, var);\n}\n\nstatic bool check_session_admin_outside_trx_outside_sf_outside_sp(\n    sys_var *self, THD *thd, set_var *var) {\n  if (check_session_admin_outside_trx_outside_sf(self, thd, var)) return true;\n  if (thd->lex->sphead) {\n    my_error(ER_VARIABLE_NOT_SETTABLE_IN_SP, MYF(0), var->var->name.str);\n    return true;\n  }\n  return false;\n}\n\nstatic bool binlog_format_check(sys_var *self, THD *thd, set_var *var) {\n  if (check_session_admin(self, thd, var)) return true;\n\n  if (var->type == OPT_GLOBAL || var->type == OPT_PERSIST) {\n    /*\n      SET @@global.binlog_format and SET @@persist.binlog_format must be\n      disallowed if any replication channel has open temporary table(s).\n      Otherwise DROP TEMPORARY TABLE is written into binary log on slave\n      (which disobeys the simple rule: When @@session.binlog_format=\n       ROW/MIXED, the server must not write CREATE/DROP TEMPORARY TABLE\n      to the binary log) in the following case:\n        slave> SET @@global.binlog_format=STATEMENT;\n        slave> START SLAVE;\n        master> CREATE TEMPORARY TABLE t1(a INT);\n        slave> [wait for t1 to replicate]\n        slave> STOP SLAVE;\n        slave> SET @@global.binlog_format=ROW / SET @@persist.binlog_format=ROW\n        master> DROP TEMPORARY TABLE t1;\n        slave> START SLAVE;\n      Note: SET @@persist_only.binlog_format is not disallowed if any\n      replication channel has temporary table(s), since unlike PERSIST,\n      PERSIST_ONLY does not modify the runtime global system variable value.\n\n      SET @@global.binlog_format and SET @@persist.binlog_format must be\n      disallowed if any replication channel applier is running, because\n      SET @@global.binlog_format does not take effect when any replication\n      channel applier is running. SET @@global.binlog_format takes effect\n      on the channel until its applier is (re)starting.\n      Note: SET @@persist_only.binlog_format is not disallowed if any\n      replication channel applier is running, since unlike PERSIST,\n      PERSIST_ONLY does not modify the runtime global system variable value.\n    */\n    enum_slave_channel_status slave_channel_status =\n        has_any_slave_channel_open_temp_table_or_is_its_applier_running();\n    if (slave_channel_status == SLAVE_CHANNEL_APPLIER_IS_RUNNING) {\n      my_error(ER_RUNNING_APPLIER_PREVENTS_SWITCH_GLOBAL_BINLOG_FORMAT, MYF(0));\n      return true;\n    } else if (slave_channel_status == SLAVE_CHANNEL_HAS_OPEN_TEMPORARY_TABLE) {\n      my_error(ER_TEMP_TABLE_PREVENTS_SWITCH_GLOBAL_BINLOG_FORMAT, MYF(0));\n      return true;\n    }\n  }\n\n  if (!var->is_global_persist()) {\n    /*\n      SET @@session.binlog_format must be disallowed if the session has open\n      temporary table(s). Otherwise DROP TEMPORARY TABLE is written into\n      binary log (which disobeys the simple rule: When\n      @@session.binlog_format=ROW/MIXED, the server must not write\n      CREATE/DROP TEMPORARY TABLE to the binary log) in the following case:\n        SET @@session.binlog_format=STATEMENT;\n        CREATE TEMPORARY TABLE t1 (a INT);\n        SET @@session.binlog_format=ROW;\n        DROP TEMPORARY TABLE t1;\n      And more, if binlog_format=ROW/MIXED and the session has open temporary\n      table(s), these CREATE TEMPORARY TABLE are not written into the binlog,\n      so we can not switch to STATEMENT.\n    */\n    if (thd->temporary_tables) {\n      my_error(ER_TEMP_TABLE_PREVENTS_SWITCH_SESSION_BINLOG_FORMAT, MYF(0));\n      return true;\n    }\n\n    /*\n      if in a stored function/trigger, it's too late to change mode\n    */\n    if (thd->in_sub_stmt) {\n      my_error(ER_STORED_FUNCTION_PREVENTS_SWITCH_BINLOG_FORMAT, MYF(0));\n      return true;\n    }\n    /*\n      Make the session variable 'binlog_format' read-only inside a transaction.\n    */\n    if (thd->in_active_multi_stmt_transaction()) {\n      my_error(ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_BINLOG_FORMAT, MYF(0));\n      return true;\n    }\n  }\n\n  /*\n    If moving to statement format, and binlog_row_value_options is set,\n    generate a warning.\n  */\n  if (var->save_result.ulonglong_value == BINLOG_FORMAT_STMT) {\n    if ((var->is_global_persist() &&\n         global_system_variables.binlog_row_value_options != 0) ||\n        (!var->is_global_persist() &&\n         thd->variables.binlog_row_value_options != 0)) {\n      push_warning_printf(thd, Sql_condition::SL_WARNING,\n                          ER_WARN_BINLOG_PARTIAL_UPDATES_DISABLED,\n                          ER_THD(thd, ER_WARN_BINLOG_PARTIAL_UPDATES_DISABLED),\n                          \"binlog_format=STATEMENT\", \"PARTIAL_JSON\");\n    }\n  }\n\n  return false;\n}\n\nstatic bool fix_binlog_format_after_update(sys_var *, THD *thd,\n                                           enum_var_type type) {\n  if (type == OPT_SESSION) thd->reset_current_stmt_binlog_format_row();\n  return false;\n}\n\nstatic bool prevent_global_rbr_exec_mode_idempotent(sys_var *self, THD *,\n                                                    set_var *var) {\n  if (var->is_global_persist()) {\n    my_error(ER_LOCAL_VARIABLE, MYF(0), self->name.str);\n    return true;\n  }\n  return false;\n}\n\nstatic Sys_var_test_flag Sys_core_file(\"core_file\",\n                                       \"write a core-file on crashes\",\n                                       TEST_CORE_ON_SIGNAL);\n\nstatic Sys_var_enum Sys_binlog_format(\n    \"binlog_format\",\n    \"What form of binary logging the master will \"\n    \"use: either ROW for row-based binary logging, STATEMENT \"\n    \"for statement-based binary logging, or MIXED. MIXED is statement-\"\n    \"based binary logging except for those statements where only row-\"\n    \"based is correct: those which involve user-defined functions (i.e. \"\n    \"UDFs) or the UUID() function; for those, row-based binary logging is \"\n    \"automatically used. If NDBCLUSTER is enabled and binlog-format is \"\n    \"MIXED, the format switches to row-based and back implicitly per each \"\n    \"query accessing an NDBCLUSTER table\",\n    SESSION_VAR(binlog_format), CMD_LINE(REQUIRED_ARG, OPT_BINLOG_FORMAT),\n    binlog_format_names, DEFAULT(BINLOG_FORMAT_ROW), NO_MUTEX_GUARD,\n    NOT_IN_BINLOG, ON_CHECK(binlog_format_check),\n    ON_UPDATE(fix_binlog_format_after_update));\n\nstatic const char *rbr_exec_mode_names[] = {\"STRICT\", \"IDEMPOTENT\", nullptr};\nstatic Sys_var_enum rbr_exec_mode(\n    \"rbr_exec_mode\",\n    \"Modes for how row events should be executed. Legal values \"\n    \"are STRICT (default) and IDEMPOTENT. In IDEMPOTENT mode, \"\n    \"the server will not throw errors for operations that are idempotent. \"\n    \"In STRICT mode, server will throw errors for the operations that \"\n    \"cause a conflict.\",\n    SESSION_VAR(rbr_exec_mode_options), NO_CMD_LINE, rbr_exec_mode_names,\n    DEFAULT(RBR_EXEC_MODE_STRICT), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n    ON_CHECK(prevent_global_rbr_exec_mode_idempotent), ON_UPDATE(nullptr));\n\nstatic bool check_binlog_row_image(sys_var *self MY_ATTRIBUTE((unused)),\n                                   THD *thd, set_var *var) {\n  DBUG_TRACE;\n  if (check_session_admin(self, thd, var)) return true;\n  if (var->save_result.ulonglong_value == BINLOG_ROW_IMAGE_FULL) {\n    if ((var->is_global_persist() &&\n         global_system_variables.binlog_row_value_options != 0) ||\n        (!var->is_global_persist() &&\n         thd->variables.binlog_row_value_options != 0)) {\n      push_warning_printf(\n          thd, Sql_condition::SL_WARNING,\n          ER_WARN_BINLOG_PARTIAL_UPDATES_SUGGESTS_PARTIAL_IMAGES,\n          ER_THD(thd, ER_WARN_BINLOG_PARTIAL_UPDATES_SUGGESTS_PARTIAL_IMAGES),\n          \"binlog_row_image=FULL\", \"PARTIAL_JSON\");\n    }\n  }\n  return false;\n}\n\nstatic const char *binlog_row_image_names[] = {\"MINIMAL\", \"NOBLOB\", \"FULL\",\n                                               NullS};\nstatic Sys_var_enum Sys_binlog_row_image(\n    \"binlog_row_image\",\n    \"Controls whether rows should be logged in 'FULL', 'NOBLOB' or \"\n    \"'MINIMAL' formats. 'FULL', means that all columns in the before \"\n    \"and after image are logged. 'NOBLOB', means that mysqld avoids logging \"\n    \"blob columns whenever possible (e.g. blob column was not changed or \"\n    \"is not part of primary key). 'MINIMAL', means that a PK equivalent (PK \"\n    \"columns or full row if there is no PK in the table) is logged in the \"\n    \"before image, and only changed columns are logged in the after image. \"\n    \"(Default: FULL).\",\n    SESSION_VAR(binlog_row_image), CMD_LINE(REQUIRED_ARG),\n    binlog_row_image_names, DEFAULT(BINLOG_ROW_IMAGE_FULL), NO_MUTEX_GUARD,\n    NOT_IN_BINLOG, ON_CHECK(check_binlog_row_image), ON_UPDATE(nullptr));\n\nstatic const char *binlog_row_metadata_names[] = {\"MINIMAL\", \"FULL\", NullS};\nstatic Sys_var_enum Sys_binlog_row_metadata(\n    \"binlog_row_metadata\",\n    \"Controls whether metadata is logged using FULL or MINIMAL format. \"\n    \"FULL causes all metadata to be logged; MINIMAL means that only \"\n    \"metadata actually required by slave is logged. Default: MINIMAL.\",\n    GLOBAL_VAR(binlog_row_metadata), CMD_LINE(REQUIRED_ARG),\n    binlog_row_metadata_names, DEFAULT(BINLOG_ROW_METADATA_MINIMAL),\n    NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(nullptr), ON_UPDATE(nullptr));\n\nstatic bool check_binlog_trx_compression(sys_var *self MY_ATTRIBUTE((unused)),\n                                         THD *thd, set_var *var) {\n  DBUG_TRACE;\n  if (check_session_admin(self, thd, var)) return true;\n\n  if (!var->is_global_persist() && thd->in_active_multi_stmt_transaction()) {\n    my_error(ER_VARIABLE_NOT_SETTABLE_IN_TRANSACTION, MYF(0),\n             var->var->name.str);\n    return true;\n  }\n  return false;\n}\n\nstatic Sys_var_bool Sys_binlog_trx_compression(\n    \"binlog_transaction_compression\",\n    \"Whether to compress transactions or not. Transactions are compressed \"\n    \"using the ZSTD compression algorythm.\",\n    SESSION_VAR(binlog_trx_compression), CMD_LINE(OPT_ARG), DEFAULT(false),\n    NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(check_binlog_trx_compression));\n\n#include \"libbinlogevents/include/compression/zstd.h\"\nstatic Sys_var_uint Sys_binlog_transaction_compression_level_zstd(\n    \"binlog_transaction_compression_level_zstd\",\n    \"Specifies the transaction compression level for ZSTD \"\n    \"transaction compression in the binary log.\",\n    SESSION_VAR(binlog_trx_compression_level_zstd), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(1, 22),\n    DEFAULT(binary_log::transaction::compression::Zstd_comp::\n                DEFAULT_COMPRESSION_LEVEL),\n    BLOCK_SIZE(1), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n    ON_CHECK(check_binlog_trx_compression), ON_UPDATE(NULL));\n\nstatic bool on_session_track_gtids_update(sys_var *, THD *thd, enum_var_type) {\n  thd->session_tracker.get_tracker(SESSION_GTIDS_TRACKER)->update(thd);\n  return false;\n}\n\nstatic const char *session_track_gtids_names[] = {\"OFF\", \"OWN_GTID\",\n                                                  \"ALL_GTIDS\", NullS};\nstatic Sys_var_enum Sys_session_track_gtids(\n    \"session_track_gtids\",\n    \"Controls the amount of global transaction ids to be \"\n    \"included in the response packet sent by the server.\"\n    \"(Default: OFF).\",\n    SESSION_VAR(session_track_gtids), CMD_LINE(REQUIRED_ARG),\n    session_track_gtids_names, DEFAULT(OFF), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n    ON_CHECK(check_outside_trx), ON_UPDATE(on_session_track_gtids_update));\n\nstatic bool binlog_direct_check(sys_var *self, THD *thd, set_var *var) {\n  if (check_session_admin(self, thd, var)) return true;\n\n  if (var->is_global_persist()) return false;\n\n  /*\n    Makes the session variable 'binlog_direct_non_transactional_updates'\n    read-only if within a procedure, trigger or function.\n  */\n  if (thd->in_sub_stmt) {\n    my_error(ER_STORED_FUNCTION_PREVENTS_SWITCH_BINLOG_DIRECT, MYF(0));\n    return true;\n  }\n  /*\n    Makes the session variable 'binlog_direct_non_transactional_updates'\n    read-only inside a transaction.\n  */\n  if (thd->in_active_multi_stmt_transaction()) {\n    my_error(ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_BINLOG_DIRECT, MYF(0));\n    return true;\n  }\n\n  return false;\n}\n\nstatic Sys_var_bool Sys_binlog_direct(\n    \"binlog_direct_non_transactional_updates\",\n    \"Causes updates to non-transactional engines using statement format to \"\n    \"be written directly to binary log. Before using this option make sure \"\n    \"that there are no dependencies between transactional and \"\n    \"non-transactional tables such as in the statement INSERT INTO t_myisam \"\n    \"SELECT * FROM t_innodb; otherwise, slaves may diverge from the master.\",\n    SESSION_VAR(binlog_direct_non_trans_update), CMD_LINE(OPT_ARG),\n    DEFAULT(false), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n    ON_CHECK(binlog_direct_check));\n\n/**\n  This variable is read only to users. It can be enabled or disabled\n  only at mysqld startup. This variable is used by User thread and\n  as well as by replication slave applier thread to apply relay_log.\n  Slave applier thread enables/disables this option based on\n  relay_log's from replication master versions. There is possibility of\n  slave applier thread and User thread to have different setting for\n  explicit_defaults_for_timestamp, hence this options is defined as\n  SESSION_VAR rather than GLOBAL_VAR.\n*/\nstatic Sys_var_bool Sys_explicit_defaults_for_timestamp(\n    \"explicit_defaults_for_timestamp\",\n    \"This option causes CREATE TABLE to create all TIMESTAMP columns \"\n    \"as NULL with DEFAULT NULL attribute, Without this option, \"\n    \"TIMESTAMP columns are NOT NULL and have implicit DEFAULT clauses. \"\n    \"The old behavior is deprecated. \"\n    \"The variable can only be set by users having the SUPER privilege.\",\n    SESSION_VAR(explicit_defaults_for_timestamp), CMD_LINE(OPT_ARG),\n    DEFAULT(true), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n    ON_CHECK(check_explicit_defaults_for_timestamp));\n\nstatic bool repository_check(sys_var *self, THD *thd, set_var *var,\n                             SLAVE_THD_TYPE thread_mask) {\n  bool ret = false;\n  if (check_session_admin_outside_trx_outside_sf(self, thd, var)) return true;\n  Master_info *mi;\n  int running = 0;\n  const char *msg = nullptr;\n  bool rpl_info_option = static_cast<uint>(var->save_result.ulonglong_value);\n\n  /* don't convert if the repositories are same */\n  if (rpl_info_option == (thread_mask == SLAVE_THD_IO ? opt_mi_repository_id\n                                                      : opt_rli_repository_id))\n    return false;\n\n  channel_map.wrlock();\n\n  /* Repository conversion not possible, when multiple channels exist */\n  if (channel_map.get_num_instances(true) > 1) {\n    msg = \"Repository conversion is possible when only default channel exists\";\n    my_error(ER_CHANGE_RPL_INFO_REPOSITORY_FAILURE, MYF(0), msg);\n    channel_map.unlock();\n    return true;\n  }\n\n  mi = channel_map.get_default_channel_mi();\n\n  if (mi != nullptr) {\n    mi->channel_wrlock();\n    lock_slave_threads(mi);\n    init_thread_mask(&running, mi, false);\n    if (!running) {\n      switch (thread_mask) {\n        case SLAVE_THD_IO:\n          if (Rpl_info_factory::change_mi_repository(\n                  mi, static_cast<uint>(var->save_result.ulonglong_value),\n                  &msg)) {\n            ret = true;\n            my_error(ER_CHANGE_RPL_INFO_REPOSITORY_FAILURE, MYF(0), msg);\n          }\n          break;\n        case SLAVE_THD_SQL:\n          mts_recovery_groups(mi->rli);\n          if (!mi->rli->is_mts_recovery()) {\n            if (Rpl_info_factory::reset_workers(mi->rli) ||\n                Rpl_info_factory::change_rli_repository(\n                    mi->rli,\n                    static_cast<uint>(var->save_result.ulonglong_value),\n                    &msg)) {\n              ret = true;\n              my_error(ER_CHANGE_RPL_INFO_REPOSITORY_FAILURE, MYF(0), msg);\n            }\n          } else\n            LogErr(WARNING_LEVEL, ER_RPL_REPO_HAS_GAPS);\n          break;\n        default:\n          assert(0);\n          break;\n      }\n    } else {\n      ret = true;\n      my_error(ER_SLAVE_CHANNEL_MUST_STOP, MYF(0), mi->get_channel());\n    }\n    unlock_slave_threads(mi);\n    mi->channel_unlock();\n  }\n  channel_map.unlock();\n  return ret;\n}\n\nstatic bool relay_log_info_repository_check(sys_var *self, THD *thd,\n                                            set_var *var) {\n  return repository_check(self, thd, var, SLAVE_THD_SQL);\n}\n\nstatic bool master_info_repository_check(sys_var *self, THD *thd,\n                                         set_var *var) {\n  return repository_check(self, thd, var, SLAVE_THD_IO);\n}\n\nstatic bool relay_log_info_repository_update(sys_var *, THD *thd,\n                                             enum_var_type) {\n  if (opt_rli_repository_id == INFO_REPOSITORY_FILE) {\n    push_warning_printf(\n        thd, Sql_condition::SL_WARNING, ER_WARN_DEPRECATED_SYNTAX,\n        ER_THD(thd, ER_WARN_DEPRECATED_SYNTAX), \"FILE\", \"'TABLE'\");\n  }\n  return false;\n}\n\nstatic bool master_info_repository_update(sys_var *, THD *thd, enum_var_type) {\n  if (opt_mi_repository_id == INFO_REPOSITORY_FILE) {\n    push_warning_printf(\n        thd, Sql_condition::SL_WARNING, ER_WARN_DEPRECATED_SYNTAX,\n        ER_THD(thd, ER_WARN_DEPRECATED_SYNTAX), \"FILE\", \"'TABLE'\");\n  }\n  return false;\n}\n\nstatic const char *repository_names[] = {\"FILE\", \"TABLE\",\n#ifndef DBUG_OFF\n                                         \"DUMMY\",\n#endif\n                                         nullptr};\n\nulong opt_mi_repository_id = INFO_REPOSITORY_TABLE;\nstatic Sys_var_enum Sys_mi_repository(\n    \"master_info_repository\",\n    \"Defines the type of the repository for the master information.\",\n    GLOBAL_VAR(opt_mi_repository_id), CMD_LINE(REQUIRED_ARG), repository_names,\n    DEFAULT(INFO_REPOSITORY_TABLE), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n    ON_CHECK(master_info_repository_check),\n    ON_UPDATE(master_info_repository_update));\n\nulong opt_rli_repository_id = INFO_REPOSITORY_TABLE;\nstatic Sys_var_enum Sys_rli_repository(\n    \"relay_log_info_repository\",\n    \"Defines the type of the repository for the relay log information \"\n    \"and associated workers.\",\n    GLOBAL_VAR(opt_rli_repository_id), CMD_LINE(REQUIRED_ARG), repository_names,\n    DEFAULT(INFO_REPOSITORY_TABLE), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n    ON_CHECK(relay_log_info_repository_check),\n    ON_UPDATE(relay_log_info_repository_update));\n\nstatic Sys_var_bool Sys_binlog_rows_query(\n    \"binlog_rows_query_log_events\",\n    \"Allow writing of Rows_query_log events into binary log.\",\n    SESSION_VAR(binlog_rows_query_log_events), CMD_LINE(OPT_ARG),\n    DEFAULT(false), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n    ON_CHECK(check_session_admin));\n\nstatic Sys_var_bool Sys_binlog_order_commits(\n    \"binlog_order_commits\",\n    \"Issue internal commit calls in the same order as transactions are\"\n    \" written to the binary log. Default is to order commits.\",\n    GLOBAL_VAR(opt_binlog_order_commits), CMD_LINE(OPT_ARG), DEFAULT(true));\n\nstatic Sys_var_ulong Sys_bulk_insert_buff_size(\n    \"bulk_insert_buffer_size\",\n    \"Size of tree cache used in bulk \"\n    \"insert optimisation. Note that this is a limit per thread!\",\n    HINT_UPDATEABLE SESSION_VAR(bulk_insert_buff_size), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(0, ULONG_MAX), DEFAULT(8192 * 1024), BLOCK_SIZE(1),\n    NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(check_session_admin));\n\nstatic Sys_var_charptr Sys_character_sets_dir(\n    \"character_sets_dir\", \"Directory where character sets are\",\n    READ_ONLY NON_PERSIST GLOBAL_VAR(charsets_dir), CMD_LINE(REQUIRED_ARG),\n    IN_FS_CHARSET, DEFAULT(nullptr));\n\nstatic bool check_not_null(sys_var *, THD *, set_var *var) {\n  return var->value && var->value->is_null();\n}\n\n/**\n  Check storage engine is not empty and log warning.\n\n  Checks if default_storage_engine or default_tmp_storage_engine is set\n  empty and return true. This method also logs warning if the\n  storage engine set is a disabled storage engine specified in\n  disabled_storage_engines.\n\n  @param self    pointer to system variable object.\n  @param thd     Connection handle.\n  @param var     pointer to set variable object.\n\n  @return  true if the set variable is empty.\n           false if the set variable is not empty.\n*/\nstatic bool check_storage_engine(sys_var *self, THD *thd, set_var *var) {\n  if (check_not_null(self, thd, var)) return true;\n\n  if (!opt_initialize && !opt_noacl) {\n    char buff[STRING_BUFFER_USUAL_SIZE];\n    String str(buff, sizeof(buff), system_charset_info), *res;\n    LEX_CSTRING se_name;\n\n    if (var->value) {\n      res = var->value->val_str(&str);\n      lex_cstring_set(&se_name, res->ptr());\n    } else {\n      // Use the default value defined by sys_var.\n      lex_cstring_set(&se_name,\n                      pointer_cast<const char *>(\n                          down_cast<Sys_var_plugin *>(self)->global_value_ptr(\n                              thd, nullptr)));\n    }\n\n    plugin_ref plugin;\n    if ((plugin = ha_resolve_by_name(nullptr, &se_name, false))) {\n      handlerton *hton = plugin_data<handlerton *>(plugin);\n      if (ha_is_storage_engine_disabled(hton))\n        LogErr(WARNING_LEVEL, ER_DISABLED_STORAGE_ENGINE_AS_DEFAULT,\n               self->name.str, se_name.str);\n      plugin_unlock(nullptr, plugin);\n    }\n  }\n  return false;\n}\n\nstatic bool check_charset(sys_var *, THD *thd, set_var *var) {\n  if (!var->value) return false;\n\n  char buff[STRING_BUFFER_USUAL_SIZE];\n  if (var->value->result_type() == STRING_RESULT) {\n    String str(buff, sizeof(buff), system_charset_info), *res;\n    if (!(res = var->value->val_str(&str)))\n      var->save_result.ptr = nullptr;\n    else {\n      ErrConvString err(res); /* Get utf8 '\\0' terminated string */\n      if (!(var->save_result.ptr =\n                get_charset_by_csname(err.ptr(), MY_CS_PRIMARY, MYF(0))) &&\n          !(var->save_result.ptr = get_old_charset_by_name(err.ptr()))) {\n        my_error(ER_UNKNOWN_CHARACTER_SET, MYF(0), err.ptr());\n        return true;\n      }\n      warn_on_deprecated_charset(\n          thd, static_cast<const CHARSET_INFO *>(var->save_result.ptr),\n          err.ptr());\n    }\n  } else  // INT_RESULT\n  {\n    int csno = (int)var->value->val_int();\n    if (!(var->save_result.ptr = get_charset(csno, MYF(0)))) {\n      my_error(ER_UNKNOWN_CHARACTER_SET, MYF(0), llstr(csno, buff));\n      return true;\n    }\n    warn_on_deprecated_charset(\n        thd, static_cast<const CHARSET_INFO *>(var->save_result.ptr),\n        static_cast<const CHARSET_INFO *>(var->save_result.ptr)->name);\n  }\n  return false;\n}\nstatic bool check_charset_not_null(sys_var *self, THD *thd, set_var *var) {\n  return check_charset(self, thd, var) || check_not_null(self, thd, var);\n}\n\nnamespace {\nstruct Get_name {\n  explicit Get_name(const CHARSET_INFO *ci) : m_ci(ci) {}\n  const uchar *get_name() const {\n    return pointer_cast<const uchar *>(m_ci->name);\n  }\n  const CHARSET_INFO *m_ci;\n};\n\nstruct Get_csname {\n  explicit Get_csname(const CHARSET_INFO *ci) : m_ci(ci) {}\n  const uchar *get_name() const {\n    return pointer_cast<const uchar *>(m_ci->csname);\n  }\n  const CHARSET_INFO *m_ci;\n};\n\n}  // namespace\n\nstatic CHARSET_INFO *charset_system_default = &my_charset_utf8_general_ci;\n\nstatic Sys_var_struct<CHARSET_INFO, Get_csname> Sys_character_set_system(\n    \"character_set_system\",\n    \"The character set used by the server \"\n    \"for storing identifiers\",\n    READ_ONLY NON_PERSIST GLOBAL_VAR(system_charset_info), NO_CMD_LINE,\n    DEFAULT(&charset_system_default));\n\nstatic Sys_var_struct<CHARSET_INFO, Get_csname> Sys_character_set_server(\n    \"character_set_server\", \"The default character set\",\n    SESSION_VAR(collation_server), NO_CMD_LINE, DEFAULT(&default_charset_info),\n    NO_MUTEX_GUARD, IN_BINLOG, ON_CHECK(check_charset_not_null));\n\nstatic bool check_charset_db(sys_var *self, THD *thd, set_var *var) {\n  if (check_session_admin(self, thd, var)) return true;\n  if (check_charset_not_null(self, thd, var)) return true;\n  if (!var->value)  // = DEFAULT\n    var->save_result.ptr = thd->db_charset;\n  return false;\n}\nstatic bool update_deprecated(sys_var *self, THD *thd, enum_var_type) {\n  push_warning_printf(\n      thd, Sql_condition::SL_WARNING, ER_WARN_DEPRECATED_SYNTAX_NO_REPLACEMENT,\n      ER_THD(thd, ER_WARN_DEPRECATED_SYSVAR_UPDATE), self->name.str);\n  return false;\n}\nstatic Sys_var_struct<CHARSET_INFO, Get_csname> Sys_character_set_database(\n    \"character_set_database\", \" The character set used by the default database\",\n    SESSION_VAR(collation_database), NO_CMD_LINE,\n    DEFAULT(&default_charset_info), NO_MUTEX_GUARD, IN_BINLOG,\n    ON_CHECK(check_charset_db), ON_UPDATE(update_deprecated));\n\nstatic bool check_cs_client(sys_var *self, THD *thd, set_var *var) {\n  if (check_charset_not_null(self, thd, var)) return true;\n\n  // Currently, UCS-2 cannot be used as a client character set\n  return (static_cast<const CHARSET_INFO *>(var->save_result.ptr))->mbminlen >\n         1;\n}\nstatic bool fix_thd_charset(sys_var *, THD *thd, enum_var_type type) {\n  if (type == OPT_SESSION) thd->update_charset();\n  return false;\n}\nstatic Sys_var_struct<CHARSET_INFO, Get_csname> Sys_character_set_client(\n    \"character_set_client\",\n    \"The character set for statements \"\n    \"that arrive from the client\",\n    SESSION_VAR(character_set_client), NO_CMD_LINE,\n    DEFAULT(&default_charset_info), NO_MUTEX_GUARD, IN_BINLOG,\n    ON_CHECK(check_cs_client), ON_UPDATE(fix_thd_charset));\n\nstatic Sys_var_struct<CHARSET_INFO, Get_csname> Sys_character_set_connection(\n    \"character_set_connection\",\n    \"The character set used for \"\n    \"literals that do not have a character set introducer and for \"\n    \"number-to-string conversion\",\n    SESSION_VAR(collation_connection), NO_CMD_LINE,\n    DEFAULT(&default_charset_info), NO_MUTEX_GUARD, IN_BINLOG,\n    ON_CHECK(check_charset_not_null), ON_UPDATE(fix_thd_charset));\n\nstatic Sys_var_struct<CHARSET_INFO, Get_csname> Sys_character_set_results(\n    \"character_set_results\",\n    \"The character set used for returning \"\n    \"query results to the client\",\n    SESSION_VAR(character_set_results), NO_CMD_LINE,\n    DEFAULT(&default_charset_info), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n    ON_CHECK(check_charset));\n\nstatic bool check_cs_filesystem(sys_var *self, THD *thd, set_var *var) {\n  if (check_session_admin(self, thd, var)) return true;\n  if (check_charset_not_null(self, thd, var)) return true;\n\n  return false;\n}\n\nstatic Sys_var_struct<CHARSET_INFO, Get_csname> Sys_character_set_filesystem(\n    \"character_set_filesystem\", \"The filesystem character set\",\n    SESSION_VAR(character_set_filesystem), NO_CMD_LINE,\n    DEFAULT(&character_set_filesystem), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n    ON_CHECK(check_cs_filesystem), ON_UPDATE(fix_thd_charset));\n\nstatic const char *completion_type_names[] = {\"NO_CHAIN\", \"CHAIN\", \"RELEASE\",\n                                              nullptr};\nstatic Sys_var_enum Sys_completion_type(\n    \"completion_type\",\n    \"The transaction completion type, one of \"\n    \"NO_CHAIN, CHAIN, RELEASE\",\n    SESSION_VAR(completion_type), CMD_LINE(REQUIRED_ARG), completion_type_names,\n    DEFAULT(0));\n\nstatic bool check_collation_not_null(sys_var *self, THD *thd, set_var *var) {\n  if (!var->value) return false;\n\n  char buff[STRING_BUFFER_USUAL_SIZE];\n  if (var->value->result_type() == STRING_RESULT) {\n    String str(buff, sizeof(buff), system_charset_info), *res;\n    if (!(res = var->value->val_str(&str)))\n      var->save_result.ptr = nullptr;\n    else {\n      ErrConvString err(res); /* Get utf8 '\\0'-terminated string */\n      if (!(var->save_result.ptr = get_charset_by_name(err.ptr(), MYF(0)))) {\n        my_error(ER_UNKNOWN_COLLATION, MYF(0), err.ptr());\n        return true;\n      }\n    }\n  } else  // INT_RESULT\n  {\n    int csno = (int)var->value->val_int();\n    if (!(var->save_result.ptr = get_charset(csno, MYF(0)))) {\n      my_error(ER_UNKNOWN_COLLATION, MYF(0), llstr(csno, buff));\n      return true;\n    }\n  }\n  if (var->save_result.ptr) {\n    warn_on_deprecated_collation(\n        thd, static_cast<const CHARSET_INFO *>(var->save_result.ptr));\n  }\n\n  return check_not_null(self, thd, var);\n}\nstatic Sys_var_struct<CHARSET_INFO, Get_name> Sys_collation_connection(\n    \"collation_connection\",\n    \"The collation of the connection \"\n    \"character set\",\n    SESSION_VAR(collation_connection), NO_CMD_LINE,\n    DEFAULT(&default_charset_info), NO_MUTEX_GUARD, IN_BINLOG,\n    ON_CHECK(check_collation_not_null), ON_UPDATE(fix_thd_charset));\n\nstatic bool check_collation_db(sys_var *self, THD *thd, set_var *var) {\n  if (check_collation_not_null(self, thd, var)) return true;\n  if (!var->value)  // = DEFAULT\n    var->save_result.ptr = thd->db_charset;\n  return false;\n}\nstatic Sys_var_struct<CHARSET_INFO, Get_name> Sys_collation_database(\n    \"collation_database\",\n    \"The collation of the database \"\n    \"character set\",\n    SESSION_VAR(collation_database), NO_CMD_LINE,\n    DEFAULT(&default_charset_info), NO_MUTEX_GUARD, IN_BINLOG,\n    ON_CHECK(check_collation_db), ON_UPDATE(update_deprecated));\n\nstatic Sys_var_struct<CHARSET_INFO, Get_name> Sys_collation_server(\n    \"collation_server\", \"The server default collation\",\n    SESSION_VAR(collation_server), NO_CMD_LINE, DEFAULT(&default_charset_info),\n    NO_MUTEX_GUARD, IN_BINLOG, ON_CHECK(check_collation_not_null));\n\nstatic const char *concurrent_insert_names[] = {\"NEVER\", \"AUTO\", \"ALWAYS\",\n                                                nullptr};\nstatic Sys_var_enum Sys_concurrent_insert(\n    \"concurrent_insert\",\n    \"Use concurrent insert with MyISAM. Possible \"\n    \"values are NEVER, AUTO, ALWAYS\",\n    GLOBAL_VAR(myisam_concurrent_insert), CMD_LINE(OPT_ARG),\n    concurrent_insert_names, DEFAULT(1));\n\nstatic Sys_var_ulong Sys_connect_timeout(\n    \"connect_timeout\",\n    \"The number of seconds the mysqld server is waiting for a connect \"\n    \"packet before responding with 'Bad handshake'\",\n    GLOBAL_VAR(connect_timeout), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(2, LONG_TIMEOUT), DEFAULT(CONNECT_TIMEOUT), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_information_schema_stats_expiry(\n    \"information_schema_stats_expiry\",\n    \"The number of seconds after which mysqld server will fetch \"\n    \"data from storage engine and replace the data in cache.\",\n    SESSION_VAR(information_schema_stats_expiry), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(0, LONG_TIMEOUT), DEFAULT(24 * 60 * 60), BLOCK_SIZE(1));\n\nstatic Sys_var_charptr Sys_datadir(\n    \"datadir\", \"Path to the database root directory\",\n    READ_ONLY NON_PERSIST GLOBAL_VAR(mysql_real_data_home_ptr),\n    CMD_LINE(REQUIRED_ARG, 'h'), IN_FS_CHARSET, DEFAULT(mysql_real_data_home));\n\n#ifndef DBUG_OFF\nstatic Sys_var_dbug Sys_dbug(\"debug\", \"Debug log\", sys_var::SESSION,\n                             CMD_LINE(OPT_ARG, '#'), DEFAULT(\"\"),\n                             NO_MUTEX_GUARD, NOT_IN_BINLOG,\n                             ON_CHECK(check_session_admin));\n#endif\n\n/**\n  @todo\n    When updating myisam_delay_key_write, we should do a 'flush tables'\n    of all MyISAM tables to ensure that they are reopen with the\n    new attribute.\n*/\nexport bool fix_delay_key_write(sys_var *, THD *, enum_var_type) {\n  switch (delay_key_write_options) {\n    case DELAY_KEY_WRITE_NONE:\n      myisam_delay_key_write = false;\n      break;\n    case DELAY_KEY_WRITE_ON:\n      myisam_delay_key_write = true;\n      break;\n    case DELAY_KEY_WRITE_ALL:\n      myisam_delay_key_write = true;\n      ha_open_options |= HA_OPEN_DELAY_KEY_WRITE;\n      break;\n  }\n  return false;\n}\n\n/**\n   Make sure we don't have an active TABLE FOR BACKUP lock when setting\n   delay_key_writes=ALL dynamically.\n*/\nstatic bool check_delay_key_write(sys_var *self MY_ATTRIBUTE((unused)),\n                                  THD *thd, set_var *var) {\n  DBUG_ASSERT(delay_key_write_options != DELAY_KEY_WRITE_ALL ||\n              !thd->backup_tables_lock.is_acquired());\n\n  if (var->save_result.ulonglong_value == DELAY_KEY_WRITE_ALL) {\n    const ulong timeout = thd->variables.lock_wait_timeout;\n\n    if (thd->backup_tables_lock.abort_if_acquired() ||\n        thd->backup_tables_lock.acquire_protection(thd, MDL_STATEMENT, timeout))\n      return true;\n  }\n\n  return false;\n}\n\nstatic const char *delay_key_write_names[] = {\"OFF\", \"ON\", \"ALL\", NullS};\nstatic Sys_var_enum Sys_delay_key_write(\n    \"delay_key_write\", \"Type of DELAY_KEY_WRITE\",\n    GLOBAL_VAR(delay_key_write_options), CMD_LINE(OPT_ARG),\n    delay_key_write_names, DEFAULT(DELAY_KEY_WRITE_ON), NO_MUTEX_GUARD,\n    NOT_IN_BINLOG, ON_CHECK(check_delay_key_write),\n    ON_UPDATE(fix_delay_key_write));\n\nstatic Sys_var_ulong Sys_delayed_insert_limit(\n    \"delayed_insert_limit\",\n    \"After inserting delayed_insert_limit rows, the INSERT DELAYED \"\n    \"handler will check if there are any SELECT statements pending. \"\n    \"If so, it allows these to execute before continuing. \"\n    \"This variable is deprecated along with INSERT DELAYED.\",\n    GLOBAL_VAR(delayed_insert_limit), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(1, ULONG_MAX), DEFAULT(DELAYED_LIMIT), BLOCK_SIZE(1),\n    NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(nullptr), ON_UPDATE(nullptr),\n    DEPRECATED_VAR(\"\"));\n\nstatic Sys_var_ulong Sys_delayed_insert_timeout(\n    \"delayed_insert_timeout\",\n    \"How long a INSERT DELAYED thread should wait for INSERT statements \"\n    \"before terminating. \"\n    \"This variable is deprecated along with INSERT DELAYED.\",\n    GLOBAL_VAR(delayed_insert_timeout), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(1, LONG_TIMEOUT), DEFAULT(DELAYED_WAIT_TIMEOUT), BLOCK_SIZE(1),\n    NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(nullptr), ON_UPDATE(nullptr),\n    DEPRECATED_VAR(\"\"));\n\nstatic Sys_var_ulong Sys_delayed_queue_size(\n    \"delayed_queue_size\",\n    \"What size queue (in rows) should be allocated for handling INSERT \"\n    \"DELAYED. If the queue becomes full, any client that does INSERT \"\n    \"DELAYED will wait until there is room in the queue again. \"\n    \"This variable is deprecated along with INSERT DELAYED.\",\n    GLOBAL_VAR(delayed_queue_size), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(1, ULONG_MAX), DEFAULT(DELAYED_QUEUE_SIZE), BLOCK_SIZE(1),\n    NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(nullptr), ON_UPDATE(nullptr),\n    DEPRECATED_VAR(\"\"));\n\nstatic const char *event_scheduler_names[] = {\"OFF\", \"ON\", \"DISABLED\", NullS};\nstatic bool event_scheduler_check(sys_var *, THD *, set_var *var) {\n  /* DISABLED is only accepted on the command line */\n  if (var->save_result.ulonglong_value == Events::EVENTS_DISABLED) return true;\n  if (Events::opt_event_scheduler == Events::EVENTS_DISABLED) {\n    my_error(ER_OPTION_PREVENTS_STATEMENT, MYF(0),\n             \"--event-scheduler=DISABLED or --skip-grant-tables\");\n    return true;\n  }\n  return false;\n}\nstatic bool event_scheduler_update(sys_var *, THD *, enum_var_type) {\n  int err_no = 0;\n  ulong opt_event_scheduler_value = Events::opt_event_scheduler;\n  mysql_mutex_unlock(&LOCK_global_system_variables);\n  /*\n    Events::start() is heavyweight. In particular it creates a new THD,\n    which takes LOCK_global_system_variables internally.\n    Thus we have to release it here.\n    We need to re-take it before returning, though.\n\n    Note that since we release LOCK_global_system_variables before calling\n    start/stop, there is a possibility that the server variable\n    can become out of sync with the real event scheduler state.\n\n    This can happen with two concurrent statments if the first gets\n    interrupted after start/stop but before retaking\n    LOCK_global_system_variables. However, this problem should be quite\n    rare and it's difficult to avoid it without opening up possibilities\n    for deadlocks. See bug#51160.\n  */\n  bool ret = opt_event_scheduler_value == Events::EVENTS_ON\n                 ? Events::start(&err_no)\n                 : Events::stop();\n  mysql_mutex_lock(&LOCK_global_system_variables);\n  if (ret) {\n    Events::opt_event_scheduler = Events::EVENTS_OFF;\n    my_error(ER_EVENT_SET_VAR_ERROR, MYF(0), err_no);\n  }\n  return ret;\n}\n\nstatic Sys_var_enum Sys_event_scheduler(\n    \"event_scheduler\",\n    \"Enable the event scheduler. Possible values are \"\n    \"ON, OFF, and DISABLED (keep the event scheduler completely \"\n    \"deactivated, it cannot be activated run-time)\",\n    GLOBAL_VAR(Events::opt_event_scheduler), CMD_LINE(OPT_ARG),\n    event_scheduler_names, DEFAULT(Events::EVENTS_ON), NO_MUTEX_GUARD,\n    NOT_IN_BINLOG, ON_CHECK(event_scheduler_check),\n    ON_UPDATE(event_scheduler_update));\n\nstatic bool check_expire_logs_days(sys_var *, THD *, set_var *var) {\n  ulonglong expire_logs_days_value = var->save_result.ulonglong_value;\n\n  if (expire_logs_days_value && binlog_expire_logs_seconds) {\n    my_error(ER_BINLOG_EXPIRE_LOG_DAYS_AND_SECS_USED_TOGETHER, MYF(0));\n    return true;\n  }\n  return false;\n}\n\nstatic bool check_expire_logs_seconds(sys_var *, THD *, set_var *var) {\n  ulonglong expire_logs_seconds_value = var->save_result.ulonglong_value;\n\n  if (expire_logs_days && expire_logs_seconds_value) {\n    my_error(ER_EXPIRE_LOGS_DAYS_IGNORED, MYF(0));\n    return true;\n  }\n  return false;\n}\n\nstatic Sys_var_bool Sys_expand_fast_index_creation(\n    \"expand_fast_index_creation\",\n    \"Enable/disable improvements to the InnoDB fast index creation \"\n    \"functionality. Has no effect when fast index creation is disabled with \"\n    \"the fast-index-creation option\",\n    SESSION_VAR(expand_fast_index_creation), CMD_LINE(OPT_ARG), DEFAULT(false));\n\nstatic Sys_var_ulong Sys_expire_logs_days(\n    \"expire_logs_days\",\n    \"If non-zero, binary logs will be purged after expire_logs_days \"\n    \"days; If this option alone is set on the command line or in a \"\n    \"configuration file, it overrides the default value for \"\n    \"binlog-expire-logs-seconds. If both options are set to nonzero values, \"\n    \"binlog-expire-logs-seconds takes priority. Possible purges happen at \"\n    \"startup and at binary log rotation.\",\n    GLOBAL_VAR(expire_logs_days), CMD_LINE(REQUIRED_ARG, OPT_EXPIRE_LOGS_DAYS),\n    VALID_RANGE(0, 99), DEFAULT(0), BLOCK_SIZE(1), NO_MUTEX_GUARD,\n    NOT_IN_BINLOG, ON_CHECK(check_expire_logs_days), ON_UPDATE(nullptr),\n    DEPRECATED_VAR(\"binlog_expire_logs_seconds\"));\n\nstatic Sys_var_ulonglong Sys_binlog_space_limit(\n    \"binlog_space_limit\",\n    \"Maximum space to use for all binary logs. \"\n    \"Default is 0, this feature is disabled.\",\n    READ_ONLY GLOBAL_VAR(binlog_space_limit), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(0, ULONG_MAX), DEFAULT(0), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_binlog_expire_logs_seconds(\n    \"binlog_expire_logs_seconds\",\n    \"If non-zero, binary logs will be purged after binlog_expire_logs_seconds\"\n    \" seconds; If both this option and expire_logs_days are set to non-zero\"\n    \"  values, this option takes priority. Purges happen at\"\n    \" startup and at binary log rotation.\",\n    GLOBAL_VAR(binlog_expire_logs_seconds),\n    CMD_LINE(REQUIRED_ARG, OPT_BINLOG_EXPIRE_LOGS_SECONDS),\n    VALID_RANGE(0, 0xFFFFFFFF), DEFAULT(2592000), BLOCK_SIZE(1), NO_MUTEX_GUARD,\n    NOT_IN_BINLOG, ON_CHECK(check_expire_logs_seconds), ON_UPDATE(nullptr));\n\nstatic Sys_var_bool Sys_flush(\n    \"flush\", \"Flush MyISAM tables to disk between SQL commands\",\n    GLOBAL_VAR(myisam_flush), CMD_LINE(OPT_ARG), DEFAULT(false));\n\nstatic Sys_var_ulong Sys_flush_time(\n    \"flush_time\",\n    \"A dedicated thread is created to flush all tables at the \"\n    \"given interval\",\n    GLOBAL_VAR(flush_time), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(0, LONG_TIMEOUT), DEFAULT(0), BLOCK_SIZE(1));\n\nstatic bool check_ftb_syntax(sys_var *, THD *, set_var *var) {\n  return ft_boolean_check_syntax_string(\n      (uchar *)(var->save_result.string_value.str));\n}\n/// @todo make SESSION_VAR (usability enhancement and a fix for a race\n/// condition)\nstatic Sys_var_charptr Sys_ft_boolean_syntax(\n    \"ft_boolean_syntax\",\n    \"List of operators for \"\n    \"MATCH ... AGAINST ( ... IN BOOLEAN MODE)\",\n    GLOBAL_VAR(ft_boolean_syntax), CMD_LINE(REQUIRED_ARG), IN_SYSTEM_CHARSET,\n    DEFAULT(DEFAULT_FTB_SYNTAX), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n    ON_CHECK(check_ftb_syntax));\n\nstatic Sys_var_ulong Sys_ft_max_word_len(\n    \"ft_max_word_len\",\n    \"The maximum length of the word to be included in a FULLTEXT index. \"\n    \"Note: FULLTEXT indexes must be rebuilt after changing this variable\",\n    READ_ONLY GLOBAL_VAR(ft_max_word_len), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(10, HA_FT_MAXCHARLEN), DEFAULT(HA_FT_MAXCHARLEN),\n    BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_ft_min_word_len(\n    \"ft_min_word_len\",\n    \"The minimum length of the word to be included in a FULLTEXT index. \"\n    \"Note: FULLTEXT indexes must be rebuilt after changing this variable\",\n    READ_ONLY GLOBAL_VAR(ft_min_word_len), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(1, HA_FT_MAXCHARLEN), DEFAULT(4), BLOCK_SIZE(1));\n\n/// @todo make it an updatable SESSION_VAR\nstatic Sys_var_ulong Sys_ft_query_expansion_limit(\n    \"ft_query_expansion_limit\",\n    \"Number of best matches to use for query expansion\",\n    READ_ONLY GLOBAL_VAR(ft_query_expansion_limit), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(0, 1000), DEFAULT(20), BLOCK_SIZE(1));\n\nstatic Sys_var_charptr Sys_ft_stopword_file(\n    \"ft_stopword_file\", \"Use stopwords from this file instead of built-in list\",\n    READ_ONLY NON_PERSIST GLOBAL_VAR(ft_stopword_file), CMD_LINE(REQUIRED_ARG),\n    IN_FS_CHARSET, DEFAULT(nullptr));\n\nstatic Sys_var_bool Sys_ft_query_extra_word_chars(\n    \"ft_query_extra_word_chars\",\n    \"If enabled, all non-whitespace characters are considered word symbols \"\n    \"for full text search queries\",\n    SESSION_VAR(ft_query_extra_word_chars), CMD_LINE(OPT_ARG), DEFAULT(false));\n\nstatic bool check_init_string(sys_var *, THD *, set_var *var) {\n  if (var->save_result.string_value.str == nullptr) {\n    var->save_result.string_value.str = const_cast<char *>(\"\");\n    var->save_result.string_value.length = 0;\n  }\n  return false;\n}\nstatic PolyLock_rwlock PLock_sys_init_connect(&LOCK_sys_init_connect);\nstatic Sys_var_lexstring Sys_init_connect(\n    \"init_connect\",\n    \"Command(s) that are executed for each \"\n    \"new connection\",\n    GLOBAL_VAR(opt_init_connect), CMD_LINE(REQUIRED_ARG), IN_SYSTEM_CHARSET,\n    DEFAULT(\"\"), &PLock_sys_init_connect, NOT_IN_BINLOG,\n    ON_CHECK(check_init_string));\n\nstatic Sys_var_charptr Sys_init_file(\n    \"init_file\", \"Read SQL commands from this file at startup\",\n    READ_ONLY NON_PERSIST GLOBAL_VAR(opt_init_file), CMD_LINE(REQUIRED_ARG),\n    IN_FS_CHARSET, DEFAULT(nullptr));\n\nstatic PolyLock_rwlock PLock_sys_init_slave(&LOCK_sys_init_slave);\nstatic Sys_var_lexstring Sys_init_slave(\n    \"init_slave\",\n    \"Command(s) that are executed by a slave server \"\n    \"each time the SQL thread starts\",\n    GLOBAL_VAR(opt_init_slave), CMD_LINE(REQUIRED_ARG), IN_SYSTEM_CHARSET,\n    DEFAULT(\"\"), &PLock_sys_init_slave, NOT_IN_BINLOG,\n    ON_CHECK(check_init_string));\n\nstatic Sys_var_ulong Sys_interactive_timeout(\n    \"interactive_timeout\",\n    \"The number of seconds the server waits for activity on an interactive \"\n    \"connection before closing it\",\n    SESSION_VAR(net_interactive_timeout), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(1, LONG_TIMEOUT), DEFAULT(NET_WAIT_TIMEOUT), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_join_buffer_size(\n    \"join_buffer_size\", \"The size of the buffer that is used for full joins\",\n    HINT_UPDATEABLE SESSION_VAR(join_buff_size), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(128, ULONG_MAX), DEFAULT(256 * 1024), BLOCK_SIZE(128));\n\nstatic Sys_var_keycache Sys_key_buffer_size(\n    \"key_buffer_size\",\n    \"The size of the buffer used for \"\n    \"index blocks for MyISAM tables. Increase this to get better index \"\n    \"handling (for all reads and multiple writes) to as much as you can \"\n    \"afford\",\n    KEYCACHE_VAR(param_buff_size), CMD_LINE(REQUIRED_ARG, OPT_KEY_BUFFER_SIZE),\n    VALID_RANGE(0, SIZE_T_MAX), DEFAULT(KEY_CACHE_SIZE), BLOCK_SIZE(IO_SIZE),\n    NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(nullptr),\n    ON_UPDATE(update_buffer_size));\n\nstatic Sys_var_keycache Sys_key_cache_block_size(\n    \"key_cache_block_size\", \"The default size of key cache blocks\",\n    KEYCACHE_VAR(param_block_size),\n    CMD_LINE(REQUIRED_ARG, OPT_KEY_CACHE_BLOCK_SIZE),\n    VALID_RANGE(512, 1024 * 16), DEFAULT(KEY_CACHE_BLOCK_SIZE), BLOCK_SIZE(512),\n    NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(nullptr),\n    ON_UPDATE(update_keycache_param));\n\nstatic Sys_var_keycache Sys_key_cache_division_limit(\n    \"key_cache_division_limit\",\n    \"The minimum percentage of warm blocks in key cache\",\n    KEYCACHE_VAR(param_division_limit),\n    CMD_LINE(REQUIRED_ARG, OPT_KEY_CACHE_DIVISION_LIMIT), VALID_RANGE(1, 100),\n    DEFAULT(100), BLOCK_SIZE(1), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n    ON_CHECK(nullptr), ON_UPDATE(update_keycache_param));\n\nstatic Sys_var_keycache Sys_key_cache_age_threshold(\n    \"key_cache_age_threshold\",\n    \"This characterizes the number of \"\n    \"hits a hot block has to be untouched until it is considered aged \"\n    \"enough to be downgraded to a warm block. This specifies the \"\n    \"percentage ratio of that number of hits to the total number of \"\n    \"blocks in key cache\",\n    KEYCACHE_VAR(param_age_threshold),\n    CMD_LINE(REQUIRED_ARG, OPT_KEY_CACHE_AGE_THRESHOLD),\n    VALID_RANGE(100, ULONG_MAX), DEFAULT(300), BLOCK_SIZE(100), NO_MUTEX_GUARD,\n    NOT_IN_BINLOG, ON_CHECK(nullptr), ON_UPDATE(update_keycache_param));\n\nstatic Sys_var_bool Sys_large_files_support(\n    \"large_files_support\",\n    \"Whether mysqld was compiled with options for large file support\",\n    READ_ONLY NON_PERSIST GLOBAL_VAR(opt_large_files), NO_CMD_LINE,\n    DEFAULT(sizeof(my_off_t) > 4));\n\nstatic Sys_var_uint Sys_large_page_size(\n    \"large_page_size\",\n    \"If large page support is enabled, this shows the size of memory pages\",\n    READ_ONLY NON_PERSIST GLOBAL_VAR(opt_large_page_size), NO_CMD_LINE,\n    VALID_RANGE(0, UINT_MAX), DEFAULT(0), BLOCK_SIZE(1));\n\nstatic Sys_var_bool Sys_large_pages(\"large_pages\",\n                                    \"Enable support for large pages\",\n                                    READ_ONLY GLOBAL_VAR(opt_large_pages),\n                                    IF_WIN(NO_CMD_LINE, CMD_LINE(OPT_ARG)),\n                                    DEFAULT(false));\n\nstatic Sys_var_charptr Sys_language(\n    \"lc_messages_dir\", \"Directory where error messages are\",\n    READ_ONLY NON_PERSIST GLOBAL_VAR(lc_messages_dir_ptr),\n    CMD_LINE(REQUIRED_ARG, OPT_LC_MESSAGES_DIRECTORY), IN_FS_CHARSET,\n    DEFAULT(nullptr));\n\nstatic Sys_var_bool Sys_local_infile(\"local_infile\",\n                                     \"Enable LOAD DATA LOCAL INFILE\",\n                                     GLOBAL_VAR(opt_local_infile),\n                                     CMD_LINE(OPT_ARG), DEFAULT(false));\n\nstatic Sys_var_ulong Sys_lock_wait_timeout(\n    \"lock_wait_timeout\",\n    \"Timeout in seconds to wait for a lock before returning an error.\",\n    HINT_UPDATEABLE SESSION_VAR(lock_wait_timeout), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(1, LONG_TIMEOUT), DEFAULT(LONG_TIMEOUT), BLOCK_SIZE(1));\n\n#ifdef HAVE_MLOCKALL\nstatic Sys_var_bool Sys_locked_in_memory(\n    \"locked_in_memory\", \"Whether mysqld was locked in memory with --memlock\",\n    READ_ONLY NON_PERSIST GLOBAL_VAR(locked_in_memory), NO_CMD_LINE,\n    DEFAULT(false));\n#endif\n\n/* this says NO_CMD_LINE, as command-line option takes a string, not a bool */\nstatic Sys_var_bool Sys_log_bin(\"log_bin\", \"Whether the binary log is enabled\",\n                                READ_ONLY NON_PERSIST GLOBAL_VAR(opt_bin_log),\n                                NO_CMD_LINE, DEFAULT(true));\n\nstatic bool transaction_write_set_check(sys_var *self, THD *thd, set_var *var) {\n  if (check_session_admin(self, thd, var)) return true;\n  // Can't change the algorithm when group replication is enabled.\n  if (is_group_replication_running()) {\n    my_message(\n        ER_GROUP_REPLICATION_RUNNING,\n        \"The write set algorithm cannot be changed when Group replication\"\n        \" is running.\",\n        MYF(0));\n    return true;\n  }\n\n  if ((var->is_global_persist()) &&\n      global_system_variables.binlog_format != BINLOG_FORMAT_ROW) {\n    my_error(ER_PREVENTS_VARIABLE_WITHOUT_RBR, MYF(0), var->var->name.str);\n    return true;\n  }\n\n  if (var->type == OPT_SESSION &&\n      thd->variables.binlog_format != BINLOG_FORMAT_ROW) {\n    my_error(ER_PREVENTS_VARIABLE_WITHOUT_RBR, MYF(0), var->var->name.str);\n    return true;\n  }\n  /*\n    if in a stored function/trigger, it's too late to change\n  */\n  if (thd->in_sub_stmt) {\n    my_error(ER_VARIABLE_NOT_SETTABLE_IN_TRANSACTION, MYF(0),\n             var->var->name.str);\n    return true;\n  }\n  /*\n    Make the session variable 'transaction_write_set_extraction' read-only\n    inside a transaction.\n  */\n  if (thd->in_active_multi_stmt_transaction()) {\n    my_error(ER_VARIABLE_NOT_SETTABLE_IN_TRANSACTION, MYF(0),\n             var->var->name.str);\n    return true;\n  }\n  /*\n    Disallow changing variable 'transaction_write_set_extraction' while\n    binlog_transaction_dependency_tracking is different from COMMIT_ORDER.\n  */\n  if (mysql_bin_log.m_dependency_tracker.m_opt_tracking_mode !=\n      DEPENDENCY_TRACKING_COMMIT_ORDER) {\n    my_error(ER_WRONG_USAGE, MYF(0),\n             \"transaction_write_set_extraction (changed)\",\n             \"binlog_transaction_dependency_tracking (!= COMMIT_ORDER)\");\n    return true;\n  }\n\n  return false;\n}\n\nstatic Sys_var_enum Sys_extract_write_set(\n    \"transaction_write_set_extraction\",\n    \"This option is used to let the server know when to \"\n    \"extract the write set which will be used for various purposes. \",\n    SESSION_VAR(transaction_write_set_extraction), CMD_LINE(OPT_ARG),\n    transaction_write_set_hashing_algorithms, DEFAULT(HASH_ALGORITHM_XXHASH64),\n    NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(transaction_write_set_check),\n    ON_UPDATE(nullptr));\n\nstatic Sys_var_ulong Sys_rpl_stop_slave_timeout(\n    \"rpl_stop_slave_timeout\",\n    \"Timeout in seconds to wait for slave to stop before returning a \"\n    \"warning.\",\n    GLOBAL_VAR(rpl_stop_slave_timeout), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(2, LONG_TIMEOUT), DEFAULT(LONG_TIMEOUT), BLOCK_SIZE(1));\n\nstatic Sys_var_enum Sys_binlog_error_action(\n    \"binlog_error_action\",\n    \"When statements cannot be written to the binary log due to a fatal \"\n    \"error, the server can either ignore the error and let the master \"\n    \"continue, or abort.\",\n    GLOBAL_VAR(binlog_error_action), CMD_LINE(REQUIRED_ARG),\n    binlog_error_action_list, DEFAULT(ABORT_SERVER));\n\nstatic Sys_var_bool Sys_binlog_skip_flush_commands(\n    \"binlog_skip_flush_commands\",\n    \"If set to TRUE, FLUSH <XXX> commands will not be be written \"\n    \"to the binary log\",\n    GLOBAL_VAR(opt_binlog_skip_flush_commands), CMD_LINE(OPT_ARG),\n    DEFAULT(false));\n\nstatic Sys_var_bool Sys_trust_function_creators(\n    \"log_bin_trust_function_creators\",\n    \"If set to FALSE (the default), then when --log-bin is used, creation \"\n    \"of a stored function (or trigger) is allowed only to users having the \"\n    \"SUPER privilege and only if this stored function (trigger) may not \"\n    \"break binary logging. Note that if ALL connections to this server \"\n    \"ALWAYS use row-based binary logging, the security issues do not \"\n    \"exist and the binary logging cannot break, so you can safely set \"\n    \"this to TRUE\",\n    GLOBAL_VAR(trust_function_creators), CMD_LINE(OPT_ARG), DEFAULT(false));\n\nstatic Sys_var_bool Sys_check_proxy_users(\n    \"check_proxy_users\",\n    \"If set to FALSE (the default), then proxy user identity will not be \"\n    \"mapped for authentication plugins which support mapping from grant \"\n    \"tables.  When set to TRUE, users associated with authentication \"\n    \"plugins which signal proxy user mapping should be done according to \"\n    \"GRANT PROXY privilege definition.\",\n    GLOBAL_VAR(check_proxy_users), CMD_LINE(OPT_ARG), DEFAULT(false));\n\nstatic Sys_var_bool Sys_mysql_native_password_proxy_users(\n    \"mysql_native_password_proxy_users\",\n    \"If set to FALSE (the default), then the mysql_native_password \"\n    \"plugin will not signal for authenticated users to be checked for \"\n    \"mapping \"\n    \"to proxy users.  When set to TRUE, the plugin will flag associated \"\n    \"authenticated accounts to be mapped to proxy users when the server \"\n    \"option \"\n    \"check_proxy_users is enabled.\",\n    GLOBAL_VAR(mysql_native_password_proxy_users), CMD_LINE(OPT_ARG),\n    DEFAULT(false));\n\nstatic Sys_var_bool Sys_sha256_password_proxy_users(\n    \"sha256_password_proxy_users\",\n    \"If set to FALSE (the default), then the sha256_password authentication \"\n    \"plugin will not signal for authenticated users to be checked for \"\n    \"mapping \"\n    \"to proxy users.  When set to TRUE, the plugin will flag associated \"\n    \"authenticated accounts to be mapped to proxy users when the server \"\n    \"option \"\n    \"check_proxy_users is enabled.\",\n    GLOBAL_VAR(sha256_password_proxy_users), CMD_LINE(OPT_ARG), DEFAULT(false));\n\nstatic bool check_log_bin_use_v1_row_events(sys_var *, THD *thd, set_var *var) {\n  if (var->save_result.ulonglong_value == 1 &&\n      global_system_variables.binlog_row_value_options != 0)\n    push_warning_printf(thd, Sql_condition::SL_WARNING,\n                        ER_WARN_BINLOG_V1_ROW_EVENTS_DISABLED,\n                        ER_THD(thd, ER_WARN_BINLOG_V1_ROW_EVENTS_DISABLED),\n                        \"binlog_row_value_options=PARTIAL_JSON\");\n  return false;\n}\n\nstatic Sys_var_bool Sys_log_bin_use_v1_row_events(\n    \"log_bin_use_v1_row_events\",\n    \"If equal to 1 then version 1 row events are written to a row based \"\n    \"binary log.  If equal to 0, then the latest version of events are \"\n    \"written.  \"\n    \"This option is useful during some upgrades.\",\n    NON_PERSIST GLOBAL_VAR(log_bin_use_v1_row_events),\n    CMD_LINE(OPT_ARG, OPT_LOG_BIN_USE_V1_ROW_EVENTS), DEFAULT(false),\n    NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(check_log_bin_use_v1_row_events),\n    ON_UPDATE(nullptr), DEPRECATED_VAR(\"\"));\n\nstatic Sys_var_charptr Sys_log_error(\n    \"log_error\", \"Error log file\",\n    READ_ONLY NON_PERSIST GLOBAL_VAR(log_error_dest),\n    CMD_LINE(OPT_ARG, OPT_LOG_ERROR), IN_FS_CHARSET,\n    DEFAULT(disabled_my_option), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n    ON_CHECK(nullptr), ON_UPDATE(nullptr), nullptr, sys_var::PARSE_EARLY);\n\nstatic bool check_log_error_services(sys_var *self, THD *thd, set_var *var) {\n  // test whether syntax is OK and services exist\n  size_t pos;\n\n  if (var->save_result.string_value.str == nullptr) return true;\n\n  if (log_builtins_error_stack(var->save_result.string_value.str, true, &pos) <\n      0) {\n    push_warning_printf(\n        thd, Sql_condition::SL_WARNING, ER_CANT_SET_ERROR_LOG_SERVICE,\n        ER_THD(thd, ER_CANT_SET_ERROR_LOG_SERVICE), self->name.str,\n        &((char *)var->save_result.string_value.str)[pos]);\n    return true;\n  } else if (strlen(var->save_result.string_value.str) < 1) {\n    push_warning_printf(\n        thd, Sql_condition::SL_WARNING, ER_EMPTY_PIPELINE_FOR_ERROR_LOG_SERVICE,\n        ER_THD(thd, ER_EMPTY_PIPELINE_FOR_ERROR_LOG_SERVICE), self->name.str);\n  }\n\n  return false;\n}\n\nstatic bool fix_log_error_services(sys_var *self MY_ATTRIBUTE((unused)),\n                                   THD *thd,\n                                   enum_var_type type MY_ATTRIBUTE((unused))) {\n  // syntax is OK and services exist; try to initialize them!\n  size_t pos;\n  if (log_builtins_error_stack(opt_log_error_services, false, &pos) < 0) {\n    if (pos < strlen(opt_log_error_services)) /* purecov: begin inspected */\n      push_warning_printf(\n          thd, Sql_condition::SL_WARNING, ER_CANT_START_ERROR_LOG_SERVICE,\n          ER_THD(thd, ER_CANT_START_ERROR_LOG_SERVICE), self->name.str,\n          &((char *)opt_log_error_services)[pos]);\n    return true; /* purecov: end */\n  }\n\n  return false;\n}\n\nstatic Sys_var_charptr Sys_log_error_services(\n    \"log_error_services\",\n    \"Services that should be called when an error event is received\",\n    GLOBAL_VAR(opt_log_error_services), CMD_LINE(REQUIRED_ARG),\n    IN_SYSTEM_CHARSET, DEFAULT(LOG_ERROR_SERVICES_DEFAULT), NO_MUTEX_GUARD,\n    NOT_IN_BINLOG, ON_CHECK(check_log_error_services),\n    ON_UPDATE(fix_log_error_services));\n\nstatic bool check_log_error_suppression_list(sys_var *self, THD *thd,\n                                             set_var *var) {\n  int i;\n\n  if (var->save_result.string_value.str == nullptr) return true;\n\n  if ((i = log_builtins_filter_parse_suppression_list(\n           var->save_result.string_value.str, false)) < 0) {\n    push_warning_printf(\n        thd, Sql_condition::SL_WARNING, ER_CANT_SET_ERROR_SUPPRESSION_LIST,\n        ER_THD(thd, ER_CANT_SET_ERROR_SUPPRESSION_LIST), self->name.str,\n        &((char *)var->save_result.string_value.str)[-(i + 1)]);\n    return true;\n  }\n\n  return false;\n}\n\nstatic bool fix_log_error_suppression_list(\n    sys_var *self MY_ATTRIBUTE((unused)), THD *thd MY_ATTRIBUTE((unused)),\n    enum_var_type type MY_ATTRIBUTE((unused))) {\n  // syntax is OK and errcodes have messages; try to make filter rules for\n  // them!\n  int rr = log_builtins_filter_parse_suppression_list(\n      opt_log_error_suppression_list, true);\n  return (rr < 0) ? true : false;\n}\n\nstatic Sys_var_charptr Sys_log_error_suppression_list(\n    \"log_error_suppression_list\",\n    \"Comma-separated list of error-codes. Error messages corresponding to \"\n    \"these codes will not be included in the error log. Only events with a \"\n    \"severity of Warning or Information can be suppressed; events with \"\n    \"System \"\n    \"or Error severity will always be included. Requires the filter \"\n    \"\\'log_filter_internal\\' to be set in @@global.log_error_services, which \"\n    \"is the default.\",\n    GLOBAL_VAR(opt_log_error_suppression_list), CMD_LINE(REQUIRED_ARG),\n    IN_SYSTEM_CHARSET, DEFAULT(\"\"), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n    ON_CHECK(check_log_error_suppression_list),\n    ON_UPDATE(fix_log_error_suppression_list));\n\nstatic Sys_var_bool Sys_log_queries_not_using_indexes(\n    \"log_queries_not_using_indexes\",\n    \"Log queries that are executed without benefit of any index to the \"\n    \"slow log if it is open\",\n    GLOBAL_VAR(opt_log_queries_not_using_indexes), CMD_LINE(OPT_ARG),\n    DEFAULT(false));\n\nstatic Sys_var_bool Sys_log_slow_admin_statements(\n    \"log_slow_admin_statements\",\n    \"Log slow OPTIMIZE, ANALYZE, ALTER and other administrative statements \"\n    \"to \"\n    \"the slow log if it is open.\",\n    GLOBAL_VAR(opt_log_slow_admin_statements), CMD_LINE(OPT_ARG),\n    DEFAULT(false));\n\nstatic Sys_var_bool Sys_log_slow_slave_statements(\n    \"log_slow_slave_statements\",\n    \"Log slow statements executed by slave thread to the slow log if it is \"\n    \"open.\",\n    GLOBAL_VAR(opt_log_slow_slave_statements), CMD_LINE(OPT_ARG),\n    DEFAULT(false));\n\nstatic bool update_log_throttle_queries_not_using_indexes(sys_var *, THD *thd,\n                                                          enum_var_type) {\n  // Check if we should print a summary of any suppressed lines to the slow\n  // log now since opt_log_throttle_queries_not_using_indexes was changed.\n  log_throttle_qni.flush(thd);\n  return false;\n}\n\nstatic Sys_var_ulong Sys_log_throttle_queries_not_using_indexes(\n    \"log_throttle_queries_not_using_indexes\",\n    \"Log at most this many 'not using index' warnings per minute to the \"\n    \"slow log. Any further warnings will be condensed into a single \"\n    \"summary line. A value of 0 disables throttling. \"\n    \"Option has no effect unless --log_queries_not_using_indexes is set.\",\n    GLOBAL_VAR(opt_log_throttle_queries_not_using_indexes),\n    CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, ULONG_MAX), DEFAULT(0),\n    BLOCK_SIZE(1), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(nullptr),\n    ON_UPDATE(update_log_throttle_queries_not_using_indexes));\n\nstatic bool update_log_error_verbosity(sys_var *, THD *, enum_var_type) {\n  return (log_builtins_filter_update_verbosity(log_error_verbosity) < 0);\n}\n\nstatic Sys_var_ulong Sys_log_error_verbosity(\n    \"log_error_verbosity\",\n    \"How detailed the error log should be. \"\n    \"1, log errors only. \"\n    \"2, log errors and warnings. \"\n    \"3, log errors, warnings, and notes. \"\n    \"Messages sent to the client are unaffected by this setting.\",\n    GLOBAL_VAR(log_error_verbosity), CMD_LINE(REQUIRED_ARG), VALID_RANGE(1, 3),\n    DEFAULT(2), BLOCK_SIZE(1), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(nullptr),\n    ON_UPDATE(update_log_error_verbosity), nullptr,\n    /* 1. my_init_signals() allows to use setrlimit() which can generate\n       LogErr() that depends on log_error_verbosity\n       2. my_init_signals() was moved before sys_var::PARSE_NORMAL */\n    sys_var::PARSE_EARLY);\n\nstatic Sys_var_enum Sys_log_timestamps(\n    \"log_timestamps\",\n    \"UTC to timestamp log files in zulu time, for more concise timestamps \"\n    \"and easier correlation of logs from servers from multiple time zones, \"\n    \"or SYSTEM to use the system's local time. \"\n    \"This affects only log files, not log tables, as the timestamp columns \"\n    \"of the latter can be converted at will.\",\n    GLOBAL_VAR(opt_log_timestamps), CMD_LINE(REQUIRED_ARG),\n    timestamp_type_names, DEFAULT(0), NO_MUTEX_GUARD, NOT_IN_BINLOG);\n\nstatic Sys_var_bool Sys_log_statements_unsafe_for_binlog(\n    \"log_statements_unsafe_for_binlog\",\n    \"Log statements considered unsafe when using statement based binary \"\n    \"logging.\",\n    GLOBAL_VAR(opt_log_unsafe_statements), CMD_LINE(OPT_ARG), DEFAULT(true));\n\nstatic bool update_cached_long_query_time(sys_var *, THD *thd,\n                                          enum_var_type type) noexcept {\n  if (type == OPT_SESSION)\n    thd->variables.long_query_time =\n        double2ulonglong(thd->variables.long_query_time_double * 1e6);\n  else\n    global_system_variables.long_query_time =\n        double2ulonglong(global_system_variables.long_query_time_double * 1e6);\n  return false;\n}\n\nstatic Sys_var_double Sys_long_query_time(\n    \"long_query_time\",\n    \"Log all queries that have taken more than long_query_time seconds \"\n    \"to execute to file. The argument will be treated as a decimal value \"\n    \"with microsecond precision\",\n    SESSION_VAR(long_query_time_double), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(0, LONG_TIMEOUT), DEFAULT(10), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n    ON_CHECK(nullptr), ON_UPDATE(update_cached_long_query_time));\n\n#ifndef DBUG_OFF\nstatic bool update_cached_query_exec_time(sys_var *self MY_ATTRIBUTE((unused)),\n                                          THD *thd, enum_var_type type) {\n  if (type == OPT_SESSION)\n    thd->variables.query_exec_time =\n        double2ulonglong(thd->variables.query_exec_time_double * 1e6);\n  else\n    global_system_variables.query_exec_time =\n        double2ulonglong(global_system_variables.query_exec_time_double * 1e6);\n  return false;\n}\n\nstatic Sys_var_double Sys_query_exec_time(\n    \"query_exec_time\",\n    \"Pretend queries take this many seconds. When 0 (the default) use the \"\n    \"actual execution time. Used only for debugging.\",\n    SESSION_VAR(query_exec_time_double), NO_CMD_LINE,\n    VALID_RANGE(0, LONG_TIMEOUT), DEFAULT(0), NO_MUTEX_GUARD, IN_BINLOG,\n    ON_CHECK(nullptr), ON_UPDATE(update_cached_query_exec_time));\n#endif\n\nstatic bool fix_low_prio_updates(sys_var *, THD *thd, enum_var_type type) {\n  if (type == OPT_SESSION) {\n    thd->update_lock_default =\n        (thd->variables.low_priority_updates ? TL_WRITE_LOW_PRIORITY\n                                             : TL_WRITE);\n    thd->insert_lock_default =\n        (thd->variables.low_priority_updates ? TL_WRITE_LOW_PRIORITY\n                                             : TL_WRITE_CONCURRENT_INSERT);\n  } else\n    thr_upgraded_concurrent_insert_lock =\n        (global_system_variables.low_priority_updates ? TL_WRITE_LOW_PRIORITY\n                                                      : TL_WRITE);\n  return false;\n}\nstatic Sys_var_bool Sys_low_priority_updates(\n    \"low_priority_updates\",\n    \"INSERT/DELETE/UPDATE has lower priority than selects\",\n    SESSION_VAR(low_priority_updates), CMD_LINE(OPT_ARG), DEFAULT(false),\n    NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(nullptr),\n    ON_UPDATE(fix_low_prio_updates));\n\nstatic Sys_var_bool Sys_lower_case_file_system(\n    \"lower_case_file_system\",\n    \"Case sensitivity of file names on the file system where the \"\n    \"data directory is located\",\n    READ_ONLY NON_PERSIST GLOBAL_VAR(lower_case_file_system), NO_CMD_LINE,\n    DEFAULT(false));\n\nstatic Sys_var_uint Sys_lower_case_table_names(\n    \"lower_case_table_names\",\n    \"If set to 1 table names are stored in lowercase on disk and table \"\n    \"names will be case-insensitive.  Should be set to 2 if you are using \"\n    \"a case insensitive file system\",\n    READ_ONLY GLOBAL_VAR(lower_case_table_names),\n    CMD_LINE(OPT_ARG, OPT_LOWER_CASE_TABLE_NAMES), VALID_RANGE(0, 2),\n#ifdef FN_NO_CASE_SENSE\n    DEFAULT(1),\n#else\n    DEFAULT(0),\n#endif\n    BLOCK_SIZE(1));\n\nstatic bool session_readonly(sys_var *self, THD *, set_var *var) {\n  if (var->is_global_persist()) return false;\n  my_error(ER_VARIABLE_IS_READONLY, MYF(0), \"SESSION\", self->name.str,\n           \"GLOBAL\");\n  return true;\n}\n\nstatic bool check_max_allowed_packet(sys_var *self, THD *thd, set_var *var) {\n  longlong val;\n  if (session_readonly(self, thd, var)) return true;\n\n  val = var->save_result.ulonglong_value;\n  if (val < (longlong)global_system_variables.net_buffer_length) {\n    push_warning_printf(thd, Sql_condition::SL_WARNING, WARN_OPTION_BELOW_LIMIT,\n                        ER_THD(thd, WARN_OPTION_BELOW_LIMIT),\n                        \"max_allowed_packet\", \"net_buffer_length\");\n  }\n  return false;\n}\n\nstatic Sys_var_ulong Sys_max_allowed_packet(\n    \"max_allowed_packet\",\n    \"Max packet length to send to or receive from the server\",\n    SESSION_VAR(max_allowed_packet), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(1024, 1024 * 1024 * 1024), DEFAULT(64 * 1024 * 1024),\n    BLOCK_SIZE(1024), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n    ON_CHECK(check_max_allowed_packet));\n\nstatic Sys_var_ulong Sys_slave_max_allowed_packet(\n    \"slave_max_allowed_packet\",\n    \"The maximum packet length to sent successfully from the master to \"\n    \"slave.\",\n    GLOBAL_VAR(slave_max_allowed_packet), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(1024, MAX_MAX_ALLOWED_PACKET), DEFAULT(MAX_MAX_ALLOWED_PACKET),\n    BLOCK_SIZE(1024));\n\nstatic Sys_var_ulonglong Sys_max_binlog_cache_size(\n    \"max_binlog_cache_size\", \"Sets the total size of the transactional cache\",\n    GLOBAL_VAR(max_binlog_cache_size), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(IO_SIZE, ULLONG_MAX), DEFAULT((ULLONG_MAX / IO_SIZE) * IO_SIZE),\n    BLOCK_SIZE(IO_SIZE), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(nullptr),\n    ON_UPDATE(fix_binlog_cache_size));\n\nstatic Sys_var_ulonglong Sys_max_binlog_stmt_cache_size(\n    \"max_binlog_stmt_cache_size\", \"Sets the total size of the statement cache\",\n    GLOBAL_VAR(max_binlog_stmt_cache_size), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(IO_SIZE, ULLONG_MAX), DEFAULT((ULLONG_MAX / IO_SIZE) * IO_SIZE),\n    BLOCK_SIZE(IO_SIZE), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(nullptr),\n    ON_UPDATE(fix_binlog_stmt_cache_size));\n\nstatic bool fix_max_binlog_size(sys_var *, THD *, enum_var_type) {\n  mysql_bin_log.set_max_size(max_binlog_size);\n  /*\n    For multisource replication, this max size is set to all relay logs\n    per channel. So, run through them\n  */\n  if (!max_relay_log_size) {\n    Master_info *mi = nullptr;\n\n    channel_map.wrlock();\n    for (mi_map::iterator it = channel_map.begin(); it != channel_map.end();\n         it++) {\n      mi = it->second;\n      if (mi != nullptr) mi->rli->relay_log.set_max_size(max_binlog_size);\n    }\n    channel_map.unlock();\n  }\n  return false;\n}\nstatic Sys_var_ulong Sys_max_binlog_size(\n    \"max_binlog_size\",\n    \"Binary log will be rotated automatically when the size exceeds this \"\n    \"value. Will also apply to relay logs if max_relay_log_size is 0\",\n    GLOBAL_VAR(max_binlog_size), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(IO_SIZE, 1024 * 1024L * 1024L), DEFAULT(1024 * 1024L * 1024L),\n    BLOCK_SIZE(IO_SIZE), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(nullptr),\n    ON_UPDATE(fix_max_binlog_size));\n\nstatic Sys_var_ulong Sys_max_connections(\n    \"max_connections\", \"The number of simultaneous clients allowed\",\n    GLOBAL_VAR(max_connections), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(1, MAX_CONNECTIONS), DEFAULT(MAX_CONNECTIONS_DEFAULT),\n    BLOCK_SIZE(1), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(nullptr),\n    ON_UPDATE(nullptr), nullptr,\n    /* max_connections is used as a sizing hint by the performance schema. */\n    sys_var::PARSE_EARLY);\n\nstatic Sys_var_ulong Sys_max_connect_errors(\n    \"max_connect_errors\",\n    \"If there is more than this number of interrupted connections from \"\n    \"a host this host will be blocked from further connections\",\n    GLOBAL_VAR(max_connect_errors), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(1, ULONG_MAX), DEFAULT(100), BLOCK_SIZE(1));\n\nstatic Sys_var_long Sys_max_digest_length(\n    \"max_digest_length\", \"Maximum length considered for digest text.\",\n    READ_ONLY GLOBAL_VAR(max_digest_length), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(0, 1024 * 1024), DEFAULT(1024), BLOCK_SIZE(1));\n\nstatic bool check_max_delayed_threads(sys_var *, THD *, set_var *var) {\n  return (!var->is_global_persist()) && var->save_result.ulonglong_value != 0 &&\n         var->save_result.ulonglong_value !=\n             global_system_variables.max_insert_delayed_threads;\n}\n\n// Alias for max_delayed_threads\nstatic Sys_var_ulong Sys_max_insert_delayed_threads(\n    \"max_insert_delayed_threads\",\n    \"Don't start more than this number of threads to handle INSERT \"\n    \"DELAYED statements. If set to zero INSERT DELAYED will be not used. \"\n    \"This variable is deprecated along with INSERT DELAYED.\",\n    SESSION_VAR(max_insert_delayed_threads), NO_CMD_LINE, VALID_RANGE(0, 16384),\n    DEFAULT(20), BLOCK_SIZE(1), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n    ON_CHECK(check_max_delayed_threads), ON_UPDATE(nullptr),\n    DEPRECATED_VAR(\"\"));\n\nstatic Sys_var_ulong Sys_max_delayed_threads(\n    \"max_delayed_threads\",\n    \"Don't start more than this number of threads to handle INSERT \"\n    \"DELAYED statements. If set to zero INSERT DELAYED will be not used. \"\n    \"This variable is deprecated along with INSERT DELAYED.\",\n    SESSION_VAR(max_insert_delayed_threads), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(0, 16384), DEFAULT(20), BLOCK_SIZE(1), NO_MUTEX_GUARD,\n    NOT_IN_BINLOG, ON_CHECK(check_max_delayed_threads), ON_UPDATE(nullptr),\n    DEPRECATED_VAR(\"\"));\n\nstatic Sys_var_ulong Sys_max_error_count(\n    \"max_error_count\", \"Max number of errors/warnings to store for a statement\",\n    HINT_UPDATEABLE SESSION_VAR(max_error_count), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(0, 65535), DEFAULT(DEFAULT_ERROR_COUNT), BLOCK_SIZE(1));\n\nstatic Sys_var_ulonglong Sys_max_heap_table_size(\n    \"max_heap_table_size\",\n    \"Don't allow creation of heap tables bigger than this\",\n    HINT_UPDATEABLE SESSION_VAR(max_heap_table_size), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(16384, (ulonglong) ~(intptr)0), DEFAULT(16 * 1024 * 1024),\n    BLOCK_SIZE(1024));\n\n// relies on DBUG_ASSERT(sizeof(my_thread_id) == 4);\nstatic Sys_var_uint Sys_pseudo_thread_id(\n    \"pseudo_thread_id\", \"This variable is for internal server use\",\n    SESSION_ONLY(pseudo_thread_id), NO_CMD_LINE, VALID_RANGE(0, UINT_MAX32),\n    DEFAULT(0), BLOCK_SIZE(1), NO_MUTEX_GUARD, IN_BINLOG,\n    ON_CHECK(check_session_admin));\n\nstatic bool fix_max_join_size(sys_var *self, THD *thd, enum_var_type type) {\n  System_variables *sv = (self->is_global_persist(type))\n                             ? &global_system_variables\n                             : &thd->variables;\n  if (sv->max_join_size == HA_POS_ERROR)\n    sv->option_bits |= OPTION_BIG_SELECTS;\n  else\n    sv->option_bits &= ~OPTION_BIG_SELECTS;\n  return false;\n}\nstatic Sys_var_harows Sys_max_join_size(\n    \"max_join_size\",\n    \"Joins that are probably going to read more than max_join_size \"\n    \"records return an error\",\n    HINT_UPDATEABLE SESSION_VAR(max_join_size), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(1, HA_POS_ERROR), DEFAULT(HA_POS_ERROR), BLOCK_SIZE(1),\n    NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(nullptr),\n    ON_UPDATE(fix_max_join_size));\n\nstatic Sys_var_ulong Sys_max_seeks_for_key(\n    \"max_seeks_for_key\",\n    \"Limit assumed max number of seeks when looking up rows based on a key\",\n    HINT_UPDATEABLE SESSION_VAR(max_seeks_for_key), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(1, ULONG_MAX), DEFAULT(ULONG_MAX), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_max_length_for_sort_data(\n    \"max_length_for_sort_data\",\n    \"This variable is deprecated and will be removed in a future release.\",\n    HINT_UPDATEABLE SESSION_VAR(max_length_for_sort_data),\n    CMD_LINE(REQUIRED_ARG), VALID_RANGE(4, 8192 * 1024L), DEFAULT(4096),\n    BLOCK_SIZE(1), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(nullptr),\n    ON_UPDATE(nullptr), DEPRECATED_VAR(\"\"));\n\nstatic Sys_var_ulong Sys_max_points_in_geometry(\n    \"max_points_in_geometry\", \"Maximum number of points in a geometry\",\n    HINT_UPDATEABLE SESSION_VAR(max_points_in_geometry), CMD_LINE(OPT_ARG),\n    VALID_RANGE(3, 1024 * 1024L), DEFAULT(64 * 1024), BLOCK_SIZE(1));\n\nstatic PolyLock_mutex PLock_prepared_stmt_count(&LOCK_prepared_stmt_count);\n\nstatic Sys_var_ulong Sys_max_prepared_stmt_count(\n    \"max_prepared_stmt_count\",\n    \"Maximum number of prepared statements in the server\",\n    GLOBAL_VAR(max_prepared_stmt_count), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(0, num_prepared_stmt_limit), DEFAULT(16382), BLOCK_SIZE(1),\n    &PLock_prepared_stmt_count, NOT_IN_BINLOG, ON_CHECK(nullptr),\n    ON_UPDATE(nullptr), nullptr,\n    /* max_prepared_stmt_count is used as a sizing hint by the performance\n       schema. */\n    sys_var::PARSE_EARLY);\n\nstatic bool fix_max_relay_log_size(sys_var *, THD *, enum_var_type) {\n  Master_info *mi = nullptr;\n\n  channel_map.wrlock();\n  for (mi_map::iterator it = channel_map.begin(); it != channel_map.end();\n       it++) {\n    mi = it->second;\n\n    if (mi != nullptr)\n      mi->rli->relay_log.set_max_size(max_relay_log_size ? max_relay_log_size\n                                                         : max_binlog_size);\n  }\n  channel_map.unlock();\n  return false;\n}\nstatic Sys_var_ulong Sys_max_relay_log_size(\n    \"max_relay_log_size\",\n    \"If non-zero: relay log will be rotated automatically when the \"\n    \"size exceeds this value; if zero: when the size \"\n    \"exceeds max_binlog_size\",\n    GLOBAL_VAR(max_relay_log_size), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(0, 1024L * 1024 * 1024), DEFAULT(0), BLOCK_SIZE(IO_SIZE),\n    NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(nullptr),\n    ON_UPDATE(fix_max_relay_log_size));\n\nstatic Sys_var_ulong Sys_max_sort_length(\n    \"max_sort_length\",\n    \"The number of bytes to use when sorting long values with PAD SPACE \"\n    \"collations (only the first max_sort_length bytes of each value are \"\n    \"used; the rest are ignored)\",\n    HINT_UPDATEABLE SESSION_VAR(max_sort_length), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(4, 8192 * 1024L), DEFAULT(1024), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_max_sp_recursion_depth(\n    \"max_sp_recursion_depth\", \"Maximum stored procedure recursion depth\",\n    SESSION_VAR(max_sp_recursion_depth), CMD_LINE(OPT_ARG), VALID_RANGE(0, 255),\n    DEFAULT(0), BLOCK_SIZE(1));\n\n// non-standard session_value_ptr() here\nstatic Sys_var_max_user_conn Sys_max_user_connections(\n    \"max_user_connections\",\n    \"The maximum number of active connections for a single user \"\n    \"(0 = no limit)\",\n    SESSION_VAR(max_user_connections), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(0, UINT_MAX), DEFAULT(0), BLOCK_SIZE(1), NO_MUTEX_GUARD,\n    NOT_IN_BINLOG, ON_CHECK(session_readonly));\n\nstatic Sys_var_ulong Sys_max_write_lock_count(\n    \"max_write_lock_count\",\n    \"After this many write locks, allow some read locks to run in between\",\n    GLOBAL_VAR(max_write_lock_count), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(1, ULONG_MAX), DEFAULT(ULONG_MAX), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_min_examined_row_limit(\n    \"min_examined_row_limit\",\n    \"Don't write queries to slow log that examine fewer rows \"\n    \"than that\",\n    SESSION_VAR(min_examined_row_limit), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(0, ULONG_MAX), DEFAULT(0), BLOCK_SIZE(1));\n\n#ifdef _WIN32\nstatic Sys_var_bool Sys_named_pipe(\"named_pipe\", \"Enable the named pipe (NT)\",\n                                   READ_ONLY NON_PERSIST\n                                       GLOBAL_VAR(opt_enable_named_pipe),\n                                   CMD_LINE(OPT_ARG), DEFAULT(false));\n\nstatic PolyLock_rwlock PLock_named_pipe_full_access_group(\n    &LOCK_named_pipe_full_access_group);\nstatic bool check_named_pipe_full_access_group(sys_var *self, THD *thd,\n                                               set_var *var) {\n  if (!var->value) return false;  // DEFAULT is ok\n\n  if (!is_valid_named_pipe_full_access_group(\n          var->save_result.string_value.str)) {\n    my_error(ER_WRONG_VALUE_FOR_VAR, MYF(0), self->name.str,\n             var->save_result.string_value.str);\n    return true;\n  }\n  return false;\n}\nstatic bool fix_named_pipe_full_access_group(sys_var *, THD *, enum_var_type) {\n  return update_named_pipe_full_access_group(named_pipe_full_access_group);\n}\nstatic Sys_var_charptr Sys_named_pipe_full_access_group(\n    \"named_pipe_full_access_group\",\n    \"Name of Windows group granted full access to the named pipe\",\n    GLOBAL_VAR(named_pipe_full_access_group),\n    CMD_LINE(REQUIRED_ARG, OPT_NAMED_PIPE_FULL_ACCESS_GROUP), IN_FS_CHARSET,\n    DEFAULT(DEFAULT_NAMED_PIPE_FULL_ACCESS_GROUP),\n    &PLock_named_pipe_full_access_group, NOT_IN_BINLOG,\n    ON_CHECK(check_named_pipe_full_access_group),\n    ON_UPDATE(fix_named_pipe_full_access_group));\n#endif\n\nstatic bool check_net_buffer_length(sys_var *self, THD *thd, set_var *var) {\n  longlong val;\n  if (session_readonly(self, thd, var)) return true;\n\n  val = var->save_result.ulonglong_value;\n  if (val > (longlong)global_system_variables.max_allowed_packet) {\n    push_warning_printf(thd, Sql_condition::SL_WARNING, WARN_OPTION_BELOW_LIMIT,\n                        ER_THD(thd, WARN_OPTION_BELOW_LIMIT),\n                        \"max_allowed_packet\", \"net_buffer_length\");\n  }\n  return false;\n}\nstatic Sys_var_ulong Sys_net_buffer_length(\n    \"net_buffer_length\", \"Buffer length for TCP/IP and socket communication\",\n    SESSION_VAR(net_buffer_length), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(1024, 1024 * 1024), DEFAULT(16384), BLOCK_SIZE(1024),\n    NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(check_net_buffer_length));\n\nstatic bool fix_net_read_timeout(sys_var *self, THD *thd, enum_var_type type) {\n  if (!self->is_global_persist(type)) {\n    // net_buffer_length is a specific property for the classic protocols\n    if (!thd->is_classic_protocol()) {\n      my_error(ER_PLUGGABLE_PROTOCOL_COMMAND_NOT_SUPPORTED, MYF(0));\n      return true;\n    }\n    my_net_set_read_timeout(thd->get_protocol_classic()->get_net(),\n                            thd->variables.net_read_timeout);\n  }\n  return false;\n}\nstatic Sys_var_ulong Sys_net_read_timeout(\n    \"net_read_timeout\",\n    \"Number of seconds to wait for more data from a connection before \"\n    \"aborting the read\",\n    SESSION_VAR(net_read_timeout), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(1, LONG_TIMEOUT), DEFAULT(NET_READ_TIMEOUT), BLOCK_SIZE(1),\n    NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(nullptr),\n    ON_UPDATE(fix_net_read_timeout));\n\nstatic bool fix_net_write_timeout(sys_var *self, THD *thd, enum_var_type type) {\n  if (!self->is_global_persist(type)) {\n    // net_read_timeout is a specific property for the classic protocols\n    if (!thd->is_classic_protocol()) {\n      my_error(ER_PLUGGABLE_PROTOCOL_COMMAND_NOT_SUPPORTED, MYF(0));\n      return true;\n    }\n    my_net_set_write_timeout(thd->get_protocol_classic()->get_net(),\n                             thd->variables.net_write_timeout);\n  }\n  return false;\n}\nstatic Sys_var_ulong Sys_net_write_timeout(\n    \"net_write_timeout\",\n    \"Number of seconds to wait for a block to be written to a connection \"\n    \"before aborting the write\",\n    SESSION_VAR(net_write_timeout), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(1, LONG_TIMEOUT), DEFAULT(NET_WRITE_TIMEOUT), BLOCK_SIZE(1),\n    NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(nullptr),\n    ON_UPDATE(fix_net_write_timeout));\n\nstatic Sys_var_ulong Sys_kill_idle_transaction(\n    \"kill_idle_transaction\",\n    \"If non-zero, number of seconds to wait before killing idle \"\n    \"connections that have open transactions\",\n    GLOBAL_VAR(kill_idle_transaction_timeout), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(0, LONG_TIMEOUT), DEFAULT(0), BLOCK_SIZE(1), NO_MUTEX_GUARD,\n    NOT_IN_BINLOG, ON_CHECK(nullptr), ON_UPDATE(nullptr));\n\nstatic bool fix_net_retry_count(sys_var *self, THD *thd, enum_var_type type) {\n  if (!self->is_global_persist(type)) {\n    // net_write_timeout is a specific property for the classic protocols\n    if (!thd->is_classic_protocol()) {\n      my_error(ER_PLUGGABLE_PROTOCOL_COMMAND_NOT_SUPPORTED, MYF(0));\n      return true;\n    }\n    thd->get_protocol_classic()->get_net()->retry_count =\n        thd->variables.net_retry_count;\n  }\n  return false;\n}\nstatic Sys_var_ulong Sys_net_retry_count(\n    \"net_retry_count\",\n    \"If a read on a communication port is interrupted, retry this \"\n    \"many times before giving up\",\n    SESSION_VAR(net_retry_count), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(1, ULONG_MAX), DEFAULT(MYSQLD_NET_RETRY_COUNT), BLOCK_SIZE(1),\n    NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(nullptr),\n    ON_UPDATE(fix_net_retry_count));\n\nstatic Sys_var_bool Sys_new_mode(\"new\",\n                                 \"Use very new possible \\\"unsafe\\\" functions\",\n                                 SESSION_VAR(new_mode), CMD_LINE(OPT_ARG, 'n'),\n                                 DEFAULT(false));\n\nstatic Sys_var_bool Sys_old_mode(\"old\", \"Use compatible behavior\",\n                                 READ_ONLY GLOBAL_VAR(old_mode),\n                                 CMD_LINE(OPT_ARG), DEFAULT(false));\n\nstatic Sys_var_bool Sys_old_alter_table(\"old_alter_table\",\n                                        \"Use old, non-optimized alter table\",\n                                        SESSION_VAR(old_alter_table),\n                                        CMD_LINE(OPT_ARG), DEFAULT(false));\n\nstatic Sys_var_ulong Sys_open_files_limit(\n    \"open_files_limit\",\n    \"If this is not 0, then mysqld will use this value to reserve file \"\n    \"descriptors to use with setrlimit(). If this value is 0 then mysqld \"\n    \"will reserve max_connections*5 or max_connections + table_open_cache*2 \"\n    \"(whichever is larger) number of file descriptors\",\n    READ_ONLY GLOBAL_VAR(open_files_limit), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(0, OS_FILE_LIMIT), DEFAULT(0), BLOCK_SIZE(1), NO_MUTEX_GUARD,\n    NOT_IN_BINLOG, ON_CHECK(nullptr), ON_UPDATE(nullptr), nullptr,\n    /* open_files_limit is used as a sizing hint by the performance schema. */\n    sys_var::PARSE_EARLY);\n\n/// @todo change to enum\nstatic Sys_var_ulong Sys_optimizer_prune_level(\n    \"optimizer_prune_level\",\n    \"Controls the heuristic(s) applied during query optimization to prune \"\n    \"less-promising partial plans from the optimizer search space. \"\n    \"Meaning: 0 - do not apply any heuristic, thus perform exhaustive \"\n    \"search; 1 - prune plans based on number of retrieved rows\",\n    HINT_UPDATEABLE SESSION_VAR(optimizer_prune_level), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(0, 1), DEFAULT(1), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_optimizer_search_depth(\n    \"optimizer_search_depth\",\n    \"Maximum depth of search performed by the query optimizer. Values \"\n    \"larger than the number of relations in a query result in better \"\n    \"query plans, but take longer to compile a query. Values smaller \"\n    \"than the number of tables in a relation result in faster \"\n    \"optimization, but may produce very bad query plans. If set to 0, \"\n    \"the system will automatically pick a reasonable value\",\n    HINT_UPDATEABLE SESSION_VAR(optimizer_search_depth), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(0, MAX_TABLES + 1), DEFAULT(MAX_TABLES + 1), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_range_optimizer_max_mem_size(\n    \"range_optimizer_max_mem_size\",\n    \"Maximum amount of memory used by the range optimizer \"\n    \"to allocate predicates during range analysis. \"\n    \"The larger the number, more memory may be consumed during \"\n    \"range analysis. If the value is too low to completed range \"\n    \"optimization of a query, index range scan will not be \"\n    \"considered for this query. A value of 0 means range optimizer \"\n    \"does not have any cap on memory. \",\n    HINT_UPDATEABLE SESSION_VAR(range_optimizer_max_mem_size),\n    CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, ULONG_MAX), DEFAULT(8388608),\n    BLOCK_SIZE(1));\n\nstatic bool limit_parser_max_mem_size(sys_var *, THD *thd, set_var *var) {\n  if (var->is_global_persist()) return false;\n  ulonglong val = var->save_result.ulonglong_value;\n  if (val > global_system_variables.parser_max_mem_size) {\n    if (thd->security_context()->check_access(SUPER_ACL)) return false;\n    var->save_result.ulonglong_value =\n        global_system_variables.parser_max_mem_size;\n    return throw_bounds_warning(thd, \"parser_max_mem_size\",\n                                true,  // fixed\n                                true,  // is_unsigned\n                                val);\n  }\n  return false;\n}\n\nconstexpr size_t max_mem_sz = std::numeric_limits<size_t>::max();\n\nstatic Sys_var_ulonglong Sys_histogram_generation_max_mem_size(\n    \"histogram_generation_max_mem_size\",\n    \"Maximum amount of memory available for generating histograms\",\n    HINT_UPDATEABLE SESSION_VAR(histogram_generation_max_mem_size),\n    CMD_LINE(REQUIRED_ARG), VALID_RANGE(1000000, max_mem_sz), DEFAULT(20000000),\n    BLOCK_SIZE(1), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(check_session_admin),\n    ON_UPDATE(nullptr));\n\n/*\n  Need at least 400Kb to get through bootstrap.\n  Need at least 8Mb to get through mtr check testcase, which does\n    SELECT * FROM INFORMATION_SCHEMA.VIEWS\n*/\nstatic Sys_var_ulonglong Sys_parser_max_mem_size(\n    \"parser_max_mem_size\", \"Maximum amount of memory available to the parser\",\n    SESSION_VAR(parser_max_mem_size), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(10 * 1000 * 1000, max_mem_sz), DEFAULT(max_mem_sz),\n    BLOCK_SIZE(1), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n    ON_CHECK(limit_parser_max_mem_size), ON_UPDATE(nullptr));\n\n/*\n  There is no call on Sys_var_integer::do_check() for 'set xxx=default';\n  The predefined default for parser_max_mem_size is \"infinite\".\n  Update it in case we have seen option maximum-parser-max-mem-size\n  Also update global_system_variables, so 'SELECT parser_max_mem_size'\n  reports correct data.\n*/\nexport void update_parser_max_mem_size() {\n  const ulonglong max_max = max_system_variables.parser_max_mem_size;\n  if (max_max == max_mem_sz) return;\n  // In case parser-max-mem-size is also set:\n  const ulonglong new_val =\n      std::min(max_max, global_system_variables.parser_max_mem_size);\n  Sys_parser_max_mem_size.update_default(new_val);\n  global_system_variables.parser_max_mem_size = new_val;\n}\n\n/**\n  @note\n  @b BEWARE! These must have the same order as the \\#defines in sql_const.h!\n*/\nstatic const char *optimizer_switch_names[] = {\n    \"index_merge\",\n    \"index_merge_union\",\n    \"index_merge_sort_union\",\n    \"index_merge_intersection\",\n    \"engine_condition_pushdown\",\n    \"index_condition_pushdown\",\n    \"mrr\",\n    \"mrr_cost_based\",\n    \"block_nested_loop\",\n    \"batched_key_access\",\n    \"materialization\",\n    \"semijoin\",\n    \"loosescan\",\n    \"firstmatch\",\n    \"duplicateweedout\",\n    \"subquery_materialization_cost_based\",\n    \"use_index_extensions\",\n    \"condition_fanout_filter\",\n    \"derived_merge\",\n    \"use_invisible_indexes\",\n    \"skip_scan\",\n    \"hash_join\",\n    \"default\",\n    NullS};\nstatic Sys_var_flagset Sys_optimizer_switch(\n    \"optimizer_switch\",\n    \"optimizer_switch=option=val[,option=val...], where option is one of \"\n    \"{index_merge, index_merge_union, index_merge_sort_union, \"\n    \"index_merge_intersection, engine_condition_pushdown, \"\n    \"index_condition_pushdown, mrr, mrr_cost_based\"\n    \", materialization, semijoin, loosescan, firstmatch, duplicateweedout,\"\n    \" subquery_materialization_cost_based, skip_scan\"\n    \", block_nested_loop, batched_key_access, use_index_extensions,\"\n    \" condition_fanout_filter, derived_merge, hash_join} and val is one of \"\n    \"{on, off, default}\",\n    HINT_UPDATEABLE SESSION_VAR(optimizer_switch), CMD_LINE(REQUIRED_ARG),\n    optimizer_switch_names, DEFAULT(OPTIMIZER_SWITCH_DEFAULT), NO_MUTEX_GUARD,\n    NOT_IN_BINLOG, ON_CHECK(nullptr), ON_UPDATE(nullptr));\n\nstatic Sys_var_bool Sys_var_end_markers_in_json(\n    \"end_markers_in_json\",\n    \"In JSON output (\\\"EXPLAIN FORMAT=JSON\\\" and optimizer trace), \"\n    \"if variable is set to 1, repeats the structure's key (if it has one) \"\n    \"near the closing bracket\",\n    HINT_UPDATEABLE SESSION_VAR(end_markers_in_json), CMD_LINE(OPT_ARG),\n    DEFAULT(false));\n\nstatic Sys_var_flagset Sys_optimizer_trace(\n    \"optimizer_trace\",\n    \"Controls tracing of the Optimizer:\"\n    \" optimizer_trace=option=val[,option=val...], where option is one of\"\n    \" {enabled, one_line}\"\n    \" and val is one of {on, default}\",\n    SESSION_VAR(optimizer_trace), CMD_LINE(REQUIRED_ARG),\n    Opt_trace_context::flag_names, DEFAULT(Opt_trace_context::FLAG_DEFAULT));\n// @see set_var::is_var_optimizer_trace()\nexport sys_var *Sys_optimizer_trace_ptr = &Sys_optimizer_trace;\n\n/**\n  Note how \"misc\" is not here: it is not accessible to the user; disabling\n  \"misc\" would disable the top object, which would make an empty trace.\n*/\nstatic Sys_var_flagset Sys_optimizer_trace_features(\n    \"optimizer_trace_features\",\n    \"Enables/disables tracing of selected features of the Optimizer:\"\n    \" optimizer_trace_features=option=val[,option=val...], where option is \"\n    \"one \"\n    \"of\"\n    \" {greedy_search, range_optimizer, dynamic_range, repeated_subselect}\"\n    \" and val is one of {on, off, default}\",\n    SESSION_VAR(optimizer_trace_features), CMD_LINE(REQUIRED_ARG),\n    Opt_trace_context::feature_names,\n    DEFAULT(Opt_trace_context::default_features));\n\n/** Delete all old optimizer traces */\nstatic bool optimizer_trace_update(sys_var *, THD *thd, enum_var_type) {\n  thd->opt_trace.reset();\n  return false;\n}\n\nstatic Sys_var_long Sys_optimizer_trace_offset(\n    \"optimizer_trace_offset\",\n    \"Offset of first optimizer trace to show; see manual\",\n    SESSION_VAR(optimizer_trace_offset), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(LONG_MIN, LONG_MAX), DEFAULT(-1), BLOCK_SIZE(1), NO_MUTEX_GUARD,\n    NOT_IN_BINLOG, ON_CHECK(nullptr), ON_UPDATE(optimizer_trace_update));\n\nstatic Sys_var_long Sys_optimizer_trace_limit(\n    \"optimizer_trace_limit\", \"Maximum number of shown optimizer traces\",\n    SESSION_VAR(optimizer_trace_limit), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(0, LONG_MAX), DEFAULT(1), BLOCK_SIZE(1), NO_MUTEX_GUARD,\n    NOT_IN_BINLOG, ON_CHECK(nullptr), ON_UPDATE(optimizer_trace_update));\n\nstatic Sys_var_ulong Sys_optimizer_trace_max_mem_size(\n    \"optimizer_trace_max_mem_size\",\n    \"Maximum allowed cumulated size of stored optimizer traces\",\n    SESSION_VAR(optimizer_trace_max_mem_size), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(0, ULONG_MAX), DEFAULT(1024 * 1024), BLOCK_SIZE(1));\n\nstatic Sys_var_charptr Sys_pid_file(\n    \"pid_file\", \"Pid file used by safe_mysqld\",\n    READ_ONLY NON_PERSIST GLOBAL_VAR(pidfile_name_ptr), CMD_LINE(REQUIRED_ARG),\n    IN_FS_CHARSET, DEFAULT(pidfile_name));\n\nstatic Sys_var_charptr Sys_plugin_dir(\n    \"plugin_dir\", \"Directory for plugins\",\n    READ_ONLY NON_PERSIST GLOBAL_VAR(opt_plugin_dir_ptr),\n    CMD_LINE(REQUIRED_ARG), IN_FS_CHARSET, DEFAULT(nullptr));\n\nstatic Sys_var_uint Sys_port(\n    \"port\",\n    \"Port number to use for connection or 0 to default to, \"\n    \"my.cnf, $MYSQL_TCP_PORT, \"\n#if MYSQL_PORT_DEFAULT == 0\n    \"/etc/services, \"\n#endif\n    \"built-in default (\" STRINGIFY_ARG(MYSQL_PORT) \"), whatever comes first\",\n    READ_ONLY NON_PERSIST GLOBAL_VAR(mysqld_port), CMD_LINE(REQUIRED_ARG, 'P'),\n    VALID_RANGE(0, 65535), DEFAULT(0), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_preload_buff_size(\n    \"preload_buffer_size\",\n    \"The size of the buffer that is allocated when preloading indexes\",\n    HINT_UPDATEABLE SESSION_VAR(preload_buff_size), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(1024, 1024 * 1024 * 1024), DEFAULT(32768), BLOCK_SIZE(1));\n\nstatic Sys_var_uint Sys_protocol_version(\n    \"protocol_version\",\n    \"The version of the client/server protocol used by the MySQL server\",\n    READ_ONLY NON_PERSIST GLOBAL_VAR(protocol_version), NO_CMD_LINE,\n    VALID_RANGE(0, ~0), DEFAULT(PROTOCOL_VERSION), BLOCK_SIZE(1));\n\nstatic Sys_var_proxy_user Sys_proxy_user(\n    \"proxy_user\", \"The proxy user account name used when logging in\",\n    IN_SYSTEM_CHARSET);\n\nstatic Sys_var_external_user Sys_external_user(\n    \"external_user\", \"The external user account used when logging in\",\n    IN_SYSTEM_CHARSET);\n\nstatic Sys_var_ulong Sys_read_buff_size(\n    \"read_buffer_size\",\n    \"Each thread that does a sequential scan allocates a buffer of \"\n    \"this size for each table it scans. If you do many sequential scans, \"\n    \"you may want to increase this value\",\n    HINT_UPDATEABLE SESSION_VAR(read_buff_size), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(IO_SIZE * 2, INT_MAX32), DEFAULT(128 * 1024),\n    BLOCK_SIZE(IO_SIZE));\n\nstatic bool check_read_only(sys_var *, THD *thd, set_var *) {\n  /* Prevent self dead-lock */\n  if (thd->locked_tables_mode || thd->in_active_multi_stmt_transaction()) {\n    my_error(ER_LOCK_OR_ACTIVE_TRANSACTION, MYF(0));\n    return true;\n  }\n  return false;\n}\n\nstatic bool check_require_secure_transport(\n    sys_var *, THD *, set_var *var MY_ATTRIBUTE((unused))) {\n#if !defined(_WIN32)\n  /*\n    always allow require_secure_transport to be enabled on\n    Linux, as socket is secure.\n  */\n  return false;\n#else\n  /*\n    check whether SSL or shared memory transports are enabled before\n    turning require_secure_transport ON, otherwise no connections will\n    be allowed on Windows.\n  */\n\n  if (!var->save_result.ulonglong_value) return false;\n  if (SslAcceptorContext::have_ssl() || opt_enable_shared_memory) return false;\n  /* reject if SSL and shared memory are both disabled: */\n  my_error(ER_NO_SECURE_TRANSPORTS_CONFIGURED, MYF(0));\n  return true;\n\n#endif\n}\n\nstatic bool fix_read_only(sys_var *self, THD *thd, enum_var_type) {\n  bool result = true;\n  bool new_read_only = read_only;  // make a copy before releasing a mutex\n  DBUG_TRACE;\n\n  if (read_only == false || read_only == opt_readonly) {\n    if (opt_super_readonly && !read_only) {\n      opt_super_readonly = false;\n      super_read_only = false;\n    }\n    opt_readonly = read_only;\n    return false;\n  }\n\n  if (check_read_only(self, thd, nullptr))  // just in case\n    goto end;\n\n  if (thd->global_read_lock.is_acquired()) {\n    /*\n      This connection already holds the global read lock.\n      This can be the case with:\n      - FLUSH TABLES WITH READ LOCK\n      - SET GLOBAL READ_ONLY = 1\n    */\n    if (opt_super_readonly && !read_only) {\n      opt_super_readonly = false;\n      super_read_only = false;\n    }\n    opt_readonly = read_only;\n    return false;\n  }\n\n  /*\n    READ_ONLY=1 prevents write locks from being taken on tables and\n    blocks transactions from committing. We therefore should make sure\n    that no such events occur while setting the read_only variable.\n    This is a 2 step process:\n    [1] lock_global_read_lock()\n      Prevents connections from obtaining new write locks on\n      tables. Note that we can still have active rw transactions.\n    [2] make_global_read_lock_block_commit()\n      Prevents transactions from committing.\n  */\n\n  read_only = opt_readonly;\n  mysql_mutex_unlock(&LOCK_global_system_variables);\n\n  if (thd->global_read_lock.lock_global_read_lock(thd))\n    goto end_with_mutex_unlock;\n\n  if ((result = thd->global_read_lock.make_global_read_lock_block_commit(thd)))\n    goto end_with_read_lock;\n\n  /* Change the opt_readonly system variable, safe because the lock is held */\n  opt_readonly = new_read_only;\n\n  result = false;\n\nend_with_read_lock:\n  /* Release the lock */\n  thd->global_read_lock.unlock_global_read_lock(thd);\nend_with_mutex_unlock:\n  mysql_mutex_lock(&LOCK_global_system_variables);\nend:\n  read_only = opt_readonly;\n  return result;\n}\n\nstatic bool fix_super_read_only(sys_var *, THD *thd, enum_var_type type) {\n  DBUG_TRACE;\n\n  /* return if no changes: */\n  if (super_read_only == opt_super_readonly) return false;\n\n  /* return immediately if turning super_read_only OFF: */\n  if (super_read_only == false) {\n    opt_super_readonly = false;\n    return false;\n  }\n  bool result = true;\n  bool new_super_read_only =\n      super_read_only; /* make a copy before releasing a mutex */\n\n  /* set read_only to ON if it is OFF, letting fix_read_only()\n     handle its own locking needs\n  */\n  if (!opt_readonly) {\n    read_only = true;\n    if ((result = fix_read_only(nullptr, thd, type))) goto end;\n  }\n\n  /* if we already have global read lock, set super_read_only\n     and return immediately:\n  */\n  if (thd->global_read_lock.is_acquired()) {\n    opt_super_readonly = super_read_only;\n    return false;\n  }\n\n  /* now we're turning ON super_read_only: */\n  super_read_only = opt_super_readonly;\n  mysql_mutex_unlock(&LOCK_global_system_variables);\n\n  if (thd->global_read_lock.lock_global_read_lock(thd))\n    goto end_with_mutex_unlock;\n\n  if ((result = thd->global_read_lock.make_global_read_lock_block_commit(thd)))\n    goto end_with_read_lock;\n  opt_super_readonly = new_super_read_only;\n  result = false;\n\nend_with_read_lock:\n  /* Release the lock */\n  thd->global_read_lock.unlock_global_read_lock(thd);\nend_with_mutex_unlock:\n  mysql_mutex_lock(&LOCK_global_system_variables);\nend:\n  super_read_only = opt_super_readonly;\n  return result;\n}\n\nstatic Sys_var_bool Sys_require_secure_transport(\n    \"require_secure_transport\",\n    \"When this option is enabled, connections attempted using insecure \"\n    \"transport will be rejected.  Secure transports are SSL/TLS, \"\n    \"Unix socket or Shared Memory (on Windows).\",\n    GLOBAL_VAR(opt_require_secure_transport), CMD_LINE(OPT_ARG), DEFAULT(false),\n    NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(check_require_secure_transport),\n    ON_UPDATE(nullptr));\n\n/**\n  The read_only boolean is always equal to the opt_readonly boolean except\n  during fix_read_only(); when that function is entered, opt_readonly is\n  the pre-update value and read_only is the post-update value.\n  fix_read_only() compares them and runs needed operations for the\n  transition (especially when transitioning from false to true) and\n  synchronizes both booleans in the end.\n*/\nstatic Sys_var_bool Sys_readonly(\n    \"read_only\",\n    \"Make all non-temporary tables read-only, with the exception for \"\n    \"replication (slave) threads and users with the SUPER privilege\",\n    GLOBAL_VAR(read_only), CMD_LINE(OPT_ARG), DEFAULT(false), NO_MUTEX_GUARD,\n    NOT_IN_BINLOG, ON_CHECK(check_read_only), ON_UPDATE(fix_read_only));\n\nstatic Sys_var_bool Sys_userstat(\n    \"userstat\",\n    \"Control USER_STATISTICS, CLIENT_STATISTICS, THREAD_STATISTICS, \"\n    \"INDEX_STATISTICS and TABLE_STATISTICS running\",\n    GLOBAL_VAR(opt_userstat), CMD_LINE(OPT_ARG), DEFAULT(false));\n\nstatic Sys_var_bool Sys_thread_statistics(\n    \"thread_statistics\",\n    \"Control TABLE_STATISTICS running, when userstat is enabled\",\n    GLOBAL_VAR(opt_thread_statistics), CMD_LINE(OPT_ARG), DEFAULT(false));\n\n/**\nSetting super_read_only to ON triggers read_only to also be set to ON.\n*/\nstatic Sys_var_bool Sys_super_readonly(\n    \"super_read_only\",\n    \"Make all non-temporary tables read-only, with the exception for \"\n    \"replication (slave) threads.  Users with the SUPER privilege are \"\n    \"affected, unlike read_only.  Setting super_read_only to ON \"\n    \"also sets read_only to ON.\",\n    GLOBAL_VAR(super_read_only), CMD_LINE(OPT_ARG), DEFAULT(false),\n    NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(nullptr),\n    ON_UPDATE(fix_super_read_only));\n\n// Small lower limit to be able to test MRR\nstatic Sys_var_ulong Sys_read_rnd_buff_size(\n    \"read_rnd_buffer_size\",\n    \"When reading rows in sorted order after a sort, the rows are read \"\n    \"through this buffer to avoid a disk seeks\",\n    HINT_UPDATEABLE SESSION_VAR(read_rnd_buff_size), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(1, INT_MAX32), DEFAULT(256 * 1024), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_div_precincrement(\n    \"div_precision_increment\",\n    \"Precision of the result of '/' \"\n    \"operator will be increased on that value\",\n    HINT_UPDATEABLE SESSION_VAR(div_precincrement), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(0, DECIMAL_MAX_SCALE), DEFAULT(4), BLOCK_SIZE(1));\n\nstatic Sys_var_uint Sys_eq_range_index_dive_limit(\n    \"eq_range_index_dive_limit\",\n    \"The optimizer will use existing index statistics instead of \"\n    \"doing index dives for equality ranges if the number of equality \"\n    \"ranges for the index is larger than or equal to this number. \"\n    \"If set to 0, index dives are always used.\",\n    HINT_UPDATEABLE SESSION_VAR(eq_range_index_dive_limit),\n    CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, UINT_MAX32), DEFAULT(200),\n    BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_range_alloc_block_size(\n    \"range_alloc_block_size\",\n    \"Allocation block size for storing ranges during optimization\",\n    HINT_UPDATEABLE SESSION_VAR(range_alloc_block_size), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(RANGE_ALLOC_BLOCK_SIZE, UINT32_MAX),\n    DEFAULT(RANGE_ALLOC_BLOCK_SIZE), BLOCK_SIZE(1024));\n\nstatic bool fix_thd_mem_root(sys_var *self, THD *thd, enum_var_type type) {\n  if (!self->is_global_persist(type))\n    thd->mem_root->set_block_size(thd->variables.query_alloc_block_size);\n  return false;\n}\nstatic Sys_var_ulong Sys_query_alloc_block_size(\n    \"query_alloc_block_size\",\n    \"Allocation block size for query parsing and execution\",\n    SESSION_VAR(query_alloc_block_size), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(1024, UINT_MAX32), DEFAULT(QUERY_ALLOC_BLOCK_SIZE),\n    BLOCK_SIZE(1024), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(nullptr),\n    ON_UPDATE(fix_thd_mem_root));\n\nstatic Sys_var_ulong Sys_query_prealloc_size(\n    \"query_prealloc_size\", \"Persistent buffer for query parsing and execution\",\n    SESSION_VAR(query_prealloc_size), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(QUERY_ALLOC_PREALLOC_SIZE, ULONG_MAX),\n    DEFAULT(QUERY_ALLOC_PREALLOC_SIZE), BLOCK_SIZE(1024), NO_MUTEX_GUARD,\n    NOT_IN_BINLOG, ON_CHECK(nullptr), ON_UPDATE(fix_thd_mem_root));\n\n#if defined(_WIN32)\nstatic Sys_var_bool Sys_shared_memory(\n    \"shared_memory\", \"Enable the shared memory\",\n    READ_ONLY NON_PERSIST GLOBAL_VAR(opt_enable_shared_memory),\n    CMD_LINE(OPT_ARG), DEFAULT(false));\n\nstatic Sys_var_charptr Sys_shared_memory_base_name(\n    \"shared_memory_base_name\", \"Base name of shared memory\",\n    READ_ONLY NON_PERSIST GLOBAL_VAR(shared_memory_base_name),\n    CMD_LINE(REQUIRED_ARG), IN_FS_CHARSET, DEFAULT(0));\n#endif\n\n// this has to be NO_CMD_LINE as the command-line option has a different name\nstatic Sys_var_bool Sys_skip_external_locking(\n    \"skip_external_locking\", \"Don't use system (external) locking\",\n    READ_ONLY NON_PERSIST GLOBAL_VAR(my_disable_locking), NO_CMD_LINE,\n    DEFAULT(true));\n\nstatic Sys_var_bool Sys_skip_networking(\n    \"skip_networking\", \"Don't allow connection with TCP/IP\",\n    READ_ONLY NON_PERSIST GLOBAL_VAR(opt_disable_networking), CMD_LINE(OPT_ARG),\n    DEFAULT(false));\n\nstatic Sys_var_bool Sys_skip_name_resolve(\n    \"skip_name_resolve\",\n    \"Don't resolve hostnames. All hostnames are IP's or 'localhost'.\",\n    READ_ONLY GLOBAL_VAR(opt_skip_name_resolve),\n    CMD_LINE(OPT_ARG, OPT_SKIP_RESOLVE), DEFAULT(false));\n\nstatic Sys_var_bool Sys_skip_show_database(\n    \"skip_show_database\", \"Don't allow 'SHOW DATABASE' commands\",\n    READ_ONLY GLOBAL_VAR(opt_skip_show_db), CMD_LINE(OPT_ARG), DEFAULT(false));\n\nstatic Sys_var_charptr Sys_socket(\n    \"socket\", \"Socket file to use for connection\",\n    READ_ONLY NON_PERSIST GLOBAL_VAR(mysqld_unix_port), CMD_LINE(REQUIRED_ARG),\n    IN_FS_CHARSET, DEFAULT(nullptr));\n\nstatic Sys_var_ulong Sys_thread_stack(\n    \"thread_stack\", \"The stack size for each thread\",\n    READ_ONLY GLOBAL_VAR(my_thread_stack_size), CMD_LINE(REQUIRED_ARG),\n#if defined(__clang__) && defined(HAVE_UBSAN)\n    // DEFAULT_THREAD_STACK is multiplied by 3 for clang/UBSAN\n    // We need to increase the minimum value as well.\n    VALID_RANGE(DEFAULT_THREAD_STACK / 2, ULONG_MAX),\n#else\n    VALID_RANGE(128 * 1024, ULONG_MAX),\n#endif\n    DEFAULT(DEFAULT_THREAD_STACK), BLOCK_SIZE(1024));\n\nstatic Sys_var_charptr Sys_tmpdir(\n    \"tmpdir\",\n    \"Path for temporary files. Several paths may \"\n    \"be specified, separated by a \"\n#if defined(_WIN32)\n    \"semicolon (;)\"\n#else\n    \"colon (:)\"\n#endif\n    \", in this case they are used in a round-robin fashion\",\n    READ_ONLY NON_PERSIST GLOBAL_VAR(opt_mysql_tmpdir),\n    CMD_LINE(REQUIRED_ARG, 't'), IN_FS_CHARSET, DEFAULT(nullptr));\n\nstatic bool fix_trans_mem_root(sys_var *self, THD *thd, enum_var_type type) {\n  if (!self->is_global_persist(type))\n    thd->get_transaction()->init_mem_root_defaults(\n        thd->variables.trans_alloc_block_size,\n        thd->variables.trans_prealloc_size);\n  return false;\n}\nstatic Sys_var_ulong Sys_trans_alloc_block_size(\n    \"transaction_alloc_block_size\",\n    \"Allocation block size for transactions to be stored in binary log\",\n    SESSION_VAR(trans_alloc_block_size), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(1024, 128 * 1024), DEFAULT(QUERY_ALLOC_BLOCK_SIZE),\n    BLOCK_SIZE(1024), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(nullptr),\n    ON_UPDATE(fix_trans_mem_root));\n\nstatic Sys_var_ulong Sys_trans_prealloc_size(\n    \"transaction_prealloc_size\",\n    \"Persistent buffer for transactions to be stored in binary log\",\n    SESSION_VAR(trans_prealloc_size), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(1024, 128 * 1024), DEFAULT(TRANS_ALLOC_PREALLOC_SIZE),\n    BLOCK_SIZE(1024), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(nullptr),\n    ON_UPDATE(fix_trans_mem_root));\n\nstatic const char *thread_handling_names[] = {\"one-thread-per-connection\",\n                                              \"no-threads\",\n#ifdef HAVE_POOL_OF_THREADS\n                                              \"pool-of-threads\",\n#endif\n                                              nullptr};\n\n#if defined(_WIN32) && defined(HAVE_POOL_OF_THREADS)\n/* Windows is using OS threadpool, so we're pretty sure it works well */\n#define DEFAULT_THREAD_HANDLING 2\n#else\n#define DEFAULT_THREAD_HANDLING 0\n#endif\n\nstatic Sys_var_enum Sys_thread_handling(\n    \"thread_handling\",\n    \"Define threads usage for handling queries, one of \"\n    \"one-thread-per-connection, no-threads, pool-of-threads\",\n    READ_ONLY GLOBAL_VAR(Connection_handler_manager::thread_handling),\n    CMD_LINE(REQUIRED_ARG), thread_handling_names, DEFAULT(0));\n\nstatic Sys_var_charptr Sys_secure_file_priv(\n    \"secure_file_priv\",\n    \"Limit LOAD DATA, SELECT ... OUTFILE, and LOAD_FILE() to files \"\n    \"within specified directory\",\n    READ_ONLY NON_PERSIST GLOBAL_VAR(opt_secure_file_priv),\n    CMD_LINE(REQUIRED_ARG), IN_FS_CHARSET,\n    DEFAULT(DEFAULT_SECURE_FILE_PRIV_DIR));\n\nstatic bool fix_server_id(sys_var *, THD *thd, enum_var_type) {\n  // server_id is 'MYSQL_PLUGIN_IMPORT ulong'\n  // So we cast here, rather than change its type.\n  server_id_supplied = true;\n  thd->server_id = static_cast<uint32>(server_id);\n  return false;\n}\nstatic Sys_var_ulong Sys_server_id(\n    \"server_id\",\n    \"Uniquely identifies the server instance in the community of \"\n    \"replication partners\",\n    GLOBAL_VAR(server_id), CMD_LINE(REQUIRED_ARG, OPT_SERVER_ID),\n    VALID_RANGE(0, UINT_MAX32), DEFAULT(1), BLOCK_SIZE(1), NO_MUTEX_GUARD,\n    NOT_IN_BINLOG, ON_CHECK(nullptr), ON_UPDATE(fix_server_id));\n\nstatic Sys_var_charptr Sys_server_uuid(\n    \"server_uuid\", \"Uniquely identifies the server instance in the universe\",\n    READ_ONLY NON_PERSIST GLOBAL_VAR(server_uuid_ptr), NO_CMD_LINE,\n    IN_FS_CHARSET, DEFAULT(server_uuid));\n\nstatic Sys_var_uint Sys_server_id_bits(\n    \"server_id_bits\", \"Set number of significant bits in server-id\",\n    GLOBAL_VAR(opt_server_id_bits), CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, 32),\n    DEFAULT(32), BLOCK_SIZE(1));\n\nstatic Sys_var_int32 Sys_regexp_time_limit(\n    \"regexp_time_limit\",\n    \"Timeout for regular expressions matches, in steps of the match \"\n    \"engine, typically on the order of milliseconds.\",\n    GLOBAL_VAR(opt_regexp_time_limit), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(0, INT32_MAX), DEFAULT(32), BLOCK_SIZE(1));\n\nstatic Sys_var_int32 Sys_regexp_stack_limit(\n    \"regexp_stack_limit\", \"Stack size limit for regular expressions matches\",\n    GLOBAL_VAR(opt_regexp_stack_limit), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(0, INT32_MAX), DEFAULT(8000000), BLOCK_SIZE(1));\n\nstatic Sys_var_bool Sys_slave_compressed_protocol(\n    \"slave_compressed_protocol\", \"Use compression on master/slave protocol\",\n    GLOBAL_VAR(opt_slave_compressed_protocol), CMD_LINE(OPT_ARG),\n    DEFAULT(false));\n\nstatic const char *slave_exec_mode_names[] = {\"STRICT\", \"IDEMPOTENT\", nullptr};\nstatic Sys_var_enum Slave_exec_mode(\n    \"slave_exec_mode\",\n    \"Modes for how replication events should be executed. Legal values \"\n    \"are STRICT (default) and IDEMPOTENT. In IDEMPOTENT mode, \"\n    \"replication will not stop for operations that are idempotent. \"\n    \"In STRICT mode, replication will stop on any unexpected difference \"\n    \"between the master and the slave\",\n    GLOBAL_VAR(slave_exec_mode_options), CMD_LINE(REQUIRED_ARG),\n    slave_exec_mode_names, DEFAULT(RBR_EXEC_MODE_STRICT));\n\nconst char *slave_type_conversions_name[] = {\n    \"ALL_LOSSY\", \"ALL_NON_LOSSY\", \"ALL_UNSIGNED\", \"ALL_SIGNED\", nullptr};\nstatic Sys_var_set Slave_type_conversions(\n    \"slave_type_conversions\",\n    \"Set of slave type conversions that are enabled. Legal values are:\"\n    \" ALL_LOSSY to enable lossy conversions,\"\n    \" ALL_NON_LOSSY to enable non-lossy conversions,\"\n    \" ALL_UNSIGNED to treat all integer column type data to be unsigned \"\n    \"values, and\"\n    \" ALL_SIGNED to treat all integer column type data to be signed values.\"\n    \" Default treatment is ALL_SIGNED. If ALL_SIGNED and ALL_UNSIGNED both \"\n    \"are\"\n    \" specified, ALL_SIGNED will take higher priority than ALL_UNSIGNED.\"\n    \" If the variable is assigned the empty set, no conversions are\"\n    \" allowed and it is expected that the types match exactly.\",\n    GLOBAL_VAR(slave_type_conversions_options), CMD_LINE(REQUIRED_ARG),\n    slave_type_conversions_name, DEFAULT(0));\n\nstatic Sys_var_bool Sys_slave_sql_verify_checksum(\n    \"slave_sql_verify_checksum\",\n    \"Force checksum verification of replication events after reading them \"\n    \"from relay log. Note: Events are always checksum-verified by slave on \"\n    \"receiving them from the network before writing them to the relay \"\n    \"log. Enabled by default.\",\n    GLOBAL_VAR(opt_slave_sql_verify_checksum), CMD_LINE(OPT_ARG),\n    DEFAULT(true));\n\nstatic bool check_not_null_not_empty(sys_var *self, THD *thd, set_var *var) {\n  String str, *res;\n  /* null value is not allowed */\n  if (check_not_null(self, thd, var)) return true;\n\n  /** empty value ('') is not allowed */\n  res = var->value ? var->value->val_str(&str) : nullptr;\n  if (res && res->is_empty()) return true;\n\n  return false;\n}\n\nstatic bool check_slave_stopped(sys_var *self, THD *thd, set_var *var) {\n  bool result = false;\n  Master_info *mi = nullptr;\n\n  if (check_not_null_not_empty(self, thd, var)) return true;\n\n  channel_map.wrlock();\n\n  for (mi_map::iterator it = channel_map.begin(); it != channel_map.end();\n       it++) {\n    mi = it->second;\n    if (mi) {\n      mysql_mutex_lock(&mi->rli->run_lock);\n      if (mi->rli->slave_running) {\n        my_error(ER_SLAVE_SQL_THREAD_MUST_STOP, MYF(0));\n        result = true;\n      }\n      mysql_mutex_unlock(&mi->rli->run_lock);\n    }\n  }\n  channel_map.unlock();\n  return result;\n}\n\nstatic const char *slave_rows_search_algorithms_names[] = {\n    \"TABLE_SCAN\", \"INDEX_SCAN\", \"HASH_SCAN\", nullptr};\nstatic Sys_var_set Slave_rows_search_algorithms(\n    \"slave_rows_search_algorithms\",\n    \"Set of searching algorithms that the slave will use while \"\n    \"searching for records from the storage engine to either \"\n    \"updated or deleted them. Possible values are: INDEX_SCAN, \"\n    \"TABLE_SCAN and HASH_SCAN. Any combination is allowed, and \"\n    \"the slave will always pick the most suitable algorithm for \"\n    \"any given scenario. \"\n    \"(Default: INDEX_SCAN, HASH_SCAN).\",\n    GLOBAL_VAR(slave_rows_search_algorithms_options),\n    CMD_LINE(REQUIRED_ARG, OPT_SLAVE_ROWS_SEARCH_ALGORITHMS),\n    slave_rows_search_algorithms_names,\n    DEFAULT(SLAVE_ROWS_INDEX_SCAN | SLAVE_ROWS_HASH_SCAN), NO_MUTEX_GUARD,\n    NOT_IN_BINLOG, ON_CHECK(check_not_null_not_empty), ON_UPDATE(nullptr),\n    DEPRECATED_VAR(\"\"));\n\nstatic const char *mts_parallel_type_names[] = {\"DATABASE\", \"LOGICAL_CLOCK\",\n                                                nullptr};\nstatic Sys_var_enum Mts_parallel_type(\n    \"slave_parallel_type\",\n    \"Specifies if the slave will use database partitioning \"\n    \"or information from master to parallelize transactions.\"\n    \"(Default: DATABASE).\",\n    PERSIST_AS_READONLY GLOBAL_VAR(mts_parallel_option), CMD_LINE(REQUIRED_ARG),\n    mts_parallel_type_names, DEFAULT(MTS_PARALLEL_TYPE_DB_NAME), NO_MUTEX_GUARD,\n    NOT_IN_BINLOG, ON_CHECK(check_slave_stopped), ON_UPDATE(nullptr));\n\nstatic bool check_binlog_transaction_dependency_tracking(sys_var *, THD *,\n                                                         set_var *var) {\n  if (global_system_variables.transaction_write_set_extraction ==\n          HASH_ALGORITHM_OFF &&\n      var->save_result.ulonglong_value != DEPENDENCY_TRACKING_COMMIT_ORDER) {\n    my_error(ER_WRONG_USAGE, MYF(0),\n             \"binlog_transaction_dependency_tracking (!= COMMIT_ORDER)\",\n             \"transaction_write_set_extraction (= OFF)\");\n\n    return true;\n  }\n  return false;\n}\n\nstatic bool update_binlog_transaction_dependency_tracking(sys_var *, THD *,\n                                                          enum_var_type) {\n  /*\n    the writeset_history_start needs to be set to 0 whenever there is a\n    change in the transaction dependency source so that WS and COMMIT\n    transition smoothly.\n  */\n  mysql_bin_log.m_dependency_tracker.tracking_mode_changed();\n  return false;\n}\n\nstatic PolyLock_mutex PLock_slave_trans_dep_tracker(\n    &LOCK_slave_trans_dep_tracker);\nstatic const char *opt_binlog_transaction_dependency_tracking_names[] = {\n    \"COMMIT_ORDER\", \"WRITESET\", \"WRITESET_SESSION\", NullS};\nstatic Sys_var_enum Binlog_transaction_dependency_tracking(\n    \"binlog_transaction_dependency_tracking\",\n    \"Selects the source of dependency information from which to \"\n    \"assess which transactions can be executed in parallel by the \"\n    \"slave's multi-threaded applier. \"\n    \"Possible values are COMMIT_ORDER, WRITESET and WRITESET_SESSION.\",\n    GLOBAL_VAR(mysql_bin_log.m_dependency_tracker.m_opt_tracking_mode),\n    CMD_LINE(REQUIRED_ARG), opt_binlog_transaction_dependency_tracking_names,\n    DEFAULT(DEPENDENCY_TRACKING_COMMIT_ORDER), &PLock_slave_trans_dep_tracker,\n    NOT_IN_BINLOG, ON_CHECK(check_binlog_transaction_dependency_tracking),\n    ON_UPDATE(update_binlog_transaction_dependency_tracking));\nstatic Sys_var_ulong Binlog_transaction_dependency_history_size(\n    \"binlog_transaction_dependency_history_size\",\n    \"Maximum number of rows to keep in the writeset history.\",\n    GLOBAL_VAR(mysql_bin_log.m_dependency_tracker.get_writeset()\n                   ->m_opt_max_history_size),\n    CMD_LINE(REQUIRED_ARG, 0), VALID_RANGE(1, 1000000), DEFAULT(25000),\n    BLOCK_SIZE(1), &PLock_slave_trans_dep_tracker, NOT_IN_BINLOG,\n    ON_CHECK(nullptr), ON_UPDATE(nullptr));\n\nstatic Sys_var_bool Sys_slave_preserve_commit_order(\n    \"slave_preserve_commit_order\",\n    \"Force slave workers to make commits in the same order as on the master. \"\n    \"Disabled by default.\",\n    PERSIST_AS_READONLY GLOBAL_VAR(opt_slave_preserve_commit_order),\n    CMD_LINE(OPT_ARG, OPT_SLAVE_PRESERVE_COMMIT_ORDER), DEFAULT(false),\n    NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(check_slave_stopped),\n    ON_UPDATE(nullptr));\n\nbool Sys_var_charptr::global_update(THD *, set_var *var) {\n  char *new_val, *ptr = var->save_result.string_value.str;\n  size_t len = var->save_result.string_value.length;\n  if (ptr) {\n    new_val = (char *)my_memdup(key_memory_Sys_var_charptr_value, ptr, len + 1,\n                                MYF(MY_WME));\n    if (!new_val) return true;\n    new_val[len] = 0;\n  } else\n    new_val = nullptr;\n  if (flags & ALLOCATED) my_free(global_var(char *));\n  flags |= ALLOCATED;\n  global_var(char *) = new_val;\n  return false;\n}\n\nbool Sys_var_enum_binlog_checksum::global_update(THD *thd, set_var *var) {\n  bool check_purge = false;\n\n  /*\n    SET binlog_checksome command should ignore 'read-only' and\n    'super_read_only' options so that it can update 'mysql.gtid_executed'\n    replication repository table.\n  */\n  thd->set_skip_readonly_check();\n  mysql_mutex_lock(mysql_bin_log.get_log_lock());\n  if (mysql_bin_log.is_open()) {\n    bool alg_changed =\n        (binlog_checksum_options != (uint)var->save_result.ulonglong_value);\n    if (alg_changed)\n      mysql_bin_log.checksum_alg_reset =\n          (uint8)var->save_result.ulonglong_value;\n    mysql_bin_log.rotate(true, &check_purge);\n    if (alg_changed)\n      mysql_bin_log.checksum_alg_reset =\n          binary_log::BINLOG_CHECKSUM_ALG_UNDEF;  // done\n  } else {\n    binlog_checksum_options =\n        static_cast<ulong>(var->save_result.ulonglong_value);\n  }\n  DBUG_ASSERT(binlog_checksum_options == var->save_result.ulonglong_value);\n  DBUG_ASSERT(mysql_bin_log.checksum_alg_reset ==\n              binary_log::BINLOG_CHECKSUM_ALG_UNDEF);\n  mysql_mutex_unlock(mysql_bin_log.get_log_lock());\n\n  if (check_purge) mysql_bin_log.purge();\n\n  return false;\n}\n\nbool Sys_var_gtid_next::session_update(THD *thd, set_var *var) {\n  DBUG_TRACE;\n  char buf[Gtid::MAX_TEXT_LENGTH + 1];\n  // Get the value\n  String str(buf, sizeof(buf), &my_charset_latin1);\n  char *res = nullptr;\n  if (!var->value) {\n    // set session gtid_next= default\n    DBUG_ASSERT(var->save_result.string_value.str);\n    DBUG_ASSERT(var->save_result.string_value.length);\n    res = var->save_result.string_value.str;\n  } else if (var->value->val_str(&str))\n    res = var->value->val_str(&str)->c_ptr_safe();\n  if (!res) {\n    my_error(ER_WRONG_VALUE_FOR_VAR, MYF(0), name.str, \"NULL\");\n    return true;\n  }\n  global_sid_lock->rdlock();\n  Gtid_specification spec;\n  if (spec.parse(global_sid_map, res) != RETURN_STATUS_OK) {\n    global_sid_lock->unlock();\n    return true;\n  }\n\n  bool ret = set_gtid_next(thd, spec);\n  // set_gtid_next releases global_sid_lock\n  return ret;\n}\n\n#ifdef HAVE_GTID_NEXT_LIST\nbool Sys_var_gtid_set::session_update(THD *thd, set_var *var) {\n  DBUG_TRACE;\n  Gtid_set_or_null *gsn = (Gtid_set_or_null *)session_var_ptr(thd);\n  char *value = var->save_result.string_value.str;\n  if (value == NULL)\n    gsn->set_null();\n  else {\n    Gtid_set *gs = gsn->set_non_null(global_sid_map);\n    if (gs == NULL) {\n      my_error(ER_OUT_OF_RESOURCES, MYF(0));  // allocation failed\n      return true;\n    }\n    /*\n      If string begins with '+', add to the existing set, otherwise\n      replace existing set.\n    */\n    while (isspace(*value)) value++;\n    if (*value == '+')\n      value++;\n    else\n      gs->clear();\n    // Add specified set of groups to Gtid_set.\n    global_sid_lock->rdlock();\n    enum_return_status ret = gs->add_gtid_text(value);\n    global_sid_lock->unlock();\n    if (ret != RETURN_STATUS_OK) {\n      gsn->set_null();\n      return true;\n    }\n  }\n  return false;\n}\n#endif  // HAVE_GTID_NEXT_LIST\n\n/**\n  This function shall issue a deprecation warning\n  if the new gtid mode is set to GTID_MODE_ON and\n  there is at least one replication channel with\n  IGNORE_SERVER_IDS configured (i.e., not empty).\n\n  The caller must have acquired a lock on the\n  channel_map object before calling this function.\n\n  The warning emitted is: ER_WARN_DEPRECATED_SYNTAX_NO_REPLACEMENT .\n\n  @param thd The current session thread context.\n  @param oldmode The old value of @@global.gtid_mode.\n  @param newmode The new value for @@global.gtid_mode.\n\n*/\nstatic void issue_deprecation_warnings_gtid_mode(\n    THD *thd, enum_gtid_mode oldmode MY_ATTRIBUTE((unused)),\n    enum_gtid_mode newmode) {\n  channel_map.assert_some_lock();\n\n  /*\n    Check that if changing to gtid_mode=on no channel is configured\n    to ignore server ids. If it is, issue a deprecation warning.\n  */\n  if (newmode == GTID_MODE_ON) {\n    for (mi_map::iterator it = channel_map.begin(); it != channel_map.end();\n         it++) {\n      Master_info *mi = it->second;\n      if (mi != nullptr && mi->is_ignore_server_ids_configured()) {\n        push_warning_printf(\n            thd, Sql_condition::SL_WARNING, ER_WARN_DEPRECATED_SYNTAX,\n            ER_THD(thd, ER_WARN_DEPRECATED_SYNTAX_NO_REPLACEMENT),\n            \"CHANGE MASTER TO ... IGNORE_SERVER_IDS='...' \"\n            \"(when @@GLOBAL.GTID_MODE = ON)\");\n\n        break;  // Only push one warning\n      }\n    }\n  }\n}\n\n/**\n  This function shall be called whenever the global scope\n  of gtid_mode var is updated.\n\n  It checks some preconditions and also emits deprecation\n  warnings conditionally when changing the value.\n\n  Deprecation warnings are emitted after error conditions\n  have been checked and only if there is no error raised.\n*/\nbool Sys_var_gtid_mode::global_update(THD *thd, set_var *var) {\n  DBUG_TRACE;\n  bool ret = true;\n\n  /*\n    SET binlog_checksome command should ignore 'read-only' and\n    'super_read_only' options so that it can update 'mysql.gtid_executed'\n    replication repository table.\n  */\n  thd->set_skip_readonly_check();\n  /*\n    Hold lock_log so that:\n    - other transactions are not flushed while gtid_mode is changed;\n    - gtid_mode is not changed while some other thread is rotating\n    the binlog.\n\n    Hold channel_map lock so that:\n    - gtid_mode is not changed during the execution of some\n    replication command; particularly CHANGE MASTER. CHANGE MASTER\n    checks if GTID_MODE is compatible with AUTO_POSITION, and\n    later it actually updates the in-memory structure for\n    AUTO_POSITION.  If gtid_mode was changed between these calls,\n    auto_position could be set incompatible with gtid_mode.\n\n    Hold global_sid_lock.wrlock so that:\n    - other transactions cannot acquire ownership of any gtid.\n\n    Hold gtid_mode_lock so that all places that don't want to hold\n    any of the other locks, but want to read gtid_mode, don't need\n    to take the other locks.\n  */\n\n  enum_gtid_mode new_gtid_mode =\n      (enum_gtid_mode)var->save_result.ulonglong_value;\n\n  if (gtid_mode_lock->trywrlock()) {\n    my_error(ER_CANT_SET_GTID_MODE, MYF(0), get_gtid_mode_string(new_gtid_mode),\n             \"there is a concurrent operation that disallows changes to \"\n             \"@@GLOBAL.GTID_MODE\");\n    return ret;\n  }\n\n  DEBUG_SYNC(\n      thd,\n      \"gtid_mode_update_gtid_mode_lock_wrlock_taken_will_take_global_sid_lock\");\n\n  channel_map.wrlock();\n  mysql_mutex_lock(mysql_bin_log.get_log_lock());\n  global_sid_lock->wrlock();\n  int lock_count = 4;\n\n  enum_gtid_mode old_gtid_mode = get_gtid_mode(GTID_MODE_LOCK_SID);\n  DBUG_ASSERT(new_gtid_mode <= GTID_MODE_ON);\n\n  DBUG_PRINT(\"info\", (\"old_gtid_mode=%d new_gtid_mode=%d\", old_gtid_mode,\n                      new_gtid_mode));\n\n  if (new_gtid_mode == old_gtid_mode) goto end;\n\n  // Can only change one step at a time.\n  /*\n   Change gtid_mode value without checking for one step change during\n   server startup.\n  */\n  if (mysqld_server_started &&\n      abs((int)new_gtid_mode - (int)old_gtid_mode) > 1) {\n    my_error(ER_GTID_MODE_CAN_ONLY_CHANGE_ONE_STEP_AT_A_TIME, MYF(0));\n    goto err;\n  }\n\n  // Not allowed with slave_sql_skip_counter\n  DBUG_PRINT(\"info\", (\"sql_slave_skip_counter=%d\", sql_slave_skip_counter));\n  if (new_gtid_mode == GTID_MODE_ON && sql_slave_skip_counter > 0) {\n    my_error(ER_CANT_SET_GTID_MODE, MYF(0), \"ON\",\n             \"@@GLOBAL.SQL_SLAVE_SKIP_COUNTER is greater than zero\");\n    goto err;\n  }\n\n  if (new_gtid_mode != GTID_MODE_ON && replicate_same_server_id &&\n      opt_log_slave_updates && opt_bin_log) {\n    std::string mode = get_gtid_mode_string(new_gtid_mode);\n    std::stringstream ss;\n\n    ss << \"replicate_same_server_id is set together with log_slave_updates\"\n       << \" and log_bin. Thus, setting @@global.GTID_MODE = \" << mode\n       << \" would lead to infinite loops in case this server is part of a\"\n       << \" circular replication topology\";\n\n    my_error(ER_CANT_SET_GTID_MODE, MYF(0), mode.c_str(), ss.str().c_str());\n    goto err;\n  }\n\n  // Cannot set OFF when some channel uses AUTO_POSITION.\n  if (new_gtid_mode == GTID_MODE_OFF) {\n    for (mi_map::iterator it = channel_map.begin(); it != channel_map.end();\n         it++) {\n      Master_info *mi = it->second;\n      DBUG_PRINT(\"info\", (\"auto_position for channel '%s' is %d\",\n                          mi->get_channel(), mi->is_auto_position()));\n      if (mi != nullptr && mi->is_auto_position()) {\n        char buf[1024];\n        snprintf(buf, sizeof(buf),\n                 \"replication channel '%.192s' is configured \"\n                 \"in AUTO_POSITION mode. Execute \"\n                 \"CHANGE MASTER TO MASTER_AUTO_POSITION = 0 \"\n                 \"FOR CHANNEL '%.192s' before you set \"\n                 \"@@GLOBAL.GTID_MODE = OFF.\",\n                 mi->get_channel(), mi->get_channel());\n        my_error(ER_CANT_SET_GTID_MODE, MYF(0), \"OFF\", buf);\n        goto err;\n      }\n    }\n  }\n\n  // Can't set GTID_MODE != ON when group replication is enabled.\n  if (is_group_replication_running()) {\n    DBUG_ASSERT(old_gtid_mode == GTID_MODE_ON);\n    DBUG_ASSERT(new_gtid_mode == GTID_MODE_ON_PERMISSIVE);\n    my_error(ER_CANT_SET_GTID_MODE, MYF(0), get_gtid_mode_string(new_gtid_mode),\n             \"group replication requires @@GLOBAL.GTID_MODE=ON\");\n    goto err;\n  }\n\n  // Compatible with ongoing transactions.\n  DBUG_PRINT(\"info\", (\"anonymous_ownership_count=%d owned_gtids->is_empty=%d\",\n                      gtid_state->get_anonymous_ownership_count(),\n                      gtid_state->get_owned_gtids()->is_empty()));\n  gtid_state->get_owned_gtids()->dbug_print(\"global owned_gtids\");\n  if (new_gtid_mode == GTID_MODE_ON &&\n      gtid_state->get_anonymous_ownership_count() > 0) {\n    my_error(ER_CANT_SET_GTID_MODE, MYF(0), \"ON\",\n             \"there are ongoing, anonymous transactions. Before \"\n             \"setting @@GLOBAL.GTID_MODE = ON, wait until \"\n             \"SHOW STATUS LIKE 'ANONYMOUS_TRANSACTION_COUNT' \"\n             \"shows zero on all servers. Then wait for all \"\n             \"existing, anonymous transactions to replicate to \"\n             \"all slaves, and then execute \"\n             \"SET @@GLOBAL.GTID_MODE = ON on all servers. \"\n             \"See the Manual for details\");\n    goto err;\n  }\n\n  if (new_gtid_mode == GTID_MODE_OFF &&\n      !gtid_state->get_owned_gtids()->is_empty()) {\n    my_error(ER_CANT_SET_GTID_MODE, MYF(0), \"OFF\",\n             \"there are ongoing transactions that have a GTID. \"\n             \"Before you set @@GLOBAL.GTID_MODE = OFF, wait \"\n             \"until SELECT @@GLOBAL.GTID_OWNED is empty on all \"\n             \"servers. Then wait for all GTID-transactions to \"\n             \"replicate to all servers, and then execute \"\n             \"SET @@GLOBAL.GTID_MODE = OFF on all servers. \"\n             \"See the Manual for details\");\n    goto err;\n  }\n\n  // Compatible with ongoing GTID-violating transactions\n  DBUG_PRINT(\"info\",\n             (\"automatic_gtid_violating_transaction_count=%d\",\n              gtid_state->get_automatic_gtid_violating_transaction_count()));\n  if (new_gtid_mode >= GTID_MODE_ON_PERMISSIVE &&\n      gtid_state->get_automatic_gtid_violating_transaction_count() > 0) {\n    my_error(ER_CANT_SET_GTID_MODE, MYF(0), \"ON_PERMISSIVE\",\n             \"there are ongoing transactions that use \"\n             \"GTID_NEXT = 'AUTOMATIC', which violate GTID \"\n             \"consistency. Adjust your workload to be \"\n             \"GTID-consistent before setting \"\n             \"@@GLOBAL.GTID_MODE = ON_PERMISSIVE. \"\n             \"See the Manual for \"\n             \"@@GLOBAL.ENFORCE_GTID_CONSISTENCY for details\");\n    goto err;\n  }\n\n  // Compatible with ENFORCE_GTID_CONSISTENCY.\n  if (new_gtid_mode == GTID_MODE_ON &&\n      get_gtid_consistency_mode() != GTID_CONSISTENCY_MODE_ON) {\n    my_error(ER_CANT_SET_GTID_MODE, MYF(0), \"ON\",\n             \"ENFORCE_GTID_CONSISTENCY is not ON\");\n    goto err;\n  }\n\n  // Can't set GTID_MODE=OFF with ongoing calls to\n  // WAIT_FOR_EXECUTED_GTID_SET or\n  // WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS.\n  DBUG_PRINT(\"info\",\n             (\"gtid_wait_count=%d\", gtid_state->get_gtid_wait_count() > 0));\n  if (new_gtid_mode == GTID_MODE_OFF && gtid_state->get_gtid_wait_count() > 0) {\n    my_error(ER_CANT_SET_GTID_MODE, MYF(0), \"OFF\",\n             \"there are ongoing calls to \"\n             \"WAIT_FOR_EXECUTED_GTID_SET or \"\n             \"WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS. Before you set \"\n             \"@@GLOBAL.GTID_MODE = OFF, ensure that no other \"\n             \"client is waiting for GTID-transactions to be \"\n             \"committed\");\n    goto err;\n  }\n\n  // Update the mode\n  global_var(ulong) = new_gtid_mode;\n  gtid_mode_counter++;\n  global_sid_lock->unlock();\n  lock_count = 3;\n\n  // Generate note in log\n  LogErr(SYSTEM_LEVEL, ER_CHANGED_GTID_MODE, gtid_mode_names[old_gtid_mode],\n         gtid_mode_names[new_gtid_mode]);\n\n  // Rotate\n  {\n    bool dont_care = false;\n    if (mysql_bin_log.rotate(true, &dont_care)) goto err;\n  }\n\nend:\n  /* handle deprecations warning */\n  issue_deprecation_warnings_gtid_mode(thd, old_gtid_mode, new_gtid_mode);\n\n  ret = false;\nerr:\n  DBUG_ASSERT(lock_count >= 0);\n  DBUG_ASSERT(lock_count <= 4);\n  if (lock_count == 4) global_sid_lock->unlock();\n  mysql_mutex_unlock(mysql_bin_log.get_log_lock());\n  channel_map.unlock();\n  gtid_mode_lock->unlock();\n  return ret;\n}\n\nbool Sys_var_enforce_gtid_consistency::global_update(THD *thd, set_var *var) {\n  DBUG_TRACE;\n  bool ret = true;\n\n  /*\n    Hold global_sid_lock.wrlock so that other transactions cannot\n    acquire ownership of any gtid.\n  */\n  global_sid_lock->wrlock();\n\n  DBUG_PRINT(\"info\", (\"var->save_result.ulonglong_value=%llu\",\n                      var->save_result.ulonglong_value));\n  enum_gtid_consistency_mode new_mode =\n      (enum_gtid_consistency_mode)var->save_result.ulonglong_value;\n  enum_gtid_consistency_mode old_mode = get_gtid_consistency_mode();\n  enum_gtid_mode gtid_mode = get_gtid_mode(GTID_MODE_LOCK_SID);\n\n  DBUG_ASSERT(new_mode <= GTID_CONSISTENCY_MODE_WARN);\n\n  DBUG_PRINT(\"info\", (\"old enforce_gtid_consistency=%d \"\n                      \"new enforce_gtid_consistency=%d \"\n                      \"gtid_mode=%d \",\n                      old_mode, new_mode, gtid_mode));\n\n  if (new_mode == old_mode) goto end;\n\n  // Can't turn off GTID-consistency when GTID_MODE=ON.\n  if (new_mode != GTID_CONSISTENCY_MODE_ON && gtid_mode == GTID_MODE_ON) {\n    my_error(ER_GTID_MODE_ON_REQUIRES_ENFORCE_GTID_CONSISTENCY_ON, MYF(0));\n    goto err;\n  }\n  // If there are ongoing GTID-violating transactions, and we are\n  // moving from OFF->ON, WARN->ON, or OFF->WARN, generate warning\n  // or error accordingly.\n  if (new_mode == GTID_CONSISTENCY_MODE_ON ||\n      (old_mode == GTID_CONSISTENCY_MODE_OFF &&\n       new_mode == GTID_CONSISTENCY_MODE_WARN)) {\n    DBUG_PRINT(\"info\",\n               (\"automatic_gtid_violating_transaction_count=%d \"\n                \"anonymous_gtid_violating_transaction_count=%d\",\n                gtid_state->get_automatic_gtid_violating_transaction_count(),\n                gtid_state->get_anonymous_gtid_violating_transaction_count()));\n    if (gtid_state->get_automatic_gtid_violating_transaction_count() > 0 ||\n        gtid_state->get_anonymous_gtid_violating_transaction_count() > 0) {\n      if (new_mode == GTID_CONSISTENCY_MODE_ON) {\n        my_error(\n            ER_CANT_ENFORCE_GTID_CONSISTENCY_WITH_ONGOING_GTID_VIOLATING_TX,\n            MYF(0));\n        goto err;\n      } else {\n        push_warning(\n            thd, Sql_condition::SL_WARNING,\n            ER_ENFORCE_GTID_CONSISTENCY_WARN_WITH_ONGOING_GTID_VIOLATING_TX,\n            ER_THD(\n                thd,\n                ER_ENFORCE_GTID_CONSISTENCY_WARN_WITH_ONGOING_GTID_VIOLATING_TX));\n      }\n    }\n  }\n\n  // Update the mode\n  global_var(ulong) = new_mode;\n\n  // Generate note in log\n  LogErr(INFORMATION_LEVEL, ER_CHANGED_ENFORCE_GTID_CONSISTENCY,\n         get_gtid_consistency_mode_string(old_mode),\n         get_gtid_consistency_mode_string(new_mode));\n\nend:\n  ret = false;\nerr:\n  global_sid_lock->unlock();\n  return ret;\n}\n\nstatic Sys_var_enum_binlog_checksum Binlog_checksum_enum(\n    \"binlog_checksum\",\n    \"Type of BINLOG_CHECKSUM_ALG. Include checksum for \"\n    \"log events in the binary log. Possible values are NONE and CRC32; \"\n    \"default is CRC32.\",\n    GLOBAL_VAR(binlog_checksum_options), CMD_LINE(REQUIRED_ARG),\n    binlog_checksum_type_names, DEFAULT(binary_log::BINLOG_CHECKSUM_ALG_CRC32),\n    NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(check_outside_trx));\n\nstatic Sys_var_bool Sys_master_verify_checksum(\n    \"master_verify_checksum\",\n    \"Force checksum verification of logged events in binary log before \"\n    \"sending them to slaves or printing them in output of SHOW BINLOG \"\n    \"EVENTS. \"\n    \"Disabled by default.\",\n    GLOBAL_VAR(opt_master_verify_checksum), CMD_LINE(OPT_ARG), DEFAULT(false));\n\nstatic Sys_var_ulong Sys_slow_launch_time(\n    \"slow_launch_time\",\n    \"If creating the thread takes longer than this value (in seconds), \"\n    \"the Slow_launch_threads counter will be incremented\",\n    GLOBAL_VAR(slow_launch_time), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(0, LONG_TIMEOUT), DEFAULT(2), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_sort_buffer(\n    \"sort_buffer_size\",\n    \"Each thread that needs to do a sort allocates a buffer of this size\",\n    HINT_UPDATEABLE SESSION_VAR(sortbuff_size), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(MIN_SORT_MEMORY, ULONG_MAX), DEFAULT(DEFAULT_SORT_MEMORY),\n    BLOCK_SIZE(1));\n\n/**\n  Check sql modes strict_mode, 'NO_ZERO_DATE', 'NO_ZERO_IN_DATE' and\n  'ERROR_FOR_DIVISION_BY_ZERO' are used together. If only subset of it\n  is set then warning is reported.\n\n  @param sql_mode sql mode.\n  @param thd      Current thread\n*/\nstatic void check_sub_modes_of_strict_mode(sql_mode_t &sql_mode, THD *thd) {\n  const sql_mode_t strict_modes =\n      (MODE_STRICT_TRANS_TABLES | MODE_STRICT_ALL_TABLES);\n\n  const sql_mode_t new_strict_submodes =\n      (MODE_NO_ZERO_IN_DATE | MODE_NO_ZERO_DATE |\n       MODE_ERROR_FOR_DIVISION_BY_ZERO);\n\n  const sql_mode_t strict_modes_set = (sql_mode & strict_modes);\n  const sql_mode_t new_strict_submodes_set = (sql_mode & new_strict_submodes);\n\n  if (((strict_modes_set | new_strict_submodes_set) != 0) &&\n      ((new_strict_submodes_set != new_strict_submodes) ||\n       (strict_modes_set == 0))) {\n    if (thd)\n      push_warning(thd, Sql_condition::SL_WARNING, ER_SQL_MODE_MERGED,\n                   ER_THD(thd, ER_SQL_MODE_MERGED));\n    else\n      LogErr(WARNING_LEVEL, ER_SQL_MODE_MERGED_WITH_STRICT_MODE);\n  }\n}\n\nexport sql_mode_t expand_sql_mode(sql_mode_t sql_mode, THD *thd) {\n  if (sql_mode & MODE_ANSI) {\n    /*\n      Note that we dont set\n      MODE_NO_KEY_OPTIONS | MODE_NO_TABLE_OPTIONS | MODE_NO_FIELD_OPTIONS\n      to allow one to get full use of MySQL in this mode.\n    */\n    sql_mode |= (MODE_REAL_AS_FLOAT | MODE_PIPES_AS_CONCAT | MODE_ANSI_QUOTES |\n                 MODE_IGNORE_SPACE | MODE_ONLY_FULL_GROUP_BY);\n  }\n  if (sql_mode & MODE_TRADITIONAL)\n    sql_mode |= (MODE_STRICT_TRANS_TABLES | MODE_STRICT_ALL_TABLES |\n                 MODE_NO_ZERO_IN_DATE | MODE_NO_ZERO_DATE |\n                 MODE_ERROR_FOR_DIVISION_BY_ZERO | MODE_NO_ENGINE_SUBSTITUTION);\n\n  check_sub_modes_of_strict_mode(sql_mode, thd);\n  return sql_mode;\n}\nstatic bool check_sql_mode(sys_var *, THD *thd, set_var *var) {\n  sql_mode_t candidate_mode =\n      expand_sql_mode(var->save_result.ulonglong_value, thd);\n\n  if (candidate_mode & ~(MODE_ALLOWED_MASK | MODE_IGNORED_MASK)) {\n    my_error(ER_UNSUPPORTED_SQL_MODE, MYF(0),\n             candidate_mode & ~(MODE_ALLOWED_MASK | MODE_IGNORED_MASK));\n    return true;  // mode seems never supported before\n  }\n\n  if (candidate_mode & ~MODE_ALLOWED_MASK) {\n    if (thd->variables.pseudo_slave_mode &&  // (1)\n        thd->lex->sphead == nullptr) {       // (2)\n      /*\n        (1): catch the auto-generated SET SQL_MODE calls in the output of\n             mysqlbinlog,\n        (2): but ignore the other ones (e.g. nested SET SQL_MODE calls in\n             SBR-invoked trigger calls).\n      */\n      push_warning_printf(\n          thd, Sql_condition::SL_WARNING, ER_WARN_REMOVED_SQL_MODE,\n          ER_THD(thd, ER_WARN_REMOVED_SQL_MODE),\n          static_cast<uint>(candidate_mode & ~MODE_ALLOWED_MASK));\n      // ignore obsolete mode flags in case this is an old mysqlbinlog:\n      candidate_mode &= MODE_ALLOWED_MASK;\n    } else {\n      my_error(ER_UNSUPPORTED_SQL_MODE, MYF(0),\n               candidate_mode & ~MODE_ALLOWED_MASK);\n      return true;  // error on obsolete mode flags\n    }\n  }\n\n  if (candidate_mode & MODE_PAD_CHAR_TO_FULL_LENGTH) {\n    push_warning_printf(\n        thd, Sql_condition::SL_WARNING, ER_WARN_DEPRECATED_SQLMODE,\n        ER_THD(thd, ER_WARN_DEPRECATED_SQLMODE), \"PAD_CHAR_TO_FULL_LENGTH\");\n  }\n\n  var->save_result.ulonglong_value = candidate_mode;\n  return false;\n}\nstatic bool fix_sql_mode(sys_var *self, THD *thd, enum_var_type type) {\n  if (!self->is_global_persist(type)) {\n    /* Update thd->server_status */\n    if (thd->variables.sql_mode & MODE_NO_BACKSLASH_ESCAPES)\n      thd->server_status |= SERVER_STATUS_NO_BACKSLASH_ESCAPES;\n    else\n      thd->server_status &= ~SERVER_STATUS_NO_BACKSLASH_ESCAPES;\n  }\n  return false;\n}\n/*\n  WARNING: When adding new SQL modes don't forget to update the\n  tables definitions that stores it's value (ie: mysql.event, mysql.routines,\n  mysql.triggers)\n*/\nstatic const char *sql_mode_names[] = {\"REAL_AS_FLOAT\",\n                                       \"PIPES_AS_CONCAT\",\n                                       \"ANSI_QUOTES\",\n                                       \"IGNORE_SPACE\",\n                                       \"NOT_USED\",\n                                       \"ONLY_FULL_GROUP_BY\",\n                                       \"NO_UNSIGNED_SUBTRACTION\",\n                                       \"NO_DIR_IN_CREATE\",\n                                       \"NOT_USED_9\",\n                                       \"NOT_USED_10\",\n                                       \"NOT_USED_11\",\n                                       \"NOT_USED_12\",\n                                       \"NOT_USED_13\",\n                                       \"NOT_USED_14\",\n                                       \"NOT_USED_15\",\n                                       \"NOT_USED_16\",\n                                       \"NOT_USED_17\",\n                                       \"NOT_USED_18\",\n                                       \"ANSI\",\n                                       \"NO_AUTO_VALUE_ON_ZERO\",\n                                       \"NO_BACKSLASH_ESCAPES\",\n                                       \"STRICT_TRANS_TABLES\",\n                                       \"STRICT_ALL_TABLES\",\n                                       \"NO_ZERO_IN_DATE\",\n                                       \"NO_ZERO_DATE\",\n                                       \"ALLOW_INVALID_DATES\",\n                                       \"ERROR_FOR_DIVISION_BY_ZERO\",\n                                       \"TRADITIONAL\",\n                                       \"NOT_USED_29\",\n                                       \"HIGH_NOT_PRECEDENCE\",\n                                       \"NO_ENGINE_SUBSTITUTION\",\n                                       \"PAD_CHAR_TO_FULL_LENGTH\",\n                                       \"TIME_TRUNCATE_FRACTIONAL\",\n                                       nullptr};\nexport bool sql_mode_string_representation(THD *thd, sql_mode_t sql_mode,\n                                           LEX_STRING *ls) {\n  set_to_string(thd, ls, sql_mode, sql_mode_names);\n  return ls->str == nullptr;\n}\nexport bool sql_mode_quoted_string_representation(THD *thd, sql_mode_t sql_mode,\n                                                  LEX_STRING *ls) {\n  set_to_string(thd, ls, sql_mode, sql_mode_names, true);\n  return ls->str == nullptr;\n}\n/*\n  sql_mode should *not* be IN_BINLOG: even though it is written to the binlog,\n  the slave ignores the MODE_NO_DIR_IN_CREATE variable, so slave's value\n  differs from master's (see log_event.cc: Query_log_event::do_apply_event()).\n*/\nstatic Sys_var_set Sys_sql_mode(\n    \"sql_mode\",\n    \"Syntax: sql-mode=mode[,mode[,mode...]]. See the manual for the \"\n    \"complete list of valid sql modes\",\n    HINT_UPDATEABLE SESSION_VAR(sql_mode), CMD_LINE(REQUIRED_ARG),\n    sql_mode_names,\n    DEFAULT(MODE_NO_ENGINE_SUBSTITUTION | MODE_ONLY_FULL_GROUP_BY |\n            MODE_STRICT_TRANS_TABLES | MODE_NO_ZERO_IN_DATE |\n            MODE_NO_ZERO_DATE | MODE_ERROR_FOR_DIVISION_BY_ZERO),\n    NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(check_sql_mode),\n    ON_UPDATE(fix_sql_mode));\n\nstatic Sys_var_ulong Sys_max_execution_time(\n    \"max_execution_time\",\n    \"Kill SELECT statement that takes over the specified number of \"\n    \"milliseconds\",\n    HINT_UPDATEABLE SESSION_VAR(max_execution_time), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(0, ULONG_MAX), DEFAULT(0), BLOCK_SIZE(1));\n\nstatic bool update_fips_mode(sys_var *, THD *, enum_var_type) {\n  char ssl_err_string[OPENSSL_ERROR_LENGTH] = {'\\0'};\n  if (set_fips_mode(opt_ssl_fips_mode, ssl_err_string) != 1) {\n    opt_ssl_fips_mode = get_fips_mode();\n    my_error(ER_SSL_FIPS_MODE_ERROR, MYF(0), \"Openssl is not fips enabled\");\n    return true;\n  } else {\n    return false;\n  }\n}\n\nstatic const char *ssl_fips_mode_names[] = {\"OFF\", \"ON\", \"STRICT\", nullptr};\nstatic Sys_var_enum Sys_ssl_fips_mode(\n    \"ssl_fips_mode\",\n    \"SSL FIPS mode (applies only for OpenSSL); \"\n    \"permitted values are: OFF, ON, STRICT\",\n    GLOBAL_VAR(opt_ssl_fips_mode), CMD_LINE(REQUIRED_ARG, OPT_SSL_FIPS_MODE),\n    ssl_fips_mode_names, DEFAULT(0), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n    ON_CHECK(nullptr), ON_UPDATE(update_fips_mode), nullptr);\n\nstatic Sys_var_bool Sys_auto_generate_certs(\n    \"auto_generate_certs\",\n    \"Auto generate SSL certificates at server startup if --ssl is set to \"\n    \"ON and none of the other SSL system variables are specified and \"\n    \"certificate/key files are not present in data directory.\",\n    READ_ONLY NON_PERSIST GLOBAL_VAR(opt_auto_generate_certs),\n    CMD_LINE(OPT_ARG), DEFAULT(true), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n    ON_CHECK(nullptr), ON_UPDATE(nullptr), nullptr);\n\n// why ENUM and not BOOL ?\nstatic const char *updatable_views_with_limit_names[] = {\"NO\", \"YES\", nullptr};\nstatic Sys_var_enum Sys_updatable_views_with_limit(\n    \"updatable_views_with_limit\",\n    \"YES = Don't issue an error message (warning only) if a VIEW without \"\n    \"presence of a key of the underlying table is used in queries with a \"\n    \"LIMIT clause for updating. NO = Prohibit update of a VIEW, which \"\n    \"does not contain a key of the underlying table and the query uses \"\n    \"a LIMIT clause (usually get from GUI tools)\",\n    HINT_UPDATEABLE SESSION_VAR(updatable_views_with_limit),\n    CMD_LINE(REQUIRED_ARG), updatable_views_with_limit_names, DEFAULT(true));\n\nstatic char *system_time_zone_ptr;\nstatic Sys_var_charptr Sys_system_time_zone(\n    \"system_time_zone\", \"The server system time zone\",\n    READ_ONLY NON_PERSIST GLOBAL_VAR(system_time_zone_ptr), NO_CMD_LINE,\n    IN_FS_CHARSET, DEFAULT(system_time_zone));\n\nstatic Sys_var_ulong Sys_table_def_size(\n    \"table_definition_cache\", \"The number of cached table definitions\",\n    GLOBAL_VAR(table_def_size),\n    CMD_LINE(REQUIRED_ARG, OPT_TABLE_DEFINITION_CACHE),\n    VALID_RANGE(TABLE_DEF_CACHE_MIN, 512 * 1024),\n    DEFAULT(TABLE_DEF_CACHE_DEFAULT), BLOCK_SIZE(1), NO_MUTEX_GUARD,\n    NOT_IN_BINLOG, ON_CHECK(nullptr), ON_UPDATE(nullptr), nullptr,\n    /* table_definition_cache is used as a sizing hint by the performance\n       schema. */\n    sys_var::PARSE_EARLY);\n\nstatic Sys_var_ulong Sys_schema_def_size(\n    \"schema_definition_cache\", \"The number of cached schema definitions\",\n    GLOBAL_VAR(schema_def_size), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(SCHEMA_DEF_CACHE_MIN, 512 * 1024),\n    DEFAULT(SCHEMA_DEF_CACHE_DEFAULT), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_tablespace_def_size(\n    \"tablespace_definition_cache\",\n    \"The number of cached tablespace definitions\",\n    GLOBAL_VAR(tablespace_def_size), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(TABLESPACE_DEF_CACHE_MIN, 512 * 1024),\n    DEFAULT(TABLESPACE_DEF_CACHE_DEFAULT), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_stored_program_def_size(\n    \"stored_program_definition_cache\",\n    \"The number of cached stored program definitions\",\n    GLOBAL_VAR(stored_program_def_size), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(STORED_PROGRAM_DEF_CACHE_MIN, 512 * 1024),\n    DEFAULT(STORED_PROGRAM_DEF_CACHE_DEFAULT), BLOCK_SIZE(1));\n\nstatic bool fix_table_cache_size(sys_var *, THD *, enum_var_type) {\n  /*\n    table_open_cache parameter is a soft limit for total number of objects\n    in all table cache instances. Once this value is updated we need to\n    update value of a per-instance soft limit on table cache size.\n  */\n  table_cache_size_per_instance = table_cache_size / table_cache_instances;\n  return false;\n}\n\nstatic Sys_var_ulong Sys_table_cache_size(\n    \"table_open_cache\",\n    \"The number of cached open tables \"\n    \"(total for all table cache instances)\",\n    GLOBAL_VAR(table_cache_size), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(1, 512 * 1024), DEFAULT(TABLE_OPEN_CACHE_DEFAULT),\n    BLOCK_SIZE(1), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(nullptr),\n    ON_UPDATE(fix_table_cache_size), nullptr,\n    /* table_open_cache is used as a sizing hint by the performance schema. */\n    sys_var::PARSE_EARLY);\n\nstatic Sys_var_ulong Sys_table_cache_instances(\n    \"table_open_cache_instances\", \"The number of table cache instances\",\n    READ_ONLY GLOBAL_VAR(table_cache_instances), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(1, Table_cache_manager::MAX_TABLE_CACHES),\n    DEFAULT(Table_cache_manager::DEFAULT_MAX_TABLE_CACHES), BLOCK_SIZE(1),\n    NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(nullptr), ON_UPDATE(nullptr),\n    nullptr,\n    /*\n      table_open_cache is used as a sizing hint by the performance schema,\n      and 'table_open_cache' is a prefix of 'table_open_cache_instances'.\n      Is is better to keep these options together, to avoid confusing\n      handle_options() with partial name matches.\n    */\n    sys_var::PARSE_EARLY);\n\n/**\n  Modify the thread size cache size.\n*/\n\nstatic inline bool modify_thread_cache_size(sys_var *, THD *, enum_var_type) {\n  if (Connection_handler_manager::thread_handling ==\n      Connection_handler_manager::SCHEDULER_ONE_THREAD_PER_CONNECTION) {\n    Per_thread_connection_handler::modify_thread_cache_size(\n        Per_thread_connection_handler::max_blocked_pthreads);\n  }\n  return false;\n}\n\nstatic Sys_var_ulong Sys_thread_cache_size(\n    \"thread_cache_size\", \"How many threads we should keep in a cache for reuse\",\n    GLOBAL_VAR(Per_thread_connection_handler::max_blocked_pthreads),\n    CMD_LINE(REQUIRED_ARG, OPT_THREAD_CACHE_SIZE), VALID_RANGE(0, 16384),\n    DEFAULT(0), BLOCK_SIZE(1), NO_MUTEX_GUARD, NOT_IN_BINLOG, nullptr,\n    ON_UPDATE(modify_thread_cache_size));\n\n#ifdef HAVE_POOL_OF_THREADS\n\nstatic bool fix_tp_max_threads(sys_var *, THD *, enum_var_type) noexcept {\n#ifdef _WIN32\n  tp_set_max_threads(threadpool_max_threads);\n#endif\n  return false;\n}\n\n#ifdef _WIN32\nstatic bool fix_tp_min_threads(sys_var *, THD *, enum_var_type) noexcept {\n  tp_set_min_threads(threadpool_min_threads);\n  return false;\n}\n#endif\n\n#ifndef _WIN32\nstatic bool fix_threadpool_size(sys_var *, THD *, enum_var_type) noexcept {\n  tp_set_threadpool_size(threadpool_size);\n  return false;\n}\n\nstatic bool fix_threadpool_stall_limit(sys_var *, THD *,\n                                       enum_var_type) noexcept {\n  tp_set_threadpool_stall_limit(threadpool_stall_limit);\n  return false;\n}\n#endif\n\nstatic inline int my_getncpus() noexcept {\n#ifdef _SC_NPROCESSORS_ONLN\n  return sysconf(_SC_NPROCESSORS_ONLN);\n#else\n  return 2; /* The value returned by the old my_getncpus implementation */\n#endif\n}\n\n#ifdef _WIN32\nstatic Sys_var_uint Sys_threadpool_min_threads(\n    \"thread_pool_min_threads\", \"Minimum number of threads in the thread pool.\",\n    GLOBAL_VAR(threadpool_min_threads), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(1, 256), DEFAULT(1), BLOCK_SIZE(1), NO_MUTEX_GUARD,\n    NOT_IN_BINLOG, ON_CHECK(nullptr), ON_UPDATE(fix_tp_min_threads));\n#else\nstatic Sys_var_uint Sys_threadpool_idle_thread_timeout(\n    \"thread_pool_idle_timeout\",\n    \"Timeout in seconds for an idle thread in the thread pool.\"\n    \"Worker thread will be shut down after timeout\",\n    GLOBAL_VAR(threadpool_idle_timeout), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(1, UINT_MAX), DEFAULT(60), BLOCK_SIZE(1));\nstatic Sys_var_uint Sys_threadpool_oversubscribe(\n    \"thread_pool_oversubscribe\",\n    \"How many additional active worker threads in a group are allowed.\",\n    GLOBAL_VAR(threadpool_oversubscribe), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(1, 1000), DEFAULT(3), BLOCK_SIZE(1));\nstatic Sys_var_uint Sys_threadpool_size(\n    \"thread_pool_size\",\n    \"Number of thread groups in the pool. \"\n    \"This parameter is roughly equivalent to maximum number of concurrently \"\n    \"executing threads (threads in a waiting state do not count as executing).\",\n    GLOBAL_VAR(threadpool_size), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(1, MAX_THREAD_GROUPS), DEFAULT(my_getncpus()), BLOCK_SIZE(1),\n    NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(nullptr),\n    ON_UPDATE(fix_threadpool_size));\nstatic Sys_var_uint Sys_threadpool_stall_limit(\n    \"thread_pool_stall_limit\",\n    \"Maximum query execution time in milliseconds,\"\n    \"before an executing non-yielding thread is considered stalled.\"\n    \"If a worker thread is stalled, additional worker thread \"\n    \"may be created to handle remaining clients.\",\n    GLOBAL_VAR(threadpool_stall_limit), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(10, UINT_MAX), DEFAULT(500), BLOCK_SIZE(1), NO_MUTEX_GUARD,\n    NOT_IN_BINLOG, ON_CHECK(nullptr), ON_UPDATE(fix_threadpool_stall_limit));\nstatic Sys_var_uint Sys_threadpool_high_prio_tickets(\n    \"thread_pool_high_prio_tickets\",\n    \"Number of tickets to enter the high priority event queue for each \"\n    \"transaction.\",\n    SESSION_VAR(threadpool_high_prio_tickets), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(0, UINT_MAX), DEFAULT(UINT_MAX), BLOCK_SIZE(1));\n\nstatic Sys_var_enum Sys_threadpool_high_prio_mode(\n    \"thread_pool_high_prio_mode\",\n    \"High priority queue mode: one of 'transactions', 'statements' or 'none'. \"\n    \"In the 'transactions' mode the thread pool uses both high- and \"\n    \"low-priority \"\n    \"queues depending on whether an event is generated by an already started \"\n    \"transaction or a connection holding a MDL, table, user, or a global read \"\n    \"or backup lock and whether it has any high priority tickets (see \"\n    \"thread_pool_high_prio_tickets). In the 'statements' mode all events (i.e. \"\n    \"individual statements) always go to the high priority queue, regardless \"\n    \"of \"\n    \"the current transaction and lock state and high priority tickets. \"\n    \"'none' is the opposite of 'statements', i.e. disables the high priority \"\n    \"queue \"\n    \"completely.\",\n    SESSION_VAR(threadpool_high_prio_mode), CMD_LINE(REQUIRED_ARG),\n    threadpool_high_prio_mode_names, DEFAULT(TP_HIGH_PRIO_MODE_TRANSACTIONS));\n\n#endif /* !WIN32 */\nstatic Sys_var_uint Sys_threadpool_max_threads(\n    \"thread_pool_max_threads\",\n    \"Maximum allowed number of worker threads in the thread pool\",\n    GLOBAL_VAR(threadpool_max_threads), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(1, MAX_CONNECTIONS), DEFAULT(MAX_CONNECTIONS), BLOCK_SIZE(1),\n    NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(nullptr),\n    ON_UPDATE(fix_tp_max_threads));\n#endif /* HAVE_POOL_OF_THREADS */\n\n/**\n  Function to check if the 'next' transaction isolation level\n  can be changed.\n\n  @param[in] thd    Thread handler.\n  @param[in] var    A pointer to set_var holding the specified list of\n                    system variable names.\n\n  @retval   false   Success.\n  @retval   true    Error.\n*/\nstatic bool check_transaction_isolation(sys_var *, THD *thd, set_var *var) {\n  if (var->type == OPT_DEFAULT &&\n      (thd->in_active_multi_stmt_transaction() || thd->in_sub_stmt)) {\n    DBUG_ASSERT(thd->in_multi_stmt_transaction_mode() || thd->in_sub_stmt);\n    my_error(ER_CANT_CHANGE_TX_CHARACTERISTICS, MYF(0));\n    return true;\n  }\n  return false;\n}\n\n/**\n  This function sets the session variable thd->variables.transaction_isolation\n  to reflect changes to @@session.transaction_isolation.\n\n  @param[in] thd    Thread handler.\n  @param[in] var    A pointer to the set_var.\n\n  @retval   false   Success.\n  @retval   true    Error.\n*/\nbool Sys_var_transaction_isolation::session_update(THD *thd, set_var *var) {\n  if (var->type == OPT_SESSION && Sys_var_enum::session_update(thd, var))\n    return true;\n  if (var->type == OPT_DEFAULT ||\n      !(thd->in_active_multi_stmt_transaction() || thd->in_sub_stmt)) {\n    /*\n      Update the isolation level of the next transaction.\n      I.e. if one did:\n      COMMIT;\n      SET SESSION ISOLATION LEVEL ...\n      BEGIN; <-- this transaction has the new isolation\n      Note, that in case of:\n      COMMIT;\n      SET TRANSACTION ISOLATION LEVEL ...\n      SET SESSION ISOLATION LEVEL ...\n      BEGIN; <-- the session isolation level is used, not the\n      result of SET TRANSACTION statement.\n\n      When we are in a trigger/function the transaction is already\n      started. Adhering to above behavior, the SET TRANSACTION would\n      fail when run from within trigger/function. And SET SESSION\n      TRANSACTION would always succeed making the characteristics\n      effective for the next transaction that starts.\n     */\n    enum_tx_isolation tx_isol;\n    tx_isol = (enum_tx_isolation)var->save_result.ulonglong_value;\n    bool one_shot = (var->type == OPT_DEFAULT);\n    return set_tx_isolation(thd, tx_isol, one_shot);\n  }\n  return false;\n}\n\n// NO_CMD_LINE\nstatic Sys_var_transaction_isolation Sys_transaction_isolation(\n    \"transaction_isolation\", \"Default transaction isolation level\",\n    UNTRACKED_DEFAULT SESSION_VAR(transaction_isolation), NO_CMD_LINE,\n    tx_isolation_names, DEFAULT(ISO_REPEATABLE_READ), NO_MUTEX_GUARD,\n    NOT_IN_BINLOG, ON_CHECK(check_transaction_isolation));\n\n/**\n  Function to check if the state of 'transaction_read_only' can be changed.\n  The state cannot be changed if there is already a transaction in progress.\n\n  @param[in] thd    Thread handler\n  @param[in] var    A pointer to set_var holding the specified list of\n                    system variable names.\n\n  @retval   false   Success.\n  @retval   true    Error.\n*/\nstatic bool check_transaction_read_only(sys_var *, THD *thd, set_var *var) {\n  if (var->type == OPT_DEFAULT &&\n      (thd->in_active_multi_stmt_transaction() || thd->in_sub_stmt)) {\n    DBUG_ASSERT(thd->in_multi_stmt_transaction_mode() || thd->in_sub_stmt);\n    my_error(ER_CANT_CHANGE_TX_CHARACTERISTICS, MYF(0));\n    return true;\n  }\n  return false;\n}\n\n/**\n  This function sets the session variable thd->variables.transaction_read_only\n  to reflect changes to @@session.transaction_read_only.\n\n  @param[in] thd    Thread handler.\n  @param[in] var    A pointer to the set_var.\n\n  @retval   false   Success.\n*/\nbool Sys_var_transaction_read_only::session_update(THD *thd, set_var *var) {\n  if (var->type == OPT_SESSION && Sys_var_bool::session_update(thd, var))\n    return true;\n  if (var->type == OPT_DEFAULT ||\n      !(thd->in_active_multi_stmt_transaction() || thd->in_sub_stmt)) {\n    // @see Sys_var_transaction_isolation::session_update() above for the\n    // rules.\n    thd->tx_read_only = var->save_result.ulonglong_value;\n\n    if (thd->variables.session_track_transaction_info > TX_TRACK_NONE) {\n      TX_TRACKER_GET(tst);\n\n      if (var->type == OPT_DEFAULT)\n        tst->set_read_flags(thd,\n                            thd->tx_read_only ? TX_READ_ONLY : TX_READ_WRITE);\n      else\n        tst->set_read_flags(thd, TX_READ_INHERIT);\n    }\n  }\n  return false;\n}\n\nstatic Sys_var_transaction_read_only Sys_transaction_read_only(\n    \"transaction_read_only\",\n    \"Set default transaction access mode to read only.\",\n    UNTRACKED_DEFAULT SESSION_VAR(transaction_read_only), NO_CMD_LINE,\n    DEFAULT(0), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n    ON_CHECK(check_transaction_read_only));\n\nstatic Sys_var_ulonglong Sys_tmp_table_size(\n    \"tmp_table_size\",\n    \"If an internal in-memory temporary table in the MEMORY storage engine \"\n    \"exceeds this size, MySQL will automatically convert it to an on-disk \"\n    \"table\",\n    HINT_UPDATEABLE SESSION_VAR(tmp_table_size), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(1024, (ulonglong) ~(intptr)0), DEFAULT(16 * 1024 * 1024),\n    BLOCK_SIZE(1));\n\nstatic char *server_version_ptr;\nstatic Sys_var_version Sys_version(\n    \"version\", \"Server version\",\n    READ_ONLY NON_PERSIST GLOBAL_VAR(server_version_ptr), NO_CMD_LINE,\n    IN_SYSTEM_CHARSET, DEFAULT(MYSQL_SERVER_VERSION));\n\nstatic char *server_version_suffix_ptr;\nstatic Sys_var_charptr Sys_version_suffix(\"version_suffix\", \"version_suffix\",\n                                          GLOBAL_VAR(server_version_suffix_ptr),\n                                          NO_CMD_LINE, IN_SYSTEM_CHARSET,\n                                          DEFAULT(server_version_suffix));\n\nstatic char *server_version_comment_ptr;\nstatic Sys_var_charptr Sys_version_comment(\n    \"version_comment\", \"version_comment\",\n    GLOBAL_VAR(server_version_comment_ptr), NO_CMD_LINE, IN_SYSTEM_CHARSET,\n    DEFAULT(MYSQL_COMPILATION_COMMENT_SERVER));\n\nstatic char *server_version_compile_machine_ptr;\nstatic Sys_var_charptr Sys_version_compile_machine(\n    \"version_compile_machine\", \"version_compile_machine\",\n    READ_ONLY NON_PERSIST GLOBAL_VAR(server_version_compile_machine_ptr),\n    NO_CMD_LINE, IN_SYSTEM_CHARSET, DEFAULT(MACHINE_TYPE));\n\nstatic char *server_version_compile_os_ptr;\nstatic Sys_var_charptr Sys_version_compile_os(\n    \"version_compile_os\", \"version_compile_os\",\n    READ_ONLY NON_PERSIST GLOBAL_VAR(server_version_compile_os_ptr),\n    NO_CMD_LINE, IN_SYSTEM_CHARSET, DEFAULT(SYSTEM_TYPE));\n\nstatic const char *server_version_compile_zlib_ptr = ZLIB_VERSION;\nstatic Sys_var_charptr Sys_version_compile_zlib(\n    \"version_compile_zlib\", \"version_compile_zlib\",\n    READ_ONLY NON_PERSIST GLOBAL_VAR(server_version_compile_zlib_ptr),\n    NO_CMD_LINE, IN_SYSTEM_CHARSET, DEFAULT(ZLIB_VERSION));\n\nstatic Sys_var_ulong Sys_net_wait_timeout(\n    \"wait_timeout\",\n    \"The number of seconds the server waits for activity on a \"\n    \"connection before closing it\",\n    SESSION_VAR(net_wait_timeout), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(1, IF_WIN(INT_MAX32 / 1000, LONG_TIMEOUT)),\n    DEFAULT(NET_WAIT_TIMEOUT), BLOCK_SIZE(1));\n\nstatic Sys_var_plugin Sys_default_storage_engine(\n    \"default_storage_engine\", \"The default storage engine for new tables\",\n    SESSION_VAR(table_plugin), NO_CMD_LINE, MYSQL_STORAGE_ENGINE_PLUGIN,\n    DEFAULT(&default_storage_engine), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n    ON_CHECK(check_storage_engine));\n\nconst char *internal_tmp_mem_storage_engine_names[] = {\"MEMORY\", \"TempTable\",\n                                                       nullptr};\nstatic Sys_var_enum Sys_internal_tmp_mem_storage_engine(\n    \"internal_tmp_mem_storage_engine\",\n    \"The default storage engine for in-memory internal temporary tables.\",\n    HINT_UPDATEABLE SESSION_VAR(internal_tmp_mem_storage_engine),\n    CMD_LINE(REQUIRED_ARG), internal_tmp_mem_storage_engine_names,\n    DEFAULT(TMP_TABLE_TEMPTABLE));\n\nstatic Sys_var_ulonglong Sys_temptable_max_ram(\n    \"temptable_max_ram\",\n    \"Maximum amount of memory (in bytes) the TempTable storage engine is \"\n    \"allowed to allocate from the main memory (RAM) before starting to \"\n    \"store data on disk.\",\n    GLOBAL_VAR(temptable_max_ram), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(2 << 20 /* 2 MiB */, ULLONG_MAX), DEFAULT(1 << 30 /* 1 GiB */),\n    BLOCK_SIZE(1));\n\nstatic Sys_var_bool Sys_temptable_use_mmap(\"temptable_use_mmap\",\n                                           \"Use mmap files for temptables\",\n                                           GLOBAL_VAR(temptable_use_mmap),\n                                           CMD_LINE(OPT_ARG), DEFAULT(true));\n\nstatic Sys_var_plugin Sys_default_tmp_storage_engine(\n    \"default_tmp_storage_engine\",\n    \"The default storage engine for new explicit temporary tables\",\n    HINT_UPDATEABLE SESSION_VAR(temp_table_plugin), NO_CMD_LINE,\n    MYSQL_STORAGE_ENGINE_PLUGIN, DEFAULT(&default_tmp_storage_engine),\n    NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(check_storage_engine));\n\nstatic Sys_var_charptr Sys_enforce_storage_engine(\n    \"enforce_storage_engine\",\n    \"Force the use of a storage engine for new tables\",\n    READ_ONLY GLOBAL_VAR(enforce_storage_engine), CMD_LINE(REQUIRED_ARG),\n    IN_SYSTEM_CHARSET, DEFAULT(nullptr));\n\n#if defined(ENABLED_DEBUG_SYNC)\n/*\n  Variable can be set for the session only.\n\n  This could be changed later. Then we need to have a global array of\n  actions in addition to the thread local ones. SET GLOBAL would\n  manage the global array, SET [SESSION] the local array. A sync point\n  would need to look for a local and a global action. Setting and\n  executing of global actions need to be protected by a mutex.\n\n  The purpose of global actions could be to allow synchronizing with\n  connectionless threads that cannot execute SET statements.\n*/\nstatic Sys_var_debug_sync Sys_debug_sync(\"debug_sync\", \"Debug Sync Facility\",\n                                         sys_var::ONLY_SESSION, NO_CMD_LINE,\n                                         DEFAULT(nullptr), NO_MUTEX_GUARD,\n                                         NOT_IN_BINLOG,\n                                         ON_CHECK(check_session_admin));\n#endif /* defined(ENABLED_DEBUG_SYNC) */\n\nstatic bool fix_autocommit(sys_var *self, THD *thd, enum_var_type type) {\n  if (self->is_global_persist(type)) {\n    if (global_system_variables.option_bits & OPTION_AUTOCOMMIT)\n      global_system_variables.option_bits &= ~OPTION_NOT_AUTOCOMMIT;\n    else\n      global_system_variables.option_bits |= OPTION_NOT_AUTOCOMMIT;\n    return false;\n  }\n\n  if (thd->variables.option_bits & OPTION_AUTOCOMMIT &&\n      thd->variables.option_bits &\n          OPTION_NOT_AUTOCOMMIT) {  // activating autocommit\n\n    if (trans_commit_stmt(thd) || trans_commit(thd)) {\n      thd->variables.option_bits &= ~OPTION_AUTOCOMMIT;\n      return true;\n    }\n    /*\n      Don't close thread tables or release metadata locks: if we do so, we\n      risk releasing locks/closing tables of expressions used to assign\n      other variables, as in:\n      set @var=my_stored_function1(), @@autocommit=1, @var2=(select max(a)\n      from my_table), ...\n      The locks will be released at statement end anyway, as SET\n      statement that assigns autocommit is marked to commit\n      transaction implicitly at the end (@sa stmt_causes_implicitcommit()).\n    */\n    thd->variables.option_bits &= ~(OPTION_BEGIN | OPTION_NOT_AUTOCOMMIT);\n    thd->get_transaction()->reset_unsafe_rollback_flags(\n        Transaction_ctx::SESSION);\n    thd->server_status |= SERVER_STATUS_AUTOCOMMIT;\n    return false;\n  }\n\n  if (!(thd->variables.option_bits & OPTION_AUTOCOMMIT) &&\n      !(thd->variables.option_bits &\n        OPTION_NOT_AUTOCOMMIT)) {  // disabling autocommit\n\n    thd->get_transaction()->reset_unsafe_rollback_flags(\n        Transaction_ctx::SESSION);\n    thd->server_status &= ~SERVER_STATUS_AUTOCOMMIT;\n    thd->variables.option_bits |= OPTION_NOT_AUTOCOMMIT;\n    return false;\n  }\n\n  return false;  // autocommit value wasn't changed\n}\nstatic Sys_var_bit Sys_autocommit(\"autocommit\", \"autocommit\",\n                                  SESSION_VAR(option_bits), NO_CMD_LINE,\n                                  OPTION_AUTOCOMMIT, DEFAULT(true),\n                                  NO_MUTEX_GUARD, NOT_IN_BINLOG,\n                                  ON_CHECK(nullptr), ON_UPDATE(fix_autocommit));\nexport sys_var *Sys_autocommit_ptr = &Sys_autocommit;  // for sql_yacc.yy\n\nstatic Sys_var_bool Sys_big_tables(\n    \"big_tables\",\n    \"Allow big result sets by saving all \"\n    \"temporary sets on file (Solves most 'table full' errors)\",\n    HINT_UPDATEABLE SESSION_VAR(big_tables), CMD_LINE(OPT_ARG), DEFAULT(false));\n\nstatic Sys_var_bit Sys_big_selects(\"sql_big_selects\", \"sql_big_selects\",\n                                   HINT_UPDATEABLE SESSION_VAR(option_bits),\n                                   NO_CMD_LINE, OPTION_BIG_SELECTS,\n                                   DEFAULT(false));\n\nstatic Sys_var_bit Sys_log_off(\"sql_log_off\", \"sql_log_off\",\n                               SESSION_VAR(option_bits), NO_CMD_LINE,\n                               OPTION_LOG_OFF, DEFAULT(false), NO_MUTEX_GUARD,\n                               NOT_IN_BINLOG, ON_CHECK(check_session_admin));\n\n/**\n  This function sets the session variable thd->variables.sql_log_bin\n  to reflect changes to @@session.sql_log_bin.\n\n  @param     thd    Current thread\n  @param[in] type   The type either session or global.\n\n  @return @c false.\n*/\nstatic bool fix_sql_log_bin_after_update(\n    sys_var *, THD *thd, enum_var_type type MY_ATTRIBUTE((unused))) {\n  DBUG_ASSERT(type == OPT_SESSION);\n\n  if (thd->variables.sql_log_bin)\n    thd->variables.option_bits |= OPTION_BIN_LOG;\n  else\n    thd->variables.option_bits &= ~OPTION_BIN_LOG;\n\n  return false;\n}\n\n/**\n  This function checks if the sql_log_bin can be changed,\n  what is possible if:\n    - the user is a super user;\n    - the set is not called from within a function/trigger;\n    - there is no on-going transaction.\n\n  @param     thd    Current thread\n  @param[in] self   A pointer to the sys_var, i.e. Sys_log_binlog.\n  @param[in] var    A pointer to the set_var created by the parser.\n\n  @return @c false if the change is allowed, otherwise @c true.\n*/\nstatic bool check_sql_log_bin(sys_var *self, THD *thd, set_var *var) {\n  if (check_session_admin(self, thd, var)) return true;\n\n  if (var->is_global_persist()) return true;\n\n  /* If in a stored function/trigger, it's too late to change sql_log_bin. */\n  if (thd->in_sub_stmt) {\n    my_error(ER_STORED_FUNCTION_PREVENTS_SWITCH_SQL_LOG_BIN, MYF(0));\n    return true;\n  }\n  /* Make the session variable 'sql_log_bin' read-only inside a transaction.\n   */\n  if (thd->in_active_multi_stmt_transaction()) {\n    my_error(ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_SQL_LOG_BIN, MYF(0));\n    return true;\n  }\n\n  return false;\n}\n\nstatic Sys_var_bool Sys_log_binlog(\n    \"sql_log_bin\", \"Controls whether logging to the binary log is done\",\n    SESSION_ONLY(sql_log_bin), NO_CMD_LINE, DEFAULT(true), NO_MUTEX_GUARD,\n    NOT_IN_BINLOG, ON_CHECK(check_sql_log_bin),\n    ON_UPDATE(fix_sql_log_bin_after_update));\n\nstatic Sys_var_bit Sys_transaction_allow_batching(\n    \"transaction_allow_batching\", \"transaction_allow_batching\",\n    SESSION_ONLY(option_bits), NO_CMD_LINE, OPTION_ALLOW_BATCH, DEFAULT(false));\n\nstatic Sys_var_bit Sys_sql_warnings(\"sql_warnings\", \"sql_warnings\",\n                                    SESSION_VAR(option_bits), NO_CMD_LINE,\n                                    OPTION_WARNINGS, DEFAULT(false));\n\nstatic Sys_var_bit Sys_sql_notes(\"sql_notes\", \"sql_notes\",\n                                 SESSION_VAR(option_bits), NO_CMD_LINE,\n                                 OPTION_SQL_NOTES, DEFAULT(true));\n\nstatic Sys_var_bit Sys_auto_is_null(\"sql_auto_is_null\", \"sql_auto_is_null\",\n                                    HINT_UPDATEABLE SESSION_VAR(option_bits),\n                                    NO_CMD_LINE, OPTION_AUTO_IS_NULL,\n                                    DEFAULT(false), NO_MUTEX_GUARD, IN_BINLOG);\n\nstatic Sys_var_bit Sys_safe_updates(\"sql_safe_updates\", \"sql_safe_updates\",\n                                    HINT_UPDATEABLE SESSION_VAR(option_bits),\n                                    NO_CMD_LINE, OPTION_SAFE_UPDATES,\n                                    DEFAULT(false));\n\nstatic Sys_var_bit Sys_buffer_results(\"sql_buffer_result\", \"sql_buffer_result\",\n                                      HINT_UPDATEABLE SESSION_VAR(option_bits),\n                                      NO_CMD_LINE, OPTION_BUFFER_RESULT,\n                                      DEFAULT(false));\n\nstatic Sys_var_bit Sys_quote_show_create(\"sql_quote_show_create\",\n                                         \"sql_quote_show_create\",\n                                         SESSION_VAR(option_bits), NO_CMD_LINE,\n                                         OPTION_QUOTE_SHOW_CREATE,\n                                         DEFAULT(true));\n\nstatic Sys_var_bit Sys_foreign_key_checks(\n    \"foreign_key_checks\", \"foreign_key_checks\",\n    HINT_UPDATEABLE SESSION_VAR(option_bits), NO_CMD_LINE,\n    REVERSE(OPTION_NO_FOREIGN_KEY_CHECKS), DEFAULT(true), NO_MUTEX_GUARD,\n    IN_BINLOG);\n\nstatic Sys_var_bit Sys_unique_checks(\"unique_checks\", \"unique_checks\",\n                                     HINT_UPDATEABLE SESSION_VAR(option_bits),\n                                     NO_CMD_LINE,\n                                     REVERSE(OPTION_RELAXED_UNIQUE_CHECKS),\n                                     DEFAULT(true), NO_MUTEX_GUARD, IN_BINLOG);\n\n#ifdef ENABLED_PROFILING\nstatic Sys_var_bit Sys_profiling(\"profiling\", \"profiling\",\n                                 SESSION_VAR(option_bits), NO_CMD_LINE,\n                                 OPTION_PROFILING, DEFAULT(false),\n                                 NO_MUTEX_GUARD, NOT_IN_BINLOG,\n                                 ON_CHECK(nullptr), ON_UPDATE(nullptr),\n                                 DEPRECATED_VAR(\"\"));\n\nstatic Sys_var_ulong Sys_profiling_history_size(\n    \"profiling_history_size\", \"Limit of query profiling memory\",\n    SESSION_VAR(profiling_history_size), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(0, 100), DEFAULT(15), BLOCK_SIZE(1), NO_MUTEX_GUARD,\n    NOT_IN_BINLOG, ON_CHECK(nullptr), ON_UPDATE(nullptr), DEPRECATED_VAR(\"\"));\n#endif\n\nstatic Sys_var_harows Sys_select_limit(\n    \"sql_select_limit\",\n    \"The maximum number of rows to return from SELECT statements\",\n    HINT_UPDATEABLE SESSION_VAR(select_limit), NO_CMD_LINE,\n    VALID_RANGE(0, HA_POS_ERROR), DEFAULT(HA_POS_ERROR), BLOCK_SIZE(1));\n\nstatic bool update_timestamp(THD *thd, set_var *var) {\n  if (var->value) {\n    double intpart;\n    double fractpart = modf(var->save_result.double_value, &intpart);\n    double micros = fractpart * 1000000.0;\n    // Double multiplication, and conversion to integral may yield\n    // 1000000 rather than 999999.\n    struct timeval tmp;\n    tmp.tv_sec = llrint(intpart);\n    tmp.tv_usec = std::min(llrint(micros), 999999LL);\n    thd->set_time(&tmp);\n  } else  // SET timestamp=DEFAULT\n  {\n    thd->user_time.tv_sec = 0;\n    thd->user_time.tv_usec = 0;\n  }\n  return false;\n}\nstatic double read_timestamp(THD *thd) {\n  return (double)thd->start_time.tv_sec +\n         (double)thd->start_time.tv_usec / 1000000;\n}\n\nstatic bool check_timestamp(sys_var *, THD *, set_var *var) {\n  double val;\n\n  if (!var->value) return false;\n\n  val = var->save_result.double_value;\n  if (val != 0 &&  // this is how you set the default value\n      (val < TIMESTAMP_MIN_VALUE || val > TIMESTAMP_MAX_VALUE)) {\n    ErrConvString prm(val);\n    my_error(ER_WRONG_VALUE_FOR_VAR, MYF(0), \"timestamp\", prm.ptr());\n    return true;\n  }\n  return false;\n}\n\nstatic Sys_var_session_special_double Sys_timestamp(\n    \"timestamp\", \"Set the time for this client\",\n    HINT_UPDATEABLE sys_var::ONLY_SESSION, NO_CMD_LINE, VALID_RANGE(0, 0),\n    BLOCK_SIZE(1), NO_MUTEX_GUARD, IN_BINLOG, ON_CHECK(check_timestamp),\n    ON_UPDATE(update_timestamp), ON_READ(read_timestamp));\n\nstatic bool update_last_insert_id(THD *thd, set_var *var) {\n  if (!var->value) {\n    my_error(ER_NO_DEFAULT, MYF(0), var->var->name.str);\n    return true;\n  }\n  thd->first_successful_insert_id_in_prev_stmt =\n      var->save_result.ulonglong_value;\n  return false;\n}\nstatic ulonglong read_last_insert_id(THD *thd) {\n  return thd->read_first_successful_insert_id_in_prev_stmt();\n}\nstatic Sys_var_session_special Sys_last_insert_id(\n    \"last_insert_id\", \"The value to be returned from LAST_INSERT_ID()\",\n    sys_var::ONLY_SESSION, NO_CMD_LINE, VALID_RANGE(0, ULLONG_MAX),\n    BLOCK_SIZE(1), NO_MUTEX_GUARD, IN_BINLOG, ON_CHECK(nullptr),\n    ON_UPDATE(update_last_insert_id), ON_READ(read_last_insert_id));\n\n// alias for last_insert_id(), Sybase-style\nstatic Sys_var_session_special Sys_identity(\n    \"identity\", \"Synonym for the last_insert_id variable\",\n    sys_var::ONLY_SESSION, NO_CMD_LINE, VALID_RANGE(0, ULLONG_MAX),\n    BLOCK_SIZE(1), NO_MUTEX_GUARD, IN_BINLOG, ON_CHECK(nullptr),\n    ON_UPDATE(update_last_insert_id), ON_READ(read_last_insert_id));\n\n/*\n  insert_id should *not* be marked as written to the binlog (i.e., it\n  should *not* be IN_BINLOG), because we want any statement that\n  refers to insert_id explicitly to be unsafe.  (By \"explicitly\", we\n  mean using @@session.insert_id, whereas insert_id is used\n  \"implicitly\" when NULL value is inserted into an auto_increment\n  column).\n\n  We want statements referring explicitly to @@session.insert_id to be\n  unsafe, because insert_id is modified internally by the slave sql\n  thread when NULL values are inserted in an AUTO_INCREMENT column.\n  This modification interfers with the value of the\n  @@session.insert_id variable if @@session.insert_id is referred\n  explicitly by an insert statement (as is seen by executing \"SET\n  @@session.insert_id=0; CREATE TABLE t (a INT, b INT KEY\n  AUTO_INCREMENT); INSERT INTO t(a) VALUES (@@session.insert_id);\" in\n  statement-based logging mode: t will be different on master and\n  slave).\n*/\nstatic bool update_insert_id(THD *thd, set_var *var) {\n  if (!var->value) {\n    my_error(ER_NO_DEFAULT, MYF(0), var->var->name.str);\n    return true;\n  }\n  thd->force_one_auto_inc_interval(var->save_result.ulonglong_value);\n  return false;\n}\n\nstatic ulonglong read_insert_id(THD *thd) {\n  return thd->auto_inc_intervals_forced.minimum();\n}\nstatic Sys_var_session_special Sys_insert_id(\n    \"insert_id\",\n    \"The value to be used by the following INSERT \"\n    \"or ALTER TABLE statement when inserting an AUTO_INCREMENT value\",\n    HINT_UPDATEABLE sys_var::ONLY_SESSION, NO_CMD_LINE,\n    VALID_RANGE(0, ULLONG_MAX), BLOCK_SIZE(1), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n    ON_CHECK(nullptr), ON_UPDATE(update_insert_id), ON_READ(read_insert_id));\n\nstatic bool update_rand_seed1(THD *thd, set_var *var) {\n  if (!var->value) {\n    my_error(ER_NO_DEFAULT, MYF(0), var->var->name.str);\n    return true;\n  }\n  thd->rand.seed1 = (ulong)var->save_result.ulonglong_value;\n  return false;\n}\nstatic ulonglong read_rand_seed(THD *) { return 0; }\nstatic Sys_var_session_special Sys_rand_seed1(\n    \"rand_seed1\",\n    \"Sets the internal state of the RAND() \"\n    \"generator for replication purposes\",\n    sys_var::ONLY_SESSION, NO_CMD_LINE, VALID_RANGE(0, ULONG_MAX),\n    BLOCK_SIZE(1), NO_MUTEX_GUARD, IN_BINLOG, ON_CHECK(nullptr),\n    ON_UPDATE(update_rand_seed1), ON_READ(read_rand_seed));\n\nstatic bool update_rand_seed2(THD *thd, set_var *var) {\n  if (!var->value) {\n    my_error(ER_NO_DEFAULT, MYF(0), var->var->name.str);\n    return true;\n  }\n  thd->rand.seed2 = (ulong)var->save_result.ulonglong_value;\n  return false;\n}\nstatic Sys_var_session_special Sys_rand_seed2(\n    \"rand_seed2\",\n    \"Sets the internal state of the RAND() \"\n    \"generator for replication purposes\",\n    sys_var::ONLY_SESSION, NO_CMD_LINE, VALID_RANGE(0, ULONG_MAX),\n    BLOCK_SIZE(1), NO_MUTEX_GUARD, IN_BINLOG, ON_CHECK(nullptr),\n    ON_UPDATE(update_rand_seed2), ON_READ(read_rand_seed));\n\nstatic ulonglong read_error_count(THD *thd) {\n  return thd->get_stmt_da()->error_count(thd);\n}\n// this really belongs to the SHOW STATUS\nstatic Sys_var_session_special Sys_error_count(\n    \"error_count\",\n    \"The number of errors that resulted from the \"\n    \"last statement that generated messages\",\n    READ_ONLY sys_var::ONLY_SESSION, NO_CMD_LINE, VALID_RANGE(0, ULLONG_MAX),\n    BLOCK_SIZE(1), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(nullptr),\n    ON_UPDATE(nullptr), ON_READ(read_error_count));\n\nstatic ulonglong read_warning_count(THD *thd) {\n  return thd->get_stmt_da()->warn_count(thd);\n}\n// this really belongs to the SHOW STATUS\nstatic Sys_var_session_special Sys_warning_count(\n    \"warning_count\",\n    \"The number of errors, warnings, and notes \"\n    \"that resulted from the last statement that generated messages\",\n    READ_ONLY sys_var::ONLY_SESSION, NO_CMD_LINE, VALID_RANGE(0, ULLONG_MAX),\n    BLOCK_SIZE(1), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(nullptr),\n    ON_UPDATE(nullptr), ON_READ(read_warning_count));\n\nstatic Sys_var_ulong Sys_default_week_format(\n    \"default_week_format\", \"The default week format used by WEEK() functions\",\n    HINT_UPDATEABLE SESSION_VAR(default_week_format), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(0, 7), DEFAULT(0), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_group_concat_max_len(\n    \"group_concat_max_len\",\n    \"The maximum length of the result of function  GROUP_CONCAT()\",\n    HINT_UPDATEABLE SESSION_VAR(group_concat_max_len), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(4, ULONG_MAX), DEFAULT(1024), BLOCK_SIZE(1));\n\nstatic char *glob_hostname_ptr;\nstatic Sys_var_charptr Sys_hostname(\n    \"hostname\", \"Server host name\",\n    READ_ONLY NON_PERSIST GLOBAL_VAR(glob_hostname_ptr), NO_CMD_LINE,\n    IN_FS_CHARSET, DEFAULT(glob_hostname));\n\nstatic Sys_var_charptr Sys_repl_report_host(\n    \"report_host\",\n    \"Hostname or IP of the slave to be reported to the master during \"\n    \"slave registration. Will appear in the output of SHOW SLAVE HOSTS. \"\n    \"Leave unset if you do not want the slave to register itself with the \"\n    \"master. Note that it is not sufficient for the master to simply read \"\n    \"the IP of the slave off the socket once the slave connects. Due to \"\n    \"NAT and other routing issues, that IP may not be valid for connecting \"\n    \"to the slave from the master or other hosts\",\n    READ_ONLY GLOBAL_VAR(report_host), CMD_LINE(REQUIRED_ARG), IN_FS_CHARSET,\n    DEFAULT(nullptr));\n\nstatic Sys_var_charptr Sys_repl_report_user(\n    \"report_user\",\n    \"The account user name of the slave to be reported to the master \"\n    \"during slave registration\",\n    READ_ONLY GLOBAL_VAR(report_user), CMD_LINE(REQUIRED_ARG), IN_FS_CHARSET,\n    DEFAULT(nullptr));\n\nstatic Sys_var_charptr Sys_repl_report_password(\n    \"report_password\",\n    \"The account password of the slave to be reported to the master \"\n    \"during slave registration\",\n    READ_ONLY GLOBAL_VAR(report_password), CMD_LINE(REQUIRED_ARG),\n    IN_FS_CHARSET, DEFAULT(nullptr));\n\nstatic Sys_var_uint Sys_repl_report_port(\n    \"report_port\",\n    \"Port for connecting to slave reported to the master during slave \"\n    \"registration. Set it only if the slave is listening on a non-default \"\n    \"port or if you have a special tunnel from the master or other clients \"\n    \"to the slave. If not sure, leave this option unset\",\n    READ_ONLY GLOBAL_VAR(report_port), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(0, 65535), DEFAULT(0), BLOCK_SIZE(1));\n\nstatic Sys_var_bool Sys_keep_files_on_create(\n    \"keep_files_on_create\",\n    \"Don't overwrite stale .MYD and .MYI even if no directory is specified\",\n    SESSION_VAR(keep_files_on_create), CMD_LINE(OPT_ARG), DEFAULT(false));\n\nstatic char *license;\nstatic Sys_var_charptr Sys_license(\"license\",\n                                   \"The type of license the server has\",\n                                   READ_ONLY NON_PERSIST GLOBAL_VAR(license),\n                                   NO_CMD_LINE, IN_SYSTEM_CHARSET,\n                                   DEFAULT(STRINGIFY_ARG(LICENSE)));\n\nstatic bool check_log_path(sys_var *self, THD *, set_var *var) {\n  if (!var->value) return false;  // DEFAULT is ok\n\n  if (!var->save_result.string_value.str) return true;\n\n  if (!is_valid_log_name(var->save_result.string_value.str,\n                         var->save_result.string_value.length)) {\n    my_error(ER_WRONG_VALUE_FOR_VAR, MYF(0), self->name.str,\n             var->save_result.string_value.str);\n    return true;\n  }\n\n  if (var->save_result.string_value.length > FN_REFLEN) {  // path is too long\n    my_error(ER_PATH_LENGTH, MYF(0), self->name.str);\n    return true;\n  }\n\n  char path[FN_REFLEN];\n  size_t path_length = unpack_filename(path, var->save_result.string_value.str);\n\n  if (!path_length) return true;\n\n  if (!is_filename_allowed(var->save_result.string_value.str,\n                           var->save_result.string_value.length, true)) {\n    my_error(ER_WRONG_VALUE_FOR_VAR, MYF(0), self->name.str,\n             var->save_result.string_value.str);\n    return true;\n  }\n\n  MY_STAT f_stat;\n\n  if (my_stat(path, &f_stat, MYF(0))) {\n    if (!MY_S_ISREG(f_stat.st_mode) || !(f_stat.st_mode & MY_S_IWRITE))\n      return true;  // not a regular writable file\n    return false;\n  }\n\n  (void)dirname_part(path, var->save_result.string_value.str, &path_length);\n\n  if (var->save_result.string_value.length - path_length >=\n      FN_LEN) {  // filename is too long\n    my_error(ER_PATH_LENGTH, MYF(0), self->name.str);\n    return true;\n  }\n\n  if (!path_length)  // no path is good path (remember, relative to datadir)\n    return false;\n\n  if (my_access(path, (F_OK | W_OK))) return true;  // directory is not writable\n\n  return false;\n}\n\nstatic bool fix_general_log_file(sys_var *, THD *, enum_var_type) {\n  bool res;\n\n  if (!opt_general_logname)  // SET ... = DEFAULT\n  {\n    char buff[FN_REFLEN];\n    opt_general_logname = my_strdup(\n        key_memory_LOG_name, make_query_log_name(buff, QUERY_LOG_GENERAL),\n        MYF(MY_FAE + MY_WME));\n    if (!opt_general_logname) return true;\n  }\n\n  res = query_logger.set_log_file(QUERY_LOG_GENERAL);\n\n  if (opt_general_log) {\n    mysql_mutex_unlock(&LOCK_global_system_variables);\n\n    if (!res)\n      res = query_logger.reopen_log_file(QUERY_LOG_GENERAL);\n    else\n      query_logger.deactivate_log_handler(QUERY_LOG_GENERAL);\n\n    mysql_mutex_lock(&LOCK_global_system_variables);\n  }\n\n  if (res) opt_general_log = false;\n\n  return res;\n}\n\nstatic Sys_var_charptr Sys_general_log_path(\n    \"general_log_file\", \"Log connections and queries to given file\",\n    GLOBAL_VAR(opt_general_logname), CMD_LINE(REQUIRED_ARG), IN_FS_CHARSET,\n    DEFAULT(nullptr), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(check_log_path),\n    ON_UPDATE(fix_general_log_file));\n\nstatic bool fix_slow_log_file(sys_var *, THD *thd MY_ATTRIBUTE((unused)),\n                              enum_var_type) {\n  bool res;\n\n  DEBUG_SYNC(thd, \"log_fix_slow_log_holds_sysvar_lock\");\n\n  if (!opt_slow_logname)  // SET ... = DEFAULT\n  {\n    char buff[FN_REFLEN];\n    opt_slow_logname = my_strdup(key_memory_LOG_name,\n                                 make_query_log_name(buff, QUERY_LOG_SLOW),\n                                 MYF(MY_FAE + MY_WME));\n    if (!opt_slow_logname) return true;\n  }\n\n  res = query_logger.set_log_file(QUERY_LOG_SLOW);\n\n  DEBUG_SYNC(thd, \"log_fix_slow_log_released_logger_lock\");\n\n  if (opt_slow_log) {\n    mysql_mutex_unlock(&LOCK_global_system_variables);\n\n    DEBUG_SYNC(thd, \"log_fix_slow_log_released_sysvar_lock\");\n\n    if (!res)\n      res = query_logger.reopen_log_file(QUERY_LOG_SLOW);\n    else\n      query_logger.deactivate_log_handler(QUERY_LOG_SLOW);\n\n    mysql_mutex_lock(&LOCK_global_system_variables);\n  }\n\n  if (res) opt_slow_log = false;\n\n  return res;\n}\nstatic Sys_var_charptr Sys_slow_log_path(\n    \"slow_query_log_file\",\n    \"Log slow queries to given log file. \"\n    \"Defaults logging to hostname-slow.log. Must be enabled to activate \"\n    \"other slow log options\",\n    GLOBAL_VAR(opt_slow_logname), CMD_LINE(REQUIRED_ARG), IN_FS_CHARSET,\n    DEFAULT(nullptr), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(check_log_path),\n    ON_UPDATE(fix_slow_log_file));\n\nstatic Sys_var_have Sys_have_compress(\n    \"have_compress\", \"have_compress\",\n    READ_ONLY NON_PERSIST GLOBAL_VAR(have_compress), NO_CMD_LINE);\n\nstatic Sys_var_have Sys_have_dlopen(\n    \"have_dynamic_loading\", \"have_dynamic_loading\",\n    READ_ONLY NON_PERSIST GLOBAL_VAR(have_dlopen), NO_CMD_LINE);\n\nstatic Sys_var_have Sys_have_geometry(\n    \"have_geometry\", \"have_geometry\",\n    READ_ONLY NON_PERSIST GLOBAL_VAR(have_geometry), NO_CMD_LINE);\n\nstatic SHOW_COMP_OPTION have_ssl_func(THD *thd MY_ATTRIBUTE((unused))) {\n  return SslAcceptorContext::have_ssl() ? SHOW_OPTION_YES\n                                        : SHOW_OPTION_DISABLED;\n}\n\nenum SHOW_COMP_OPTION Sys_var_have_func::dummy_;\n\nstatic Sys_var_have_func Sys_have_openssl(\"have_openssl\", \"have_openssl\",\n                                          have_ssl_func);\n\nstatic Sys_var_have Sys_have_profiling(\n    \"have_profiling\", \"have_profiling\",\n    READ_ONLY NON_PERSIST GLOBAL_VAR(have_profiling), NO_CMD_LINE,\n    NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(nullptr), ON_UPDATE(nullptr),\n    DEPRECATED_VAR(\"\"));\n\nstatic Sys_var_have Sys_have_backup_locks(\n    \"have_backup_locks\", \"have_backup_locks\",\n    READ_ONLY NON_PERSIST GLOBAL_VAR(have_backup_locks), NO_CMD_LINE);\n\nstatic Sys_var_have Sys_have_backup_safe_binlog_info(\n    \"have_backup_safe_binlog_info\", \"have_backup_safe_binlog_info\",\n    READ_ONLY NON_PERSIST GLOBAL_VAR(have_backup_safe_binlog_info),\n    NO_CMD_LINE);\n\nstatic Sys_var_have Sys_have_snapshot_cloning(\n    \"have_snapshot_cloning\", \"have_snapshot_cloning\",\n    READ_ONLY NON_PERSIST GLOBAL_VAR(have_snapshot_cloning), NO_CMD_LINE);\n\nstatic Sys_var_have Sys_have_query_cache(\n    \"have_query_cache\",\n    \"have_query_cache. \"\n    \"This variable is deprecated and will be removed in a future release.\",\n    READ_ONLY NON_PERSIST GLOBAL_VAR(have_query_cache), NO_CMD_LINE,\n    NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(nullptr), ON_UPDATE(nullptr),\n    DEPRECATED_VAR(\"\"));\n\nstatic Sys_var_have Sys_have_rtree_keys(\n    \"have_rtree_keys\", \"have_rtree_keys\",\n    READ_ONLY NON_PERSIST GLOBAL_VAR(have_rtree_keys), NO_CMD_LINE);\n\nstatic Sys_var_have_func Sys_have_ssl(\"have_ssl\", \"have_ssl\", have_ssl_func);\n\nstatic Sys_var_have Sys_have_symlink(\n    \"have_symlink\", \"have_symlink\",\n    READ_ONLY NON_PERSIST GLOBAL_VAR(have_symlink), NO_CMD_LINE);\n\nstatic Sys_var_have Sys_have_statement_timeout(\n    \"have_statement_timeout\", \"have_statement_timeout\",\n    READ_ONLY NON_PERSIST GLOBAL_VAR(have_statement_timeout), NO_CMD_LINE);\n\nstatic const char *log_slow_filter_name[] = {\n    \"full_scan\", \"full_join\",        \"tmp_table\", \"tmp_table_on_disk\",\n    \"filesort\",  \"filesort_on_disk\", nullptr};\n\nstatic Sys_var_set Sys_log_slow_filter(\n    \"log_slow_filter\",\n    \"Log only the queries that followed certain execution plan. \"\n    \"Multiple flags allowed in a comma-separated string. \"\n    \"[full_scan, full_join, tmp_table, tmp_table_on_disk, \"\n    \"filesort, filesort_on_disk]\",\n    SESSION_VAR(log_slow_filter), CMD_LINE(REQUIRED_ARG), log_slow_filter_name,\n    DEFAULT(0));\n\nstatic Sys_var_ulong sys_log_slow_rate_limit(\n    \"log_slow_rate_limit\",\n    \"Rate limit statement writes to slow log to only those from every \"\n    \"(1/log_slow_rate_limit) session.\",\n    SESSION_VAR(log_slow_rate_limit), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(1, SLOG_SLOW_RATE_LIMIT_MAX), DEFAULT(1), BLOCK_SIZE(1));\n\nstatic double opt_slow_query_log_always_write_time;\n\nstatic bool update_slow_query_log_always_write_time(\n    sys_var *self MY_ATTRIBUTE((unused)), THD *thd MY_ATTRIBUTE((unused)),\n    enum_var_type type MY_ATTRIBUTE((unused))) noexcept {\n  slow_query_log_always_write_time =\n      double2ulonglong(opt_slow_query_log_always_write_time * 1e6);\n  return false;\n}\n\nstatic Sys_var_double sys_slow_query_log_always_write_time(\n    \"slow_query_log_always_write_time\",\n    \"Log queries which run longer than specified by this value regardless \"\n    \"of the log_slow_rate_limit valiue.\",\n    GLOBAL_VAR(opt_slow_query_log_always_write_time), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(0, LONG_TIMEOUT), DEFAULT(10), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n    ON_CHECK(nullptr), ON_UPDATE(update_slow_query_log_always_write_time));\n\nstatic const char *log_slow_verbosity_name[] = {\n    \"microtime\", \"query_plan\", \"innodb\", \"profiling\", \"profiling_use_getrusage\",\n    \"minimal\",   \"standard\",   \"full\",   nullptr};\n\nstatic ulonglong update_log_slow_verbosity_replace(ulonglong value,\n                                                   ulonglong what,\n                                                   ulonglong by) noexcept {\n  if ((value & what) == what) {\n    value = value & (~what);\n    value = value | by;\n  }\n  return value;\n}\n\nstatic void update_log_slow_verbosity(ulonglong *value_ptr) noexcept {\n  ulonglong &value = *value_ptr;\n  static constexpr ulonglong microtime = 1ULL << SLOG_V_MICROTIME;\n  static constexpr ulonglong query_plan = 1ULL << SLOG_V_QUERY_PLAN;\n  static constexpr ulonglong innodb = 1ULL << SLOG_V_INNODB;\n  static constexpr ulonglong minimal = 1ULL << SLOG_V_MINIMAL;\n  static constexpr ulonglong standard = 1ULL << SLOG_V_STANDARD;\n  static constexpr ulonglong full = 1ULL << SLOG_V_FULL;\n  value = update_log_slow_verbosity_replace(value, minimal, microtime);\n  value = update_log_slow_verbosity_replace(value, standard,\n                                            microtime | query_plan);\n  value = update_log_slow_verbosity_replace(value, full,\n                                            microtime | query_plan | innodb);\n}\n\nstatic bool update_log_slow_verbosity_helper(sys_var *, THD *thd,\n                                             enum_var_type type) noexcept {\n  if (type == OPT_SESSION) {\n    update_log_slow_verbosity(&(thd->variables.log_slow_verbosity));\n  } else {\n    update_log_slow_verbosity(&(global_system_variables.log_slow_verbosity));\n  }\n  return false;\n}\n\nvoid init_slow_query_log_use_global_control() noexcept {\n  update_log_slow_verbosity(&(global_system_variables.log_slow_verbosity));\n}\n\nstatic Sys_var_set Sys_log_slow_verbosity(\n    \"log_slow_verbosity\",\n    \"Choose how verbose the messages to your slow log will be. \"\n    \"Multiple flags allowed in a comma-separated string. [microtime, \"\n    \"query_plan, innodb, profiling, profiling_use_getrusage]\",\n    SESSION_VAR(log_slow_verbosity), CMD_LINE(REQUIRED_ARG),\n    log_slow_verbosity_name, DEFAULT(SLOG_V_MICROTIME), NO_MUTEX_GUARD,\n    NOT_IN_BINLOG, ON_CHECK(nullptr),\n    ON_UPDATE(update_log_slow_verbosity_helper));\n\nstatic const char *log_slow_sp_statements_names[] = {\n    \"OFF\", \"ON\", \"OFF_NO_CALLS\", \"FALSE\", \"TRUE\", \"0\", \"1\", nullptr};\n\nstatic bool fix_log_slow_sp_statements(sys_var *, THD *,\n                                       enum_var_type) noexcept {\n  if (opt_log_slow_sp_statements > 2) {\n    opt_log_slow_sp_statements = (opt_log_slow_sp_statements - 3) % 2;\n  }\n  return false;\n}\n\nvoid init_log_slow_sp_statements() noexcept {\n  fix_log_slow_sp_statements(nullptr, nullptr, OPT_GLOBAL);\n}\n\nstatic Sys_var_enum Sys_log_slow_sp_statements(\n    \"log_slow_sp_statements\",\n    \"Choice between logging slow CALL statements, logging individual slow \"\n    \"statements inside stored procedures or skipping the logging of stored \"\n    \"procedures into the slow log entirely. Values are OFF, ON and \"\n    \"OFF_NO_CALLS respectively.\",\n    GLOBAL_VAR(opt_log_slow_sp_statements), CMD_LINE(OPT_ARG),\n    log_slow_sp_statements_names, DEFAULT(1), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n    ON_CHECK(nullptr), ON_UPDATE(fix_log_slow_sp_statements));\n\nstatic const char *slow_query_log_use_global_control_name[] = {\n    \"log_slow_filter\",\n    \"log_slow_rate_limit\",\n    \"log_slow_verbosity\",\n    \"long_query_time\",\n    \"min_examined_row_limit\",\n    \"all\",\n    nullptr};\n\nstatic bool update_slow_query_log_use_global_control(sys_var *, THD *,\n                                                     enum_var_type) noexcept {\n  if (opt_slow_query_log_use_global_control & (1ULL << SLOG_UG_ALL)) {\n    opt_slow_query_log_use_global_control =\n        (1ULL << SLOG_UG_LOG_SLOW_FILTER) |\n        (1ULL << SLOG_UG_LOG_SLOW_RATE_LIMIT) |\n        (1ULL << SLOG_UG_LOG_SLOW_VERBOSITY) |\n        (1ULL << SLOG_UG_LONG_QUERY_TIME) |\n        (1ULL << SLOG_UG_MIN_EXAMINED_ROW_LIMIT);\n  }\n  return false;\n}\n\nvoid init_log_slow_verbosity() noexcept {\n  update_slow_query_log_use_global_control(nullptr, nullptr, OPT_GLOBAL);\n}\n\n/**\n  Specialized class that handles \"none\" value of\n  slow_query_log_use_global_control_set variable.\n  When \"none\" only value is detected, it is rewriten to empty\n  causing set to be cleared.\n*/\nclass Sys_var_set_none : public Sys_var_set {\n public:\n  Sys_var_set_none(\n      const char *name_arg, const char *comment, int flag_args, ptrdiff_t off,\n      size_t size, CMD_LINE getopt, const char *values[], ulonglong def_val,\n      PolyLock *lock = 0,\n      enum binlog_status_enum binlog_status_arg = VARIABLE_NOT_IN_BINLOG,\n      on_check_function on_check_func = 0,\n      on_update_function on_update_func = 0, const char *substitute = 0)\n      : Sys_var_set(name_arg, comment, flag_args, off, size, getopt, values,\n                    def_val, lock, binlog_status_arg, on_check_func,\n                    on_update_func, substitute) {}\n\n  virtual bool do_check(THD *thd, set_var *var) {\n    if (var->value->result_type() == STRING_RESULT) {\n      char buff[STRING_BUFFER_USUAL_SIZE];\n      String str(buff, sizeof(buff), system_charset_info);\n\n      String *res = var->value->val_str(&str);\n      if (res && (res->length() > 0) &&\n          (0 == my_strcasecmp(system_charset_info, res->ptr(), \"none\"))) {\n        var->value = new Item_string(\"\", 0, system_charset_info);\n      }\n    }\n    return Sys_var_set::do_check(thd, var);\n  }\n};\n\nstatic Sys_var_set_none Sys_slow_query_log_use_global_control(\n    \"slow_query_log_use_global_control\",\n    \"Choose flags, wich always use the global variables. Multiple flags \"\n    \"allowed in a comma-separated string. [none, log_slow_filter, \"\n    \"log_slow_rate_limit, log_slow_verbosity, long_query_time, \"\n    \"min_examined_row_limit, all]\",\n    GLOBAL_VAR(opt_slow_query_log_use_global_control), CMD_LINE(REQUIRED_ARG),\n    slow_query_log_use_global_control_name, DEFAULT(0), NO_MUTEX_GUARD,\n    NOT_IN_BINLOG, ON_CHECK(0),\n    ON_UPDATE(update_slow_query_log_use_global_control));\n\nstatic const char *slow_query_log_rate_name[] = {\"session\", \"query\", 0};\n\nstatic Sys_var_enum Sys_slow_query_log_rate_type(\n    \"log_slow_rate_type\",\n    \"Choose the log_slow_rate_limit behavior: session or query. \"\n    \"When you choose 'session' - every %log_slow_rate_limit connection \"\n    \"will be processed to slow query log. \"\n    \"When you choose 'query' - every %log_slow_rate_limit query \"\n    \"will be processed to slow query log. \"\n    \"[session, query]\",\n    GLOBAL_VAR(opt_slow_query_log_rate_type), CMD_LINE(REQUIRED_ARG),\n    slow_query_log_rate_name, DEFAULT(SLOG_RT_SESSION));\n\nstatic bool fix_general_log_state(sys_var *, THD *thd, enum_var_type) {\n  bool new_state = opt_general_log, res = false;\n\n  if (query_logger.is_log_file_enabled(QUERY_LOG_GENERAL) == new_state)\n    return false;\n\n  mysql_mutex_unlock(&LOCK_global_system_variables);\n\n  if (!new_state) {\n    query_logger.deactivate_log_handler(QUERY_LOG_GENERAL);\n  } else {\n    res = query_logger.activate_log_handler(thd, QUERY_LOG_GENERAL);\n  }\n\n  mysql_mutex_lock(&LOCK_global_system_variables);\n\n  if (res) opt_general_log = false;\n\n  return res;\n}\nstatic Sys_var_bool Sys_general_log(\n    \"general_log\",\n    \"Log connections and queries to a table or log file. \"\n    \"Defaults to logging to a file hostname.log, \"\n    \"or if --log-output=TABLE is used, to a table mysql.general_log.\",\n    GLOBAL_VAR(opt_general_log), CMD_LINE(OPT_ARG), DEFAULT(false),\n    NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(nullptr),\n    ON_UPDATE(fix_general_log_state));\n\nstatic Sys_var_bool Sys_log_raw(\n    \"log_raw\",\n    \"Log to general log before any rewriting of the query. For use in \"\n    \"debugging, not production as sensitive information may be logged.\",\n    GLOBAL_VAR(opt_general_log_raw), CMD_LINE(OPT_ARG), DEFAULT(false),\n    NO_MUTEX_GUARD, NOT_IN_BINLOG);\n\nstatic bool fix_slow_log_state(sys_var *, THD *thd, enum_var_type) {\n  bool new_state = opt_slow_log, res = false;\n\n  if (query_logger.is_log_file_enabled(QUERY_LOG_SLOW) == new_state)\n    return false;\n\n  mysql_mutex_unlock(&LOCK_global_system_variables);\n\n  if (!new_state) {\n    query_logger.deactivate_log_handler(QUERY_LOG_SLOW);\n  } else {\n    res = query_logger.activate_log_handler(thd, QUERY_LOG_SLOW);\n  }\n\n  mysql_mutex_lock(&LOCK_global_system_variables);\n\n  if (res) opt_slow_log = false;\n\n  return res;\n}\nstatic Sys_var_bool Sys_slow_query_log(\n    \"slow_query_log\",\n    \"Log slow queries to a table or log file. Defaults logging to a file \"\n    \"hostname-slow.log or a table mysql.slow_log if --log-output=TABLE is \"\n    \"used. Must be enabled to activate other slow log options\",\n    GLOBAL_VAR(opt_slow_log), CMD_LINE(OPT_ARG), DEFAULT(false), NO_MUTEX_GUARD,\n    NOT_IN_BINLOG, ON_CHECK(nullptr), ON_UPDATE(fix_slow_log_state));\n\nstatic bool check_slow_log_extra(sys_var *, THD *thd, set_var *) {\n  // If FILE is not one of the log-targets, succeed but warn!\n  if (!(log_output_options & LOG_FILE))\n    push_warning(\n        thd, Sql_condition::SL_WARNING,\n        ER_SLOW_LOG_MODE_IGNORED_WHEN_NOT_LOGGING_TO_FILE,\n        ER_THD(thd, ER_SLOW_LOG_MODE_IGNORED_WHEN_NOT_LOGGING_TO_FILE));\n\n  return false;\n}\n\nstatic Sys_var_bool Sys_slow_log_extra(\n    \"log_slow_extra\",\n    \"Print more attributes to the slow query log file. Has no effect on \"\n    \"logging to table.\",\n    GLOBAL_VAR(opt_log_slow_extra), CMD_LINE(OPT_ARG), DEFAULT(false),\n    NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(check_slow_log_extra),\n    ON_UPDATE(nullptr));\n\nstatic bool check_not_empty_set(sys_var *, THD *, set_var *var) {\n  return var->save_result.ulonglong_value == 0;\n}\nstatic bool fix_log_output(sys_var *, THD *, enum_var_type) {\n  query_logger.set_handlers(static_cast<uint>(log_output_options));\n  return false;\n}\n\nstatic const char *log_output_names[] = {\"NONE\", \"FILE\", \"TABLE\", nullptr};\n\nstatic Sys_var_set Sys_log_output(\n    \"log_output\",\n    \"Syntax: log-output=value[,value...], \"\n    \"where \\\"value\\\" could be TABLE, FILE or NONE\",\n    GLOBAL_VAR(log_output_options), CMD_LINE(REQUIRED_ARG), log_output_names,\n    DEFAULT(LOG_FILE), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n    ON_CHECK(check_not_empty_set), ON_UPDATE(fix_log_output));\n\nstatic Sys_var_bool Sys_log_slave_updates(\n    \"log_slave_updates\",\n    \"Tells the slave to log the updates from \"\n    \"the slave thread to the binary log.\",\n    READ_ONLY GLOBAL_VAR(opt_log_slave_updates),\n    CMD_LINE(OPT_ARG, OPT_LOG_SLAVE_UPDATES), DEFAULT(1));\n\nstatic Sys_var_charptr Sys_relay_log(\n    \"relay_log\", \"The location and name to use for relay logs\",\n    READ_ONLY NON_PERSIST GLOBAL_VAR(opt_relay_logname), CMD_LINE(REQUIRED_ARG),\n    IN_FS_CHARSET, DEFAULT(nullptr));\n\n/*\n  Uses NO_CMD_LINE since the --relay-log-index option set\n  opt_relaylog_index_name variable and computes a value for the\n  relay_log_index variable.\n*/\nstatic Sys_var_charptr Sys_relay_log_index(\n    \"relay_log_index\",\n    \"The location and name to use for the file \"\n    \"that keeps a list of the last relay logs\",\n    READ_ONLY NON_PERSIST GLOBAL_VAR(relay_log_index), NO_CMD_LINE,\n    IN_FS_CHARSET, DEFAULT(nullptr));\n\n/*\n  Uses NO_CMD_LINE since the --log-bin-index option set\n  opt_binlog_index_name variable and computes a value for the\n  log_bin_index variable.\n*/\nstatic Sys_var_charptr Sys_binlog_index(\n    \"log_bin_index\", \"File that holds the names for last binary log files.\",\n    READ_ONLY NON_PERSIST GLOBAL_VAR(log_bin_index), NO_CMD_LINE, IN_FS_CHARSET,\n    DEFAULT(nullptr));\n\nstatic Sys_var_charptr Sys_relay_log_basename(\n    \"relay_log_basename\",\n    \"The full path of the relay log file names, excluding the extension.\",\n    READ_ONLY NON_PERSIST GLOBAL_VAR(relay_log_basename), NO_CMD_LINE,\n    IN_FS_CHARSET, DEFAULT(nullptr));\n\nstatic Sys_var_charptr Sys_log_bin_basename(\n    \"log_bin_basename\",\n    \"The full path of the binary log file names, excluding the extension.\",\n    READ_ONLY NON_PERSIST GLOBAL_VAR(log_bin_basename), NO_CMD_LINE,\n    IN_FS_CHARSET, DEFAULT(nullptr));\n\nstatic Sys_var_charptr Sys_relay_log_info_file(\n    \"relay_log_info_file\",\n    \"The location and name of the file that \"\n    \"remembers where the SQL replication thread is in the relay logs\",\n    READ_ONLY NON_PERSIST GLOBAL_VAR(relay_log_info_file),\n    CMD_LINE(REQUIRED_ARG, OPT_RELAY_LOG_INFO_FILE), IN_FS_CHARSET,\n    DEFAULT(nullptr), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(nullptr),\n    ON_UPDATE(nullptr), DEPRECATED_VAR(\"\"));\n\nstatic Sys_var_bool Sys_relay_log_purge(\n    \"relay_log_purge\",\n    \"if disabled - do not purge relay logs. \"\n    \"if enabled - purge them as soon as they are no more needed\",\n    GLOBAL_VAR(relay_log_purge), CMD_LINE(OPT_ARG), DEFAULT(true));\n\nstatic Sys_var_bool Sys_relay_log_recovery(\n    \"relay_log_recovery\",\n    \"Enables automatic relay log recovery \"\n    \"right after the database startup, which means that the IO Thread \"\n    \"starts re-fetching from the master right after the last transaction \"\n    \"processed\",\n    READ_ONLY GLOBAL_VAR(relay_log_recovery), CMD_LINE(OPT_ARG),\n    DEFAULT(false));\n\nstatic Sys_var_ulong Sys_rpl_read_size(\n    \"rpl_read_size\",\n    \"The size for reads done from the binlog and relay log. \"\n    \"It must be a multiple of 4kb. Making it larger might help with IO \"\n    \"stalls while reading these files when they are not in the OS buffer \"\n    \"cache\",\n    GLOBAL_VAR(rpl_read_size), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(IO_SIZE * 2, ULONG_MAX), DEFAULT(IO_SIZE * 2),\n    BLOCK_SIZE(IO_SIZE));\n\nstatic Sys_var_bool Sys_slave_allow_batching(\n    \"slave_allow_batching\", \"Allow slave to batch requests\",\n    GLOBAL_VAR(opt_slave_allow_batching), CMD_LINE(OPT_ARG), DEFAULT(false));\n\nstatic Sys_var_charptr Sys_slave_load_tmpdir(\n    \"slave_load_tmpdir\",\n    \"The location where the slave should put \"\n    \"its temporary files when replicating a LOAD DATA INFILE command\",\n    READ_ONLY NON_PERSIST GLOBAL_VAR(slave_load_tmpdir), CMD_LINE(REQUIRED_ARG),\n    IN_FS_CHARSET, DEFAULT(nullptr));\n\nstatic bool fix_slave_net_timeout(sys_var *, THD *thd, enum_var_type) {\n  DEBUG_SYNC(thd, \"fix_slave_net_timeout\");\n  Master_info *mi;\n\n  /* @TODO: slave net timeout is for all channels, but does this make\n           sense?\n   */\n\n  /*\n   Here we have lock on LOCK_global_system_variables and we need\n    lock on channel_map lock. In START_SLAVE handler, we take these\n    two locks in different order. This can lead to DEADLOCKs. See\n    BUG#14236151 for more details.\n   So we release lock on LOCK_global_system_variables before acquiring\n    lock on channel_map lock. But this could lead to isolation issues\n    between multiple setters. Hence introducing secondary guard\n    for this global variable and releasing the lock here and acquiring\n    locks back again at the end of this function.\n   */\n  mysql_mutex_unlock(&LOCK_slave_net_timeout);\n  mysql_mutex_unlock(&LOCK_global_system_variables);\n  channel_map.wrlock();\n\n  for (mi_map::iterator it = channel_map.begin(); it != channel_map.end();\n       it++) {\n    mi = it->second;\n\n    DBUG_PRINT(\"info\", (\"slave_net_timeout=%u mi->heartbeat_period=%.3f\",\n                        slave_net_timeout, (mi ? mi->heartbeat_period : 0.0)));\n    if (mi != nullptr && slave_net_timeout < mi->heartbeat_period)\n      push_warning(thd, Sql_condition::SL_WARNING,\n                   ER_SLAVE_HEARTBEAT_VALUE_OUT_OF_RANGE_MAX,\n                   ER_THD(thd, ER_SLAVE_HEARTBEAT_VALUE_OUT_OF_RANGE_MAX));\n  }\n\n  channel_map.unlock();\n  mysql_mutex_lock(&LOCK_global_system_variables);\n  mysql_mutex_lock(&LOCK_slave_net_timeout);\n  return false;\n}\nstatic PolyLock_mutex PLock_slave_net_timeout(&LOCK_slave_net_timeout);\nstatic Sys_var_uint Sys_slave_net_timeout(\n    \"slave_net_timeout\",\n    \"Number of seconds to wait for more data \"\n    \"from a master/slave connection before aborting the read\",\n    GLOBAL_VAR(slave_net_timeout), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(1, LONG_TIMEOUT), DEFAULT(SLAVE_NET_TIMEOUT), BLOCK_SIZE(1),\n    &PLock_slave_net_timeout, NOT_IN_BINLOG, ON_CHECK(nullptr),\n    ON_UPDATE(fix_slave_net_timeout));\n\nstatic bool check_slave_skip_counter(sys_var *, THD *, set_var *) {\n  /*\n    @todo: move this check into the set function and hold the lock on\n    gtid_mode_lock until the operation has completed, so that we are\n    sure a concurrent connection does not change gtid_mode between\n    check and fix.\n  */\n  if (get_gtid_mode(GTID_MODE_LOCK_NONE) == GTID_MODE_ON) {\n    my_error(ER_SQL_SLAVE_SKIP_COUNTER_NOT_SETTABLE_IN_GTID_MODE, MYF(0));\n    return true;\n  }\n\n  return false;\n}\n\nstatic PolyLock_mutex PLock_sql_slave_skip_counter(\n    &LOCK_sql_slave_skip_counter);\nstatic Sys_var_uint Sys_slave_skip_counter(\n    \"sql_slave_skip_counter\", \"sql_slave_skip_counter\",\n    GLOBAL_VAR(sql_slave_skip_counter), NO_CMD_LINE, VALID_RANGE(0, UINT_MAX),\n    DEFAULT(0), BLOCK_SIZE(1), &PLock_sql_slave_skip_counter, NOT_IN_BINLOG,\n    ON_CHECK(check_slave_skip_counter));\n\nstatic Sys_var_charptr Sys_slave_skip_errors(\n    \"slave_skip_errors\",\n    \"Tells the slave thread to continue \"\n    \"replication when a query event returns an error from the \"\n    \"provided list\",\n    READ_ONLY GLOBAL_VAR(opt_slave_skip_errors), CMD_LINE(REQUIRED_ARG),\n    IN_SYSTEM_CHARSET, DEFAULT(nullptr));\n\nstatic Sys_var_ulonglong Sys_relay_log_space_limit(\n    \"relay_log_space_limit\", \"Maximum space to use for all relay logs\",\n    READ_ONLY GLOBAL_VAR(relay_log_space_limit), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(0, ULONG_MAX), DEFAULT(0), BLOCK_SIZE(1));\n\nstatic Sys_var_uint Sys_sync_relaylog_period(\n    \"sync_relay_log\",\n    \"Synchronously flush relay log to disk after \"\n    \"every #th event. Use 0 to disable synchronous flushing\",\n    GLOBAL_VAR(sync_relaylog_period), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(0, UINT_MAX), DEFAULT(10000), BLOCK_SIZE(1));\n\nstatic Sys_var_uint Sys_sync_relayloginfo_period(\n    \"sync_relay_log_info\",\n    \"Synchronously flush relay log info \"\n    \"to disk after every #th transaction. Use 0 to disable \"\n    \"synchronous flushing\",\n    GLOBAL_VAR(sync_relayloginfo_period), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(0, UINT_MAX), DEFAULT(10000), BLOCK_SIZE(1));\n\nstatic Sys_var_uint Sys_checkpoint_mts_period(\n    \"slave_checkpoint_period\",\n    \"Gather workers' activities to \"\n    \"Update progress status of Multi-threaded slave and flush \"\n    \"the relay log info to disk after every #th milli-seconds.\",\n    GLOBAL_VAR(opt_mts_checkpoint_period), CMD_LINE(REQUIRED_ARG),\n#ifndef DBUG_OFF\n    VALID_RANGE(0, UINT_MAX), DEFAULT(300), BLOCK_SIZE(1));\n#else\n    VALID_RANGE(1, UINT_MAX), DEFAULT(300), BLOCK_SIZE(1));\n#endif /* DBUG_OFF */\n\nstatic Sys_var_uint Sys_checkpoint_mts_group(\n    \"slave_checkpoint_group\",\n    \"Maximum number of processed transactions by Multi-threaded slave \"\n    \"before a checkpoint operation is called to update progress status.\",\n    GLOBAL_VAR(opt_mts_checkpoint_group), CMD_LINE(REQUIRED_ARG),\n#ifndef DBUG_OFF\n    VALID_RANGE(1, MTS_MAX_BITS_IN_GROUP), DEFAULT(512), BLOCK_SIZE(1));\n#else\n    VALID_RANGE(32, MTS_MAX_BITS_IN_GROUP), DEFAULT(512), BLOCK_SIZE(8));\n#endif /* DBUG_OFF */\n\nstatic Sys_var_uint Sys_sync_binlog_period(\n    \"sync_binlog\",\n    \"Synchronously flush binary log to disk after\"\n    \" every #th write to the file. Use 0 to disable synchronous\"\n    \" flushing\",\n    GLOBAL_VAR(sync_binlog_period), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(0, UINT_MAX), DEFAULT(1), BLOCK_SIZE(1));\n\nstatic Sys_var_uint Sys_sync_masterinfo_period(\n    \"sync_master_info\",\n    \"Synchronously flush master info to disk \"\n    \"after every #th event. Use 0 to disable synchronous flushing\",\n    GLOBAL_VAR(sync_masterinfo_period), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(0, UINT_MAX), DEFAULT(10000), BLOCK_SIZE(1));\n\nstatic Sys_var_ulonglong Sys_var_original_commit_timestamp(\n    \"original_commit_timestamp\",\n    \"The time when the current transaction was committed on the originating \"\n    \"replication master, measured in microseconds since the epoch.\",\n    SESSION_ONLY(original_commit_timestamp), NO_CMD_LINE,\n    VALID_RANGE(0, MAX_COMMIT_TIMESTAMP_VALUE),\n    DEFAULT(MAX_COMMIT_TIMESTAMP_VALUE), BLOCK_SIZE(1), NO_MUTEX_GUARD,\n    IN_BINLOG, ON_CHECK(check_session_admin_or_replication_applier));\n\nstatic Sys_var_ulong Sys_slave_trans_retries(\n    \"slave_transaction_retries\",\n    \"Number of times the slave SQL \"\n    \"thread will retry a transaction in case it failed with a deadlock \"\n    \"or elapsed lock wait timeout, before giving up and stopping\",\n    GLOBAL_VAR(slave_trans_retries), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(0, ULONG_MAX), DEFAULT(10), BLOCK_SIZE(1));\n\nstatic Sys_var_ulong Sys_slave_parallel_workers(\n    \"slave_parallel_workers\",\n    \"Number of worker threads for executing events in parallel \",\n    PERSIST_AS_READONLY GLOBAL_VAR(opt_mts_slave_parallel_workers),\n    CMD_LINE(REQUIRED_ARG), VALID_RANGE(0, MTS_MAX_WORKERS), DEFAULT(0),\n    BLOCK_SIZE(1));\n\nstatic Sys_var_ulonglong Sys_mts_pending_jobs_size_max(\n    \"slave_pending_jobs_size_max\",\n    \"Max size of Slave Worker queues holding not yet applied events. \"\n    \"The least possible value must be not less than the master side \"\n    \"max_allowed_packet.\",\n    GLOBAL_VAR(opt_mts_pending_jobs_size_max), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(1024, (ulonglong) ~(intptr)0), DEFAULT(128 * 1024 * 1024),\n    BLOCK_SIZE(1024), ON_CHECK(nullptr));\n\nstatic bool check_locale(sys_var *self, THD *thd, set_var *var) {\n  if (!var->value) return false;\n\n  MY_LOCALE *locale;\n  char buff[STRING_BUFFER_USUAL_SIZE];\n  if (var->value->result_type() == INT_RESULT) {\n    int lcno = (int)var->value->val_int();\n    if (!(locale = my_locale_by_number(lcno))) {\n      my_error(ER_UNKNOWN_LOCALE, MYF(0), llstr(lcno, buff));\n      return true;\n    }\n    if (check_not_null(self, thd, var)) return true;\n  } else  // STRING_RESULT\n  {\n    String str(buff, sizeof(buff), system_charset_info), *res;\n    if (!(res = var->value->val_str(&str)))\n      return true;\n    else if (!(locale = my_locale_by_name(thd, res->ptr(), res->length()))) {\n      ErrConvString err(res);\n      my_error(ER_UNKNOWN_LOCALE, MYF(0), err.ptr());\n      return true;\n    }\n  }\n\n  var->save_result.ptr = locale;\n\n  if (!locale->errmsgs->is_loaded()) {\n    mysql_mutex_lock(&LOCK_error_messages);\n    if (!locale->errmsgs->is_loaded() && locale->errmsgs->read_texts()) {\n      push_warning_printf(thd, Sql_condition::SL_WARNING, ER_UNKNOWN_ERROR,\n                          \"Can't process error message file for locale '%s'\",\n                          locale->name);\n      mysql_mutex_unlock(&LOCK_error_messages);\n      return true;\n    }\n    mysql_mutex_unlock(&LOCK_error_messages);\n  }\n  return false;\n}\n\nnamespace {\nstruct Get_locale_name {\n  explicit Get_locale_name(const MY_LOCALE *ml) : m_ml(ml) {}\n  const uchar *get_name() const {\n    return pointer_cast<const uchar *>(m_ml->name);\n  }\n  const MY_LOCALE *m_ml;\n};\n}  // namespace\n\nstatic Sys_var_struct<MY_LOCALE, Get_locale_name> Sys_lc_messages(\n    \"lc_messages\", \"Set the language used for the error messages\",\n    SESSION_VAR(lc_messages), NO_CMD_LINE, DEFAULT(&my_default_lc_messages),\n    NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(check_locale));\n\nstatic Sys_var_struct<MY_LOCALE, Get_locale_name> Sys_lc_time_names(\n    \"lc_time_names\",\n    \"Set the language used for the month \"\n    \"names and the days of the week\",\n    SESSION_VAR(lc_time_names), NO_CMD_LINE, DEFAULT(&my_default_lc_time_names),\n    NO_MUTEX_GUARD, IN_BINLOG, ON_CHECK(check_locale));\n\nstatic Sys_var_tz Sys_time_zone(\"time_zone\", \"time_zone\",\n                                HINT_UPDATEABLE SESSION_VAR(time_zone),\n                                NO_CMD_LINE, DEFAULT(&default_tz),\n                                NO_MUTEX_GUARD, IN_BINLOG);\n\nstatic bool fix_host_cache_size(sys_var *, THD *, enum_var_type) {\n  hostname_cache_resize(host_cache_size);\n  return false;\n}\n\nstatic Sys_var_uint Sys_host_cache_size(\n    \"host_cache_size\",\n    \"How many host names should be cached to avoid resolving.\",\n    GLOBAL_VAR(host_cache_size), CMD_LINE(REQUIRED_ARG, OPT_HOST_CACHE_SIZE),\n    VALID_RANGE(0, 65536), DEFAULT(HOST_CACHE_SIZE), BLOCK_SIZE(1),\n    NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(nullptr),\n    ON_UPDATE(fix_host_cache_size));\n\nconst Sys_var_multi_enum::ALIAS enforce_gtid_consistency_aliases[] = {\n    {\"OFF\", 0},   {\"ON\", 1},   {\"WARN\", 2},\n    {\"FALSE\", 0}, {\"TRUE\", 1}, {nullptr, 0}};\nstatic Sys_var_enforce_gtid_consistency Sys_enforce_gtid_consistency(\n    \"enforce_gtid_consistency\",\n    \"Prevents execution of statements that would be impossible to log \"\n    \"in a transactionally safe manner. Currently, the disallowed \"\n    \"statements include CREATE TEMPORARY TABLE inside transactions, \"\n    \"all updates to non-transactional tables, and CREATE TABLE ... SELECT.\",\n    PERSIST_AS_READONLY GLOBAL_VAR(_gtid_consistency_mode),\n    CMD_LINE(OPT_ARG, OPT_ENFORCE_GTID_CONSISTENCY),\n    enforce_gtid_consistency_aliases, 3,\n    DEFAULT(3 /*position of \"FALSE\" in enforce_gtid_consistency_aliases*/),\n    DEFAULT(GTID_CONSISTENCY_MODE_ON), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n    ON_CHECK(check_session_admin_outside_trx_outside_sf_outside_sp));\nconst char *fixup_enforce_gtid_consistency_command_line(char *value_arg) {\n  return Sys_enforce_gtid_consistency.fixup_command_line(value_arg);\n}\n\nstatic Sys_var_bool Sys_binlog_gtid_simple_recovery(\n    \"binlog_gtid_simple_recovery\",\n    \"If this option is enabled, the server does not open more than \"\n    \"two binary logs when initializing GTID_PURGED and \"\n    \"GTID_EXECUTED, either during server restart or when binary \"\n    \"logs are being purged. Enabling this option is useful when \"\n    \"the server has already generated many binary logs without \"\n    \"GTID events (e.g., having GTID_MODE = OFF). Note: If this \"\n    \"option is enabled, GLOBAL.GTID_EXECUTED and \"\n    \"GLOBAL.GTID_PURGED may be initialized wrongly in two cases: \"\n    \"(1) All binary logs were generated by MySQL 5.7.5 or older, \"\n    \"and GTID_MODE was ON for some binary logs but OFF for the \"\n    \"newest binary log. (2) The oldest existing binary log was \"\n    \"generated by MySQL 5.7.5 or older, and SET GTID_PURGED was \"\n    \"issued after the oldest binary log was generated. If a wrong \"\n    \"set is computed in one of case (1) or case (2), it will \"\n    \"remain wrong even if the server is later restarted with this \"\n    \"option disabled.\",\n    READ_ONLY GLOBAL_VAR(binlog_gtid_simple_recovery), CMD_LINE(OPT_ARG),\n    DEFAULT(true));\n\nstatic Sys_var_ulong Sys_sp_cache_size(\n    \"stored_program_cache\",\n    \"The soft upper limit for number of cached stored routines for \"\n    \"one connection.\",\n    GLOBAL_VAR(stored_program_cache_size), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(16, 512 * 1024), DEFAULT(256), BLOCK_SIZE(1));\n\nstatic Sys_var_bool Sys_encrypt_tmp_files(\n    \"encrypt_tmp_files\",\n    \"Encrypt temporary files \"\n    \"(created for filesort, Group Replication, etc)\",\n    READ_ONLY GLOBAL_VAR(encrypt_tmp_files), CMD_LINE(OPT_ARG), DEFAULT(false));\n\nstatic bool check_pseudo_slave_mode(sys_var *self, THD *thd, set_var *var) {\n  if (check_session_admin_or_replication_applier(self, thd, var)) return true;\n  if (check_outside_trx(self, thd, var)) return true;\n  longlong previous_val = thd->variables.pseudo_slave_mode;\n  longlong val = (longlong)var->save_result.ulonglong_value;\n  bool rli_fake = false;\n\n  rli_fake = thd->rli_fake ? true : false;\n\n  if (rli_fake) {\n    if (!val) {\n      thd->rli_fake->end_info();\n      delete thd->rli_fake;\n      thd->rli_fake = nullptr;\n    } else if (previous_val && val)\n      goto ineffective;\n    else if (!previous_val && val)\n      push_warning(thd, Sql_condition::SL_WARNING, ER_WRONG_VALUE_FOR_VAR,\n                   \"'pseudo_slave_mode' is already ON.\");\n  } else {\n    if (!previous_val && !val)\n      goto ineffective;\n    else if (previous_val && !val)\n      push_warning(thd, Sql_condition::SL_WARNING, ER_WRONG_VALUE_FOR_VAR,\n                   \"Slave applier execution mode not active, \"\n                   \"statement ineffective.\");\n  }\n  goto end;\n\nineffective:\n  push_warning(thd, Sql_condition::SL_WARNING, ER_WRONG_VALUE_FOR_VAR,\n               \"'pseudo_slave_mode' change was ineffective.\");\n\nend:\n  return false;\n}\nstatic Sys_var_bool Sys_pseudo_slave_mode(\n    \"pseudo_slave_mode\",\n    \"SET pseudo_slave_mode= 0,1 are commands that mysqlbinlog \"\n    \"adds to beginning and end of binary log dumps. While zero \"\n    \"value indeed disables, the actual enabling of the slave \"\n    \"applier execution mode is done implicitly when a \"\n    \"Format_description_event is sent through the session.\",\n    SESSION_ONLY(pseudo_slave_mode), NO_CMD_LINE, DEFAULT(false),\n    NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(check_pseudo_slave_mode));\n\n#ifdef HAVE_GTID_NEXT_LIST\nstatic bool check_gtid_next_list(sys_var *self, THD *thd, set_var *var) {\n  DBUG_TRACE;\n  my_error(ER_NOT_SUPPORTED_YET, MYF(0), \"GTID_NEXT_LIST\");\n  if (check_session_admin_outside_trx_outside_sf_outside_sp(self, thd, var))\n    return true;\n  /*\n    @todo: move this check into the set function and hold the lock on\n    gtid_mode_lock until the operation has completed, so that we are\n    sure a concurrent connection does not change gtid_mode between\n    check and fix - if we ever implement this variable.\n  */\n  if (get_gtid_mode(GTID_MODE_LOCK_NONE) == GTID_MODE_OFF &&\n      var->save_result.string_value.str != NULL)\n    my_error(ER_CANT_SET_GTID_NEXT_LIST_TO_NON_NULL_WHEN_GTID_MODE_IS_OFF,\n             MYF(0));\n  return false;\n}\n\nstatic bool update_gtid_next_list(sys_var *self, THD *thd, enum_var_type type) {\n  DBUG_ASSERT(type == OPT_SESSION);\n  if (thd->get_gtid_next_list() != NULL)\n    return gtid_acquire_ownership_multiple(thd) != 0 ? true : false;\n  return false;\n}\n\nstatic Sys_var_gtid_set Sys_gtid_next_list(\n    \"gtid_next_list\",\n    \"Before re-executing a transaction that contains multiple \"\n    \"Global Transaction Identifiers, this variable must be set \"\n    \"to the set of all re-executed transactions.\",\n    SESSION_ONLY(gtid_next_list), NO_CMD_LINE, DEFAULT(NULL), NO_MUTEX_GUARD,\n    NOT_IN_BINLOG, ON_CHECK(check_gtid_next_list),\n    ON_UPDATE(update_gtid_next_list));\nexport sys_var *Sys_gtid_next_list_ptr = &Sys_gtid_next_list;\n#endif  // HAVE_GTID_NEXT_LIST\n\nstatic Sys_var_gtid_next Sys_gtid_next(\n    \"gtid_next\",\n    \"Specifies the Global Transaction Identifier for the following \"\n    \"transaction.\",\n    SESSION_ONLY(gtid_next), NO_CMD_LINE, DEFAULT(\"AUTOMATIC\"), NO_MUTEX_GUARD,\n    NOT_IN_BINLOG, ON_CHECK(check_gtid_next));\nexport sys_var *Sys_gtid_next_ptr = &Sys_gtid_next;\n\nstatic Sys_var_gtid_executed Sys_gtid_executed(\n    \"gtid_executed\",\n    \"The global variable contains the set of GTIDs in the \"\n    \"binary log. The session variable contains the set of GTIDs \"\n    \"in the current, ongoing transaction.\");\n\nstatic bool check_gtid_purged(sys_var *self, THD *thd, set_var *var) {\n  DBUG_TRACE;\n\n  /*\n    GTID_PURGED must not be set / updated when GR is running (it goes against\n    the whole purpose of update everywhere replication).\n  */\n  if (is_group_replication_running()) {\n    my_error(ER_UPDATE_GTID_PURGED_WITH_GR, MYF(0));\n    return true;\n  }\n\n  if (!var->value ||\n      check_session_admin_outside_trx_outside_sf_outside_sp(self, thd, var))\n    return true;\n\n  if (var->value->result_type() != STRING_RESULT ||\n      !var->save_result.string_value.str)\n    return true;\n\n  return false;\n}\n\nbool Sys_var_gtid_purged::global_update(THD *thd, set_var *var) {\n  DBUG_TRACE;\n  bool error = false;\n\n  global_sid_lock->wrlock();\n\n  /*\n    ensures the commit of the transaction started when saving the\n    purged gtid set in the table\n  */\n  thd->lex->autocommit = true;\n\n  /*\n    SET GITD_PURGED command should ignore 'read-only' and 'super_read_only'\n    options so that it can update 'mysql.gtid_executed' replication repository\n    table.\n  */\n  thd->set_skip_readonly_check();\n  char *previous_gtid_executed = nullptr, *previous_gtid_purged = nullptr,\n       *current_gtid_executed = nullptr, *current_gtid_purged = nullptr;\n  gtid_state->get_executed_gtids()->to_string(&previous_gtid_executed);\n  gtid_state->get_lost_gtids()->to_string(&previous_gtid_purged);\n  Gtid_set gtid_set(global_sid_map, global_sid_lock);\n  bool starts_with_plus = false;\n  enum_return_status ret = gtid_set.add_gtid_text(\n      var->save_result.string_value.str, nullptr, &starts_with_plus);\n\n  if (ret != RETURN_STATUS_OK) {\n    error = true;\n    goto end;\n  }\n  ret = gtid_state->add_lost_gtids(&gtid_set, starts_with_plus);\n  if (ret != RETURN_STATUS_OK) {\n    error = true;\n    goto end;\n  }\n  gtid_state->get_executed_gtids()->to_string(&current_gtid_executed);\n  gtid_state->get_lost_gtids()->to_string(&current_gtid_purged);\n\n  // Log messages saying that GTID_PURGED and GTID_EXECUTED were changed.\n  LogErr(SYSTEM_LEVEL, ER_GTID_PURGED_WAS_UPDATED, previous_gtid_purged,\n         current_gtid_purged);\n  LogErr(SYSTEM_LEVEL, ER_GTID_EXECUTED_WAS_UPDATED, previous_gtid_executed,\n         current_gtid_executed);\n\nend:\n  global_sid_lock->unlock();\n  my_free(previous_gtid_executed);\n  my_free(previous_gtid_purged);\n  my_free(current_gtid_executed);\n  my_free(current_gtid_purged);\n  return error;\n}\n\nGtid_set *gtid_purged;\nstatic Sys_var_gtid_purged Sys_gtid_purged(\n    \"gtid_purged\",\n    \"The set of GTIDs that existed in previous, purged binary logs.\",\n    GLOBAL_VAR(gtid_purged), NO_CMD_LINE, DEFAULT(nullptr), NO_MUTEX_GUARD,\n    NOT_IN_BINLOG, ON_CHECK(check_gtid_purged));\nexport sys_var *Sys_gtid_purged_ptr = &Sys_gtid_purged;\n\nstatic Sys_var_gtid_owned Sys_gtid_owned(\n    \"gtid_owned\",\n    \"The global variable lists all GTIDs owned by all threads. \"\n    \"The session variable lists all GTIDs owned by the current thread.\");\n\nstatic Sys_var_gtid_mode Sys_gtid_mode(\n    \"gtid_mode\",\n    \"Controls whether Global Transaction Identifiers (GTIDs) are \"\n    \"enabled. Can be OFF, OFF_PERMISSIVE, ON_PERMISSIVE, or ON. OFF \"\n    \"means that no transaction has a GTID. OFF_PERMISSIVE means that \"\n    \"new transactions (committed in a client session using \"\n    \"GTID_NEXT='AUTOMATIC') are not assigned any GTID, and \"\n    \"replicated transactions are allowed to have or not have a \"\n    \"GTID. ON_PERMISSIVE means that new transactions are assigned a \"\n    \"GTID, and replicated transactions are allowed to have or not \"\n    \"have a GTID. ON means that all transactions have a GTID. \"\n    \"ON is required on a master before any slave can use \"\n    \"MASTER_AUTO_POSITION=1. To safely switch from OFF to ON, first \"\n    \"set all servers to OFF_PERMISSIVE, then set all servers to \"\n    \"ON_PERMISSIVE, then wait for all transactions without a GTID to \"\n    \"be replicated and executed on all servers, and finally set all \"\n    \"servers to GTID_MODE = ON.\",\n    PERSIST_AS_READONLY GLOBAL_VAR(_gtid_mode), CMD_LINE(REQUIRED_ARG),\n    gtid_mode_names, DEFAULT(DEFAULT_GTID_MODE), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n    ON_CHECK(check_session_admin_outside_trx_outside_sf_outside_sp));\n\nstatic Sys_var_uint Sys_gtid_executed_compression_period(\n    \"gtid_executed_compression_period\",\n    \"When binlog is disabled, \"\n    \"a background thread wakes up to compress the gtid_executed table \"\n    \"every gtid_executed_compression_period transactions, as a \"\n    \"special case, if variable is 0, the thread never wakes up \"\n    \"to compress the gtid_executed table.\",\n    GLOBAL_VAR(gtid_executed_compression_period), CMD_LINE(OPT_ARG),\n    VALID_RANGE(0, UINT_MAX32), DEFAULT(1000), BLOCK_SIZE(1));\n\nstatic Sys_var_bool Sys_disconnect_on_expired_password(\n    \"disconnect_on_expired_password\",\n    \"Give clients that don't signal password expiration support execution \"\n    \"time \"\n    \"error(s) instead of connection error\",\n    READ_ONLY GLOBAL_VAR(disconnect_on_expired_password), CMD_LINE(OPT_ARG),\n    DEFAULT(true));\n\nstatic Sys_var_bool Sys_validate_user_plugins(\n    \"validate_user_plugins\",\n    \"Turns on additional validation of authentication plugins assigned \"\n    \"to user accounts. \",\n    READ_ONLY NOT_VISIBLE GLOBAL_VAR(validate_user_plugins), CMD_LINE(OPT_ARG),\n    DEFAULT(true), NO_MUTEX_GUARD, NOT_IN_BINLOG);\n\nstatic Sys_var_enum Sys_block_encryption_mode(\n    \"block_encryption_mode\", \"mode for AES_ENCRYPT/AES_DECRYPT\",\n    HINT_UPDATEABLE SESSION_VAR(my_aes_mode), CMD_LINE(REQUIRED_ARG),\n    my_aes_opmode_names, DEFAULT(my_aes_128_ecb));\n\nstatic bool check_track_session_sys_vars(sys_var *, THD *thd, set_var *var) {\n  DBUG_TRACE;\n  return thd->session_tracker.get_tracker(SESSION_SYSVARS_TRACKER)\n      ->check(thd, var);\n  return false;\n}\n\nstatic bool update_track_session_sys_vars(sys_var *, THD *thd,\n                                          enum_var_type type) {\n  DBUG_TRACE;\n  /* Populate map only for session variable. */\n  if (type == OPT_SESSION)\n    return thd->session_tracker.get_tracker(SESSION_SYSVARS_TRACKER)\n        ->update(thd);\n  return false;\n}\n\nstatic Sys_var_charptr Sys_track_session_sys_vars(\n    \"session_track_system_variables\",\n    \"Track changes in registered system variables.\",\n    SESSION_VAR(track_sysvars_ptr), CMD_LINE(REQUIRED_ARG), IN_FS_CHARSET,\n    DEFAULT(\"time_zone,autocommit,character_set_client,character_set_results,\"\n            \"character_set_connection\"),\n    NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(check_track_session_sys_vars),\n    ON_UPDATE(update_track_session_sys_vars));\n\nstatic bool update_session_track_schema(sys_var *, THD *thd, enum_var_type) {\n  DBUG_TRACE;\n  return thd->session_tracker.get_tracker(CURRENT_SCHEMA_TRACKER)->update(thd);\n}\n\nstatic Sys_var_bool Sys_session_track_schema(\n    \"session_track_schema\", \"Track changes to the 'default schema'.\",\n    SESSION_VAR(session_track_schema), CMD_LINE(OPT_ARG), DEFAULT(true),\n    NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(nullptr),\n    ON_UPDATE(update_session_track_schema));\n\nstatic bool update_session_track_tx_info(sys_var *, THD *thd, enum_var_type) {\n  DBUG_TRACE;\n  TX_TRACKER_GET(tst);\n  return tst->update(thd);\n}\n\nstatic const char *session_track_transaction_info_names[] = {\n    \"OFF\", \"STATE\", \"CHARACTERISTICS\", NullS};\n\nstatic Sys_var_enum Sys_session_track_transaction_info(\n    \"session_track_transaction_info\",\n    \"Track changes to the transaction attributes. OFF to disable; \"\n    \"STATE to track just transaction state (Is there an active transaction? \"\n    \"Does it have any data? etc.); CHARACTERISTICS to track transaction \"\n    \"state \"\n    \"and report all statements needed to start a transaction with the same \"\n    \"characteristics (isolation level, read only/read write, snapshot - \"\n    \"but not any work done / data modified within the transaction).\",\n    SESSION_VAR(session_track_transaction_info), CMD_LINE(REQUIRED_ARG),\n    session_track_transaction_info_names, DEFAULT(OFF), NO_MUTEX_GUARD,\n    NOT_IN_BINLOG, ON_CHECK(nullptr), ON_UPDATE(update_session_track_tx_info));\n\nstatic bool update_session_track_state_change(sys_var *, THD *thd,\n                                              enum_var_type) {\n  DBUG_TRACE;\n  return thd->session_tracker.get_tracker(SESSION_STATE_CHANGE_TRACKER)\n      ->update(thd);\n}\n\nstatic Sys_var_bool Sys_session_track_state_change(\n    \"session_track_state_change\", \"Track changes to the 'session state'.\",\n    SESSION_VAR(session_track_state_change), CMD_LINE(OPT_ARG), DEFAULT(false),\n    NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(nullptr),\n    ON_UPDATE(update_session_track_state_change));\n\nstatic bool handle_offline_mode(sys_var *, THD *thd, enum_var_type) {\n  DBUG_TRACE;\n  DEBUG_SYNC(thd, \"after_lock_offline_mode_acquire\");\n\n  if (mysqld_offline_mode()) {\n    // Unlock the global system varaible lock as kill holds LOCK_thd_data.\n    mysql_mutex_unlock(&LOCK_global_system_variables);\n    killall_non_super_threads(thd);\n    mysql_mutex_lock(&LOCK_global_system_variables);\n  }\n\n  return false;\n}\n\nstatic Sys_var_bool Sys_offline_mode(\n    \"offline_mode\", \"Make the server into offline mode\",\n    GLOBAL_VAR(offline_mode), CMD_LINE(OPT_ARG), DEFAULT(false), NO_MUTEX_GUARD,\n    NOT_IN_BINLOG, ON_CHECK(nullptr), ON_UPDATE(handle_offline_mode));\n\nstatic Sys_var_bool Sys_avoid_temporal_upgrade(\n    \"avoid_temporal_upgrade\",\n    \"When this option is enabled, the pre-5.6.4 temporal types are \"\n    \"not upgraded to the new format for ALTER TABLE requests \"\n    \"ADD/CHANGE/MODIFY\"\n    \" COLUMN, ADD INDEX or FORCE operation. \"\n    \"This variable is deprecated and will be removed in a future release.\",\n    GLOBAL_VAR(avoid_temporal_upgrade),\n    CMD_LINE(OPT_ARG, OPT_AVOID_TEMPORAL_UPGRADE), DEFAULT(false),\n    NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(nullptr), ON_UPDATE(nullptr),\n    DEPRECATED_VAR(\"\"));\n\nstatic Sys_var_bool Sys_show_old_temporals(\n    \"show_old_temporals\",\n    \"When this option is enabled, the pre-5.6.4 temporal types will \"\n    \"be marked in the 'SHOW CREATE TABLE' and 'INFORMATION_SCHEMA.COLUMNS' \"\n    \"table as a comment in COLUMN_TYPE field. \"\n    \"This variable is deprecated and will be removed in a future release.\",\n    SESSION_VAR(show_old_temporals), CMD_LINE(OPT_ARG, OPT_SHOW_OLD_TEMPORALS),\n    DEFAULT(false), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(nullptr),\n    ON_UPDATE(nullptr), DEPRECATED_VAR(\"\"));\n\nstatic Sys_var_charptr Sys_disabled_storage_engines(\n    \"disabled_storage_engines\",\n    \"Limit CREATE TABLE for the storage engines listed\",\n    READ_ONLY GLOBAL_VAR(opt_disabled_storage_engines), CMD_LINE(REQUIRED_ARG),\n    IN_SYSTEM_CHARSET, DEFAULT(\"\"));\n\nstatic Sys_var_bool Sys_persisted_globals_load(\n    PERSISTED_GLOBALS_LOAD,\n    \"When this option is enabled, config file mysqld-auto.cnf is read \"\n    \"and applied to server, else this file is ignored even if present.\",\n    READ_ONLY NON_PERSIST GLOBAL_VAR(persisted_globals_load), CMD_LINE(OPT_ARG),\n    DEFAULT(true), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(nullptr),\n    ON_UPDATE(nullptr));\n\nstatic bool sysvar_check_authid_string(sys_var *, THD *thd, set_var *var) {\n  /*\n    Since mandatory_roles is similar to a GRANT role statement without a\n    GRANT ADMIN privilege, setting this variable requires both the\n    ROLE_ADMIN and the SYSTEM_VARIABLES_ADMIN.\n  */\n  Security_context *sctx = thd->security_context();\n  DBUG_ASSERT(sctx != nullptr);\n  if (sctx && !sctx->has_global_grant(STRING_WITH_LEN(\"ROLE_ADMIN\")).first) {\n    my_error(ER_SPECIFIC_ACCESS_DENIED_ERROR, MYF(0),\n             \"SYSTEM_VARIABLES_ADMIN or SUPER privileges, as well as the \"\n             \"ROLE_ADMIN\");\n    /* No privilege access error */\n    return true;\n  }\n  if (var->save_result.string_value.str == nullptr) {\n    var->save_result.string_value.str = const_cast<char *>(\"\");\n    var->save_result.string_value.length = 0;\n  }\n  return check_authorization_id_string(thd, var->save_result.string_value);\n}\n\nstatic bool sysvar_update_mandatory_roles(sys_var *, THD *, enum_var_type) {\n  update_mandatory_roles();\n  return false;\n}\n\nstatic PolyLock_mutex PLock_sys_mandatory_roles(&LOCK_mandatory_roles);\nstatic Sys_var_lexstring Sys_mandatory_roles(\n    \"mandatory_roles\",\n    \"All the specified roles are always considered granted to every user and \"\n    \"they\"\n    \" can't be revoked. Mandatory roles still require activation unless they \"\n    \"are made into \"\n    \"default roles. The granted roles will not be visible in the \"\n    \"mysql.role_edges\"\n    \" table.\",\n    GLOBAL_VAR(opt_mandatory_roles), CMD_LINE(REQUIRED_ARG), IN_SYSTEM_CHARSET,\n    DEFAULT(\"\"), &PLock_sys_mandatory_roles, NOT_IN_BINLOG,\n    ON_CHECK(sysvar_check_authid_string),\n    ON_UPDATE(sysvar_update_mandatory_roles));\n\nstatic Sys_var_bool Sys_always_activate_granted_roles(\n    \"activate_all_roles_on_login\",\n    \"Automatically set all granted roles as active after the user has \"\n    \"authenticated successfully.\",\n    GLOBAL_VAR(opt_always_activate_granted_roles), CMD_LINE(OPT_ARG),\n    DEFAULT(false), NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(nullptr),\n    ON_UPDATE(nullptr));\n\nstatic PolyLock_mutex plock_sys_password_history(&LOCK_password_history);\nstatic Sys_var_uint Sys_password_history(\n    \"password_history\",\n    \"The number of old passwords to check in the history.\"\n    \" Set to 0 (the default) to turn the checks off\",\n    GLOBAL_VAR(global_password_history), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(0, UINT_MAX32), DEFAULT(0), BLOCK_SIZE(1),\n    &plock_sys_password_history);\n\nstatic PolyLock_mutex plock_sys_password_reuse_interval(\n    &LOCK_password_reuse_interval);\nstatic Sys_var_uint Sys_password_reuse_interval(\n    \"password_reuse_interval\",\n    \"The minimum number of days that need to pass before a password can \"\n    \"be reused. Set to 0 (the default) to turn the checks off\",\n    GLOBAL_VAR(global_password_reuse_interval), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(0, UINT_MAX32), DEFAULT(0), BLOCK_SIZE(1),\n    &plock_sys_password_reuse_interval);\n\nstatic bool check_resultset_metadata(sys_var *, THD *thd, set_var *var) {\n  /*\n    Set @@resultset_metadata to the value other than FULL only if\n    the client supports it.\n  */\n  if (var->save_result.ulonglong_value != RESULTSET_METADATA_FULL &&\n      !thd->get_protocol()->has_client_capability(\n          CLIENT_OPTIONAL_RESULTSET_METADATA)) {\n    my_error(ER_CLIENT_DOES_NOT_SUPPORT, MYF(0), \"optional metadata transfer\");\n    return true;\n  }\n  return false;\n}\n\nstatic const char *resultset_metadata_names[] = {\"NONE\", \"FULL\", NullS};\n\nstatic Sys_var_enum Sys_resultset_metadata(\n    \"resultset_metadata\",\n    \"Controls what meatadata the server will send to the client: \"\n    \"either FULL (default) for all metadata, NONE for no metadata.\",\n    SESSION_ONLY(resultset_metadata), NO_CMD_LINE, resultset_metadata_names,\n    DEFAULT(static_cast<ulong>(RESULTSET_METADATA_FULL)), NO_MUTEX_GUARD,\n    NOT_IN_BINLOG, ON_CHECK(check_resultset_metadata), ON_UPDATE(nullptr));\n\nstatic bool check_binlog_row_value_options(sys_var *self, THD *thd,\n                                           set_var *var) {\n  DBUG_TRACE;\n  if (check_session_admin_outside_trx_outside_sf_outside_sp(self, thd, var))\n    return true;\n  if (var->save_result.ulonglong_value != 0) {\n    const char *msg = nullptr;\n    int code = ER_WARN_BINLOG_PARTIAL_UPDATES_DISABLED;\n    if (!mysql_bin_log.is_open())\n      msg = \"the binary log is closed\";\n    else if (!var->is_global_persist()) {\n      if (!thd->variables.sql_log_bin)\n        msg = \"the binary log is disabled\";\n      else if (thd->variables.binlog_format == BINLOG_FORMAT_STMT)\n        msg = \"binlog_format=STATEMENT\";\n      else if (log_bin_use_v1_row_events) {\n        msg = \"binlog_row_value_options=PARTIAL_JSON\";\n        code = ER_WARN_BINLOG_V1_ROW_EVENTS_DISABLED;\n      } else if (thd->variables.binlog_row_image == BINLOG_ROW_IMAGE_FULL) {\n        msg = \"binlog_row_image=FULL\";\n        code = ER_WARN_BINLOG_PARTIAL_UPDATES_SUGGESTS_PARTIAL_IMAGES;\n      }\n    } else {\n      if (global_system_variables.binlog_format == BINLOG_FORMAT_STMT)\n        msg = \"binlog_format=STATEMENT\";\n      else if (log_bin_use_v1_row_events) {\n        msg = \"binlog_row_value_options=PARTIAL_JSON\";\n        code = ER_WARN_BINLOG_V1_ROW_EVENTS_DISABLED;\n      } else if (global_system_variables.binlog_row_image ==\n                 BINLOG_ROW_IMAGE_FULL) {\n        msg = \"binlog_row_image=FULL\";\n        code = ER_WARN_BINLOG_PARTIAL_UPDATES_SUGGESTS_PARTIAL_IMAGES;\n      }\n    }\n    if (msg) {\n      switch (code) {\n        case ER_WARN_BINLOG_PARTIAL_UPDATES_DISABLED:\n          push_warning_printf(\n              thd, Sql_condition::SL_WARNING, code,\n              ER_THD(thd, ER_WARN_BINLOG_PARTIAL_UPDATES_DISABLED), msg,\n              \"PARTIAL_JSON\");\n          break;\n        case ER_WARN_BINLOG_PARTIAL_UPDATES_SUGGESTS_PARTIAL_IMAGES:\n          push_warning_printf(\n              thd, Sql_condition::SL_WARNING, code,\n              ER_THD(thd,\n                     ER_WARN_BINLOG_PARTIAL_UPDATES_SUGGESTS_PARTIAL_IMAGES),\n              msg, \"PARTIAL_JSON\");\n          break;\n        case ER_WARN_BINLOG_V1_ROW_EVENTS_DISABLED:\n          push_warning_printf(\n              thd, Sql_condition::SL_WARNING, code,\n              ER_THD(thd, ER_WARN_BINLOG_V1_ROW_EVENTS_DISABLED), msg);\n          break;\n        default:\n          DBUG_ASSERT(0); /* purecov: deadcode */\n      }\n    }\n  }\n\n  return false;\n}\n\nconst char *binlog_row_value_options_names[] = {\"PARTIAL_JSON\", nullptr};\nstatic Sys_var_set Sys_binlog_row_value_options(\n    \"binlog_row_value_options\",\n    \"When set to PARTIAL_JSON, this option enables a space-efficient \"\n    \"row-based binary log format for UPDATE statements that modify a \"\n    \"JSON value using only the functions JSON_SET, JSON_REPLACE, and \"\n    \"JSON_REMOVE. For such updates, only the modified parts of the \"\n    \"JSON document are included in the binary log, so small changes of \"\n    \"big documents may need significantly less space.\",\n    SESSION_VAR(binlog_row_value_options), CMD_LINE(REQUIRED_ARG),\n    binlog_row_value_options_names, DEFAULT(0), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n    ON_CHECK(check_binlog_row_value_options));\n\nstatic bool check_keyring_access(sys_var *, THD *thd, set_var *) {\n  if (!thd->security_context()->check_access(SUPER_ACL) &&\n      !(thd->security_context()\n            ->has_global_grant(STRING_WITH_LEN(\"ENCRYPTION_KEY_ADMIN\"))\n            .first)) {\n    my_error(ER_KEYRING_ACCESS_DENIED_ERROR, MYF(0),\n             \"SUPER or ENCRYPTION_KEY_ADMIN\");\n    return true;\n  }\n  return false;\n}\n\n/**\n  This is a mutex used to protect global variable @@keyring_operations.\n*/\nstatic PolyLock_mutex PLock_keyring_operations(&LOCK_keyring_operations);\n/**\n  This variable provides access to keyring service APIs. When this variable\n  is disabled calls to keyring_key_generate(), keyring_key_store() and\n  keyring_key_remove() will report error until this variable is enabled.\n  This variable is protected under a mutex named PLock_keyring_operations.\n  To access this variable you must first set this mutex.\n\n  @sa PLock_keyring_operations\n*/\nstatic Sys_var_bool Sys_keyring_operations(\n    \"keyring_operations\",\n    \"This variable provides access to keyring service APIs. When this \"\n    \"option is disabled calls to keyring_key_generate(), keyring_key_store() \"\n    \"and keyring_key_remove() will report error until this variable is \"\n    \"enabled.\",\n    NON_PERSIST GLOBAL_VAR(opt_keyring_operations), NO_CMD_LINE, DEFAULT(true),\n    &PLock_keyring_operations, NOT_IN_BINLOG, ON_CHECK(check_keyring_access),\n    ON_UPDATE(nullptr));\n\nstatic bool check_default_collation_for_utf8mb4(sys_var *self, THD *thd,\n                                                set_var *var) {\n  if (check_collation_not_null(self, thd, var)) {\n    return true;\n  }\n\n  if (!var->value)\n    var->save_result.ptr = reinterpret_cast<void *>(self->get_default());\n\n  auto cs = static_cast<const CHARSET_INFO *>(var->save_result.ptr);\n  if (cs == &my_charset_utf8mb4_0900_ai_ci ||\n      cs == &my_charset_utf8mb4_general_ci)\n    return false;\n\n  my_error(ER_INVALID_DEFAULT_UTF8MB4_COLLATION, MYF(0), cs->name);\n  return true;\n}\n\nstatic Sys_var_struct<CHARSET_INFO, Get_name> Sys_default_collation_for_utf8mb4(\n    \"default_collation_for_utf8mb4\",\n    \"Controls default collation for utf8mb4 while replicating implicit \"\n    \"utf8mb4 collations.\",\n    SESSION_VAR(default_collation_for_utf8mb4), NO_CMD_LINE,\n    DEFAULT(&my_charset_utf8mb4_0900_ai_ci), NO_MUTEX_GUARD, IN_BINLOG,\n    ON_CHECK(check_default_collation_for_utf8mb4),\n    ON_UPDATE(update_deprecated));\n\nstatic Sys_var_bool Sys_show_create_table_verbosity(\n    \"show_create_table_verbosity\",\n    \"When this option is enabled, it increases the verbosity of \"\n    \"'SHOW CREATE TABLE'.\",\n    SESSION_VAR(show_create_table_verbosity), CMD_LINE(OPT_ARG), DEFAULT(false),\n    NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(nullptr), ON_UPDATE(nullptr));\n\nstatic const char *use_secondary_engine_values[] = {\"OFF\", \"ON\", \"FORCED\",\n                                                    nullptr};\nstatic Sys_var_enum Sys_use_secondary_engine(\n    \"use_secondary_engine\",\n    \"Controls preparation of SELECT statements against secondary storage \"\n    \"engine. Valid values: OFF/ON/FORCED. OFF = Prepare only against primary \"\n    \"storage engine. ON = First prepare against secondary storage engine, \"\n    \"reprepare against primary storage engine if error. FORCED = Prepare all \"\n    \"SELECT statements referencing one or more base tables only against \"\n    \"secondary storage engine.\",\n    HINT_UPDATEABLE SESSION_ONLY(use_secondary_engine), NO_CMD_LINE,\n    use_secondary_engine_values, DEFAULT(SECONDARY_ENGINE_ON), NO_MUTEX_GUARD,\n    NOT_IN_BINLOG, ON_CHECK(nullptr), ON_UPDATE(nullptr));\n\n/**\n  Cost threshold for executing queries in a secondary storage engine. Only\n  queries that have an estimated cost above this value will be attempted\n  executed in a secondary storage engine.\n\n  Secondary storage engines are meant to accelerate queries that would otherwise\n  take a relatively long time to execute. If a secondary storage engine accepts\n  a query, it is assumed that it will be able to accelerate it. However, if the\n  estimated cost of the query is low, the query will execute fast in the primary\n  engine too, so there is little to gain by offloading the query to the\n  secondary engine.\n\n  The default value aims to avoid use of secondary storage engines for queries\n  that could be executed by the primary engine in a few tenths of seconds or\n  less, and attempt to use secondary storage engines for queries would take\n  seconds or more.\n*/\nstatic Sys_var_double Sys_secondary_engine_cost_threshold(\n    \"secondary_engine_cost_threshold\",\n    \"Controls which statements to consider for execution in a secondary \"\n    \"storage engine. Only statements that have a cost estimate higher than \"\n    \"this value will be attempted executed in a secondary storage engine.\",\n    HINT_UPDATEABLE SESSION_VAR(secondary_engine_cost_threshold),\n    CMD_LINE(OPT_ARG), VALID_RANGE(0, DBL_MAX), DEFAULT(100000), NO_MUTEX_GUARD,\n    NOT_IN_BINLOG, ON_CHECK(nullptr), ON_UPDATE(nullptr));\n\nstatic Sys_var_bool Sys_sql_require_primary_key{\n    \"sql_require_primary_key\",\n    \"When set, tables must be created with a primary key, and an existing \"\n    \"primary key cannot be removed with 'ALTER TABLE'. Attempts to do so \"\n    \"will result in an error.\",\n    HINT_UPDATEABLE SESSION_VAR(sql_require_primary_key),\n    CMD_LINE(OPT_ARG),\n    DEFAULT(false),\n    NO_MUTEX_GUARD,\n    IN_BINLOG,\n    ON_CHECK(check_session_admin)};\n\nstatic Sys_var_charptr Sys_sys_variables_admin_subject(\n    PERSIST_ONLY_ADMIN_X509_SUBJECT,\n    \"The client peer certificate name required to enable setting all \"\n    \"system variables via SET PERSIST[_ONLY]\",\n    READ_ONLY NON_PERSIST GLOBAL_VAR(sys_var_persist_only_admin_x509_subject),\n    CMD_LINE(OPT_ARG), IN_SYSTEM_CHARSET, DEFAULT(\"\"));\n\nstatic Sys_var_ulong Sys_binlog_row_event_max_size(\n    \"binlog_row_event_max_size\",\n    \"The maximum size of a row-based binary log event in bytes. Rows will be \"\n    \"grouped into events smaller than this size if possible. \"\n    \"The value has to be a multiple of 256.\",\n    READ_ONLY GLOBAL_VAR(binlog_row_event_max_size), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(256, ULONG_MAX), DEFAULT(8192), BLOCK_SIZE(256));\n\nstatic bool check_group_replication_consistency(sys_var *self, THD *thd,\n                                                set_var *var) {\n  if (var->type == OPT_GLOBAL || var->type == OPT_PERSIST) {\n    Security_context *sctx = thd->security_context();\n    if (!sctx->check_access(SUPER_ACL) &&\n        !sctx->has_global_grant(STRING_WITH_LEN(\"GROUP_REPLICATION_ADMIN\"))\n             .first) {\n      my_error(ER_SPECIFIC_ACCESS_DENIED_ERROR, MYF(0),\n               \"SUPER or GROUP_REPLICATION_ADMIN\");\n      return true;\n    }\n  }\n\n  return check_outside_trx(self, thd, var);\n}\n\nstatic const char *group_replication_consistency_names[] = {\n    \"EVENTUAL\", \"BEFORE_ON_PRIMARY_FAILOVER\", \"BEFORE\",\n    \"AFTER\",    \"BEFORE_AND_AFTER\",           NullS};\n\nstatic Sys_var_enum Sys_group_replication_consistency(\n    \"group_replication_consistency\",\n    \"Transaction consistency guarantee, possible values: EVENTUAL, \"\n    \"BEFORE_ON_PRIMARY_FAILOVER, BEFORE, AFTER, BEFORE_AND_AFTER\",\n    SESSION_VAR(group_replication_consistency), CMD_LINE(OPT_ARG),\n    group_replication_consistency_names,\n    DEFAULT(GROUP_REPLICATION_CONSISTENCY_EVENTUAL), NO_MUTEX_GUARD,\n    NOT_IN_BINLOG, ON_CHECK(check_group_replication_consistency),\n    ON_UPDATE(nullptr));\n\nstatic bool check_binlog_encryption_admin(sys_var *, THD *thd, set_var *) {\n  DBUG_TRACE;\n  if (!thd->security_context()->check_access(SUPER_ACL) &&\n      !(thd->security_context()\n            ->has_global_grant(STRING_WITH_LEN(\"BINLOG_ENCRYPTION_ADMIN\"))\n            .first)) {\n    my_error(ER_SPECIFIC_ACCESS_DENIED_ERROR, MYF(0),\n             \"SUPER or BINLOG_ENCRYPTION_ADMIN\");\n    return true;\n  }\n  return false;\n}\n\nbool Sys_var_binlog_encryption::global_update(THD *thd, set_var *var) {\n  DBUG_TRACE;\n\n  /* No-op if trying to set to current value */\n  bool new_value = var->save_result.ulonglong_value;\n  if (new_value == rpl_encryption.is_enabled()) return false;\n\n  DEBUG_SYNC(thd, \"after_locking_global_sys_var_set_binlog_enc\");\n  /* We unlock in following statement to avoid deadlock involving following\n   * conditions.\n   * ------------------------------------------------------------------------\n   * Thread 1 (START SLAVE)  has locked channel_map and waiting for cond_wait\n   * that is supposed to be done by Thread 2.\n   *\n   * Thread 2 (handle_slave_io) is supposed to signal Thread 1 but waiting to\n   * lock LOCK_global_system_variables.\n   *\n   * Thread 3 (SET GLOBAL binlog_encryption=ON|OFF) has locked\n   * LOCK_global_system_variables and waiting for channel_map.\n   */\n  mysql_mutex_unlock(&LOCK_global_system_variables);\n  /* Set the option new value */\n  bool res = false;\n  if (new_value)\n    res = rpl_encryption.enable(thd);\n  else\n    rpl_encryption.disable(thd);\n  mysql_mutex_lock(&LOCK_global_system_variables);\n  return res;\n}\n\nstatic Sys_var_binlog_encryption Sys_binlog_encryption(\n    \"binlog_encryption\", \"Enable/disable binary and relay logs encryption.\",\n    GLOBAL_VAR(rpl_encryption.get_enabled_var()), CMD_LINE(OPT_ARG),\n    DEFAULT(false), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n    ON_CHECK(check_binlog_encryption_admin));\n\nstatic Sys_var_bool Sys_binlog_rotate_encryption_master_key_at_startup(\n    \"binlog_rotate_encryption_master_key_at_startup\",\n    \"Force binlog encryption master key rotation at startup\",\n    READ_ONLY GLOBAL_VAR(\n        rpl_encryption.get_master_key_rotation_at_startup_var()),\n    CMD_LINE(OPT_ARG), DEFAULT(false), NO_MUTEX_GUARD, NOT_IN_BINLOG);\n\nstatic Sys_var_uint Sys_original_server_version(\n    \"original_server_version\",\n    \"The version of the server where the transaction was originally executed\",\n    SESSION_ONLY(original_server_version), NO_CMD_LINE,\n    VALID_RANGE(0, UNDEFINED_SERVER_VERSION), DEFAULT(UNDEFINED_SERVER_VERSION),\n    BLOCK_SIZE(1), NO_MUTEX_GUARD, IN_BINLOG,\n    ON_CHECK(check_session_admin_or_replication_applier));\n\nstatic Sys_var_uint Sys_immediate_server_version(\n    \"immediate_server_version\",\n    \"The server version of the immediate server in the replication topology\",\n    SESSION_ONLY(immediate_server_version), NO_CMD_LINE,\n    VALID_RANGE(0, UNDEFINED_SERVER_VERSION), DEFAULT(UNDEFINED_SERVER_VERSION),\n    BLOCK_SIZE(1), NO_MUTEX_GUARD, IN_BINLOG,\n    ON_CHECK(check_session_admin_or_replication_applier));\n\nstatic bool check_set_default_table_encryption_access(\n    sys_var *self MY_ATTRIBUTE((unused)), THD *thd, set_var *var) {\n  DBUG_EXECUTE_IF(\"skip_table_encryption_admin_check_for_set\",\n                  { return false; });\n  if ((var->type == OPT_GLOBAL || var->type == OPT_PERSIST) &&\n      is_group_replication_running()) {\n    my_message(ER_GROUP_REPLICATION_RUNNING,\n               \"The default_table_encryption option cannot be changed when \"\n               \"Group replication is running.\",\n               MYF(0));\n    return true;\n  }\n\n  // Should own one of SUPER or both (SYSTEM_VARIABLES_ADMIN and\n  // TABLE_ENCRYPTION_ADMIN), unless this is the session option and\n  // the value is unchanged.\n  longlong previous_val = thd->variables.default_table_encryption;\n  longlong val = (longlong)var->save_result.ulonglong_value;\n  if ((!var->is_global_persist() && val == previous_val) ||\n      thd->security_context()->check_access(SUPER_ACL) ||\n      (thd->security_context()\n           ->has_global_grant(STRING_WITH_LEN(\"SYSTEM_VARIABLES_ADMIN\"))\n           .first &&\n       thd->security_context()\n           ->has_global_grant(STRING_WITH_LEN(\"TABLE_ENCRYPTION_ADMIN\"))\n           .first)) {\n    return false;\n  }\n\n  my_error(ER_SPECIFIC_ACCESS_DENIED_ERROR, MYF(0),\n           \"SUPER or SYSTEM_VARIABLES_ADMIN and TABLE_ENCRYPTION_ADMIN\");\n  return true;\n}\n\nstatic const char *default_table_encryption_type_names[] = {\n    \"OFF\", \"ON\", \"ONLINE_TO_KEYRING\", \"ONLINE_FROM_KEYRING_TO_UNENCRYPTED\",\n    nullptr};\n\nbool Sys_var_enum_default_table_encryption::global_update(THD *, set_var *var) {\n  global_var(ulong) = var->save_result.ulonglong_value;\n\n  static const LEX_CSTRING innodb_engine{STRING_WITH_LEN(\"innodb\")};\n\n  plugin_ref plugin;\n  if ((plugin = ha_resolve_by_name(nullptr, &innodb_engine, false))) {\n    handlerton *hton = plugin_data<handlerton *>(plugin);\n    hton->fix_default_table_encryption(var->save_result.ulonglong_value);\n    plugin_unlock(nullptr, plugin);\n  }\n\n  return 0;\n}\n\nstatic Sys_var_enum_default_table_encryption Sys_default_table_encryption(\n    \"default_table_encryption\",\n    \"Database and tablespace are created with this default encryption property \"\n    \"unless the user specifies an explicit encryption property.\",\n    HINT_UPDATEABLE SESSION_VAR(default_table_encryption), CMD_LINE(OPT_ARG),\n    default_table_encryption_type_names, DEFAULT(DEFAULT_TABLE_ENC_OFF),\n    NO_MUTEX_GUARD, IN_BINLOG,\n    ON_CHECK(check_set_default_table_encryption_access));\n\nstatic bool check_set_table_encryption_privilege_access(sys_var *, THD *thd,\n                                                        set_var *) {\n  DBUG_EXECUTE_IF(\"skip_table_encryption_admin_check_for_set\",\n                  { return false; });\n  if (!thd->security_context()->check_access(SUPER_ACL)) {\n    my_error(ER_SPECIFIC_ACCESS_DENIED_ERROR, MYF(0), \"SUPER\");\n    return true;\n  }\n  return false;\n}\n\nstatic Sys_var_bool Sys_table_encryption_privilege_check(\n    \"table_encryption_privilege_check\",\n    \"Indicates if server enables privilege check when user tries to use \"\n    \"non-default value for CREATE DATABASE or CREATE TABLESPACE or when \"\n    \"user tries to do CREATE TABLE with ENCRYPTION option which deviates \"\n    \"from per-database default.\",\n    GLOBAL_VAR(opt_table_encryption_privilege_check), CMD_LINE(OPT_ARG),\n    DEFAULT(false), NO_MUTEX_GUARD, NOT_IN_BINLOG,\n    ON_CHECK(check_set_table_encryption_privilege_access), ON_UPDATE(nullptr));\n\nstatic Sys_var_bool Sys_var_print_identified_with_as_hex(\n    \"print_identified_with_as_hex\",\n    \"SHOW CREATE USER will print the AS clause as HEX if it contains \"\n    \"non-prinable characters\",\n    SESSION_VAR(print_identified_with_as_hex), CMD_LINE(OPT_ARG),\n    DEFAULT(false));\n\n/**\n   Session only flag to skip printing secondary engine in SHOW CREATE\n   TABLE.\n\n   @sa store_create_info\n*/\nstatic Sys_var_bool Sys_var_show_create_table_skip_secondary_engine(\n    \"show_create_table_skip_secondary_engine\",\n    \"SHOW CREATE TABLE will skip SECONDARY_ENGINE when printing the table \"\n    \"definition\",\n    SESSION_ONLY(show_create_table_skip_secondary_engine), NO_CMD_LINE,\n    DEFAULT(false));\n\nstatic Sys_var_uint Sys_generated_random_password_length(\n    \"generated_random_password_length\",\n    \"Determines the length randomly generated passwords in CREATE USER-,\"\n    \"SET PASSWORD- or ALTER USER statements\",\n    SESSION_VAR(generated_random_password_length), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(5, 255), DEFAULT(20), BLOCK_SIZE(1), NO_MUTEX_GUARD, IN_BINLOG,\n    ON_CHECK(nullptr));\n\nstatic bool check_set_protocol_compression_algorithms(sys_var *, THD *,\n                                                      set_var *var) {\n  if (!(var->save_result.string_value.str)) return true;\n  return validate_compression_attributes(var->save_result.string_value.str,\n                                         std::string(), true);\n}\n\nstatic Sys_var_charptr Sys_protocol_compression_algorithms(\n    \"protocol_compression_algorithms\",\n    \"List of compression algorithms supported by server. Supported values \"\n    \"are any combination of zlib, zstd, uncompressed. Command line clients \"\n    \"may use the --compression-algorithms flag to specify a set of algorithms, \"\n    \"and the connection will use an algorithm supported by both client and \"\n    \"server. It picks zlib if both client and server support it; otherwise it \"\n    \"picks zstd if both support it; otherwise it picks uncompressed if both \"\n    \"support it; otherwise it fails.\",\n    GLOBAL_VAR(opt_protocol_compression_algorithms), CMD_LINE(REQUIRED_ARG),\n    IN_FS_CHARSET,\n    DEFAULT(const_cast<char *>(PROTOCOL_COMPRESSION_DEFAULT_VALUE)),\n    NO_MUTEX_GUARD, NOT_IN_BINLOG,\n    ON_CHECK(check_set_protocol_compression_algorithms), ON_UPDATE(nullptr));\n\nstatic bool check_set_require_row_format(sys_var *, THD *thd, set_var *var) {\n  /*\n   Should own SUPER or SYSTEM_VARIABLES_ADMIN or SESSION_VARIABLES_ADMIN\n   when the value is changing to NO, no privileges are needed to set to YES\n  */\n  longlong previous_val = thd->variables.require_row_format;\n  longlong val = (longlong)var->save_result.ulonglong_value;\n  DBUG_ASSERT(!var->is_global_persist());\n\n  // if it was true and we are changing it\n  if (previous_val && val != previous_val) {\n    if (thd->security_context()->check_access(SUPER_ACL) ||\n        thd->security_context()\n            ->has_global_grant(STRING_WITH_LEN(\"SYSTEM_VARIABLES_ADMIN\"))\n            .first ||\n        thd->security_context()\n            ->has_global_grant(STRING_WITH_LEN(\"SESSION_VARIABLES_ADMIN\"))\n            .first)\n      return false;\n\n    my_error(ER_SPECIFIC_ACCESS_DENIED_ERROR, MYF(0),\n             \"SUPER or SYSTEM_VARIABLES_ADMIN or SESSION_VARIABLES_ADMIN\");\n    return true;\n  }\n  return false;\n}\n\n/**\n   Session only flag to limit the application of queries to row based events\n   and DDLs with the exception of temporary table creation/deletion\n*/\nstatic Sys_var_bool Sys_var_require_row_format(\n    \"require_row_format\",\n    \"Limit the application of queries to row based events \"\n    \"and DDLs with the exception of temporary table creation/deletion.\",\n    SESSION_ONLY(require_row_format), NO_CMD_LINE, DEFAULT(false),\n    NO_MUTEX_GUARD, NOT_IN_BINLOG, ON_CHECK(check_set_require_row_format));\n\nstatic Sys_var_ulonglong Sys_tf_sequence_table_max_upper_bound(\n    \"tf_sequence_table_max_upper_bound\",\n    \"Maximum number of records SEQUENCE_TABLE() table function \"\n    \"is allowed to generate.\",\n    GLOBAL_VAR(tf_sequence_table_max_upper_bound), CMD_LINE(REQUIRED_ARG),\n    VALID_RANGE(1024, ULLONG_MAX), DEFAULT(1048576), BLOCK_SIZE(1));\n",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/sql/set_var.h": "#ifndef SET_VAR_INCLUDED\n#define SET_VAR_INCLUDED\n/* Copyright (c) 2002, 2019, Oracle and/or its affiliates. All rights reserved.\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License, version 2.0,\n   as published by the Free Software Foundation.\n\n   This program is also distributed with certain software (including\n   but not limited to OpenSSL) that is licensed under separate terms,\n   as designated in a particular file or component or in included license\n   documentation.  The authors of MySQL hereby grant you an additional\n   permission to link the program and your derivative works with the\n   separately licensed software that they have included with MySQL.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License, version 2.0, for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA */\n\n/**\n  @file\n  \"public\" interface to sys_var - server configuration variables.\n*/\n\n#include \"my_config.h\"\n\n#include <stddef.h>\n#include <string.h>\n#include <sys/types.h>\n#include <string>\n#include <vector>\n\n#include \"lex_string.h\"\n#include \"m_ctype.h\"\n#include \"my_getopt.h\"    // get_opt_arg_type\n#include \"my_hostname.h\"  // HOSTNAME_LENGTH\n#include \"my_inttypes.h\"\n#include \"my_sys.h\"\n#include \"my_systime.h\"  // my_micro_time()\n#include \"mysql/components/services/system_variable_source_type.h\"\n#include \"mysql/status_var.h\"\n#include \"mysql/udf_registration_types.h\"\n#include \"mysql_com.h\"           // Item_result\n#include \"prealloced_array.h\"    // Prealloced_array\n#include \"sql/sql_const.h\"       // SHOW_COMP_OPTION\n#include \"sql/sql_plugin_ref.h\"  // plugin_ref\n#include \"typelib.h\"             // TYPELIB\n\nclass Item;\nclass Item_func_set_user_var;\nclass PolyLock;\nclass String;\nclass THD;\nclass Time_zone;\nclass set_var;\nclass sys_var;\nclass sys_var_pluginvar;\nstruct LEX_USER;\ntemplate <class Key, class Value>\nclass collation_unordered_map;\n\ntypedef ulonglong sql_mode_t;\ntypedef enum enum_mysql_show_type SHOW_TYPE;\ntypedef enum enum_mysql_show_scope SHOW_SCOPE;\ntemplate <class T>\nclass List;\n\nextern TYPELIB bool_typelib;\n\n/* Number of system variable elements to preallocate. */\n#define SHOW_VAR_PREALLOC 200\ntypedef Prealloced_array<SHOW_VAR, SHOW_VAR_PREALLOC> Show_var_array;\n\nstruct sys_var_chain {\n  sys_var *first;\n  sys_var *last;\n};\n\nint mysql_add_sys_var_chain(sys_var *chain);\nint mysql_del_sys_var_chain(sys_var *chain);\n\nenum enum_var_type : int {\n  OPT_DEFAULT = 0,\n  OPT_SESSION,\n  OPT_GLOBAL,\n  OPT_PERSIST,\n  OPT_PERSIST_ONLY\n};\n\n/**\n  A class representing one system variable - that is something\n  that can be accessed as @@global.variable_name or @@session.variable_name,\n  visible in SHOW xxx VARIABLES and in INFORMATION_SCHEMA.xxx_VARIABLES,\n  optionally it can be assigned to, optionally it can have a command-line\n  counterpart with the same name.\n*/\nclass sys_var {\n public:\n  sys_var *next;\n  LEX_CSTRING name;\n  enum flag_enum {\n    GLOBAL = 0x0001,\n    SESSION = 0x0002,\n    ONLY_SESSION = 0x0004,\n    SCOPE_MASK = 0x03FF,  // 1023\n    READONLY = 0x0400,    // 1024\n    ALLOCATED = 0x0800,   // 2048\n    INVISIBLE = 0x1000,   // 4096\n    TRI_LEVEL = 0x2000,   // 8192 - default is neither GLOBAL nor SESSION\n    NOTPERSIST = 0x4000,\n    HINT_UPDATEABLE = 0x8000,  // Variable is updateable using SET_VAR hint\n    /**\n     There can be some variables which needs to be set before plugin is loaded.\n     ex: binlog_checksum needs to be set before GR plugin is loaded.\n     Also, there are some variables which needs to be set before some server\n     internal component initialization.\n     ex: binlog_encryption needs to be set before binary and relay log\n     files generation.\n    */\n\n    PERSIST_AS_READ_ONLY = 0x10000\n  };\n  static const int PARSE_EARLY = 1;\n  static const int PARSE_NORMAL = 2;\n  /**\n    Enumeration type to indicate for a system variable whether\n    it will be written to the binlog or not.\n  */\n  enum binlog_status_enum {\n    VARIABLE_NOT_IN_BINLOG,\n    SESSION_VARIABLE_IN_BINLOG\n  } binlog_status;\n\n protected:\n  typedef bool (*on_check_function)(sys_var *self, THD *thd, set_var *var);\n  typedef bool (*on_update_function)(sys_var *self, THD *thd,\n                                     enum_var_type type);\n\n  int flags;                      ///< or'ed flag_enum values\n  int m_parse_flag;               ///< either PARSE_EARLY or PARSE_NORMAL.\n  const SHOW_TYPE show_val_type;  ///< what value_ptr() returns for sql_show.cc\n  my_option option;               ///< min, max, default values are stored here\n  PolyLock *guard;                ///< *second* lock that protects the variable\n  ptrdiff_t offset;  ///< offset to the value from global_system_variables\n  on_check_function on_check;\n  on_update_function on_update;\n  const char *const deprecation_substitute;\n  bool is_os_charset;  ///< true if the value is in character_set_filesystem\n  struct get_opt_arg_source source;\n  char user[USERNAME_CHAR_LENGTH + 1]; /* which user  has set this variable */\n  char host[HOSTNAME_LENGTH + 1];      /* host on which this variable is set */\n  ulonglong timestamp; /* represents when this variable was set */\n\n public:\n  sys_var(sys_var_chain *chain, const char *name_arg, const char *comment,\n          int flag_args, ptrdiff_t off, int getopt_id,\n          enum get_opt_arg_type getopt_arg_type, SHOW_TYPE show_val_type_arg,\n          longlong def_val, PolyLock *lock,\n          enum binlog_status_enum binlog_status_arg,\n          on_check_function on_check_func, on_update_function on_update_func,\n          const char *substitute, int parse_flag);\n\n  virtual ~sys_var() {}\n\n  /**\n    All the cleanup procedures should be performed here\n  */\n  virtual void cleanup() {}\n  /**\n    downcast for sys_var_pluginvar. Returns this if it's an instance\n    of sys_var_pluginvar, and 0 otherwise.\n  */\n  virtual sys_var_pluginvar *cast_pluginvar() { return nullptr; }\n\n  bool check(THD *thd, set_var *var);\n  const uchar *value_ptr(THD *running_thd, THD *target_thd, enum_var_type type,\n                         LEX_STRING *base);\n  const uchar *value_ptr(THD *thd, enum_var_type type, LEX_STRING *base);\n  virtual void update_default(longlong new_def_value) {\n    option.def_value = new_def_value;\n  }\n  longlong get_default() { return option.def_value; }\n  virtual longlong get_min_value() { return option.min_value; }\n  virtual ulonglong get_max_value() { return option.max_value; }\n  /**\n    Returns variable type.\n\n    @return variable type\n  */\n  virtual ulong get_var_type() { return (option.var_type & GET_TYPE_MASK); }\n  virtual void set_arg_source(get_opt_arg_source *) {}\n  virtual void set_is_plugin(bool) {}\n  enum_variable_source get_source() { return source.m_source; }\n  const char *get_source_name() { return source.m_path_name; }\n  void set_source(enum_variable_source src) {\n    option.arg_source->m_source = src;\n  }\n  bool set_source_name(const char *path) {\n    return set_and_truncate(option.arg_source->m_path_name, path,\n                            sizeof(option.arg_source->m_path_name));\n  }\n  bool set_user(const char *usr) {\n    return set_and_truncate(user, usr, sizeof(user));\n  }\n  const char *get_user() { return user; }\n  const char *get_host() { return host; }\n  bool set_host(const char *hst) {\n    return set_and_truncate(host, hst, sizeof(host));\n  }\n  ulonglong get_timestamp() const { return timestamp; }\n  void set_user_host(THD *thd);\n  my_option *get_option() { return &option; }\n  void set_timestamp() { timestamp = my_micro_time(); }\n  void set_timestamp(ulonglong ts) { timestamp = ts; }\n  void clear_user_host_timestamp() {\n    user[0] = '\\0';\n    host[0] = '\\0';\n    timestamp = 0;\n  }\n  virtual bool is_non_persistent() { return flags & NOTPERSIST; }\n\n  /**\n     Update the system variable with the default value from either\n     session or global scope.  The default value is stored in the\n     'var' argument. Return false when successful.\n  */\n  bool set_default(THD *thd, set_var *var);\n  bool update(THD *thd, set_var *var);\n\n  /**\n    This function converts value stored in save_result to string. This\n    function must ba called after calling save_default() as save_default() will\n    store default value to save_result.\n  */\n  virtual void saved_value_to_string(THD *thd, set_var *var, char *def_val) = 0;\n\n  SHOW_TYPE show_type() { return show_val_type; }\n  int scope() const { return flags & SCOPE_MASK; }\n  const CHARSET_INFO *charset(THD *thd);\n  bool is_readonly() const { return flags & READONLY; }\n  bool not_visible() const { return flags & INVISIBLE; }\n  bool is_trilevel() const { return flags & TRI_LEVEL; }\n  bool is_persist_readonly() const { return flags & PERSIST_AS_READ_ONLY; }\n  /**\n    Check if the variable can be set using SET_VAR hint.\n\n    @return true if the variable can be set using SET_VAR hint,\n            false otherwise.\n  */\n  virtual bool is_hint_updateable() const { return flags & HINT_UPDATEABLE; }\n  /**\n    the following is only true for keycache variables,\n    that support the syntax @@keycache_name.variable_name\n  */\n  bool is_struct() { return option.var_type & GET_ASK_ADDR; }\n  bool is_written_to_binlog(enum_var_type type) {\n    return type != OPT_GLOBAL && binlog_status == SESSION_VARIABLE_IN_BINLOG;\n  }\n  virtual bool check_update_type(Item_result type) = 0;\n\n  /**\n    Return true for success if:\n      Global query and variable scope is GLOBAL or SESSION, or\n      Session query and variable scope is SESSION or ONLY_SESSION.\n  */\n  bool check_scope(enum_var_type query_type) {\n    switch (query_type) {\n      case OPT_PERSIST:\n      case OPT_PERSIST_ONLY:\n      case OPT_GLOBAL:\n        return scope() & (GLOBAL | SESSION);\n      case OPT_SESSION:\n        return scope() & (SESSION | ONLY_SESSION);\n      case OPT_DEFAULT:\n        return scope() & (SESSION | ONLY_SESSION);\n    }\n    return false;\n  }\n  bool is_global_persist(enum_var_type type) {\n    return (type == OPT_GLOBAL || type == OPT_PERSIST ||\n            type == OPT_PERSIST_ONLY);\n  }\n\n  /**\n    Return true if settable at the command line\n  */\n  bool is_settable_at_command_line() { return option.id != -1; }\n\n  bool register_option(std::vector<my_option> *array, int parse_flags) {\n    return is_settable_at_command_line() && (m_parse_flag & parse_flags) &&\n           (array->push_back(option), false);\n  }\n  void do_deprecated_warning(THD *thd);\n  /**\n    Create item from system variable session value.\n\n    @param  thd  pointer to THD object\n\n    @return pointer to Item object or NULL if it's\n            impossible to obtain the value.\n  */\n  virtual Item *copy_value(THD *thd);\n\n  void save_default(THD *thd, set_var *var) { global_save_default(thd, var); }\n\n private:\n  inline static bool set_and_truncate(char *dst, const char *string,\n                                      size_t sizeof_dst) {\n    size_t string_length = strlen(string), length;\n    length = std::min(sizeof_dst - 1, string_length);\n    memcpy(dst, string, length);\n    dst[length] = 0;\n    return length < string_length;  // truncated\n  }\n  virtual bool do_check(THD *thd, set_var *var) = 0;\n  /**\n    save the session default value of the variable in var\n  */\n  virtual void session_save_default(THD *thd, set_var *var) = 0;\n  /**\n    save the global default value of the variable in var\n  */\n  virtual void global_save_default(THD *thd, set_var *var) = 0;\n  virtual bool session_update(THD *thd, set_var *var) = 0;\n  virtual bool global_update(THD *thd, set_var *var) = 0;\n\n protected:\n  /**\n    A pointer to a value of the variable for SHOW.\n    It must be of show_val_type type (bool for SHOW_BOOL, int for SHOW_INT,\n    longlong for SHOW_LONGLONG, etc).\n  */\n  virtual const uchar *session_value_ptr(THD *running_thd, THD *target_thd,\n                                         LEX_STRING *base);\n  virtual const uchar *global_value_ptr(THD *thd, LEX_STRING *base);\n\n  /**\n    A pointer to a storage area of the variable, to the raw data.\n    Typically it's the same as session_value_ptr(), but it's different,\n    for example, for ENUM, that is printed as a string, but stored as a number.\n  */\n  uchar *session_var_ptr(THD *thd);\n\n  uchar *global_var_ptr();\n};\n\n/****************************************************************************\n  Classes for parsing of the SET command\n****************************************************************************/\n\n/**\n  A base class for everything that can be set with SET command.\n  It's similar to Items, an instance of this is created by the parser\n  for every assigmnent in SET (or elsewhere, e.g. in SELECT).\n*/\nclass set_var_base {\n public:\n  set_var_base() {}\n  virtual ~set_var_base() {}\n  virtual int resolve(THD *thd) = 0;  ///< Check privileges & fix_fields\n  virtual int check(THD *thd) = 0;    ///< Evaluate the expression\n  virtual int update(THD *thd) = 0;   ///< Set the value\n  virtual void print(const THD *thd, String *str) = 0;  ///< To self-print\n\n  /**\n    @returns whether this variable is @@@@optimizer_trace.\n  */\n  virtual bool is_var_optimizer_trace() const { return false; }\n\n  /**\n    Used only by prepared statements to resolve and check. No locking of tables\n    between the two phases.\n  */\n  virtual int light_check(THD *thd) { return (resolve(thd) || check(thd)); }\n};\n\n/**\n  set_var_base descendant for assignments to the system variables.\n*/\nclass set_var : public set_var_base {\n public:\n  sys_var *var;  ///< system variable to be updated\n  Item *value;   ///< the expression that provides the new value of the variable\n  enum_var_type type;\n  union  ///< temp storage to hold a value between sys_var::check and ::update\n  {\n    ulonglong ulonglong_value;  ///< for all integer, set, enum sysvars\n    double double_value;        ///< for Sys_var_double\n    plugin_ref plugin;          ///< for Sys_var_plugin\n    Time_zone *time_zone;       ///< for Sys_var_tz\n    LEX_STRING string_value;    ///< for Sys_var_charptr and others\n    const void *ptr;            ///< for Sys_var_struct\n  } save_result;\n  LEX_CSTRING\n  base; /**< for structured variables, like keycache_name.variable_name */\n\n  set_var(enum_var_type type_arg, sys_var *var_arg, LEX_CSTRING base_name_arg,\n          Item *value_arg);\n\n  int resolve(THD *thd);\n  int check(THD *thd);\n  int update(THD *thd);\n  void update_source_user_host_timestamp(THD *thd);\n  int light_check(THD *thd);\n  /**\n    Print variable in short form.\n\n    @param thd Thread handle.\n    @param str String buffer to append the partial assignment to.\n  */\n  void print_short(const THD *thd, String *str);\n  void print(const THD *, String *str); /* To self-print */\n  bool is_global_persist() {\n    return (type == OPT_GLOBAL || type == OPT_PERSIST ||\n            type == OPT_PERSIST_ONLY);\n  }\n  virtual bool is_var_optimizer_trace() const {\n    extern sys_var *Sys_optimizer_trace_ptr;\n    return var == Sys_optimizer_trace_ptr;\n  }\n};\n\n/* User variables like @my_own_variable */\nclass set_var_user : public set_var_base {\n  Item_func_set_user_var *user_var_item;\n\n public:\n  set_var_user(Item_func_set_user_var *item) : user_var_item(item) {}\n  int resolve(THD *thd);\n  int check(THD *thd);\n  int update(THD *thd);\n  int light_check(THD *thd);\n  void print(const THD *thd, String *str); /* To self-print */\n};\n\nclass set_var_password : public set_var_base {\n  LEX_USER *user;\n  char *password;\n  const char *current_password;\n  bool retain_current_password;\n  bool generate_password;\n  char *str_generated_password;\n\n public:\n  set_var_password(LEX_USER *user_arg, char *password_arg,\n                   char *current_password_arg, bool retain_current,\n                   bool generate_password);\n\n  const LEX_USER *get_user(void) { return user; }\n  bool has_generated_password(void) { return generate_password; }\n  const char *get_generated_password(void) { return str_generated_password; }\n  int resolve(THD *) { return 0; }\n  int check(THD *thd);\n  int update(THD *thd);\n  void print(const THD *thd, String *str); /* To self-print */\n  virtual ~set_var_password();\n};\n\n/* For SET NAMES and SET CHARACTER SET */\n\nclass set_var_collation_client : public set_var_base {\n  int set_cs_flags;\n  const CHARSET_INFO *character_set_client;\n  const CHARSET_INFO *character_set_results;\n  const CHARSET_INFO *collation_connection;\n\n public:\n  enum set_cs_flags_enum {\n    SET_CS_NAMES = 1,\n    SET_CS_DEFAULT = 2,\n    SET_CS_COLLATE = 4\n  };\n  set_var_collation_client(int set_cs_flags_arg,\n                           const CHARSET_INFO *client_coll_arg,\n                           const CHARSET_INFO *connection_coll_arg,\n                           const CHARSET_INFO *result_coll_arg)\n      : set_cs_flags(set_cs_flags_arg),\n        character_set_client(client_coll_arg),\n        character_set_results(result_coll_arg),\n        collation_connection(connection_coll_arg) {}\n  int resolve(THD *) { return 0; }\n  int check(THD *thd);\n  int update(THD *thd);\n  void print(const THD *thd, String *str); /* To self-print */\n};\n\n/* optional things, have_* variables */\nextern SHOW_COMP_OPTION have_profiling;\n\nextern SHOW_COMP_OPTION have_symlink, have_dlopen;\nextern SHOW_COMP_OPTION have_query_cache;\nextern SHOW_COMP_OPTION have_geometry, have_rtree_keys;\nextern SHOW_COMP_OPTION have_compress;\nextern SHOW_COMP_OPTION have_statement_timeout;\nextern SHOW_COMP_OPTION have_backup_locks;\nextern SHOW_COMP_OPTION have_backup_safe_binlog_info;\nextern SHOW_COMP_OPTION have_snapshot_cloning;\n\n/*\n  Helper functions\n*/\nulong get_system_variable_hash_records(void);\nulonglong get_system_variable_hash_version(void);\ncollation_unordered_map<std::string, sys_var *> *get_system_variable_hash(void);\n\nextern bool get_sysvar_source(const char *name, uint length,\n                              enum enum_variable_source *source);\n\nbool enumerate_sys_vars(Show_var_array *show_var_array, bool sort,\n                        enum enum_var_type type, bool strict);\nvoid lock_plugin_mutex();\nvoid unlock_plugin_mutex();\nsys_var *find_sys_var(THD *thd, const char *str, size_t length = 0);\nsys_var *find_sys_var_ex(THD *thd, const char *str, size_t length = 0,\n                         bool throw_error = false, bool locked = false);\nMY_NODISCARD\nint sql_set_variables(THD *thd, List<set_var_base> *var_list, bool opened);\nbool keyring_access_test();\nbool fix_delay_key_write(sys_var *self, THD *thd, enum_var_type type);\n\nsql_mode_t expand_sql_mode(sql_mode_t sql_mode, THD *thd);\nbool sql_mode_string_representation(THD *thd, sql_mode_t sql_mode,\n                                    LEX_STRING *ls);\nbool sql_mode_quoted_string_representation(THD *thd, sql_mode_t sql_mode,\n                                           LEX_STRING *ls);\nvoid update_parser_max_mem_size();\n\nextern sys_var *Sys_autocommit_ptr;\nextern sys_var *Sys_gtid_next_ptr;\nextern sys_var *Sys_gtid_next_list_ptr;\nextern sys_var *Sys_gtid_purged_ptr;\n\nextern ulonglong system_variable_hash_version;\n\nconst CHARSET_INFO *get_old_charset_by_name(const char *old_name);\n\nint sys_var_init();\nint sys_var_add_options(std::vector<my_option> *long_options, int parse_flags);\nvoid sys_var_end(void);\n\n/* check needed privileges to perform SET PERSIST[_only] or RESET PERSIST */\nbool check_priv(THD *thd, bool static_variable);\n\n#define PERSIST_ONLY_ADMIN_X509_SUBJECT \"persist_only_admin_x509_subject\"\n#define PERSISTED_GLOBALS_LOAD \"persisted_globals_load\"\nextern char *sys_var_persist_only_admin_x509_subject;\n\nextern void init_log_slow_verbosity() noexcept;\nextern void init_slow_query_log_use_global_control() noexcept;\nextern void init_log_slow_sp_statements() noexcept;\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/sql/sql_udf.cc": "/* Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License, version 2.0,\n   as published by the Free Software Foundation.\n\n   This program is also distributed with certain software (including\n   but not limited to OpenSSL) that is licensed under separate terms,\n   as designated in a particular file or component or in included license\n   documentation.  The authors of MySQL hereby grant you an additional\n   permission to link the program and your derivative works with the\n   separately licensed software that they have included with MySQL.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License, version 2.0, for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA */\n\n/* This implements 'user defined functions' */\n\n#include \"sql/sql_udf.h\"\n\n#include \"my_config.h\"\n\n#include <stdio.h>\n#include <string.h>\n#include <iterator>\n#include <memory>\n#include <new>\n#include <string>\n#include <unordered_map>\n#include <utility>\n\n#include \"m_ctype.h\"\n#include \"m_string.h\"  // my_stpcpy\n#include \"map_helpers.h\"\n#include \"my_alloc.h\"\n#include \"my_base.h\"\n#include \"my_dbug.h\"\n#include \"my_inttypes.h\"\n#include \"my_io.h\"\n#include \"my_loglevel.h\"\n#include \"my_macros.h\"\n#include \"my_psi_config.h\"\n#include \"my_sharedlib.h\"\n#include \"my_sys.h\"\n#include \"my_thread_local.h\"\n#include \"mysql/components/service_implementation.h\"\n#include \"mysql/components/services/log_builtins.h\"\n#include \"mysql/components/services/log_shared.h\"\n#include \"mysql/components/services/mysql_rwlock_bits.h\"\n#include \"mysql/components/services/psi_memory_bits.h\"\n#include \"mysql/components/services/psi_rwlock_bits.h\"\n#include \"mysql/psi/mysql_memory.h\"\n#include \"mysql/psi/mysql_rwlock.h\"\n#include \"mysql/psi/psi_base.h\"\n#include \"mysql_com.h\"\n#include \"mysqld_error.h\"  // ER_*\n#include \"sql/field.h\"\n#include \"sql/handler.h\"\n#include \"sql/mdl.h\"\n#include \"sql/mysqld.h\"   // opt_allow_suspicious_udfs\n#include \"sql/records.h\"  // unique_ptr_destroy_only<RowIterator>\n#include \"sql/row_iterator.h\"\n#include \"sql/sql_base.h\"   // close_mysql_tables\n#include \"sql/sql_class.h\"  // THD\n#include \"sql/sql_const.h\"\n#include \"sql/sql_parse.h\"   // check_string_char_length\n#include \"sql/sql_plugin.h\"  // check_valid_path\n#include \"sql/sql_table.h\"   // write_bin_log\n#include \"sql/table.h\"       // TABLE_LIST\n#include \"sql/thd_raii.h\"\n#include \"sql/thr_malloc.h\"\n#include \"sql/transaction.h\"  // trans_*\n#include \"thr_lock.h\"\n#include \"udf_registration_imp.h\"\n\n#ifdef HAVE_DLFCN_H\n#include <dlfcn.h>\n#endif\n\n/**\n  @page page_ext_udf User Defined Functions\n\n  @todo Document me\n\n  @sa add_udf, udf_hash_delete.\n*/\n\n/**\n  A local flag indicating whether SQL based UDF operations are allowed.\n  Now the UDF structures are always allocated/deallocated due to\n  the component service.\n\n  So this variable does not cover initialization/deinitialization of these.\n  \\ref mem and \\ref THR_LOCK_udf are always initialized, even in\n  --skip-grant-tables mode.\n*/\nstatic bool initialized = false;\nstatic MEM_ROOT mem;\nstatic collation_unordered_map<std::string, udf_func *> *udf_hash;\nstatic mysql_rwlock_t THR_LOCK_udf;\n\nstatic udf_func *add_udf(LEX_STRING *name, Item_result ret, char *dl,\n                         Item_udftype typ);\nstatic void udf_hash_delete(udf_func *udf);\nstatic void *find_udf_dl(const char *dl);\n\nstatic char *init_syms(udf_func *tmp, char *nm) {\n  char *end;\n\n  if (!((tmp->func = (Udf_func_any)dlsym(tmp->dlhandle, tmp->name.str))))\n    return tmp->name.str;\n\n  end = my_stpcpy(nm, tmp->name.str);\n\n  if (tmp->type == UDFTYPE_AGGREGATE) {\n    (void)my_stpcpy(end, \"_clear\");\n    if (!((tmp->func_clear = (Udf_func_clear)dlsym(tmp->dlhandle, nm))))\n      return nm;\n    (void)my_stpcpy(end, \"_add\");\n    if (!((tmp->func_add = (Udf_func_add)dlsym(tmp->dlhandle, nm)))) return nm;\n  }\n\n  (void)my_stpcpy(end, \"_deinit\");\n  tmp->func_deinit = (Udf_func_deinit)dlsym(tmp->dlhandle, nm);\n\n  (void)my_stpcpy(end, \"_init\");\n  tmp->func_init = (Udf_func_init)dlsym(tmp->dlhandle, nm);\n\n  /*\n    to prevent loading \"udf\" from, e.g. libc.so\n    let's ensure that at least one auxiliary symbol is defined\n  */\n  if (!tmp->func_init && !tmp->func_deinit && tmp->type != UDFTYPE_AGGREGATE) {\n    if (!opt_allow_suspicious_udfs) return nm;\n    LogErr(WARNING_LEVEL, ER_FAILED_TO_FIND_DL_ENTRY, nm);\n  }\n  return nullptr;\n}\n\nstatic PSI_memory_key key_memory_udf_mem;\n\n#ifdef HAVE_PSI_INTERFACE\nstatic PSI_rwlock_key key_rwlock_THR_LOCK_udf;\n\nstatic PSI_rwlock_info all_udf_rwlocks[] = {{&key_rwlock_THR_LOCK_udf,\n                                             \"THR_LOCK_udf\", PSI_FLAG_SINGLETON,\n                                             0, PSI_DOCUMENT_ME}};\n\nstatic PSI_memory_info all_udf_memory[] = {{&key_memory_udf_mem, \"udf_mem\",\n                                            PSI_FLAG_ONLY_GLOBAL_STAT, 0,\n                                            PSI_DOCUMENT_ME}};\n\nstatic void init_udf_psi_keys(void) {\n  const char *category = \"sql\";\n  int count;\n\n  count = static_cast<int>(array_elements(all_udf_rwlocks));\n  mysql_rwlock_register(category, all_udf_rwlocks, count);\n\n  count = static_cast<int>(array_elements(all_udf_memory));\n  mysql_memory_register(category, all_udf_memory, count);\n}\n#endif\n\n/**\n  Initialize the UDF global structures.\n  This is done as a separate step so that the UDF registration\n  service can work when initalizing plugins, which happens\n  before reading the UDF table.\n*/\nvoid udf_init_globals() {\n  DBUG_TRACE;\n  if (initialized) return;\n\n#ifdef HAVE_PSI_INTERFACE\n  init_udf_psi_keys();\n#endif\n\n  mysql_rwlock_init(key_rwlock_THR_LOCK_udf, &THR_LOCK_udf);\n  init_sql_alloc(key_memory_udf_mem, &mem, UDF_ALLOC_BLOCK_SIZE, 0);\n\n  udf_hash = new collation_unordered_map<std::string, udf_func *>(\n      system_charset_info, key_memory_udf_mem);\n}\n\n/*\n  Read all predeclared functions from mysql.func and accept all that\n  can be used.\n  The global structures must be initialized first.\n*/\nvoid udf_read_functions_table() {\n  udf_func *tmp;\n  TABLE *table;\n  unique_ptr_destroy_only<RowIterator> iterator;\n  int error;\n  DBUG_TRACE;\n  char db[] = \"mysql\"; /* A subject to casednstr, can't be constant */\n\n  if (initialized) {\n    DBUG_ASSERT(\"wrong init order: reading UDFs from the table twice\");\n    return;\n  }\n\n  initialized = true;\n\n  THD *new_thd = new (std::nothrow) THD;\n  if (new_thd == nullptr) {\n    LogErr(ERROR_LEVEL, ER_UDF_CANT_ALLOC_FOR_STRUCTURES);\n    free_root(&mem, MYF(0));\n    delete new_thd;\n    return;\n  }\n  new_thd->thread_stack = (char *)&new_thd;\n  new_thd->store_globals();\n  {\n    LEX_CSTRING db_lex_cstr = {STRING_WITH_LEN(db)};\n    new_thd->set_db(db_lex_cstr);\n  }\n\n  TABLE_LIST tables(db, \"func\", TL_READ, MDL_SHARED_READ_ONLY);\n\n  if (open_trans_system_tables_for_read(new_thd, &tables)) {\n    DBUG_PRINT(\"error\", (\"Can't open udf table\"));\n    LogErr(ERROR_LEVEL, ER_UDF_CANT_OPEN_FUNCTION_TABLE);\n    goto end;\n  }\n\n  table = tables.table;\n  iterator = init_table_iterator(new_thd, table, nullptr, false,\n                                 /*ignore_not_found_rows=*/false);\n  if (iterator == nullptr) goto end;\n  while (!(error = iterator->Read())) {\n    DBUG_PRINT(\"info\", (\"init udf record\"));\n    LEX_STRING name;\n    name.str = get_field(&mem, table->field[0]);\n    name.length = strlen(name.str);\n    char *dl_name = get_field(&mem, table->field[2]);\n    bool new_dl = false;\n    Item_udftype udftype = UDFTYPE_FUNCTION;\n    if (table->s->fields >= 4)  // New func table\n      udftype = (Item_udftype)table->field[3]->val_int();\n\n    /*\n      Ensure that the .dll doesn't have a path\n      This is done to ensure that only approved dll from the system\n      directories are used (to make this even remotely secure).\n\n      On windows we must check both FN_LIBCHAR and '/'.\n    */\n\n    LEX_CSTRING name_cstr = {name.str, name.length};\n    if (check_valid_path(dl_name, strlen(dl_name)) ||\n        check_string_char_length(name_cstr, \"\", NAME_CHAR_LEN,\n                                 system_charset_info, true)) {\n      LogErr(ERROR_LEVEL, ER_UDF_INVALID_ROW_IN_FUNCTION_TABLE, name.str);\n      continue;\n    }\n\n    if (!(tmp = add_udf(&name, (Item_result)table->field[1]->val_int(), dl_name,\n                        udftype))) {\n      LogErr(ERROR_LEVEL, ER_UDF_CANT_ALLOC_FOR_FUNCTION, name.str);\n      continue;\n    }\n\n    void *dl = find_udf_dl(tmp->dl);\n    if (dl == nullptr) {\n      char dlpath[FN_REFLEN];\n      strxnmov(dlpath, sizeof(dlpath) - 1, opt_plugin_dir, \"/\", tmp->dl, NullS);\n      (void)unpack_filename(dlpath, dlpath);\n      if (!(dl = dlopen(dlpath, RTLD_NOW))) {\n        const char *errmsg;\n        int error_number = dlopen_errno;\n        DLERROR_GENERATE(errmsg, error_number);\n\n        // Print warning to log\n        LogErr(ERROR_LEVEL, ER_FAILED_TO_OPEN_SHARED_LIBRARY, tmp->dl,\n               error_number, errmsg);\n        // Keep the udf in the hash so that we can remove it later\n        continue;\n      }\n      new_dl = true;\n    }\n    tmp->dlhandle = dl;\n    {\n      char buf[NAME_LEN + 16], *missing;\n      if ((missing = init_syms(tmp, buf))) {\n        LogErr(ERROR_LEVEL, ER_FAILED_TO_FIND_DL_ENTRY, missing);\n        udf_hash_delete(tmp);\n        if (new_dl) dlclose(dl);\n      }\n    }\n  }\n  if (error > 0) LogErr(ERROR_LEVEL, ER_UNKNOWN_ERROR_NUMBER, my_errno());\n  iterator.reset();\n  table->m_needs_reopen = true;  // Force close to free memory\n\nend:\n  close_trans_system_tables(new_thd);\n  delete new_thd;\n}\n\n/**\n   Deintialize the UDF subsystem.\n\n   This function closes the shared libaries.\n*/\nvoid udf_unload_udfs() {\n  DBUG_TRACE;\n  if (udf_hash != nullptr) {\n    for (auto it1 = udf_hash->begin(); it1 != udf_hash->end(); ++it1) {\n      udf_func *udf = it1->second;\n      if (udf->dlhandle)  // Not closed before\n      {\n        /* Mark all versions using the same handler as closed */\n        for (auto it2 = std::next(it1); it2 != udf_hash->end(); ++it2) {\n          udf_func *tmp = it2->second;\n          if (udf->dlhandle == tmp->dlhandle)\n            tmp->dlhandle = nullptr;  // Already closed\n        }\n        dlclose(udf->dlhandle);\n      }\n    }\n  }\n}\n\n/**\n   Deintialize the UDF subsystem.\n\n   This function does the following:\n   1. Free the UDF hash.\n   2. Free the memroot allocated.\n   3. Destroy the RW mutex object.\n*/\nvoid udf_deinit_globals() {\n  DBUG_TRACE;\n  if (udf_hash != nullptr) {\n    delete udf_hash;\n    udf_hash = nullptr;\n  }\n  free_root(&mem, MYF(0));\n  initialized = false;\n\n  mysql_rwlock_destroy(&THR_LOCK_udf);\n}\n\n/**\n   Delete the UDF function from the UDF hash.\n\n   @param udf  Pointer to the UDF function.\n\n   @note The function remove the udf function from the udf\n         hash if it is not in use. If the function is in use,\n         the function name is renamed so that it is not used.\n         The function shall be removed when no threads use it.\n*/\nstatic void udf_hash_delete(udf_func *udf) {\n  DBUG_TRACE;\n\n  mysql_rwlock_wrlock(&THR_LOCK_udf);\n\n  const auto it = udf_hash->find(to_string(udf->name));\n  if (it == udf_hash->end()) {\n    DBUG_ASSERT(false);\n    return;\n  }\n\n  if (!--udf->usage_count) {\n    udf_hash->erase(it);\n    using_udf_functions = !udf_hash->empty();\n  } else {\n    /*\n      The functions is in use ; Rename the functions instead of removing it.\n      The functions will be automaticly removed when the least threads\n      doesn't use it anymore\n    */\n    udf_hash->erase(it);\n    char new_name[32];\n    snprintf(new_name, sizeof(new_name), \"*<%p>\", udf);\n    udf_hash->emplace(new_name, udf);\n  }\n  mysql_rwlock_unlock(&THR_LOCK_udf);\n}\n\nvoid free_udf(udf_func *udf) {\n  DBUG_TRACE;\n\n  if (!initialized) return;\n\n  mysql_rwlock_wrlock(&THR_LOCK_udf);\n  if (!--udf->usage_count) {\n    /*\n      We come here when someone has deleted the udf function\n      while another thread still was using the udf\n    */\n    const auto it = udf_hash->find(to_string(udf->name));\n    if (it == udf_hash->end()) {\n      DBUG_ASSERT(false);\n      return;\n    }\n    udf_hash->erase(it);\n    using_udf_functions = !udf_hash->empty();\n    if (udf->dlhandle && !find_udf_dl(udf->dl)) dlclose(udf->dlhandle);\n  }\n  mysql_rwlock_unlock(&THR_LOCK_udf);\n}\n\n/* This is only called if using_udf_functions != 0 */\n\nudf_func *find_udf(const char *name, size_t length, bool mark_used) {\n  udf_func *udf = nullptr;\n  DBUG_TRACE;\n\n  if (!initialized) return nullptr;\n\n  /* TODO: This should be changed to reader locks someday! */\n  if (mark_used)\n    mysql_rwlock_wrlock(&THR_LOCK_udf); /* Called during fix_fields */\n  else\n    mysql_rwlock_rdlock(&THR_LOCK_udf); /* Called during parsing */\n\n  std::string key = length ? std::string(name, length) : std::string(name);\n  const auto it = udf_hash->find(key);\n\n  if (it != udf_hash->end()) {\n    udf = it->second;\n    if (mark_used) udf->usage_count++;\n  }\n  mysql_rwlock_unlock(&THR_LOCK_udf);\n  return udf;\n}\n\nstatic void *find_udf_dl(const char *dl) {\n  DBUG_TRACE;\n\n  if (!dl) return nullptr;\n  /*\n    Because only the function name is hashed, we have to search trough\n    all rows to find the dl.\n  */\n  for (const auto &key_and_value : *udf_hash) {\n    udf_func *udf = key_and_value.second;\n    if (udf->dl && !strcmp(dl, udf->dl) && udf->dlhandle != nullptr)\n      return udf->dlhandle;\n  }\n  return nullptr;\n}\n\n/* Assume that name && dl is already allocated */\n\nstatic udf_func *add_udf(LEX_STRING *name, Item_result ret, char *dl,\n                         Item_udftype type) {\n  if (!name || !dl || !(uint)type || (uint)type > (uint)UDFTYPE_AGGREGATE)\n    return nullptr;\n\n  udf_func *tmp = (udf_func *)mem.Alloc(sizeof(udf_func));\n  if (!tmp) return nullptr;\n  memset(tmp, 0, sizeof(*tmp));\n  tmp->name = *name;  // dup !!\n  tmp->dl = dl;\n  tmp->returns = ret;\n  tmp->type = type;\n  tmp->usage_count = 1;\n\n  mysql_rwlock_wrlock(&THR_LOCK_udf);\n\n  udf_hash->emplace(to_string(tmp->name), tmp);\n  using_udf_functions = true;\n\n  mysql_rwlock_unlock(&THR_LOCK_udf);\n  return tmp;\n}\n\n/**\n   Commit or rollback a transaction. Also close tables\n   which it has opened and release metadata locks.\n   Add/Remove from the in-memory hash depending on transaction\n   commit or rollback and the bool flag passed to this function.\n\n   @param thd                 THD context.\n   @param rollback            Rollback transaction if true.\n   @param udf                 Pointer to UDF function.\n   @param insert_udf          Insert UDF in hash if true.\n\n   @retval False - Success.\n   @retval True  - Error.\n*/\n\nstatic bool udf_end_transaction(THD *thd, bool rollback, udf_func *udf,\n                                bool insert_udf) {\n  bool result;\n  bool rollback_transaction = thd->transaction_rollback_request || rollback;\n  udf_func *u_f = nullptr;\n\n  DBUG_ASSERT(stmt_causes_implicit_commit(thd, CF_IMPLICIT_COMMIT_END));\n\n  if (!rollback_transaction && insert_udf) {\n    udf->name.str = strdup_root(&mem, udf->name.str);\n    udf->dl = strdup_root(&mem, udf->dl);\n    // create entry in mysql.func table\n    u_f = add_udf(&udf->name, udf->returns, udf->dl, udf->type);\n    if (u_f != nullptr) {\n      u_f->dlhandle = udf->dlhandle;\n      u_f->func = udf->func;\n      u_f->func_init = udf->func_init;\n      u_f->func_deinit = udf->func_deinit;\n      u_f->func_clear = udf->func_clear;\n      u_f->func_add = udf->func_add;\n    }\n  }\n\n  rollback_transaction = rollback_transaction || (insert_udf && u_f == nullptr);\n\n  /*\n    CREATE/DROP UDF operations must acquire IX Backup Lock in order\n    to be mutually exclusive with LOCK INSTANCE FOR BACKUP.\n  */\n  DBUG_ASSERT(thd->mdl_context.owns_equal_or_stronger_lock(\n      MDL_key::BACKUP_LOCK, \"\", \"\", MDL_INTENTION_EXCLUSIVE));\n\n  /*\n    Rollback the transaction if there is an error or there is a request by the\n    SE (which is unlikely).\n  */\n  if (rollback_transaction) {\n    result = trans_rollback_stmt(thd);\n    result = result || trans_rollback_implicit(thd);\n  } else {\n    result = trans_commit_stmt(thd);\n    result = result || trans_commit_implicit(thd);\n  }\n\n  /*\n    Delete UDF from the hash if\n      * the transaction commit fails for CREATE UDF operation\n      * OR if the transaction is committed successfully for the DROP UDF\n        operation.\n  */\n  if (!rollback_transaction &&\n      ((insert_udf && result) || (!insert_udf && !result)))\n    udf_hash_delete(udf);\n\n  close_thread_tables(thd);\n  thd->mdl_context.release_transactional_locks();\n\n  return result || rollback || (insert_udf && u_f == nullptr);\n}\n\n/**\n  Create a user defined function.\n\n  Atomicity:\n    The operation to create a user defined function is atomic/crash-safe.\n    Changes to the Data-dictionary and writing event to binlog are\n    part of the same transaction. All the changes are done as part\n    of the same transaction or do not have any side effects on the\n    operation failure. UDF hash is in sync with operation state.\n    UDF hash do not contain any stale/incorrect data in case of failure.\n    In case of crash, there won't be any discrepancy between the\n    data-dictionary table and the binary log.\n\n  @param thd                 THD context.\n  @param udf                 Pointer to UDF function.\n\n  @note Like implementations of other DDL/DML in MySQL, this function\n  relies on the caller to close the thread tables. This is done in the\n  end of dispatch_command().\n*/\n\nbool mysql_create_function(THD *thd, udf_func *udf) {\n  bool error = true;\n  void *dl = nullptr;\n  int new_dl = 0;\n  TABLE *table;\n\n  DBUG_TRACE;\n\n  if (!initialized) {\n    if (opt_noacl)\n      my_error(ER_CANT_INITIALIZE_UDF, MYF(0), udf->name.str,\n               \"UDFs are unavailable with the --skip-grant-tables option\");\n    else\n      my_error(ER_OUT_OF_RESOURCES, MYF(0));\n    return error;\n  }\n\n  /* must not be dynamically registered */\n  DBUG_ASSERT(udf->dl);\n\n  /*\n    Ensure that the .dll doesn't have a path\n    This is done to ensure that only approved dll from the system\n    directories are used (to make this even remotely secure).\n  */\n  if (check_valid_path(udf->dl, strlen(udf->dl))) {\n    my_error(ER_UDF_NO_PATHS, MYF(0));\n    return error;\n  }\n  LEX_CSTRING udf_name_cstr = {udf->name.str, udf->name.length};\n  if (check_string_char_length(udf_name_cstr, \"\", NAME_CHAR_LEN,\n                               system_charset_info, true)) {\n    my_error(ER_TOO_LONG_IDENT, MYF(0), udf->name.str);\n    return error;\n  }\n\n  /*\n    Acquire MDL SNRW for TL_WRITE type so that deadlock and\n    timeout errors are avoided from the Storage Engine.\n  */\n  TABLE_LIST tables(\"mysql\", \"func\", TL_WRITE, MDL_SHARED_NO_READ_WRITE);\n\n  if (open_and_lock_tables(thd, &tables, MYSQL_LOCK_IGNORE_TIMEOUT))\n    return error;\n  table = tables.table;\n  /*\n    Turn off row binlogging of this statement and use statement-based\n    so that all supporting tables are updated for CREATE FUNCTION command.\n  */\n  Save_and_Restore_binlog_format_state binlog_format_state(thd);\n\n  mysql_rwlock_rdlock(&THR_LOCK_udf);\n  if (udf_hash->count(to_string(udf->name)) != 0) {\n    my_error(ER_UDF_EXISTS, MYF(0), udf->name.str);\n    mysql_rwlock_unlock(&THR_LOCK_udf);\n    return error;\n  }\n  dl = find_udf_dl(udf->dl);\n  mysql_rwlock_unlock(&THR_LOCK_udf);\n\n  if (dl == nullptr) {\n    char dlpath[FN_REFLEN];\n    strxnmov(dlpath, sizeof(dlpath) - 1, opt_plugin_dir, \"/\", udf->dl, NullS);\n    (void)unpack_filename(dlpath, dlpath);\n\n    if (!(dl = dlopen(dlpath, RTLD_NOW))) {\n      const char *errmsg;\n      int error_number = dlopen_errno;\n      DLERROR_GENERATE(errmsg, error_number);\n\n      DBUG_PRINT(\"error\", (\"dlopen of %s failed, error: %d (%s)\", udf->dl,\n                           error_number, errmsg));\n      my_error(ER_CANT_OPEN_LIBRARY, MYF(0), udf->dl, error_number, errmsg);\n      return error;\n    }\n    new_dl = 1;\n  }\n  udf->dlhandle = dl;\n  {\n    char buf[NAME_LEN + 16], *missing;\n    if ((missing = init_syms(udf, buf))) {\n      my_error(ER_CANT_FIND_DL_ENTRY, MYF(0), missing);\n      if (new_dl) dlclose(dl);\n      return error;\n    }\n  }\n\n  // create entry in mysql.func table\n\n  table->use_all_columns();\n  restore_record(table, s->default_values);  // Default values for fields\n  table->field[0]->store(udf->name.str, udf->name.length, system_charset_info);\n  table->field[1]->store((longlong)udf->returns, true);\n  table->field[2]->store(udf->dl, strlen(udf->dl), system_charset_info);\n  if (table->s->fields >= 4)  // If not old func format\n    table->field[3]->store((longlong)udf->type, true);\n  error = (table->file->ha_write_row(table->record[0]) != 0);\n\n  // Binlog the create function.\n  if (!error)\n    error = (write_bin_log(thd, true, thd->query().str, thd->query().length,\n                           true) != 0);\n\n  error = udf_end_transaction(thd, error, udf, true);\n\n  if (error) {\n    char errbuf[MYSYS_STRERROR_SIZE];\n    my_error(ER_ERROR_ON_WRITE, MYF(0), \"mysql.func\", error,\n             my_strerror(errbuf, sizeof(errbuf), error));\n    if (new_dl) dlclose(dl);\n  }\n  return error;\n}\n\n/**\n  Drop a user defined function.\n\n  Atomicity:\n    The operation to drop a user defined function is atomic/crash-safe.\n    Changes to the Data-dictionary and writing event to binlog are\n    part of the same transaction. All the changes are done as part\n    of the same transaction or do not have any side effects on the\n    operation failure. UDF hash is in sync with operation state.\n    UDF hash do not contain any stale/incorrect data in case of failure.\n    In case of crash, there won't be any discrepancy between the\n    data-dictionary table and the binary log.\n\n  @param thd                 THD context.\n  @param udf_name            Name of the UDF function.\n*/\n\nbool mysql_drop_function(THD *thd, const LEX_STRING *udf_name) {\n  TABLE *table;\n  udf_func *udf;\n  bool error = true;\n\n  DBUG_TRACE;\n\n  if (!initialized) {\n    if (opt_noacl)\n      my_error(ER_FUNCTION_NOT_DEFINED, MYF(0), udf_name->str);\n    else\n      my_error(ER_OUT_OF_RESOURCES, MYF(0));\n    return error;\n  }\n\n  TABLE_LIST tables(\"mysql\", \"func\", TL_WRITE, MDL_SHARED_NO_READ_WRITE);\n\n  if (open_and_lock_tables(thd, &tables, MYSQL_LOCK_IGNORE_TIMEOUT))\n    return error;\n  table = tables.table;\n  /*\n    Turn off row binlogging of this statement and use statement-based\n    so that all supporting tables are updated for DROP FUNCTION command.\n  */\n  Save_and_Restore_binlog_format_state binlog_format_state(thd);\n\n  mysql_rwlock_rdlock(&THR_LOCK_udf);\n  const auto it = udf_hash->find(to_string(*udf_name));\n  if (it == udf_hash->end()) {\n    my_error(ER_FUNCTION_NOT_DEFINED, MYF(0), udf_name->str);\n    mysql_rwlock_unlock(&THR_LOCK_udf);\n    return error;\n  }\n  udf = it->second;\n  if (!udf->dl) {\n    mysql_rwlock_unlock(&THR_LOCK_udf);\n    my_error(ER_UDF_DROP_DYNAMICALLY_REGISTERED, MYF(0));\n    return error;\n  }\n\n  mysql_rwlock_unlock(&THR_LOCK_udf);\n\n  table->use_all_columns();\n  table->field[0]->store(udf->name.str, udf->name.length, &my_charset_bin);\n  if (!table->file->ha_index_read_idx_map(table->record[0], 0,\n                                          table->field[0]->ptr, HA_WHOLE_KEY,\n                                          HA_READ_KEY_EXACT)) {\n    int delete_err;\n    if ((delete_err = table->file->ha_delete_row(table->record[0])))\n      table->file->print_error(delete_err, MYF(0));\n    error = delete_err != 0;\n  }\n\n  /*\n    Binlog the drop function. Keep the table open and locked\n    while binlogging, to avoid binlog inconsistency.\n  */\n  if (!error)\n    error = (write_bin_log(thd, true, thd->query().str, thd->query().length,\n                           true) != 0);\n\n  error = udf_end_transaction(thd, error, udf, false);\n\n  /*\n    Close the handle if this was function that was found during boot or\n    CREATE FUNCTION and it's not in use by any other udf function\n  */\n  if (udf->dlhandle && !find_udf_dl(udf->dl)) dlclose(udf->dlhandle);\n\n  return error;\n}\n\nbool mysql_udf_registration_imp::udf_register_inner(udf_func *ufunc) {\n  mysql_rwlock_wrlock(&THR_LOCK_udf);\n\n  DBUG_ASSERT(ufunc->dl == nullptr);\n  DBUG_ASSERT(ufunc->dlhandle == nullptr);\n\n  auto res = udf_hash->emplace(to_string(ufunc->name), ufunc);\n  if (!res.second)\n    ufunc = nullptr;\n  else\n    using_udf_functions = true;\n\n  mysql_rwlock_unlock(&THR_LOCK_udf);\n  return ufunc == nullptr;\n}\n\nudf_func *mysql_udf_registration_imp::alloc_udf(const char *name,\n                                                Item_result return_type,\n                                                Udf_func_any func,\n                                                Udf_func_init init_func,\n                                                Udf_func_deinit deinit_func) {\n  udf_func *ufunc;\n\n  ufunc = (udf_func *)mem.Alloc(sizeof(udf_func));\n  if (!ufunc) return nullptr;\n  memset(ufunc, 0, sizeof(udf_func));\n  ufunc->name.str = strdup_root(&mem, name);\n  ufunc->name.length = strlen(name);\n  ufunc->func = func;\n  ufunc->func_init = init_func;\n  ufunc->func_deinit = deinit_func;\n  ufunc->returns = return_type;\n  ufunc->usage_count = 1;\n\n  return ufunc;\n}\n\nDEFINE_BOOL_METHOD(mysql_udf_registration_imp::udf_register,\n                   (const char *name, Item_result return_type,\n                    Udf_func_any func, Udf_func_init init_func,\n                    Udf_func_deinit deinit_func)) {\n  udf_func *ufunc;\n\n  if (!func && !init_func && !deinit_func) return true;\n\n  ufunc = alloc_udf(name, return_type, func, init_func, deinit_func);\n  if (!ufunc) return true;\n  ufunc->type = Item_udftype::UDFTYPE_FUNCTION;\n\n  return udf_register_inner(ufunc);\n}\n\nDEFINE_BOOL_METHOD(mysql_udf_registration_imp::udf_register_aggregate,\n                   (const char *name, enum Item_result return_type,\n                    Udf_func_any func, Udf_func_init init_func,\n                    Udf_func_deinit deinit_func, Udf_func_add add_func,\n                    Udf_func_clear clear_func)) {\n  udf_func *ufunc;\n\n  if (!func && !add_func && !clear_func && !init_func && !deinit_func)\n    return true;\n\n  ufunc = alloc_udf(name, return_type, func, init_func, deinit_func);\n  if (!ufunc) return true;\n  ufunc->type = Item_udftype::UDFTYPE_AGGREGATE;\n  ufunc->func_add = add_func;\n  ufunc->func_clear = clear_func;\n\n  return udf_register_inner(ufunc);\n}\n\nDEFINE_BOOL_METHOD(mysql_udf_registration_imp::udf_unregister,\n                   (const char *name, int *was_present)) {\n  udf_func *udf = nullptr;\n\n  if (was_present) *was_present = 0;\n  mysql_rwlock_wrlock(&THR_LOCK_udf);\n  const auto it = udf_hash->find(name);\n  if (it != udf_hash->end()) {\n    if (was_present) *was_present = 1;\n\n    udf = it->second;\n\n    if (!udf->dl && !udf->dlhandle &&  // Not registered via CREATE FUNCTION\n        !--udf->usage_count)           // Not used\n    {\n      udf_hash->erase(it);\n      using_udf_functions = !udf_hash->empty();\n    } else  // error\n      udf = nullptr;\n  }\n  mysql_rwlock_unlock(&THR_LOCK_udf);\n  return udf != nullptr ? false : true;\n}\n\nvoid udf_hash_rlock(void) { mysql_rwlock_rdlock(&THR_LOCK_udf); }\n\nvoid udf_hash_unlock(void) { mysql_rwlock_unlock(&THR_LOCK_udf); }\n\nulong udf_hash_size(void) { return udf_hash->size(); }\n\nvoid udf_hash_for_each(udf_hash_for_each_func_t *func, void *arg) {\n  for (auto it : *udf_hash) func(it.second, arg);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/sql/sql_plugin.cc": "/* Copyright (c) 2005, 2020, Oracle and/or its affiliates. All rights reserved.\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License, version 2.0,\n   as published by the Free Software Foundation.\n\n   This program is also distributed with certain software (including\n   but not limited to OpenSSL) that is licensed under separate terms,\n   as designated in a particular file or component or in included license\n   documentation.  The authors of MySQL hereby grant you an additional\n   permission to link the program and your derivative works with the\n   separately licensed software that they have included with MySQL.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License, version 2.0, for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA */\n\n#include \"sql/sql_plugin.h\"\n\n#include \"my_config.h\"\n\n#include <stdarg.h>\n#include <stdio.h>\n#include <string.h>\n\n#include \"m_ctype.h\"\n#include \"m_string.h\"\n#include \"map_helpers.h\"\n#include \"mutex_lock.h\"  // MUTEX_LOCK\n#include \"my_alloc.h\"\n#include \"my_base.h\"\n#include \"my_compiler.h\"\n#include \"my_dbug.h\"\n#include \"my_default.h\"  // free_defaults\n#include \"my_getopt.h\"\n#include \"my_inttypes.h\"\n#include \"my_list.h\"\n#include \"my_loglevel.h\"\n#include \"my_macros.h\"\n#include \"my_psi_config.h\"\n#include \"my_sharedlib.h\"\n#include \"my_sys.h\"\n#include \"my_thread_local.h\"\n#include \"mysql/components/services/log_builtins.h\"\n#include \"mysql/components/services/log_shared.h\"\n#include \"mysql/components/services/psi_memory_bits.h\"\n#include \"mysql/components/services/psi_mutex_bits.h\"\n#include \"mysql/components/services/system_variable_source_type.h\"\n#include \"mysql/plugin_audit.h\"\n#include \"mysql/plugin_auth.h\"\n#include \"mysql/plugin_clone.h\"\n#include \"mysql/plugin_group_replication.h\"\n#include \"mysql/plugin_keyring.h\"\n#include \"mysql/plugin_validate_password.h\"\n#include \"mysql/psi/mysql_memory.h\"\n#include \"mysql/psi/mysql_mutex.h\"\n#include \"mysql/psi/mysql_rwlock.h\"\n#include \"mysql/psi/mysql_system.h\"\n#include \"mysql/psi/mysql_thread.h\"\n#include \"mysql/psi/psi_base.h\"\n#include \"mysql/service_mysql_alloc.h\"\n#include \"mysql_com.h\"\n#include \"mysql_version.h\"\n#include \"mysqld_error.h\"\n#include \"prealloced_array.h\"\n#include \"sql/auth/auth_acls.h\"\n#include \"sql/auth/auth_common.h\"  // check_table_access\n#include \"sql/auto_thd.h\"          // Auto_THD\n#include \"sql/current_thd.h\"\n#include \"sql/dd/cache/dictionary_client.h\"  // dd::cache::Dictionary_client\n#include \"sql/dd/dd_schema.h\"                // dd::Schema_MDL_locker\n#include \"sql/dd/info_schema/metadata.h\"  // dd::info_schema::store_dynamic_p...\n#include \"sql/dd/string_type.h\"           // dd::String_type\n#include \"sql/dd_sql_view.h\"              // update_referencing_views_metadata\n#include \"sql/debug_sync.h\"               // DEBUG_SYNC\n#include \"sql/derror.h\"                   // ER_THD\n#include \"sql/field.h\"\n#include \"sql/handler.h\"  // ha_initalize_handlerton\n#include \"sql/key.h\"      // key_copy\n#include \"sql/lock.h\"     // acquire_shared_global...\n#include \"sql/log.h\"\n#include \"sql/mdl.h\"\n#include \"sql/mysqld.h\"              // files_charset_info\n#include \"sql/persisted_variable.h\"  // Persisted_variables_cache\n#include \"sql/protocol_classic.h\"\n#include \"sql/psi_memory_key.h\"\n#include \"sql/records.h\"  // unique_ptr_destroy_only<RowIterator>\n#include \"sql/row_iterator.h\"\n#include \"sql/set_var.h\"\n#include \"sql/sql_audit.h\"        // mysql_audit_acquire_plugins\n#include \"sql/sql_backup_lock.h\"  // acquire_shared_backup_lock\n#include \"sql/sql_base.h\"         // close_mysql_tables\n#include \"sql/sql_class.h\"        // THD\n#include \"sql/sql_const.h\"\n#include \"sql/sql_error.h\"\n#include \"sql/sql_lex.h\"\n#include \"sql/sql_list.h\"\n#include \"sql/sql_parse.h\"  // check_string_char_length\n#include \"sql/sql_plugin_var.h\"\n#include \"sql/sql_show.h\"  // add_status_vars\n#include \"sql/sql_table.h\"\n#include \"sql/sys_vars_resource_mgr.h\"\n#include \"sql/sys_vars_shared.h\"  // intern_find_sys_var\n#include \"sql/system_variables.h\"\n#include \"sql/table.h\"\n#include \"sql/thd_raii.h\"\n#include \"sql/thr_malloc.h\"\n#include \"sql/transaction.h\"  // trans_rollback_stmt\n#include \"sql_string.h\"\n#include \"template_utils.h\"  // pointer_cast\n#include \"thr_lock.h\"\n#include \"thr_mutex.h\"\n#include \"typelib.h\"\n\n/* clang-format off */\n/**\n  @page page_ext_plugins Plugins\n\n  The Big Picture\n  ----------------\n\n  @startuml\n  actor \"SQL client\" as client\n  box \"MySQL Server\" #LightBlue\n    participant \"Server Code\" as server\n    participant \"Plugin\" as plugin\n  endbox\n\n  == INSTALL PLUGIN ==\n  server -> plugin : initialize\n  activate plugin\n  plugin --> server : initialization done\n\n  == CLIENT SESSION ==\n  loop many\n    client -> server : SQL command\n    server -> server : Add reference for Plugin if absent\n    loop one or many\n      server -> plugin : plugin API call\n      plugin --> server : plugin API call result\n    end\n    server -> server : Optionally release reference for Plugin\n    server --> client : SQL command reply\n  end\n\n  == UNINSTALL PLUGIN ==\n  server -> plugin : deinitialize\n  plugin --> server : deinitialization done\n  deactivate plugin\n  @enduml\n\n  @sa Sql_cmd_install_plugin, Sql_cmd_uninstall_plugin.\n*/\n\n/**\n  @page page_ext_plugin_services Plugin Services\n\n  Adding Plugin Services Into The Big Picture\n  ------------------------------------\n\n  You probably remember the big picture for @ref page_ext_plugins.\n  Below is an extended version of it with plugin services added.\n\n  @startuml\n\n  actor \"SQL client\" as client\n  box \"MySQL Server\" #LightBlue\n    participant \"Server Code\" as server\n    participant \"Plugin\" as plugin\n  endbox\n\n  == INSTALL PLUGIN ==\n  server -> plugin : initialize\n  activate plugin\n\n  loop zero or many\n    plugin -> server : service API call\n    server --> plugin : service API result\n  end\n  plugin --> server : initialization done\n\n  == CLIENT SESSION ==\n  loop many\n    client -> server : SQL command\n    server -> server : Add reference for Plugin if absent\n    loop one or many\n      server -> plugin : plugin API call\n      loop zero or many\n        plugin -> server : service API call\n        server --> plugin : service API result\n      end\n      plugin --> server : plugin API call result\n    end\n    server -> server : Optionally release reference for Plugin\n    server --> client : SQL command reply\n  end\n\n  == UNINSTALL PLUGIN ==\n  server -> plugin : deinitialize\n  loop zero or many\n    plugin -> server : service API call\n    server --> plugin : service API result\n  end\n  plugin --> server : deinitialization done\n  deactivate plugin\n  @enduml\n\n  Understanding and creating plugin services\n  -----------------------------\n\n  - @subpage page_ext_plugin_svc_anathomy\n  - @subpage page_ext_plugin_svc_new_service_howto\n  - @subpage page_ext_plugin_api_goodservices\n\n  @section sect_ext_plugin_svc_reference Plugin Services Reference\n\n   See @ref group_ext_plugin_services\n*/\n\n/**\n  @page page_ext_plugin_svc_anathomy Plugin Service Anathomy\n\n  A \"service\" is a struct of C function pointers.\n\n  It is a tool to expose a pre-exitsing set of server functions to plugins.\n  You need the actual server functions as a starting point.\n\n  The server has all service structs defined and initialized so\n  that the the function pointers point to the actual service implementation\n  functions.\n\n  The server also keeps a global list of the plugin service reference\n  structures called ::list_of_services.\n\n  See ::st_service_ref for details of what a service reference is.\n\n  The server copies of all plugin structures are filled in at compile time\n  with the function pointers of the actual server functions that implement\n  the service functions. References to them are stored into the relevant\n  element of ::list_of_services.\n\n  Each plugin must export pointer symbols for every plugin service that\n  the server knows about.\n\n  The plugin service pointers are initialized with the version of the plugin\n  service that the plugin expects.\n\n  When a dynamic plugin shared object is loaded by ::plugin_dl_add it will\n  iterate over ::list_of_services, find the plugin symbol by name,\n  check the service version stored in that symbol against the one stored into\n  ::st_service_ref and then will replace the version stored in plugin's struct\n  pointer with the actual pointer of the server's copy of the same structure.\n\n  When that is filled in the plugin can use the newly set server structure\n  through its local pointer to call into the service method pointers that point\n  to the server implementaiton functions.\n\n  Once set to the server's structure, the plugin's service pointer value is\n  never reset back to service version.\n\n  The plugin service header also defines a set of convenience macros\n  that replace top level plugin service calls with the corresponding function\n  pointer call, i.e. for service foo:\n\n  ~~~~\n  struct foo_service_st {\n     int (*foo_mtd_1)(int a);\n  }\n\n  struct foo_service_st *foo_service;\n  ~~~~\n\n  a convenience macro is defined for `foo_mtd_1` as follows:\n\n  ~~~~\n  #define foo_mtd_1(a)  foo_service->foo_mtd_1(a)\n  ~~~~\n\n  This trick allows plugin service functions to look as top level function\n  calls inside the plugin code.\n\n  @sa plugin_add, plugin_del, plugin_dl_add, plugin_dl_del, list_of_services,\n    st_service_ref\n*/\n/* clang-format on */\n\n#ifdef HAVE_DLFCN_H\n#include <dlfcn.h>\n#endif\n\n#include <algorithm>\n#include <memory>\n#include <new>\n#include <unordered_map>\n#include <utility>\n\n#include \"sql/srv_session.h\"  // Srv_session::check_for_stale_threads()\n\nusing std::max;\nusing std::min;\n\n#define REPORT_TO_LOG 1\n#define REPORT_TO_USER 2\n\n#ifndef DBUG_OFF\nstatic PSI_memory_key key_memory_plugin_ref;\n#endif\n\nstatic PSI_memory_key key_memory_plugin_mem_root;\nstatic PSI_memory_key key_memory_plugin_init_tmp;\nstatic PSI_memory_key key_memory_plugin_int_mem_root;\nstatic PSI_memory_key key_memory_mysql_plugin;\nstatic PSI_memory_key key_memory_mysql_plugin_dl;\nstatic PSI_memory_key key_memory_plugin_bookmark;\n\nextern st_mysql_plugin *mysql_optional_plugins[];\nextern st_mysql_plugin *mysql_mandatory_plugins[];\n\n/**\n  @note The order of the enumeration is critical.\n  @see construct_options\n*/\nconst char *global_plugin_typelib_names[] = {\"OFF\", \"ON\", \"FORCE\",\n                                             \"FORCE_PLUS_PERMANENT\", nullptr};\nstatic TYPELIB global_plugin_typelib = {\n    array_elements(global_plugin_typelib_names) - 1, \"\",\n    global_plugin_typelib_names, nullptr};\n\nstatic I_List<i_string> opt_plugin_load_list;\nI_List<i_string> *opt_plugin_load_list_ptr = &opt_plugin_load_list;\nstatic I_List<i_string> opt_early_plugin_load_list;\nI_List<i_string> *opt_early_plugin_load_list_ptr = &opt_early_plugin_load_list;\nchar *opt_plugin_dir_ptr;\nchar opt_plugin_dir[FN_REFLEN];\n/*\n  When you ad a new plugin type, add both a string and make sure that the\n  init and deinit array are correctly updated.\n*/\nconst LEX_CSTRING plugin_type_names[MYSQL_MAX_PLUGIN_TYPE_NUM] = {\n    {STRING_WITH_LEN(\"UDF\")},\n    {STRING_WITH_LEN(\"STORAGE ENGINE\")},\n    {STRING_WITH_LEN(\"FTPARSER\")},\n    {STRING_WITH_LEN(\"DAEMON\")},\n    {STRING_WITH_LEN(\"INFORMATION SCHEMA\")},\n    {STRING_WITH_LEN(\"AUDIT\")},\n    {STRING_WITH_LEN(\"REPLICATION\")},\n    {STRING_WITH_LEN(\"AUTHENTICATION\")},\n    {STRING_WITH_LEN(\"VALIDATE PASSWORD\")},\n    {STRING_WITH_LEN(\"GROUP REPLICATION\")},\n    {STRING_WITH_LEN(\"KEYRING\")},\n    {STRING_WITH_LEN(\"CLONE\")}};\n\nextern int initialize_schema_table(st_plugin_int *plugin);\nextern int finalize_schema_table(st_plugin_int *plugin);\n\n/*\n  The number of elements in both plugin_type_initialize and\n  plugin_type_deinitialize should equal to the number of plugins\n  defined.\n*/\nplugin_type_init plugin_type_initialize[MYSQL_MAX_PLUGIN_TYPE_NUM] = {\n    nullptr,\n    ha_initialize_handlerton,\n    nullptr,\n    nullptr,\n    initialize_schema_table,\n    initialize_audit_plugin,\n    nullptr,\n    nullptr,\n    nullptr};\n\nplugin_type_init plugin_type_deinitialize[MYSQL_MAX_PLUGIN_TYPE_NUM] = {\n    nullptr,\n    ha_finalize_handlerton,\n    nullptr,\n    nullptr,\n    finalize_schema_table,\n    finalize_audit_plugin,\n    nullptr,\n    nullptr,\n    nullptr};\n\nstatic const char *plugin_interface_version_sym =\n    \"_mysql_plugin_interface_version_\";\nstatic const char *sizeof_st_plugin_sym = \"_mysql_sizeof_struct_st_plugin_\";\nstatic const char *plugin_declarations_sym = \"_mysql_plugin_declarations_\";\nstatic int min_plugin_interface_version =\n    MYSQL_PLUGIN_INTERFACE_VERSION & ~0xFF;\n\nstatic void *innodb_callback_data;\n\n/* Note that 'int version' must be the first field of every plugin\n   sub-structure (plugin->info).\n*/\nstatic int min_plugin_info_interface_version[MYSQL_MAX_PLUGIN_TYPE_NUM] = {\n    0x0000,\n    MYSQL_HANDLERTON_INTERFACE_VERSION,\n    MYSQL_FTPARSER_INTERFACE_VERSION,\n    MYSQL_DAEMON_INTERFACE_VERSION,\n    MYSQL_INFORMATION_SCHEMA_INTERFACE_VERSION,\n    MYSQL_AUDIT_INTERFACE_VERSION,\n    MYSQL_REPLICATION_INTERFACE_VERSION,\n    MYSQL_AUTHENTICATION_INTERFACE_VERSION,\n    MYSQL_VALIDATE_PASSWORD_INTERFACE_VERSION,\n    MYSQL_GROUP_REPLICATION_INTERFACE_VERSION,\n    MYSQL_KEYRING_INTERFACE_VERSION,\n    MYSQL_CLONE_INTERFACE_VERSION};\nstatic int cur_plugin_info_interface_version[MYSQL_MAX_PLUGIN_TYPE_NUM] = {\n    0x0000, /* UDF: not implemented */\n    MYSQL_HANDLERTON_INTERFACE_VERSION,\n    MYSQL_FTPARSER_INTERFACE_VERSION,\n    MYSQL_DAEMON_INTERFACE_VERSION,\n    MYSQL_INFORMATION_SCHEMA_INTERFACE_VERSION,\n    MYSQL_AUDIT_INTERFACE_VERSION,\n    MYSQL_REPLICATION_INTERFACE_VERSION,\n    MYSQL_AUTHENTICATION_INTERFACE_VERSION,\n    MYSQL_VALIDATE_PASSWORD_INTERFACE_VERSION,\n    MYSQL_GROUP_REPLICATION_INTERFACE_VERSION,\n    MYSQL_KEYRING_INTERFACE_VERSION,\n    MYSQL_CLONE_INTERFACE_VERSION};\n\n/* support for Services */\n\n#include \"sql/sql_plugin_services.h\"\n\n/*\n  A mutex LOCK_plugin_delete must be acquired before calling plugin_del\n  function.\n*/\nmysql_mutex_t LOCK_plugin_delete;\n\n/**\n  Serializes access to the global plugin memory list.\n\n  LOCK_plugin must be acquired before accessing\n  plugin_dl_array, plugin_array and plugin_hash.\n  We are always manipulating ref count, so a rwlock here is unneccessary.\n  If it must be taken together with the LOCK_system_variables_hash then\n  LOCK_plugin must be taken before LOCK_system_variables_hash.\n*/\nmysql_mutex_t LOCK_plugin;\n/**\n  Serializes the INSTALL and UNINSTALL PLUGIN commands.\n  Must be taken before LOCK_plugin.\n*/\nmysql_mutex_t LOCK_plugin_install;\nstatic Prealloced_array<st_plugin_dl *, 16> *plugin_dl_array;\nstatic Prealloced_array<st_plugin_int *, 16> *plugin_array;\nstatic collation_unordered_map<std::string, st_plugin_int *>\n    *plugin_hash[MYSQL_MAX_PLUGIN_TYPE_NUM] = {nullptr};\nstatic bool reap_needed = false;\nstatic int plugin_array_version = 0;\n\nstatic bool initialized = false;\n\nstatic MEM_ROOT plugin_mem_root;\nstatic uint global_variables_dynamic_size = 0;\nstatic malloc_unordered_map<std::string, st_bookmark *> *bookmark_hash;\n/** Hash for system variables of string type with MEMALLOC flag. */\nstatic malloc_unordered_map<std::string, st_bookmark *>\n    *malloced_string_type_sysvars_bookmark_hash;\n\n/* prototypes */\nstatic void plugin_load(MEM_ROOT *tmp_root, int *argc, char **argv);\nstatic bool plugin_load_list(MEM_ROOT *tmp_root, int *argc, char **argv,\n                             const char *list, bool load_early);\nstatic bool check_if_option_is_deprecated(int optid,\n                                          const struct my_option *opt,\n                                          char *argument);\nstatic int test_plugin_options(MEM_ROOT *, st_plugin_int *, int *, char **);\nstatic bool register_builtin(st_mysql_plugin *, st_plugin_int *,\n                             st_plugin_int **);\nstatic void unlock_variables(struct System_variables *vars);\nstatic void cleanup_variables(THD *thd, struct System_variables *vars);\nstatic void plugin_vars_free_values(sys_var *vars);\nstatic void plugin_var_memalloc_free(struct System_variables *vars);\nstatic void restore_pluginvar_names(sys_var *first);\n#define my_intern_plugin_lock(A, B) intern_plugin_lock(A, B)\n#define my_intern_plugin_lock_ci(A, B) intern_plugin_lock(A, B)\nstatic plugin_ref intern_plugin_lock(LEX *lex, plugin_ref plugin);\nstatic void intern_plugin_unlock(LEX *lex, plugin_ref plugin);\nstatic void reap_plugins(void);\n\nmalloc_unordered_map<std::string, st_bookmark *> *get_bookmark_hash(void) {\n  return bookmark_hash;\n}\n\n/**\n @warning Make sure all errors reported to the log here are\n defined in share/messages_to_error_log.txt as well as in\n share/messages_to_clients.txt.\n\n @arg where_to  a combination of @ref REPORT_TO_USER and @ref REPORT_TO_LOG\n @arg error  the code for the mysql_error()\n*/\nstatic void report_error(int where_to, uint error, ...) {\n  va_list args;\n  if (where_to & REPORT_TO_USER) {\n    va_start(args, error);\n    my_printv_error(error, ER_THD_NONCONST(current_thd, error), MYF(0), args);\n    va_end(args);\n  }\n  if (where_to & REPORT_TO_LOG) {\n    longlong ecode = 0;\n    switch (error) {\n      case ER_UDF_NO_PATHS:\n        ecode = ER_NO_PATH_FOR_SHARED_LIBRARY;\n        break;\n      case ER_CANT_OPEN_LIBRARY:\n        ecode = ER_FAILED_TO_OPEN_SHARED_LIBRARY;\n        break;\n      case ER_CANT_FIND_DL_ENTRY:\n        ecode = ER_FAILED_TO_FIND_DL_ENTRY;\n        break;\n      case ER_OUTOFMEMORY:\n        ecode = ER_SERVER_OUTOFMEMORY;\n        break;\n      case ER_UDF_EXISTS:\n        ecode = ER_UDF_ALREADY_EXISTS;\n        break;\n      case ER_PLUGIN_NO_INSTALL:\n        ecode = ER_PLUGIN_NO_INSTALL_DUP;\n        break;\n      case ER_PLUGIN_NOT_EARLY:\n        ecode = ER_PLUGIN_NOT_EARLY_DUP;\n        break;\n      default:\n        DBUG_ASSERT(false);\n        return;\n    }\n    va_start(args, error);\n    LogEvent().type(LOG_TYPE_ERROR).prio(ERROR_LEVEL).lookupv(ecode, args);\n    va_end(args);\n  }\n}\n\n/**\n   Check if the provided path is valid in the sense that it does cause\n   a relative reference outside the directory.\n\n   @note Currently, this function only check if there are any\n   characters in FN_DIRSEP in the string, but it might change in the\n   future.\n\n   @code\n   check_valid_path(\"../foo.so\") -> true\n   check_valid_path(\"foo.so\") -> false\n   @endcode\n */\nbool check_valid_path(const char *path, size_t len) {\n  size_t prefix = my_strcspn(files_charset_info, path, path + len, FN_DIRSEP,\n                             strlen(FN_DIRSEP));\n  return prefix < len;\n}\n\n/****************************************************************************\n  Plugin support code\n****************************************************************************/\n\nstatic st_plugin_dl *plugin_dl_find(const LEX_STRING *dl) {\n  DBUG_TRACE;\n  for (st_plugin_dl **it = plugin_dl_array->begin();\n       it != plugin_dl_array->end(); ++it) {\n    st_plugin_dl *tmp = *it;\n    if (tmp->ref_count &&\n        !my_strnncoll(files_charset_info, pointer_cast<uchar *>(dl->str),\n                      dl->length, pointer_cast<uchar *>(tmp->dl.str),\n                      tmp->dl.length))\n      return tmp;\n  }\n  return nullptr;\n}\n\nstatic st_plugin_dl *plugin_dl_insert_or_reuse(st_plugin_dl *plugin_dl) {\n  DBUG_TRACE;\n  st_plugin_dl *tmp;\n  for (st_plugin_dl **it = plugin_dl_array->begin();\n       it != plugin_dl_array->end(); ++it) {\n    tmp = *it;\n    if (!tmp->ref_count) {\n      memcpy(tmp, plugin_dl, sizeof(st_plugin_dl));\n      return tmp;\n    }\n  }\n  if (plugin_dl_array->push_back(plugin_dl)) return nullptr;\n  tmp = plugin_dl_array->back() = static_cast<st_plugin_dl *>(\n      memdup_root(&plugin_mem_root, plugin_dl, sizeof(st_plugin_dl)));\n  return tmp;\n}\n\nstatic inline void free_plugin_mem(st_plugin_dl *p) {\n  /*\n     The valgrind leak report is done at the end of the program execution.\n     But since the plugins are unloaded from the memory,\n     it is impossible for valgrind to correctly report the leak locations.\n     So leave the shared objects (.DLL/.so) open for the symbols definition.\n   */\n  bool preserve_shared_objects_after_unload = false;\n  DBUG_EXECUTE_IF(\"preserve_shared_objects_after_unload\",\n                  { preserve_shared_objects_after_unload = true; });\n  if (p->handle != nullptr && !preserve_shared_objects_after_unload) {\n#ifdef HAVE_PSI_SYSTEM_INTERFACE\n    PSI_SYSTEM_CALL(unload_plugin)\n    (std::string(p->dl.str, p->dl.length).c_str());\n#endif\n    dlclose(p->handle);\n  }\n  my_free(p->dl.str);\n  if (p->version != MYSQL_PLUGIN_INTERFACE_VERSION) my_free(p->plugins);\n}\n\n/**\n  Loads a dynamic plugin\n\n  Fills in a ::st_plugin_dl structure.\n  Initializes the plugin services pointer inside the plugin.\n  Does not initialize the individual plugins.\n  Must have LOCK_plugin and LOCK_system_variables locked(write).\n  On error releases LOCK_system_variables and LOCK_plugin.\n\n  @arg dl      The path to the plugin binary to load\n  @arg report  a bitmask that's passed down to report_error()\n  @arg load_early true if loading the \"early\" plugins (--early-plugin-load etc)\n\n  @return      A plugin reference.\n  @retval      NULL      failed to load the plugin\n*/\nstatic st_plugin_dl *plugin_dl_add(const LEX_STRING *dl, int report,\n                                   bool load_early) {\n  char dlpath[FN_REFLEN];\n  uint dummy_errors, i;\n  size_t plugin_dir_len, dlpathlen;\n  st_plugin_dl *tmp, plugin_dl;\n  void *sym;\n  DBUG_TRACE;\n  DBUG_PRINT(\"enter\",\n             (\"dl->str: '%s', dl->length: %d\", dl->str, (int)dl->length));\n  plugin_dir_len = strlen(opt_plugin_dir);\n  /*\n    Ensure that the dll doesn't have a path.\n    This is done to ensure that only approved libraries from the\n    plugin directory are used (to make this even remotely secure).\n  */\n  LEX_CSTRING dl_cstr = {dl->str, dl->length};\n  if (check_valid_path(dl->str, dl->length) ||\n      check_string_char_length(dl_cstr, \"\", NAME_CHAR_LEN, system_charset_info,\n                               true) ||\n      plugin_dir_len + dl->length + 1 >= FN_REFLEN) {\n    mysql_rwlock_unlock(&LOCK_system_variables_hash);\n    mysql_mutex_unlock(&LOCK_plugin);\n    report_error(report, ER_UDF_NO_PATHS);\n    return nullptr;\n  }\n  /* If this dll is already loaded just increase ref_count. */\n  if ((tmp = plugin_dl_find(dl))) {\n    tmp->ref_count++;\n    return tmp;\n  }\n  memset(&plugin_dl, 0, sizeof(plugin_dl));\n  /* Compile dll path */\n  dlpathlen = strxnmov(dlpath, sizeof(dlpath) - 1, opt_plugin_dir, \"/\", dl->str,\n                       NullS) -\n              dlpath;\n  (void)unpack_filename(dlpath, dlpath);\n  plugin_dl.ref_count = 1;\n  /* Open new dll handle */\n  mysql_mutex_assert_owner(&LOCK_plugin);\n  if (!(plugin_dl.handle = dlopen(dlpath, RTLD_NOW))) {\n    const char *errmsg;\n    int error_number = dlopen_errno;\n    /*\n      Conforming applications should use a critical section to retrieve\n      the error pointer and buffer...\n    */\n    DLERROR_GENERATE(errmsg, error_number);\n\n    if (!strncmp(\n            dlpath, errmsg,\n            dlpathlen)) {  // if errmsg starts from dlpath, trim this prefix.\n      errmsg += dlpathlen;\n      if (*errmsg == ':') errmsg++;\n      if (*errmsg == ' ') errmsg++;\n    }\n    mysql_rwlock_unlock(&LOCK_system_variables_hash);\n    mysql_mutex_unlock(&LOCK_plugin);\n    report_error(report, ER_CANT_OPEN_LIBRARY, dlpath, error_number, errmsg);\n\n    /*\n      \"The messages returned by dlerror() may reside in a static buffer\n       that is overwritten on each call to dlerror().\"\n\n      Some implementations have a static pointer instead, and the memory it\n      points to may be reported as \"still reachable\" by Valgrind.\n      Calling dlerror() once more will free the memory.\n     */\n#if !defined(_WIN32)\n    errmsg = dlerror();\n    DBUG_ASSERT(errmsg == nullptr);\n#endif\n    return nullptr;\n  }\n  /* Determine interface version */\n  if (!(sym = dlsym(plugin_dl.handle, plugin_interface_version_sym))) {\n    free_plugin_mem(&plugin_dl);\n    mysql_rwlock_unlock(&LOCK_system_variables_hash);\n    mysql_mutex_unlock(&LOCK_plugin);\n    report_error(report, ER_CANT_FIND_DL_ENTRY, plugin_interface_version_sym);\n    return nullptr;\n  }\n  plugin_dl.version = *(int *)sym;\n  /* Versioning */\n  if (plugin_dl.version < min_plugin_interface_version ||\n      (plugin_dl.version >> 8) > (MYSQL_PLUGIN_INTERFACE_VERSION >> 8)) {\n    free_plugin_mem(&plugin_dl);\n    mysql_rwlock_unlock(&LOCK_system_variables_hash);\n    mysql_mutex_unlock(&LOCK_plugin);\n    report_error(report, ER_CANT_OPEN_LIBRARY, dlpath, 0,\n                 \"plugin interface version mismatch\");\n    return nullptr;\n  }\n\n  /* link the services in */\n  for (i = 0; i < array_elements(list_of_services); i++) {\n    if ((sym = dlsym(plugin_dl.handle, list_of_services[i].name))) {\n      uint ver = (uint)(intptr) * (void **)sym;\n      if ((*(void **)sym) !=\n              list_of_services[i].service && /* already replaced */\n          (ver > list_of_services[i].version ||\n           (ver >> 8) < (list_of_services[i].version >> 8))) {\n        char buf[MYSQL_ERRMSG_SIZE];\n        snprintf(buf, sizeof(buf), \"service '%s' interface version mismatch\",\n                 list_of_services[i].name);\n        mysql_rwlock_unlock(&LOCK_system_variables_hash);\n        mysql_mutex_unlock(&LOCK_plugin);\n        report_error(report, ER_CANT_OPEN_LIBRARY, dlpath, 0, buf);\n        return nullptr;\n      }\n      *(void **)sym = list_of_services[i].service;\n    }\n  }\n\n  /* Find plugin declarations */\n  if (!(sym = dlsym(plugin_dl.handle, plugin_declarations_sym))) {\n    free_plugin_mem(&plugin_dl);\n    mysql_rwlock_unlock(&LOCK_system_variables_hash);\n    mysql_mutex_unlock(&LOCK_plugin);\n    report_error(report, ER_CANT_FIND_DL_ENTRY, plugin_declarations_sym);\n    return nullptr;\n  }\n\n  if (plugin_dl.version != MYSQL_PLUGIN_INTERFACE_VERSION) {\n    uint sizeof_st_plugin;\n    st_mysql_plugin *old, *cur;\n    char *ptr = (char *)sym;\n\n    if ((sym = dlsym(plugin_dl.handle, sizeof_st_plugin_sym)))\n      sizeof_st_plugin = *(int *)sym;\n    else {\n      /*\n        When the following assert starts failing, we'll have to call\n        report_error(report, ER_CANT_FIND_DL_ENTRY, sizeof_st_plugin_sym);\n      */\n      DBUG_ASSERT(min_plugin_interface_version == 0);\n      sizeof_st_plugin = (int)offsetof(st_mysql_plugin, version);\n    }\n\n    /*\n      What's the purpose of this loop? If the goal is to catch a\n      missing 0 record at the end of a list, it will fail miserably\n      since the compiler is likely to optimize this away. /Matz\n     */\n    for (i = 0; ((st_mysql_plugin *)(ptr + i * sizeof_st_plugin))->info; i++)\n      /* no op */;\n\n    cur = (st_mysql_plugin *)my_malloc(key_memory_mysql_plugin,\n                                       (i + 1) * sizeof(st_mysql_plugin),\n                                       MYF(MY_ZEROFILL | MY_WME));\n    if (!cur) {\n      free_plugin_mem(&plugin_dl);\n      mysql_rwlock_unlock(&LOCK_system_variables_hash);\n      mysql_mutex_unlock(&LOCK_plugin);\n      report_error(report, ER_OUTOFMEMORY,\n                   static_cast<int>(plugin_dl.dl.length));\n      return nullptr;\n    }\n    /*\n      All st_plugin fields not initialized in the plugin explicitly, are\n      set to 0. It matches C standard behaviour for struct initializers that\n      have less values than the struct definition.\n    */\n    for (i = 0; (old = (st_mysql_plugin *)(ptr + i * sizeof_st_plugin))->info;\n         i++)\n      memcpy(cur + i, old, min<size_t>(sizeof(cur[i]), sizeof_st_plugin));\n\n    sym = cur;\n  }\n  plugin_dl.plugins = (st_mysql_plugin *)sym;\n\n  /*\n    If report is REPORT_TO_USER, we were called from\n    mysql_install_plugin. Otherwise, we are called\n    indirectly from plugin_register_dynamic_and_init_all().\n   */\n  if (report == REPORT_TO_USER) {\n    st_mysql_plugin *plugin = plugin_dl.plugins;\n    for (; plugin->info; ++plugin)\n      if (plugin->flags & PLUGIN_OPT_NO_INSTALL) {\n        mysql_rwlock_unlock(&LOCK_system_variables_hash);\n        mysql_mutex_unlock(&LOCK_plugin);\n        report_error(report, ER_PLUGIN_NO_INSTALL, plugin->name);\n        free_plugin_mem(&plugin_dl);\n        return nullptr;\n      }\n  }\n\n  if (load_early) {\n    st_mysql_plugin *plugin = plugin_dl.plugins;\n    for (; plugin->info; ++plugin)\n      if (!(plugin->flags & PLUGIN_OPT_ALLOW_EARLY)) {\n        mysql_rwlock_unlock(&LOCK_system_variables_hash);\n        mysql_mutex_unlock(&LOCK_plugin);\n        report_error(report, ER_PLUGIN_NOT_EARLY, plugin->name);\n        free_plugin_mem(&plugin_dl);\n        return nullptr;\n      }\n  }\n\n  /* Duplicate and convert dll name */\n  plugin_dl.dl.length = dl->length * files_charset_info->mbmaxlen + 1;\n  if (!(plugin_dl.dl.str = (char *)my_malloc(key_memory_mysql_plugin_dl,\n                                             plugin_dl.dl.length, MYF(0)))) {\n    mysql_rwlock_unlock(&LOCK_system_variables_hash);\n    mysql_mutex_unlock(&LOCK_plugin);\n    free_plugin_mem(&plugin_dl);\n    report_error(report, ER_OUTOFMEMORY, static_cast<int>(plugin_dl.dl.length));\n    return nullptr;\n  }\n  plugin_dl.dl.length = copy_and_convert(\n      plugin_dl.dl.str, plugin_dl.dl.length, files_charset_info, dl->str,\n      dl->length, system_charset_info, &dummy_errors);\n  plugin_dl.dl.str[plugin_dl.dl.length] = 0;\n  /* Add this dll to array */\n  if (!(tmp = plugin_dl_insert_or_reuse(&plugin_dl))) {\n    mysql_rwlock_unlock(&LOCK_system_variables_hash);\n    mysql_mutex_unlock(&LOCK_plugin);\n    free_plugin_mem(&plugin_dl);\n    report_error(report, ER_OUTOFMEMORY,\n                 static_cast<int>(sizeof(st_plugin_dl)));\n    return nullptr;\n  }\n  return tmp;\n}\n\nstatic void plugin_dl_del(const LEX_STRING *dl) {\n  DBUG_TRACE;\n\n  mysql_mutex_assert_owner(&LOCK_plugin);\n\n  for (st_plugin_dl **it = plugin_dl_array->begin();\n       it != plugin_dl_array->end(); ++it) {\n    st_plugin_dl *tmp = *it;\n    if (tmp->ref_count &&\n        !my_strnncoll(files_charset_info, pointer_cast<uchar *>(dl->str),\n                      dl->length, pointer_cast<uchar *>(tmp->dl.str),\n                      tmp->dl.length)) {\n      /* Do not remove this element, unless no other plugin uses this dll. */\n      if (!--tmp->ref_count) {\n        free_plugin_mem(tmp);\n        memset(tmp, 0, sizeof(st_plugin_dl));\n      }\n      break;\n    }\n  }\n}\n\nstatic st_plugin_int *plugin_find_internal(const LEX_CSTRING &name, int type) {\n  uint i;\n  DBUG_TRACE;\n  if (!initialized) return nullptr;\n\n  mysql_mutex_assert_owner(&LOCK_plugin);\n\n  if (type == MYSQL_ANY_PLUGIN) {\n    for (i = 0; i < MYSQL_MAX_PLUGIN_TYPE_NUM; i++) {\n      const auto it = plugin_hash[i]->find(to_string(name));\n      if (it != plugin_hash[i]->end()) return it->second;\n    }\n  } else\n    return find_or_nullptr(*plugin_hash[type], to_string(name));\n  return nullptr;\n}\n\nstatic SHOW_COMP_OPTION plugin_status(const LEX_CSTRING &name, int type) {\n  SHOW_COMP_OPTION rc = SHOW_OPTION_NO;\n  st_plugin_int *plugin;\n  DBUG_TRACE;\n  mysql_mutex_lock(&LOCK_plugin);\n  if ((plugin = plugin_find_internal(name, type))) {\n    rc = SHOW_OPTION_DISABLED;\n    if (plugin->state == PLUGIN_IS_READY) rc = SHOW_OPTION_YES;\n  }\n  mysql_mutex_unlock(&LOCK_plugin);\n  return rc;\n}\n\nbool plugin_is_ready(const LEX_CSTRING &name, int type) {\n  bool rc = false;\n  if (plugin_status(name, type) == SHOW_OPTION_YES) rc = true;\n  return rc;\n}\n\nSHOW_COMP_OPTION plugin_status(const char *name, size_t len, int type) {\n  LEX_CSTRING plugin_name = {name, len};\n  return plugin_status(plugin_name, type);\n}\n\nstatic plugin_ref intern_plugin_lock(LEX *lex, plugin_ref rc) {\n  st_plugin_int *pi = plugin_ref_to_int(rc);\n  DBUG_TRACE;\n\n  mysql_mutex_assert_owner(&LOCK_plugin);\n\n  if (pi->state & (PLUGIN_IS_READY | PLUGIN_IS_UNINITIALIZED)) {\n    plugin_ref plugin;\n#ifdef DBUG_OFF\n    /* built-in plugins don't need ref counting */\n    if (!pi->plugin_dl) return pi;\n\n    plugin = pi;\n#else\n    /*\n      For debugging, we do an additional malloc which allows the\n      memory manager and/or valgrind to track locked references and\n      double unlocks to aid resolving reference counting problems.\n    */\n    if (!(plugin = (plugin_ref)my_malloc(key_memory_plugin_ref, sizeof(pi),\n                                         MYF(MY_WME))))\n      return nullptr;\n\n    *plugin = pi;\n#endif\n    pi->ref_count++;\n    DBUG_PRINT(\"info\", (\"thd: %p, plugin: \\\"%s\\\", ref_count: %d\", current_thd,\n                        pi->name.str, pi->ref_count));\n    if (lex) lex->plugins.push_back(plugin);\n    return plugin;\n  }\n  return nullptr;\n}\n\nplugin_ref plugin_lock(THD *thd, plugin_ref *ptr) {\n  LEX *lex = thd ? thd->lex : nullptr;\n  plugin_ref rc;\n  DBUG_TRACE;\n  mysql_mutex_lock(&LOCK_plugin);\n  rc = my_intern_plugin_lock_ci(lex, *ptr);\n  mysql_mutex_unlock(&LOCK_plugin);\n  return rc;\n}\n\nplugin_ref plugin_lock_by_name(THD *thd, const LEX_CSTRING &name, int type) {\n  LEX *lex = thd ? thd->lex : nullptr;\n  plugin_ref rc = nullptr;\n  st_plugin_int *plugin;\n  DBUG_TRACE;\n  mysql_mutex_lock(&LOCK_plugin);\n  if ((plugin = plugin_find_internal(name, type)))\n    rc = my_intern_plugin_lock_ci(lex, plugin_int_to_ref(plugin));\n  mysql_mutex_unlock(&LOCK_plugin);\n  return rc;\n}\n\nstatic st_plugin_int *plugin_insert_or_reuse(st_plugin_int *plugin) {\n  DBUG_TRACE;\n  st_plugin_int *tmp;\n  /* During server bootstrap, don't reuse free slot. In case some early plugin\n  load like key_ring fails, an user plugin could occupy that empty slot and\n  get installed before mandatory plugins like PFS. This will cause issue if\n  the plugin has dependency on PFS like creating dynamic PFS table. This issue\n  is observed during clone plugin testing. */\n  const bool reuse_free_slot = (get_server_state() != SERVER_BOOTING);\n\n  if (reuse_free_slot) {\n    for (st_plugin_int **it = plugin_array->begin(); it != plugin_array->end();\n         ++it) {\n      tmp = *it;\n      if (tmp->state == PLUGIN_IS_FREED) {\n        *tmp = std::move(*plugin);\n        return tmp;\n      }\n    }\n  }\n\n  if (plugin_array->push_back(plugin)) return nullptr;\n  tmp = plugin_array->back() =\n      new (&plugin_mem_root) st_plugin_int(std::move(*plugin));\n  return tmp;\n}\n\n/**\n  Adds a plugin to the global plugin list.\n\n  Also installs the plugin variables.\n  In case of error releases ::LOCK_system_variables_hash and ::LOCK_plugin\n  and reports the error.\n  @note Requires that a write-lock is held on ::LOCK_plugin and\n  ::LOCK_system_variables_hash\n*/\nstatic bool plugin_add(MEM_ROOT *tmp_root, LEX_CSTRING name,\n                       const LEX_STRING *dl, int *argc, char **argv, int report,\n                       bool load_early) {\n  st_plugin_int tmp;\n  st_mysql_plugin *plugin;\n  DBUG_TRACE;\n\n  mysql_mutex_assert_owner(&LOCK_plugin);\n  if (plugin_find_internal(name, MYSQL_ANY_PLUGIN)) {\n    mysql_rwlock_unlock(&LOCK_system_variables_hash);\n    mysql_mutex_unlock(&LOCK_plugin);\n    report_error(report, ER_UDF_EXISTS, name.str);\n    return true;\n  }\n  if (!(tmp.plugin_dl = plugin_dl_add(dl, report, load_early))) return true;\n  /* Find plugin by name */\n  for (plugin = tmp.plugin_dl->plugins; plugin->info; plugin++) {\n    size_t name_len = strlen(plugin->name);\n    if (plugin->type >= 0 && plugin->type < MYSQL_MAX_PLUGIN_TYPE_NUM &&\n        !my_strnncoll(system_charset_info,\n                      pointer_cast<const uchar *>(name.str), name.length,\n                      pointer_cast<const uchar *>(plugin->name), name_len)) {\n      st_plugin_int *tmp_plugin_ptr;\n      if (*(int *)plugin->info <\n              min_plugin_info_interface_version[plugin->type] ||\n          ((*(int *)plugin->info) >> 8) >\n              (cur_plugin_info_interface_version[plugin->type] >> 8)) {\n        char buf[256], dl_name[FN_REFLEN];\n        strxnmov(buf, sizeof(buf) - 1, \"API version for \",\n                 plugin_type_names[plugin->type].str,\n                 \" plugin is too different\", NullS);\n        /* copy the library name so we can release the mutex */\n        strncpy(dl_name, dl->str, sizeof(dl_name) - 1);\n        dl_name[sizeof(dl_name) - 1] = 0;\n        plugin_dl_del(dl);\n        mysql_rwlock_unlock(&LOCK_system_variables_hash);\n        mysql_mutex_unlock(&LOCK_plugin);\n        report_error(report, ER_CANT_OPEN_LIBRARY, dl_name, 0, buf);\n        return true;\n      }\n      tmp.plugin = plugin;\n      tmp.name.str = plugin->name;\n      tmp.name.length = name_len;\n      tmp.ref_count = 0;\n      tmp.state = PLUGIN_IS_UNINITIALIZED;\n      tmp.load_option = PLUGIN_ON;\n      if (test_plugin_options(tmp_root, &tmp, argc, argv))\n        tmp.state = PLUGIN_IS_DISABLED;\n\n      if ((tmp_plugin_ptr = plugin_insert_or_reuse(&tmp))) {\n        plugin_array_version++;\n        if (plugin_hash[plugin->type]\n                ->emplace(to_string(tmp_plugin_ptr->name), tmp_plugin_ptr)\n                .second) {\n          init_alloc_root(key_memory_plugin_int_mem_root,\n                          &tmp_plugin_ptr->mem_root, 4096, 4096);\n          return false;\n        }\n        tmp_plugin_ptr->state = PLUGIN_IS_FREED;\n      }\n      mysql_del_sys_var_chain(tmp.system_vars);\n      restore_pluginvar_names(tmp.system_vars);\n      plugin_dl_del(dl);\n      mysql_rwlock_unlock(&LOCK_system_variables_hash);\n      mysql_mutex_unlock(&LOCK_plugin);\n      return true;\n    }\n  }\n  plugin_dl_del(dl);\n  mysql_rwlock_unlock(&LOCK_system_variables_hash);\n  mysql_mutex_unlock(&LOCK_plugin);\n  report_error(report, ER_CANT_FIND_DL_ENTRY, name.str);\n  return true;\n}\n\nstatic void plugin_deinitialize(st_plugin_int *plugin, bool ref_check) {\n  /*\n    we don't want to hold the LOCK_plugin mutex as it may cause\n    deinitialization to deadlock if plugins have worker threads\n    with plugin locks\n  */\n  mysql_mutex_assert_not_owner(&LOCK_plugin);\n\n  if (plugin->plugin->status_vars) {\n    remove_status_vars(plugin->plugin->status_vars);\n  }\n\n  if (plugin_type_deinitialize[plugin->plugin->type]) {\n    if ((*plugin_type_deinitialize[plugin->plugin->type])(plugin)) {\n      LogErr(ERROR_LEVEL, ER_PLUGIN_FAILED_DEINITIALIZATION, plugin->name.str,\n             plugin_type_names[plugin->plugin->type].str);\n    }\n  } else if (plugin->plugin->deinit) {\n    DBUG_PRINT(\"info\", (\"Deinitializing plugin: '%s'\", plugin->name.str));\n    if (plugin->plugin->deinit(plugin)) {\n      DBUG_PRINT(\"warning\", (\"Plugin '%s' deinit function returned error.\",\n                             plugin->name.str));\n    }\n  }\n  plugin->state = PLUGIN_IS_UNINITIALIZED;\n\n  Srv_session::check_for_stale_threads(plugin);\n  /*\n    We do the check here because NDB has a worker THD which doesn't\n    exit until NDB is shut down.\n  */\n  if (ref_check && plugin->ref_count)\n    LogErr(ERROR_LEVEL, ER_PLUGIN_HAS_NONZERO_REFCOUNT_AFTER_DEINITIALIZATION,\n           plugin->name.str, plugin->ref_count);\n}\n\n/*\n  Unload a plugin.\n  Note: During valgrind testing, the plugin's shared object (.dll/.so)\n        is not unloaded in order to keep the call stack\n        of the leaked objects.\n*/\nstatic void plugin_del(st_plugin_int *plugin) {\n  DBUG_TRACE;\n  mysql_mutex_assert_owner(&LOCK_plugin);\n  mysql_mutex_assert_owner(&LOCK_plugin_delete);\n  /* Free allocated strings before deleting the plugin. */\n  mysql_rwlock_wrlock(&LOCK_system_variables_hash);\n  mysql_del_sys_var_chain(plugin->system_vars);\n  mysql_rwlock_unlock(&LOCK_system_variables_hash);\n  restore_pluginvar_names(plugin->system_vars);\n  plugin_vars_free_values(plugin->system_vars);\n  plugin_hash[plugin->plugin->type]->erase(to_string(plugin->name));\n\n  if (plugin->plugin_dl) plugin_dl_del(&plugin->plugin_dl->dl);\n  plugin->state = PLUGIN_IS_FREED;\n  plugin_array_version++;\n  free_root(&plugin->mem_root, MYF(0));\n}\n\nstatic void reap_plugins(void) {\n  st_plugin_int *plugin, **reap, **list;\n\n  mysql_mutex_assert_owner(&LOCK_plugin);\n\n  if (!reap_needed) return;\n\n  reap_needed = false;\n  const size_t count = plugin_array->size();\n  reap = (st_plugin_int **)my_alloca(sizeof(plugin) * (count + 1));\n  *(reap++) = nullptr;\n\n  for (size_t idx = 0; idx < count; idx++) {\n    plugin = plugin_array->at(idx);\n    if (plugin->state == PLUGIN_IS_DELETED && !plugin->ref_count) {\n      /* change the status flag to prevent reaping by another thread */\n      plugin->state = PLUGIN_IS_DYING;\n      *(reap++) = plugin;\n    }\n  }\n\n  mysql_mutex_unlock(&LOCK_plugin);\n\n  list = reap;\n  while ((plugin = *(--list))) {\n    if (!opt_initialize)\n      LogErr(INFORMATION_LEVEL, ER_PLUGIN_SHUTTING_DOWN_PLUGIN,\n             plugin->name.str);\n    plugin_deinitialize(plugin, true);\n  }\n\n  mysql_mutex_lock(&LOCK_plugin_delete);\n  mysql_mutex_lock(&LOCK_plugin);\n\n  while ((plugin = *(--reap))) plugin_del(plugin);\n\n  mysql_mutex_unlock(&LOCK_plugin_delete);\n}\n\nstatic void intern_plugin_unlock(LEX *lex, plugin_ref plugin) {\n  st_plugin_int *pi;\n  DBUG_TRACE;\n\n  mysql_mutex_assert_owner(&LOCK_plugin);\n\n  if (!plugin) return;\n\n  pi = plugin_ref_to_int(plugin);\n\n#ifdef DBUG_OFF\n  if (!pi->plugin_dl) return;\n#else\n  my_free(plugin);\n#endif\n\n  DBUG_PRINT(\"info\", (\"unlocking plugin, name= %s, ref_count= %d\", pi->name.str,\n                      pi->ref_count));\n  if (lex) {\n    /*\n      Remove one instance of this plugin from the use list.\n      We are searching backwards so that plugins locked last\n      could be unlocked faster - optimizing for LIFO semantics.\n    */\n    plugin_ref *iter = lex->plugins.end() - 1;\n    bool found_it MY_ATTRIBUTE((unused)) = false;\n    for (; iter >= lex->plugins.begin() - 1; --iter) {\n      if (plugin == *iter) {\n        lex->plugins.erase(iter);\n        found_it = true;\n        break;\n      }\n    }\n    DBUG_ASSERT(found_it);\n  }\n\n  DBUG_ASSERT(pi->ref_count);\n  pi->ref_count--;\n\n  if (pi->state == PLUGIN_IS_DELETED && !pi->ref_count) reap_needed = true;\n}\n\nvoid plugin_unlock(THD *thd, plugin_ref plugin) {\n  LEX *lex = thd ? thd->lex : nullptr;\n  DBUG_TRACE;\n  if (!plugin) return;\n#ifdef DBUG_OFF\n  /* built-in plugins don't need ref counting */\n  if (!plugin_dlib(plugin)) return;\n#endif\n  mysql_mutex_lock(&LOCK_plugin);\n  intern_plugin_unlock(lex, plugin);\n  reap_plugins();\n  mysql_mutex_unlock(&LOCK_plugin);\n}\n\nvoid plugin_unlock_list(THD *thd, plugin_ref *list, size_t count) {\n  LEX *lex = thd ? thd->lex : nullptr;\n  DBUG_TRACE;\n  DBUG_ASSERT(list);\n\n  /*\n    In unit tests, LOCK_plugin may be uninitialized, so do not lock it.\n    Besides: there's no point in locking it, if there are no plugins to unlock.\n   */\n  if (count == 0) return;\n\n  mysql_mutex_lock(&LOCK_plugin);\n  while (count--) intern_plugin_unlock(lex, *list++);\n  reap_plugins();\n  mysql_mutex_unlock(&LOCK_plugin);\n}\n\nstatic int plugin_initialize(st_plugin_int *plugin) {\n  int ret = 1;\n  DBUG_TRACE;\n\n  mysql_mutex_assert_owner(&LOCK_plugin);\n  uint state = plugin->state;\n  DBUG_ASSERT(state == PLUGIN_IS_UNINITIALIZED);\n\n  mysql_mutex_unlock(&LOCK_plugin);\n\n  DEBUG_SYNC(current_thd, \"in_plugin_initialize\");\n\n  if (plugin_type_initialize[plugin->plugin->type]) {\n    if ((*plugin_type_initialize[plugin->plugin->type])(plugin)) {\n      LogErr(ERROR_LEVEL, ER_PLUGIN_REGISTRATION_FAILED, plugin->name.str,\n             plugin_type_names[plugin->plugin->type].str);\n      goto err;\n    }\n\n    /* FIXME: Need better solution to transfer the callback function\n    array to memcached */\n    if (strcmp(plugin->name.str, \"InnoDB\") == 0) {\n      innodb_callback_data = ((handlerton *)plugin->data)->data;\n    }\n  } else if (plugin->plugin->init) {\n    if (strcmp(plugin->name.str, \"daemon_memcached\") == 0) {\n      plugin->data = innodb_callback_data;\n    }\n\n    if (plugin->plugin->init(plugin)) {\n      LogErr(ERROR_LEVEL, ER_PLUGIN_INIT_FAILED, plugin->name.str);\n      goto err;\n    }\n  }\n  state = PLUGIN_IS_READY;  // plugin->init() succeeded\n\n  if (plugin->plugin->status_vars) {\n    if (add_status_vars(plugin->plugin->status_vars)) goto err;\n  }\n\n  /*\n    set the plugin attribute of plugin's sys vars so they are pointing\n    to the active plugin\n  */\n  if (plugin->system_vars) {\n    sys_var_pluginvar *var = plugin->system_vars->cast_pluginvar();\n    for (;;) {\n      var->plugin = plugin;\n      if (!var->next) break;\n      var = var->next->cast_pluginvar();\n    }\n  }\n\n  ret = 0;\n\nerr:\n  mysql_mutex_lock(&LOCK_plugin);\n  plugin->state = state;\n\n  return ret;\n}\n\nstatic inline void convert_dash_to_underscore(char *str, size_t len) {\n  for (char *p = str; p <= str + len; p++)\n    if (*p == '-') *p = '_';\n}\n\n#ifdef HAVE_PSI_INTERFACE\nstatic PSI_mutex_key key_LOCK_plugin;\nstatic PSI_mutex_key key_LOCK_plugin_delete;\nstatic PSI_mutex_key key_LOCK_plugin_install;\n\n/* clang-format off */\nstatic PSI_mutex_info all_plugin_mutexes[]=\n{\n  { &key_LOCK_plugin, \"LOCK_plugin\", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},\n  { &key_LOCK_plugin_delete, \"LOCK_plugin_delete\", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME},\n  { &key_LOCK_plugin_install, \"LOCK_plugin_install\", PSI_FLAG_SINGLETON, 0, PSI_DOCUMENT_ME}\n};\n/* clang-format on */\n\n/* clang-format off */\nstatic PSI_memory_info all_plugin_memory[]=\n{\n#ifndef DBUG_OFF\n  { &key_memory_plugin_ref, \"plugin_ref\", PSI_FLAG_ONLY_GLOBAL_STAT, 0, PSI_DOCUMENT_ME},\n#endif\n  { &key_memory_plugin_mem_root, \"plugin_mem_root\", PSI_FLAG_ONLY_GLOBAL_STAT, 0, PSI_DOCUMENT_ME},\n  { &key_memory_plugin_init_tmp, \"plugin_init_tmp\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_memory_plugin_int_mem_root, \"plugin_int_mem_root\", 0, 0, PSI_DOCUMENT_ME},\n  { &key_memory_mysql_plugin_dl, \"mysql_plugin_dl\", PSI_FLAG_ONLY_GLOBAL_STAT, 0, PSI_DOCUMENT_ME},\n  { &key_memory_mysql_plugin, \"mysql_plugin\", PSI_FLAG_ONLY_GLOBAL_STAT, 0, PSI_DOCUMENT_ME},\n  { &key_memory_plugin_bookmark, \"plugin_bookmark\", PSI_FLAG_ONLY_GLOBAL_STAT, 0, PSI_DOCUMENT_ME}\n};\n/* clang-format on */\n\nstatic void init_plugin_psi_keys(void) {\n  const char *category = \"sql\";\n  int count;\n\n  count = array_elements(all_plugin_mutexes);\n  mysql_mutex_register(category, all_plugin_mutexes, count);\n\n  count = array_elements(all_plugin_memory);\n  mysql_memory_register(category, all_plugin_memory, count);\n}\n#endif /* HAVE_PSI_INTERFACE */\n\n/**\n  Initialize the internals of the plugin system. Allocate required\n  resources, initialize mutex, etc.\n\n  @return Operation outcome, false means no errors\n */\nstatic bool plugin_init_internals() {\n#ifdef HAVE_PSI_INTERFACE\n  init_plugin_psi_keys();\n#endif\n\n  init_alloc_root(key_memory_plugin_mem_root, &plugin_mem_root, 4096, 4096);\n\n  bookmark_hash = new malloc_unordered_map<std::string, st_bookmark *>(\n      key_memory_plugin_bookmark);\n\n  malloced_string_type_sysvars_bookmark_hash =\n      new malloc_unordered_map<std::string, st_bookmark *>(\n          key_memory_plugin_bookmark);\n\n  mysql_mutex_init(key_LOCK_plugin, &LOCK_plugin, MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_plugin_delete, &LOCK_plugin_delete,\n                   MY_MUTEX_INIT_FAST);\n  mysql_mutex_init(key_LOCK_plugin_install, &LOCK_plugin_install,\n                   MY_MUTEX_INIT_FAST);\n\n  plugin_dl_array = new (std::nothrow)\n      Prealloced_array<st_plugin_dl *, 16>(key_memory_mysql_plugin_dl);\n  plugin_array = new (std::nothrow)\n      Prealloced_array<st_plugin_int *, 16>(key_memory_mysql_plugin);\n  if (plugin_dl_array == nullptr || plugin_array == nullptr) goto err;\n\n  for (uint i = 0; i < MYSQL_MAX_PLUGIN_TYPE_NUM; i++) {\n    plugin_hash[i] = new collation_unordered_map<std::string, st_plugin_int *>(\n        system_charset_info, key_memory_plugin_mem_root);\n  }\n  return false;\n\nerr:\n  return true;\n}\n\n/**\n  Initialize the plugins. Reap those that fail to initialize.\n\n  @return Operation outcome, false means no errors\n */\nstatic bool plugin_init_initialize_and_reap() {\n  struct st_plugin_int *plugin_ptr;\n  struct st_plugin_int **reap;\n\n  /* Now we initialize all plugins that are not already initialized */\n  mysql_mutex_lock(&LOCK_plugin);\n  reap =\n      (st_plugin_int **)my_alloca((plugin_array->size() + 1) * sizeof(void *));\n  *(reap++) = nullptr;\n\n  for (st_plugin_int **it = plugin_array->begin(); it != plugin_array->end();\n       ++it) {\n    plugin_ptr = *it;\n    if (plugin_ptr->state == PLUGIN_IS_UNINITIALIZED) {\n      if (plugin_initialize(plugin_ptr)) {\n        plugin_ptr->state = PLUGIN_IS_DYING;\n        *(reap++) = plugin_ptr;\n      }\n    }\n  }\n\n  /* Check if any plugins have to be reaped */\n  bool reaped_mandatory_plugin = false;\n  while ((plugin_ptr = *(--reap))) {\n    mysql_mutex_unlock(&LOCK_plugin);\n    if (plugin_ptr->load_option == PLUGIN_FORCE ||\n        plugin_ptr->load_option == PLUGIN_FORCE_PLUS_PERMANENT)\n      reaped_mandatory_plugin = true;\n    plugin_deinitialize(plugin_ptr, true);\n    mysql_mutex_lock(&LOCK_plugin_delete);\n    mysql_mutex_lock(&LOCK_plugin);\n    plugin_del(plugin_ptr);\n    mysql_mutex_unlock(&LOCK_plugin_delete);\n  }\n\n  mysql_mutex_unlock(&LOCK_plugin);\n  if (reaped_mandatory_plugin) return true;\n\n  return false;\n}\n\n/**\n   Register and initialize early plugins.\n\n   @param argc  Command line argument counter\n   @param argv  Command line arguments\n   @param flags Flags to control whether dynamic loading\n                and plugin initialization should be skipped\n\n   @return Operation outcome, false if no errors\n*/\nbool plugin_register_early_plugins(int *argc, char **argv, int flags) {\n  bool retval = false;\n  DBUG_TRACE;\n\n  /* Don't allow initializing twice */\n  DBUG_ASSERT(!initialized);\n\n  /* Make sure the internals are initialized */\n  if ((retval = plugin_init_internals())) return retval;\n\n  /* Allocate the temporary mem root, will be freed before returning */\n  MEM_ROOT tmp_root;\n  init_alloc_root(key_memory_plugin_init_tmp, &tmp_root, 4096, 4096);\n\n  I_List_iterator<i_string> iter(opt_early_plugin_load_list);\n  i_string *item;\n  while (nullptr != (item = iter++))\n    plugin_load_list(&tmp_root, argc, argv, item->ptr, true);\n\n  /* Temporary mem root not needed anymore, can free it here */\n  free_root(&tmp_root, MYF(0));\n\n  if (!(flags & PLUGIN_INIT_SKIP_INITIALIZATION))\n    retval = plugin_init_initialize_and_reap();\n\n  return retval;\n}\n\n/**\n  Register the builtin plugins. Some of the plugins (MyISAM, CSV and InnoDB)\n  are also initialized.\n\n  @param argc number of arguments, propagated to the plugin\n  @param argv actual arguments, propagated to the plugin\n  @return Operation outcome, false means no errors\n */\nbool plugin_register_builtin_and_init_core_se(int *argc, char **argv) {\n  bool mandatory = true;\n  DBUG_TRACE;\n\n  /* Don't allow initializing twice */\n  DBUG_ASSERT(!initialized);\n\n  /* Allocate the temporary mem root, will be freed before returning */\n  MEM_ROOT tmp_root;\n  init_alloc_root(key_memory_plugin_init_tmp, &tmp_root, 4096, 4096);\n\n  mysql_mutex_lock(&LOCK_plugin);\n  initialized = true;\n\n  /* First we register the builtin mandatory and optional plugins */\n  for (struct st_mysql_plugin **builtins = mysql_mandatory_plugins;\n       *builtins || mandatory; builtins++) {\n    /* Switch to optional plugins when done with the mandatory ones */\n    if (!*builtins) {\n      builtins = mysql_optional_plugins;\n      mandatory = false;\n      if (!*builtins) break;\n    }\n    for (struct st_mysql_plugin *plugin = *builtins; plugin->info; plugin++) {\n      struct st_plugin_int tmp;\n      tmp.plugin = plugin;\n      tmp.name.str = plugin->name;\n      tmp.name.length = strlen(plugin->name);\n      tmp.state = 0;\n      tmp.load_option = mandatory ? PLUGIN_FORCE : PLUGIN_ON;\n\n      /*\n        If the performance schema is compiled in,\n        treat the storage engine plugin as 'mandatory',\n        to suppress any plugin-level options such as '--performance-schema'.\n        This is specific to the performance schema, and is done on purpose:\n        the server-level option '--performance-schema' controls the overall\n        performance schema initialization, which consists of much more that\n        the underlying storage engine initialization.\n        See mysqld.cc, set_vars.cc.\n        Suppressing ways to interfere directly with the storage engine alone\n        prevents awkward situations where:\n        - the user wants the performance schema functionality, by using\n          '--enable-performance-schema' (the server option),\n        - yet disable explicitly a component needed for the functionality\n          to work, by using '--skip-performance-schema' (the plugin)\n      */\n      if (!my_strcasecmp(&my_charset_latin1, plugin->name,\n                         \"PERFORMANCE_SCHEMA\")) {\n        tmp.load_option = PLUGIN_FORCE;\n      }\n\n      free_root(&tmp_root, MYF(MY_MARK_BLOCKS_FREE));\n      if (test_plugin_options(&tmp_root, &tmp, argc, argv))\n        tmp.state = PLUGIN_IS_DISABLED;\n      else\n        tmp.state = PLUGIN_IS_UNINITIALIZED;\n\n      struct st_plugin_int *plugin_ptr;  // Pointer to registered plugin\n      if (register_builtin(plugin, &tmp, &plugin_ptr)) goto err_unlock;\n\n      /*\n        Only initialize MyISAM, InnoDB and CSV at this stage.\n        Note that when the --help option is supplied, InnoDB is not\n        initialized because the plugin table will not be read anyway,\n        as indicated by the flag set when the plugin_init() function\n        is called.\n      */\n      bool is_myisam =\n          !my_strcasecmp(&my_charset_latin1, plugin->name, \"MyISAM\");\n      bool is_innodb =\n          !my_strcasecmp(&my_charset_latin1, plugin->name, \"InnoDB\");\n      if (!is_myisam && (!is_innodb || is_help_or_validate_option()) &&\n          my_strcasecmp(&my_charset_latin1, plugin->name, \"CSV\"))\n        continue;\n\n      if (plugin_ptr->state != PLUGIN_IS_UNINITIALIZED ||\n          plugin_initialize(plugin_ptr))\n        goto err_unlock;\n\n      /*\n        Initialize the global default storage engine so that it may\n        not be null in any child thread.\n      */\n      if (is_myisam) {\n        DBUG_ASSERT(!global_system_variables.table_plugin);\n        DBUG_ASSERT(!global_system_variables.temp_table_plugin);\n        global_system_variables.table_plugin =\n            my_intern_plugin_lock(nullptr, plugin_int_to_ref(plugin_ptr));\n        global_system_variables.temp_table_plugin =\n            my_intern_plugin_lock(nullptr, plugin_int_to_ref(plugin_ptr));\n        DBUG_ASSERT(plugin_ptr->ref_count == 2);\n      }\n    }\n  }\n\n  /* Should now be set to MyISAM storage engine */\n  DBUG_ASSERT(global_system_variables.table_plugin);\n  DBUG_ASSERT(global_system_variables.temp_table_plugin);\n\n  mysql_mutex_unlock(&LOCK_plugin);\n\n  free_root(&tmp_root, MYF(0));\n  return false;\n\nerr_unlock:\n  mysql_mutex_unlock(&LOCK_plugin);\n  free_root(&tmp_root, MYF(0));\n  return true;\n}\n\nbool is_builtin_and_core_se_initialized() { return initialized; }\n\nnamespace dd {\nnamespace upgrade {\n\nconstexpr const char *delayed_plugins[] = {\"audit_log\", \"mysql_firewall\"};\n\n/**\n  Initialize delayed plugins.\n\n  This function is used to initialize plugins that depend on changes in\n  the environment if there has been upgrade of mysql tables used by\n  the plugins.\n\n  @note This function will initialize all plugins that are in state\n        PLUGIN_IS_UNINITIALIZED. Plugins that are not in the submitted\n        list of plugin names will either be in state PLUGIN_IS_READY\n        at this point, or they should have been reaped already.\n\n  @return Operation outcome, false if no errors\n*/\nbool plugin_initialize_delayed_after_upgrade() {\n  /* Make sure the internals are initialized and builtins registered */\n  if (!initialized) return true;\n\n  /*\n    Iterate over named plugins and change state from\n    PLUGIN_IS_WAITING_FOR_UPGRADE to PLUGIN_IS_UNINITIALIZED.\n  */\n  mysql_mutex_lock(&LOCK_plugin);\n  for (auto name : delayed_plugins) {\n    const LEX_CSTRING plugin_name = to_lex_cstring(name);\n    st_plugin_int *plugin_ptr =\n        plugin_find_internal(plugin_name, MYSQL_ANY_PLUGIN);\n    if (plugin_ptr != nullptr &&\n        plugin_ptr->state == PLUGIN_IS_WAITING_FOR_UPGRADE) {\n      plugin_ptr->state = PLUGIN_IS_UNINITIALIZED;\n    }\n  }\n  mysql_mutex_unlock(&LOCK_plugin);\n\n  /*\n    Then, initialize all plugins that are in state PLUGIN_UNINITIALIZED,\n    and reap those that fail to initialize. Plugins that failed to initialize\n    the last time we tried will have their state set to PLUGIN_IS_DYING, and\n    be deleted, so the plugins being initialized below should be only those\n    that are in the submitted list of plugin names.\n  */\n  Auto_THD fake_session;\n  Disable_autocommit_guard autocommit_guard(fake_session.thd);\n  dd::cache::Dictionary_client::Auto_releaser releaser(\n      fake_session.thd->dd_client());\n  if (plugin_init_initialize_and_reap())\n    return ::end_transaction(fake_session.thd, true);\n\n  return ::end_transaction(fake_session.thd, false);\n}\n\n/**\n  Reset state of delayed plugins to indicate that they wait for upgrade to\n  complete. This means they will not be initialized yet.\n*/\nvoid delay_initialization_of_dependent_plugins() {\n  mysql_mutex_lock(&LOCK_plugin);\n  for (auto name : delayed_plugins) {\n    const LEX_CSTRING plugin_name = to_lex_cstring(name);\n    st_plugin_int *plugin_ptr =\n        plugin_find_internal(plugin_name, MYSQL_ANY_PLUGIN);\n    if (plugin_ptr != nullptr && plugin_ptr->state == PLUGIN_IS_UNINITIALIZED) {\n      plugin_ptr->state = PLUGIN_IS_WAITING_FOR_UPGRADE;\n    }\n  }\n  mysql_mutex_unlock(&LOCK_plugin);\n}\n\n}  // namespace upgrade\n}  // namespace dd\n\n/**\n  Register and initialize the dynamic plugins. Also initialize\n  the remaining builtin plugins that are not initialized\n  already.\n\n  @param argc  Command line argument counter\n  @param argv  Command line arguments\n  @param flags Flags to control whether dynamic loading\n               and plugin initialization should be skipped\n\n  @return Operation outcome, false if no errors\n*/\nbool plugin_register_dynamic_and_init_all(int *argc, char **argv, int flags) {\n  DBUG_TRACE;\n\n  /* Make sure the internals are initialized and builtins registered */\n  if (!initialized) return true;\n\n  /* Register all dynamic plugins */\n  if (!(flags & PLUGIN_INIT_SKIP_DYNAMIC_LOADING)) {\n    /* Allocate the temporary mem root, will be freed before returning */\n    MEM_ROOT tmp_root;\n    init_alloc_root(key_memory_plugin_init_tmp, &tmp_root, 4096, 4096);\n\n    I_List_iterator<i_string> iter(opt_plugin_load_list);\n    i_string *item;\n    while (nullptr != (item = iter++))\n      plugin_load_list(&tmp_root, argc, argv, item->ptr, false);\n\n    if (!(flags & PLUGIN_INIT_SKIP_PLUGIN_TABLE))\n      plugin_load(&tmp_root, argc, argv);\n\n    /* Temporary mem root not needed anymore, can free it here */\n    free_root(&tmp_root, MYF(0));\n  } else if (!opt_plugin_load_list.is_empty()) {\n    /* Table is always empty at initialize */\n    DBUG_ASSERT(opt_initialize);\n    /* Tell the user the plugin-load[-add] is ignored if not empty */\n    LogErr(WARNING_LEVEL, ER_PLUGIN_LOAD_OPTIONS_IGNORED);\n  }\n\n  /*\n    Delay initialization of plugins that depend on the environment.\n  */\n  if ((flags & PLUGIN_INIT_DELAY_UNTIL_AFTER_UPGRADE)) {\n    dd::upgrade::delay_initialization_of_dependent_plugins();\n  }\n\n  /*\n    Initialize plugins that are in state 'PLUGIN_IS_UNINITIALIZED'.\n  */\n  Auto_THD fake_session;\n  Disable_autocommit_guard autocommit_guard(fake_session.thd);\n  dd::cache::Dictionary_client::Auto_releaser releaser(\n      fake_session.thd->dd_client());\n  if (!(flags & PLUGIN_INIT_SKIP_INITIALIZATION))\n    if (plugin_init_initialize_and_reap()) {\n      return ::end_transaction(fake_session.thd, true);\n    }\n\n  return ::end_transaction(fake_session.thd, false);\n}\n\nstatic bool register_builtin(st_mysql_plugin *plugin, st_plugin_int *tmp,\n                             st_plugin_int **ptr) {\n  DBUG_TRACE;\n  tmp->ref_count = 0;\n  tmp->plugin_dl = nullptr;\n\n  if (plugin_array->push_back(tmp)) return true;\n\n  *ptr = plugin_array->back() =\n      new (&plugin_mem_root) st_plugin_int(std::move(*tmp));\n\n  plugin_hash[plugin->type]->emplace(to_string((*ptr)->name), *ptr);\n\n  return false;\n}\n\n/**\n  Reads the plugins from mysql.plugin and loads them\n\n  Called only by plugin_register_dynamic_and_init_all()\n  a.k.a. the bootstrap sequence.\n\n  @arg tmp_root  memory root to use for plugin_add()\n  @arg argc      number of command line arguments to process\n  @arg argv      array of command line argument to read values from\n  @retval true   failure\n  @retval false  success\n*/\nstatic void plugin_load(MEM_ROOT *tmp_root, int *argc, char **argv) {\n  THD thd;\n  TABLE *table;\n  int error;\n  THD *new_thd = &thd;\n  bool result;\n  DBUG_TRACE;\n\n  TABLE_LIST tables(\"mysql\", \"plugin\", TL_READ);\n  new_thd->thread_stack = (char *)&tables;\n  new_thd->store_globals();\n  LEX_CSTRING db_lex_cstr = {STRING_WITH_LEN(\"mysql\")};\n  new_thd->set_db(db_lex_cstr);\n  thd.get_protocol_classic()->wipe_net();\n\n  result = open_trans_system_tables_for_read(new_thd, &tables);\n\n  if (result) {\n    DBUG_PRINT(\"error\", (\"Can't open plugin table\"));\n    LogErr(ERROR_LEVEL, ER_PLUGIN_CANT_OPEN_PLUGIN_TABLE);\n    return;\n  }\n  table = tables.table;\n  unique_ptr_destroy_only<RowIterator> iterator =\n      init_table_iterator(new_thd, table, nullptr, false,\n                          /*ignore_not_found_rows=*/false);\n  if (iterator == nullptr) {\n    close_trans_system_tables(new_thd);\n    return;\n  }\n  table->use_all_columns();\n  /*\n    there're no other threads running yet, so we don't need a mutex.\n    but plugin_add() before is designed to work in multi-threaded\n    environment, and it uses mysql_mutex_assert_owner(), so we lock\n    the mutex here to satisfy the assert\n  */\n  while (!(error = iterator->Read())) {\n    DBUG_PRINT(\"info\", (\"init plugin record\"));\n    String str_name, str_dl;\n    get_field(tmp_root, table->field[0], &str_name);\n    get_field(tmp_root, table->field[1], &str_dl);\n\n    LEX_CSTRING name = str_name.lex_cstring();\n    LEX_STRING dl = str_dl.lex_string();\n\n    /*\n      The whole locking sequence is not strictly speaking needed since this\n      is a function that's executed only during server bootstrap, but we do\n      it properly for uniformity of the environment for plugin_add.\n      Note that it must be done for each iteration since, unlike INSTALL PLUGIN\n      the bootstrap process just reports the error and goes on.\n      So to ensure the right sequence of lock and unlock we need to take and\n      release both the wlock and the mutex.\n    */\n    mysql_mutex_lock(&LOCK_plugin);\n    mysql_rwlock_wrlock(&LOCK_system_variables_hash);\n    if (plugin_add(tmp_root, name, &dl, argc, argv, REPORT_TO_LOG, false)) {\n      LogErr(WARNING_LEVEL, ER_PLUGIN_CANT_LOAD, str_name.c_ptr(),\n             str_dl.c_ptr());\n    } else {\n      mysql_rwlock_unlock(&LOCK_system_variables_hash);\n      mysql_mutex_unlock(&LOCK_plugin);\n    }\n    free_root(tmp_root, MYF(MY_MARK_BLOCKS_FREE));\n  }\n  if (error > 0) {\n    char errbuf[MYSQL_ERRMSG_SIZE];\n    LogErr(ERROR_LEVEL, ER_GET_ERRNO_FROM_STORAGE_ENGINE, my_errno(),\n           my_strerror(errbuf, MYSQL_ERRMSG_SIZE, my_errno()));\n  }\n  iterator.reset();\n  table->m_needs_reopen = true;  // Force close to free memory\n\n  close_trans_system_tables(new_thd);\n}\n\n/**\n  Load a list of plugins\n\n  Called by plugin_register_early_plugins() and\n  plugin_register_dynamic_and_init_all(), a.k.a. the bootstrap sequence.\n\n  @arg tmp_root  memory root to use for plugin_add()\n  @arg argc      number of command line arguments to process\n  @arg argv      array of command line argument to read values from\n  @arg list      list of plugins to load. Ends with a NULL pointer\n  @arg load_early true if loading plugins via --early-plugin-load or migration\n  @retval true   failure\n  @retval false  success\n*/\nstatic bool plugin_load_list(MEM_ROOT *tmp_root, int *argc, char **argv,\n                             const char *list, bool load_early) {\n  char buffer[FN_REFLEN];\n  LEX_STRING name = {buffer, 0}, dl = {nullptr, 0}, *str = &name;\n  st_plugin_dl *plugin_dl;\n  st_mysql_plugin *plugin;\n  char *p = buffer;\n  DBUG_TRACE;\n  while (list) {\n    if (p == buffer + sizeof(buffer) - 1) {\n      LogErr(ERROR_LEVEL, ER_PLUGIN_LOAD_PARAMETER_TOO_LONG);\n      return true;\n    }\n\n    switch ((*(p++) = *(list++))) {\n      case '\\0':\n        list = nullptr; /* terminate the loop */\n                        /* fall through */\n      case ';':\n#ifndef _WIN32\n      case ':': /* can't use this as delimiter as it may be drive letter */\n#endif\n        str->str[str->length] = '\\0';\n        if (str == &name)  // load all plugins in named module\n        {\n          if (!name.length) {\n            p--; /* reset pointer */\n            continue;\n          }\n\n          dl = name;\n          /*\n            The whole locking sequence is not strictly speaking needed since\n            this is a function that's executed only during server bootstrap, but\n            we do it properly for uniformity of the environment for plugin_add.\n          */\n          mysql_mutex_lock(&LOCK_plugin);\n          mysql_rwlock_wrlock(&LOCK_system_variables_hash);\n          if ((plugin_dl = plugin_dl_add(&dl, REPORT_TO_LOG, load_early))) {\n            for (plugin = plugin_dl->plugins; plugin->info; plugin++) {\n              name.str = const_cast<char *>(plugin->name);\n              name.length = strlen(name.str);\n\n              free_root(tmp_root, MYF(MY_MARK_BLOCKS_FREE));\n              if (plugin_add(tmp_root, to_lex_cstring(name), &dl, argc, argv,\n                             REPORT_TO_LOG, load_early))\n                goto error;\n            }\n            plugin_dl_del(&dl);  // reduce ref count\n          } else\n            goto error;\n        } else {\n          free_root(tmp_root, MYF(MY_MARK_BLOCKS_FREE));\n          /*\n            The whole locking sequence is not strictly speaking needed since\n            this is a function that's executed only during server bootstrap, but\n            we do it properly for uniformity of the environment for plugin_add.\n          */\n          mysql_mutex_lock(&LOCK_plugin);\n          mysql_rwlock_wrlock(&LOCK_system_variables_hash);\n          if (plugin_add(tmp_root, to_lex_cstring(name), &dl, argc, argv,\n                         REPORT_TO_LOG, load_early))\n            goto error;\n        }\n        mysql_rwlock_unlock(&LOCK_system_variables_hash);\n        mysql_mutex_unlock(&LOCK_plugin);\n        name.length = dl.length = 0;\n        dl.str = nullptr;\n        name.str = p = buffer;\n        str = &name;\n        continue;\n      case '=':\n      case '#':\n        if (str == &name) {\n          name.str[name.length] = '\\0';\n          str = &dl;\n          str->str = p;\n          continue;\n        }\n        // Fall through.\n      default:\n        str->length++;\n        continue;\n    }\n  }\n  return false;\nerror:\n  LogErr(ERROR_LEVEL, ER_PLUGIN_CANT_LOAD, name.str, dl.str);\n  return true;\n}\n\n/*\n  Shutdown memcached plugin before binlog shuts down\n*/\nvoid memcached_shutdown(void) {\n  if (initialized) {\n    for (st_plugin_int **it = plugin_array->begin(); it != plugin_array->end();\n         ++it) {\n      st_plugin_int *plugin = *it;\n\n      if (plugin->state == PLUGIN_IS_READY &&\n          strcmp(plugin->name.str, \"daemon_memcached\") == 0) {\n        plugin_deinitialize(plugin, true);\n\n        mysql_mutex_lock(&LOCK_plugin_delete);\n        mysql_mutex_lock(&LOCK_plugin);\n        plugin->state = PLUGIN_IS_DYING;\n        plugin_del(plugin);\n        mysql_mutex_unlock(&LOCK_plugin);\n        mysql_mutex_unlock(&LOCK_plugin_delete);\n      }\n    }\n  }\n}\n\n/*\n  Deinitialize and unload all the loaded plugins.\n  Note: During valgrind testing, the shared objects (.dll/.so)\n        are not unloaded in order to keep the call stack\n        of the leaked objects.\n*/\nvoid plugin_shutdown(void) {\n  size_t i;\n  st_plugin_int **plugins, *plugin;\n  st_plugin_dl **dl;\n  bool skip_binlog = true;\n  std::list<st_plugin_int *> keyring_plugins;\n\n  DBUG_TRACE;\n\n  if (initialized) {\n    size_t count = plugin_array->size();\n    mysql_mutex_lock(&LOCK_plugin);\n\n    reap_needed = true;\n\n    /*\n      We want to shut down plugins in a reasonable order, this will\n      become important when we have plugins which depend upon each other.\n      Circular references cannot be reaped so they are forced afterwards.\n      TODO: Have an additional step here to notify all active plugins that\n      shutdown is requested to allow plugins to deinitialize in parallel.\n    */\n    while (reap_needed && (count = plugin_array->size())) {\n      reap_plugins();\n      for (i = 0; i < count; i++) {\n        plugin = plugin_array->at(i);\n\n        if (plugin->state == PLUGIN_IS_READY) {\n          if (strcmp(plugin->name.str, \"binlog\") == 0 && skip_binlog) {\n            skip_binlog = false;\n          } else if (plugin->plugin->type != MYSQL_KEYRING_PLUGIN) {\n            plugin->state = PLUGIN_IS_DELETED;\n            reap_needed = true;\n          } else if (plugin->plugin->type == MYSQL_KEYRING_PLUGIN)\n            keyring_plugins.push_back(plugin);\n        }\n      }\n      if (!reap_needed) {\n        /*\n          release any plugin references held.\n        */\n        unlock_variables(&global_system_variables);\n        unlock_variables(&max_system_variables);\n      }\n    }\n\n    plugins = (st_plugin_int **)my_alloca(sizeof(void *) * (count + 1));\n\n    /*\n      If we have any plugins which did not die cleanly, we force shutdown\n    */\n    for (i = 0; i < count; i++) {\n      plugins[i] = plugin_array->at(i);\n      /* change the state to ensure no reaping races */\n      if (plugins[i]->state == PLUGIN_IS_DELETED)\n        plugins[i]->state = PLUGIN_IS_DYING;\n    }\n    mysql_mutex_unlock(&LOCK_plugin);\n\n    for (std::list<st_plugin_int *>::iterator keyring_iter =\n             keyring_plugins.begin();\n         keyring_iter != keyring_plugins.end(); ++keyring_iter) {\n      if (!((*keyring_iter)->state & PLUGIN_IS_UNINITIALIZED))\n        plugin_deinitialize(*keyring_iter, false);\n    }\n\n    /*\n      We loop through all plugins and call deinit() if they have one.\n    */\n    for (i = 0; i < count; i++)\n      if (!(plugins[i]->state &\n            (PLUGIN_IS_UNINITIALIZED | PLUGIN_IS_FREED | PLUGIN_IS_DISABLED))) {\n        LogErr(WARNING_LEVEL, ER_PLUGIN_FORCING_SHUTDOWN, plugins[i]->name.str);\n        /*\n          We are forcing deinit on plugins so we don't want to do a ref_count\n          check until we have processed all the plugins.\n        */\n        plugin_deinitialize(plugins[i], false);\n      }\n\n    /*\n      It's perfectly safe not to lock LOCK_plugin, LOCK_plugin_delete, as\n      there're no concurrent threads anymore. But some functions called from\n      here use mysql_mutex_assert_owner(), so we lock the mutex to satisfy it\n    */\n    mysql_mutex_lock(&LOCK_plugin_delete);\n    mysql_mutex_lock(&LOCK_plugin);\n\n    /*\n      We defer checking ref_counts until after all plugins are deinitialized\n      as some may have worker threads holding on to plugin references.\n    */\n    for (i = 0; i < count; i++) {\n      if (plugins[i]->ref_count)\n        LogErr(ERROR_LEVEL, ER_PLUGIN_HAS_NONZERO_REFCOUNT_AFTER_SHUTDOWN,\n               plugins[i]->name.str, plugins[i]->ref_count);\n      if (plugins[i]->state & PLUGIN_IS_UNINITIALIZED) plugin_del(plugins[i]);\n    }\n\n    /*\n      Now we can deallocate all memory.\n    */\n\n    cleanup_variables(nullptr, &global_system_variables);\n    cleanup_variables(nullptr, &max_system_variables);\n    mysql_mutex_unlock(&LOCK_plugin);\n    mysql_mutex_unlock(&LOCK_plugin_delete);\n\n    initialized = false;\n    mysql_mutex_destroy(&LOCK_plugin);\n    mysql_mutex_destroy(&LOCK_plugin_delete);\n    mysql_mutex_destroy(&LOCK_plugin_install);\n  }\n\n  /* Dispose of the memory */\n\n  for (i = 0; i < MYSQL_MAX_PLUGIN_TYPE_NUM; i++) {\n    delete plugin_hash[i];\n    plugin_hash[i] = nullptr;\n  }\n  delete plugin_array;\n  plugin_array = nullptr;\n\n  if (plugin_dl_array != nullptr) {\n    size_t count = plugin_dl_array->size();\n    dl = (st_plugin_dl **)my_alloca(sizeof(void *) * count);\n    for (i = 0; i < count; i++) dl[i] = plugin_dl_array->at(i);\n    for (i = 0; i < plugin_dl_array->size(); i++) free_plugin_mem(dl[i]);\n    delete plugin_dl_array;\n    plugin_dl_array = nullptr;\n  }\n\n  delete bookmark_hash;\n  bookmark_hash = nullptr;\n  delete malloced_string_type_sysvars_bookmark_hash;\n  malloced_string_type_sysvars_bookmark_hash = nullptr;\n  free_root(&plugin_mem_root, MYF(0));\n\n  global_variables_dynamic_size = 0;\n}\n\n// Helper function to do rollback or commit, depending on error.\nbool end_transaction(THD *thd, bool error) {\n  if (error) {\n    // Rollback the statement before we can rollback the real transaction.\n    trans_rollback_stmt(thd);\n    trans_rollback(thd);\n  } else if (trans_commit_stmt(thd) || trans_commit(thd)) {\n    error = true;\n    trans_rollback(thd);\n  }\n\n  // Close tables regardless of error.\n  close_thread_tables(thd);\n  return error;\n}\n\n/**\n  Initialize one plugin. This function is used to early load one single\n  plugin. This function is used by key migration tool.\n\n   @param[in]   argc  Command line argument counter\n   @param[in]   argv  Command line arguments\n   @param[in]   plugin library file name\n\n   @return Operation status\n     @retval 0 OK\n     @retval 1 ERROR\n*/\nbool plugin_early_load_one(int *argc, char **argv, const char *plugin) {\n  bool retval = false;\n  DBUG_TRACE;\n\n  /* Make sure the internals are initialized */\n  if (!initialized) {\n    if ((retval = plugin_init_internals()))\n      return retval;\n    else\n      initialized = true;\n  }\n  /* Allocate the temporary mem root, will be freed before returning */\n  MEM_ROOT tmp_root;\n  init_alloc_root(PSI_NOT_INSTRUMENTED, &tmp_root, 4096, 4096);\n\n  plugin_load_list(&tmp_root, argc, argv, plugin, true);\n\n  /* Temporary mem root not needed anymore, can free it here */\n  free_root(&tmp_root, MYF(0));\n\n  retval = plugin_init_initialize_and_reap();\n\n  return retval;\n}\n\nstatic bool mysql_install_plugin(THD *thd, LEX_CSTRING name,\n                                 const LEX_STRING *dl) {\n  TABLE *table;\n  bool error = true;\n  int argc = orig_argc;\n  char **argv = orig_argv;\n  st_plugin_int *tmp = nullptr;\n  bool store_infoschema_metadata = false;\n  dd::Schema_MDL_locker mdl_handler(thd);\n  Persisted_variables_cache *pv = Persisted_variables_cache::get_instance();\n\n  DBUG_TRACE;\n\n  Disable_autocommit_guard autocommit_guard(thd);\n  dd::cache::Dictionary_client::Auto_releaser releaser(thd->dd_client());\n\n  TABLE_LIST tables(\"mysql\", \"plugin\", TL_WRITE);\n\n  if (!opt_noacl &&\n      check_table_access(thd, INSERT_ACL, &tables, false, 1, false))\n    return true;\n\n  if (acquire_shared_global_read_lock(thd, thd->variables.lock_wait_timeout) ||\n      acquire_shared_backup_lock(thd, thd->variables.lock_wait_timeout))\n    return true;\n\n  /* need to open before acquiring LOCK_plugin or it will deadlock */\n  if (!(table = open_ltable(thd, &tables, TL_WRITE, MYSQL_LOCK_IGNORE_TIMEOUT)))\n    return true;\n\n  /*\n    Pre-acquire audit plugins for events that may potentially occur\n    during [UN]INSTALL PLUGIN.\n\n    When audit event is triggered, audit subsystem acquires interested\n    plugins by walking through plugin list. Evidently plugin list\n    iterator protects plugin list by acquiring LOCK_plugin, see\n    plugin_foreach_with_mask().\n\n    On the other hand [UN]INSTALL PLUGIN is acquiring LOCK_plugin\n    rather for a long time.\n\n    When audit event is triggered during [UN]INSTALL PLUGIN, plugin\n    list iterator acquires the same lock (within the same thread)\n    second time.\n\n    This hack should be removed when LOCK_plugin is fixed so it\n    protects only what it supposed to protect.\n    */\n  mysql_audit_acquire_plugins(thd, MYSQL_AUDIT_GENERAL_CLASS,\n                              MYSQL_AUDIT_GENERAL_ALL);\n\n  mysql_mutex_lock(&LOCK_plugin_install);\n  mysql_mutex_lock(&LOCK_plugin);\n  DEBUG_SYNC(thd, \"acquired_LOCK_plugin\");\n  mysql_rwlock_wrlock(&LOCK_system_variables_hash);\n\n  {\n    MEM_ROOT alloc{PSI_NOT_INSTRUMENTED, 512};\n    my_getopt_use_args_separator = true;\n    if (my_load_defaults(MYSQL_CONFIG_NAME, load_default_groups, &argc, &argv,\n                         &alloc, nullptr)) {\n      mysql_rwlock_unlock(&LOCK_system_variables_hash);\n      mysql_mutex_unlock(&LOCK_plugin);\n      report_error(REPORT_TO_USER, ER_PLUGIN_IS_NOT_LOADED, name.str);\n      goto err;\n    }\n    my_getopt_use_args_separator = false;\n    /*\n     Append static variables present in mysqld-auto.cnf file for the\n     newly installed plugin to process those options which are specific\n     to this plugin.\n    */\n    if (pv && pv->append_read_only_variables(&argc, &argv, true)) {\n      mysql_rwlock_unlock(&LOCK_system_variables_hash);\n      mysql_mutex_unlock(&LOCK_plugin);\n      report_error(REPORT_TO_USER, ER_PLUGIN_IS_NOT_LOADED, name.str);\n      goto err;\n    }\n    error =\n        plugin_add(thd->mem_root, name, dl, &argc, argv, REPORT_TO_USER, false);\n  }\n\n  /* LOCK_plugin and LOCK_system_variables_hash already unlocked by plugin_add()\n     if error */\n  if (error) goto err;\n\n  mysql_rwlock_unlock(&LOCK_system_variables_hash);\n  if (!(tmp = plugin_find_internal(name, MYSQL_ANY_PLUGIN))) {\n    mysql_mutex_unlock(&LOCK_plugin);\n    goto err;\n  }\n\n  error = false;\n  if (tmp->state == PLUGIN_IS_DISABLED) {\n    push_warning_printf(thd, Sql_condition::SL_WARNING, ER_CANT_INITIALIZE_UDF,\n                        ER_THD(thd, ER_CANT_INITIALIZE_UDF), name.str,\n                        \"Plugin is disabled\");\n  }\n\n  // Check if we need to store I_S plugin metadata in DD.\n  store_infoschema_metadata =\n      (tmp->plugin->type == MYSQL_INFORMATION_SCHEMA_PLUGIN &&\n       tmp->state != PLUGIN_IS_DISABLED);\n  mysql_mutex_unlock(&LOCK_plugin);\n\n  // Acquire MDL lock if we are storing metadata in DD.\n  if (store_infoschema_metadata) {\n    if (!mdl_handler.ensure_locked(INFORMATION_SCHEMA_NAME.str)) {\n      MDL_request mdl_request;\n      MDL_REQUEST_INIT(&mdl_request, MDL_key::TABLE,\n                       INFORMATION_SCHEMA_NAME.str, tmp->name.str,\n                       MDL_EXCLUSIVE, MDL_TRANSACTION);\n      if (thd->mdl_context.acquire_lock(&mdl_request,\n                                        thd->variables.lock_wait_timeout))\n        error = true;\n    } else\n      error = true;\n\n    if (error) {\n      report_error(REPORT_TO_USER, ER_DA_PLUGIN_INSTALL_ERROR, name.str,\n                   \"error acquiring metadata lock\");\n    }\n  }\n\n  /*\n    We do not replicate the INSTALL PLUGIN statement. Disable binlogging\n    of the insert into the plugin table, so that it is not replicated in\n    row based mode.\n  */\n  if (!error) {\n    Disable_binlog_guard binlog_guard(thd);\n    table->use_all_columns();\n    restore_record(table, s->default_values);\n    table->field[0]->store(name.str, name.length, system_charset_info);\n    table->field[1]->store(dl->str, dl->length, files_charset_info);\n    error = table->file->ha_write_row(table->record[0]);\n    if (error) {\n      const char msg[] = \"got '%s' writing to mysql.plugin\";\n      char buf[MYSQL_ERRMSG_SIZE + sizeof(msg) - 2];\n      char errbuf[MYSQL_ERRMSG_SIZE];\n      my_strerror(errbuf, sizeof(errbuf), error);\n      snprintf(buf, sizeof(buf), msg, errbuf);\n      report_error(REPORT_TO_USER, ER_DA_PLUGIN_INSTALL_ERROR, name.str, buf);\n    } else {\n      mysql_mutex_lock(&LOCK_plugin);\n\n      if (tmp->state != PLUGIN_IS_DISABLED && plugin_initialize(tmp)) {\n        my_error(ER_CANT_INITIALIZE_UDF, MYF(0), name.str,\n                 \"Plugin initialization function failed.\");\n        error = true;\n      }\n\n      /*\n        Store plugin I_S table metadata into DD tables. The\n        tables are closed before the function returns.\n       */\n      error = error || thd->transaction_rollback_request;\n      if (!error && store_infoschema_metadata) {\n        error = dd::info_schema::store_dynamic_plugin_I_S_metadata(thd, tmp);\n        if (error) {\n          report_error(REPORT_TO_USER, ER_DA_PLUGIN_INSTALL_ERROR, name.str,\n                       \"error storing metadata\");\n        }\n      }\n      mysql_mutex_unlock(&LOCK_plugin);\n\n      if (!error && store_infoschema_metadata) {\n        Uncommitted_tables_guard uncommitted_tables(thd);\n        error = update_referencing_views_metadata(\n            thd, INFORMATION_SCHEMA_NAME.str, tmp->name.str, false,\n            &uncommitted_tables);\n        if (error) {\n          report_error(REPORT_TO_USER, ER_DA_PLUGIN_INSTALL_ERROR, name.str,\n                       \"error updating metadata\");\n        }\n      }\n    }\n  }\n\n  if (error) {\n    mysql_mutex_lock(&LOCK_plugin);\n    tmp->state = PLUGIN_IS_DELETED;\n    reap_needed = true;\n    reap_plugins();\n    mysql_mutex_unlock(&LOCK_plugin);\n  }\n\nerr:\n  mysql_mutex_unlock(&LOCK_plugin_install);\n  return end_transaction(thd, error);\n}\n\nstatic bool mysql_uninstall_plugin(THD *thd, LEX_CSTRING name) {\n  TABLE *table;\n  st_plugin_int *plugin;\n  bool error = true;\n  int rc = 0;\n  bool remove_IS_metadata_from_dd = false;\n  dd::Schema_MDL_locker mdl_handler(thd);\n  dd::String_type orig_plugin_name;\n\n  DBUG_TRACE;\n\n  TABLE_LIST tables(\"mysql\", 5, \"plugin\", 6, \"plugin\", TL_WRITE);\n\n  if (!opt_noacl &&\n      check_table_access(thd, DELETE_ACL, &tables, false, 1, false)) {\n    DBUG_ASSERT(thd->is_error());\n    return true;\n  }\n\n  if (acquire_shared_global_read_lock(thd, thd->variables.lock_wait_timeout) ||\n      acquire_shared_backup_lock(thd, thd->variables.lock_wait_timeout))\n    return true;\n\n  Disable_autocommit_guard autocommit_guard(thd);\n  dd::cache::Dictionary_client::Auto_releaser releaser(thd->dd_client());\n  /* need to open before acquiring LOCK_plugin or it will deadlock */\n  if (!(table =\n            open_ltable(thd, &tables, TL_WRITE, MYSQL_LOCK_IGNORE_TIMEOUT))) {\n    DBUG_ASSERT(thd->is_error());\n    return true;\n  }\n\n  mysql_mutex_lock(&LOCK_plugin_install);\n  if (!table->key_info) {\n    my_error(ER_MISSING_KEY, MYF(0), table->s->db.str,\n             table->s->table_name.str);\n    goto err;\n  }\n\n  /*\n    Pre-acquire audit plugins for events that may potentially occur\n    during [UN]INSTALL PLUGIN.\n\n    When audit event is triggered, audit subsystem acquires interested\n    plugins by walking through plugin list. Evidently plugin list\n    iterator protects plugin list by acquiring LOCK_plugin, see\n    plugin_foreach_with_mask().\n\n    On the other hand [UN]INSTALL PLUGIN is acquiring LOCK_plugin\n    rather for a long time.\n\n    When audit event is triggered during [UN]INSTALL PLUGIN, plugin\n    list iterator acquires the same lock (within the same thread)\n    second time.\n\n    This hack should be removed when LOCK_plugin is fixed so it\n    protects only what it supposed to protect.\n  */\n  mysql_audit_acquire_plugins(thd, MYSQL_AUDIT_GENERAL_CLASS,\n                              MYSQL_AUDIT_GENERAL_ALL);\n\n  mysql_mutex_lock(&LOCK_plugin);\n  if (!(plugin = plugin_find_internal(name, MYSQL_ANY_PLUGIN)) ||\n      plugin->state & (PLUGIN_IS_UNINITIALIZED | PLUGIN_IS_DYING)) {\n    mysql_mutex_unlock(&LOCK_plugin);\n    my_error(ER_SP_DOES_NOT_EXIST, MYF(0), \"PLUGIN\", name.str);\n    goto err;\n  }\n  if (!plugin->plugin_dl) {\n    mysql_mutex_unlock(&LOCK_plugin);\n    my_error(ER_PLUGIN_DELETE_BUILTIN, MYF(0));\n    goto err;\n  }\n  if (plugin->load_option == PLUGIN_FORCE_PLUS_PERMANENT) {\n    mysql_mutex_unlock(&LOCK_plugin);\n    my_error(ER_PLUGIN_IS_PERMANENT, MYF(0), name.str);\n    goto err;\n  }\n  /*\n    Error message for ER_PLUGIN_IS_PERMANENT is not suitable for\n    plugins marked as not dynamically uninstallable, so we have a\n    separate one instead of changing the old one.\n   */\n  if (plugin->plugin->flags & PLUGIN_OPT_NO_UNINSTALL) {\n    mysql_mutex_unlock(&LOCK_plugin);\n    my_error(ER_PLUGIN_NO_UNINSTALL, MYF(0), plugin->plugin->name);\n    goto err;\n  }\n\n  /*\n    FIXME: plugin rpl_semi_sync_master, check_uninstall() function.\n  */\n\n  /* Block Uninstallation of semi_sync plugins (Master/Slave)\n     when they are busy\n   */\n  char buff[20];\n  size_t buff_length;\n  /*\n    Master: If there are active semi sync slaves for this Master,\n    then that means it is busy and rpl_semi_sync_master plugin\n    cannot be uninstalled. To check whether the master\n    has any semi sync slaves or not, check Rpl_semi_sync_master_cliens\n    status variable value, if it is not 0, that means it is busy.\n  */\n  if (!strcmp(name.str, \"rpl_semi_sync_master\") &&\n      get_status_var(thd, plugin->plugin->status_vars,\n                     \"Rpl_semi_sync_master_clients\", buff, OPT_DEFAULT,\n                     &buff_length) &&\n      strcmp(buff, \"0\")) {\n    mysql_mutex_unlock(&LOCK_plugin);\n    my_error(ER_PLUGIN_CANNOT_BE_UNINSTALLED, MYF(0), name.str,\n             \"Stop any active semisynchronous slaves of this master first.\");\n    goto err;\n  }\n\n  /*\n    FIXME: plugin rpl_semi_sync_slave, check_uninstall() function.\n  */\n\n  /* Slave: If there is semi sync enabled IO thread active on this Slave,\n    then that means plugin is busy and rpl_semi_sync_slave plugin\n    cannot be uninstalled. To check whether semi sync\n    IO thread is active or not, check Rpl_semi_sync_slave_status status\n    variable value, if it is ON, that means it is busy.\n  */\n  if (!strcmp(name.str, \"rpl_semi_sync_slave\") &&\n      get_status_var(thd, plugin->plugin->status_vars,\n                     \"Rpl_semi_sync_slave_status\", buff, OPT_DEFAULT,\n                     &buff_length) &&\n      !strcmp(buff, \"ON\")) {\n    mysql_mutex_unlock(&LOCK_plugin);\n    my_error(\n        ER_PLUGIN_CANNOT_BE_UNINSTALLED, MYF(0), name.str,\n        \"Stop any active semisynchronous I/O threads on this slave first.\");\n    goto err;\n  }\n\n  if ((plugin->plugin->check_uninstall) && (plugin->state == PLUGIN_IS_READY)) {\n    int check;\n    /*\n      Prevent other threads to uninstall concurrently this plugin.\n    */\n    plugin->state = PLUGIN_IS_DYING;\n    mysql_mutex_unlock(&LOCK_plugin);\n\n    DEBUG_SYNC(current_thd, \"in_plugin_check_uninstall\");\n\n    /*\n      Check uninstall may perform complex operations,\n      including acquiring MDL locks, which in turn may need LOCK_plugin.\n    */\n    DBUG_PRINT(\"info\", (\"check uninstall plugin: '%s'\", plugin->name.str));\n    check = plugin->plugin->check_uninstall(plugin);\n\n    mysql_mutex_lock(&LOCK_plugin);\n    DBUG_ASSERT(plugin->state == PLUGIN_IS_DYING);\n\n    if (check) {\n      DBUG_PRINT(\"warning\",\n                 (\"Plugin '%s' blocked uninstall.\", plugin->name.str));\n      plugin->state = PLUGIN_IS_READY;\n      mysql_mutex_unlock(&LOCK_plugin);\n      my_error(ER_PLUGIN_CANNOT_BE_UNINSTALLED, MYF(0), name.str,\n               \"Plugin is still in use.\");\n      goto err;\n    }\n  }\n\n  if (plugin->ref_count && plugin->plugin->type == MYSQL_KEYRING_PLUGIN) {\n    mysql_mutex_unlock(&LOCK_plugin);\n\n    my_error(ER_PLUGIN_CANNOT_BE_UNINSTALLED, MYF(0), name.str,\n             \"Plugin is busy, it cannot be uninstalled. \");\n    goto err;\n  }\n\n  plugin->state = PLUGIN_IS_DELETED;\n  if (plugin->ref_count)\n    push_warning(thd, Sql_condition::SL_WARNING, WARN_PLUGIN_BUSY,\n                 ER_THD(thd, WARN_PLUGIN_BUSY));\n  else\n    reap_needed = true;\n\n  // Check if we need to remove I_S plugin metadata from DD.\n  remove_IS_metadata_from_dd =\n      (plugin->plugin->type == MYSQL_INFORMATION_SCHEMA_PLUGIN &&\n       plugin->load_option != PLUGIN_OFF);\n\n  orig_plugin_name = dd::String_type(plugin->name.str, plugin->name.length);\n  reap_plugins();\n  mysql_mutex_unlock(&LOCK_plugin);\n\n  uchar user_key[MAX_KEY_LENGTH];\n  table->use_all_columns();\n  table->field[0]->store(name.str, name.length, system_charset_info);\n  key_copy(user_key, table->record[0], table->key_info,\n           table->key_info->key_length);\n\n  if ((rc = table->file->ha_index_read_idx_map(\n           table->record[0], 0, user_key, HA_WHOLE_KEY, HA_READ_KEY_EXACT)) ==\n      0) {\n    /*\n      We do not replicate the UNINSTALL PLUGIN statement. Disable binlogging\n      of the delete from the plugin table, so that it is not replicated in\n      row based mode.\n    */\n    DBUG_ASSERT(!thd->is_error());\n    Disable_binlog_guard binlog_guard(thd);\n    rc = table->file->ha_delete_row(table->record[0]);\n    if (rc) {\n      DBUG_ASSERT(thd->is_error());\n    } else\n      error = false;\n  } else if (rc != HA_ERR_KEY_NOT_FOUND && rc != HA_ERR_END_OF_FILE) {\n    DBUG_ASSERT(thd->is_error());\n  } else\n    error = false;\n\n  if (error) {\n    const char msg[] = \"got '%s' deleting from mysql.plugin\";\n    char buf[MYSQL_ERRMSG_SIZE + sizeof(msg) - 2];\n    char errbuf[MYSQL_ERRMSG_SIZE];\n    my_strerror(errbuf, sizeof(errbuf), error);\n    snprintf(buf, sizeof(buf), msg, errbuf);\n    report_error(REPORT_TO_USER, ER_PLUGIN_UNINSTALL_ERROR, name.str, buf);\n  }\n\n  if (!error && !thd->transaction_rollback_request &&\n      remove_IS_metadata_from_dd) {\n    error = dd::info_schema::remove_I_S_view_metadata(\n        thd,\n        dd::String_type(orig_plugin_name.c_str(), orig_plugin_name.length()));\n    DBUG_ASSERT(!error || thd->is_error());\n\n    if (!error) {\n      Uncommitted_tables_guard uncommitted_tables(thd);\n      error = update_referencing_views_metadata(\n          thd, INFORMATION_SCHEMA_NAME.str, orig_plugin_name.c_str(), false,\n          &uncommitted_tables);\n    }\n\n    if (error) {\n      report_error(REPORT_TO_USER, ER_PLUGIN_UNINSTALL_ERROR, name.str,\n                   \"error updating metadata\");\n    }\n  }\n\nerr:\n  mysql_mutex_unlock(&LOCK_plugin_install);\n  return end_transaction(thd, error || thd->transaction_rollback_request);\n}\n\nbool plugin_foreach_with_mask(THD *thd, plugin_foreach_func **funcs, int type,\n                              uint state_mask, void *arg) {\n  size_t idx, total;\n  st_plugin_int *plugin, **plugins;\n  int version = plugin_array_version;\n  DBUG_TRACE;\n\n  if (!initialized) return false;\n\n  state_mask = ~state_mask;  // do it only once\n\n  mysql_mutex_lock(&LOCK_plugin);\n  total = type == MYSQL_ANY_PLUGIN ? plugin_array->size()\n                                   : plugin_hash[type]->size();\n  /*\n    Do the alloca out here in case we do have a working alloca:\n        leaving the nested stack frame invalidates alloca allocation.\n  */\n  plugins = (st_plugin_int **)my_alloca(total * sizeof(plugin));\n  if (type == MYSQL_ANY_PLUGIN) {\n    for (idx = 0; idx < total; idx++) {\n      plugin = plugin_array->at(idx);\n      plugins[idx] = !(plugin->state & state_mask) ? plugin : nullptr;\n    }\n  } else {\n    collation_unordered_map<std::string, st_plugin_int *> *hash =\n        plugin_hash[type];\n    idx = 0;\n    for (const auto &key_and_value : *hash) {\n      plugin = key_and_value.second;\n      plugins[idx++] = !(plugin->state & state_mask) ? plugin : nullptr;\n    }\n  }\n  mysql_mutex_unlock(&LOCK_plugin);\n\n  size_t binlog_index = 0;\n  bool found_binlog = false;\n  /* Identify binary log SE which we need to invoke first. */\n  if (type == MYSQL_STORAGE_ENGINE_PLUGIN) {\n    for (idx = 0; idx < total; idx++) {\n      /* Note index of binlog */\n      plugin = plugins[idx];\n      if (plugin && (0 == std::strcmp(plugin->name.str, \"binlog\"))) {\n        binlog_index = idx;\n        found_binlog = true;\n        break;\n      }\n    }\n  }\n\n  for (; *funcs != nullptr; ++funcs) {\n    /* Call binlog engine function first. This is required as GTID is generated\n    by binlog to be used by othe SE. */\n    if (found_binlog) {\n      DBUG_ASSERT(type == MYSQL_STORAGE_ENGINE_PLUGIN);\n      plugin = plugins[binlog_index];\n      if (plugin && (*funcs)(thd, plugin_int_to_ref(plugin), arg)) goto err;\n      plugins[binlog_index] = nullptr;\n    }\n    for (idx = 0; idx < total; idx++) {\n      if (unlikely(version != plugin_array_version)) {\n        mysql_mutex_lock(&LOCK_plugin);\n        for (size_t i = idx; i < total; i++)\n          if (plugins[i] && plugins[i]->state & state_mask)\n            plugins[i] = nullptr;\n        mysql_mutex_unlock(&LOCK_plugin);\n      }\n      plugin = plugins[idx];\n      /* It will stop iterating on first engine error when \"func\" returns true\n       */\n      if (plugin && (*funcs)(thd, plugin_int_to_ref(plugin), arg)) goto err;\n    }\n  }\n\n  return false;\nerr:\n  return true;\n}\n\nbool plugin_foreach_with_mask(THD *thd, plugin_foreach_func *func, int type,\n                              uint state_mask, void *arg) {\n  plugin_foreach_func *funcs[] = {func, nullptr};\n\n  return plugin_foreach_with_mask(thd, funcs, type, state_mask, arg);\n}\n\n/****************************************************************************\n  System Variables support\n****************************************************************************/\n/*\n  This function is not thread safe as the pointer returned at the end of\n  the function is outside mutex.\n*/\n\nvoid lock_plugin_mutex() { mysql_mutex_lock(&LOCK_plugin); }\n\nvoid unlock_plugin_mutex() { mysql_mutex_unlock(&LOCK_plugin); }\n\nsys_var *find_sys_var_ex(THD *thd, const char *str, size_t length,\n                         bool throw_error, bool locked) {\n  sys_var *var;\n  sys_var_pluginvar *pi = nullptr;\n  plugin_ref plugin;\n  DBUG_TRACE;\n\n  if (!locked) mysql_mutex_lock(&LOCK_plugin);\n  mysql_rwlock_rdlock(&LOCK_system_variables_hash);\n  if ((var = intern_find_sys_var(str, length)) &&\n      (pi = var->cast_pluginvar()) && pi->is_plugin) {\n    mysql_rwlock_unlock(&LOCK_system_variables_hash);\n    LEX *lex = thd ? thd->lex : nullptr;\n    if (!(plugin = my_intern_plugin_lock(lex, plugin_int_to_ref(pi->plugin))))\n      var = nullptr; /* failed to lock it, it must be uninstalling */\n    else if (!(plugin_state(plugin) & PLUGIN_IS_READY)) {\n      /* initialization not completed */\n      var = nullptr;\n      intern_plugin_unlock(lex, plugin);\n    }\n  } else\n    mysql_rwlock_unlock(&LOCK_system_variables_hash);\n  if (!locked) mysql_mutex_unlock(&LOCK_plugin);\n\n  if (!throw_error && !var) my_error(ER_UNKNOWN_SYSTEM_VARIABLE, MYF(0), str);\n  return var;\n}\n\nsys_var *find_sys_var(THD *thd, const char *str, size_t length) {\n  return find_sys_var_ex(thd, str, length, false, false);\n}\n\n/*\n  returns a bookmark for thd-local variables, creating if neccessary.\n  returns null for non thd-local variables.\n  Requires that a write lock is obtained on LOCK_system_variables_hash\n*/\nstatic st_bookmark *register_var(const char *plugin, const char *name,\n                                 int flags) {\n  size_t length = strlen(plugin) + strlen(name) + 3, size = 0, offset, new_size;\n  st_bookmark *result;\n  char *varname, *p;\n\n  if (!(flags & PLUGIN_VAR_THDLOCAL)) return nullptr;\n\n  switch (flags & PLUGIN_VAR_TYPEMASK) {\n    case PLUGIN_VAR_BOOL:\n      size = sizeof(bool);\n      break;\n    case PLUGIN_VAR_INT:\n      size = sizeof(int);\n      break;\n    case PLUGIN_VAR_LONG:\n    case PLUGIN_VAR_ENUM:\n      size = sizeof(long);\n      break;\n    case PLUGIN_VAR_LONGLONG:\n    case PLUGIN_VAR_SET:\n      size = sizeof(ulonglong);\n      break;\n    case PLUGIN_VAR_STR:\n      size = sizeof(char *);\n      break;\n    case PLUGIN_VAR_DOUBLE:\n      size = sizeof(double);\n      break;\n    default:\n      DBUG_ASSERT(0);\n      return nullptr;\n  };\n\n  varname = ((char *)my_alloca(length));\n  strxmov(varname + 1, plugin, \"_\", name, NullS);\n  for (p = varname + 1; *p; p++)\n    if (*p == '-') *p = '_';\n\n  if (!(result = find_bookmark(nullptr, varname + 1, flags))) {\n    result =\n        (st_bookmark *)plugin_mem_root.Alloc(sizeof(st_bookmark) + length - 1);\n    varname[0] = flags & PLUGIN_VAR_TYPEMASK;\n    memcpy(result->key, varname, length);\n    result->name_len = length - 2;\n    result->offset = -1;\n\n    DBUG_ASSERT(size && !(size & (size - 1))); /* must be power of 2 */\n\n    offset = global_system_variables.dynamic_variables_size;\n    offset = (offset + size - 1) & ~(size - 1);\n    result->offset = (int)offset;\n\n    new_size = (offset + size + 63) & ~63;\n\n    if (new_size > global_variables_dynamic_size) {\n      global_system_variables.dynamic_variables_ptr = (char *)my_realloc(\n          key_memory_global_system_variables,\n          global_system_variables.dynamic_variables_ptr, new_size,\n          MYF(MY_WME | MY_FAE | MY_ALLOW_ZERO_PTR));\n      max_system_variables.dynamic_variables_ptr = (char *)my_realloc(\n          key_memory_global_system_variables,\n          max_system_variables.dynamic_variables_ptr, new_size,\n          MYF(MY_WME | MY_FAE | MY_ALLOW_ZERO_PTR));\n      /*\n        Clear the new variable value space. This is required for string\n        variables. If their value is non-NULL, it must point to a valid\n        string.\n      */\n      memset(global_system_variables.dynamic_variables_ptr +\n                 global_variables_dynamic_size,\n             0, new_size - global_variables_dynamic_size);\n      memset(max_system_variables.dynamic_variables_ptr +\n                 global_variables_dynamic_size,\n             0, new_size - global_variables_dynamic_size);\n      global_variables_dynamic_size = new_size;\n    }\n\n    global_system_variables.dynamic_variables_head = offset;\n    max_system_variables.dynamic_variables_head = offset;\n    global_system_variables.dynamic_variables_size = offset + size;\n    max_system_variables.dynamic_variables_size = offset + size;\n    global_system_variables.dynamic_variables_version++;\n    max_system_variables.dynamic_variables_version++;\n\n    result->version = global_system_variables.dynamic_variables_version;\n\n    /* this should succeed because we have already checked if a dup exists */\n    std::string key(result->key, result->name_len + 1);\n    bookmark_hash->emplace(key, result);\n\n    /*\n      Hashing vars of string type with MEMALLOC flag.\n    */\n    if (((flags & PLUGIN_VAR_TYPEMASK) == PLUGIN_VAR_STR) &&\n        (flags & PLUGIN_VAR_MEMALLOC) &&\n        !malloced_string_type_sysvars_bookmark_hash->emplace(key, result)\n             .second) {\n      fprintf(stderr,\n              \"failed to add placeholder to\"\n              \" hash of malloced string type sysvars\");\n      DBUG_ASSERT(0);\n    }\n  }\n  return result;\n}\n\nstatic void restore_pluginvar_names(sys_var *first) {\n  for (sys_var *var = first; var; var = var->next) {\n    sys_var_pluginvar *pv = var->cast_pluginvar();\n    pv->plugin_var->name = pv->orig_pluginvar_name;\n  }\n}\n\n/**\n  Allocate memory and copy dynamic variables from global system variables\n  to per-thread system variables copy.\n\n  @param thd              thread context\n  @param global_lock      If true LOCK_global_system_variables should be\n                          acquired while copying variables from global\n                          variables copy.\n*/\nvoid alloc_and_copy_thd_dynamic_variables(THD *thd, bool global_lock) {\n  mysql_rwlock_rdlock(&LOCK_system_variables_hash);\n\n  if (global_lock) mysql_mutex_lock(&LOCK_global_system_variables);\n\n  mysql_mutex_assert_owner(&LOCK_global_system_variables);\n\n  /*\n    MAINTAINER:\n    The following assert is wrong on purpose, useful to debug\n    when thd dynamic variables are expanded:\n    DBUG_ASSERT(thd->variables.dynamic_variables_ptr == NULL);\n  */\n\n  thd->variables.dynamic_variables_ptr = (char *)my_realloc(\n      key_memory_THD_variables, thd->variables.dynamic_variables_ptr,\n      global_variables_dynamic_size, MYF(MY_WME | MY_FAE | MY_ALLOW_ZERO_PTR));\n\n  /*\n    Debug hook which allows tests to check that this code is not\n    called for InnoDB after connection was created.\n  */\n  DBUG_EXECUTE_IF(\"verify_innodb_thdvars\", DBUG_ASSERT(0););\n\n  memcpy(thd->variables.dynamic_variables_ptr +\n             thd->variables.dynamic_variables_size,\n         global_system_variables.dynamic_variables_ptr +\n             thd->variables.dynamic_variables_size,\n         global_system_variables.dynamic_variables_size -\n             thd->variables.dynamic_variables_size);\n\n  /*\n    Iterate through newly copied vars of string type with MEMALLOC\n    flag and strdup value.\n  */\n  for (const auto &key_and_value :\n       *malloced_string_type_sysvars_bookmark_hash) {\n    sys_var_pluginvar *pi;\n    sys_var *var;\n    int varoff;\n    char **thdvar, **sysvar;\n    st_bookmark *v = key_and_value.second;\n\n    if (v->version <= thd->variables.dynamic_variables_version ||\n        !(var = intern_find_sys_var(v->key + 1, v->name_len)) ||\n        !(pi = var->cast_pluginvar()) ||\n        v->key[0] != (pi->plugin_var->flags & PLUGIN_VAR_TYPEMASK))\n      continue;\n\n    varoff = *(int *)(pi->plugin_var + 1);\n    thdvar = (char **)(thd->variables.dynamic_variables_ptr + varoff);\n    sysvar = (char **)(global_system_variables.dynamic_variables_ptr + varoff);\n    *thdvar = nullptr;\n    plugin_var_memalloc_session_update(thd, nullptr, thdvar, *sysvar);\n  }\n\n  if (global_lock) mysql_mutex_unlock(&LOCK_global_system_variables);\n\n  thd->variables.dynamic_variables_version =\n      global_system_variables.dynamic_variables_version;\n  thd->variables.dynamic_variables_head =\n      global_system_variables.dynamic_variables_head;\n  thd->variables.dynamic_variables_size =\n      global_system_variables.dynamic_variables_size;\n\n  mysql_rwlock_unlock(&LOCK_system_variables_hash);\n}\n\n/**\n  For correctness and simplicity's sake, a pointer to a function\n  must be compatible with pointed-to type, that is, the return and\n  parameters types must be the same. Thus, a callback function is\n  defined for each scalar type. The functions are assigned in\n  construct_options to their respective types.\n*/\n\nstatic bool *mysql_sys_var_bool(THD *thd, int offset) {\n  return (bool *)intern_sys_var_ptr(thd, offset, true);\n}\n\nstatic int *mysql_sys_var_int(THD *thd, int offset) {\n  return (int *)intern_sys_var_ptr(thd, offset, true);\n}\n\nstatic unsigned int *mysql_sys_var_uint(THD *thd, int offset) {\n  return (unsigned int *)intern_sys_var_ptr(thd, offset, true);\n}\n\nstatic unsigned long *mysql_sys_var_ulong(THD *thd, int offset) {\n  return (unsigned long *)intern_sys_var_ptr(thd, offset, true);\n}\n\nstatic unsigned long long *mysql_sys_var_ulonglong(THD *thd, int offset) {\n  return (unsigned long long *)intern_sys_var_ptr(thd, offset, true);\n}\n\nstatic char **mysql_sys_var_str(THD *thd, int offset) {\n  return (char **)intern_sys_var_ptr(thd, offset, true);\n}\n\nstatic double *mysql_sys_var_double(THD *thd, int offset) {\n  return (double *)intern_sys_var_ptr(thd, offset, true);\n}\n\nvoid plugin_thdvar_init(THD *thd, bool enable_plugins) {\n  plugin_ref old_table_plugin = thd->variables.table_plugin;\n  plugin_ref old_temp_table_plugin = thd->variables.temp_table_plugin;\n  DBUG_TRACE;\n\n  thd->variables.table_plugin = nullptr;\n  thd->variables.temp_table_plugin = nullptr;\n  cleanup_variables(thd, &thd->variables);\n\n  mysql_mutex_lock(&LOCK_global_system_variables);\n  thd->variables = global_system_variables;\n  thd->variables.table_plugin = nullptr;\n  thd->variables.temp_table_plugin = nullptr;\n\n  thd->variables.dynamic_variables_version = 0;\n  thd->variables.dynamic_variables_size = 0;\n  thd->variables.dynamic_variables_ptr = nullptr;\n\n  if (enable_plugins) {\n    mysql_mutex_lock(&LOCK_plugin);\n    thd->variables.table_plugin =\n        my_intern_plugin_lock(nullptr, global_system_variables.table_plugin);\n    intern_plugin_unlock(nullptr, old_table_plugin);\n    thd->variables.temp_table_plugin = my_intern_plugin_lock(\n        nullptr, global_system_variables.temp_table_plugin);\n    intern_plugin_unlock(nullptr, old_temp_table_plugin);\n    mysql_mutex_unlock(&LOCK_plugin);\n  }\n  mysql_mutex_unlock(&LOCK_global_system_variables);\n\n  /* Initialize all Sys_var_charptr variables here. */\n\n  // @@session.session_track_system_variables\n  thd->session_sysvar_res_mgr.init(&thd->variables.track_sysvars_ptr);\n}\n\n/*\n  Unlocks all system variables which hold a reference\n*/\nstatic void unlock_variables(struct System_variables *vars) {\n  intern_plugin_unlock(nullptr, vars->table_plugin);\n  intern_plugin_unlock(nullptr, vars->temp_table_plugin);\n  vars->table_plugin = nullptr;\n  vars->temp_table_plugin = nullptr;\n}\n\n/*\n  Frees memory used by system variables\n\n  Unlike plugin_vars_free_values() it frees all variables of all plugins,\n  it's used on shutdown.\n*/\nstatic void cleanup_variables(THD *thd, struct System_variables *vars) {\n  if (thd) {\n    /* Block the Performance Schema from accessing THD::variables. */\n    mysql_mutex_lock(&thd->LOCK_thd_data);\n\n    plugin_var_memalloc_free(&thd->variables);\n    /* Remove references to session_sysvar_res_mgr memory before freeing it. */\n    thd->variables.track_sysvars_ptr = nullptr;\n    thd->session_sysvar_res_mgr.deinit();\n  }\n  DBUG_ASSERT(vars->table_plugin == nullptr);\n  DBUG_ASSERT(vars->temp_table_plugin == nullptr);\n\n  my_free(vars->dynamic_variables_ptr);\n  vars->dynamic_variables_ptr = nullptr;\n  vars->dynamic_variables_size = 0;\n  vars->dynamic_variables_version = 0;\n\n  if (thd) mysql_mutex_unlock(&thd->LOCK_thd_data);\n}\n\nvoid plugin_thdvar_cleanup(THD *thd, bool enable_plugins) {\n  DBUG_TRACE;\n\n  if (enable_plugins) {\n    MUTEX_LOCK(plugin_lock, &LOCK_plugin);\n    unlock_variables(&thd->variables);\n    size_t idx;\n    if ((idx = thd->lex->plugins.size())) {\n      plugin_ref *list = thd->lex->plugins.end() - 1;\n      DBUG_PRINT(\"info\", (\"unlocking %u plugins\", static_cast<uint>(idx)));\n      while (list >= thd->lex->plugins.begin())\n        intern_plugin_unlock(thd->lex, *list--);\n    }\n\n    reap_plugins();\n    thd->lex->plugins.clear();\n  }\n  cleanup_variables(thd, &thd->variables);\n}\n\n/**\n  @brief Free values of thread variables of a plugin.\n\n  This must be called before a plugin is deleted. Otherwise its\n  variables are no longer accessible and the value space is lost. Note\n  that only string values with PLUGIN_VAR_MEMALLOC are allocated and\n  must be freed.\n\n  @param[in]        vars        Chain of system variables of a plugin\n*/\n\nstatic void plugin_vars_free_values(sys_var *vars) {\n  DBUG_TRACE;\n\n  for (sys_var *var = vars; var; var = var->next) {\n    sys_var_pluginvar *piv = var->cast_pluginvar();\n    if (piv &&\n        ((piv->plugin_var->flags & PLUGIN_VAR_TYPEMASK) == PLUGIN_VAR_STR) &&\n        (piv->plugin_var->flags & PLUGIN_VAR_MEMALLOC)) {\n      /* Free the string from global_system_variables. */\n      char **valptr = (char **)piv->real_value_ptr(nullptr, OPT_GLOBAL);\n      DBUG_PRINT(\"plugin\",\n                 (\"freeing value for: '%s'  addr: %p\", var->name.str, valptr));\n      my_free(*valptr);\n      *valptr = nullptr;\n    }\n  }\n}\n\n/**\n  Set value for a thread local variable.\n\n  @param[in]     thd   Thread context.\n  @param[in]     var   Plugin variable.\n  @param[in,out] dest  Destination memory pointer.\n  @param[in]     value New value.\n\n  Note: new value should be '\\0'-terminated for string variables.\n\n  Used in plugin.h:THDVAR_SET(thd, name, value) macro.\n*/\n\nvoid plugin_thdvar_safe_update(THD *thd, SYS_VAR *var, char **dest,\n                               const char *value) {\n  DBUG_ASSERT(thd == current_thd);\n\n  if (var->flags & PLUGIN_VAR_THDLOCAL) {\n    if ((var->flags & PLUGIN_VAR_TYPEMASK) == PLUGIN_VAR_STR &&\n        var->flags & PLUGIN_VAR_MEMALLOC)\n      plugin_var_memalloc_session_update(thd, var, dest, value);\n    else\n      var->update(thd, var, dest, value);\n  }\n}\n\n/**\n  Free all elements allocated by plugin_var_memalloc_session_update().\n\n  @param[in]     vars  system variables structure\n\n  @see plugin_var_memalloc_session_update\n*/\n\nstatic void plugin_var_memalloc_free(struct System_variables *vars) {\n  LIST *next, *root;\n  DBUG_TRACE;\n  for (root = vars->dynamic_variables_allocs; root; root = next) {\n    next = root->next;\n    my_free(root);\n  }\n  vars->dynamic_variables_allocs = nullptr;\n}\n\nextern \"C\" bool get_one_plugin_option(int, const struct my_option *, char *);\n\nbool get_one_plugin_option(int, const struct my_option *, char *) {\n  return false;\n}\n\n/**\n  Creates a set of my_option objects associated with a specified plugin-\n  handle.\n\n  @param mem_root Memory allocator to be used.\n  @param tmp A pointer to a plugin handle\n  @param[out] options A pointer to a pre-allocated static array\n\n  The set is stored in the pre-allocated static array supplied to the function.\n  The size of the array is calculated as (number_of_plugin_varaibles*2+3). The\n  reason is that each option can have a prefix '--plugin-' in addtion to the\n  shorter form '--&lt;plugin-name&gt;'. There is also space allocated for\n  terminating NULL pointers.\n\n  @retval -1 An error occurred\n  @retval 0 Success\n*/\n\nstatic int construct_options(MEM_ROOT *mem_root, st_plugin_int *tmp,\n                             my_option *options) {\n  const char *plugin_name = tmp->plugin->name;\n  const LEX_CSTRING plugin_dash = {STRING_WITH_LEN(\"plugin-\")};\n  size_t plugin_name_len = strlen(plugin_name);\n  size_t optnamelen;\n  const int max_comment_len = 180;\n  char *comment = (char *)mem_root->Alloc(max_comment_len + 1);\n  char *optname;\n\n  int index = 0, offset = 0;\n  SYS_VAR *opt, **plugin_option;\n  st_bookmark *v;\n\n  /** Used to circumvent the const attribute on my_option::name */\n  char *plugin_name_ptr, *plugin_name_with_prefix_ptr;\n\n  DBUG_TRACE;\n\n  plugin_name_ptr = (char *)mem_root->Alloc(plugin_name_len + 1);\n  strcpy(plugin_name_ptr, plugin_name);\n  my_casedn_str(&my_charset_latin1, plugin_name_ptr);\n  convert_underscore_to_dash(plugin_name_ptr, plugin_name_len);\n  plugin_name_with_prefix_ptr =\n      (char *)mem_root->Alloc(plugin_name_len + plugin_dash.length + 1);\n  strxmov(plugin_name_with_prefix_ptr, plugin_dash.str, plugin_name_ptr, NullS);\n\n  if (tmp->load_option != PLUGIN_FORCE &&\n      tmp->load_option != PLUGIN_FORCE_PLUS_PERMANENT) {\n    /* support --skip-plugin-foo syntax */\n    options[0].name = plugin_name_ptr;\n    options[1].name = plugin_name_with_prefix_ptr;\n    options[0].id = 0;\n    options[1].id = -1;\n    options[0].var_type = options[1].var_type = GET_ENUM;\n    options[0].arg_type = options[1].arg_type = OPT_ARG;\n    options[0].def_value = options[1].def_value = 1; /* ON */\n    options[0].typelib = options[1].typelib = &global_plugin_typelib;\n\n    strxnmov(comment, max_comment_len, \"Enable or disable \", plugin_name,\n             \" plugin. Possible values are ON, OFF, FORCE (don't start \"\n             \"if the plugin fails to load).\",\n             NullS);\n    options[0].comment = comment;\n    /*\n      Allocate temporary space for the value of the tristate.\n      This option will have a limited lifetime and is not used beyond\n      server initialization.\n      GET_ENUM value is an unsigned long integer.\n    */\n    options[0].value = options[1].value =\n        (uchar **)mem_root->Alloc(sizeof(ulong));\n    *((ulong *)options[0].value) = (ulong)options[0].def_value;\n\n    options[0].arg_source = options[1].arg_source =\n        (get_opt_arg_source *)mem_root->Alloc(sizeof(get_opt_arg_source));\n    memset(options[0].arg_source, 0, sizeof(get_opt_arg_source));\n    options[0].arg_source->m_path_name[0] = 0;\n    options[1].arg_source->m_path_name[0] = 0;\n    options[0].arg_source->m_source = options[1].arg_source->m_source =\n        enum_variable_source::COMPILED;\n\n    options += 2;\n  }\n\n  if (!my_strcasecmp(&my_charset_latin1, plugin_name_ptr, \"NDBCLUSTER\")) {\n    plugin_name_ptr = const_cast<char *>(\"ndb\");  // Use legacy \"ndb\" prefix\n    plugin_name_len = 3;\n  }\n\n  /*\n    Two passes as the 2nd pass will take pointer addresses for use\n    by my_getopt and register_var() in the first pass uses realloc\n  */\n\n  for (plugin_option = tmp->plugin->system_vars;\n       plugin_option && *plugin_option; plugin_option++, index++) {\n    opt = *plugin_option;\n    if (!(opt->flags & PLUGIN_VAR_THDLOCAL)) continue;\n    if (!(register_var(plugin_name_ptr, opt->name, opt->flags))) continue;\n    switch (opt->flags & PLUGIN_VAR_TYPEMASK) {\n      case PLUGIN_VAR_BOOL:\n        ((thdvar_bool_t *)opt)->resolve = mysql_sys_var_bool;\n        break;\n      case PLUGIN_VAR_INT:\n        // All PLUGIN_VAR_INT variables are actually uint,\n        // see struct System_variables\n        // Except: plugin variables declared with MYSQL_THDVAR_INT,\n        // which may actually be signed.\n        if (((thdvar_int_t *)opt)->offset == -1 &&\n            !(opt->flags & PLUGIN_VAR_UNSIGNED))\n          ((thdvar_int_t *)opt)->resolve = mysql_sys_var_int;\n        else\n          ((thdvar_uint_t *)opt)->resolve = mysql_sys_var_uint;\n        break;\n      case PLUGIN_VAR_LONG:\n        // All PLUGIN_VAR_LONG variables are actually ulong,\n        // see struct System_variables\n        ((thdvar_ulong_t *)opt)->resolve = mysql_sys_var_ulong;\n        break;\n      case PLUGIN_VAR_LONGLONG:\n        // All PLUGIN_VAR_LONGLONG variables are actually ulonglong,\n        // see struct System_variables\n        ((thdvar_ulonglong_t *)opt)->resolve = mysql_sys_var_ulonglong;\n        break;\n      case PLUGIN_VAR_STR:\n        ((thdvar_str_t *)opt)->resolve = mysql_sys_var_str;\n        break;\n      case PLUGIN_VAR_ENUM:\n        ((thdvar_enum_t *)opt)->resolve = mysql_sys_var_ulong;\n        break;\n      case PLUGIN_VAR_SET:\n        ((thdvar_set_t *)opt)->resolve = mysql_sys_var_ulonglong;\n        break;\n      case PLUGIN_VAR_DOUBLE:\n        ((thdvar_double_t *)opt)->resolve = mysql_sys_var_double;\n        break;\n      default:\n        LogErr(ERROR_LEVEL, ER_PLUGIN_UNKNOWN_VARIABLE_TYPE, opt->flags,\n               plugin_name);\n        return -1;\n    };\n  }\n\n  for (plugin_option = tmp->plugin->system_vars;\n       plugin_option && *plugin_option; plugin_option++, index++) {\n    switch ((opt = *plugin_option)->flags & PLUGIN_VAR_TYPEMASK) {\n      case PLUGIN_VAR_BOOL:\n        if (!opt->check) opt->check = check_func_bool;\n        if (!opt->update) opt->update = update_func_bool;\n        break;\n      case PLUGIN_VAR_INT:\n        if (!opt->check) opt->check = check_func_int;\n        if (!opt->update) opt->update = update_func_int;\n        break;\n      case PLUGIN_VAR_LONG:\n        if (!opt->check) opt->check = check_func_long;\n        if (!opt->update) opt->update = update_func_long;\n        break;\n      case PLUGIN_VAR_LONGLONG:\n        if (!opt->check) opt->check = check_func_longlong;\n        if (!opt->update) opt->update = update_func_longlong;\n        break;\n      case PLUGIN_VAR_STR:\n        if (!opt->check) opt->check = check_func_str;\n        if (!opt->update) {\n          opt->update = update_func_str;\n          if (!(opt->flags & (PLUGIN_VAR_MEMALLOC | PLUGIN_VAR_READONLY))) {\n            opt->flags |= PLUGIN_VAR_READONLY;\n            LogErr(WARNING_LEVEL, ER_PLUGIN_VARIABLE_SET_READ_ONLY, opt->name,\n                   plugin_name);\n          }\n        }\n        break;\n      case PLUGIN_VAR_ENUM:\n        if (!opt->check) opt->check = check_func_enum;\n        if (!opt->update) opt->update = update_func_long;\n        break;\n      case PLUGIN_VAR_SET:\n        if (!opt->check) opt->check = check_func_set;\n        if (!opt->update) opt->update = update_func_longlong;\n        break;\n      case PLUGIN_VAR_DOUBLE:\n        if (!opt->check) opt->check = check_func_double;\n        if (!opt->update) opt->update = update_func_double;\n        break;\n      default:\n        LogErr(ERROR_LEVEL, ER_PLUGIN_UNKNOWN_VARIABLE_TYPE, opt->flags,\n               plugin_name);\n        return -1;\n    }\n\n    if ((opt->flags & (PLUGIN_VAR_NOCMDOPT | PLUGIN_VAR_THDLOCAL)) ==\n        PLUGIN_VAR_NOCMDOPT)\n      continue;\n\n    if (!opt->name) {\n      LogErr(ERROR_LEVEL, ER_PLUGIN_VARIABLE_MISSING_NAME, plugin_name);\n      return -1;\n    }\n\n    if (!(opt->flags & PLUGIN_VAR_THDLOCAL)) {\n      optnamelen = strlen(opt->name);\n      optname = (char *)mem_root->Alloc(plugin_name_len + optnamelen + 2);\n      strxmov(optname, plugin_name_ptr, \"-\", opt->name, NullS);\n      optnamelen = plugin_name_len + optnamelen + 1;\n    } else {\n      /* this should not fail because register_var should create entry */\n      if (!(v = find_bookmark(plugin_name_ptr, opt->name, opt->flags))) {\n        LogErr(ERROR_LEVEL, ER_PLUGIN_VARIABLE_NOT_ALLOCATED_THREAD_LOCAL,\n               opt->name, plugin_name);\n        return -1;\n      }\n\n      *(int *)(opt + 1) = offset = v->offset;\n\n      if (opt->flags & PLUGIN_VAR_NOCMDOPT) continue;\n\n      optname = (char *)memdup_root(mem_root, v->key + 1,\n                                    (optnamelen = v->name_len) + 1);\n    }\n\n    convert_underscore_to_dash(optname, optnamelen);\n\n    options->name = optname;\n    options->comment = opt->comment;\n    options->app_type = opt;\n    options->id = 0;\n\n    plugin_opt_set_limits(options, opt);\n\n    if (opt->flags & PLUGIN_VAR_THDLOCAL)\n      options->value = options->u_max_value =\n          (uchar **)(global_system_variables.dynamic_variables_ptr + offset);\n    else\n      options->value = options->u_max_value = *(uchar ***)(opt + 1);\n\n    char *option_name_ptr;\n    options[1] = options[0];\n    options[1].id = -1;\n    options[1].name = option_name_ptr =\n        (char *)mem_root->Alloc(plugin_dash.length + optnamelen + 1);\n    options[1].comment = nullptr; /* Hidden from the help text */\n    strxmov(option_name_ptr, plugin_dash.str, optname, NullS);\n\n    options[0].arg_source = options[1].arg_source =\n        (get_opt_arg_source *)mem_root->Alloc(sizeof(get_opt_arg_source));\n    memset(options[0].arg_source, 0, sizeof(get_opt_arg_source));\n    options[0].arg_source->m_path_name[0] = 0;\n    options[1].arg_source->m_path_name[0] = 0;\n    options[0].arg_source->m_source = options[1].arg_source->m_source =\n        enum_variable_source::COMPILED;\n\n    options += 2;\n  }\n\n  return 0;\n}\n\nstatic my_option *construct_help_options(MEM_ROOT *mem_root, st_plugin_int *p) {\n  SYS_VAR **opt;\n  my_option *opts;\n  uint count = EXTRA_OPTIONS;\n  DBUG_TRACE;\n\n  for (opt = p->plugin->system_vars; opt && *opt; opt++, count += 2)\n    ;\n\n  if (!(opts = (my_option *)mem_root->Alloc(sizeof(my_option) * count)))\n    return nullptr;\n\n  memset(opts, 0, sizeof(my_option) * count);\n\n  /**\n    some plugin variables (those that don't have PLUGIN_VAR_EXPERIMENTAL flag)\n    have their names prefixed with the plugin name. Restore the names here\n    to get the correct (not double-prefixed) help text.\n    We won't need @@sysvars anymore and don't care about their proper names.\n  */\n  restore_pluginvar_names(p->system_vars);\n\n  if (construct_options(mem_root, p, opts)) return nullptr;\n\n  return opts;\n}\n\n/**\n  Check option being used and raise deprecation warning if required.\n\n  @param optid ID of the option that was passed through command line\n  @param opt List of options\n  @param argument unused\n\n  A deprecation warning will be raised if --plugin-xxx type of option\n  is used.\n\n  @return Always returns success as purpose of the function is to raise\n  warning only.\n  @retval 0 Success\n*/\n\nstatic bool check_if_option_is_deprecated(\n    int optid, const struct my_option *opt,\n    char *argument MY_ATTRIBUTE((unused))) {\n  if (optid == -1) {\n    push_deprecated_warn(nullptr, opt->name, (opt->name + strlen(\"plugin-\")));\n  }\n  return false;\n}\n\n/**\n  Create and register system variables supplied from the plugin and\n  assigns initial values from corresponding command line arguments.\n\n  @param tmp_root Temporary scratch space\n  @param[out] tmp Internal plugin structure\n  @param argc Number of command line arguments\n  @param argv Command line argument vector\n\n  The plugin will be updated with a policy on how to handle errors during\n  initialization.\n\n  @note Requires that a write-lock is held on LOCK_system_variables_hash\n\n  @return How initialization of the plugin should be handled.\n    @retval  0 Initialization should proceed.\n    @retval  1 Plugin is disabled.\n    @retval -1 An error has occurred.\n*/\n\nstatic int test_plugin_options(MEM_ROOT *tmp_root, st_plugin_int *tmp,\n                               int *argc, char **argv) {\n  struct sys_var_chain chain = {nullptr, nullptr};\n  bool disable_plugin;\n  enum_plugin_load_option plugin_load_option = tmp->load_option;\n\n  /*\n    We should use tmp->mem_root here instead of the global plugin_mem_root,\n    but tmp->root is not always properly freed, so it will cause leaks in\n    Valgrind (e.g. the main.validate_password_plugin test).\n  */\n  MEM_ROOT *mem_root = &plugin_mem_root;\n  SYS_VAR **opt;\n  my_option *opts = nullptr;\n  LEX_CSTRING plugin_name;\n  char *varname;\n  int error;\n  sys_var *v MY_ATTRIBUTE((unused));\n  st_bookmark *var;\n  size_t len;\n  uint count = EXTRA_OPTIONS;\n  DBUG_TRACE;\n  DBUG_ASSERT(tmp->plugin && tmp->name.str);\n\n  /*\n    The 'federated' and 'ndbcluster' storage engines are always disabled by\n    default.\n  */\n  if (!(my_strcasecmp(&my_charset_latin1, tmp->name.str, \"federated\") &&\n        my_strcasecmp(&my_charset_latin1, tmp->name.str, \"ndbcluster\")))\n    plugin_load_option = PLUGIN_OFF;\n\n  for (opt = tmp->plugin->system_vars; opt && *opt; opt++)\n    count += 2; /* --{plugin}-{optname} and --plugin-{plugin}-{optname} */\n\n  if (count > EXTRA_OPTIONS || (*argc > 1)) {\n    if (!(opts = (my_option *)tmp_root->Alloc(sizeof(my_option) * count))) {\n      LogErr(ERROR_LEVEL, ER_PLUGIN_OOM, tmp->name.str);\n      return -1;\n    }\n    memset(opts, 0, sizeof(my_option) * count);\n\n    if (construct_options(tmp_root, tmp, opts)) {\n      LogErr(ERROR_LEVEL, ER_PLUGIN_BAD_OPTIONS, tmp->name.str);\n      return -1;\n    }\n\n    /*\n      We adjust the default value to account for the hardcoded exceptions\n      we have set for the federated and ndbcluster storage engines.\n    */\n    if (tmp->load_option != PLUGIN_FORCE &&\n        tmp->load_option != PLUGIN_FORCE_PLUS_PERMANENT)\n      opts[0].def_value = opts[1].def_value = plugin_load_option;\n\n    error = handle_options(argc, &argv, opts, check_if_option_is_deprecated);\n    (*argc)++; /* add back one for the program name */\n\n    if (error) {\n      LogErr(ERROR_LEVEL, ER_PLUGIN_PARSING_OPTIONS_FAILED, tmp->name.str);\n      goto err;\n    }\n    /*\n     Set plugin loading policy from option value. First element in the option\n     list is always the <plugin name> option value.\n    */\n    if (tmp->load_option != PLUGIN_FORCE &&\n        tmp->load_option != PLUGIN_FORCE_PLUS_PERMANENT)\n      plugin_load_option = (enum_plugin_load_option) * (ulong *)opts[0].value;\n  }\n\n  disable_plugin = (plugin_load_option == PLUGIN_OFF);\n  tmp->load_option = plugin_load_option;\n\n  /*\n    If the plugin is disabled it should not be initialized.\n  */\n  if (disable_plugin) {\n    LogErr(INFORMATION_LEVEL, ER_PLUGIN_DISABLED, tmp->name.str);\n    if (opts) my_cleanup_options(opts);\n    return 1;\n  }\n\n  if (!my_strcasecmp(&my_charset_latin1, tmp->name.str, \"NDBCLUSTER\")) {\n    plugin_name.str = const_cast<char *>(\"ndb\");  // Use legacy \"ndb\" prefix\n    plugin_name.length = 3;\n  } else\n    plugin_name = tmp->name;\n\n  error = 1;\n  for (opt = tmp->plugin->system_vars; opt && *opt; opt++) {\n    SYS_VAR *o;\n    if (((o = *opt)->flags & PLUGIN_VAR_NOSYSVAR)) continue;\n    if ((var = find_bookmark(plugin_name.str, o->name, o->flags)))\n      v = new (mem_root) sys_var_pluginvar(&chain, var->key + 1, o);\n    else {\n      len = plugin_name.length + strlen(o->name) + 2;\n      varname = (char *)mem_root->Alloc(len);\n      strxmov(varname, plugin_name.str, \"-\", o->name, NullS);\n      my_casedn_str(&my_charset_latin1, varname);\n      convert_dash_to_underscore(varname, len - 1);\n      v = new (mem_root) sys_var_pluginvar(&chain, varname, o);\n    }\n    DBUG_ASSERT(v); /* check that an object was actually constructed */\n\n    const my_option *optp = opts;\n    if (findopt(o->name, strlen(o->name), &optp))\n      v->set_arg_source(optp->arg_source);\n  } /* end for */\n  if (chain.first) {\n    chain.last->next = nullptr;\n    if (mysql_add_sys_var_chain(chain.first)) {\n      LogErr(ERROR_LEVEL, ER_PLUGIN_HAS_CONFLICTING_SYSTEM_VARIABLES,\n             tmp->name.str);\n      goto err;\n    }\n    tmp->system_vars = chain.first;\n  }\n\n  /*\n    Once server is started and if there are few persisted plugin variables\n    which needs to be handled, we do it here.\n  */\n  if (mysqld_server_started) {\n    Persisted_variables_cache *pv = Persisted_variables_cache::get_instance();\n    if (pv && pv->set_persist_options(true)) {\n      LogErr(ERROR_LEVEL, ER_PLUGIN_CANT_SET_PERSISTENT_OPTIONS, tmp->name.str);\n      goto err;\n    }\n  }\n  return 0;\n\nerr:\n  if (opts) my_cleanup_options(opts);\n  return error;\n}\n\n/****************************************************************************\n  Help Verbose text with Plugin System Variables\n****************************************************************************/\n\nvoid add_plugin_options(std::vector<my_option> *options, MEM_ROOT *mem_root) {\n  my_option *opt;\n\n  if (!initialized) return;\n\n  for (st_plugin_int **it = plugin_array->begin(); it != plugin_array->end();\n       ++it) {\n    st_plugin_int *p = *it;\n\n    if (!(opt = construct_help_options(mem_root, p))) continue;\n\n    /* Only options with a non-NULL comment are displayed in help text */\n    for (; opt->name; opt++)\n      if (opt->comment) options->push_back(*opt);\n  }\n}\n\n/**\n  Searches for a correctly loaded plugin of a particular type by name\n\n  @param plugin   the name of the plugin we're looking for\n  @param type     type of the plugin (0-MYSQL_MAX_PLUGIN_TYPE_NUM)\n  @return plugin, or NULL if not found\n*/\nst_plugin_int *plugin_find_by_type(const LEX_CSTRING &plugin, int type) {\n  st_plugin_int *ret;\n  DBUG_TRACE;\n\n  ret = plugin_find_internal(plugin, type);\n  return ret && ret->state == PLUGIN_IS_READY ? ret : nullptr;\n}\n\n/**\n  Locks the plugin strucutres so calls to plugin_find_inner can be issued.\n\n  Must be followed by unlock_plugin_data.\n*/\nint lock_plugin_data() {\n  DBUG_TRACE;\n  return mysql_mutex_lock(&LOCK_plugin);\n}\n\n/**\n  Unlocks the plugin strucutres as locked by lock_plugin_data()\n*/\nint unlock_plugin_data() {\n  DBUG_TRACE;\n  return mysql_mutex_unlock(&LOCK_plugin);\n}\n\nbool Sql_cmd_install_plugin::execute(THD *thd) {\n  bool st = mysql_install_plugin(thd, m_comment, &m_ident);\n  if (!st) my_ok(thd);\n  mysql_audit_release(thd);\n  return st;\n}\n\nbool Sql_cmd_uninstall_plugin::execute(THD *thd) {\n  bool st = mysql_uninstall_plugin(thd, m_comment);\n  if (!st) my_ok(thd);\n  return st;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/cmake/os/SunOS.cmake": "# Copyright (c) 2010, 2019, Oracle and/or its affiliates. All rights reserved.\n# \n# This program is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License, version 2.0,\n# as published by the Free Software Foundation.\n#\n# This program is also distributed with certain software (including\n# but not limited to OpenSSL) that is licensed under separate terms,\n# as designated in a particular file or component or in included license\n# documentation.  The authors of MySQL hereby grant you an additional\n# permission to link the program and your derivative works with the\n# separately licensed software that they have included with MySQL.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License, version 2.0, for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA \n\nINCLUDE(CheckSymbolExists)\nINCLUDE(CheckCSourceRuns)\nINCLUDE(CheckCSourceCompiles) \nINCLUDE(CheckCXXSourceCompiles)\n\nSET(SOLARIS 1)\nIF(CMAKE_SYSTEM_PROCESSOR MATCHES \"sparc\")\n  SET(SOLARIS_SPARC 1)\nELSE()\n  SET(SOLARIS_INTEL 1)\nENDIF()\n\nIF (NOT \"${CMAKE_C_FLAGS}${CMAKE_CXX_FLAGS}\" MATCHES \"-m32|-m64\")\n  IF(NOT FORCE_UNSUPPORTED_COMPILER)\n    MESSAGE(\"Adding -m64\")\n    STRING_APPEND(CMAKE_C_FLAGS        \" -m64\")\n    STRING_APPEND(CMAKE_CXX_FLAGS      \" -m64\")\n    STRING_APPEND(CMAKE_C_LINK_FLAGS   \" -m64\")\n    STRING_APPEND(CMAKE_CXX_LINK_FLAGS \" -m64\")\n  ENDIF()\nENDIF()\n\nINCLUDE(CheckTypeSize)\nCHECK_TYPE_SIZE(\"void *\" SIZEOF_VOIDP)\n\n# We require at least SunStudio 12.6 (CC 5.15)\nIF(NOT FORCE_UNSUPPORTED_COMPILER)\n  IF(MY_COMPILER_IS_SUNPRO)\n    IF(SIZEOF_VOIDP MATCHES 4)\n      MESSAGE(FATAL_ERROR \"32 bit Solaris builds are not supported. \")\n    ENDIF()\n    # CC -V yields\n    # CC: Studio 12.6 Sun C++ 5.15 SunOS_sparc Beta 2016/12/19\n    # CC: Studio 12.5 Sun C++ 5.14 SunOS_sparc Dodona 2016/04/04\n    # CC: Sun C++ 5.13 SunOS_sparc Beta 2014/03/11\n    # CC: Sun C++ 5.11 SunOS_sparc 2010/08/13\n    EXECUTE_PROCESS(\n      COMMAND ${CMAKE_CXX_COMPILER} \"-V\"\n      OUTPUT_VARIABLE stdout\n      ERROR_VARIABLE  stderr\n      RESULT_VARIABLE result\n    )\n    STRING(REGEX MATCH \"CC: Sun C\\\\+\\\\+ 5\\\\.([0-9]+)\" VERSION_STRING ${stderr})\n    IF (NOT CMAKE_MATCH_1 OR CMAKE_MATCH_1 STREQUAL \"\")\n      STRING(REGEX MATCH \"CC: Studio 12\\\\.[56] Sun C\\\\+\\\\+ 5\\\\.([0-9]+)\"\n        VERSION_STRING ${stderr})\n    ENDIF()\n    SET(CC_MINOR_VERSION ${CMAKE_MATCH_1})\n    IF(${CC_MINOR_VERSION} LESS 15)\n      MESSAGE(FATAL_ERROR \"Oracle Studio 12.6 or newer is required!\")\n    ENDIF()\n  ELSEIF(MY_COMPILER_IS_CLANG)\n    MESSAGE(WARNING \"Clang is (highly) experimental!!\")\n  ELSEIF(MY_COMPILER_IS_GNU)\n    MESSAGE(WARNING \"gcc is experimental\")\n  ELSE()\n    MESSAGE(FATAL_ERROR \"Unsupported compiler!\")\n  ENDIF()\nENDIF()\n\n# Enable 64 bit file offsets\nADD_DEFINITIONS(-D_FILE_OFFSET_BITS=64)\n\n# Enable general POSIX extensions. See standards(5) man page.\nADD_DEFINITIONS(-D__EXTENSIONS__)\n\n# Solaris threads with POSIX semantics:\n# http://docs.oracle.com/cd/E19455-01/806-5257/6je9h033k/index.html\nADD_DEFINITIONS(-D_POSIX_PTHREAD_SEMANTICS -D_REENTRANT -D_PTHREADS)\n\n# On  Solaris, use of intrinsics will screw the lib search logic\n# Force using -lm, so rint etc are found.\nSET(LIBM m)\n\n# CMake defined -lthread as thread flag. This crashes in dlopen \n# when trying to load plugins workaround with -lpthread\nSET(CMAKE_THREAD_LIBS_INIT -lpthread CACHE INTERNAL \"\" FORCE)\n\n# Solaris specific large page support\nCHECK_SYMBOL_EXISTS(MHA_MAPSIZE_VA sys/mman.h  HAVE_SOLARIS_LARGE_PAGES)\n\n# Solaris atomics\nCHECK_C_SOURCE_RUNS(\n \"\n #include  <atomic.h>\n  int main()\n  {\n    int foo = -10; int bar = 10;\n    int64_t foo64 = -10; int64_t bar64 = 10;\n    if (atomic_add_int_nv((uint_t *)&foo, bar) || foo)\n      return -1;\n    bar = atomic_swap_uint((uint_t *)&foo, (uint_t)bar);\n    if (bar || foo != 10)\n     return -1;\n    bar = atomic_cas_uint((uint_t *)&bar, (uint_t)foo, 15);\n    if (bar)\n      return -1;\n    if (atomic_add_64_nv((volatile uint64_t *)&foo64, bar64) || foo64)\n      return -1;\n    bar64 = atomic_swap_64((volatile uint64_t *)&foo64, (uint64_t)bar64);\n    if (bar64 || foo64 != 10)\n      return -1;\n    bar64 = atomic_cas_64((volatile uint64_t *)&bar64, (uint_t)foo64, 15);\n    if (bar64)\n      return -1;\n    atomic_or_64((volatile uint64_t *)&bar64, 0);\n    return 0;\n  }\n\"  HAVE_SOLARIS_ATOMIC)\n\n# This is used for the version_compile_machine variable.\nIF(SIZEOF_VOIDP MATCHES 8 AND SOLARIS_INTEL)\n  SET(MYSQL_MACHINE_TYPE \"x86_64\")\nENDIF()\n\n\nMACRO(DIRNAME IN OUT)\n  GET_FILENAME_COMPONENT(${OUT} ${IN} PATH)\nENDMACRO()\n\n# We assume that developer studio runtime libraries are installed.\nIF(MY_COMPILER_IS_SUNPRO)\n  DIRNAME(${CMAKE_CXX_COMPILER} CXX_PATH)\n\n  SET(LIBRARY_SUFFIX \"lib/compilers/CC-gcc/lib\")\n  IF(SIZEOF_VOIDP EQUAL 8 AND SOLARIS_SPARC)\n    SET(LIBRARY_SUFFIX \"${LIBRARY_SUFFIX}/sparcv9\")\n  ENDIF()\n  IF(SIZEOF_VOIDP EQUAL 8 AND SOLARIS_INTEL)\n    SET(LIBRARY_SUFFIX \"${LIBRARY_SUFFIX}/amd64\")\n  ENDIF()\n  FIND_LIBRARY(STL_LIBRARY_NAME\n    NAMES \"stdc++\"\n    PATHS ${CXX_PATH}/../${LIBRARY_SUFFIX}\n    NO_DEFAULT_PATH\n  )\n  MESSAGE(STATUS \"STL_LIBRARY_NAME ${STL_LIBRARY_NAME}\")\n  IF(STL_LIBRARY_NAME)\n    DIRNAME(${STL_LIBRARY_NAME} STL_LIBRARY_PATH)\n    SET(LRFLAGS \" -L${STL_LIBRARY_PATH} -R${STL_LIBRARY_PATH}\")\n    SET(QUOTED_CMAKE_CXX_LINK_FLAGS \"${CMAKE_CXX_LINK_FLAGS}\")\n\n    STRING_APPEND(CMAKE_C_LINK_FLAGS          \"${LRFLAGS}\")\n    STRING_APPEND(CMAKE_CXX_LINK_FLAGS        \"${LRFLAGS}\")\n    STRING_APPEND(CMAKE_MODULE_LINKER_FLAGS   \"${LRFLAGS}\")\n    STRING_APPEND(CMAKE_SHARED_LINKER_FLAGS   \"${LRFLAGS}\")\n    STRING_APPEND(QUOTED_CMAKE_CXX_LINK_FLAGS \"${LRFLAGS}\")\n  ENDIF()\n\n  STRING_APPEND(CMAKE_C_LINK_FLAGS          \" -lc\")\n  STRING_APPEND(CMAKE_CXX_LINK_FLAGS        \" -lstdc++ -lgcc_s -lCrunG3 -lc\")\n  STRING_APPEND(CMAKE_MODULE_LINKER_FLAGS   \" -lstdc++ -lgcc_s -lCrunG3 -lc\")\n  STRING_APPEND(CMAKE_SHARED_LINKER_FLAGS   \" -lstdc++ -lgcc_s -lCrunG3 -lc\")\n  STRING_APPEND(QUOTED_CMAKE_CXX_LINK_FLAGS \" -lstdc++ -lgcc_s -lCrunG3 -lc\")\n\n  SET(LIBRARY_SUFFIX \"lib/compilers/atomic\")\n  IF(SIZEOF_VOIDP EQUAL 8 AND SOLARIS_SPARC)\n    SET(LIBRARY_SUFFIX \"${LIBRARY_SUFFIX}/sparcv9\")\n  ENDIF()\n  IF(SIZEOF_VOIDP EQUAL 8 AND SOLARIS_INTEL)\n    SET(LIBRARY_SUFFIX \"${LIBRARY_SUFFIX}/amd64\")\n  ENDIF()\n  FIND_LIBRARY(ATOMIC_LIBRARY_NAME\n    NAMES \"statomic\"\n    PATHS ${CXX_PATH}/../${LIBRARY_SUFFIX}\n    NO_DEFAULT_PATH\n  )\n  MESSAGE(STATUS \"ATOMIC_LIBRARY_NAME ${ATOMIC_LIBRARY_NAME}\")\n  IF(ATOMIC_LIBRARY_NAME)\n    DIRNAME(${ATOMIC_LIBRARY_NAME} ATOMIC_LIB_PATH)\n    SET(LRFLAGS \" -L${ATOMIC_LIB_PATH} -R${ATOMIC_LIB_PATH}\")\n\n    STRING_APPEND(CMAKE_C_LINK_FLAGS          \"${LRFLAGS}\")\n    STRING_APPEND(CMAKE_CXX_LINK_FLAGS        \"${LRFLAGS}\")\n    STRING_APPEND(CMAKE_MODULE_LINKER_FLAGS   \"${LRFLAGS}\")\n    STRING_APPEND(CMAKE_SHARED_LINKER_FLAGS   \"${LRFLAGS}\")\n    STRING_APPEND(QUOTED_CMAKE_CXX_LINK_FLAGS \"${LRFLAGS}\")\n  ENDIF()\n\n  SET(QUOTED_CMAKE_CXX_LINK_FLAGS\n    \"${QUOTED_CMAKE_CXX_LINK_FLAGS} -lstatomic \")\nENDIF()\n\n# Experimental support for clang on Intel Solaris.\n# Try to build and run static_thread_local_test.\nIF(MY_COMPILER_IS_CLANG AND SOLARIS_INTEL)\n  SET(CLANG_OUTPUT_FILE ${CMAKE_BINARY_DIR}/clang-output)\n  EXECUTE_PROCESS(\n    COMMAND ${CMAKE_CXX_COMPILER} --print-search-dirs\n    OUTPUT_FILE ${CLANG_OUTPUT_FILE}\n    )\n  FILE(READ ${CLANG_OUTPUT_FILE} OUTPUT_FILE_CONTENTS)\n  STRING(REPLACE \"\\n\" \";\" OUTPUT_FILE_CONTENTS ${OUTPUT_FILE_CONTENTS})\n  FOREACH(LINE ${OUTPUT_FILE_CONTENTS})\n    STRING(REGEX MATCH \"(libraries: =)(.*)\" XXX ${LINE})\n    IF(CMAKE_MATCH_1)\n      SET(LIBRARIES_STRING \"${CMAKE_MATCH_2}\")\n    ENDIF()\n  ENDFOREACH()\n  STRING(REPLACE \":\" \";\" LIBRARIES_LIST \"${LIBRARIES_STRING}\")\n\n  SET(LRFLAGS \"\")\n  FOREACH(LIB_PATH ${LIBRARIES_LIST})\n    GET_FILENAME_COMPONENT(REAL_PATH ${LIB_PATH} REALPATH)\n    STRING_APPEND(LRFLAGS \" -Wl,-L${REAL_PATH} -Wl,-R${REAL_PATH}\")\n  ENDFOREACH()\n\n  STRING_APPEND(CMAKE_C_LINK_FLAGS          \"${LRFLAGS}\")\n  STRING_APPEND(CMAKE_CXX_LINK_FLAGS        \"${LRFLAGS}\")\n  STRING_APPEND(CMAKE_MODULE_LINKER_FLAGS   \"${LRFLAGS}\")\n  STRING_APPEND(CMAKE_SHARED_LINKER_FLAGS   \"${LRFLAGS}\")\n\n  STRING_APPEND(CMAKE_C_LINK_FLAGS          \" -lc\")\n  STRING_APPEND(CMAKE_CXX_LINK_FLAGS        \" -lstdc++ -lgcc_s -lc\")\n  STRING_APPEND(CMAKE_MODULE_LINKER_FLAGS   \" -lstdc++ -lgcc_s -lc\")\n  STRING_APPEND(CMAKE_SHARED_LINKER_FLAGS   \" -lstdc++ -lgcc_s -lc\")\n  STRING_APPEND(QUOTED_CMAKE_CXX_LINK_FLAGS \" -lstdc++ -lgcc_s -lc\")\nENDIF()\n",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/libmysql/authentication_ldap/auth_ldap_sasl_client.cc": "/* Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License, version 2.0,\n   as published by the Free Software Foundation.\n\n   This program is also distributed with certain software (including\n   but not limited to OpenSSL) that is licensed under separate terms,\n   as designated in a particular file or component or in included license\n   documentation.  The authors of MySQL hereby grant you an additional\n   permission to link the program and your derivative works with the\n   separately licensed software that they have included with MySQL.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License, version 2.0, for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA */\n\n#include \"my_config.h\"\n\n/*\n  In case of Kerberos authentication we need to fill user name as Kerberos user\n  name if it is empty. We need to fill user name inside mysql->user, clients\n  uses my_strdup directly to create new string. To use MySQL alloc functions we\n  need to include \"/mysql/service_mysql_alloc.h\". Inside service_mysql_alloc.h\n  there is #define which forces all dynamic plugins to use MySQL malloc function\n  via services. Client side plugin cannot use any services as of now.   Code\n  check in service_mysql_alloc.h #ifdef MYSQL_DYNAMIC_PLUGIN #define my_strdup\n  mysql_malloc_service->my_strdup #else extern char *my_strdup(PSI_memory_key\n  key, const char *from, myf_t flags); #endif Client authentication plugin\n  defines MYSQL_DYNAMIC_PLUGIN. And this forces to use always my_strdup via\n  services. To use native direct my_strdup, we need to undefine\n  MYSQL_DYNAMIC_PLUGIN. And again define MYSQL_DYNAMIC_PLUGIN once correct\n  my_strdup are declared. service_mysql_alloc.h should provide proper fix like\n  Instead of #ifdef MYSQL_DYNAMIC_PLUGIN\n  #ifdef  MYSQL_DYNAMIC_PLUGIN  &&   ! MYSQL_CLIENT_PLUGIN\n*/\n#if defined(KERBEROS_LIB_CONFIGURED)\n#undef MYSQL_DYNAMIC_PLUGIN\n#include <mysql/service_mysql_alloc.h>\n#define MYSQL_DYNAMIC_PLUGIN\n#endif\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"auth_ldap_sasl_client.h\"\n#ifndef _WIN32\n#include <lber.h>\n#include <sasl/sasl.h>\n#endif\n\n#if defined(SASL_CUSTOM_LIBRARY)\n#include <dlfcn.h>\n#include <link.h>\n#include <string>\n#endif\n\n#include <mysql.h>\n#include <mysql/client_plugin.h>\n#include <sql_common.h>\n\nvoid Sasl_client::interact(sasl_interact_t *ilist) {\n  while (ilist->id != SASL_CB_LIST_END) {\n    switch (ilist->id) {\n      /*\n        the name of the user authenticating\n      */\n      case SASL_CB_USER:\n        ilist->result = m_user_name;\n        ilist->len = strlen((const char *)ilist->result);\n        break;\n      /* the name of the user acting for. (for example postman delivering mail\n         for Martin might have an AUTHNAME of postman and a USER of Martin)\n      */\n      case SASL_CB_AUTHNAME:\n        ilist->result = m_user_name;\n        ilist->len = strlen((const char *)ilist->result);\n        break;\n      case SASL_CB_PASS:\n        ilist->result = m_user_pwd;\n        ilist->len = strlen((const char *)ilist->result);\n        break;\n      default:\n        ilist->result = nullptr;\n        ilist->len = 0;\n    }\n    ilist++;\n  }\n}\n\nvoid Sasl_client::set_plugin_info(MYSQL_PLUGIN_VIO *vio, MYSQL *mysql) {\n  m_vio = vio;\n  m_mysql = mysql;\n}\n\n/**\n  SASL method is send from the Mysql server, and this is set by the client.\n  SASL client and sasl server may support many sasl authentication methods\n  and can negotiate in anyone.\n  We want to enforce the SASL authentication set by the client.\n*/\nint Sasl_client::read_method_name_from_server() {\n  int rc_server_read = -1;\n  unsigned char *packet = nullptr;\n  std::stringstream log_stream;\n  /*\n    We are assuming that there will be only one method name passed by\n    server, and length of the method name will not exceed 256 chars.\n  */\n  const int max_method_name_len = 256;\n\n  if (m_vio == nullptr) {\n    return rc_server_read;\n  }\n  /** Get authentication method from the server. */\n  rc_server_read = m_vio->read_packet(m_vio, (unsigned char **)&packet);\n  if (rc_server_read >= 0 && rc_server_read <= max_method_name_len) {\n    strncpy(m_mechanism, (const char *)packet, rc_server_read);\n    m_mechanism[rc_server_read] = '\\0';\n\n    if (strcmp(m_mechanism, SASL_GSSAPI) == 0) {\n      /*\n        If user tries to use kerberos without kerberos libs are installed,\n        We should gracefully error out the authentication. Kerberos objects\n        will not be built in this case.\n      */\n#if defined(KERBEROS_LIB_CONFIGURED)\n      m_sasl_mechanism = new Sasl_mechanism_kerberos();\n#else\n      m_sasl_mechanism = NULL;\n      log_info(\"Kerberos lib not installed, not creting kerberos objects.\");\n#endif\n    } else {\n      m_sasl_mechanism = new Sasl_mechanism();\n    }\n    log_stream << \"Sasl_client::read_method_name_from_server : \" << m_mechanism;\n    log_dbg(log_stream.str());\n  } else if (rc_server_read > max_method_name_len) {\n    rc_server_read = -1;\n    m_mechanism[0] = '\\0';\n    log_stream << \"Sasl_client::read_method_name_from_server : Method name \"\n               << \"is greater then allowed limit of 256 characters.\";\n    log_error(log_stream.str());\n  } else {\n    m_mechanism[0] = '\\0';\n    log_stream << \"Sasl_client::read_method_name_from_server : Plugin has \"\n               << \"failed to read the method name, make sure that default \"\n               << \"authentication plugin and method name specified at \"\n               << \"server are correct.\";\n    log_error(log_stream.str());\n  }\n  return rc_server_read;\n}\n\nSasl_client::Sasl_client() {\n  m_connection = NULL;\n  m_ldap_server_host = \"\";\n  m_mysql = nullptr;\n  m_sasl_mechanism = nullptr;\n}\n\nint Sasl_client::initilize() {\n  std::stringstream log_stream;\n  int rc_sasl = SASL_FAIL;\n  strncpy(m_service_name, SASL_SERVICE_NAME, sizeof(m_service_name) - 1);\n  m_service_name[sizeof(m_service_name) - 1] = '\\0';\n\n  if (m_sasl_mechanism) {\n    m_sasl_mechanism->set_user_info(m_user_name, m_user_pwd);\n    m_sasl_mechanism->pre_authentication();\n    m_sasl_mechanism->get_ldap_host(m_ldap_server_host);\n  }\n#if defined(KERBEROS_LIB_CONFIGURED)\n  if (strcmp(m_mechanism, SASL_GSSAPI) == 0) {\n    m_user_name[0] = '\\0';\n  }\n#endif\n  /** Creating sasl connection. */\n  if (m_ldap_server_host.empty()) {\n    rc_sasl = sasl_client_new(m_service_name, NULL, NULL, NULL, callbacks, 0,\n                              &m_connection);\n  } else {\n    log_info(m_ldap_server_host.c_str());\n    rc_sasl = sasl_client_new(m_service_name, m_ldap_server_host.c_str(), NULL,\n                              NULL, callbacks, 0, &m_connection);\n  }\n  if (rc_sasl != SASL_OK) {\n    log_stream << \"Sasl_client::initilize failed rc: \" << rc_sasl;\n    log_error(log_stream.str());\n    return rc_sasl;\n  }\n\n  /** Set security properties. */\n  sasl_setprop(m_connection, SASL_SEC_PROPS, &security_properties);\n  return SASL_OK;\n}\n\nSasl_client::~Sasl_client() {\n  if (m_connection) {\n    sasl_dispose(&m_connection);\n    m_connection = nullptr;\n  }\n  delete m_sasl_mechanism;\n  m_sasl_mechanism = nullptr;\n}\n\nvoid Sasl_client::sasl_client_done_wrapper() {\n#if (SASL_VERSION_MAJOR >= 2) && (SASL_VERSION_MINOR >= 1) && \\\n    (SASL_VERSION_STEP >= 24) && (!defined __APPLE__) && (!defined __sun)\n  sasl_client_done();\n#else\n  sasl_done();\n#endif\n}\n\nint Sasl_client::send_sasl_request_to_server(const unsigned char *request,\n                                             int request_len,\n                                             unsigned char **response,\n                                             int *response_len) {\n  int rc_server = CR_ERROR;\n  std::stringstream log_stream;\n\n  if (m_vio == nullptr) {\n    goto EXIT;\n  }\n  /** Send the request to the MySQL server. */\n  log_stream << \"Sasl_client::SendSaslRequestToServer length:\" << request_len\n             << \" request: \" << request;\n  log_dbg(log_stream.str());\n  rc_server = m_vio->write_packet(m_vio, request, request_len);\n  if (rc_server) {\n    log_error(\n        \"Sasl_client::SendSaslRequestToServer: sasl request write failed\");\n    goto EXIT;\n  }\n\n  /** Get the sasl response from the MySQL server. */\n  *response_len = m_vio->read_packet(m_vio, response);\n  if ((*response_len) < 0 || (*response == nullptr)) {\n    log_error(\n        \"Sasl_client::SendSaslRequestToServer: sasl response read failed\");\n    goto EXIT;\n  }\n  log_stream.str(\"\");\n  log_stream << \"Sasl_client::SendSaslRequestToServer response:\" << *response\n             << \" length: \" << *response_len;\n  log_dbg(log_stream.str());\nEXIT:\n  return rc_server;\n}\n\nint Sasl_client::sasl_start(char **client_output, int *client_output_length) {\n  int rc_sasl = SASL_FAIL;\n  const char *mechanism = nullptr;\n  char *sasl_client_output = nullptr;\n  sasl_interact_t *interactions = nullptr;\n  std::stringstream log_stream;\n\n  if (m_connection == nullptr) {\n    log_error(\"Sasl_client::SaslStart: sasl connection is null\");\n    return rc_sasl;\n  }\n  void *sasl_client_output_p = &sasl_client_output;\n  do {\n    rc_sasl =\n        sasl_client_start(m_connection, m_mechanism, &interactions,\n                          static_cast<const char **>(sasl_client_output_p),\n                          (unsigned int *)client_output_length, &mechanism);\n    if (rc_sasl == SASL_INTERACT) interact(interactions);\n  } while (rc_sasl == SASL_INTERACT);\n  if (rc_sasl == SASL_NOMECH) {\n    log_stream << \"SASL method '\" << m_mechanism << \"' sent by server, \"\n               << \"is not supported by the SASL client. Make sure that \"\n               << \"cyrus SASL library is installed.\";\n    log_error(log_stream.str());\n    goto EXIT;\n  }\n  if (client_output != nullptr) {\n    *client_output = sasl_client_output;\n    log_stream << \"Sasl_client::SaslStart sasl output: \" << sasl_client_output;\n    log_dbg(log_stream.str());\n  }\nEXIT:\n  return rc_sasl;\n}\n\nint Sasl_client::sasl_step(char *server_in, int server_in_length,\n                           char **client_out, int *client_out_length) {\n  int rc_sasl = SASL_FAIL;\n  sasl_interact_t *interactions = nullptr;\n\n  if (m_connection == nullptr) {\n    return rc_sasl;\n  }\n  void *client_out_p = client_out;\n  do {\n    if (server_in && server_in[0] == 0x0) {\n      server_in_length = 0;\n      server_in = NULL;\n    }\n    rc_sasl = sasl_client_step(\n        m_connection, (server_in == NULL) ? NULL : server_in,\n        (server_in == NULL) ? 0 : server_in_length, &interactions,\n        static_cast<const char **>(client_out_p),\n        (unsigned int *)client_out_length);\n    if (rc_sasl == SASL_INTERACT) Sasl_client::interact(interactions);\n  } while (rc_sasl == SASL_INTERACT);\n  return rc_sasl;\n}\n\nstd::string Sasl_client::get_method() { return m_mechanism; }\n\n#if defined(KERBEROS_LIB_CONFIGURED)\nvoid Sasl_client::read_kerberos_user_name() {\n  std::string user_name = \"\";\n  bool ret_kerberos = false;\n  auth_ldap_client_kerberos_context::Kerberos kerberos(\"\", \"\");\n  ret_kerberos = kerberos.get_user_name(&user_name);\n  if (m_mysql && ret_kerberos && (!user_name.empty())) {\n    /*\n      MySQL clients/lib uses my_free, my_strdup my_* string function for string\n      management. We also need to use same methods as these are used/free inside\n      libmysqlclient\n    */\n    if (m_mysql->user) {\n      my_free(m_mysql->user);\n      m_mysql->user = nullptr;\n    }\n    m_mysql->user =\n        my_strdup(PSI_NOT_INSTRUMENTED, user_name.c_str(), MYF(MY_WME));\n  }\n}\n#endif\n\nvoid Sasl_client::set_user_info(std::string name, std::string pwd) {\n  strncpy(m_user_name, name.c_str(), sizeof(m_user_name) - 1);\n  m_user_name[sizeof(m_user_name) - 1] = '\\0';\n  strncpy(m_user_pwd, pwd.c_str(), sizeof(m_user_pwd) - 1);\n  m_user_pwd[sizeof(m_user_pwd) - 1] = '\\0';\n}\n\n#ifdef __clang__\n// Clang UBSAN false positive?\n// Call to function through pointer to incorrect function type\nstatic int sasl_authenticate(MYSQL_PLUGIN_VIO *vio,\n                             MYSQL *mysql) SUPPRESS_UBSAN;\nstatic int initialize_plugin(char *, size_t, int, va_list) SUPPRESS_UBSAN;\nstatic int deinitialize_plugin() SUPPRESS_UBSAN;\n#endif  // __clang__\n\nstatic int sasl_authenticate(MYSQL_PLUGIN_VIO *vio, MYSQL *mysql) {\n  int rc_sasl = SASL_FAIL;\n  int rc_auth = CR_ERROR;\n  unsigned char *server_packet = nullptr;\n  int server_packet_len = 0;\n  char *sasl_client_output = nullptr;\n  int sasl_client_output_len = 0;\n  std::stringstream log_stream;\n  Sasl_client sasl_client;\n\n  sasl_client.set_plugin_info(vio, mysql);\n\n#if defined(KERBEROS_LIB_CONFIGURED)\n  /*\n    For some cases MySQL user name will be empty as user name is supposed to\n    come from kerberos TGT. Get kerberos user name from TGT and assign this as\n    MySQL user name.\n  */\n  if (!mysql->user || mysql->user[0] == '\\0') {\n    sasl_client.read_kerberos_user_name();\n  }\n#endif\n\n  server_packet_len = sasl_client.read_method_name_from_server();\n  if (server_packet_len < 0) {\n    // Callee has already logged the messages.\n    goto EXIT;\n  }\n\n#if !defined(KERBEROS_LIB_CONFIGURED)\n  if (strcmp(sasl_client.get_method().c_str(), SASL_GSSAPI) == 0) {\n    log_error(\n        \"Kerberos library not installed, kerberos authentication will not \"\n        \"work..\");\n    rc_auth = CR_ERROR;\n    goto EXIT;\n  }\n#endif\n\n  sasl_client.set_user_info(mysql->user, mysql->passwd);\n  rc_sasl = sasl_client.initilize();\n  if (rc_sasl != SASL_OK) {\n    log_error(\"sasl_authenticate: initialize failed\");\n    goto EXIT;\n  }\n\n  rc_sasl =\n      sasl_client.sasl_start(&sasl_client_output, &sasl_client_output_len);\n  if ((rc_sasl != SASL_OK) && (rc_sasl != SASL_CONTINUE)) {\n    log_error(\"sasl_authenticate: SaslStart failed\");\n    goto EXIT;\n  }\n\n  /**\n    Running SASL authentication step till authentication process is concluded\n    MySQL server plug-in working as proxy for SASL / LDAP server.\n  */\n  do {\n    server_packet = NULL;\n    server_packet_len = 0;\n    rc_auth = sasl_client.send_sasl_request_to_server(\n        (const unsigned char *)sasl_client_output, sasl_client_output_len,\n        &server_packet, &server_packet_len);\n    if (rc_auth < 0) {\n      goto EXIT;\n    }\n    sasl_client_output = NULL;\n    rc_sasl =\n        sasl_client.sasl_step((char *)server_packet, server_packet_len,\n                              &sasl_client_output, &sasl_client_output_len);\n    if (sasl_client_output_len == 0) {\n      log_dbg(\"sasl_step: empty client output\");\n    }\n\n  } while (rc_sasl == SASL_CONTINUE);\n\n  if (rc_sasl == SASL_OK) {\n    rc_auth = CR_OK;\n    log_dbg(\"sasl_authenticate authentication successful\");\n    /**\n      Kerberos authentication is concluded by the LDAP/SASL server,\n      From client side, authentication is succeded and we need to send data to\n      server side to conclude the authentication. Other SASL authentication are\n      conculded in the client side.\n    */\n    if (strcmp(sasl_client.get_method().c_str(), SASL_GSSAPI) == 0) {\n      server_packet = NULL;\n      rc_auth = sasl_client.send_sasl_request_to_server(\n          (const unsigned char *)sasl_client_output, sasl_client_output_len,\n          &server_packet, &server_packet_len);\n      rc_auth = CR_OK;\n    }\n  } else {\n    log_error(\"sasl_authenticate client failed\");\n  }\n\nEXIT:\n  if (rc_sasl != SASL_OK) {\n    log_stream.str(\"\");\n    log_stream << \"sasl_authenticate client failed rc: \" << rc_sasl;\n    log_error(log_stream.str());\n  }\n  return rc_auth;\n}\n\n#if defined(SASL_CUSTOM_LIBRARY) || defined(_WIN32)\nstatic int set_sasl_plugin_path() {\n#if defined(_WIN32)\n  std::stringstream log_stream;\n\n  char sasl_plugin_dir[MAX_PATH] = \"\";\n  int ret_executable_path = 0;\n  /**\n    Getting the current executable path, SASL SCRAM dll will be copied in\n    executable path. Using/Setting the path from cmake file may not work as\n    during installation SASL SCRAM DLL may be copied to any path based on\n    installable path.\n  */\n  ret_executable_path =\n      GetModuleFileName(NULL, sasl_plugin_dir, sizeof(sasl_plugin_dir));\n  if ((ret_executable_path == 0) ||\n      (ret_executable_path == sizeof(sasl_plugin_dir))) {\n    log_error(\n        \"sasl client initialize: failed to find executable path or buffer size \"\n        \"for path is too small.\");\n    log_stream << \"Sasl_client::initialize failed\";\n    log_error(log_stream.str());\n    return 1;\n  }\n  char *pos = strrchr(sasl_plugin_dir, '\\\\');\n  if (pos != NULL) {\n    *pos = '\\0';\n  }\n  /**\n    Sasl SCRAM dll default search path is C:\\CMU2,\n    This is the reason we have copied in the executable folder and setting the\n    same from the code.\n  */\n  sasl_set_path(SASL_PATH_TYPE_PLUGIN, sasl_plugin_dir);\n  log_stream << \"Sasl_client::initilize sasl scrum plug-in path : \"\n             << sasl_plugin_dir;\n  log_dbg(log_stream.str());\n  return 0;\n#endif\n\n#if defined(SASL_CUSTOM_LIBRARY)\n  /**\n    Tell SASL where to look for plugins:\n\n    Custom versions of libsasl2.so and libscram.so will be copied to\n      <build directory>/library_output_directory/\n    and\n      <build directory>/library_output_directory/sasl2\n    respectively during build, and to\n      <install directory>/lib/private\n      <install directory>/lib/private/sasl2\n    after 'make install'.\n\n    sasl_set_path() must be called before sasl_client_init(),\n    and is not thread-safe.\n   */\n  char sasl_plugin_dir[PATH_MAX]{};\n  // dlopen(NULL, ) should not fail ...\n  void *main_handle = dlopen(nullptr, RTLD_LAZY);\n  if (main_handle == nullptr) {\n    log_error(dlerror());\n    return 1;\n  }\n  struct link_map *lm = nullptr;\n  if (0 != dlinfo(main_handle, RTLD_DI_LINKMAP, &lm)) {\n    log_error(dlerror());\n    dlclose(main_handle);\n    return 1;\n  }\n  size_t find_result = std::string::npos;\n  for (; lm; lm = lm->l_next) {\n    std::string so_path(lm->l_name);\n    find_result = so_path.find(\"/libsasl\");\n    if (find_result != std::string::npos) {\n      std::string so_dir(lm->l_name, find_result);\n      so_dir.append(\"/sasl2\");\n      so_dir.copy(sasl_plugin_dir, so_dir.size());\n      sasl_set_path(SASL_PATH_TYPE_PLUGIN, sasl_plugin_dir);\n      break;\n    }\n  }\n  dlclose(main_handle);\n  if (find_result == std::string::npos) {\n    log_error(\"Cannot find SASL plugins\");\n    return 1;\n  }\n  return 0;\n#endif  // defined(SASL_CUSTOM_LIBRARY)\n}\n#endif  // defined(SASL_CUSTOM_LIBRARY) || defined(_WIN32)\n\nstatic int initialize_plugin(char *, size_t, int, va_list) {\n  g_logger_client = new Ldap_logger();\n\n  const char *opt = getenv(\"AUTHENTICATION_LDAP_CLIENT_LOG\");\n  int opt_val = opt ? atoi(opt) : 0;\n  if (opt && opt_val > 0 && opt_val < 6) {\n    g_logger_client->set_log_level(static_cast<ldap_log_level>(opt_val));\n  }\n\n  int rc_sasl;\n#if defined(SASL_CUSTOM_LIBRARY) || defined(_WIN32)\n  rc_sasl = set_sasl_plugin_path();\n  if (rc_sasl != SASL_OK) {\n    // Error already logged.\n    return 1;\n  }\n#endif  // SASL_CUSTOM_LIBRARY\n\n  /** Initialize client-side of SASL. */\n  rc_sasl = sasl_client_init(nullptr);\n  if (rc_sasl != SASL_OK) {\n    std::stringstream log_stream;\n    log_stream << \"sasl_client_init failed rc: \" << rc_sasl;\n    log_error(log_stream.str());\n    return 1;\n  }\n\n  return 0;\n}\n\nstatic int deinitialize_plugin() {\n  Sasl_client::sasl_client_done_wrapper();\n\n  delete g_logger_client;\n  g_logger_client = nullptr;\n\n  return 0;\n}\n\nmysql_declare_client_plugin(AUTHENTICATION) \"authentication_ldap_sasl_client\",\n    MYSQL_CLIENT_PLUGIN_AUTHOR_ORACLE, \"LDAP SASL Client Authentication Plugin\",\n    {0, 1, 0}, \"PROPRIETARY\", nullptr, initialize_plugin, deinitialize_plugin,\n    nullptr, sasl_authenticate, nullptr mysql_end_client_plugin;\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/src/common/logger/MSG00001.bin",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/src/ndbapi/NdbUtil.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/src/ndbapi/NdbUtil.hpp",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/src/kernel/blocks/new-block.tar.gz",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/src/kernel/blocks/dbdict/Slave_AddTable.sfl",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/favicon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/img/content-header-dropdown-btn.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/img/right.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/img/content-panel-main-left.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/img/oracle_logo.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/img/settings.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/img/box-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/img/icon-gauge.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/img/content-panel-main-left-top.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/img/content-header-history.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/img/content-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/img/start.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/img/icon-network.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/img/welcome-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/img/welcome-title.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/img/content-header-search-btn.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/img/icons8-view-50.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/img/content-panel-main-right.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/img/tab-separator.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/img/left.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/img/content-panel-main-right-bottom.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/img/content-panel-main-right-top.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/img/icons.odg",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/img/pwdshow_button.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/img/greenlight.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/img/content-title-o-logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/img/icon_continue_cluster.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/img/link-item.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/img/favicon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/img/icon_continue_cluster_disabled.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/img/last.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/img/deploy.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/img/content-panel-main-left-bottom.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/img/content-header-enterprise.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/img/welcome-mysql-logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/img/content-title.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/img/redlight.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/img/pwdshow_btn_small.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/img/vertical-separator.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/img/icon-stopwatch.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/img/yellowlight.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/img/content-panel-main-bottom.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/img/stop.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/img/anyhost.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/img/flag.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/img/icon_new_cluster.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/img/icon-cluster.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/storage/storage_dialog.swf",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/storage/Storage.swf",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/storage/storage_dialog.fla",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/layout/resources/icons/grip_bg.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/layout/resources/icons/resizeRtl.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/layout/resources/icons/pixel.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/layout/resources/icons/splitterToggleH.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/layout/resources/icons/gridcontainer_grip.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/layout/resources/icons/rotator.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/layout/resources/icons/resize.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/layout/resources/icons/splitterToggleV.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/grid/compatGrid.tar.gz",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/grid/enhanced/resources/images/sprite_icons.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/grid/resources/images/tabEnabled_rotated.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/grid/resources/images/header.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/grid/resources/images/header_shadow.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/grid/resources/images/tabHover_rotated.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/grid/resources/images/row_back.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/grid/resources/images/grid_sort_up.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/grid/resources/images/grid_sort_down.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/grid/resources/images/td_button_down.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/grid/resources/images/grid_dx_gradient.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/embed/resources/version.mov",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/fx/resources/shadowTL.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/fx/resources/shadowT.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/fx/resources/shadowTR.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/fx/resources/shadowR.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/fx/resources/shadowBR.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/fx/resources/shadowL.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/fx/resources/shadowB.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/fx/resources/shadowBL.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/rheader.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/zoomouttime.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/parentnode_filled.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/save.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/projProgressFilled.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/resourceBg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/parentnode_bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/collapse.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/zoomin.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/taskProgressFilled.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/taskBar.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/expand.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/rowHighlight.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/resourceHeader.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/taskArrow.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/load.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/zoomintime.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/ownerBar.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/arrow.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/zoomout.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/taskProgressBg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/minus.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/progress_filled.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/plus.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/rbg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/menuHighlight.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/pm.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/am.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/progress_bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/gantt/resources/images/projProgressBg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/image/dojox-image-flickerbase.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/image/resources/images/warning.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/image/resources/images/right.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/image/resources/images/close.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/image/resources/images/loading.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/image/resources/images/left.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/image/resources/images/close.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/image/resources/images/buttons.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/image/resources/images/buttons.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/image/resources/images/left.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/image/resources/images/right.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/image/resources/images/close_dark.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/drawing/resources/CrazyTruck.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/drawing/resources/images/tool_icons.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/drawing/resources/images/tool_sprites.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/smiley.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/previewDisabled.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/anchor.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/anchorDisabled.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/smileyDisabled.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/preview.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/pasteFromWordDisabled.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/editorIconsFindReplaceEnabled.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/save.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/showBlockNodesDisabled.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/editorIconsFindReplaceDisabled.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/breadcrumbDown.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/insertEntity.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/saveDisabled.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/pageBreak.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/blockquoteDisabled.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/blockquote.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/showBlockNodes.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/spellcheck.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/pageBreakDisabled.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/pasteFromWord.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/insertEntityDisabled.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/autoSave.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/soria/close.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/tundra/close.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/nihilo/close.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/icons/claro/close.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/tableIcons.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/anchor.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/cellspace.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/uploadImageIcon.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/tableIcons_rtl.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/cellpad.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/busy.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/checking.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/h4.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/fieldset.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/address.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/ul.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/dd.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/dt.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/noscript.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/iframe.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/h6.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/h1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/center.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/h5.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/div.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/ol.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/h2.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/map.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/h3.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/blockquote.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/button.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/script.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/p.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/form.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/li.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/hr.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/ins.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/del.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/object.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/table.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/blockelems/pre.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/soria/collapse.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/soria/sidebar.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/soria/expand.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/tundra/collapse.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/tundra/sidebar.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/tundra/expand.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/nihilo/collapse.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/nihilo/sidebar.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/nihilo/expand.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/claro/collapse.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/images/claro/expand.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/emoticons/emoticonHalf.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/emoticons/emoticonCool.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/emoticons/emoticonAngel.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/emoticons/emoticonAngry.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/emoticons/emoticonGrin.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/emoticons/emoticonTongue.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/emoticons/emoticonShy.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/emoticons/emoticonNo.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/emoticons/emoticonHappy.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/emoticons/emoticonLaughing.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/emoticons/emoticonCrying.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/emoticons/emoticonIdea.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/emoticons/emoticonFrown.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/emoticons/emoticonSmile.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/emoticons/emoticonOops.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/emoticons/emoticonGoofy.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/emoticons/emoticonWink.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/emoticons/emoticonYes.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/editor/plugins/resources/emoticons/emoticonEyebrow.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/sketch/resources/images/icons.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/compat/spinwheel-bar.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/compat/spinwheel-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonDarkBlueMinus.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonBlueCircleArrow.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonBlackRightArrow16.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonGreenCirclePlus.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonBlackDownArrow16.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonWhiteDownArrow16.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonWhiteRightArrow16.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonBlueCirclePlus.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonDarkBlueCheck.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonWhiteMinus.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonWhiteUpArrow16.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonRedCirclePlus.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonWhiteLeftArrow16.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonRedMinus.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonGrayPlus.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonCheckboxOff.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonWhiteUpArrow.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonGrayKnob.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonSilverCircleRedCross.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonBlackCircleCross.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonRedCross.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonWhiteSearch.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonGrayMinus.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonGreenCircleArrow.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonWhiteArrow.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonSilverCircleGreenPlus.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonWhiteCheck.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonYellowStar.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonRedCircleMinus.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonWhitePlus.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonBlueMinus.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonGrayStar.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonGreenBall.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonBluePlus.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonBlueCircleMinus.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonArrow.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonSilverCircleGreenButton.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonSilverCircleDownArrow.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonDarkBluePlus.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonGreenCircleMinus.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonRedBall.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonBlueBall.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonOrangeBall.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonRedCircleArrow.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonBlackUpArrow16.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonBlackLeftArrow16.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonGrayArrow.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonWhiteCross.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonCheck.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonRedPlus.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonCheckboxOn.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonSilverCircleGrayButton.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonWhiteDownArrow.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonGrayCross.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/common/domButtons/compat/mblDomButtonSilverCircleOrangeButton.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/button-arrow-head-bg.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/togglebutton-chk-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/arrow-button-head.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/button-unsel-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/red-button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/blue-button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/arrow-button-right-head-sel.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/switch-round1-l.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/slider-h-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/switch-square-k.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/switch-arc2-k.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/tab-orange-button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/button-sel-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/switch-arc1-r.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/tab-tall-bar-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/tab-seg-sel-button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/arrow-button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/switch-round2-l.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/switch-round1-k.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/icon-content-heading-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/button-chk-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/tab-sel-button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/tab-slim-bar-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/tab-button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/switch-arc2-l.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/slider-h-bar-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/switch-square-r.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/valuepicker-button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/switch-round1-r.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/tab-seg-button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/switch-arc2-r.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/switch-round2-r.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/switch-arc1-k.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/heading-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/blue-button-sel-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/togglebutton-chk-mark-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/arrow-button-bg-sel.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/slider-handle-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/switch-round2-k.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/gray-arrow.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/red-button-sel-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/switch-square-l.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/arrow-button-right-head.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/switch-arc1-l.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/compat/arrow-button-head-sel.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/images/thumb-overlay.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/images/thumb-overlay-large.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/images/thumb-overlay-small.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/dijit/compat/calendar-datelabel-act-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/dijit/compat/calendar-datelabel-sel-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/dijit/compat/calendar-month-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/android/dijit/compat/calendar-year-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/custom/compat/button-arrow-head-bg.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/custom/compat/button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/custom/compat/arrow-button-head.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/custom/compat/button-unsel-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/custom/compat/red-button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/custom/compat/blue-button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/custom/compat/arrow-button-right-head-sel.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/custom/compat/switch-round1-l.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/custom/compat/slider-h-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/custom/compat/switch-square-k.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/custom/compat/switch-arc2-k.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/custom/compat/button-sel-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/custom/compat/switch-arc1-r.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/custom/compat/tab-tall-bar-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/custom/compat/tab-seg-sel-button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/custom/compat/arrow-button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/custom/compat/switch-round2-l.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/custom/compat/switch-round1-k.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/custom/compat/icon-content-heading-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/custom/compat/button-chk-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/custom/compat/tab-slim-bar-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/custom/compat/switch-arc2-l.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/custom/compat/slider-h-bar-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/custom/compat/switch-square-r.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/custom/compat/valuepicker-button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/custom/compat/switch-round1-r.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/custom/compat/tab-seg-button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/custom/compat/switch-arc2-r.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/custom/compat/switch-round2-r.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/custom/compat/switch-arc1-k.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/custom/compat/heading-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/custom/compat/blue-button-sel-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/custom/compat/togglebutton-chk-mark-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/custom/compat/arrow-button-bg-sel.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/custom/compat/slider-handle-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/custom/compat/switch-round2-k.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/custom/compat/red-button-sel-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/custom/compat/switch-square-l.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/custom/compat/arrow-button-right-head.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/custom/compat/switch-arc1-l.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/custom/compat/arrow-button-head-sel.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/custom/images/thumb-overlay.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/custom/images/thumb-overlay-large.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/custom/images/thumb-overlay-small.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/custom/dijit/compat/calendar-datelabel-act-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/custom/dijit/compat/calendar-datelabel-sel-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/custom/dijit/compat/calendar-month-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/custom/dijit/compat/calendar-year-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/button-arrow-head-bg.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/arrow-button-head.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/button-unsel-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/red-button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/blue-button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/arrow-button-right-head-sel.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/switch-round1-l.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/slider-h-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/switch-square-k.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/switch-arc2-k.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/tab-orange-button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/button-sel-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/switch-arc1-r.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/tab-tall-bar-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/tab-seg-sel-button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/arrow-button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/switch-round2-l.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/switch-round1-k.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/icon-content-heading-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/button-chk-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/tab-sel-button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/tab-slim-bar-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/tab-button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/switch-arc2-l.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/slider-h-bar-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/switch-square-r.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/valuepicker-button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/switch-round1-r.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/tab-seg-button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/switch-arc2-r.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/switch-round2-r.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/switch-arc1-k.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/heading-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/blue-button-sel-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/togglebutton-chk-mark-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/arrow-button-bg-sel.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/slider-handle-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/switch-round2-k.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/gray-arrow.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/red-button-sel-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/switch-square-l.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/arrow-button-right-head.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/arrow-button-head.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/switch-arc1-l.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/compat/arrow-button-head-sel.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/images/thumb-overlay.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/images/thumb-overlay-large.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/images/thumb-overlay-small.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/dijit/compat/calendar-datelabel-sel-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/dijit/compat/calendar-month-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/blackberry/dijit/compat/calendar-year-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/switch-arc-r.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/button-arrow-head-bg.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/arrow-button-head.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/button-unsel-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/red-button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/blue-button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/arrow-button-right-head-sel.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/switch-round1-l.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/slider-h-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/switch-square-k.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/switch-arc2-k.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/ipad-arrow-button-head.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/ipad-arrow-button-right-head.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/button-sel-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/switch-arc1-r.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/tab-tall-bar-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/tab-seg-sel-button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/switch-default-l.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/arrow-button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/switch-round2-l.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/switch-round1-k.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/icon-content-heading-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/switch-arc-l.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/ipad-arrow-button-right-head-sel.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/button-chk-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/tab-sel-button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/tab-slim-bar-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/tab-button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/switch-arc2-l.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/switch-round-l.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/slider-h-bar-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/switch-square-r.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/valuepicker-button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/ipad-arrow-button-sel-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/switch-round1-r.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/tab-seg-button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/switch-arc2-r.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/switch-round2-r.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/switch-arc1-k.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/switch-default-r.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/switch-default-k.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/heading-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/blue-button-sel-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/togglebutton-chk-mark-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/arrow-button-bg-sel.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/tooltip-heading-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/slider-handle-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/switch-round2-k.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/tooltip-button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/ipad-arrow-button-head-sel.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/ipad-heading-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/gray-arrow.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/red-button-sel-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/switch-round-r.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/switch-square-l.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/arrow-button-right-head.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/ipad-arrow-button-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/edge-categ-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/white-arrow.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/switch-arc1-l.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/compat/arrow-button-head-sel.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/images/thumb-overlay.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/images/thumb-overlay-large.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/images/thumb-overlay-small.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/dijit/compat/calendar-daylabel-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/dijit/compat/calendar-month-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/mobile/themes/iphone/dijit/compat/calendar-year-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/form/resources/uploader.swf",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/form/resources/fileuploader.swf",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/form/resources/images/soriaFolderSprite.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/form/resources/images/nihiloFolderSprite.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/form/resources/images/rating_full.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/form/resources/images/tundraFolderSprite.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/form/resources/images/loading_wheel.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/form/resources/images/rating_empty.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/form/resources/images/tristatecheckboxStates.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/geo/charting/resources/img/zoomin.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/geo/charting/resources/img/zoomin.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/geo/charting/resources/img/zoomout.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/geo/charting/resources/img/zoomout.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/av/resources/audio.swf",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/av/resources/video.swf",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/av/resources/version.mov",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/av/widget/resources/images/progressPositionBk.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/av/widget/resources/images/progressLoadedBk.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/av/widget/resources/images/player_sprite.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/av/widget/resources/images/sliderHandleSprite.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/av/widget/resources/images/sliderHandleNorm.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/av/widget/resources/images/sliderHandleOver.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/av/widget/resources/images/dojoPlayerIcons.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/widget/FilePicker/images/soriaFileIcons.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/widget/FilePicker/images/nihiloFileIcons.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/widget/FilePicker/images/tundraFileIcons.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/widget/Dialog/images/dialogCloseButton.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/widget/Dialog/images/dialogCloseButton.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/widget/Pager/images/pageInactive.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/widget/Pager/images/hPrevious.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/widget/Pager/images/hNext.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/widget/Pager/images/pageActive.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/widget/Pager/images/vNext.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/widget/Pager/images/vPrevious.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/widget/Standby/images/loading.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/widget/Portlet/images/icons.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/widget/Portlet/images/icons.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/widget/ColorPicker/images/hue.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/widget/ColorPicker/images/hueHandleA11y.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/widget/ColorPicker/images/pickerPointer.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/widget/ColorPicker/images/underlay.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/widget/ColorPicker/images/hueHandle.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/widget/Loader/icons/loading.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/calendar/themes/soria/images/accordionItemActive.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/calendar/themes/soria/images/titleBar.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/calendar/themes/tundra/images/accordionItemHover.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/calendar/themes/tundra/images/titleBar.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/calendar/themes/nihilo/images/accordionItemActive.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/calendar/themes/nihilo/images/titleBar.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojox/calendar/themes/claro/images/titlebar.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/icons/images/editorIconsDisabled_rtl.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/icons/images/loadingAnimation_rtl.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/icons/images/commonIconsObjActDisabled.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/icons/images/commonIconsObjActEnabled_rtl.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/icons/images/commonIconsObjActEnabled8bit.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/icons/images/commonIconsObjActDisabled_rtl.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/icons/images/editorIconsDisabled.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/icons/images/editorIconsEnabled_rtl.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/icons/images/editorIconsEnabled.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/icons/images/commonIconsObjActEnabled.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/icons/images/commonIconsObjActEnabled8bit_rtl.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/a11y/colors7x10.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/a11y/indeterminate_progress.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/a11y/colors3x4.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/buttonDisabled.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/treeI_rtl.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/spriteRoundedIconsSmallBl.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/warning.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/tabLeftChecked.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/spriteDivIcons.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/sliderEmptyVertical.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/progressBarAnim.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/buttonHover.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/tooltipConnectorDown.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/spriteCheckbox.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/tooltipConnectorRight.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/tabBottomHoverC.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/treeI.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/buttonEnabled.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/spriteTree_rtl.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/spriteRoundedIconsSmall.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/sliderEmpty.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/splitContainerSizerV-thumb.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/treeExpand_loading.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/titleBarActive.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/preciseSliderThumbFocus.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/tooltipConnectorUp.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/treeI_half_rtl.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/accordionItemActive.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/sliderFullVerticalFocus.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/spriteTree.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/tooltipConnectorUp.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/tooltipConnectorLeft.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/dndMove.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/sliderThumb.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/spriteRadio.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/spriteRoundedIconsSmallBl.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/accordionItemActive.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/sliderFull.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/splitContainerSizerH-thumb.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/tabRightChecked.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/sliderThumbFocus.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/treeI_half.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/sliderThumbFocus.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/titleBar.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/validationInputBg.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/tabBottomEnabledC.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/tooltipConnectorDown.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/tabBottomEnabledSpriteLR.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/preciseSliderThumb.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/tabBottomActiveC.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/spriteArrows.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/splitContainerSizerH.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/tooltipConnectorLeft.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/spriteTree.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/preciseSliderThumb.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/spriteRadio.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/buttonActive.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/sliderThumb.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/treeHover.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/splitContainerSizerV.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/dndNoCopy.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/dndCopy.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/spriteCheckbox.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/progressBarEmpty.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/spriteDivIcons.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/validationInputBg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/sliderFullFocus.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/spriteTree_rtl.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/tabContainerSprite.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/spriteRoundedIconsSmall.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/dndNoMove.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/progressBarFull.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/tooltipConnectorRight.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/sliderFullVertical.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/preciseSliderThumbFocus.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/soria/images/spriteArrows.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/progressBarAnim.psd",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/buttonDisabled.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/warning.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/i.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/sliderEmptyVertical.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/tabHover.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/progressBarAnim.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/buttonHover.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/dijitProgressBarAnim.psd",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/tooltipConnectorDown.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/tabActive.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/tooltipConnectorRight.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/dojoTundraGradientBg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/progressBarAnim-2.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/buttonEnabled.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/tabClose.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/comboArrowDown.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/folderOpened.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/dojoTundraGradientBg.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/spriteRoundedIconsSmall.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/sliderEmpty.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/tabCloseHover.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/leaf.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/smallArrowDown.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/splitContainerSizerV-thumb.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/i_half_rtl.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/radioButtonActiveHover.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/treeExpand_minus.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/treeExpand_loading.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/loading.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/preciseSliderThumbFocus.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/tooltipConnectorUp.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/accordionItemActive.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/sliderFullVerticalFocus.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/plusButton.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/menu.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/tooltipConnectorUp.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/tooltipConnectorLeft.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/noX.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/treeExpand_mius.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/dndMove.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/checkmark.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/treeExpand_leaf.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/calendarYearLabel.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/accordionItemHover.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/sliderThumb.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/treeExpand_minus_rtl.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/radioButtonDisabled.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/progressBarAnim-4.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/tabHover.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/tabClose.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/treeExpand_plus_rtl.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/progressBarAnim-9.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/progressBarAnim-6.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/progressBarAnim-5.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/treeExpand_plus.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/sliderFull.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/titleBarBg.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/splitContainerSizerH-thumb.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/circleIcon.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/i_half.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/doubleArrowDown.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/sliderThumbFocus.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/sliderThumbFocus.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/titleBar.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/progressBarAnim-8.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/tabEnabled.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/validationInputBg.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/tabCloseHover.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/tooltipConnectorDown.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/tabDisabled.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/checkmarkNoBorder.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/preciseSliderThumb.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/popupMenuBg.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/radioButtonEnabled.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/folderClosed.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/spriteArrows.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/dijitProgressBarAnim.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/splitContainerSizerH.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/tooltipConnectorLeft.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/smallArrowUp.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/radioButtonActive.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/preciseSliderThumb.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/buttonActive.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/checkmark.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/minusButton.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/treeHover.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/splitContainerSizerV.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/dndNoCopy.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/checkmarkNoBorder.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/dndCopy.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/i_rtl.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/no.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/progressBarEmpty.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/radioButtonActiveDisabled.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/validationInputBg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/progressBarAnim-3.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/sliderFullFocus.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/circleIcon.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/spriteRoundedIconsSmall.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/progressBarAnim-7.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/treeExpand_leaf_rtl.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/dndNoMove.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/progressBarFull.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/tooltipConnectorRight.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/progressBarAnim-1.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/calendarDayLabel.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/doubleArrowUp.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/calendarMonthLabel.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/sliderFullVertical.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/radioButtonHover.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/preciseSliderThumbFocus.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/tundra/images/spriteArrows.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/buttonDisabled.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/treeI_rtl.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/warning.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/spriteDivIcons.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/sliderEmptyVertical.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/progressBarAnim.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/buttonHover.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/tooltipConnectorDown.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/spriteCheckbox.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/tooltipConnectorRight.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/tabBottomHoverC.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/treeI.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/buttonEnabled.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/spriteTree_rtl.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/spriteRoundedIconsSmall.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/sliderEmpty.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/splitContainerSizerV-thumb.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/treeExpand_loading.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/titleBarActive.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/preciseSliderThumbFocus.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/tooltipConnectorUp.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/treeI_half_rtl.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/sliderFullVerticalFocus.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/spriteTree.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/tooltipConnectorUp.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/tooltipConnectorLeft.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/dndMove.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/sliderThumb.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/spriteRadio.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/accordionItemActive.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/sliderFull.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/splitContainerSizerH-thumb.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/sliderThumbFocus.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/treeI_half.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/sliderThumbFocus.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/titleBar.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/validationInputBg.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/tabBottomEnabledC.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/tooltipConnectorDown.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/preciseSliderThumb.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/tabBottomActiveC.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/spriteArrows.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/splitContainerSizerH.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/tooltipConnectorLeft.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/spriteTree.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/preciseSliderThumb.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/spriteRadio.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/buttonActive.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/sliderThumb.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/treeHover.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/splitContainerSizerV.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/dndNoCopy.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/dndCopy.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/no.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/spriteCheckbox.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/progressBarEmpty.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/spriteDivIcons.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/validationInputBg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/sliderFullFocus.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/spriteTree_rtl.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/tabContainerSprite.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/spriteRoundedIconsSmall.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/dndNoMove.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/progressBarFull.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/tooltipConnectorRight.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/sliderFullVertical.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/preciseSliderThumbFocus.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/nihilo/images/spriteArrows.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/layout/images/tabBottomUnselected.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/layout/images/tabTopSelected.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/layout/images/tabLeftSelected.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/layout/images/tabClose.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/layout/images/tabBottomSelected.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/layout/images/tabRightSelected.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/layout/images/tabRightUnselected.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/layout/images/tabLeftUnselected.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/layout/images/tabTopUnselected.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/layout/images/tabNested.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/images/dnd.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/images/progressBarAnim.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/images/standardGradient.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/images/tooltip8bit.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/images/activeGradient.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/images/treeExpandImages8bit.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/images/treeExpandImages.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/images/dialogCloseIcon.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/images/calendar.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/images/calendarArrows8bit.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/images/checkmarkNoBorder.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/images/tooltip.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/images/calendarArrows.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/images/loadingAnimation.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/images/checkmarkNoBorder.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/images/progressBarFull.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/images/spriteArrows.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/images/dialogCloseIcon8bit.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/form/images/buttonDisabled.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/form/images/commonFormArrows.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/form/images/error.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/form/images/buttonEnabled.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/form/images/checkboxRadioButtonStates.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/form/images/buttonArrows.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/form/images/sliderThumbs.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dijit/themes/claro/form/images/checkboxAndRadioButtons_IE6.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojo/resources/blank.gif",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojo/resources/images/dndMove.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojo/resources/images/dndNoCopy.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojo/resources/images/dndCopy.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/dojo/dojo/resources/images/dndNoMove.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/hlp/img/deploy.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/hlp/img/ClusterToolsMenu.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/hlp/img/define_cluster-pwdreminder.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/hlp/img/clusterdefpageextssh.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/hlp/img/breadcrumb_trail.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/hlp/img/cluster-not-deployed.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/hlp/img/shadow-buttons.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/hlp/img/edit_selected_hosts.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/hlp/img/define_parameters.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/hlp/img/hosts-pwd-reminder.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/hlp/img/changed-no-of-repl.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/hlp/img/hostgrid-collapsed.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/hlp/img/hostgrid-expanded.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/hlp/img/define_cluster.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/hlp/img/welcome.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/hlp/img/add_process.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/hlp/img/define_parameters-paramchg-view-shadow.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/hlp/img/cookies.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/hlp/img/help_menu.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/hlp/img/page_buttons.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/hlp/img/unknown-progress.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/hlp/img/starting_cluster.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/hlp/img/define_hosts.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/hlp/img/IEsecset.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/hlp/img/12hostsclusterstarted.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/hlp/img/define_processes.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/hlp/img/invalid-config.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/hlp/img/define_processes-warning.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/hlp/img/define_parameters-paramchg.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/hlp/img/deploypageinstallconfirm.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/mcc/frontend/hlp/img/add_host.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/include/ndbapi/NdbScanFilter.hpp",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/test/include/getarg.h",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/storage/ndb/test/run-test/atrt-example.tgz",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/build-ps/debian/.percona-server-server-8.0.postinst.swp",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/router/src/harness/src/logging/eventlog_rc/MSG00001.bin",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/packaging/WiX/AdminBackground.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/packaging/WiX/AdminHeader.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/packaging/WiX/MySQLServer.ico",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/packaging/WiX/mysqlcommandlineshell.ico",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/packaging/WiX/router/AdminBackground.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/packaging/WiX/router/MySQLRouter.ico",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/packaging/WiX/router/AdminHeader.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/plugin/percona-pam-for-mysql/doc/source/percona-pam-plugin-logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/plugin/percona-pam-for-mysql/doc/source/percona_favicon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/plugin/percona-pam-for-mysql/doc/source/_static/percona-pam-plugin-logo.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/plugin/percona-pam-for-mysql/doc/source/_static/percona_favicon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/extra/zlib/zlib.3.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/initial_v@1o.frm",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/8.0.15_cfg.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/bug37631.frm",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/corrupt-relay-bin.000624",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/data_8017_crypt_v1_keyring_encrypted.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/crc32_endianness.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/binlog_no_fd_event.000001",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/binlog_56_gtid_reserved_word.000001",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/table_encrypted_32.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/t_set.frm",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/old_table-323.frm",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/data57_drop_fts.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/data_8016_crypt_v1.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/data57_enum.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/14897.frm",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/loaddata6.dat",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/binlog_truncated_event.000001",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/loaddata7.dat",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/data57.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/data_redo_log_keyring_v1_encrypted.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/data57_zip_dict.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/data_prev_ver_part_tokudb.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/tablespace_portable_linux.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/57import.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/data_57_crypt_v1_encryption_n.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/data_prev_ver_part_rocksdb.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/bug16266.000001",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/t_gcol_dep.frm",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/data_8017_crypt_v1_half_rotated.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/data57_sys.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/tablespace_portable_win.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/bug47205.frm",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/keys2.txt",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/data80011_upgrade_groupby_desc_ci_win.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/leak172_t2.data",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/bug21542698.dat",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/data57_encrypted.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/mylogin-bad-cipher.cnf",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/master-bin.000001",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/data57_upgrade_groupby_desc.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/data_57_crypt_v1.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/rpl_cross_version_default_utf8mb4_collation.000001",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/data_8017_crypt_v1_encryption_n.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/keys3.txt",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/data80011_upgrade_groupby_desc_ci_mac.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/data57_upgrade_trigger_order.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/rpl_atomic_ddl_rollback_view.000001",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/data_prev_ver_row_format_tokudb.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/data_8017_crypt_v1_sys_half_encrypted.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/data57_upgrade_innodb_4k.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/data76.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/loaddata_incomplete_mb.dat",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/wl12261_dump.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/rpl_atomic_ddl_rollback_table.000001",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/rpl_nogtid_encryption_master-bin.000002",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/initial_t@1o.frm",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/data57_fts_lctn.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/bug20444737.sql",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/data57_fts_nolctn.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/corrupt_t1#P#p1.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/data_8017_crypt_v1_sys_encrypted.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/rpl_atomic_ddl_rollback_full.000001",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/data_8017_crypt_v1_decrypted.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/data57_partition_prefix_key.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/bug33029-slave-relay-bin.000001",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/binlog_savepoint.000001",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/undo57_encrypted.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/bug27213339-bin.000001",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/data_8017_crypt_v1.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/binlog_transaction.000001",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/rpl_unfiltered_hidden_gcol.000001",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/binlog_transaction_with_GTID.000001",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/data57_fts_aux.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/bug37631.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/corrupt_t1.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/fw_data_57.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/table_encrypted_64.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/bug40482-bin.000001",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/41_decimal.frm",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/binlog_truncated_prev_gtid_event.000001",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/data80011_upgrade_groupby_desc_cs.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/slave-relay-bin.000001",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/data8013_57.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/binlog_transaction_with_anonymous_GTID.000001",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/data_8015_dd_encrypted.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/data57_upgrade_default_timezone_bug.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/fw_data_80016.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/8.0.17_cfg.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/data57_partition.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/data57_index_stats.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/bug46565.ARZ",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/parts/t1_will_crash#P#p6_2.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/parts/t1_will_crash#P#p6_3.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/parts/t1TIMESTAMP.frm",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/parts/t1_will_crash#P#p1_first_1024.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/parts/t1_will_crash#P#p2.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/parts/t1_blackhole.frm",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/parts/t1_will_crash#P#p3.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/parts/t1_will_crash#P#p6.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/parts/t1_will_crash#P#p2.MYD",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/parts/t1_will_crash#P#p4.MYI",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/lob/earth215kb.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/57_binlog_encryption/ps_encrypted_master-bin.000002",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/57_binlog_encryption/ps_encrypted_slave-relay-bin.000002",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/57_binlog_encryption/ps_encrypted_truncated_master-bin.000002",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/57_binlog_encryption/ps_encrypted_slave-relay-bin.000001",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/log_corruption/log_corruption3.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/log_corruption/log_corruption.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/log_corruption/log_corruption0.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/log_corruption/log_corruption4c.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/log_corruption/log_corruption1.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/log_corruption/log_corruption2.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/log_corruption/log_corruption5.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/log_corruption/log_corruption_1.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/log_corruption/log_corruption6.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/log_corruption/log_corruption4a.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/log_corruption/log_corruption6b.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/log_corruption/log_corruption4b.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/log_corruption/log_corruption4d.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/log_corruption/log_corruption4.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/log_corruption/log_corruption7.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/rocksdb/data_rocks_5730_bloomfilter.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/dd/sdi/innodb_sdi/t18_#p#p1#sp#p11.json",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/upgrade/export_wl13352_8019_win_lctn_1.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/upgrade/data_57_lctn2_ci_win.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/upgrade/data_80011.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/upgrade/data_wl13352_5727_lin_lctn_0.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/upgrade/data_wl13352_8019_win_lctn_2.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/upgrade/data_wl13352_5727_mac_lctn_1.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/upgrade/data_80013_sql_modes.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/upgrade/extn_wl13352_8015.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/upgrade/wl12261_upgrade_80013.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/upgrade/data_wl13352_8015.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/upgrade/wl12261_upgrade_80012.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/upgrade/data_wl13352_8019_mac_lctn_2.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/upgrade/data_wl13352_5727_lin_lctn_1.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/upgrade/bug29791350_upgrade_57022.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/upgrade/data_80018.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/upgrade/data_57022.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/upgrade/data_57_lctn1_ci_win.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/upgrade/export_wl13352_8015.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/upgrade/data_80014.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/upgrade/extn_wl13352_8019_win_lctn_2.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/upgrade/data_57_lctn0_cs_lin.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/upgrade/extn_wl13352_8019_win_lctn_1.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/upgrade/data_wl13352_8019_lin_lctn_1.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/upgrade/data_80013.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/upgrade/export_wl13352_8019_win_lctn_2.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/upgrade/data_wl13352_8019_lin_lctn_0.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/upgrade/data_80016_lctn1_lin_nopart.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/upgrade/extn_wl13352_8019_mac_lctn_1.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/upgrade/extn_wl13352_8017.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/upgrade/data_80016.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/upgrade/data_57_clone_lin.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/upgrade/data_encrypted_80016.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/upgrade/data_80017.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/upgrade/data_wl13352_8019_mac_lctn_1.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/upgrade/data_80016_lctn0_lin_nopart.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/upgrade/data_wl13352_8019_win_lctn_1.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/upgrade/data_80011_ci_mac.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/upgrade/data_80012.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/upgrade/80016_subpart.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/upgrade/extn_wl13352_8019_mac_lctn_2.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/upgrade/data_57_lctn1_cs_lin.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/upgrade/data_wl13352_5727_mac_lctn_2.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/upgrade/extn_wl13352_8013.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/upgrade/data_wl13352_8017.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/upgrade/export_wl13352_8019_lin_lctn_1.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/upgrade/extn_wl13352_8019_lin_lctn_0.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/upgrade/data_80012_part.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/upgrade/export_wl13352_8019_lin_lctn_0.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/upgrade/data_wl13352_5727_win_lctn_1.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/upgrade/data_wl13352_8013.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/upgrade/data_wl13352_5727_win_lctn_2.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/upgrade/wl12261_upgrade_57025.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/upgrade/export_wl13352_8019_mac_lctn_1.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/upgrade/extn_wl13352_8019_lin_lctn_1.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/upgrade/data_80016_lctn0_lin_part.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/upgrade/bug29996434_upgrade_57022.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/upgrade/data_80015.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/upgrade/export_wl13352_8013.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/upgrade/export_wl13352_8019_mac_lctn_2.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/upgrade/bugdata_80011.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/upgrade/data_57_lctn2_ci_mac.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/upgrade/data_80016_lctn1_lin_part.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/upgrade/data_57_lctn1_ci_mac.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/upgrade/data_80011_fts.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/upgrade/export_wl13352_8017.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/std_data/upgrade/data_80011_ci_win.zip",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/include/ctype_utf8mb4.inc",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/include/subquery_sj.inc",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/51_d2_le/BACKUP-1.2.log",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/51_d2_le/BACKUP-1-0.2.Data",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/51_d2_le/BACKUP-1.1.log",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/51_d2_le/BACKUP-1.1.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/51_d2_le/BACKUP-1-0.1.Data",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/51_d2_le/BACKUP-1.2.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_80_minor_fk/BACKUP-1-PART-2-OF-4/BACKUP-1.2.log",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_80_minor_fk/BACKUP-1-PART-2-OF-4/BACKUP-1-0.2.Data",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_80_minor_fk/BACKUP-1-PART-2-OF-4/BACKUP-1.1.log",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_80_minor_fk/BACKUP-1-PART-2-OF-4/BACKUP-1.1.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_80_minor_fk/BACKUP-1-PART-2-OF-4/BACKUP-1-0.1.Data",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_80_minor_fk/BACKUP-1-PART-2-OF-4/BACKUP-1.2.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_80_minor_fk/BACKUP-1-PART-1-OF-4/BACKUP-1.2.log",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_80_minor_fk/BACKUP-1-PART-1-OF-4/BACKUP-1-0.2.Data",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_80_minor_fk/BACKUP-1-PART-1-OF-4/BACKUP-1.1.log",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_80_minor_fk/BACKUP-1-PART-1-OF-4/BACKUP-1.1.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_80_minor_fk/BACKUP-1-PART-1-OF-4/BACKUP-1-0.1.Data",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_80_minor_fk/BACKUP-1-PART-1-OF-4/BACKUP-1.2.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_80_minor_fk/BACKUP-1-PART-3-OF-4/BACKUP-1.2.log",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_80_minor_fk/BACKUP-1-PART-3-OF-4/BACKUP-1-0.2.Data",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_80_minor_fk/BACKUP-1-PART-3-OF-4/BACKUP-1.1.log",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_80_minor_fk/BACKUP-1-PART-3-OF-4/BACKUP-1.1.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_80_minor_fk/BACKUP-1-PART-3-OF-4/BACKUP-1-0.1.Data",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_80_minor_fk/BACKUP-1-PART-3-OF-4/BACKUP-1.2.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_80_minor_fk/BACKUP-1-PART-4-OF-4/BACKUP-1.2.log",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_80_minor_fk/BACKUP-1-PART-4-OF-4/BACKUP-1-0.2.Data",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_80_minor_fk/BACKUP-1-PART-4-OF-4/BACKUP-1.1.log",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_80_minor_fk/BACKUP-1-PART-4-OF-4/BACKUP-1.1.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_80_minor_fk/BACKUP-1-PART-4-OF-4/BACKUP-1-0.1.Data",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_80_minor_fk/BACKUP-1-PART-4-OF-4/BACKUP-1.2.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/bug54613/BACKUP-2.2.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_disk_data_backup/BACKUP-1.2.log",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_disk_data_backup/BACKUP-1-0.2.Data",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_disk_data_backup/BACKUP-1.1.log",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_disk_data_backup/BACKUP-1.1.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_disk_data_backup/BACKUP-1-0.1.Data",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_disk_data_backup/BACKUP-1.2.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/76_inplace_upgrade_backup/BACKUP-1.2.log",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/76_inplace_upgrade_backup/BACKUP-1-0.2.Data",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/76_inplace_upgrade_backup/BACKUP-1.1.log",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/76_inplace_upgrade_backup/BACKUP-1.1.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/76_inplace_upgrade_backup/BACKUP-1-0.1.Data",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/76_inplace_upgrade_backup/BACKUP-1.2.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/before_native_default/BACKUP-1.2.log",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/before_native_default/BACKUP-1-0.2.Data",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/before_native_default/BACKUP-1.1.log",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/before_native_default/BACKUP-1.1.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/before_native_default/BACKUP-1-0.1.Data",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/before_native_default/BACKUP-1.2.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/packed/BACKUP-1.2.log",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/packed/BACKUP-1-0.2.Data",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/packed/BACKUP-1.2.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/51_data_be/BACKUP-1.2.log",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/51_data_be/BACKUP-1-0.2.Data",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/51_data_be/BACKUP-1.1.log",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/51_data_be/BACKUP-1.1.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/51_data_be/BACKUP-1-0.1.Data",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/51_data_be/BACKUP-1.2.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_basic_backup/BACKUP-1.2.log",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_basic_backup/BACKUP-1-0.2.Data",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_basic_backup/BACKUP-1.1.log",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_basic_backup/BACKUP-1.1.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_basic_backup/BACKUP-1-0.1.Data",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_basic_backup/BACKUP-1.2.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_fk_backup/BACKUP-1.2.log",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_fk_backup/BACKUP-1-0.2.Data",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_fk_backup/BACKUP-1.1.log",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_fk_backup/BACKUP-1.1.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_fk_backup/BACKUP-1-0.1.Data",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_fk_backup/BACKUP-1.2.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/51_dd/BACKUP-1.2.log",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/51_dd/BACKUP-1-0.2.Data",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/51_dd/BACKUP-1.1.log",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/51_dd/BACKUP-1.1.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/51_dd/BACKUP-1-0.1.Data",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/51_dd/BACKUP-1.2.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/51_data_le/BACKUP-1.2.log",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/51_data_le/BACKUP-1-0.2.Data",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/51_data_le/BACKUP-1.1.log",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/51_data_le/BACKUP-1.1.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/51_data_le/BACKUP-1-0.1.Data",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/51_data_le/BACKUP-1.2.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_large_backup/BACKUP-1.2.log",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_large_backup/BACKUP-1-0.2.Data",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_large_backup/BACKUP-1.1.log",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_large_backup/BACKUP-1.1.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_large_backup/BACKUP-1-0.1.Data",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_large_backup/BACKUP-1.2.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/51_d2_be/BACKUP-1.2.log",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/51_d2_be/BACKUP-1-0.2.Data",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/51_d2_be/BACKUP-1.1.log",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/51_d2_be/BACKUP-1.1.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/51_d2_be/BACKUP-1-0.1.Data",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/51_d2_be/BACKUP-1.2.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/pre_75_partitioning_variants/BACKUP-1.1.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/undo_backup/BACKUP-1-PART-2-OF-4/BACKUP-1.2.log",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/undo_backup/BACKUP-1-PART-2-OF-4/BACKUP-1-0.2.Data",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/undo_backup/BACKUP-1-PART-2-OF-4/BACKUP-1.1.log",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/undo_backup/BACKUP-1-PART-2-OF-4/BACKUP-1.1.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/undo_backup/BACKUP-1-PART-2-OF-4/BACKUP-1-0.1.Data",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/undo_backup/BACKUP-1-PART-2-OF-4/BACKUP-1.2.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/undo_backup/BACKUP-1-PART-1-OF-4/BACKUP-1.2.log",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/undo_backup/BACKUP-1-PART-1-OF-4/BACKUP-1-0.2.Data",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/undo_backup/BACKUP-1-PART-1-OF-4/BACKUP-1.1.log",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/undo_backup/BACKUP-1-PART-1-OF-4/BACKUP-1.1.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/undo_backup/BACKUP-1-PART-1-OF-4/BACKUP-1-0.1.Data",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/undo_backup/BACKUP-1-PART-1-OF-4/BACKUP-1.2.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/undo_backup/BACKUP-1-PART-3-OF-4/BACKUP-1.2.log",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/undo_backup/BACKUP-1-PART-3-OF-4/BACKUP-1-0.2.Data",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/undo_backup/BACKUP-1-PART-3-OF-4/BACKUP-1.1.log",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/undo_backup/BACKUP-1-PART-3-OF-4/BACKUP-1.1.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/undo_backup/BACKUP-1-PART-3-OF-4/BACKUP-1-0.1.Data",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/undo_backup/BACKUP-1-PART-3-OF-4/BACKUP-1.2.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/undo_backup/BACKUP-1-PART-4-OF-4/BACKUP-1.2.log",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/undo_backup/BACKUP-1-PART-4-OF-4/BACKUP-1-0.2.Data",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/undo_backup/BACKUP-1-PART-4-OF-4/BACKUP-1.1.log",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/undo_backup/BACKUP-1-PART-4-OF-4/BACKUP-1.1.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/undo_backup/BACKUP-1-PART-4-OF-4/BACKUP-1-0.1.Data",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/undo_backup/BACKUP-1-PART-4-OF-4/BACKUP-1.2.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/50/BACKUP-2-0.2.Data",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/50/BACKUP-1.2.log",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/50/BACKUP-2.1.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/50/BACKUP-1-0.2.Data",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/50/BACKUP-1.1.log",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/50/BACKUP-1.1.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/50/BACKUP-1-0.1.Data",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/50/BACKUP-2.2.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/50/BACKUP-2.2.log",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/50/BACKUP-2-0.1.Data",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/50/BACKUP-1.2.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/50/BACKUP-2.1.log",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/51/BACKUP-1.2.log",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/51/BACKUP-1-0.2.Data",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/51/BACKUP-1.1.log",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/51/BACKUP-1.1.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/51/BACKUP-1-0.1.Data",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/51/BACKUP-1.2.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/missing_part/BACKUP-1-PART-1-OF-4/BACKUP-1.2.log",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/missing_part/BACKUP-1-PART-1-OF-4/BACKUP-1-0.2.Data",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/missing_part/BACKUP-1-PART-1-OF-4/BACKUP-1.1.log",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/missing_part/BACKUP-1-PART-1-OF-4/BACKUP-1.1.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/missing_part/BACKUP-1-PART-1-OF-4/BACKUP-1-0.1.Data",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/missing_part/BACKUP-1-PART-1-OF-4/BACKUP-1.2.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/missing_part/BACKUP-1-PART-3-OF-4/BACKUP-1.2.log",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/missing_part/BACKUP-1-PART-3-OF-4/BACKUP-1-0.2.Data",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/missing_part/BACKUP-1-PART-3-OF-4/BACKUP-1.1.log",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/missing_part/BACKUP-1-PART-3-OF-4/BACKUP-1.1.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/missing_part/BACKUP-1-PART-3-OF-4/BACKUP-1-0.1.Data",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/missing_part/BACKUP-1-PART-3-OF-4/BACKUP-1.2.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/missing_part/BACKUP-1-PART-4-OF-4/BACKUP-1.2.log",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/missing_part/BACKUP-1-PART-4-OF-4/BACKUP-1-0.2.Data",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/missing_part/BACKUP-1-PART-4-OF-4/BACKUP-1.1.log",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/missing_part/BACKUP-1-PART-4-OF-4/BACKUP-1.1.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/missing_part/BACKUP-1-PART-4-OF-4/BACKUP-1-0.1.Data",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/missing_part/BACKUP-1-PART-4-OF-4/BACKUP-1.2.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/hashmap/BACKUP-1.2.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/wl946_pre/BACKUP-1.2.log",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/wl946_pre/BACKUP-1-0.2.Data",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/wl946_pre/BACKUP-1.1.log",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/wl946_pre/BACKUP-1.1.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/wl946_pre/BACKUP-1-0.1.Data",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/wl946_pre/BACKUP-1.2.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_advanced_backup/BACKUP-1.2.log",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_advanced_backup/BACKUP-1-0.2.Data",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_advanced_backup/BACKUP-1.1.log",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_advanced_backup/BACKUP-1.1.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_advanced_backup/BACKUP-1-0.1.Data",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_advanced_backup/BACKUP-1.2.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/bug17275798/BACKUP-1.21.log",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/bug17275798/BACKUP-1-0.21.Data",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/bug17275798/BACKUP-1.21.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_80_minor/BACKUP-1-PART-2-OF-4/BACKUP-1.2.log",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_80_minor/BACKUP-1-PART-2-OF-4/BACKUP-1-0.2.Data",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_80_minor/BACKUP-1-PART-2-OF-4/BACKUP-1.1.log",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_80_minor/BACKUP-1-PART-2-OF-4/BACKUP-1.1.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_80_minor/BACKUP-1-PART-2-OF-4/BACKUP-1-0.1.Data",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_80_minor/BACKUP-1-PART-2-OF-4/BACKUP-1.2.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_80_minor/BACKUP-1-PART-1-OF-4/BACKUP-1.2.log",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_80_minor/BACKUP-1-PART-1-OF-4/BACKUP-1-0.2.Data",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_80_minor/BACKUP-1-PART-1-OF-4/BACKUP-1.1.log",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_80_minor/BACKUP-1-PART-1-OF-4/BACKUP-1.1.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_80_minor/BACKUP-1-PART-1-OF-4/BACKUP-1-0.1.Data",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_80_minor/BACKUP-1-PART-1-OF-4/BACKUP-1.2.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_80_minor/BACKUP-1-PART-3-OF-4/BACKUP-1.2.log",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_80_minor/BACKUP-1-PART-3-OF-4/BACKUP-1-0.2.Data",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_80_minor/BACKUP-1-PART-3-OF-4/BACKUP-1.1.log",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_80_minor/BACKUP-1-PART-3-OF-4/BACKUP-1.1.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_80_minor/BACKUP-1-PART-3-OF-4/BACKUP-1-0.1.Data",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_80_minor/BACKUP-1-PART-3-OF-4/BACKUP-1.2.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_80_minor/BACKUP-1-PART-4-OF-4/BACKUP-1.2.log",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_80_minor/BACKUP-1-PART-4-OF-4/BACKUP-1-0.2.Data",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_80_minor/BACKUP-1-PART-4-OF-4/BACKUP-1.1.log",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_80_minor/BACKUP-1-PART-4-OF-4/BACKUP-1.1.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_80_minor/BACKUP-1-PART-4-OF-4/BACKUP-1-0.1.Data",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/backups/metadata_upgrade_80_minor/BACKUP-1-PART-4-OF-4/BACKUP-1.2.ctl",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/r/ndb_grant.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/ndb/t/ndb_grant.later",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/perfschema/r/misc.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/perfschema/r/statement_digest_charset.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/perfschema/t/statement_digest_charset.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/innodb_fts/r/fulltext.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/innodb_fts/t/fulltext.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/innodb_fts/t/fulltext_left_join.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/gcol/r/gcol_bugfixes_latin1.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/gcol/t/gcol_bugfixes_latin1.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/rpl_nogtid/t/rpl_row_mysqlbinlog.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/rpl/r/rpl_row_jsondiff_error.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/rpl/r/rpl_charset_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/rpl/r/rpl_charset.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/rpl/r/rpl_secondary_engine_load.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/rpl/r/rpl_set_charset.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/rpl/t/rpl_set_charset.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/rpl/t/rpl_charset_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/binlog/std_data/update-partial-row.binlog",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/binlog/std_data/write-full-row.binlog",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/binlog/std_data/bug32407.001",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/binlog/std_data/write-partial-row.binlog",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/binlog/std_data/ver_trunk_row_v2.001",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/binlog/std_data/bug11747887-bin.000003",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/binlog/std_data/ver_5_1_23.001",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/binlog/std_data/ver_5_1-wl2325_r.001",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/binlog/std_data/update-full-row.binlog",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/binlog/std_data/ver_5_1-wl2325_s.001",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/binlog/r/binlog_table_map_optional_metadata.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/binlog/t/binlog_mysqlbinlog-cp932.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/test_services/include/test_udf_extension_services.inc",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/funcs_1/lib/DataGen_local.pl",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/opt_trace/r/charset.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/opt_trace/t/charset.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/std_data/jisx0208_ucs2.dat",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/std_data/jisx0212_ucs2.dat",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/std_data/jisx0208_sjis2.dat",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/std_data/jisx0201_sjis.dat",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/std_data/jisx0208_ujis.dat",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/std_data/jisx0208_sjis.dat",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/std_data/jisx0208_sjis3.dat",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/std_data/jisx0201_ujis.dat",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/std_data/jisx0212_ujis.dat",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/std_data/jisx0201_ucs2.dat",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/include/trim_sjis.inc",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_rtrim_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_join_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_create_tbl_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_alter_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_join_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_create_db_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_trim_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_join_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_charset_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_create_tbl_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_ps_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_reverse_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_substring_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_insert_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_replace_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_replace_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_trim_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_substring_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_charlength_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_subquery_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_reverse_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_select_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_length_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_where_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_subquery_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_create_db_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_convert_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_insert_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_like_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_union_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_convert_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_right_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_trim_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_reverse_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_substring_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_subquery_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_update_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_alter_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_enum_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_like_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_replace_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_left_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_update_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_instr_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_alter_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_convert_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_length_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_ps_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_like_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_locate_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_charlength_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_rtrim_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_enum_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_right_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_create_db_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_enum_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_lpad_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_charlength_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_left_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_charset_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_rpad_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_left_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_locate_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_charset_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_lpad_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_ltrim_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_select_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_rtrim_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_select_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_where_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_lpad_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_create_tbl_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_update_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_locate_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_instr_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_where_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_rpad_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_instr_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_insert_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_ltrim_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_rpad_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_length_ucs2.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_right_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/r/jp_ltrim_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_rpad_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_ps_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_left_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_alter_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_create_tbl_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_ps_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_charset_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_create_db_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_insert_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_join_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_enum_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_charlength_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_instr_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_update_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_substring_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_subquery_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_reverse_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_locate_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_create_tbl_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_locate_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_create_tbl_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_where_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_insert_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_join_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_union_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_instr_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_substring_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_subquery_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_convert_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_replace_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_like_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_left_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_select_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_enum_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_enum_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_join_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_length_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_insert_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_select_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_length_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_right_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_reverse_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_instr_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_alter_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_convert_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_subquery_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_charlength_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_rtrim_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_charset_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_convert_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_ltrim_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_like_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_where_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_lpad_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_create_db_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_lpad_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_rpad_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_like_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_right_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_locate_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_length_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_right_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_select_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_reverse_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_update_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_left_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_rtrim_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_charset_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_ltrim_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_rpad_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_rtrim_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_ltrim_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_trim_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_where_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_trim_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_replace_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_create_db_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_substring_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_lpad_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_charlength_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_replace_ucs2.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_alter_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/jp/t/jp_update_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/tokudb/r/ctype_collate.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/tokudb/r/ctype_cp1250_ch.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/tokudb/t/ctype_collate.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/tokudb/t/ctype_cp1250_ch.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/binlog_nogtid/std_data/update-partial-row.binlog",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/binlog_nogtid/std_data/write-full-row.binlog",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/binlog_nogtid/std_data/bug32407.001",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/binlog_nogtid/std_data/write-partial-row.binlog",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/binlog_nogtid/std_data/ver_trunk_row_v2.001",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/binlog_nogtid/std_data/bug11747887-bin.000003",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/binlog_nogtid/std_data/ver_5_1_23.001",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/binlog_nogtid/std_data/ver_5_1-wl2325_r.001",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/binlog_nogtid/std_data/update-full-row.binlog",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/binlog_nogtid/std_data/ver_5_1-wl2325_s.001",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/binlog_nogtid/r/binlog_stm_ctype_cp932.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/binlog_nogtid/r/binlog_row_ctype_cp932.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/binlog_nogtid/r/binlog_mysqlbinlog_row_innodb.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/binlog_nogtid/r/binlog_mysqlbinlog_row_myisam.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/binlog_nogtid/r/binlog_mysqlbinlog_row.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/engines/funcs/r/jp_comment_index.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/engines/funcs/r/jp_comment_column.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/engines/funcs/r/jp_comment_table.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/engines/funcs/r/jp_comment_older_compatibility1.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/engines/funcs/t/jp_comment_column.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/engines/funcs/t/jp_comment_older_compatibility1.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/engines/funcs/t/jp_comment_index.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/engines/funcs/t/jp_comment_table.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/engines/iuds/r/type_bit_iuds.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/sys_vars/r/collation_database_func.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/sys_vars/r/character_set_results_func.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/sys_vars/r/collation_server_func.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/sys_vars/r/collation_connection_func.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/sys_vars/r/character_set_connection_basic.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/sys_vars/r/character_set_client_func.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/sys_vars/t/character_set_results_func.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/sys_vars/t/character_set_client_func.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/sys_vars/t/character_set_connection_basic.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/sys_vars/t/collation_database_func.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/sys_vars/t/collation_server_func.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/sys_vars/t/collation_connection_func.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/innodb/r/innodb_bug11789106.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/binlog_gtid/std_data/update-partial-row.binlog",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/binlog_gtid/std_data/write-full-row.binlog",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/binlog_gtid/std_data/bug32407.001",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/binlog_gtid/std_data/write-partial-row.binlog",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/binlog_gtid/std_data/ver_trunk_row_v2.001",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/binlog_gtid/std_data/bug11747887-bin.000003",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/binlog_gtid/std_data/ver_5_1_23.001",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/binlog_gtid/std_data/ver_5_1-wl2325_r.001",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/binlog_gtid/std_data/update-full-row.binlog",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/binlog_gtid/std_data/ver_5_1-wl2325_s.001",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/binlog_gtid/r/binlog_gtid_mysqlbinlog_row_myisam.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/binlog_gtid/r/binlog_gtid_mysqlbinlog_row.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/suite/binlog_gtid/r/binlog_gtid_mysqlbinlog_row_innodb.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/extra/binlog_tests/ctype_cp932.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/extra/rpl_tests/rpl_charset.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/r/ctype_big5.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/r/ctype_ucs.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/r/partition_hash.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/r/ctype_utf8mb4_innodb.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/r/opt_hints.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/r/ctype_utf8mb4_heap.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/r/mysql_cp932.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/r/type_set.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/r/errors.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/r/ctype_collate.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/r/fulltext.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/r/ctype_utf8mb4.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/r/component_string_service_charset.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/r/type_datetime.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/r/mysqldump.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/r/comment_column2.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/r/sp.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/r/ctype_sjis.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/r/cast.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/r/ctype_latin1_de.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/r/csv.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/r/ctype_gb18030_binlog.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/r/lead_lag.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/r/ctype_ujis.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/r/date_formats.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/r/ddl_i18n_koi8r.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/r/binary.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/r/mysqltest.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/r/ps.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/r/ctype_many.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/r/func_like.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/r/ctype_latin2.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/r/ctype_tis620_myisam.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/r/type_decimal.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/r/ctype_latin1.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/r/ctype_utf8mb4_myisam.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/r/log_tables.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/r/ctype_utf8.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/r/ctype_gb18030_encoding_cn.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/r/union.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/r/ctype_recoding.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/r/explain.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/r/parser.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/r/outfile_loaddata.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/r/ctype_cp1250_ch.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/r/events_bugs.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/r/ddl_i18n_utf8.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/r/alter_table.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/r/func_uuid.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/r/type_enum.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/r/show_check_cs.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/r/show_check_ci.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/r/events_1.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/r/varbinary.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/r/func_digest.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/r/grant.result",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/t/type_set.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/t/ctype_big5.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/t/ctype_latin1.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/t/ctype_utf8.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/t/sp.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/t/union.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/t/ctype_ucs.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/t/show_check_cs.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/t/cast.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/t/comment_column2.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/t/parser.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/t/func_like.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/t/ctype_gb18030_binlog.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/t/ctype_ujis.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/t/ctype_gb18030_encoding_cn.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/t/errors.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/t/events_bugs.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/t/binary.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/t/mysql_cp932.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/t/ctype_recoding.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/t/fulltext.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/t/ctype_tis620_myisam.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/t/temptable_dump.sql.gz",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/t/ctype_latin1_de.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/t/events_1.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/t/explain.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/t/opt_hints.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/t/ps.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/t/ctype_collate.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/t/ctype_sjis.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/t/ctype_utf8mb4.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/t/fulltext_left_join.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/t/ddl_i18n_koi8r.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/t/mysqltest.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/t/alter_table.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/t/ctype_many.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/t/ctype_cp1250_ch.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/t/type_decimal.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/t/log_tables.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/t/grant.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/t/ctype_filesystem-master.opt",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/t/ddl_i18n_utf8.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/mysql-test/t/type_enum.test",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/sql/MSG00001.bin",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/doxygen_resources/logo-mysql-110x55.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/doc/source/percona-xtrabackup-logo.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/doc/source/percona-logo.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/doc/source/percona_favicon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/doc/source/percona-xtradb.png",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/doc/source/percona-server-logo.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-percona-server-8.0.20-11-mnjkfv7efdfqlkaopfkau7vb2tnu56co/spack-src/libmysql/authentication_ldap/auth_ldap_kerberos.h"
    ],
    "total_files": 44426
}